language: scala
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val symbolArray = Array(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n\
    \      val powerArray = Array(0, 0, 0, 0, 0, 0, 0)\n      val res = new StringBuilder\n\
    \      var pow = 0\n      var num = number\n      while (num != 0) {\n       \
    \ val digit = num % 10\n        powerArray(pow) = digit\n        pow += 1\n  \
    \      num /= 10\n      }\n      var i = 0\n      while (i < powerArray.length)\
    \ {\n        if (powerArray(i) != 0) {\n          if (powerArray(i) <= 3) {\n\
    \            res.append(symbolArray(i) * powerArray(i))\n          } else if (powerArray(i)\
    \ == 4) {\n            res.append(symbolArray(i))\n            res.append(symbolArray(i\
    \ + 1))\n          } else if (powerArray(i) <= 8) {\n            res.append(symbolArray(i\
    \ + 1))\n            res.append(symbolArray(i) * (powerArray(i) - 5))\n      \
    \    } else {\n            res.append(symbolArray(i))\n            res.append(symbolArray(i\
    \ + 2))\n          }\n        }\n        i += 1\n      }\n      res.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwf303bhx.scala:22:26\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        powerArray(pow) = digit\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       Found:    (digit : Long)\n\e[31m   |\e[0m            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val ones = Array(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\")\n        val tens = Array(\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\")\n        val hundreds = Array(\"\
    \", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n\
    \        val thousands = Array(\"\", \"m\", \"mm\", \"mmm\")\n        var numberString\
    \ = number.toString()\n        var numberMap = Map[Int, Char]()\n        for (i\
    \ <- 0 until numberString.length) {\n            numberMap += (i -> numberString(i))\n\
    \        }\n        var resultString = \"\"\n        if (numberMap.contains(3))\
    \ {\n            resultString += thousands(numberMap(3).asDigit)\n        }\n\
    \        if (numberMap.contains(2)) {\n            resultString += hundreds(numberMap(2).asDigit)\n\
    \        }\n        if (numberMap.contains(1)) {\n            resultString +=\
    \ tens(numberMap(1).asDigit)\n        }\n        if (numberMap.contains(0)) {\n\
    \            resultString += ones(numberMap(0).asDigit)\n        }\n        return\
    \ resultString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqyoplii.scala:40)\n\tat Problem.main(tmpwqyoplii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def getExp(b : Long, ex : Int) : (Long, Int) = {\n            if (b == 0)\
    \ (0, ex)\n            else getExp(b / 10, ex + 1)\n        }\n        def aux(b\
    \ : Long, n : Long, builder : String) : String = {\n            if (n == 0) builder\n\
    \            else {\n                val (digit, exp) = getExp(n, 0)\n       \
    \         val one = pow(10, exp).toLong\n                val five = 5 * one\n\
    \                val ten = 10 * one\n                digit match {\n         \
    \           case 0 => aux(one, n, builder)\n                    case 1 => aux(one,\
    \ n - one, builder + \"i\")\n                    case 2 => aux(one, n - 2 * one,\
    \ builder + \"ii\")\n                    case 3 => aux(one, n - 3 * one, builder\
    \ + \"iii\")\n                    case 4 => aux(one, n - 4 * one, builder + \"\
    iv\")\n                    case 5 => aux(one, n - 5 * one, builder + \"v\")\n\
    \                    case 6 => aux(one, n - 6 * one, builder + \"vi\")\n     \
    \               case 7 => aux(one, n - 7 * one, builder + \"vii\")\n         \
    \           case 8 => aux(one, n - 8 * one, builder + \"viii\")\n            \
    \        case 9 => aux(one, n - 9 * one, builder + \"ix\")\n                }\n\
    \            }\n        }\n        aux(1, number, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010297
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Use a list to hold the roman numeral representation\n        var result\
    \ : List[Char] = Nil\n        // Convert the number to an array of digits\n  \
    \      var digits : Array[Long] = number.toString.map(_.asDigit.toLong).toArray\n\
    \        // If there is no digit in the thousands place, then add one\n      \
    \  if (digits.length < 4) {\n            digits = Array(0l) ++ digits\n      \
    \  }\n        // Loop over the digits array\n        for (digit <- digits) {\n\
    \            // Get the digit's roman numeral representation\n            val\
    \ digitRoman : List[Char] = digit match {\n                case 0 => Nil\n   \
    \             case 1 => List('i')\n                case 2 => List('i', 'i')\n\
    \                case 3 => List('i', 'i', 'i')\n                case 4 => List('i',\
    \ 'v')\n                case 5 => List('v')\n                case 6 => List('v',\
    \ 'i')\n                case 7 => List('v', 'i', 'i')\n                case 8\
    \ => List('v', 'i', 'i', 'i')\n                case 9 => List('i', 'x')\n    \
    \        }\n            // Add the representation to the front of the roman numeral\
    \ list\n            result = digitRoman ++ result\n        }\n        // Return\
    \ the roman numeral representation as a string\n        result.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqu_j0vly.scala:45)\n\tat Problem.main(tmpqu_j0vly.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     return number.toString.map(c => (c.toInt - 48).toChar).mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb0r4tat7.scala:18)\n\tat Problem.main(tmpb0r4tat7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def digitToRoman(digit : Long, roman : String) : String = {\n          \
    \  if (digit == 9) return \"ix\" + roman\n            if (digit == 4) return \"\
    iv\" + roman\n            var res = \"\"\n            if (digit >= 5) {\n    \
    \            res += \"v\"\n                digit -= 5\n            }\n       \
    \     while (digit > 0) {\n                res += \"i\"\n                digit\
    \ -= 1\n            }\n            res + roman\n        }\n        def run(num\
    \ : Long, roman : String) : String = {\n            if (num == 0) return roman\n\
    \            val digit = num % 10\n            run(num / 10, digitToRoman(digit,\
    \ roman))\n        }\n        run(number, \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjf_6dnzo.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                digit -= \e[31m5\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m               value -=\
    \ is not a member of Long - did you mean digit.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpjf_6dnzo.scala:25:22 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                digit -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m               value -= is not a\
    \ member of Long - did you mean digit.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Map( 1l -> \"i\",\n                            5l -> \"v\"\
    ,\n                            10l -> \"x\",\n                            50l\
    \ -> \"l\",\n                            100l -> \"c\",\n                    \
    \        500l -> \"d\",\n                            1000l -> \"m\")\n       \
    \ def numeral(n : Long) : String = {\n            if (numerals.contains(n))\n\
    \                numerals(n)\n            else if (n > 1000)\n               \
    \ numeral(1000) + numeral(n - 1000)\n            else if (n == 9l * numerals.keys.toSeq.sorted.reverse(5))\n\
    \                numeral(numerals.keys.toSeq.sorted.reverse(4)) + numeral(numerals.keys.toSeq.sorted.reverse(6))\n\
    \            else if (n == 4l * numerals.keys.toSeq.sorted.reverse(5))\n     \
    \           numeral(numerals.keys.toSeq.sorted.reverse(4)) + numeral(numerals.keys.toSeq.sorted.reverse(5))\n\
    \            else if (n > numerals.keys.toSeq.sorted.reverse(5))\n           \
    \     numeral(numerals.keys.toSeq.sorted.reverse(5)) + numeral(n - numerals.keys.toSeq.sorted.reverse(5))\n\
    \            else if (n == 9l * numerals.keys.toSeq.sorted.reverse(4))\n     \
    \           numeral(numerals.keys.toSeq.sorted.reverse(3)) + numeral(numerals.keys.toSeq.sorted.reverse(5))\n\
    \            else if (n == 4l * numerals.keys.toSeq.sorted.reverse(4))\n     \
    \           numeral(numerals.keys.toSeq.sorted.reverse(3)) + numeral(numerals.keys.toSeq.sorted.reverse(4))\n\
    \            else if (n > numerals.keys.toSeq.sorted.reverse(4))\n           \
    \     numeral(numerals.keys.toSeq.sorted.reverse(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbi5gyee3.scala:38:59 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                numeral(numerals.keys.toSeq.sorted.reverse(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpbi5gyee3.scala:58:0 ----------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbi5gyee3.scala:57:1 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpbi5gyee3.scala:40:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m40 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tval ones = Array(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\")\n    \tval tens = Array(\"\", \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\")\n    \tval hundreds = Array(\"\",\
    \ \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n\
    \    \tval thousands = Array(\"\", \"m\", \"mm\", \"mmm\")\n    \tval digits =\
    \ number.toString.map(x => x.asDigit).toArray\n    \t(thousands(digits(3)) + hundreds(digits(2))\
    \ + tens(digits(1)) + ones(digits(0))).toLowerCase\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length\
    \ 2\n\tat Problem$.intToMiniRoman(tmp28y0wxq3.scala:20)\n\tat Problem$.main(tmp28y0wxq3.scala:23)\n\
    \tat Problem.main(tmp28y0wxq3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010294
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var answer = \"\"\n        var remainder = number\n        var i = 0\n \
    \       val pairs = List((1000l, \"m\"), (900l, \"cm\"), (500l, \"d\"), (400l,\
    \ \"cd\"), (100l, \"c\"), (90l, \"xc\"), (50l, \"l\"), (40l, \"xl\"), (10l, \"\
    x\"), (9l, \"ix\"), (5l, \"v\"), (4l, \"iv\"), (1l, \"i\"))\n        for (pair\
    \ <- pairs) {\n            val (value, letter) = pair\n            while (remainder\
    \ >= value) {\n                remainder -= value\n                answer += letter\n\
    \            }\n        }\n        answer\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010293
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder\n        var rem = number\n        val rep\
    \ = List(\n            ('m', 1000),\n            ('d', 500),\n            ('c',\
    \ 100),\n            ('l', 50),\n            ('x', 10),\n            ('v', 5),\n\
    \            ('i', 1)\n        )\n        while (rem > 0) {\n            var (key,\
    \ num) = rep.filter(x => x._2 <= rem).head\n            result.append(key)\n \
    \           rem -= num\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzijwdcxa.scala:34)\n\tat Problem.main(tmpzijwdcxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val ints = Array(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n\
    \        val nums = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\",\
    \ \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val roman = new StringBuilder()\n\
    \        var remainder = number\n        for (i <- 0 until ints.length) {\n  \
    \          while (remainder >= ints(i)) {\n                roman.append(nums(i))\n\
    \                remainder -= ints(i)\n            }\n        }\n        roman.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        var miniRomanNumerals = new StringBuilder\n    \
    \    while (n >= 1000) {\n            miniRomanNumerals += \"m\"\n           \
    \ n -= 1000\n        }\n        while (n >= 900) {\n            miniRomanNumerals\
    \ += \"cm\"\n            n -= 900\n        }\n        while (n >= 500) {\n   \
    \         miniRomanNumerals += \"d\"\n            n -= 500\n        }\n      \
    \  while (n >= 400) {\n            miniRomanNumerals += \"cd\"\n            n\
    \ -= 400\n        }\n        while (n >= 100) {\n            miniRomanNumerals\
    \ += \"c\"\n            n -= 100\n        }\n        while (n >= 90) {\n     \
    \       miniRomanNumerals += \"xc\"\n            n -= 90\n        }\n        while\
    \ (n >= 50) {\n            miniRomanNumerals += \"l\"\n            n -= 50\n \
    \       }\n        while (n >= 40) {\n            miniRomanNumerals += \"xl\"\n\
    \            n -= 40\n        }\n        while (n >= 10) {\n            miniRomanNumerals\
    \ += \"x\"\n            n -= 10\n        }\n        while (n >= 9) {\n       \
    \     miniRomanNumerals += \"ix\"\n            n -= 9\n        }\n        while\
    \ (n >= 5) {\n            miniRomanNumerals += \"v\"\n            n -= 5\n   \
    \     }\n        while (n >= 4) {\n            miniRomanNumerals += \"iv\"\n \
    \           n -= 4\n        }\n        while (n >= 1) {\n            miniRomanNumerals\
    \ += \"i\"\n            n -= 1\n        }\n        miniRomanNumerals.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7knwqdda.scala:18:33\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            miniRomanNumerals\
    \ += \e[31m\"m\"\e[0m\n\e[31m\e[31m   |\e[0m                                 ^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (\e[32m\"m\"\e\
    [0m : String)\n\e[31m   |\e[0m                                 Required: Char\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7knwqdda.scala:22:33\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            miniRomanNumerals\
    \ += \e[31m\"cm\"\e[0m\n\e[31m\e[31m   |\e[0m                                \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (\e[32m\"\
    cm\"\e[0m : String)\n\e[31m   |\e[0m                                 Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7knwqdda.scala:26:33\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            miniRomanNumerals\
    \ += \e[31m\"d\"\e[0m\n\e[31m\e[31m   |\e[0m                                 ^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (\e[32m\"d\"\e\
    [0m : String)\n\e[31m   |\e[0m                                 Required: Char\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7knwqdda.scala:30:33\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            miniRomanNumerals\
    \ += \e[31m\"cd\"\e[0m\n\e[31m\e[31m   |\e[0m                                \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (\e[32m\"\
    cd\"\e[0m : String)\n\e[31m   |\e[0m                                 Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7knwqdda.scala:34:33\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            miniRomanNumerals\
    \ += \e[31m\"c\"\e[0m\n\e[31m\e[31m   |\e[0m                                 ^^^\e\
    [0m\n\e[31m   |\e[0m                            "
  stdout: ''
  timestamp: 1660010293
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var numberCopy = number\n        val strings = new ListBuffer[String]\n\
    \        while (numberCopy > 0) {\n            if (numberCopy - 1000 >= 0) {\n\
    \                strings += \"m\"\n                numberCopy -= 1000\n      \
    \      } else if (numberCopy - 900 >= 0) {\n                strings += \"cm\"\n\
    \                numberCopy -= 900\n            } else if (numberCopy - 500 >=\
    \ 0) {\n                strings += \"d\"\n                numberCopy -= 500\n\
    \            } else if (numberCopy - 400 >= 0) {\n                strings += \"\
    cd\"\n                numberCopy -= 400\n            } else if (numberCopy - 100\
    \ >= 0) {\n                strings += \"c\"\n                numberCopy -= 100\n\
    \            } else if (numberCopy - 90 >= 0) {\n                strings += \"\
    xc\"\n                numberCopy -= 90\n            } else if (numberCopy - 50\
    \ >= 0) {\n                strings += \"l\"\n                numberCopy -= 50\n\
    \            } else if (numberCopy - 40 >= 0) {\n                strings += \"\
    xl\"\n                numberCopy -= 40\n            } else if (numberCopy - 10\
    \ >= 0) {\n                strings += \"x\"\n                numberCopy -= 10\n\
    \            } else if (numberCopy - 9 >= 0) {\n                strings += \"\
    ix\"\n                numberCopy -= 9\n            } else if (numberCopy - 5 >=\
    \ 0) {\n                strings += \"v\"\n                numberCopy -= 5\n  \
    \          } else if (numberCopy - 4 >= 0) {\n                strings += \"iv\"\
    \n                numberCopy -= 4\n            } else if (numberCopy - 1 >= 0)\
    \ {\n                strings += \"i\"\n                numberCopy -= 1\n     \
    \       }\n        }\n        strings.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Map('m' -> 1000, 'd' -> 500, 'c' -> 100, 'l' -> 50, 'x' ->\
    \ 10, 'v' -> 5, 'i' -> 1)\n        var result = \"\"\n        var current = number\n\
    \        for ((numeral, value) <- numerals) {\n            val count = current\
    \ / value\n            if (count > 0) {\n                if (count == 4) {\n \
    \                   result += numerals.keys.toList(numerals.keys.toList.indexOf(numeral)\
    \ - 1)\n                    result += numeral\n                } else {\n    \
    \                for (i <- 1 to count) {\n                        result += numeral\n\
    \                    }\n                }\n            }\n            current\
    \ %= value\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps555xgbv.scala:25:35\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mfor\e\
    [0m (i <- \e[31m1\e[0m to count) {\n\e[31m\e[31m   |\e[0m                    \
    \               ^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \ Found:    (count : Long)\n\e[31m   |\e[0m                                  \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0) throw new Exception(\"invalid input\")\n        if (number\
    \ > 1000) throw new Exception(\"invalid input\")\n        val M = 1000\n     \
    \   val CM = 900\n        val D = 500\n        val CD = 400\n        val C = 100\n\
    \        val XC = 90\n        val L = 50\n        val XL = 40\n        val X =\
    \ 10\n        val IX = 9\n        val V = 5\n        val IV = 4\n        val I\
    \ = 1\n        val numerals = Array[(Int, String)]((M, \"m\"), (CM, \"cm\"), (D,\
    \ \"d\"), (CD, \"cd\"), (C, \"c\"), (XC, \"xc\"), (L, \"l\"), (XL, \"xl\"), (X,\
    \ \"x\"), (IX, \"ix\"), (V, \"v\"), (IV, \"iv\"), (I, \"i\"))\n        var res\
    \ = \"\"\n        var num = number\n        while (num > 0) {\n            for\
    \ (i <- 0 until numerals.length) {\n                if (num >= numerals(i)._1)\
    \ {\n                    res += numerals(i)._2\n                    num -= numerals(i)._1\n\
    \                    break\n                }\n            }\n        }\n    \
    \    res\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpumfdrk_g.scala:38:20 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def toStr(n : Long, str : String) : String = {\n            if (n == 0)\
    \ str\n            else if (n == 4) str + \"iv\"\n            else if (n == 9)\
    \ str + \"ix\"\n            else if (n >= 5) toStr(n - 5, str + \"v\")\n     \
    \       else toStr(n - 1, str + \"i\")\n        }\n        def toStr2(n : Long,\
    \ str : String) : String = {\n            if (n == 0) str\n            else if\
    \ (n == 4) str + \"xl\"\n            else if (n == 9) str + \"xc\"\n         \
    \   else if (n >= 5) toStr2(n - 5, str + \"l\")\n            else toStr2(n - 1,\
    \ str + \"x\")\n        }\n        def toStr3(n : Long, str : String) : String\
    \ = {\n            if (n == 0) str\n            else if (n == 4) str + \"cd\"\n\
    \            else if (n == 9) str + \"cm\"\n            else if (n >= 5) toStr3(n\
    \ - 5, str + \"d\")\n            else toStr3(n - 1, str + \"c\")\n        }\n\
    \        def toStr4(n : Long, str : String) : String = {\n            if (n ==\
    \ 0) str\n            else if (n == 4) str + \"mv\"\n            else if (n ==\
    \ 9) str + \"mx\"\n            else if (n >= 5) toStr4(n - 5, str + \"v\")\n \
    \           else toStr4(n - 1, str + \"m\")\n        }\n        val m = number\
    \ % 1000; val thousands = (number - m) / 1000\n        val h = m % 100; val hundreds\
    \ = (m - h) / 100\n        val t = h % 10; val tens = (h - t) / 10\n        val\
    \ u = t % 1; val units = (t - u) / 1\n        val unitStr = toStr(units, \"\"\
    )\n        val tenStr = toStr2(tens, \"\")\n        val hundredStr = toStr3(hundreds,\
    \ \"\")\n        val thousandStr =\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwjvj0lkb.scala:50:25 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mthousandStr\e[0m =\n\e[31m\e\
    [31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwjvj0lkb.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var result = \"\"\n        while (num > 0) {\n\
    \            if (num >= 1000) {\n                result += \"m\"\n           \
    \     num -= 1000\n            } else if (num >= 900) {\n                result\
    \ += \"cm\"\n                num -= 900\n            } else if (num >= 500) {\n\
    \                result += \"d\"\n                num -= 500\n            } else\
    \ if (num >= 400) {\n                result += \"cd\"\n                num -=\
    \ 400\n            } else if (num >= 100) {\n                result += \"c\"\n\
    \                num -= 100\n            } else if (num >= 90) {\n           \
    \     result += \"xc\"\n                num -= 90\n            } else if (num\
    \ >= 50) {\n                result += \"l\"\n                num -= 50\n     \
    \       } else if (num >= 40) {\n                result += \"xl\"\n          \
    \      num -= 40\n            } else if (num >= 10) {\n                result\
    \ += \"x\"\n                num -= 10\n            } else if (num >= 9) {\n  \
    \              result += \"ix\"\n                num -= 9\n            } else\
    \ if (num >= 5) {\n                result += \"v\"\n                num -= 5\n\
    \            } else if (num >= 4) {\n                result += \"iv\"\n      \
    \          num -= 4\n            } else if (num >= 1) {\n                result\
    \ += \"i\"\n                num -= 1\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010293
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val lookup = Array((\"m\", 1000), (\"cm\", 900), (\"d\", 500), (\"cd\",\
    \ 400), (\"c\", 100), (\"xc\", 90), (\"l\", 50), (\"xl\", 40), (\"x\", 10), (\"\
    ix\", 9), (\"v\", 5), (\"iv\", 4), (\"i\", 1))\n        def helper(n : Long, lookup\
    \ : Array[(String, Int)], roman : String) : String = {\n            if (n == 0)\
    \ return roman\n            val index = lookup.indexWhere(_._2 <= n)\n       \
    \     val (s, num) = lookup(index)\n            helper(n - num, lookup, roman\
    \ + s)\n        }\n        helper(number, lookup, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   require(number > 0 && number <= 1000, \"Input must be between 1 and 1000\"\
    )\n      var num = number\n      var romans = new StringBuilder\n      while (num\
    \ > 0) {\n        if (num >= 1000) {\n          romans += 'm'\n          num -=\
    \ 1000\n        } else if (num >= 900) {\n          romans += \"cm\"\n       \
    \   num -= 900\n        } else if (num >= 500) {\n          romans += 'd'\n  \
    \        num -= 500\n        } else if (num >= 400) {\n          romans += \"\
    cd\"\n          num -= 400\n        } else if (num >= 100) {\n          romans\
    \ += 'c'\n          num -= 100\n        } else if (num >= 90) {\n          romans\
    \ += \"xc\"\n          num -= 90\n        } else if (num >= 50) {\n          romans\
    \ += 'l'\n          num -= 50\n        } else if (num >= 40) {\n          romans\
    \ += \"xl\"\n          num -= 40\n        } else if (num >= 10) {\n          romans\
    \ += 'x'\n          num -= 10\n        } else if (num >= 9) {\n          romans\
    \ += \"ix\"\n          num -= 9\n        } else if (num >= 5) {\n          romans\
    \ += 'v'\n          num -= 5\n        } else if (num >= 4) {\n          romans\
    \ += \"iv\"\n          num -= 4\n        } else if (num >= 1) {\n          romans\
    \ += 'i'\n          num -= 1\n        }\n      }\n      romans.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9fd26um.scala:23:20\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m          romans += \e[31m\"\
    cm\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Found:    (\e[32m\"cm\"\e[0m : String)\n\e[31m   |\e[0m \
    \                   Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj9fd26um.scala:29:20 --------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m          romans += \e[31m\"cd\"\e[0m\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                    Found:    (\e[32m\"\
    cd\"\e[0m : String)\n\e[31m   |\e[0m                    Required: Char\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9fd26um.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m          romans += \e[31m\"xc\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    (\e[32m\"xc\"\e[0m : String)\n\e[31m   |\e[0m                    Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9fd26um.scala:41:20\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m          romans += \e[31m\"\
    xl\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Found:    (\e[32m\"xl\"\e[0m : String)\n\e[31m   |\e[0m \
    \                   Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj9fd26um.scala:47:20 --------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m          romans += \e[31m\"ix\"\e[0m\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                    Found:    (\e[32m\"\
    ix\"\e[0m : String)\n\e[31m   |\e[0m                    Required: Char\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9fd26um.scala"
  stdout: ''
  timestamp: 1660010293
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val base = Array(1000, 500, 100, 50, 10, 5, 1)\n        val letters = Array('m',\
    \ 'd', 'c', 'l', 'x', 'v', 'i')\n        var result = new StringBuilder\n    \
    \    var n = number\n        var i = 0\n        while (n > 0) {\n            var\
    \ count = n / base(i)\n            if (count == 4 && i % 2 == 0) {\n         \
    \       result.append(letters(i + 1))\n                result.append(letters(i\
    \ - 1))\n            } else if (count == 4) {\n                result.append(letters(i\
    \ + 1))\n                result.append(letters(i - 1))\n            } else {\n\
    \                while (count > 0) {\n                    result.append(letters(i))\n\
    \                    count -= 1\n                }\n            }\n          \
    \  n %= base(i)\n            i += 1\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length\
    \ 7\n\tat Problem$.intToMiniRoman(tmpa90cv4uz.scala:23)\n\tat Problem$.main(tmpa90cv4uz.scala:40)\n\
    \tat Problem.main(tmpa90cv4uz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     //StringBuilder is used because it is faster when appending characters to\
    \ the string,\n        //than the String.concat method.\n        val sb = new\
    \ StringBuilder\n        // Making a list of tuples with roman numbers,\n    \
    \    // and their corresponding values.\n        val romanNumber = List(\n   \
    \         (\"i\", 1),\n            (\"v\", 5),\n            (\"x\", 10),\n   \
    \         (\"l\", 50),\n            (\"c\", 100),\n            (\"d\", 500),\n\
    \            (\"m\", 1000)\n        )\n        // Sorting the list to decrementing\
    \ values.\n        val romanNumberSorted = romanNumber.sortWith(_._2 > _._2)\n\
    \        // Defining a helper function to convert the number to mini roman.\n\
    \        def calculateMiniRoman(number : Long, romanNumberSorted : List[(String,\
    \ Int)]) : String = {\n            if (number == 0) {\n                // Returning\
    \ an empty string if the number is 0,\n                // because this number\
    \ cannot be represented in roman numerals.\n                \"\"\n           \
    \ } else {\n                // Building the string recursively.\n            \
    \    val current = romanNumberSorted.head\n                // Getting the number\
    \ of times the current number will be in the string.\n                val numberOfOccurrences\
    \ = number / current._2\n                // Appending the number of occurrences\
    \ to the string.\n                sb.append(current._1 * numberOfOccurrences)\n\
    \                // Finding the remaining number to convert.\n               \
    \ val remaining = number % current._2\n                // Recursively calling\
    \ the function with the current roman number stripped from the list,\n       \
    \         // and the remaining number to convert.\n                calculateMiniRoman(remaining,\
    \ romanNumberSorted.tail)\n            }\n        }\n        // Calling the helper\
    \ function to obtain the final string.\n        calculateMiniRoman(number, romanNumberSorted)\n\
    \        // Converting the final string to lowercase.\n        sb.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8p0wt44m.scala:43:39\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m                sb.append(current._1\
    \ * numberOfOccurrences)\n\e[31m\e[31m   |\e[0m                              \
    \         ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \        Found:    (numberOfOccurrences : Long)\n\e[31m   |\e[0m             \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010292
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var result = \"\"\n        while (num >= 1000)\
    \ {\n            result += \"m\"\n            num -= 1000\n        }\n       \
    \ while (num >= 900) {\n            result += \"cm\"\n            num -= 900\n\
    \        }\n        while (num >= 500) {\n            result += \"d\"\n      \
    \      num -= 500\n        }\n        while (num >= 400) {\n            result\
    \ += \"cd\"\n            num -= 400\n        }\n        while (num >= 100) {\n\
    \            result += \"c\"\n            num -= 100\n        }\n        while\
    \ (num >= 90) {\n            result += \"xc\"\n            num -= 90\n       \
    \ }\n        while (num >= 50) {\n            result += \"l\"\n            num\
    \ -= 50\n        }\n        while (num >= 40) {\n            result += \"xl\"\n\
    \            num -= 40\n        }\n        while (num >= 10) {\n            result\
    \ += \"x\"\n            num -= 10\n        }\n        while (num >= 9) {\n   \
    \         result += \"ix\"\n            num -= 9\n        }\n        while (num\
    \ >= 5) {\n            result += \"v\"\n            num -= 5\n        }\n    \
    \    while (num >= 4) {\n            result += \"iv\"\n            num -= 4\n\
    \        }\n        while (num >= 1) {\n            result += \"i\"\n        \
    \    num -= 1\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"\
    number must be in [1, 1000]\")\n        }\n        var remaining = number\n  \
    \      var result = new StringBuilder\n        var i = -1\n        while (remaining\
    \ > 0) {\n            i += 1\n            val currentDigit = remaining % 10\n\
    \            if (currentDigit == 0) {\n                remaining /= 10\n     \
    \           continue\n            }\n            val romanDigit = i match {\n\
    \                case 0 => {\n                    currentDigit match {\n     \
    \                   case 1 => 'i'\n                        case 2 => 'ii'\n  \
    \                      case 3 => 'iii'\n                        case 4 => 'iv'\n\
    \                        case 5 => 'v'\n                        case 6 => 'vi'\n\
    \                        case 7 => 'vii'\n                        case 8 => 'viii'\n\
    \                        case 9 => 'ix'\n                    }\n             \
    \   }\n                case 1 => {\n                    currentDigit match {\n\
    \                        case 1 => 'x'\n                        case 2 => 'xx'\n\
    \                        case 3 => 'xxx'\n                        case 4 => 'xl'\n\
    \                        case 5 => 'l'\n                        case 6 => 'lx'\n\
    \                        case 7 => 'lxx'\n                        case 8 => 'lxxx'\n\
    \                        case 9 => 'xc'\n                    }\n             \
    \   }\n                case 2 => {\n                    currentDigit match {\n\
    \                        case 1 => 'c'\n                        case 2 => 'cc'\n\
    \                        case 3 => 'ccc'\n                        case 4 => 'cd'\n\
    \                        case 5 => 'd'\n                        case 6 => 'dc'\n\
    \                        case 7 => 'dcc'\n                        case 8 => 'dccc'\n\
    \                        case 9 => 'cm'\n                    }\n             \
    \   }\n                case 3 => {\n                    currentDigit match {\n\
    \                        case 1 => 'm'\n                        case 2 => 'mm'\n\
    \                        case 3 => 'mmm'\n                    }\n            \
    \    }\n            }\n            result = result.append(romanDigit)\n      \
    \      remaining /= 10\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:32:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        \e[33mcase\e[0m \e[31m2\e[0m\
    \ => \e[31m'ii\e[0m'\n\e[31m\e[31m   |\e[0m                                  \
    \   ^\e[0m\n\e[31m   |\e[0m                                     unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:33:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        \e[33mcase\e[0m \e[31m3\e[0m\
    \ => \e[31m'iii\e[0m'\n\e[31m\e[31m   |\e[0m                                 \
    \     ^\e[0m\n\e[31m   |\e[0m                                      unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:34:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        \e[33mcase\e[0m \e[31m4\e[0m\
    \ => \e[31m'iv\e[0m'\n\e[31m\e[31m   |\e[0m                                  \
    \   ^\e[0m\n\e[31m   |\e[0m                                     unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:36:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                        \e[33mcase\e[0m \e[31m6\e[0m\
    \ => \e[31m'vi\e[0m'\n\e[31m\e[31m   |\e[0m                                  \
    \   ^\e[0m\n\e[31m   |\e[0m                                     unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:37:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        \e[33mcase\e[0m \e[31m7\e[0m\
    \ => \e[31m'vii\e[0m'\n\e[31m\e[31m   |\e[0m                                 \
    \     ^\e[0m\n\e[31m   |\e[0m                                      unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:38:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                        \e[33mcase\e[0m \e[31m8\e[0m\
    \ => \e[31m'viii\e[0m'\n\e[31m\e[31m   |\e[0m                                \
    \       ^\e[0m\n\e[31m   |\e[0m                                       unclosed\
    \ character literal\n\e[31m\e[31m-- Error: /tmp/tmpytcfo0p6.scala:39:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                        \e[33"
  stdout: ''
  timestamp: 1660010290
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = \"ivxlcdm\"\n        var str = \"\"\n        var num = number\n\
    \        for (i <- 0 to 5) {\n            val digit = (num % 10).toInt\n     \
    \       num /= 10\n            val symbol = symbols(i)\n            val nextSymbol\
    \ = symbols(i + 1)\n            digit match {\n                case 1 => str =\
    \ symbol + str\n                case 2 => str = symbol + symbol + str\n      \
    \          case 3 => str = symbol + symbol + symbol + str\n                case\
    \ 4 => str = symbol + nextSymbol + str\n                case 5 => str = nextSymbol\
    \ + str\n                case 6 => str = nextSymbol + symbol + str\n         \
    \       case 7 => str = nextSymbol + symbol + symbol + str\n                case\
    \ 8 => str = nextSymbol + symbol + symbol + symbol + str\n                case\
    \ 9 => str = symbols(i) + symbols(i + 2) + str\n                case _ =>\n  \
    \          }\n        }\n        str\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphw2pfu3o.scala:39)\n\tat Problem.main(tmphw2pfu3o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Here is an explanation of the algorithm used below:\n        // 1. The\
    \ first for loop creates a list of every roman numeral in the range 1 <= num <=\
    \ 1000\n        // 2. The next line maps that list from roman numerals to positive\
    \ integers\n        // 3. The next line creates a list of all the positive integers\
    \ in the range 1 <= num <= 1000\n        // 4. The final line creates a list of\
    \ the respective indices of each integer in the first line,\n        //    in\
    \ the integer list of the third line.\n        // So, what this all means is that\
    \ we can use the number to index into this integer list,\n        // and obtain\
    \ the index of the number in the string list.\n        // That gives us the roman\
    \ numeral, in lowercase.\n        List(\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\").zipWithIndex.filter(_._1.size\
    \ == 1).map(_._2)((List(1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000).indexOf(number)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmfi8d6v9.scala:24:129\
    \ -------------------\e[0m\e[0m\n\e[31m24 |\e[0m        List(\e[31m\"i\"\e[0m,\
    \ \e[31m\"iv\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"ix\"\e[0m, \e[31m\"x\"\e[0m, \e\
    [31m\"xl\"\e[0m, \e[31m\"l\"\e[0m, \e[31m\"xc\"\e[0m, \e[31m\"c\"\e[0m, \e[31m\"\
    cd\"\e[0m, \e[31m\"d\"\e[0m, \e[31m\"cm\"\e[0m, \e[31m\"m\"\e[0m).zipWithIndex.filter(_._1.size\
    \ == \e[31m1\e[0m).map(_._2)((List(\e[31m1\e[0m, \e[31m4\e[0m, \e[31m5\e[0m, \e\
    [31m9\e[0m, \e[31m10\e[0m, \e[31m40\e[0m, \e[31m50\e[0m, \e[31m90\e[0m, \e[31m100\e\
    [0m, \e[31m400\e[0m, \e[31m500\e[0m, \e[31m900\e[0m, \e[31m1000\e[0m).indexOf(number)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010299
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var buffer = new StringBuilder\n        var quotient = number\n        while\
    \ (quotient >= 1000) {\n            buffer ++= \"m\"\n            quotient -=\
    \ 1000\n        }\n        if (quotient >= 900) {\n            buffer ++= \"cm\"\
    \n            quotient -= 900\n        }\n        if (quotient >= 500) {\n   \
    \         buffer ++= \"d\"\n            quotient -= 500\n        }\n        if\
    \ (quotient >= 400) {\n            buffer ++= \"cd\"\n            quotient -=\
    \ 400\n        }\n        while (quotient >= 100) {\n            buffer ++= \"\
    c\"\n            quotient -= 100\n        }\n        if (quotient >= 90) {\n \
    \           buffer ++= \"xc\"\n            quotient -= 90\n        }\n       \
    \ if (quotient >= 50) {\n            buffer ++= \"l\"\n            quotient -=\
    \ 50\n        }\n        if (quotient >= 40) {\n            buffer ++= \"xl\"\n\
    \            quotient -= 40\n        }\n        while (quotient >= 10) {\n   \
    \         buffer ++= \"x\"\n            quotient -= 10\n        }\n        if\
    \ (quotient >= 9) {\n            buffer ++= \"ix\"\n            quotient -= 9\n\
    \        }\n        if (quotient >= 5) {\n            buffer ++= \"v\"\n     \
    \       quotient -= 5\n        }\n        if (quotient >= 4) {\n            buffer\
    \ ++= \"iv\"\n            quotient -= 4\n        }\n        while (quotient >=\
    \ 1) {\n            buffer ++= \"i\"\n            quotient -= 1\n        }\n \
    \       buffer.toString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var current = number\n        var result = new StringBuilder\n        var\
    \ baseNum = 0\n        var base = 0\n        var symbols = Array(\"i\", \"v\"\
    , \"x\", \"l\", \"c\", \"d\", \"m\")\n        while (current > 0) {\n        \
    \    baseNum = current % 10\n            base = 2 * (current.toString.length -\
    \ 1)\n            if (baseNum < 4) {\n                for (i <- 1 to baseNum)\
    \ result.append(symbols(base))\n            } else if (baseNum == 4) {\n     \
    \           result.append(symbols(base + 1))\n                result.append(symbols(base))\n\
    \            } else if (baseNum == 5) {\n                result.append(symbols(base\
    \ + 1))\n            } else if (baseNum < 9) {\n                result.append(symbols(base))\n\
    \                for (i <- 1 to baseNum - 5) result.append(symbols(base + 1))\n\
    \            } else {\n                result.append(symbols(base + 2))\n    \
    \            result.append(symbols(base))\n            }\n            current\
    \ /= 10\n        }\n        result.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwbmijxdt.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            baseNum = current\
    \ % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m         \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val (symbols, values) = (List(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\",\
    \ \"m\"), List(1, 5, 10, 50, 100, 500, 1000))\n        def extract(number : Long,\
    \ factor : Int) : (String, Long) = {\n            val digit = (number / factor)\
    \ % 10\n            val (oneSymbol, fiveSymbol, tenSymbol) = (symbols(2 * factor),\
    \ symbols(2 * factor + 1), symbols(2 * factor + 2))\n            if (digit ==\
    \ 9)\n                (oneSymbol + tenSymbol, number - (9 * factor))\n       \
    \     else if (digit >= 5)\n                (fiveSymbol + oneSymbol * (digit -\
    \ 5), number - (digit * factor))\n            else if (digit == 4)\n         \
    \       (oneSymbol + fiveSymbol, number - (4 * factor))\n            else\n  \
    \              (oneSymbol * digit, number - (digit * factor))\n        }\n   \
    \     var (roman, value) = (\"\", number)\n        for (factor <- values.size\
    \ - 1 to 0 by -1) {\n            val (romanPart, valuePart) = extract(value, values(factor))\n\
    \            roman += romanPart\n            value = valuePart\n        }\n  \
    \      roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrci9w_p.scala:22:43\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                (fiveSymbol +\
    \ oneSymbol * (digit - \e[31m5\e[0m), number - (digit * factor))\n\e[31m\e[31m\
    \   |\e[0m                                           ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                           Found:    Long\n\e[31m   |\e\
    [0m                                           Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrci9w_p.scala:26:29 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                (oneSymbol * digit, number - (digit *\
    \ factor))\n\e[31m\e[31m   |\e[0m                             ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Found:    (digit : Long)\n\e[31m   |\e\
    [0m                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = List((\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\
    \ (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40), (\"X\", 10), (\"IX\"\
    , 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1))\n        val remain = ListBuffer(number)\n\
    \        var result = new StringBuilder()\n        for ((s, n) <- romans) {\n\
    \            while (remain(0) >= n) {\n                remain(0) -= n\n      \
    \          result.append(s)\n            }\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphdqugjsz.scala:27)\n\tat Problem.main(tmphdqugjsz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        if (n < 1 || n > 1000) throw new Exception(\"number\
    \ out of range\")\n        var m = Map[Long, String]()\n        m += (1 -> \"\
    i\")\n        m += (5 -> \"v\")\n        m += (10 -> \"x\")\n        m += (50\
    \ -> \"l\")\n        m += (100 -> \"c\")\n        m += (500 -> \"d\")\n      \
    \  m += (1000 -> \"m\")\n        var result = \"\"\n        while (n > 0) {\n\
    \            var v = m.keys.filter(v => v <= n).max\n            if (n == v) {\n\
    \                result += m(v)\n                n -= v\n            } else {\n\
    \                var u = v - n\n                var w = m.keys.filter(w => w <\
    \ v && w > u).max\n                if (w == u) {\n                    result +=\
    \ m(u) + m(v)\n                    n -= v\n                } else {\n        \
    \            result += m(w) + m(v)\n                    n -= v - w\n         \
    \       }\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdu5elurt.scala:18:14\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        m += (\e[31m1\e[0m ->\
    \ \e[31m\"i\"\e[0m)\n\e[31m\e[31m   |\e[0m              ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e\
    [0m              Required: (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdu5elurt.scala:19:14 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        m += (\e[31m5\e[0m -> \e[31m\"v\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m              ^^^^^^^^\e[0m\n\e[31m   |\e[0m              Found:\
    \    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m              Required: (\e\
    [1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdu5elurt.scala:20:14 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        m += (\e[31m10\e[0m -> \e[31m\"x\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              Found:    (\e[1m\e\
    [31mInt\e[0m, String)\n\e[31m   |\e[0m              Required: (\e[1m\e[32mLong\e\
    [0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdu5elurt.scala:21:14\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        m += (\e[31m50\e[0m ->\
    \ \e[31m\"l\"\e[0m)\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e\
    [0m              Required: (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdu5elurt.scala:22:14 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        m += (\e[31m100\e[0m -> \e[31m\"c\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \  Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m              Required:\
    \ (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ a"
  stdout: ''
  timestamp: 1660010305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val values = Array(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var remainder = number\n\
    \        var result = \"\"\n        while (remainder > 0) {\n            var i\
    \ = 0\n            while (remainder < values(i)) {\n                i += 1\n \
    \           }\n            remainder -= values(i)\n            result += numerals(i)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var res = \"\";\n        var number_ = number;\n        var next = \"\"\n\
    \        var next_ = 0\n        while (number_ > 0) {\n            if (number_\
    \ >= 1000) {\n                res += \"m\";\n                number_ -= 1000;\n\
    \            } else if (number_ >= 900) {\n                res += \"cm\";\n  \
    \              number_ -= 900;\n            } else if (number_ >= 500) {\n   \
    \             res += \"d\";\n                number_ -= 500;\n            } else\
    \ if (number_ >= 400) {\n                res += \"cd\";\n                number_\
    \ -= 400;\n            } else if (number_ >= 100) {\n                res += \"\
    c\";\n                number_ -= 100;\n            } else if (number_ >= 90) {\n\
    \                res += \"xc\";\n                number_ -= 90;\n            }\
    \ else if (number_ >= 50) {\n                res += \"l\";\n                number_\
    \ -= 50;\n            } else if (number_ >= 40) {\n                res += \"xl\"\
    ;\n                number_ -= 40;\n            } else if (number_ >= 10) {\n \
    \               res += \"x\";\n                number_ -= 10;\n            } else\
    \ if (number_ >= 9) {\n                res += \"ix\";\n                number_\
    \ -= 9;\n            } else if (number_ >= 5) {\n                res += \"v\"\
    ;\n                number_ -= 5;\n            } else if (number_ >= 4) {\n   \
    \             res += \"iv\";\n                number_ -= 4;\n            } else\
    \ if (number_ >= 1) {\n                res += \"i\";\n                number_\
    \ -= 1;\n            }\n        }\n        res;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = new Array[String](4)\n        symbols(0) = \"x\"\n       \
    \ symbols(1) = \"c\"\n        symbols(2) = \"m\"\n        symbols(3) = \"m\"\n\
    \        val values = new Array[Long](4)\n        values(0) = 10l\n        values(1)\
    \ = 100l\n        values(2) = 1000l\n        values(3) = 2000l\n        val digits\
    \ = new Array[Long](4)\n        digits(0) = number % 10l\n        digits(1) =\
    \ (number / 10l) % 10l\n        digits(2) = (number / 100l) % 10l\n        digits(3)\
    \ = (number / 1000l) % 10l\n        val result = new StringBuilder\n        for\
    \ (i <- 0 to 3) {\n            if (digits(i) == 9l) {\n                result.append(symbols(i))\n\
    \                result.append(symbols(i + 1))\n            } else if (digits(i)\
    \ == 4l) {\n                result.append(symbols(i))\n                result.append(symbols(i))\n\
    \            } else {\n                for (j <- 1l to (digits(i) / 5l)) {\n \
    \                   result.append(symbols(i + 1))\n                }\n       \
    \         for (j <- 1l to (digits(i) % 5l)) {\n                    result.append(symbols(i))\n\
    \                }\n            }\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_cvsr6v5.scala:50)\n\tat Problem.main(tmp_cvsr6v5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     require(number >= 1 && number <= 1000)\n        var x = number\n       \
    \ val roman = new ListBuffer[Char]\n        while (x >= 100) {\n            roman\
    \ += 'c'\n            x -= 100\n        }\n        if (x >= 90) {\n          \
    \  roman += 'x'\n            roman += 'c'\n            x -= 90\n        }\n  \
    \      while (x >= 50) {\n            roman += 'l'\n            x -= 50\n    \
    \    }\n        if (x >= 40) {\n            roman += 'x'\n            roman +=\
    \ 'l'\n            x -= 40\n        }\n        while (x >= 10) {\n           \
    \ roman += 'x'\n            x -= 10\n        }\n        if (x >= 9) {\n      \
    \      roman += 'i'\n            roman += 'x'\n            x -= 9\n        }\n\
    \        while (x >= 5) {\n            roman += 'v'\n            x -= 5\n    \
    \    }\n        if (x >= 4) {\n            roman += 'i'\n            roman +=\
    \ 'v'\n            x -= 4\n        }\n        while (x >= 1) {\n            roman\
    \ += 'i'\n            x -= 1\n        }\n        roman.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbm0zxdy_.scala:64)\n\tat Problem.main(tmpbm0zxdy_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder\n        var n = number\n        while (n\
    \ > 0) {\n            n match {\n                case x if (x >= 1000) => result.append(\"\
    m\"); n -= 1000\n                case x if (x >= 900) => result.append(\"cm\"\
    ); n -= 900\n                case x if (x >= 500) => result.append(\"d\"); n -=\
    \ 500\n                case x if (x >= 400) => result.append(\"cd\"); n -= 400\n\
    \                case x if (x >= 100) => result.append(\"c\"); n -= 100\n    \
    \            case x if (x >= 90) => result.append(\"xc\"); n -= 90\n         \
    \       case x if (x >= 50) => result.append(\"l\"); n -= 50\n               \
    \ case x if (x >= 40) => result.append(\"xl\"); n -= 40\n                case\
    \ x if (x >= 10) => result.append(\"x\"); n -= 10\n                case x if (x\
    \ >= 9) => result.append(\"ix\"); n -= 9\n                case x if (x >= 5) =>\
    \ result.append(\"v\"); n -= 5\n                case x if (x >= 4) => result.append(\"\
    iv\"); n -= 4\n                case x if (x >= 1) => result.append(\"i\"); n -=\
    \ 1\n            }\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val array = Array(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n   \
    \     var string = \"\"\n        var index = 0\n        var number2 = number\n\
    \        while (number2 > 0) {\n            val remainder = number2 % 10\n   \
    \         number2 /= 10\n            val (a, b, c) = (remainder % 5, remainder\
    \ / 5, remainder / 10)\n            if (c == 1) string = array(index) + string\n\
    \            if (b == 1) string = array(index + 1) + string\n            if (a\
    \ == 4) string = array(index) + array(index + 1) + string\n            else if\
    \ (a == 3) string = array(index) + array(index) + array(index) + string\n    \
    \        else if (a == 2) string = array(index) + array(index) + string\n    \
    \        else if (a == 1) string = array(index) + string\n            index +=\
    \ 2\n        }\n        string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuwz56x8g.scala:34)\n\tat Problem.main(tmpuwz56x8g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val conversion = Map(1 -> \"i\", 5 -> \"v\", 10 -> \"x\", 50 -> \"l\", 100\
    \ -> \"c\", 500 -> \"d\", 1000 -> \"m\")\n        val exponents = List(1, 5, 10,\
    \ 50, 100, 500, 1000)\n        val reverseExponents = exponents.reverse\n    \
    \    def convert(num : Long, exp : Int) : String = {\n            if (num == 0)\
    \ \"\"\n            else if (num == 1) conversion(exp)\n            else if (num\
    \ == 4) conversion(exp) + conversion(exp * 5)\n            else if (num == 5)\
    \ conversion(exp * 5)\n            else if (num == 9) conversion(exp) + conversion(exp\
    \ * 10)\n            else if (num < 4) convert(num - 1, exp) + conversion(exp)\n\
    \            else if (num < 5) convert(num - 4, exp) + conversion(exp) + conversion(exp\
    \ * 5)\n            else if (num < 9) convert(num - 5, exp) + conversion(exp *\
    \ 5)\n            else convert(num - 9, exp) + conversion(exp) + conversion(exp\
    \ * 10)\n        }\n        var n = number\n        var index = 0\n        var\
    \ string = \"\"\n        while (n > 0) {\n            string += convert(n % 10,\
    \ reverseExponents(index))\n            n /= 10\n            index += 1\n    \
    \    }\n        string.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: 10000\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.convert$1(tmp2ideejyx.scala:23)\n\
    \tat Problem$.intToMiniRoman(tmp2ideejyx.scala:33)\n\tat Problem$.main(tmp2ideejyx.scala:40)\n\
    \tat Problem.main(tmp2ideejyx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        val thousands = ((number % 10000) / 1000).toInt\n\
    \        val hundreds = ((number % 1000) / 100).toInt\n        val tens = ((number\
    \ % 100) / 10).toInt\n        val units = ((number % 10) / 1).toInt\n        if\
    \ (thousands == 1) roman += \"m\"\n        if (hundreds == 4) roman += \"cd\"\n\
    \        else if (hundreds == 9) roman += \"cm\"\n        else {\n           \
    \ if (hundreds >= 5) roman += \"d\"\n            for (i <- 1 to (hundreds % 5))\
    \ roman += \"c\"\n        }\n        if (tens == 4) roman += \"xl\"\n        else\
    \ if (tens == 9) roman += \"xc\"\n        else {\n            if (tens >= 5) roman\
    \ += \"l\"\n            for (i <- 1 to (tens % 5)) roman += \"x\"\n        }\n\
    \        if (units == 4) roman += \"iv\"\n        else if (units == 9) roman +=\
    \ \"ix\"\n        else {\n            if (units >= 5) roman += \"v\"\n       \
    \     for (i <- 1 to (units % 5)) roman += \"i\"\n        }\n        roman\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // A map for roman numeric character to numeric value\n        val numericValues\
    \ = Map(\n            'i' -> 1,\n            'v' -> 5,\n            'x' -> 10,\n\
    \            'l' -> 50,\n            'c' -> 100,\n            'd' -> 500,\n  \
    \          'm' -> 1000)\n        // A map for numeric value to roman numeric character\n\
    \        val romanCharacters = Map(\n            1 -> 'i',\n            5 -> 'v',\n\
    \            10 -> 'x',\n            50 -> 'l',\n            100 -> 'c',\n   \
    \         500 -> 'd',\n            1000 -> 'm')\n        // A map for numeric\
    \ value to the value that it is subtracted to get a\n        // preceeding value,\
    \ if such value is present\n        val subtractionValues = Map(\n           \
    \ 1 -> 0,\n            5 -> 0,\n            10 -> 1,\n            50 -> 10,\n\
    \            100 -> 10,\n            500 -> 100,\n            1000 -> 100)\n \
    \       // A map for numeric value to a list of values that are less than it and\n\
    \        // which it can be subtracted from\n        val subtractionKeys = Map(\n\
    \            1 -> List(0),\n            5 -> List(1),\n            10 -> List(1,\
    \ 5),\n            50 -> List(10, 10, 10, 10, 10),\n            100 -> List(10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5vnvdwal.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5vnvdwal.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010303
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = number.toString.toList.map(_.toString.toInt)\n        val letters\
    \ = List(\"c\", \"x\", \"i\")\n        var string = \"\"\n        for (i <- 0\
    \ to 2) {\n            var digit = digits(2 - i)\n            val letter = letters(i)\n\
    \            if (digit == 4) {\n                string += letter + letters(i -\
    \ 1)\n            } else if (digit == 9) {\n                string += letter +\
    \ letters(i - 2)\n            } else {\n                if (digit > 4) {\n   \
    \                 string += letters(i - 1)\n                    digit -= 5\n \
    \               }\n                string += letter * digit\n            }\n \
    \       }\n        string\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.intToMiniRoman$$anonfun$1(tmpmrva35du.scala:19)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.intToMiniRoman(tmpmrva35du.scala:32)\n\
    \tat Problem$.main(tmpmrva35du.scala:36)\n\tat Problem.main(tmpmrva35du.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"\
    xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val values = List(1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var temp = number\n    \
    \    var numberArray = new ArrayBuffer[Char]()\n        for (i <- 0 to symbols.length\
    \ - 1) {\n            val times = temp / values(i)\n            for (j <- 1 to\
    \ times.toInt) {\n                numberArray += symbols(i).charAt(0)\n      \
    \      }\n            temp = temp % values(i)\n        }\n        numberArray.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzxer49xm.scala:29)\n\tat Problem.main(tmpzxer49xm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Array(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n\
    \        var numStr = number.toString()\n        var result = \"\"\n        for\
    \ (i <- 0 until numStr.length) {\n            var str = \"\"\n            var\
    \ num = (numStr(i) - '0').toInt\n            var j = i\n            while (j >\
    \ 0) {\n                num *= 10\n                j -= 1\n            }\n   \
    \         if (num > 9000) {\n                var str = numerals(6)\n         \
    \       while (num > 9000) {\n                    str += numerals(6)\n       \
    \             num -= 1000\n                }\n                result += str\n\
    \            }\n            else if (num >= 1000) {\n                result +=\
    \ numerals(6)\n                num -= 1000\n            }\n            if (num\
    \ > 900) {\n                result += numerals(4) + numerals(6)\n            \
    \    num -= 900\n            }\n            else if (num >= 500) {\n         \
    \       result += numerals(5)\n                num -= 500\n            }\n   \
    \         if (num > 400) {\n                result += numerals(4) + numerals(5)\n\
    \                num -= 400\n            }\n            else if (num >= 100) {\n\
    \                result += numerals(4)\n                num -= 100\n         \
    \   }\n            if (num > 90) {\n                result += numerals(2) + numerals(4)\n\
    \                num -= 90\n            }\n            else if (num >= 50) {\n\
    \                result += numerals(3)\n                num -= 50\n          \
    \  }\n            if (num > 40) {\n                result += numerals(2) + numerals(3)\n\
    \                num -= 40\n            }\n            else if (num >= 10) {\n\
    \                result += numerals(2)\n                num -= 10\n          \
    \  }\n            if (num == 9) {\n                result += numerals(0) + numerals(2)\n\
    \                num -= 9\n            }\n            else if (num >= 5) {\n \
    \               result += numerals(1)\n                num -= 5\n            }\n\
    \            if (num == 4) {\n                result += numerals(0) + numerals(1)\n\
    \               \n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp43mva9ua.scala:100:0 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp43mva9ua.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until numStr.length) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: String\n\
    \e[31m19 |\e[0m            \e[33mvar\e[0m \e[36mstr\e[0m = \e[31m\"\"\e[0m\n\e\
    [31m20 |\e[0m            \e[33mvar\e[0m \e[36mnum\e[0m = (numStr(i) - \e[31m'0'\e\
    [0m).toInt\n\e[31m21 |\e[0m            \e[33mvar\e[0m \e[36mj\e[0m = i\n\e[31m22\
    \ |\e[0m            \e[33mwhile\e[0m (j > \e[31m0\e[0m) {\n\e[31m23 |\e[0m   \
    \             num *= \e[31m10\e[0m\n\e[31m24 |\e[0m                j -= \e[31m1\e\
    [0m\n\e[31m25 |\e[0m            }\n\e[31m26 |\e[0m            \e[33mif\e[0m (num\
    \ > \e[31m9000\e[0m) {\n\e[31m27 |\e[0m                \e[33mvar\e[0m \e[36mstr\e\
    [0m = numerals(\e[31m6\e[0m)\n\e[31m28 |\e[0m                \e[33mwhile\e[0m\
    \ (num > \e[31m9000\e[0m) {\n\e[31m29 |\e[0m                    str += numerals(\e\
    [31m6\e[0m)\n\e[31m30 |\e[0m                    num -= \e[31m1000\e[0m\n\e[31m31\
    \ |\e[0m                }\n\e[31m32 |\e[0m                result += str\n\e[31m33\
    \ |\e[0m            }\n\e[31m34 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m\
    \ (num >= \e[31m1000\e[0m) {\n\e[31m35 |\e[0m                result += numerals(\e\
    [31m6\e[0m)\n\e[31m36 |\e[0m                num -= \e[31m1000\e[0m\n\e[31m37 |\e\
    [0m            }\n\e[31m38 |\e[0m            \e[33mif\e[0m (num > \e[31m900\e\
    [0m) {\n\e[31m39 |\e[0m                result += numerals(\e[31m4\e[0m) + numerals(\e\
    [31m6\e[0m)\n\e[31m40 |\e[0m                num -= \e[31m900\e[0m\n\e[31m41 |\e\
    [0m            }\n\e[31m42 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (num\
    \ >= \e[31m500\e[0m) {\n\e[31m43 |\e[0m                result += numerals(\e[31m5\e\
    [0m)\n\e[31m44 |\e[0m                num -= \e[31m500\e[0m\n\e[31m45 |\e[0m  \
    \          }\n\e[31m46 |\e[0m            \e[33mif\e[0m (num > \e[31m400\e[0m)\
    \ {\n\e[31m47 |\e[0m                result += numerals(\e[31m4\e[0m) + numerals(\e\
    [31m5\e["
  stdout: ''
  timestamp: 1660010305
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToMiniRoman(number : Long, str : String) : String = {\n         \
    \   if (number == 0) str\n            else if (number >= 1000) intToMiniRoman(number\
    \ - 1000, str + \"m\")\n            else if (number >= 900) intToMiniRoman(number\
    \ - 900, str + \"cm\")\n            else if (number >= 500) intToMiniRoman(number\
    \ - 500, str + \"d\")\n            else if (number >= 400) intToMiniRoman(number\
    \ - 400, str + \"cd\")\n            else if (number >= 100) intToMiniRoman(number\
    \ - 100, str + \"c\")\n            else if (number >= 90) intToMiniRoman(number\
    \ - 90, str + \"xc\")\n            else if (number >= 50) intToMiniRoman(number\
    \ - 50, str + \"l\")\n            else if (number >= 40) intToMiniRoman(number\
    \ - 40, str + \"xl\")\n            else if (number >= 10) intToMiniRoman(number\
    \ - 10, str + \"x\")\n            else if (number >= 9) intToMiniRoman(number\
    \ - 9, str + \"ix\")\n            else if (number >= 5) intToMiniRoman(number\
    \ - 5, str + \"v\")\n            else if (number >= 4) intToMiniRoman(number -\
    \ 4, str + \"iv\")\n            else if (number >= 1) intToMiniRoman(number -\
    \ 1, str + \"i\")\n            else throw new RuntimeException(\"input out of\
    \ range\")\n        }\n        intToMiniRoman(number, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val list = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val array = Array(1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var num = number\n        var\
    \ res = \"\"\n        for (i <- 0 to 12) {\n            while (num >= array(i))\
    \ {\n                res += list(i)\n                num -= array(i)\n       \
    \     }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     import java.util.HashMap\n        val m = new HashMap[Long, String]()\n\
    \        m.put(1l, \"i\")\n        m.put(5l, \"v\")\n        m.put(10l, \"x\"\
    )\n        m.put(50l, \"l\")\n        m.put(100l, \"c\")\n        m.put(500l,\
    \ \"d\")\n        m.put(1000l, \"m\")\n        var s = 0l\n        var ss = List[String]()\n\
    \        while (number > 0) {\n            s = m.size() - 2 - (ceil(log(number)\
    \ / log(2)).toLong)\n            ss = ss :+ m.get(pow(2, s).toLong)\n        \
    \    number -= pow(2, s).toLong\n        }\n        ss.foldLeft(\"\")(_ + _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr03admcg.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            number -= pow(\e[31m2\e[0m, s).toLong\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010304
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1) return \"\"\n        val digits = List(\n              \
    \  'i',\n                'v',\n                'x',\n                'l',\n  \
    \              'c',\n                'd',\n                'm'\n            )\n\
    \        val numRepr = number.toString.map(x => digits(x.asDigit * 2))\n     \
    \   return numRepr.foldLeft(\"\")((a, b) => a + b)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 18\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmplqbpt5pw.scala:25)\n\tat Problem$.$anonfun$adapted$1(tmplqbpt5pw.scala:25)\n\
    \tat scala.collection.StringOps$.map$extension(StringOps.scala:223)\n\tat Problem$.intToMiniRoman(tmplqbpt5pw.scala:25)\n\
    \tat Problem$.main(tmplqbpt5pw.scala:29)\n\tat Problem.main(tmplqbpt5pw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010309
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // 1. Convert the number to hexadecimal representation\n        val hex\
    \ = number.toHexString\n        // 2. Loop thru the hexadecimal digits and convert\
    \ them to roman characters\n        val mappings = Map[Char,String](\n       \
    \     '0' -> \"\", '1' -> \"i\", '2' -> \"ii\", '3' -> \"iii\", '4' -> \"iv\"\
    , '5' -> \"v\", '6' -> \"vi\", '7' -> \"vii\", '8' -> \"viii\", '9' -> \"ix\"\
    ,\n            'a' -> \"x\", 'b' -> \"xi\", 'c' -> \"xii\", 'd' -> \"xiii\", 'e'\
    \ -> \"xiv\", 'f' -> \"xv\")\n        val chars = hex.toCharArray\n        val\
    \ result = new StringBuilder()\n        var digitIndex = 0\n        for (digit\
    \ <- chars) {\n            if (digitIndex > 0) {\n                result.append(\"\
    x\" * digitIndex)\n            }\n            result.append(mappings(digit))\n\
    \            digitIndex += 1\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplpgnl7zm.scala:34)\n\tat Problem.main(tmplpgnl7zm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010312
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val table = Map(\"M\" -> 1000, \"CM\" -> 900, \"D\" -> 500, \"CD\" -> 400,\
    \ \"C\" -> 100, \"XC\" -> 90, \"L\" -> 50, \"XL\" -> 40, \"X\" -> 10, \"IX\" ->\
    \ 9, \"V\" -> 5, \"IV\" -> 4, \"I\" -> 1)\n        var result = \"\"\n       \
    \ var remaining = number\n        for ((roman, arabic) <- table) {\n         \
    \   while (remaining >= arabic) {\n                result += roman\n         \
    \       remaining -= arabic\n            }\n        }\n        result.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_fb23740.scala:27)\n\tat Problem.main(tmp_fb23740.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var stack : List[(Int, String)] = List( (1, \"i\"), (5, \"v\"), (10, \"\
    x\"), (50, \"l\"), (100, \"c\"), (500, \"d\"), (1000, \"m\") )\n        var result\
    \ : String = \"\"\n        var currentNumber : Long = number\n        while (currentNumber\
    \ > 0) {\n            if (currentNumber < stack.head._1) stack = stack.tail\n\
    \            else {\n                val value : Int = stack.head._1\n       \
    \         result += stack.head._2\n                currentNumber -= value\n  \
    \          }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvzyw0jif.scala:29)\n\tat Problem.main(tmpvzyw0jif.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var l : List[String] = List()\n        var remaining = number\n        if\
    \ (remaining >= 1000) {\n            l = l :+ \"m\"\n            remaining -=\
    \ 1000\n        }\n        if (remaining >= 900) {\n            l = l :+ \"cm\"\
    \n            remaining -= 900\n        }\n        if (remaining >= 500) {\n \
    \           l = l :+ \"d\"\n            remaining -= 500\n        }\n        if\
    \ (remaining >= 400) {\n            l = l :+ \"cd\"\n            remaining -=\
    \ 400\n        }\n        if (remaining >= 100) {\n            l = l :+ \"c\"\n\
    \            remaining -= 100\n        }\n        if (remaining >= 90) {\n   \
    \         l = l :+ \"xc\"\n            remaining -= 90\n        }\n        if\
    \ (remaining >= 50) {\n            l = l :+ \"l\"\n            remaining -= 50\n\
    \        }\n        if (remaining >= 40) {\n            l = l :+ \"xl\"\n    \
    \        remaining -= 40\n        }\n        if (remaining >= 10) {\n        \
    \    l = l :+ \"x\"\n            remaining -= 10\n        }\n        if (remaining\
    \ >= 9) {\n            l = l :+ \"ix\"\n            remaining -= 9\n        }\n\
    \        if (remaining >= 5) {\n            l = l :+ \"v\"\n            remaining\
    \ -= 5\n        }\n        if (remaining >= 4) {\n            l = l :+ \"iv\"\n\
    \            remaining -= 4\n        }\n        if (remaining >= 1) {\n      \
    \      l = l :+ \"i\"\n            remaining -= 1\n        }\n        return l.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm1bdga8p.scala:73)\n\tat Problem.main(tmpm1bdga8p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   if (number < 1) {\n        return \"\"\n      }\n      val romanNumerals =\
    \ Array(1000 -> \"m\", 900 -> \"cm\", 500 -> \"d\", 400 -> \"cd\", 100 -> \"c\"\
    , 90 -> \"xc\", 50 -> \"l\", 40 -> \"xl\", 10 -> \"x\", 9 -> \"ix\", 5 -> \"v\"\
    , 4 -> \"iv\", 1 -> \"i\")\n      var result = new StringBuilder\n      var remainder\
    \ = number\n      for ((decimal, roman) <- romanNumerals) {\n        while (remainder\
    \ >= decimal) {\n          result.append(roman)\n          remainder -= decimal\n\
    \        }\n      }\n      result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val numbers = List(1000, 500, 100, 50, 10, 5, 1)\n      val romanNumbers =\
    \ List(\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\")\n      val map = Map[Int,\
    \ String]() ++ (numbers zip romanNumbers)\n      val sb = new StringBuilder()\n\
    \      var remainder = number\n      for (i <- 0 until 7) {\n        val n = numbers(i)\n\
    \        val r = romanNumbers(i)\n        val m = remainder / n\n        remainder\
    \ = remainder % n\n        sb.append(r * m)\n      }\n      sb.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxw_qvi8p.scala:25:22\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        sb.append(r * m)\n\e\
    [31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m             \
    \         Found:    (m : Long)\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val bases = Array(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var str = \"\"\n  \
    \      var n = number\n        for (i <- 0 to 12) {\n            while (n >= bases(i))\
    \ {\n                str += numerals(i)\n                n -= bases(i)\n     \
    \       }\n        }\n        str\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // 1, 5, 10, 50, 100, 500, 1000\n        val miniRoman = new ListBuffer[String]()\n\
    \        var n = number\n        while (n > 0) {\n            n match {\n    \
    \            case x if (x >= 1000) => {\n                    miniRoman += \"m\"\
    \n                    n -= 1000\n                }\n                case x if\
    \ (x >= 500) => {\n                    miniRoman += \"d\"\n                  \
    \  n -= 500\n                }\n                case x if (x >= 100) => {\n  \
    \                  miniRoman += \"c\"\n                    n -= 100\n        \
    \        }\n                case x if (x >= 50) => {\n                    miniRoman\
    \ += \"l\"\n                    n -= 50\n                }\n                case\
    \ x if (x >= 10) => {\n                    miniRoman += \"x\"\n              \
    \      n -= 10\n                }\n                case x if (x >= 5) => {\n \
    \                   miniRoman += \"v\"\n                    n -= 5\n         \
    \       }\n                case x if (x >= 1) => {\n                    miniRoman\
    \ += \"i\"\n                    n -= 1\n                }\n            }\n   \
    \     }\n        // Optimize\n        miniRoman.toList.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl29gn0jx.scala:54)\n\tat Problem.main(tmpl29gn0jx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Map[Long, String](1l -> \"i\", 5l -> \"v\", 10l -> \"x\"\
    , 50l -> \"l\", 100l -> \"c\", 500l -> \"d\", 1000l -> \"m\")\n        if (number\
    \ <= 0 || number > 1000) {\n            throw new IllegalArgumentException(\"\
    number must be between 1 and 1000 inclusive\")\n        }\n        def intToMiniRomanHelper(number\
    \ : Long, remainingNumerals : Map[Long, String]) : String = {\n            if\
    \ (number == 0) {\n                \"\"\n            } else {\n              \
    \  remainingNumerals.head match {\n                    case (1l, \"i\") => {\n\
    \                        val (closestNumber, closestNumeral) = numerals.filter(pair\
    \ => number >= pair._1).last\n                        val prefix = (closestNumber\
    \ - number) match {\n                            case 0 => \"\"\n            \
    \                case 1 => \"i\"\n                            case 2 => \"ii\"\
    \n                            case 3 => \"iii\"\n                            case\
    \ 4 => \"iv\"\n                            case 5 => \"v\"\n                 \
    \           case 6 => \"vi\"\n                            case 7 => \"vii\"\n\
    \                            case 8 => \"viii\"\n                            case\
    \ 9 => \"ix\"\n                        }\n                        prefix + closestNumeral\
    \ + intToMiniRomanHelper(number - closestNumber, remainingNumerals - closestNumber)\n\
    \                    }\n                    case (closestNumber, closestNumeral)\
    \ => {\n                        val prefix = (closestNumber - number) match {\n\
    \                            case 0 => \"\"\n                            case\
    \ 1 => \"i\"\n                            case 2 => \"ii\"\n                 \
    \           case 3 => \"iii\"\n                            case 4 => \"iv\"\n\
    \                            case 5 => \"v\"\n                            case\
    \ 6 => \"vi\"\n                            case 7 => \"vii\"\n               \
    \             case 8 => \"viii\"\n                            case 9 => \"ix\"\
    \n                        }\n                        prefix + closestNumeral +\
    \ intToMiniRomanHelper(number - closestNumber, remainingNumerals - closestNumber)\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ result = intToMiniRomanHelper(number, numerals)\n        result.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "scala.MatchError: -9 (of class java.lang.Long)\n\tat Problem$.intToMiniRomanHelper$1(tmp131lombn.scala:36)\n\
    \tat Problem$.intToMiniRoman(tmp131lombn.scala:58)\n\tat Problem$.main(tmp131lombn.scala:62)\n\
    \tat Problem.main(tmp131lombn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // IMPLEMENT THIS FUNCTION\n        \"REPLACE THIS STRING WITH YOUR RESULT\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_jb3wqjj.scala:19)\n\tat Problem.main(tmp_jb3wqjj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        val limit = 1000\n        var value = number\n\
    \        val map = new HashMap[Int, String]\n        map += (1 -> \"i\", 2 ->\
    \ \"ii\", 3 -> \"iii\", 4 -> \"iv\", 5 -> \"v\", 6 -> \"vi\", 7 -> \"vii\", 8\
    \ -> \"viii\", 9 -> \"ix\", 10 -> \"x\", 20 -> \"xx\", 30 -> \"xxx\", 40 -> \"\
    xl\", 50 -> \"l\", 60 -> \"lx\", 70 -> \"lxx\", 80 -> \"lxxx\", 90 -> \"xc\",\
    \ 100 -> \"c\", 200 -> \"cc\", 300 -> \"ccc\", 400 -> \"cd\", 500 -> \"d\", 600\
    \ -> \"dc\", 700 -> \"dcc\", 800 -> \"dccc\", 900 -> \"cm\", 1000 -> \"m\")\n\
    \        var keys = map.keys.toList.sorted.reverse\n        for (key <- keys)\
    \ {\n            var divided = value / key\n            value = value % key\n\
    \            if (divided > 0) result += map(key)\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010316
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val units = Array(\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\")\n        val tens = Array(\"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\")\n        val hundreds = Array(\"c\"\
    , \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n       \
    \ val thousands = Array(\"m\", \"mm\", \"mmm\")\n        var num = number\n  \
    \      val roman = new StringBuilder\n        var digit = 0\n        while (num\
    \ > 0) {\n            val d = (num % 10).toInt\n            digit += 1\n     \
    \       num /= 10\n            if (digit == 1) roman.insert(0, units(d - 1))\n\
    \            else if (digit == 2) roman.insert(0, tens(d - 1))\n            else\
    \ if (digit == 3) roman.insert(0, hundreds(d - 1))\n            else if (digit\
    \ == 4) roman.insert(0, thousands(d - 1))\n        }\n        roman.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 9\n\tat Problem$.intToMiniRoman(tmp5u2ym2jp.scala:26)\n\tat Problem$.main(tmp5u2ym2jp.scala:38)\n\
    \tat Problem.main(tmp5u2ym2jp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val convert = new Converter\n        return convert.intToMiniRoman(number)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbva8rr24.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mconvert\e[0m = \e[33mnew\e\
    [0m \e[35mConverter\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: type Converter\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010311
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var s = \"\"\n        val hundreds = (number % 1000).toInt / 100\n     \
    \   for (i <- 1 to hundreds) s += \"c\"\n        val tens = (number % 100).toInt\
    \ / 10\n        for (i <- 1 to tens) s += \"x\"\n        val ones = (number %\
    \ 10).toInt\n        for (i <- 1 to ones) s += \"i\"\n        val a = s.replaceAll(\"\
    ccccc\", \"cd\").replaceAll(\"x\", \"ill\").replaceAll(\"iiiii\", \"iv\").replaceAll(\"\
    illl\", \"xl\").replaceAll(\"iiii\", \"iv\").replaceAll(\"ill\", \"xl\").replaceAll(\"\
    i\", \"\").replaceAll(\"l\", \"\").replaceAll(\"v\", \"\").replaceAll(\"d\", \"\
    \")\n        val b = a.replaceAll(\"c\", \"d\").replaceAll(\"x\", \"l\").replaceAll(\"\
    i\", \"v\")\n        val c = b.replaceAll(\"d\", \"c\").replaceAll(\"l\", \"x\"\
    ).replaceAll(\"v\", \"i\")\n        c\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcewi8rkm.scala:28)\n\tat Problem.main(tmpcewi8rkm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // keep the repeated code in the if-blocks small by defining the conversion\
    \ of each\n        // symbol here\n        def intToRomanSymbol(int : Long, roman\
    \ : String) : String = {\n            var accumulator = \"\"\n            var\
    \ i = int\n            while (i > 0) {\n                accumulator += roman\n\
    \                i -= 1\n            }\n            accumulator\n        }\n \
    \       // convert the number to roman numerals\n        var accumulator = \"\"\
    \n        var num = number\n        // there should be a better way to do this\
    \ but i don't know how\n        if (num >= 1000) {\n            accumulator +=\
    \ intToRomanSymbol(num / 1000, \"m\")\n            num %= 1000\n        }\n  \
    \      if (num >= 500) {\n            accumulator += intToRomanSymbol(num / 500,\
    \ \"d\")\n            num %= 500\n        }\n        if (num >= 100) {\n     \
    \       accumulator += intToRomanSymbol(num / 100, \"c\")\n            num %=\
    \ 100\n        }\n        if (num >= 50) {\n            accumulator += intToRomanSymbol(num\
    \ / 50, \"l\")\n            num %= 50\n        }\n        if (num >= 10) {\n \
    \           accumulator += intToRomanSymbol(num / 10, \"x\")\n            num\
    \ %= 10\n        }\n        if (num >= 5) {\n            accumulator += intToRomanSymbol(num\
    \ / 5, \"v\")\n            num %= 5\n        }\n        if (num >= 1) {\n    \
    \        accumulator += intToRomanSymbol(num, \"i\")\n        }\n        // replace\
    \ 4's and 9's with their special symbols\n        accumulator = accumulator.replace(\"\
    iv\", \"iv\")\n        accumulator = accumulator.replace(\"ix\", \"ix\")\n   \
    \     accumulator = accumulator.replace(\"xl\", \"xl\")\n        accumulator =\
    \ accumulator.replace(\"xc\", \"xc\")\n        accumulator = accumulator.replace(\"\
    cd\", \"cd\")\n        accumulator = accumulator.replace(\"cm\", \"cm\")\n   \
    \     accumulator\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb64ohd74.scala:67)\n\tat Problem.main(tmpb64ohd74.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010314
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = ArrayBuffer.fill(13)(0)\n        var n = number\n        val\
    \ radix = Array(1000, 500, 100, 50, 10, 5, 1, 500, 100, 50, 10, 5, 1)\n      \
    \  for (i <- 0 until radix.length) {\n            roman(i) = (n / radix(i)).toInt\n\
    \            n %= radix(i)\n        }\n        val map = Array(Array(\"\", \"\
    m\", \"mm\", \"mmm\"), Array(\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\"\
    , \"dcc\", \"dccc\", \"cm\"), Array(\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\"\
    , \"lx\", \"lxx\", \"lxxx\", \"xc\"), Array(\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"))\n        var result = \"\"\n    \
    \    for (i <- 0 until 4) {\n            result += map(i)(roman(i * 3))\n    \
    \        result += map(i)(roman(i * 3 + 1))\n            result += map(i)(roman(i\
    \ * 3 + 2))\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp719yx0k5.scala:32)\n\tat Problem.main(tmp719yx0k5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010316
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder\n        val symbols = List(\"i\", \"v\"\
    , \"x\", \"l\", \"c\", \"d\", \"m\")\n        var f = number\n        var pos\
    \ = 0\n        while (f != 0) {\n            val digit = (f % 10).toInt\n    \
    \        f /= 10\n            if (digit == 0) {\n                pos += 2\n  \
    \              continue\n            }\n            if (digit < 4) result.insert(0,\
    \ symbols(pos) * digit)\n            else if (digit == 4) result.insert(0, symbols(pos)\
    \ + symbols(pos + 1))\n            else if (digit == 5) result.insert(0, symbols(pos\
    \ + 1))\n            else if (digit < 9) result.insert(0, symbols(pos + 1) + symbols(pos)\
    \ * (digit - 5))\n            else result.insert(0, symbols(pos) + symbols(pos\
    \ + 2))\n            pos += 2\n        }\n        result.toString\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb8zrf3wz.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                continue\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found: continue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010313
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\",\
    \ \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val values = Array(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var result = \"\"\n\
    \        var i = 0\n        var num = number\n        while (num > 0) {\n    \
    \        if (num >= values(i)) {\n                result += symbols(i)\n     \
    \           num -= values(i)\n            }\n            else i += 1\n       \
    \ }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = \"ivxlcdm\"\n        val values = List(1, 5, 10, 50, 100,\
    \ 500, 1000)\n        val digits = number.toString.length\n        def build(value\
    \ : Long, symbol : Int) : String = {\n            val n = value / values(symbol)\n\
    \            val nextSymbol = if (n == 4) symbol + 1 else symbol\n           \
    \ val nextValue = if (n == 4) value - 4 * values(symbol) + values(nextSymbol)\
    \ else value - n * values(symbol)\n            (if (n == 9) \"\" else symbols(symbol).toString\
    \ * n.toInt) + (if (nextValue == 0) \"\" else build(nextValue, nextSymbol))\n\
    \        }\n        build(number, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptzffsvm1.scala:27)\n\tat Problem.main(tmptzffsvm1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010316
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var roman = \"\"\n        for (d <- 0 to 3) {\n\
    \            val digit = (num % 10).toInt\n            val romanDigit = digit\
    \ match {\n                case 1 => \"i\"\n                case 2 => \"ii\"\n\
    \                case 3 => \"iii\"\n                case 4 => \"iv\"\n       \
    \         case 5 => \"v\"\n                case 6 => \"vi\"\n                case\
    \ 7 => \"vii\"\n                case 8 => \"viii\"\n                case 9 =>\
    \ \"ix\"\n                case _ => \"\"\n            }\n            roman = romanDigit\
    \ + roman\n            num /= 10\n        }\n        return roman\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn3gk3cs1.scala:37)\n\tat Problem.main(tmpn3gk3cs1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010316
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = \"\" +\n        (\"I\" * (number % 10).toInt) +\n        (\"\
    X\" * (number % 100 / 10).toInt) +\n        (\"C\" * (number % 1000 / 100).toInt)\
    \ +\n        (\"M\" * (number / 1000).toInt)\n        return roman.replace(\"\
    VIIII\", \"IX\").replace(\"IIII\", \"IV\").replace(\"LXXXX\", \"XC\").replace(\"\
    XXXX\", \"XL\").replace(\"DCCCC\", \"CM\").replace(\"CCCC\", \"CD\").toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc2wn141_.scala:23)\n\tat Problem.main(tmpc2wn141_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010316
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Determines the proper roman numeral based on a number from 1 to 9.\n\
    \        def intToMiniRomanDigit(digit : Long) : String = {\n            digit\
    \ match {\n                case 1 => \"i\"\n                case 2 => \"ii\"\n\
    \                case 3 => \"iii\"\n                case 4 => \"iv\"\n       \
    \         case 5 => \"v\"\n                case 6 => \"vi\"\n                case\
    \ 7 => \"vii\"\n                case 8 => \"viii\"\n                case 9 =>\
    \ \"ix\"\n                case _ => \"ERROR\"\n            }\n        }\n    \
    \    // Determines the proper roman numeral based on a number from 10 to 90,\n\
    \        // in increments of 10.\n        def intToMiniRomanTens(digit : Long)\
    \ : String = {\n            digit match {\n                case 10 => \"x\"\n\
    \                case 20 => \"xx\"\n                case 30 => \"xxx\"\n     \
    \           case 40 => \"xl\"\n                case 50 => \"l\"\n            \
    \    case 60 => \"lx\"\n                case 70 => \"lxx\"\n                case\
    \ 80 => \"lxxx\"\n                case 90 => \"xc\"\n                case _ =>\
    \ \"ERROR\"\n            }\n        }\n        // Determines the proper roman\
    \ numeral based on a number from 100 to 900,\n        // in increments of 100.\n\
    \        def intToMiniRomanHundreds(digit : Long) : String = {\n            digit\
    \ match {\n                case 100 => \"c\"\n                case 200 => \"cc\"\
    \n                case 300 => \"ccc\"\n                case 400 => \"cd\"\n  \
    \              case 500 => \"d\"\n                case 600 => \"dc\"\n       \
    \         case 700 => \"dcc\"\n                case 800 => \"dccc\"\n        \
    \        case 900 => \"cm\"\n                case _ => \"ERROR\"\n           \
    \ }\n        }\n        // Determines the proper roman numeral based on a number\
    \ from 1000 to 1000.\n        def intToMiniRomanThousands(digit : Long) : String\
    \ = {\n            digit match {\n                case 1000 => \"m\"\n       \
    \         case _ => \"ERROR\"\n            }\n        }\n        // Builds the\
    \ roman numeral string.\n        val numberString = number.toString\n        var\
    \ miniRoman = \"\"\n        var\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp1u4bj73_.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mvar\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1u4bj73_.scala:73:5 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010315
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\";\n        var remaining = number;\n        while (remaining\
    \ >= 1000) {\n            result += \"m\";\n            remaining -= 1000;\n \
    \       }\n        while (remaining >= 900) {\n            result += \"cm\";\n\
    \            remaining -= 900;\n        }\n        while (remaining >= 500) {\n\
    \            result += \"d\";\n            remaining -= 500;\n        }\n    \
    \    while (remaining >= 400) {\n            result += \"cd\";\n            remaining\
    \ -= 400;\n        }\n        while (remaining >= 100) {\n            result +=\
    \ \"c\";\n            remaining -= 100;\n        }\n        while (remaining >=\
    \ 90) {\n            result += \"xc\";\n            remaining -= 90;\n       \
    \ }\n        while (remaining >= 50) {\n            result += \"l\";\n       \
    \     remaining -= 50;\n        }\n        while (remaining >= 40) {\n       \
    \     result += \"xl\";\n            remaining -= 40;\n        }\n        while\
    \ (remaining >= 10) {\n            result += \"x\";\n            remaining -=\
    \ 10;\n        }\n        while (remaining >= 9) {\n            result += \"ix\"\
    ;\n            remaining -= 9;\n        }\n        while (remaining >= 5) {\n\
    \            result += \"v\";\n            remaining -= 5;\n        }\n      \
    \  while (remaining >= 4) {\n            result += \"iv\";\n            remaining\
    \ -= 4;\n        }\n        while (remaining >= 1) {\n            result += \"\
    i\";\n            remaining -= 1;\n        }\n        return result;\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010320
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val nums = List(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n\
    \        val syms = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"\
    xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val values = List(1, 10, 100,\
    \ 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000l,\
    \ 100000000000l, 1000000000000l)\n        val n = number.toInt\n        // assume\
    \ n is not too large...\n        val rems = values.map(v => n % v)\n        val\
    \ quotients = (0 to rems.length - 2).map(i => (rems(i) - rems(i + 1)) / values(i))\n\
    \        (nums zip syms zip quotients).map(p => p._1._2 * p._2).mkString(\"\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsep_h_3m.scala:22:59\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        (nums zip syms zip quotients).map(\e\
    [36mp\e[0m => p._1._2 * p._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                         ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                                         Found:    Long\n\
    \e[31m   |\e[0m                                                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val miniRoman = Array(\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\", \"x\", \"xi\", \"xii\", \"xiii\", \"xiv\", \"xv\", \"xvi\"\
    , \"xvii\", \"xviii\", \"xix\", \"xx\", \"xxi\", \"xxii\", \"xxiii\", \"xxiv\"\
    , \"xxv\", \"xxvi\", \"xxvii\", \"xxviii\", \"xxix\", \"xxx\", \"xxxi\", \"xxxii\"\
    , \"xxxiii\", \"xxxiv\", \"xxxv\", \"xxxvi\", \"xxxvii\", \"xxxviii\", \"xxxix\"\
    , \"xl\", \"xli\", \"xlii\", \"xliii\", \"xliv\", \"xlv\", \"xlvi\", \"xlvii\"\
    , \"xlviii\", \"xlix\", \"l\", \"li\", \"lii\", \"liii\", \"liv\", \"lv\", \"\
    lvi\", \"lvii\", \"lviii\", \"lix\", \"lx\", \"lxi\", \"lxii\", \"lxiii\", \"\
    lxiv\", \"lxv\", \"lxvi\", \"lxvii\", \"lxviii\", \"lxix\", \"lxx\", \"lxxi\"\
    , \"lxxii\", \"lxxiii\", \"lxxiv\", \"lxxv\", \"lxxvi\", \"lxxvii\", \"lxxviii\"\
    , \"lxxix\", \"lxxx\", \"lxxxi\", \"lxxxii\", \"lxxxiii\", \"lxxxiv\", \"lxxxv\"\
    , \"lxxxvi\", \"lxxxvii\", \"lxxxviii\", \"lxxxix\", \"xc\", \"xci\", \"xcii\"\
    , \"xciii\", \"xciv\", \"xcv\", \"xcvi\", \"xcvii\", \"xcviii\", \"xcix\", \"\
    c\", \"ci\", \"cii\", \"ciii\", \"civ\", \"cv\", \"cvi\", \"cvii\", \"cviii\"\
    , \"cix\", \"cx\", \"cxi\", \"cxii\", \"cxiii\", \"cxiv\", \"cxv\", \"cxvi\",\
    \ \"cxvii\", \"\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2j8esa38.scala:15:956 ----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mminiRoman\e[0m = Array(\e\
    [31m\"i\"\e[0m, \e[31m\"ii\"\e[0m, \e[31m\"iii\"\e[0m, \e[31m\"iv\"\e[0m, \e[31m\"\
    v\"\e[0m, \e[31m\"vi\"\e[0m, \e[31m\"vii\"\e[0m, \e[31m\"viii\"\e[0m, \e[31m\"\
    ix\"\e[0m, \e[31m\"x\"\e[0m, \e[31m\"xi\"\e[0m, \e[31m\"xii\"\e[0m, \e[31m\"xiii\"\
    \e[0m, \e[31m\"xiv\"\e[0m, \e[31m\"xv\"\e[0m, \e[31m\"xvi\"\e[0m, \e[31m\"xvii\"\
    \e[0m, \e[31m\"xviii\"\e[0m, \e[31m\"xix\"\e[0m, \e[31m\"xx\"\e[0m, \e[31m\"xxi\"\
    \e[0m, \e[31m\"xxii\"\e[0m, \e[31m\"xxiii\"\e[0m, \e[31m\"xxiv\"\e[0m, \e[31m\"\
    xxv\"\e[0m, \e[31m\"xxvi\"\e[0m, \e[31m\"xxvii\"\e[0m, \e[31m\"xxviii\"\e[0m,\
    \ \e[31m\"xxix\"\e[0m, \e[31m\"xxx\"\e[0m, \e[31m\"xxxi\"\e[0m, \e[31m\"xxxii\"\
    \e[0m, \e[31m\"xxxiii\"\e[0m, \e[31m\"xxxiv\"\e[0m, \e[31m\"xxxv\"\e[0m, \e[31m\"\
    xxxvi\"\e[0m, \e[31m\"xxxvii\"\e[0m, \e[31m\"xxxviii\"\e[0m, \e[31m\"xxxix\"\e\
    [0m, \e[31m\"xl\"\e[0m, \e[31m\"xli\"\e[0m, \e[31m\"xlii\"\e[0m, \e[31m\"xliii\"\
    \e[0m, \e[31m\"xliv\"\e[0m, \e[31m\"xlv\"\e[0m, \e[31m\"xlvi\"\e[0m, \e[31m\"\
    xlvii\"\e[0m, \e[31m\"xlviii\"\e[0m, \e[31m\"xlix\"\e[0m, \e[31m\"l\"\e[0m, \e\
    [31m\"li\"\e[0m, \e[31m\"lii\"\e[0m, \e[31m\"liii\"\e[0m, \e[31m\"liv\"\e[0m,\
    \ \e[31m\"lv\"\e[0m, \e[31m\"lvi\"\e[0m, \e[31m\"lvii\"\e[0m, \e[31m\"lviii\"\e\
    [0m, \e[31m\"lix\"\e[0m, \e[31m\"lx\"\e[0m, \e[31m\"lxi\"\e[0m, \e[31m\"lxii\"\
    \e[0m, \e[31m\"lxiii\"\e[0m, \e[31m\"lxiv\"\e[0m, \e[31m\"lxv\"\e[0m, \e[31m\"\
    lxvi\"\e[0m, \e[31m\"lxvii\"\e[0m, \e[31m\"lxviii\"\e[0m, \e[31m\"lxix\"\e[0m,\
    \ \e[31m\"lxx\"\e[0m, \e[31m\"lxxi\"\e[0m, \e[31m\"lxxii\"\e[0m, \e[31m\"lxxiii\"\
    \e[0m, \e[31m\"lxxiv\"\e[0m, \e[31m\"lxxv\"\e[0m, \e[31m\"lxxvi\"\e[0m, \e[31m\"\
    lxxvii\"\e[0m, \e[31m\"lxxviii\"\e[0m, \e[31m\"lxxix\"\e[0m, \e[31m\"lxxx\"\e\
    [0m, \e[31m\"lxxxi\"\e[0m, \e[31m\"lxxxii\"\e[0m, \e[31m\"lxxxiii\"\e[0m, \e[31m\"\
    lxxxiv\"\e[0m, \e[31m\"lxxxv\"\e[0m, \e[31m\"lxxxvi\"\e[0m, \e[31m\"lxxxvii\"\e\
    [0m, \e[31m\"lxxxviii\"\e[0m, \e[31m\"lxxxix\"\e[0m, \e[31m\"xc\"\e[0m, \e[31m\"\
    xci\"\e[0m, \e[31m\"xcii\"\e[0m, \e[31m\"xciii\"\e[0m, \e[31m\"xciv\"\e[0m, \e\
    [31m\"xcv\"\e[0m, \e[31m\"xcvi\"\e[0m, \e[31m\"xcvii\"\e[0m, \e[31m\"xcviii\"\e\
    [0m, \e[31m\"xcix\"\e[0m, \e[31m\"c\"\e[0m, \e[31m\"ci\"\e[0m, \e[31m\"cii\"\e\
    [0m, \e[31m\"ciii\"\e[0m, \e[31m\"civ\"\e[0m, \e[31m\"cv\"\e[0m, \e[31m\"cvi\"\
    \e[0m, \e[31m\"cvii\"\e[0m, \e[31m\"cviii\"\e[0m, \e[31m\"cix\"\e[0m, \e[31m\"\
    cx\"\e[0m, \e[31m\"cxi\"\e[0m, \e[31m\"cxii\"\e"
  stdout: ''
  timestamp: 1660010321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var res = new StringBuilder\n        var i = 0\n        while (number >\
    \ 0) {\n            i += 1\n            val digit = (number % 10).toInt\n    \
    \        if (digit > 0) res += intToMiniRomanSingle(digit, i)\n            number\
    \ /= 10\n        }\n        res.reverse.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpolod638i.scala:20:34 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (digit > \e[31m0\e[0m) res\
    \ += intToMiniRomanSingle(digit, i)\n\e[31m\e[31m   |\e[0m                   \
    \               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \               Not found: intToMiniRomanSingle\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpolod638i.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010322
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val (roman, _) = (\"M CM D CD C XC L XL X IX V IV I\".split(\" \").zipWithIndex.foldLeft((new\
    \ StringBuilder, number))((a, b) => {\n            val (s, n) = a\n          \
    \  val (str, index) = b\n            if (n >= 1000) {\n                val count\
    \ = n / 1000\n                (s.append(str * (count.toInt)), n % 1000)\n    \
    \        } else (s, n)\n        }))\n        roman.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvh8gf6cn.scala:26)\n\tat Problem.main(tmpvh8gf6cn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val lookup = Map[Long, Char](\n            1l -> 'i',\n            4l ->\
    \ 'v',\n            5l -> 'v',\n            9l -> 'x',\n            10l -> 'x',\n\
    \            40l -> 'l',\n            50l -> 'l',\n            90l -> 'c',\n \
    \           100l -> 'c',\n            400l -> 'd',\n            500l -> 'd',\n\
    \            900l -> 'm',\n            1000l -> 'm'\n        )\n        val keys\
    \ = lookup.keys.toList.sortWith(_ > _)\n        var number = number\n        var\
    \ result = \"\"\n        while (number > 0) {\n            var index = 0\n   \
    \         while (keys(index) > number) index += 1\n            val key = keys(index)\n\
    \            val count = number / key\n            result += lookup(key) * count.toInt\n\
    \            number -= key * count\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvcc36330.scala:31:21 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mnumber\e[0m = number\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m              \
    \       Recursive \e[33mvariable\e[0m \e[35mnumber\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val x = new Array[String](4)\n        x(0) = \"m\"\n        x(1) = \"c\"\
    \n        x(2) = \"x\"\n        x(3) = \"i\"\n        val f = new Array[(Long,\
    \ String)](4)\n        f(0) = (1000l, \"m\")\n        f(1) = (100l, \"c\")\n \
    \       f(2) = (10l, \"x\")\n        f(3) = (1l, \"i\")\n        val s = new Array[(Long,\
    \ String)](4)\n        s(0) = (900l, \"cm\")\n        s(1) = (90l, \"xc\")\n \
    \       s(2) = (9l, \"ix\")\n        s(3) = (4l, \"iv\")\n        val res = new\
    \ StringBuilder()\n        for (i <- 0 to 3) {\n            val n = (number %\
    \ (f(i)._1 * 10)) / f(i)._1\n            if (n == 0) {\n                ;\n  \
    \          } else if (n == 4 || n == 9) {\n                res.append(s(i)._2)\n\
    \            } else if (n < 4) {\n                res.append(f(i)._2 * n)\n  \
    \          } else {\n                res.append(f(i)._2 * (5 - n))\n         \
    \       res.append(x(i))\n            }\n        }\n        res.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqarlwg5r.scala:38:37\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                res.append(f(i)._2\
    \ * n)\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    (n : Long)\n\e[31m  \
    \ |\e[0m                                     Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqarlwg5r.scala:40:38 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                res.append(f(i)._2 * (\e[31m5\e[0m -\
    \ n))\n\e[31m\e[31m   |\e[0m                                      ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    Long\n\e[31m  \
    \ |\e[0m                                      Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010324
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tval parts = Array(\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\")\n    \tval tens = Array(\"\", \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\")\n    \tval digits\
    \ = Array(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\", \"x\")\n    \tval s = number.toString\n    \tval partsSize = parts.size\n\
    \    \tval tensSize = tens.size\n    \tval digitsSize = digits.size\n    \tval\
    \ len = s.length\n    \tvar res = \"\"\n    \tif (len == 4) {\n    \t\tres +=\
    \ parts(s(0).toString.toInt)\n    \t}\n    \tif (len >= 3) {\n    \t\tres += tens(s(len\
    \ - 3).toString.toInt)\n    \t}\n    \tif (len >= 2) {\n    \t\tres += digits(s(len\
    \ - 2).toString.toInt)\n    \t}\n    \tif (len >= 1) {\n    \t\tres += digits(s(len\
    \ - 1).toString.toInt)\n    \t}\n    \tres\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2mq4nc2d.scala:39)\n\tat Problem.main(tmp2mq4nc2d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Source: http://stackoverflow.com/questions/12967896/converting-integers-to-roman-numerals-java\n\
    \        val romanNumeralValues = Array(\n            Array(1000, \"m\"),\n  \
    \          Array(900, \"cm\"),\n            Array(500, \"d\"),\n            Array(400,\
    \ \"cd\"),\n            Array(100, \"c\"),\n            Array(90, \"xc\"),\n \
    \           Array(50, \"l\"),\n            Array(40, \"xl\"),\n            Array(10,\
    \ \"x\"),\n            Array(9, \"ix\"),\n            Array(5, \"v\"),\n     \
    \       Array(4, \"iv\"),\n            Array(1, \"i\")\n        )\n        val\
    \ romanNumeralStrings = romanNumeralValues.map(a => a(1))\n        val romanNumeralInts\
    \ = romanNumeralValues.map(a => a(0))\n        var remainder = number\n      \
    \  var result = \"\"\n        for (i <- 0 until romanNumeralValues.length) {\n\
    \            val div = remainder / romanNumeralInts(i)\n            remainder\
    \ = remainder % romanNumeralInts(i)\n            result += romanNumeralStrings(i)\
    \ * div\n        }\n        result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bjr8oec.scala:36:32 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mdiv\e[0m = remainder\
    \ / romanNumeralInts(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m/\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments (Matchable)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bjr8oec.scala:37:34\
    \ -----------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            remainder\
    \ = remainder % romanNumeralInts(i)\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m%\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments (Matchable)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8bjr8oec.scala:38:19 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            result += romanNumeralStrings(i) * div\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of String - did you mean String.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8bjr8oec.scala:38:45 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            result += romanNumeralStrings(i) * div\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue * is\
    \ not a member of Matchable, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e["
  stdout: ''
  timestamp: 1660010325
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val romanDigits = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n      val decimalDigits = List(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n      var n = number\n    \
    \  var romanStr = \"\"\n      for (i <- 0 to 12) {\n        while (n >= decimalDigits(i))\
    \ {\n          romanStr += romanDigits(i)\n          n -= decimalDigits(i)\n \
    \       }\n      }\n      romanStr\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010326
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0) return \"\"\n        val quotient = number / 10\n     \
    \   val remainder = number % 10\n        val prefix = quotient match {\n     \
    \       case 1 => \"x\"\n            case 2 => \"xx\"\n            case 3 => \"\
    xxx\"\n            case 4 => \"xl\"\n            case 5 => \"l\"\n           \
    \ case 6 => \"lx\"\n            case 7 => \"lxx\"\n            case 8 => \"lxxx\"\
    \n            case 9 => \"xc\"\n            case _ => \"\"\n        }\n      \
    \  val suffix = remainder match {\n            case 1 => \"i\"\n            case\
    \ 2 => \"ii\"\n            case 3 => \"iii\"\n            case 4 => \"iv\"\n \
    \           case 5 => \"v\"\n            case 6 => \"vi\"\n            case 7\
    \ => \"vii\"\n            case 8 => \"viii\"\n            case 9 => \"ix\"\n \
    \           case _ => \"\"\n        }\n        prefix + suffix\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3k_nly9h.scala:46)\n\tat Problem.main(tmp3k_nly9h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010325
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Map(\n            1 -> \"i\",\n            4 -> \"iv\",\n\
    \            5 -> \"v\",\n            9 -> \"ix\",\n            10 -> \"x\",\n\
    \            40 -> \"xl\",\n            50 -> \"l\",\n            90 -> \"xc\"\
    ,\n            100 -> \"c\",\n            400 -> \"cd\",\n            500 -> \"\
    d\",\n            900 -> \"cm\",\n            1000 -> \"m\"\n        )\n     \
    \   def helper(n : Long, acc : String) : String = n match {\n            case\
    \ 0 => acc\n            case i if (i >= 1000) => helper(i - 1000, acc + \"m\"\
    )\n            case i if (i >= 900) => helper(i - 900, acc + \"cm\")\n       \
    \     case i if (i >= 500) => helper(i - 500, acc + \"d\")\n            case i\
    \ if (i >= 400) => helper(i - 400, acc + \"cd\")\n            case i if (i >=\
    \ 100) => helper(i - 100, acc + \"c\")\n            case i if (i >= 90) => helper(i\
    \ - 90, acc + \"xc\")\n            case i if (i >= 50) => helper(i - 50, acc +\
    \ \"l\")\n            case i if (i >= 40) => helper(i - 40, acc + \"xl\")\n  \
    \          case i if (i >= 10) => helper(i - 10, acc + \"x\")\n            case\
    \ i if (i >= 9) => helper(i - 9, acc + \"ix\")\n            case i if (i >= 5)\
    \ => helper(i - 5, acc + \"v\")\n            case i if (i >= 4) => helper(i -\
    \ 4, acc + \"iv\")\n            case i if (i >= 1) => helper(i - 1, acc + \"i\"\
    )\n        }\n        helper(number, \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010327
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var buffer = new StringBuilder\n        while\
    \ (num >= 1000) {\n            buffer.append(\"m\")\n            num -= 1000\n\
    \        }\n        while (num >= 900) {\n            buffer.append(\"cm\")\n\
    \            num -= 900\n        }\n        while (num >= 500) {\n           \
    \ buffer.append(\"d\")\n            num -= 500\n        }\n        while (num\
    \ >= 400) {\n            buffer.append(\"cd\")\n            num -= 400\n     \
    \   }\n        while (num >= 100) {\n            buffer.append(\"c\")\n      \
    \      num -= 100\n        }\n        while (num >= 90) {\n            buffer.append(\"\
    xc\")\n            num -= 90\n        }\n        while (num >= 50) {\n       \
    \     buffer.append(\"l\")\n            num -= 50\n        }\n        while (num\
    \ >= 40) {\n            buffer.append(\"xl\")\n            num -= 40\n       \
    \ }\n        while (num >= 10) {\n            buffer.append(\"x\")\n         \
    \   num -= 10\n        }\n        while (num >= 9) {\n            buffer.append(\"\
    ix\")\n            num -= 9\n        }\n        while (num >= 5) {\n         \
    \   buffer.append(\"v\")\n            num -= 5\n        }\n        while (num\
    \ >= 4) {\n            buffer.append(\"iv\")\n            num -= 4\n        }\n\
    \        while (num >= 1) {\n            buffer.append(\"i\")\n            num\
    \ -= 1\n        }\n        buffer.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010326
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToRoman(number : Long, result : String) : String = {\n          \
    \  if (number == 0) result\n            else if (number >= 1 && number <= 9) {\n\
    \                val unit = \"i\" * number.toInt\n                intToRoman(0,\
    \ result + unit)\n            }\n            else if (number >= 10 && number <=\
    \ 99) {\n                val unit = \"x\" * (number / 10).toInt\n            \
    \    intToRoman(number % 10, result + unit)\n            }\n            else if\
    \ (number >= 100 && number <= 999) {\n                val unit = \"c\" * (number\
    \ / 100).toInt\n                intToRoman(number % 100, result + unit)\n    \
    \        }\n            else if (number >= 1000 && number <= 3999) {\n       \
    \         val unit = \"m\" * (number / 1000).toInt\n                intToRoman(number\
    \ % 1000, result + unit)\n            }\n            else throw new Exception(\"\
    Out of range\")\n        }\n        intToRoman(number, \"\").toLowerCase\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfcay5h3a.scala:38)\n\tat Problem.main(tmpfcay5h3a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000\n        var\
    \ numbers = Array(1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000)\n    \
    \    var numerals = Array(\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\",\
    \ \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\")\n        var s = \"\"\n       \
    \ var i = 12\n        while (number > 0) {\n            var times = number / numbers(i)\n\
    \            number %= numbers(i)\n            while (times > 0) {\n         \
    \       s += numerals(i)\n                times -= 1\n            }\n        \
    \    i -= 1\n        }\n        s\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbn8r5ftt.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            number %= numbers(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010325
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumerals = List(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"\
    )\n        def intToMiniRomanHelper(number : Long, place : Int) : String = {\n\
    \            if (number == 0) return \"\"\n            else {\n              \
    \  val digit = (number % 10).toInt\n                if (digit == 0) intToMiniRomanHelper(number\
    \ / 10, place + 1)\n                else if (digit == 4) romanNumerals(place *\
    \ 2) + romanNumerals((place * 2) + 1)\n                else if (digit == 9) romanNumerals(place\
    \ * 2) + romanNumerals((place * 2) + 2)\n                else if (digit < 4) romanNumerals(place\
    \ * 2) * digit\n                else romanNumerals((place * 2) + 1) + romanNumerals(place\
    \ * 2) * (digit - 5)\n            }\n        }\n        intToMiniRomanHelper(number,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz7fr_ojk.scala:30)\n\tat Problem.main(tmpz7fr_ojk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToMiniRoman0(number : Long, result : String) : String = number match\
    \ {\n            case 1 => result + \"i\"\n            case 2 => result + \"ii\"\
    \n            case 3 => result + \"iii\"\n            case 4 => result + \"iv\"\
    \n            case 5 => result + \"v\"\n            case 6 => result + \"vi\"\n\
    \            case 7 => result + \"vii\"\n            case 8 => result + \"viii\"\
    \n            case 9 => result + \"ix\"\n            case 10 => result + \"x\"\
    \n            case 11 => result + \"xi\"\n            case 12 => result + \"xii\"\
    \n            case 13 => result + \"xiii\"\n            case 14 => result + \"\
    xiv\"\n            case 15 => result + \"xv\"\n            case 16 => result +\
    \ \"xvi\"\n            case 17 => result + \"xvii\"\n            case 18 => result\
    \ + \"xviii\"\n            case 19 => result + \"xix\"\n            case 20 =>\
    \ result + \"xx\"\n            case 40 => result + \"xl\"\n            case 50\
    \ => result + \"l\"\n            case 60 => result + \"lx\"\n            case\
    \ 70 => result + \"lxx\"\n            case 80 => result + \"lxxx\"\n         \
    \   case 90 => result + \"xc\"\n            case 100 => result + \"c\"\n     \
    \       case 200 => result + \"cc\"\n            case 300 => result + \"ccc\"\n\
    \            case 400 => result + \"cd\"\n            case 500 => result + \"\
    d\"\n            case 600 => result + \"dc\"\n            case 700 => result +\
    \ \"dcc\"\n            case 800 => result + \"dccc\"\n            case 900 =>\
    \ result + \"cm\"\n            case 1000 => result + \"m\"\n            case _\
    \ =>\n                if (number < 10) intToMiniRoman0(number, \"\")\n       \
    \         else if (number < 100) intToMiniRoman0(number % 10, intToMiniRoman0(number\
    \ - number % 10, \"\"))\n                else if (number < 1000) intToMiniRoman0(number\
    \ % 100, intToMiniRoman0(number - number % 100, \"\"))\n                else intToMiniRoman0(number\
    \ % 1000, intToMiniRoman0(number\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhj_9o5k.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhj_9o5k.scala:76:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmpfhj_9o5k.scala:56:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m56 |\e[0m       \
    \         \e[33melse\e[0m intToMiniRoman0(number % \e[31m1000\e[0m, intToMiniRoman0(number\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter result of \e[33mmethod\e[0m\
    \ \e[35mintToMiniRoman0\e[0m: (number: Long, result: String): String\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfhj_9o5k.scala:75:1 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpfhj_9o5k.scala:58:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m58 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010327
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number > 1000 || number < 1)\n            throw new IllegalArgumentException(\"\
    Number is not between 1 and 1000!\")\n        var n = number\n        var roman\
    \ = new StringBuilder\n        var repeats = 0\n        for (i <- 0 to 3) {\n\
    \            val digit = n % 10\n            n /= 10\n            // println(\"\
    i = \" + i + \", digit = \" + digit)\n            if (digit == 0)\n          \
    \      repeats += 1\n            else {\n                if (repeats > 0) {\n\
    \                    roman.append(\"0\" * repeats)\n                    repeats\
    \ = 0\n                }\n                val one = \"0\" * i\n              \
    \  val five = one + \"v\"\n                val ten = five + \"x\"\n          \
    \      if (digit < 4)\n                    roman.append(one * digit)\n       \
    \         else if (digit == 4)\n                    roman.append(one + five)\n\
    \                else if (digit == 5)\n                    roman.append(five)\n\
    \                else if (digit < 9)\n                    roman.append(five +\
    \ one * (digit - 5))\n                else\n                    roman.append(one\
    \ + ten)\n            }\n        }\n        roman.toString.reverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp64zm165j.scala:35:39\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    roman.append(one\
    \ * digit)\n\e[31m\e[31m   |\e[0m                                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (digit :\
    \ Long)\n\e[31m   |\e[0m                                       Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp64zm165j.scala:41:47\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                    roman.append(five\
    \ + one * (digit - \e[31m5\e[0m))\n\e[31m\e[31m   |\e[0m                     \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010327
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = Array(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n \
    \       val base = 10l\n        var n = number\n        var result = List[String]()\n\
    \        while (n > 0) {\n            var pos = (log(n) / log(base)).toInt\n \
    \           if (pos % 2 == 1) pos += 1\n            val k = (pow(base, pos) /\
    \ pow(base, pos / 2)).toLong\n            val u = (n / k) * k\n            n -=\
    \ u\n            var w = u / pow(base, pos).toLong\n            var uc = \"\"\n\
    \            var d = \"\"\n            if (w >= 5) {\n                uc = symbols(pos\
    \ / 2 * 2 + 1)\n                w -= 5\n            }\n            if (w >= 1\
    \ && w <= 3) {\n                for (i <- 1 to w.toInt) d += symbols(pos / 2 *\
    \ 2)\n            }\n            if (w == 4) {\n                d = symbols(pos\
    \ / 2 * 2) + uc\n            }\n            result = (uc + d) :: result\n    \
    \    }\n        result.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp22zy27ho.scala:43)\n\tat Problem.main(tmp22zy27ho.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numeral = new StringBuilder\n        if (number < 1) throw new IllegalArgumentException\n\
    \        if (number >= 1000) {\n            for (i <- 1 to (number / 1000).toInt)\
    \ numeral.append(\"m\")\n            number %= 1000\n        }\n        if (number\
    \ >= 900) {\n            numeral.append(\"cm\")\n            number %= 900\n \
    \       }\n        if (number >= 500) {\n            numeral.append(\"d\")\n \
    \           number %= 500\n        }\n        if (number >= 400) {\n         \
    \   numeral.append(\"cd\")\n            number %= 400\n        }\n        if (number\
    \ >= 100) {\n            for (i <- 1 to (number / 100).toInt) numeral.append(\"\
    c\")\n            number %= 100\n        }\n        if (number >= 90) {\n    \
    \        numeral.append(\"xc\")\n            number %= 90\n        }\n       \
    \ if (number >= 50) {\n            numeral.append(\"l\")\n            number %=\
    \ 50\n        }\n        if (number >= 40) {\n            numeral.append(\"xl\"\
    )\n            number %= 40\n        }\n        if (number >= 10) {\n        \
    \    for (i <- 1 to (number / 10).toInt) numeral.append(\"x\")\n            number\
    \ %= 10\n        }\n        if (number >= 9) {\n            numeral.append(\"\
    ix\")\n            number %= 9\n        }\n        if (number >= 5) {\n      \
    \      numeral.append(\"v\")\n            number %= 5\n        }\n        if (number\
    \ >= 4) {\n            numeral.append(\"iv\")\n            number %= 4\n     \
    \   }\n        if (number >= 1) {\n            for (i <- 1 to number.toInt) numeral.append(\"\
    i\")\n        }\n        numeral.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            number %= \e[31m1000\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpb_d0qq_c.scala:23:19 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            number %= \e[31m900\e[0m\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member of Long\
    \ - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:27:19\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            number %= \e\
    [31m500\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value %= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number %= \e[31m400\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpb_d0qq_c.scala:35:19 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            number %= \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member of Long\
    \ - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:39:19\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            number %= \e\
    [31m90\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value %= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:43:19 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            number %= \e[31m50\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb_d0qq_c.scala:47:19\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            "
  stdout: ''
  timestamp: 1660010329
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = number.toString.toList.map(c => c.toString.toInt)\n       \
    \ val values = List(1000, 100, 10, 1)\n        val letters = Map(\n          \
    \  1000 -> \"m\",\n            900 -> \"cm\",\n            500 -> \"d\",\n   \
    \         400 -> \"cd\",\n            100 -> \"c\",\n            90 -> \"xc\"\
    ,\n            50 -> \"l\",\n            40 -> \"xl\",\n            10 -> \"x\"\
    ,\n            9 -> \"ix\",\n            5 -> \"v\",\n            4 -> \"iv\"\
    ,\n            1 -> \"i\"\n        )\n        val toLetters = Map(\n         \
    \   0 -> \"\",\n            1 -> \"i\",\n            2 -> \"ii\",\n          \
    \  3 -> \"iii\",\n            4 -> \"iv\",\n            5 -> \"v\",\n        \
    \    6 -> \"vi\",\n            7 -> \"vii\",\n            8 -> \"viii\",\n   \
    \         9 -> \"ix\"\n        )\n        if (number < 1 || number > 1000) throw\
    \ new IllegalArgumentException(\"number must be between 1 and 1000 inclusive\"\
    )\n        var num = number\n        val result = new StringBuilder\n        for\
    \ (i <- 0 to 3) {\n            val valPlace = values(i)\n            val curr\
    \ = digits(i)\n            if (curr == 0) {\n                num -= curr * valPlace\n\
    \            } else {\n                if (curr == 4 || curr == 9) {\n       \
    \             result.append(letters(curr * valPlace))\n                    num\
    \ -= curr * valPlace\n                } else {\n                    val letter\
    \ = letters(valPlace)\n                    result.append(toLetters(curr))\n  \
    \                  num -= curr * valPlace\n                }\n            }\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.intToMiniRoman$$anonfun$1(tmps8gdqcsm.scala:49)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.intToMiniRoman(tmps8gdqcsm.scala:62)\n\
    \tat Problem$.main(tmps8gdqcsm.scala:66)\n\tat Problem.main(tmps8gdqcsm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010330
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        var result = new StringBuilder()\n        val mapping\
    \ = Array[(String, Long)](\n            (\"m\", 1000),\n            (\"cm\", 900),\n\
    \            (\"d\", 500),\n            (\"cd\", 400),\n            (\"c\", 100),\n\
    \            (\"xc\", 90),\n            (\"l\", 50),\n            (\"xl\", 40),\n\
    \            (\"x\", 10),\n            (\"ix\", 9),\n            (\"v\", 5),\n\
    \            (\"iv\", 4),\n            (\"i\", 1)\n        )\n        while (n\
    \ > 0) {\n            val filtered = mapping.filter(p => p._2 <= n)\n        \
    \    val (key, value) = filtered.apply(0)\n            result.append(key)\n  \
    \          n -= value\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010329
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val map = Map(1l -> \"i\", 2l -> \"ii\", 3l -> \"iii\", 4l -> \"iv\", 5l\
    \ -> \"v\", 6l -> \"vi\", 7l -> \"vii\", 8l -> \"viii\", 9l -> \"ix\", 10l ->\
    \ \"x\", 20l -> \"xx\", 30l -> \"xxx\", 40l -> \"xl\", 50l -> \"l\", 60l -> \"\
    lx\", 70l -> \"lxx\", 80l -> \"lxxx\", 90l -> \"xc\", 100l -> \"c\", 200l -> \"\
    cc\", 300l -> \"ccc\", 400l -> \"cd\", 500l -> \"d\", 600l -> \"dc\", 700l ->\
    \ \"dcc\", 800l -> \"dccc\", 900l -> \"cm\", 1000l -> \"m\")\n        val factors\
    \ = Array(1000l, 900l, 500l, 400l, 100l, 90l, 50l, 40l, 10l, 9l, 5l, 4l, 1l)\n\
    \        val factorsQueue = new Queue[Long]()\n        factors.map(factorsQueue.enqueue(_))\n\
    \        var curr = number\n        var result = \"\"\n        while (!factorsQueue.isEmpty)\
    \ {\n            val factor = factorsQueue.front\n            if (curr - factor\
    \ >= 0) {\n                result += map(factor)\n                curr -= factor\n\
    \            } else {\n                factorsQueue.dequeue\n            }\n \
    \       }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010331
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // TODO\n        \"\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8lo4kcsj.scala:19)\n\tat Problem.main(tmp8lo4kcsj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010330
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var num = number\n        while (num >= 1000)\
    \ {\n            result += \"m\"\n            num -= 1000\n        }\n       \
    \ if (num >= 900) {\n            result += \"cm\"\n            num -= 900\n  \
    \      }\n        if (num >= 500) {\n            result += \"d\"\n           \
    \ num -= 500\n        }\n        if (num >= 400) {\n            result += \"cd\"\
    \n            num -= 400\n        }\n        while (num >= 100) {\n          \
    \  result += \"c\"\n            num -= 100\n        }\n        if (num >= 90)\
    \ {\n            result += \"xc\"\n            num -= 90\n        }\n        if\
    \ (num >= 50) {\n            result += \"l\"\n            num -= 50\n        }\n\
    \        if (num >= 40) {\n            result += \"xl\"\n            num -= 40\n\
    \        }\n        while (num >= 10) {\n            result += \"x\"\n       \
    \     num -= 10\n        }\n        if (num >= 9) {\n            result += \"\
    ix\"\n            num -= 9\n        }\n        if (num >= 5) {\n            result\
    \ += \"v\"\n            num -= 5\n        }\n        if (num >= 4) {\n       \
    \     result += \"iv\"\n            num -= 4\n        }\n        while (num >=\
    \ 1) {\n            result += \"i\"\n            num -= 1\n        }\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010332
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var s = \"\"\n        var n = number\n        while (n >= 1000) {\n    \
    \        s += \"m\"\n            n -= 1000\n        }\n        if (n >= 900) {\n\
    \            s += \"cm\"\n            n -= 900\n        }\n        while (n >=\
    \ 500) {\n            s += \"d\"\n            n -= 500\n        }\n        if\
    \ (n >= 400) {\n            s += \"cd\"\n            n -= 400\n        }\n   \
    \     while (n >= 100) {\n            s += \"c\"\n            n -= 100\n     \
    \   }\n        if (n >= 90) {\n            s += \"xc\"\n            n -= 90\n\
    \        }\n        while (n >= 50) {\n            s += \"l\"\n            n -=\
    \ 50\n        }\n        if (n >= 40) {\n            s += \"xl\"\n           \
    \ n -= 40\n        }\n        while (n >= 10) {\n            s += \"x\"\n    \
    \        n -= 10\n        }\n        if (n >= 9) {\n            s += \"ix\"\n\
    \            n -= 9\n        }\n        while (n >= 5) {\n            s += \"\
    v\"\n            n -= 5\n        }\n        if (n >= 4) {\n            s += \"\
    iv\"\n            n -= 4\n        }\n        while (n >= 1) {\n            s +=\
    \ \"i\"\n            n -= 1\n        }\n        s\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010332
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val m = number / 1000\n        val c = (number % 1000) / 100\n        val\
    \ x = (number % 100) / 10\n        val i = number % 10\n        (\"m\" * m) +\
    \ (\"c\" * c) + (\"x\" * x) + (\"i\" * i)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1tgj6bay.scala:19:15\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        (\e[31m\"m\"\e[0m * m)\
    \ + (\e[31m\"c\"\e[0m * c) + (\e[31m\"x\"\e[0m * x) + (\e[31m\"i\"\e[0m * i)\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (m : Long)\n\e[31m   |\e[0m               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1tgj6bay.scala:19:27 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        (\e[31m\"m\"\e[0m * m) + (\e[31m\"c\"\e[0m *\
    \ c) + (\e[31m\"x\"\e[0m * x) + (\e[31m\"i\"\e[0m * i)\n\e[31m\e[31m   |\e[0m\
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \ Found:    (c : Long)\n\e[31m   |\e[0m                           Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1tgj6bay.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        (\e[31m\"m\"\e[0m * m)\
    \ + (\e[31m\"c\"\e[0m * c) + (\e[31m\"x\"\e[0m * x) + (\e[31m\"i\"\e[0m * i)\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                       Found:    (x : Long)\n\e[31m   |\e[0m\
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1tgj6bay.scala:19:51 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        (\e[31m\"m\"\e[0m * m) + (\e[31m\"c\"\e[0m *\
    \ c) + (\e[31m\"x\"\e[0m * x) + (\e[31m\"i\"\e[0m * i)\n\e[31m\e[31m   |\e[0m\
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                                 Found:    (i : Long)\n\e[31m\
    \   |\e[0m                                                   Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010332
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def inner(result : String, base10 : Long) : String = {\n            if (base10\
    \ > 1000) throw new RuntimeException(\"base10 can't be greater than 1000: \" +\
    \ base10)\n            if (base10 == 0) result\n            else if (base10 >=\
    \ 1000) inner(result + \"m\", base10 - 1000)\n            else if (base10 >= 900)\
    \ inner(result + \"cm\", base10 - 900)\n            else if (base10 >= 500) inner(result\
    \ + \"d\", base10 - 500)\n            else if (base10 >= 400) inner(result + \"\
    cd\", base10 - 400)\n            else if (base10 >= 100) inner(result + \"c\"\
    , base10 - 100)\n            else if (base10 >= 90) inner(result + \"xc\", base10\
    \ - 90)\n            else if (base10 >= 50) inner(result + \"l\", base10 - 50)\n\
    \            else if (base10 >= 40) inner(result + \"xl\", base10 - 40)\n    \
    \        else if (base10 >= 10) inner(result + \"x\", base10 - 10)\n         \
    \   else if (base10 >= 9) inner(result + \"ix\", base10 - 9)\n            else\
    \ if (base10 >= 5) inner(result + \"v\", base10 - 5)\n            else if (base10\
    \ >= 4) inner(result + \"iv\", base10 - 4)\n            else if (base10 >= 1)\
    \ inner(result + \"i\", base10 - 1)\n            else throw new RuntimeException(\"\
    Shouldn't reach here\")\n        }\n        inner(\"\", number).toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010332
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder();\n        var n = number;\n        for\
    \ (i <- 1 to (floor(log10(n)) + 1).toInt) {\n            val digit = n % 10;\n\
    \            if (digit == 9) {\n                result.append(str((n - 9) % 1000\
    \ / 100) + str(n % 100 / 10));\n            } else if (digit >= 5) {\n       \
    \         result.append(str(n % 1000 / 100) + str((n - 5) % 100 / 10));\n    \
    \        } else if (digit == 4) {\n                result.append(str((n - 4) %\
    \ 1000 / 100) + str(n % 100 / 10));\n            } else {\n                result.append(str(n\
    \ % 1000 / 100) * digit);\n            }\n            n /= 10;\n        }\n  \
    \      result.reverse.toString();\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1qth3h4d.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result.append(str((n - \e[31m9\e[0m)\
    \ % \e[31m1000\e[0m / \e[31m100\e[0m) + str(n % \e[31m100\e[0m / \e[31m10\e[0m));\n\
    \e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e[31m   |\e[0m \
    \                             Not found: str\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1qth3h4d.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                result.append(str(n % \e[31m1000\e[0m\
    \ / \e[31m100\e[0m) + str((n - \e[31m5\e[0m) % \e[31m100\e[0m / \e[31m10\e[0m));\n\
    \e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e[31m   |\e[0m \
    \                             Not found: str\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1qth3h4d.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                result.append(str((n - \e[31m4\e[0m)\
    \ % \e[31m1000\e[0m / \e[31m100\e[0m) + str(n % \e[31m100\e[0m / \e[31m10\e[0m));\n\
    \e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\e[31m   |\e[0m \
    \                             Not found: str\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1qth3h4d.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                result.append(str(n % \e[31m1000\e[0m\
    \ / \e[31m100\e[0m) * digit);\n\e[31m\e[31m   |\e[0m                         \
    \     ^^^\e[0m\n\e[31m   |\e[0m                              Not found: str\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010331
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = new StringBuilder\n        var remain = number\n        var\
    \ subtract = (0l, \"\")\n        while (remain > 0) {\n            if (remain\
    \ >= 1000) {\n                roman.append(\"m\")\n                remain -= 1000\n\
    \            } else if (remain >= 900) {\n                roman.append(\"cm\"\
    )\n                remain -= 900\n            } else if (remain >= 500) {\n  \
    \              roman.append(\"d\")\n                remain -= 500\n          \
    \  } else if (remain >= 400) {\n                roman.append(\"cd\")\n       \
    \         remain -= 400\n            } else if (remain >= 100) {\n           \
    \     roman.append(\"c\")\n                remain -= 100\n            } else if\
    \ (remain >= 90) {\n                roman.append(\"xc\")\n                remain\
    \ -= 90\n            } else if (remain >= 50) {\n                roman.append(\"\
    l\")\n                remain -= 50\n            } else if (remain >= 40) {\n \
    \               roman.append(\"xl\")\n                remain -= 40\n         \
    \   } else if (remain >= 10) {\n                roman.append(\"x\")\n        \
    \        remain -= 10\n            } else if (remain >= 9) {\n               \
    \ roman.append(\"ix\")\n                remain -= 9\n            } else if (remain\
    \ >= 5) {\n                roman.append(\"v\")\n                remain -= 5\n\
    \            } else if (remain >= 4) {\n                roman.append(\"iv\")\n\
    \                remain -= 4\n            } else if (remain >= 1) {\n        \
    \        roman.append(\"i\")\n                remain -= 1\n            }\n   \
    \     }\n        roman.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010337
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0 || number > 1000) {\n            throw new IllegalArgumentException\n\
    \        }\n        val romanNum = number.toString.reverse.map(digit => {\n  \
    \          val digitValue = digit.asDigit\n            var symbols = \"\"\n  \
    \          val symbolsList = List(\"i\", \"x\", \"c\", \"m\")\n            if\
    \ (digitValue == 9) {\n                symbols = symbolsList(0) + symbolsList(1)\n\
    \            } else if (digitValue == 4) {\n                symbols = symbolsList(0)\
    \ + symbolsList(1)\n            } else {\n                var left = digitValue\n\
    \                if (left >= 5) {\n                    symbols += symbolsList(1)\n\
    \                    left -= 5\n                }\n                if (left ==\
    \ 4) {\n                    symbols = symbolsList(0) + symbols\n             \
    \   } else {\n                    symbols += symbolsList(0) * left\n         \
    \       }\n            }\n            symbols\n        }).mkString(\"\").reverse\n\
    \        return romanNum\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt_cuwe0p.scala:43)\n\tat Problem.main(tmpt_cuwe0p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010338
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = List((\"m\", 1000), (\"cm\", 900), (\"d\", 500), (\"cd\",\
    \ 400), (\"c\", 100), (\"xc\", 90), (\"l\", 50), (\"xl\", 40), (\"x\", 10), (\"\
    ix\", 9), (\"v\", 5), (\"iv\", 4), (\"i\", 1))\n        var reducedNumber = number\n\
    \        var roman = \"\"\n        for ((symbol, number) <- symbols) {\n     \
    \       roman += symbol * (reducedNumber / number).toInt\n            reducedNumber\
    \ %= number\n        }\n        roman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010337
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val thousands = number / 1000\n        val hundreds = (number - thousands\
    \ * 1000) / 100\n        val tens = (number - thousands * 1000 - hundreds * 100)\
    \ / 10\n        val ones = number - thousands * 1000 - hundreds * 100 - tens *\
    \ 10\n        val thousandsString = (1 to thousands.toInt).map(x => \"m\").mkString\n\
    \        val hundredsString = if (hundreds == 9) \"cm\" else if (hundreds == 4)\
    \ \"cd\" else {\n            val hundredsString = (1 to hundreds.toInt).map(x\
    \ => \"c\").mkString\n            if (hundreds > 4) \"d\" + hundredsString else\
    \ hundredsString\n        }\n        val tensString = if (tens == 9) \"xc\" else\
    \ if (tens == 4) \"xl\" else {\n            val tensString = (1 to tens.toInt).map(x\
    \ => \"x\").mkString\n            if (tens > 4) \"l\" + tensString else tensString\n\
    \        }\n        val onesString = if (ones == 9) \"ix\" else if (ones == 4)\
    \ \"iv\" else {\n            val onesString = (1 to ones.toInt).map(x => \"i\"\
    ).mkString\n            if (ones > 4) \"v\" + onesString else onesString\n   \
    \     }\n        thousandsString + hundredsString + tensString + onesString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3k7ivqz1.scala:36)\n\tat Problem.main(tmp3k7ivqz1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman_map = Map(\n            100l -> \"c\",\n            90l -> \"\
    xc\",\n            50l -> \"l\",\n            40l -> \"xl\",\n            10l\
    \ -> \"x\",\n            9l -> \"ix\",\n            5l -> \"v\",\n           \
    \ 4l -> \"iv\",\n            1l -> \"i\"\n        )\n        val keys = roman_map.keys.toList.sortWith(_\
    \ > _)\n        def sub(keys : List[Long], number : Long, acc : String) : String\
    \ = keys match {\n            case key :: xs => {\n                val times =\
    \ number / key\n                val remain = number % key\n                sub(xs,\
    \ remain, acc + (roman_map(key) * times))\n            }\n            case Nil\
    \ => acc\n        }\n        sub(keys, number, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpppoape5q.scala:31:56\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                sub(xs, remain,\
    \ acc + (roman_map(key) * times))\n\e[31m\e[31m   |\e[0m                     \
    \                                   ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                  Found:    (times : Long)\n\e[31m   |\e[0m \
    \                                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010336
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder()\n        var n = number\n        if (n\
    \ >= 1000) {\n            for (i <- 1 to (n / 1000).toInt) {\n               \
    \ result.append(\"m\")\n            }\n            n = n % 1000\n        }\n \
    \       if (n >= 900) {\n            result.append(\"cm\")\n            n = n\
    \ % 900\n        }\n        if (n >= 500) {\n            result.append(\"d\")\n\
    \            n = n % 500\n        }\n        if (n >= 400) {\n            result.append(\"\
    cd\")\n            n = n % 400\n        }\n        if (n >= 100) {\n         \
    \   for (i <- 1 to (n / 100).toInt) {\n                result.append(\"c\")\n\
    \            }\n            n = n % 100\n        }\n        if (n >= 90) {\n \
    \           result.append(\"xc\")\n            n = n % 90\n        }\n       \
    \ if (n >= 50) {\n            result.append(\"l\")\n            n = n % 50\n \
    \       }\n        if (n >= 40) {\n            result.append(\"xl\")\n       \
    \     n = n % 40\n        }\n        if (n >= 10) {\n            for (i <- 1 to\
    \ (n / 10).toInt) {\n                result.append(\"x\")\n            }\n   \
    \         n = n % 10\n        }\n        if (n >= 9) {\n            result.append(\"\
    ix\")\n            n = n % 9\n        }\n        if (n >= 5) {\n            result.append(\"\
    v\")\n            n = n % 5\n        }\n        if (n >= 4) {\n            result.append(\"\
    iv\")\n            n = n % 4\n        }\n        if (n >= 1) {\n            for\
    \ (i <- 1 to n.toInt) {\n                result.append(\"i\")\n            }\n\
    \        }\n        return result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0) return \"\"\n        else {\n            var n = number\n\
    \            var s = \"\";\n            var p = 1000\n            while (n > 0)\
    \ {\n                var q = n / p\n                n -= q * p\n             \
    \   for (j <- 0 until q.toInt) s += p match {\n                    case 1000 =>\
    \ \"m\"\n                    case 500 => \"d\"\n                    case 100 =>\
    \ \"c\"\n                    case 50 => \"l\"\n                    case 10 =>\
    \ \"x\"\n                    case 5 => \"v\"\n                    case 1 => \"\
    i\"\n                }\n                p /= 10\n            }\n            return\
    \ s.replace(\"dcccc\", \"cm\").replace(\"cccc\", \"cd\").replace(\"lxxxx\", \"\
    xc\").replace(\"xxxx\", \"xl\").replace(\"viiii\", \"ix\").replace(\"iiii\", \"\
    iv\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:24:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    \e[33mcase\e[0m \e[31m1000\e[0m =>\
    \ \e[31m\"m\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e\
    [31m   |\e[0m           Values of types Int and Unit cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:25:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mcase\e[0m \e[31m500\e[0m =>\
    \ \e[31m\"d\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e\
    [31m   |\e[0m           Values of types Int and Unit cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:26:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33mcase\e[0m \e[31m100\e[0m =>\
    \ \e[31m\"c\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e\
    [31m   |\e[0m           Values of types Int and Unit cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:27:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    \e[33mcase\e[0m \e[31m50\e[0m =>\
    \ \e[31m\"l\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^\e[0m\n\e\
    [31m   |\e[0m           Values of types Int and Unit cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:28:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mcase\e[0m \e[31m10\e[0m =>\
    \ \e[31m\"x\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^\e[0m\n\e\
    [31m   |\e[0m           Values of types Int and Unit cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:29:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mcase\e[0m \e[31m5\e[0m => \e\
    [31m\"v\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m \
    \  |\e[0m           Values of types Int and Unit cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmptq2fbu36.scala:30:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mcase\e[0m \e[31m1\e[0m => \e\
    [31m\"i\"\e[0m\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660010338
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var cur = number\n        var ret = new StringBuilder\n        val rom =\
    \ List((\"m\", 1000), (\"d\", 500), (\"c\", 100), (\"l\", 50), (\"x\", 10), (\"\
    v\", 5), (\"i\", 1))\n        for ((r, v) <- rom) {\n            var count = cur\
    \ / v\n            while (count > 0) {\n                ret.append(r)\n      \
    \          count -= 1\n            }\n            cur %= v\n        }\n      \
    \  return ret.toString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiyy6q2xk.scala:29)\n\tat Problem.main(tmpiyy6q2xk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010338
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var res = new StringBuilder()\n        while (num\
    \ >= 1000) {\n            res.append(\"m\")\n            num -= 1000\n       \
    \ }\n        while (num >= 900) {\n            res.append(\"cm\")\n          \
    \  num -= 900\n        }\n        while (num >= 500) {\n            res.append(\"\
    d\")\n            num -= 500\n        }\n        while (num >= 400) {\n      \
    \      res.append(\"cd\")\n            num -= 400\n        }\n        while (num\
    \ >= 100) {\n            res.append(\"c\")\n            num -= 100\n        }\n\
    \        while (num >= 90) {\n            res.append(\"xc\")\n            num\
    \ -= 90\n        }\n        while (num >= 50) {\n            res.append(\"l\"\
    )\n            num -= 50\n        }\n        while (num >= 40) {\n           \
    \ res.append(\"xl\")\n            num -= 40\n        }\n        while (num >=\
    \ 10) {\n            res.append(\"x\")\n            num -= 10\n        }\n   \
    \     while (num >= 9) {\n            res.append(\"ix\")\n            num -= 9\n\
    \        }\n        while (num >= 5) {\n            res.append(\"v\")\n      \
    \      num -= 5\n        }\n        while (num >= 4) {\n            res.append(\"\
    iv\")\n            num -= 4\n        }\n        while (num >= 1) {\n         \
    \   res.append(\"i\")\n            num -= 1\n        }\n        res.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Algorithm description:\n        // The given number is repeatedly divided\
    \ by 1000, 100, 10, and 1, to obtain\n        // the digit in each of the 1000,\
    \ 100, 10, and 1 place.\n        // The mini roman number for each digit is obtained\
    \ by calling\n        // miniRomanNumeral(digit, place), which returns the mini\
    \ roman number for the\n        // given digit and the position the digit is in.\
    \ For example, miniRomanNumeral(3,\n        // 100) will return \"ccc\", miniRomanNumeral(4,\
    \ 10) will return \"xl\", and\n        // miniRomanNumeral(9, 1) will return \"\
    ix\".\n        // The mini roman number for each digit is appended to the answer.\n\
    \        val digits = List(1000, 100, 10, 1)\n        var number1 = number\n \
    \       var answer = \"\"\n        for (digit <- digits) {\n            val div\
    \ = number1 / digit\n            number1 = number1 % digit\n            answer\
    \ += miniRomanNumeral(div, digit)\n        }\n        answer\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdrwsv4tr.scala:30:19 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            answer += miniRomanNumeral(div, digit)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpdrwsv4tr.scala:30:22 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            answer += miniRomanNumeral(div, digit)\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  Not found: miniRomanNumeral\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010337
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val base = List(List(\"\",\"i\",\"ii\",\"iii\",\"iv\",\"v\",\"vi\",\"vii\"\
    ,\"viii\",\"ix\"),List(\"\",\"x\",\"xx\",\"xxx\",\"xl\",\"l\",\"lx\",\"lxx\",\"\
    lxxx\",\"xc\"),List(\"\",\"c\",\"cc\",\"ccc\",\"cd\",\"d\",\"dc\",\"dcc\",\"dccc\"\
    ,\"cm\"),List(\"\",\"m\",\"mm\",\"mmm\"))\n        var num = number\n        var\
    \ index = 0\n        var result = \"\"\n        while (num > 0) {\n          \
    \  result = base(index)((num % 10).toInt) + result\n            num /= 10\n  \
    \          index += 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010339
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var result = \"\"\n        while (num >= 1000)\
    \ { result += \"m\"; num -= 1000 }\n        while (num >= 500) { result += \"\
    d\"; num -= 500 }\n        while (num >= 100) { result += \"c\"; num -= 100 }\n\
    \        while (num >= 50) { result += \"l\"; num -= 50 }\n        while (num\
    \ >= 10) { result += \"x\"; num -= 10 }\n        while (num >= 5) { result +=\
    \ \"v\"; num -= 5 }\n        while (num >= 1) { result += \"i\"; num -= 1 }\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplqs5a8f9.scala:27)\n\tat Problem.main(tmplqs5a8f9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = List(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n   \
    \     var miniroman = new StringBuilder\n        var n = number\n        var position\
    \ = romans.length - 1\n        while (n > 0) {\n            val div = n / 10\n\
    \            var temp = n - div * 10\n            n = div\n            if (temp\
    \ == 0) {\n                position -= 2\n            } else if (temp <= 3) {\n\
    \                miniroman append romans(position) * temp\n            } else\
    \ if (temp == 4) {\n                miniroman append romans(position)\n      \
    \          miniroman append romans(position + 1)\n            } else if (temp\
    \ <= 8) {\n                miniroman append romans(position + 1)\n           \
    \     miniroman append romans(position) * (temp - 5)\n            } else {\n \
    \               miniroman append romans(position)\n                miniroman append\
    \ romans(position + 2)\n            }\n            position -= 2\n        }\n\
    \        miniroman.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_72n4fb.scala:26:52\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                miniroman append\
    \ romans(position) * temp\n\e[31m\e[31m   |\e[0m                             \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                      Found:    (temp : Long)\n\e[31m   |\e[0m              \
    \                                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpn_72n4fb.scala:32:53 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                miniroman append romans(position) * (temp\
    \ - \e[31m5\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010340
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        val romanToIntMap = Map(\"M\" -> 1000, \"D\" ->\
    \ 500, \"C\" -> 100, \"L\" -> 50, \"X\" -> 10, \"V\" -> 5, \"I\" -> 1)\n     \
    \   val intToRomanMap = romanToIntMap.map(_.swap)\n        val roman = new StringBuilder\n\
    \        while (n > 0) {\n            val m = intToRomanMap.toList.sortBy(_._1).reverse.find(_._1\
    \ <= n).get\n            roman ++= m._2\n            n -= m._1\n        }\n  \
    \      roman.toString.toLowerCase\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphumbfwe8.scala:27)\n\tat Problem.main(tmphumbfwe8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010342
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var outputString = \"\"\n        var workingCopy = number\n        while\
    \ (workingCopy >= 1000) {\n            outputString += \"m\"\n            workingCopy\
    \ -= 1000\n        }\n        while (workingCopy >= 900) {\n            outputString\
    \ += \"cm\"\n            workingCopy -= 900\n        }\n        while (workingCopy\
    \ >= 500) {\n            outputString += \"d\"\n            workingCopy -= 500\n\
    \        }\n        while (workingCopy >= 400) {\n            outputString +=\
    \ \"cd\"\n            workingCopy -= 400\n        }\n        while (workingCopy\
    \ >= 100) {\n            outputString += \"c\"\n            workingCopy -= 100\n\
    \        }\n        while (workingCopy >= 90) {\n            outputString += \"\
    xc\"\n            workingCopy -= 90\n        }\n        while (workingCopy >=\
    \ 50) {\n            outputString += \"l\"\n            workingCopy -= 50\n  \
    \      }\n        while (workingCopy >= 40) {\n            outputString += \"\
    xl\"\n            workingCopy -= 40\n        }\n        while (workingCopy >=\
    \ 10) {\n            outputString += \"x\"\n            workingCopy -= 10\n  \
    \      }\n        while (workingCopy >= 9) {\n            outputString += \"ix\"\
    \n            workingCopy -= 9\n        }\n        while (workingCopy >= 5) {\n\
    \            outputString += \"v\"\n            workingCopy -= 5\n        }\n\
    \        while (workingCopy >= 4) {\n            outputString += \"iv\"\n    \
    \        workingCopy -= 4\n        }\n        while (workingCopy >= 1) {\n   \
    \         outputString += \"i\"\n            workingCopy -= 1\n        }\n   \
    \     return outputString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010340
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tvar ans = \"\"\n    \tval (numeral, valu) = ((Map(\"i\" -> 1, \"v\" -> 5,\
    \ \"x\" -> 10, \"l\" -> 50, \"c\" -> 100, \"d\" -> 500, \"m\" -> 1000), \n   \
    \ \t\tMap(\"i\" -> \"\", \"v\" -> \"i\", \"x\" -> \"ii\", \"l\" -> \"iii\", \"\
    c\" -> \"iiii\", \"d\" -> \"iiiii\", \"m\" -> \"iiiiii\")))\n    \tvar num = number\n\
    \    \tfor (n <- numeral.keys.toList.reverse) {\n    \t\twhile (num >= numeral(n))\
    \ {\n    \t\t\tans += n\n    \t\t\tnum -= numeral(n)\n    \t\t}\n    \t\tif (num\
    \ == 0) return ans\n    \t\twhile (num >= numeral(n) - numeral(valu(n))) {\n \
    \   \t\t\tans += valu(n) + n\n    \t\t\tnum -= numeral(n) - numeral(valu(n))\n\
    \    \t\t}\n    \t}\n    \tans\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: iiiiii\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.intToMiniRoman$$anonfun$1(tmp96ow0bhy.scala:25)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.intToMiniRoman(tmp96ow0bhy.scala:29)\n\
    \tat Problem$.main(tmp96ow0bhy.scala:33)\n\tat Problem.main(tmp96ow0bhy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010343
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Vector(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val divisors = Vector(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var remain = number\n\
    \        var result = \"\"\n        for ((n, d) <- numerals zip divisors) {\n\
    \            var q = remain / d\n            remain -= q * d\n            for\
    \ (i <- 1 to q.toInt) result += n\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010343
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumerals = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val arabicNumerals\
    \ = List(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        if (number\
    \ <= 0 || number > 1000) {\n            throw new IllegalArgumentException(\"\
    Number must be between 1 and 1000 (inclusive).\")\n        }\n        var num\
    \ = number\n        var roman = \"\"\n        for (i <- 0 to romanNumerals.length\
    \ - 1) {\n            while (num >= arabicNumerals(i)) {\n                roman\
    \ += romanNumerals(i)\n                num -= arabicNumerals(i)\n            }\n\
    \        }\n        roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010343
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        val romanDigits = Map(1 -> \"i\", 4 -> \"iv\"\
    , 5 -> \"v\", 9 -> \"ix\", 10 -> \"x\", 40 -> \"xl\", 50 -> \"l\", 90 -> \"xc\"\
    , 100 -> \"c\", 400 -> \"cd\", 500 -> \"d\", 900 -> \"cm\", 1000 -> \"m\")\n \
    \       var romanNumber = \"\"\n        while (num > 0) {\n            var largestDigit\
    \ = 0\n            for (digit <- romanDigits.keys) {\n                if (digit\
    \ <= num) largestDigit = digit\n            }\n            romanNumber += romanDigits(largestDigit)\n\
    \            num -= largestDigit\n        }\n        romanNumber\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5s7naunq.scala:30)\n\tat Problem.main(tmp5s7naunq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010344
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder\n        var currentNumber = number\n   \
    \     while (currentNumber > 0) {\n            if (currentNumber >= 1000) {\n\
    \                result.append(\"m\")\n                currentNumber -= 1000\n\
    \            } else if (currentNumber >= 900) {\n                result.append(\"\
    cm\")\n                currentNumber -= 900\n            } else if (currentNumber\
    \ >= 500) {\n                result.append(\"d\")\n                currentNumber\
    \ -= 500\n            } else if (currentNumber >= 400) {\n                result.append(\"\
    cd\")\n                currentNumber -= 400\n            } else if (currentNumber\
    \ >= 100) {\n                result.append(\"c\")\n                currentNumber\
    \ -= 100\n            } else if (currentNumber >= 90) {\n                result.append(\"\
    xc\")\n                currentNumber -= 90\n            } else if (currentNumber\
    \ >= 50) {\n                result.append(\"l\")\n                currentNumber\
    \ -= 50\n            } else if (currentNumber >= 40) {\n                result.append(\"\
    xl\")\n                currentNumber -= 40\n            } else if (currentNumber\
    \ >= 10) {\n                result.append(\"x\")\n                currentNumber\
    \ -= 10\n            } else if (currentNumber >= 9) {\n                result.append(\"\
    ix\")\n                currentNumber -= 9\n            } else if (currentNumber\
    \ >= 5) {\n                result.append(\"v\")\n                currentNumber\
    \ -= 5\n            } else if (currentNumber >= 4) {\n                result.append(\"\
    iv\")\n                currentNumber -= 4\n            } else if (currentNumber\
    \ >= 1) {\n                result.append(\"i\")\n                currentNumber\
    \ -= 1\n            }\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val table = Map(\"I\" -> 1, \"V\" -> 5, \"X\" -> 10, \"L\" -> 50, \"C\"\
    \ -> 100, \"D\" -> 500, \"M\" -> 1000)\n        var result = new StringBuilder(\"\
    \")\n        var remainder = number\n        while (remainder != 0) {\n      \
    \      var flag = false\n            for (key <- table.keys) {\n             \
    \   val roman = key\n                val value = table(key)\n                if\
    \ (remainder >= value) {\n                    val quotient = remainder / value\n\
    \                    val remainder = remainder % value\n                    if\
    \ (quotient == 4) {\n                        result.append(roman + \"v\")\n  \
    \                  } else if (quotient == 9) {\n                        result.append(roman\
    \ + \"x\")\n                    } else {\n                        result.append(roman\
    \ * quotient)\n                    }\n                    flag = true\n      \
    \          }\n                if (flag) {\n                    break\n       \
    \         }\n            }\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8kbf2r1h.scala:25:36 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mval\e[0m \e[36mremainder\e\
    [0m = remainder % value\n\e[31m\e[31m   |\e[0m                               \
    \     ^\e[0m\n\e[31m   |\e[0m                                    Recursive \e\
    [33mvalue\e[0m \e[35mremainder\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8kbf2r1h.scala:36:20 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) return \"NA\"\n        var ret = new StringBuilder();\n\
    \        var digits = number.toString.toList.map(_.toString.toInt);\n        //\
    \ Start from one's place and go up\n        for (i <- (0 until digits.length).reverse)\
    \ {\n            var digit = digits(i);\n            // Ones\n            if (i\
    \ == 0) {\n                // TODO: Use repeat\n                for (j <- 1 to\
    \ digit) ret += \"i\";\n            }\n            // Tens\n            else if\
    \ (i == 1) {\n                // TODO: Use repeat\n                if (digit <=\
    \ 3) for (j <- 1 to digit) ret += \"x\";\n                else if (digit == 4)\
    \ ret += \"xl\";\n                else if (digit == 5) ret += \"l\";\n       \
    \         else if (digit == 9) ret += \"xc\";\n                else {\n      \
    \              for (j <- 1 to (digit - 5)) ret += \"x\";\n                   \
    \ ret += \"l\";\n                }\n            }\n            // Hundreds\n \
    \           else if (i == 2) {\n                // TODO: Use repeat\n        \
    \        if (digit <= 3) for (j <- 1 to digit) ret += \"c\";\n               \
    \ else if (digit == 4) ret += \"cd\";\n                else if (digit == 5) ret\
    \ += \"d\";\n                else if (digit == 9) ret += \"cm\";\n           \
    \     else {\n                    for (j <- 1 to (digit - 5)) ret += \"c\";\n\
    \                    ret += \"d\";\n                }\n            }\n       \
    \     // Thousands\n            else if (i == 3) {\n                // TODO: Use\
    \ repeat\n                for (j <- 1 to digit) ret += \"m\";\n            }\n\
    \        }\n        return ret.toString;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqzv_4y7e.scala:24:45\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mfor\e[0m\
    \ (j <- \e[31m1\e[0m to digit) ret += \e[31m\"i\"\e[0m;\n\e[31m\e[31m   |\e[0m\
    \                                             ^^^\e[0m\n\e[31m   |\e[0m      \
    \                                       Found:    (\e[32m\"i\"\e[0m : String)\n\
    \e[31m   |\e[0m                                             Required: Char\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqzv_4y7e.scala:29:61\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m\
    \ (digit <= \e[31m3\e[0m) \e[33mfor\e[0m (j <- \e[31m1\e[0m to digit) ret += \e\
    [31m\"x\"\e[0m;\n\e[31m\e[31m   |\e[0m                                       \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                    Found:    (\e[32m\"x\"\e[0m : String)\n\e[31m   |\e[0m  \
    \                                              Required: Char\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqzv_4y7e.scala:30:44 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (digit\
    \ == \e[31m4\e[0m) ret += \e[31m\"xl\"\e[0m;\n\e[31m\e[31m   |\e[0m          \
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                             Found:    (\e[32m\"xl\"\e[0m : String)\n\e[31m \
    \  |\e[0m                                            Required: Char\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqzv_4y7e.scala:31:44 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (digit\
    \ == \e[31m5\e[0m) ret += \e[31m\"l\"\e[0m;\n\e[31m\e[31m   |\e[0m           \
    \                                 ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                           Found:    (\e[32m\"l\"\e[0m : String)\n\e[31m   |\e\
    [0m                                            Required: Char\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660010346
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val total = new StringBuilder\n        var remaining = number\n        while\
    \ (remaining >= 1000) {\n            total.append(\"m\")\n            remaining\
    \ -= 1000\n        }\n        if (remaining >= 900) {\n            total.append(\"\
    cm\")\n            remaining -= 900\n        }\n        if (remaining >= 500)\
    \ {\n            total.append(\"d\")\n            remaining -= 500\n        }\n\
    \        if (remaining >= 400) {\n            total.append(\"cd\")\n         \
    \   remaining -= 400\n        }\n        while (remaining >= 100) {\n        \
    \    total.append(\"c\")\n            remaining -= 100\n        }\n        if\
    \ (remaining >= 90) {\n            total.append(\"xc\")\n            remaining\
    \ -= 90\n        }\n        if (remaining >= 50) {\n            total.append(\"\
    l\")\n            remaining -= 50\n        }\n        if (remaining >= 40) {\n\
    \            total.append(\"xl\")\n            remaining -= 40\n        }\n  \
    \      while (remaining >= 10) {\n            total.append(\"x\")\n          \
    \  remaining -= 10\n        }\n        if (remaining >= 9) {\n            total.append(\"\
    ix\")\n            remaining -= 9\n        }\n        if (remaining >= 5) {\n\
    \            total.append(\"v\")\n            remaining -= 5\n        }\n    \
    \    if (remaining >= 4) {\n            total.append(\"iv\")\n            remaining\
    \ -= 4\n        }\n        while (remaining >= 1) {\n            total.append(\"\
    i\")\n            remaining -= 1\n        }\n        total.toString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val (div1000, remainder1000) = number /% 1000\n        val (div100, remainder100)\
    \ = remainder1000 /% 100\n        val (div10, remainder10) = remainder100 /% 10\n\
    \        val remainder1 = remainder10\n        val roman1000 = String.fill(div1000.toInt)(\"\
    m\")\n        val roman100 = if (div100 == 9) \"cm\" else if (div100 == 4) \"\
    cd\" else {\n            val div50 = div100 / 5\n            val div5 = div100\
    \ % 5\n            val roman50 = String.fill(div50.toInt)(\"l\")\n           \
    \ val roman5 = String.fill(div5.toInt)(\"v\")\n            roman50 + roman5\n\
    \        }\n        val roman10 = if (div10 == 9) \"xc\" else if (div10 == 4)\
    \ \"xl\" else {\n            val div50 = div10 / 5\n            val div5 = div10\
    \ % 5\n            val roman50 = String.fill(div50.toInt)(\"x\")\n           \
    \ val roman5 = String.fill(div5.toInt)(\"v\")\n            roman50 + roman5\n\
    \        }\n        val roman1 = if (remainder1 == 9) \"ix\" else if (remainder1\
    \ == 4) \"iv\" else {\n            val div50 = remainder1 / 5\n            val\
    \ div5 = remainder1 % 5\n            val roman50 = String.fill(div50.toInt)(\"\
    i\")\n            val roman5 = String.fill(div5.toInt)(\"v\")\n            roman50\
    \ + roman5\n        }\n        roman1000 + roman100 + roman10 + roman1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppaav0slh.scala:15:46 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (div1000, remainder1000) = number\
    \ /% \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue /% is not a member of Long, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.BigDecimal.long2bigDecimal\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m  import math.Numeric.LongIsIntegral.mkNumericOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmppaav0slh.scala:15:13 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (div1000, remainder1000) = number\
    \ /% \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m\
    \             Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppaav0slh.scala:15:22 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m (div1000, remainder1000) = number\
    \ /% \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m\
    \   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppaav0slh.scala:16:13\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ (div100, remainder100) = remainder1000 /% \e[31m100\e[0m\n\e[31m\e[31m   |\e\
    [0m             ^\e[0m\n\e[31m   |\e[0m             Recursive \e[33mvalue\e[0m\
    \ \e[35m$2$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmppaav0slh.scala:16:21 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m (div100, remainder100) = remainder1000 /% \e[31m100\e\
    [0m"
  stdout: ''
  timestamp: 1660010347
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number;\n        var text = new StringBuilder;\n        while\
    \ (num >= 1000) {\n            text.append(\"m\");\n            num -= 1000;\n\
    \        }\n        while (num >= 500) {\n            text.append(\"d\");\n  \
    \          num -= 500;\n        }\n        while (num >= 100) {\n            text.append(\"\
    c\");\n            num -= 100;\n        }\n        while (num >= 50) {\n     \
    \       text.append(\"l\");\n            num -= 50;\n        }\n        while\
    \ (num >= 10) {\n            text.append(\"x\");\n            num -= 10;\n   \
    \     }\n        while (num >= 5) {\n            text.append(\"v\");\n       \
    \     num -= 5;\n        }\n        while (num >= 1) {\n            text.append(\"\
    i\");\n            num -= 1;\n        }\n        return text.toString;\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk6t97i_3.scala:48)\n\tat Problem.main(tmpk6t97i_3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010348
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val ints = List(1000,900,500,400,100,90,50,40,10,9,5,4,1)\n        val nums\
    \ = List(\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\",\"ix\",\"v\"\
    ,\"iv\",\"i\")\n        val roman = new StringBuilder\n        var n = number\n\
    \        for ((i,j) <- ints.zip(nums)) {\n            while (n >= i) {\n     \
    \           roman.append(j)\n                n -= i\n            }\n        }\n\
    \        roman.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010350
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tval SYMBOLS = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"\
    xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n    \tval VALUES = Array(1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n    \tvar num = number\n    \tvar\
    \ roman = \"\"\n    \tvar index = 0\n    \twhile (num > 0) {\n    \t\twhile (VALUES(index)\
    \ <= num) {\n    \t\t\troman += SYMBOLS(index)\n    \t\t\tnum -= VALUES(index)\n\
    \    \t\t}\n    \t\tindex += 1\n    \t}\n    \troman\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010348
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number > 1000 || number < 1) {\n            throw new Exception(\"Number\
    \ must be between 1 and 1000, inclusive.\")\n        }\n        def intToMiniRomanHelper(currentSum\
    \ : Long, currentString : String) : String = {\n            if (currentSum ==\
    \ number) {\n                currentString\n            } else if (currentSum\
    \ + 1000 <= number) {\n                intToMiniRomanHelper(currentSum + 1000,\
    \ currentString + \"m\")\n            } else if (currentSum + 900 <= number) {\n\
    \                intToMiniRomanHelper(currentSum + 900, currentString + \"cm\"\
    )\n            } else if (currentSum + 500 <= number) {\n                intToMiniRomanHelper(currentSum\
    \ + 500, currentString + \"d\")\n            } else if (currentSum + 400 <= number)\
    \ {\n                intToMiniRomanHelper(currentSum + 400, currentString + \"\
    cd\")\n            } else if (currentSum + 100 <= number) {\n                intToMiniRomanHelper(currentSum\
    \ + 100, currentString + \"c\")\n            } else if (currentSum + 90 <= number)\
    \ {\n                intToMiniRomanHelper(currentSum + 90, currentString + \"\
    xc\")\n            } else if (currentSum + 50 <= number) {\n                intToMiniRomanHelper(currentSum\
    \ + 50, currentString + \"l\")\n            } else if (currentSum + 40 <= number)\
    \ {\n                intToMiniRomanHelper(currentSum + 40, currentString + \"\
    xl\")\n            } else if (currentSum + 10 <= number) {\n                intToMiniRomanHelper(currentSum\
    \ + 10, currentString + \"x\")\n            } else if (currentSum + 9 <= number)\
    \ {\n                intToMiniRomanHelper(currentSum + 9, currentString + \"ix\"\
    )\n            } else if (currentSum + 5 <= number) {\n                intToMiniRomanHelper(currentSum\
    \ + 5, currentString + \"v\")\n            } else if (currentSum + 4 <= number)\
    \ {\n                intToMiniRomanHelper(currentSum + 4, currentString + \"iv\"\
    )\n            } else {\n                intToMiniRomanHelper(currentSum + 1,\
    \ currentString + \"i\")\n            }\n        }\n        intToMiniRomanHelper(0,\
    \ \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var symbol = Map(\"M\" -> 1000, \"D\" -> 500, \"C\" -> 100, \"L\" -> 50,\
    \ \"X\" -> 10, \"V\" -> 5, \"I\" -> 1)\n        var n = number\n        var roman\
    \ = \"\"\n        var last = 0\n        while (n > 0) {\n            var digit\
    \ = n % 10\n            var remain = n / 10\n            var charIndex = if (digit\
    \ == 4) {\n                0\n            } else if (digit == 9) {\n         \
    \       1\n            } else {\n                (digit % 5) + 2\n           \
    \ }\n            roman = symbol.keys.toArray(charIndex).toString + roman\n   \
    \         if (remain > 0) {\n                digit = remain % 10\n           \
    \     if (digit >= 5) {\n                    digit -= 5\n                }\n \
    \               roman = symbol.keys.toArray(2 * (charIndex / 2) + 1).toString\
    \ + roman\n            }\n            last = charIndex\n            n = remain\n\
    \        }\n        return roman.toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_aw59y5.scala:29:40\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            roman = symbol.keys.toArray(charIndex).toString\
    \ + roman\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    (charIndex : Long)\n\
    \e[31m   |\e[0m                                Required: scala.reflect.ClassTag[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_aw59y5.scala:35:44\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                roman = symbol.keys.toArray(\e\
    [31m2\e[0m * (charIndex / \e[31m2\e[0m) + \e[31m1\e[0m).toString + roman\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Long\n\e[31m   |\e\
    [0m                                Required: scala.reflect.ClassTag[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_aw59y5.scala:37:19\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            last = charIndex\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \             Found:    (charIndex : Long)\n\e[31m   |\e[0m                  \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0) return \"\"\n        if (number >= 1000) return \"m\" +\
    \ intToMiniRoman(number - 1000)\n        if (number >= 900) return \"cm\" + intToMiniRoman(number\
    \ - 900)\n        if (number >= 500) return \"d\" + intToMiniRoman(number - 500)\n\
    \        if (number >= 400) return \"cd\" + intToMiniRoman(number - 400)\n   \
    \     if (number >= 100) return \"c\" + intToMiniRoman(number - 100)\n       \
    \ if (number >= 90) return \"xc\" + intToMiniRoman(number - 90)\n        if (number\
    \ >= 50) return \"l\" + intToMiniRoman(number - 50)\n        if (number >= 40)\
    \ return \"xl\" + intToMiniRoman(number - 40)\n        if (number >= 10) return\
    \ \"x\" + intToMiniRoman(number - 10)\n        if (number >= 9) return \"ix\"\
    \ + intToMiniRoman(number - 9)\n        if (number >= 5) return \"v\" + intToMiniRoman(number\
    \ - 5)\n        if (number >= 4) return \"iv\" + intToMiniRoman(number - 4)\n\
    \        if (number >= 1) return \"i\" + intToMiniRoman(number - 1)\n        throw\
    \ new Exception(\"Something went wrong!\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var i = 0\n        val pairs = Array((\"m\",\
    \ 1000), (\"d\", 500), (\"c\", 100), (\"l\", 50), (\"x\", 10), (\"v\", 5), (\"\
    i\", 1))\n        while (number > 0) {\n            val x = pairs(i)\n       \
    \     val pair = (x._1, x._2)\n            val nextPair = (pairs(i + 1)._1, pairs(i\
    \ + 1)._2)\n            if (number / pair._2 > 0) {\n                val char\
    \ = pair._1\n                val int = number / pair._2\n                if (int\
    \ == 9) {\n                    result += nextPair._1 + pair._1\n             \
    \       number -= (9 * pair._2)\n                } else if (int == 4) {\n    \
    \                result += pair._1 + nextPair._1\n                    number -=\
    \ (4 * pair._2)\n                } else {\n                    for (j <- 1 to\
    \ int) result += pair._1\n                    number -= (int * pair._2)\n    \
    \            }\n            }\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw64ac38c.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    number -= (\e[31m9\e[0m * pair._2)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \         value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpw64ac38c.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    number -= (\e[31m4\e[0m * pair._2)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \         value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpw64ac38c.scala:32:35 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mfor\e[0m (j <- \e[31m1\e[0m\
    \ to int) result += pair._1\n\e[31m\e[31m   |\e[0m                           \
    \        ^^^\e[0m\n\e[31m   |\e[0m                                   Found:  \
    \  (int : Long)\n\e[31m   |\e[0m                                   Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw64ac38c.scala:33:27\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    number\
    \ -= (int * pair._2)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m              value -= is not a member of Long - did you mean number.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = Array(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n\
    \        val romans = Array(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        var result = \"\"\n  \
    \      var num = number\n        var i = 0\n        while (num > 0) {\n      \
    \      val times = num / symbols(i)\n            num -= symbols(i) * times\n \
    \           result += romans(i) * times\n            i += 1\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp1d7apu9.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            result += romans(i) * times\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp1d7apu9.scala:23:34 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            result += romans(i) * times\n\e[31m\e[31m   |\e[0m       \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \            Found:    (times : Long)\n\e[31m   |\e[0m                       \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     import DigitValue._\n        val n = number.toInt\n        val ds = Map(1000\
    \ -> 'm', 900 -> 'c', 500 -> 'd', 400 -> 'c', 100 -> 'c', 90 -> 'x', 50 -> 'l',\
    \ 40 -> 'x', 10 -> 'x', 9 -> 'i', 5 -> 'v', 4 -> 'i', 1 -> 'i')\n        var r\
    \ = \"\"\n        for(d <- ds) {\n            val p = n / d._1\n            if(p\
    \ > 0) r += d._2.toString * p\n            n %= d._1\n        }\n        r\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1txadgve.scala:15:15 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mimport\e[0m DigitValue._\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               Not found:\
    \ DigitValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E049] Reference Error: /tmp/tmp1txadgve.scala:16:16\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mn\e[0m = number.toInt\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e\
    [31m   |\e[0m     Reference to number is ambiguous,\n\e[31m   |\e[0m     it is\
    \ both defined in \e[33mmethod\e[0m \e[35mintToMiniRoman\e[0m\n\e[31m   |\e[0m\
    \     and imported subsequently by import <error Not found: DigitValue>._\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010345
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits : List[Int] = number.toString.map(_.asDigit).toList.reverse\n\
    \        val roman = List(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n \
    \       def intToRoman(digit : Int, romanUnit : Int) : String = {\n          \
    \  val (one, five, ten) = (roman(romanUnit * 2), roman(romanUnit * 2 + 1), roman(romanUnit\
    \ * 2 + 2))\n            digit match {\n                case 0 => \"\"\n     \
    \           case 1 => one\n                case 2 => one + one\n             \
    \   case 3 => one + one + one\n                case 4 => one + five\n        \
    \        case 5 => five\n                case 6 => five + one\n              \
    \  case 7 => five + one + one\n                case 8 => five + one + one + one\n\
    \                case 9 => one + ten\n            }\n        }\n        def listToRoman(list\
    \ : List[Int], romanUnit : Int) : String = {\n            list match {\n     \
    \           case Nil => \"\"\n                case d :: t => intToRoman(d, romanUnit)\
    \ + listToRoman(t, romanUnit + 1)\n            }\n        }\n        listToRoman(digits,\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuvhtxn1u.scala:41)\n\tat Problem.main(tmpuvhtxn1u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010351
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var ans = \"\"\n        val symbols = List(('m', 1000), ('d', 500), ('c',\
    \ 100), ('l', 50), ('x', 10), ('v', 5), ('i', 1))\n        var remaining = number\n\
    \        for((symbol, value) <- symbols) {\n            while(remaining >= value)\
    \ {\n                ans += symbol\n                remaining -= value\n     \
    \       }\n        }\n        ans\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuau_3111.scala:27)\n\tat Problem.main(tmpuau_3111.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tif (number < 1 || number > 1000) throw new Exception(\"Number must be between\
    \ 1 and 1000\")\n    \tvar units = number % 10\n    \tvar tens = (number / 10)\
    \ % 10\n    \tvar hundreds = (number / 100) % 10\n    \tvar thousands = (number\
    \ / 1000) % 10\n    \tvar result = \"\"\n    \tresult += Map(0 -> \"\", 1 -> \"\
    i\", 2 -> \"ii\", 3 -> \"iii\", 4 -> \"iv\", 5 -> \"v\", 6 -> \"vi\", 7 -> \"\
    vii\", 8 -> \"viii\", 9 -> \"ix\")(units)\n    \tresult = Map(0 -> result, 1 ->\
    \ \"x\" + result, 2 -> \"xx\" + result, 3 -> \"xxx\" + result, 4 -> \"xl\" + result,\
    \ 5 -> \"l\" + result, 6 -> \"lx\" + result, 7 -> \"lxx\" + result, 8 -> \"lxxx\"\
    \ + result, 9 -> \"xc\" + result)(tens)\n    \tresult = Map(0 -> result, 1 ->\
    \ \"c\" + result, 2 -> \"cc\" + result, 3 -> \"ccc\" + result, 4 -> \"cd\" + result,\
    \ 5 -> \"d\" + result, 6 -> \"dc\" + result, 7 -> \"dcc\" + result, 8 -> \"dccc\"\
    \ + result, 9 -> \"cm\" + result)(hundreds)\n    \tresult = Map(0 -> result, 1\
    \ -> \"m\" + result, 2 -> \"mm\" + result, 3 -> \"mmm\" + result)(thousands)\n\
    \    \tresult\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf4ilb3p2.scala:22:43 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    \tresult = Map(\e[31m0\e[0m -> result, \e[31m1\e\
    [0m -> \e[31m\"x\"\e[0m + result, \e[31m2\e[0m -> \e[31m\"xx\"\e[0m + result,\
    \ \e[31m3\e[0m -> \e[31m\"xxx\"\e[0m + result, \e[31m4\e[0m -> \e[31m\"xl\"\e\
    [0m + result, \e[31m5\e[0m -> \e[31m\"l\"\e[0m + result, \e[31m6\e[0m -> \e[31m\"\
    lx\"\e[0m + result, \e[31m7\e[0m -> \e[31m\"lxx\"\e[0m + result, \e[31m8\e[0m\
    \ -> \e[31m\"lxxx\"\e[0m + result, \e[31m9\e[0m -> \e[31m\"xc\"\e[0m + result)(tens)\n\
    \e[31m\e[31m   |\e[0m    \t                          ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue + is not a member of (Int, String), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf4ilb3p2.scala:22:63 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m    \tresult = Map(\e[31m0\e[0m -> result, \e[31m1\e[0m ->\
    \ \e[31m\"x\"\e[0m + result, \e[31m2\e[0m -> \e[31m\"xx\"\e[0m + result, \e[31m3\e\
    [0m -> \e[31m\"xxx\"\e[0m + result, \e[31m4\e[0m -> \e[31m\"xl\"\e[0m + result,\
    \ \e[31m5\e[0m -> \e[31m\"l\"\e[0m + result, \e[31m6\e[0m -> \e[31m\"lx\"\e[0m\
    \ + result, \e[31m7\e[0m -> \e[31m\"lxx\"\e[0m + result, \e[31m8\e[0m -> \e[31m\"\
    lxxx\"\e[0m + result, \e[31m9\e[0m -> \e[31m\"xc\"\e[0m + result)(tens)\n\e[31m\e\
    [31m   |\e[0m    \t                                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of (Int, String), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error:"
  stdout: ''
  timestamp: 1660010357
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        var result = \"\"\n        while (n > 0) {\n   \
    \         if (n >= 1000) {\n                result += \"m\"\n                n\
    \ -= 1000\n            } else if (n >= 900) {\n                result += \"cm\"\
    \n                n -= 900\n            } else if (n >= 500) {\n             \
    \   result += \"d\"\n                n -= 500\n            } else if (n >= 400)\
    \ {\n                result += \"cd\"\n                n -= 400\n            }\
    \ else if (n >= 100) {\n                result += \"c\"\n                n -=\
    \ 100\n            } else if (n >= 90) {\n                result += \"xc\"\n \
    \               n -= 90\n            } else if (n >= 50) {\n                result\
    \ += \"l\"\n                n -= 50\n            } else if (n >= 40) {\n     \
    \           result += \"xl\"\n                n -= 40\n            } else if (n\
    \ >= 10) {\n                result += \"x\"\n                n -= 10\n       \
    \     } else if (n >= 9) {\n                result += \"ix\"\n               \
    \ n -= 9\n            } else if (n >= 5) {\n                result += \"v\"\n\
    \                n -= 5\n            } else if (n >= 4) {\n                result\
    \ += \"iv\"\n                n -= 4\n            } else if (n >= 1) {\n      \
    \          result += \"i\"\n                n -= 1\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010351
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = List(\n            \"i\", \"v\", \"x\", \"l\", \"c\", \"d\"\
    , \"m\",\n            \"iv\", \"ix\", \"xl\", \"xc\", \"cd\", \"cm\"\n       \
    \ )\n        val values = List(1, 5, 10, 50, 100, 500, 1000, 4, 9, 40, 90, 400,\
    \ 900)\n        var n = number\n        var result = \"\"\n        for (i <- 0\
    \ to 12) {\n            while (n >= values(i)) {\n                result += symbols(i)\n\
    \                n -= values(i)\n            }\n        }\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptsghl52r.scala:31)\n\tat Problem.main(tmptsghl52r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Declare a reusable StringBuilder, for efficiency\n        val romanStringBuilder\
    \ = new StringBuilder()\n        // Base case of 1, where the number is not divisible\
    \ by 10\n        if (number < 10) {\n            romanStringBuilder.append(intToMiniRoman(number,\
    \ 0))\n        }\n        // Recursive case, where the number is divisible by\
    \ 10\n        else {\n            // Get the first digit (ones place)\n      \
    \      val firstDigit = number % 10\n            // Append the ones place to the\
    \ string\n            romanStringBuilder.append(intToMiniRoman(firstDigit, 0))\n\
    \            // Recursively get the Roman numeral for the remaining digits\n \
    \           romanStringBuilder.append(intToMiniRoman(number / 10, 1))\n      \
    \  }\n        // Convert to lowercase\n        romanStringBuilder.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgcjfxni_.scala:19:53\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            romanStringBuilder.append(intToMiniRoman(number,\
    \ \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                      \
    \               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \                     Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m              \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgcjfxni_.scala:26:53 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            romanStringBuilder.append(intToMiniRoman(firstDigit,\
    \ \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                      \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                         Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m              \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgcjfxni_.scala:28:53 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            romanStringBuilder.append(intToMiniRoman(number\
    \ / \e[31m10\e[0m, \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                     \
    \                                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                           Found:    \e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m \
    \  |\e[0m                                                   Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) {\n            throw new IllegalArgumentException(\"\
    Number out of range\");\n        }\n        var temp = number;\n        var buffer\
    \ = new StringBuilder();\n        val symbols = \"ivxlcdm\";\n        var index\
    \ = 0;\n        var base = 1;\n        while (temp > 0) {\n            val remainder\
    \ = temp % 10;\n            if (remainder >= 4 && remainder <= 8) {\n        \
    \        buffer.append(symbols(index));\n                var count = remainder\
    \ - 5;\n                while (count > 0) {\n                    buffer.append(symbols(index\
    \ + 1));\n                    count -= 1;\n                }\n               \
    \ buffer.append(symbols(index + 1));\n            } else if (remainder == 9) {\n\
    \                buffer.append(symbols(index));\n                buffer.append(symbols(index\
    \ + 2));\n            } else if (remainder == 4) {\n                buffer.append(symbols(index));\n\
    \                buffer.append(symbols(index + 1));\n            } else {\n  \
    \              var count = remainder;\n                while (count > 0) {\n \
    \                   buffer.append(symbols(index + 1));\n                    count\
    \ -= 1;\n                }\n            }\n            temp /= 10;\n         \
    \   index += 2;\n            base *= 10;\n        }\n        buffer.reverse.toString;\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_m1jk_83.scala:53)\n\tat Problem.main(tmp_m1jk_83.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // let n = number\n        // let a, b, c, d, e be digits in n from left\
    \ to right\n        // \n        // 9 is represented as:  IX\n        // 90 is\
    \ represented as: XC\n        // 400 is represented as: CD\n        // 900 is\
    \ represented as: CM\n        // \n        // Thus,\n        // n = a * 1000 +\
    \ b * 100 + c * 10 + d\n        // n = a * 1000 + b * 100 + c * 10 + d + e\n \
    \       // n = a * 1000 + b * 100 + (c + 1) * 10 + d + e - 1\n        // \n  \
    \      // let k = 1000, l = 100, m = 10\n        // \n        // n = a * k + b\
    \ * l + (c + 1) * m + d + e - 1\n        // n = a * k + b * l + c * m + m + d\
    \ + e - 1\n        // n = a * k + b * l + c * m + (d + e - 1) + m\n        //\
    \ n = a * k + b * l + (c * m + d + e - 1) + m\n        // n = a * k + b * l +\
    \ k + (c * m + d + e - 1)\n        // n = (a + 1) * k + b * l + (c * m + d + e\
    \ - 1)\n        // \n        // So, we let p = (c * m + d + e - 1)\n        //\
    \ \n        // If 0 <= p <= 3, then it is represented as: p\n        // If 4 <=\
    \ p <= 8, then it is represented as: p - 4 + 'V'\n        // If 9 <= p <= 38,\
    \ then it is represented as: p - 9 + 'X'\n        // If 39 <= p <= 88, then it\
    \ is represented as: p - 39 + 'L'\n        // If 89 <= p <= 388, then it is represented\
    \ as: p - 89 + 'C'\n        // If 389 <= p <= 888, then it is represented as:\
    \ p - 389 + 'D'\n        // If 889 <= p <= 3888, then it is represented as: p\
    \ - 889 + 'M'\n        val\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppsjmi7ta.scala:46:11 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m       \
    \    ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppsjmi7ta.scala:47:5 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanMap = Map(1000l -> \"m\", 900l -> \"cm\", 500l -> \"d\", 400l ->\
    \ \"cd\", 100l -> \"c\", 90l -> \"xc\", 50l -> \"l\", 40l -> \"xl\", 10l -> \"\
    x\", 9l -> \"ix\", 5l -> \"v\", 4l -> \"iv\", 1l -> \"i\")\n        val romanList\
    \ = List(1000l, 900l, 500l, 400l, 100l, 90l, 50l, 40l, 10l, 9l, 5l, 4l, 1l)\n\
    \        def intToMiniRoman(number : Long, romanList : List[Long]) : String =\
    \ {\n            if (number == 0) \"\"\n            else {\n                romanMap(romanList.find(x\
    \ => x <= number).get) + intToMiniRoman(number - romanList.find(x => x <= number).get,\
    \ romanList)\n            }\n        }\n        intToMiniRoman(number, romanList)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010356
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumerals = Array(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n        val values = Array(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var result = \"\"\n\
    \        var i = 0\n        var remainder = number\n        while (remainder >\
    \ 0) {\n            while (remainder >= values(i)) {\n                result +=\
    \ romanNumerals(i)\n                remainder -= values(i)\n            }\n  \
    \          i += 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpif6bc9h0.scala:30)\n\tat Problem.main(tmpif6bc9h0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val mappings = List(\n            (1000l, \"m\"),\n            (900l, \"\
    cm\"),\n            (500l, \"d\"),\n            (400l, \"cd\"),\n            (100l,\
    \ \"c\"),\n            (90l, \"xc\"),\n            (50l, \"l\"),\n           \
    \ (40l, \"xl\"),\n            (10l, \"x\"),\n            (9l, \"ix\"),\n     \
    \       (5l, \"v\"),\n            (4l, \"iv\"),\n            (1l, \"i\")\n   \
    \     )\n        def helper(number : Long, mappings : List[(Long, String)]) :\
    \ String = {\n            if (number == 0) {\n                \"\"\n         \
    \   } else {\n                val (div,mod) = (number / mappings.head._1, number\
    \ % mappings.head._1)\n                mappings.head._2 * div.toInt + helper(mod,\
    \ mappings.tail)\n            }\n        }\n        helper(number, mappings)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010357
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def buildRomanString(number : Long, remain : Int, result : String) : String\
    \ = {\n            if (remain == 0) result\n            else {\n             \
    \   val n = number / remain\n                buildRomanString(number % remain,\
    \ remain / 10, result + repeatCharacter(n, remain))\n            }\n        }\n\
    \        def repeatCharacter(n : Long, remain : Int) : String = {\n          \
    \  if (n == 9) {\n                romanSymbol(remain) + romanSymbol(remain * 10)\n\
    \            } else if (n >= 5) {\n                romanSymbol(5 * remain) + romanSymbol(remain)\
    \ * (n - 5).toInt\n            } else if (n == 4) {\n                romanSymbol(remain)\
    \ + romanSymbol(5 * remain)\n            } else {\n                romanSymbol(remain)\
    \ * n.toInt\n            }\n        }\n        def romanSymbol(remain : Int) :\
    \ String = {\n            remain match {\n                case 1 => \"i\"\n  \
    \              case 10 => \"x\"\n                case 100 => \"c\"\n         \
    \       case 1000 => \"m\"\n                case _ => \"\"\n            }\n  \
    \      }\n        if (number <= 0 || number > 1000) \"\"\n        else buildRomanString(number,\
    \ 1000, \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp17s8tk1a.scala:47)\n\tat Problem.main(tmp17s8tk1a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010357
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Fill in the code here\n        var str = \"\"\n        var num = number\n\
    \        while (num > 0) {\n            if (num >= 1000) {\n                str\
    \ += \"m\"\n                num -= 1000\n            } else if (num >= 900) {\n\
    \                str += \"cm\"\n                num -= 900\n            } else\
    \ if (num >= 500) {\n                str += \"d\"\n                num -= 500\n\
    \            } else if (num >= 400) {\n                str += \"cd\"\n       \
    \         num -= 400\n            } else if (num >= 100) {\n                str\
    \ += \"c\"\n                num -= 100\n            } else if (num >= 90) {\n\
    \                str += \"xc\"\n                num -= 90\n            } else\
    \ if (num >= 50) {\n                str += \"l\"\n                num -= 50\n\
    \            } else if (num >= 40) {\n                str += \"xl\"\n        \
    \        num -= 40\n            } else if (num >= 10) {\n                str +=\
    \ \"x\"\n                num -= 10\n            } else if (num >= 9) {\n     \
    \           str += \"ix\"\n                num -= 9\n            } else if (num\
    \ >= 5) {\n                str += \"v\"\n                num -= 5\n          \
    \  } else if (num >= 4) {\n                str += \"iv\"\n                num\
    \ -= 4\n            } else if (num >= 1) {\n                str += \"i\"\n   \
    \             num -= 1\n            }\n        }\n        str\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010356
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumbers = List(\n            (\"m\", 1000),\n            (\"cm\"\
    , 900),\n            (\"d\", 500),\n            (\"cd\", 400),\n            (\"\
    c\", 100),\n            (\"xc\", 90),\n            (\"l\", 50),\n            (\"\
    xl\", 40),\n            (\"x\", 10),\n            (\"ix\", 9),\n            (\"\
    v\", 5),\n            (\"iv\", 4),\n            (\"i\", 1)\n        )\n      \
    \  def intToMiniRoman(number : Long, romanNumbers : List[(String, Int)]) : String\
    \ = romanNumbers match {\n            case Nil => \"\"\n            case (romanNumber,\
    \ int) :: _ if (number >= int) => romanNumber + intToMiniRoman(number - int, romanNumbers)\n\
    \            case _ :: rest => intToMiniRoman(number, rest)\n        }\n     \
    \   intToMiniRoman(number, romanNumbers)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanDigits = List((\"i\", 1), (\"v\", 5), (\"x\", 10), (\"l\", 50),\
    \ (\"c\", 100), (\"d\", 500), (\"m\", 1000))\n        var result = \"\"\n    \
    \    var remain = number\n        while (remain > 0) {\n            val t = romanDigits.takeWhile(_._2\
    \ <= remain).last\n            val count = remain / t._2\n            result +=\
    \ t._1 * count\n            remain -= t._2 * count\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_thpeobf.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            result += t._1 * count\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_thpeobf.scala:21:29 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \            result += t._1 * count\n\e[31m\e[31m   |\e[0m                   \
    \          ^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    (count\
    \ : Long)\n\e[31m   |\e[0m                             Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbolArray = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val valueArray = List(1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        var result = \"\"\n\
    \        var num = number\n        for (i <- 0 to symbolArray.length - 1) {\n\
    \            while (num >= valueArray(i)) {\n                result += symbolArray(i)\n\
    \                num -= valueArray(i)\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010361
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number; var roman : String = \"\";\n        var values = Vector(1000,\
    \ 500, 100, 50, 10, 5, 1);\n        var tokens = Vector(\"m\", \"d\", \"c\", \"\
    l\", \"x\", \"v\", \"i\");\n        for (i <- 0 to 6) {\n            if (n >=\
    \ values(i)) {\n                var count = n / values(i);\n                for\
    \ (j <- 1 to count.toInt) roman += tokens(i);\n                n -= count * values(i);\n\
    \            }\n        }\n        roman = roman.replace(\"dcccc\", \"cm\");\n\
    \        roman = roman.replace(\"cccc\", \"cd\");\n        roman = roman.replace(\"\
    lxxxx\", \"xc\");\n        roman = roman.replace(\"xxxx\", \"xl\");\n        roman\
    \ = roman.replace(\"viiii\", \"ix\");\n        roman = roman.replace(\"iiii\"\
    , \"iv\");\n        return roman;\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010360
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Returns the miniroman string representing the input number\n        //\
    \ Throws an error if the number is out of the supported range\n        // 1 <=\
    \ number <= 1000\n        if (number < 1 || number > 1000) {\n            throw\
    \ new Exception(\"Unsupported range\")\n        }\n        var currentNumber =\
    \ number\n        var currentPosition = 0\n        var stringRepresentation =\
    \ \"\"\n        while (currentNumber > 0) {\n            var currentDigit = currentNumber\
    \ % 10\n            currentNumber /= 10\n            currentPosition += 1\n  \
    \          var token = \"\"\n            currentDigit match {\n              \
    \  case 1 => token = \"i\"\n                case 2 => token = \"ii\"\n       \
    \         case 3 => token = \"iii\"\n                case 4 => token = \"iv\"\n\
    \                case 5 => token = \"v\"\n                case 6 => token = \"\
    vi\"\n                case 7 => token = \"vii\"\n                case 8 => token\
    \ = \"viii\"\n                case 9 => token = \"ix\"\n            }\n      \
    \      stringRepresentation = token + (if (currentPosition == 1) \"\" else \"\
    x\" * (currentPosition - 1)) + stringRepresentation\n        }\n        return\
    \ stringRepresentation\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsvrpz_2a.scala:45)\n\tat Problem.main(tmpsvrpz_2a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010360
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols = List(\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"\
    xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n        val values = List(1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)\n        val sb = new StringBuilder\n\
    \        var n = number\n        while (n > 0) {\n            var i = 0\n    \
    \        while (n < values(i)) i += 1\n            sb.append(symbols(i))\n   \
    \         n -= values(i)\n        }\n        sb.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) throw new IllegalArgumentException\n  \
    \      var result = new StringBuilder\n        var index = 0\n        while (number\
    \ > 0) {\n            if (number >= symbolValue(index)) {\n                result.append(symbol(index))\n\
    \                number -= symbolValue(index)\n            }\n            else\
    \ index += 1\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj8xn_czu.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (number >= symbolValue(index))\
    \ {\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          Not found: symbolValue\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj8xn_czu.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result.append(symbol(index))\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                        Not found: symbol\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpj8xn_czu.scala:21:23 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m                number -= symbolValue(index)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpj8xn_czu.scala:21:26 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m                number -= symbolValue(index)\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \           Not found: symbolValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = new StringBuilder\n        var num = number\n        while\
    \ (num > 0) {\n            val c = if (num >= 1000) {\n                num -=\
    \ 1000\n                \"m\"\n            } else if (num >= 900) {\n        \
    \        num -= 900\n                \"cm\"\n            } else if (num >= 500)\
    \ {\n                num -= 500\n                \"d\"\n            } else if\
    \ (num >= 400) {\n                num -= 400\n                \"cd\"\n       \
    \     } else if (num >= 100) {\n                num -= 100\n                \"\
    c\"\n            } else if (num >= 90) {\n                num -= 90\n        \
    \        \"xc\"\n            } else if (num >= 50) {\n                num -= 50\n\
    \                \"l\"\n            } else if (num >= 40) {\n                num\
    \ -= 40\n                \"xl\"\n            } else if (num >= 10) {\n       \
    \         num -= 10\n                \"x\"\n            } else if (num >= 9) {\n\
    \                num -= 9\n                \"ix\"\n            } else if (num\
    \ >= 5) {\n                num -= 5\n                \"v\"\n            } else\
    \ if (num >= 4) {\n                num -= 4\n                \"iv\"\n        \
    \    } else {\n                num -= 1\n                \"i\"\n            }\n\
    \            result.append(c)\n        }\n        result.toString\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tvar answer = new StringBuilder\n    \tval arabicChars = \"MCDXLIV\"\n    \t\
    val arabicNums = List(1000, 500, 100, 50, 10, 5, 1)\n    \tfor (i <- 0 to 6) {\n\
    \    \t\twhile (number >= arabicNums(i)) {\n    \t\t\tanswer += arabicChars(i)\n\
    \    \t\t\tnumber -= arabicNums(i)\n    \t\t}\n    \t}\n    \treturn answer.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp26vzfxmh.scala:21:15 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    \t\t\tnumber -= arabicNums(i)\n\e[31m\e[31m   |\e\
    [0m    \t\t\t^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \t\t\tvalue -= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010359
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num : Long = number\n        var result : String = \"\"\n        val\
    \ symbols : Array[Tuple2[Long,String]] = Array((1000l,\"m\"),(900l,\"cm\"),(500l,\"\
    d\"),(400l,\"cd\"),(100l,\"c\"),(90l,\"xc\"),(50l,\"l\"),(40l,\"xl\"),(10l,\"\
    x\"),(9l,\"ix\"),(5l,\"v\"),(4l,\"iv\"),(1l,\"i\"))\n        for (symbol <- symbols)\
    \ {\n            val (divider, symbolStr) = symbol\n            val quotient =\
    \ num / divider\n            for (i <- 1l to quotient) {\n                result\
    \ += symbolStr\n            }\n            num %= divider\n        }\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010364
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number\n        val values = Vector(1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1)\n        val letters = Vector(\"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\")\n\
    \        var answer = \"\"\n        for (i <- 0 to 12) {\n            while (n\
    \ >= values(i)) {\n                answer += letters(i)\n                n -=\
    \ values(i)\n            }\n        }\n        return answer\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Seq(\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\",\
    \ \"dcc\", \"dccc\", \"cm\", \"m\")\n        val tens = Seq(\"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\")\n        val\
    \ hundreds = Seq(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\", \"x\")\n        if (number > 0) {\n            var n = number\n\
    \            var s = \"m\" * (n / 1000).toInt\n            n %= 1000\n       \
    \     s += numerals(n / 100)\n            n %= 100\n            s += tens(n /\
    \ 10)\n            n %= 10\n            s += hundreds(n)\n            s\n    \
    \    } else \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6unn1jib.scala:22:14 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            s += numerals(n / \e[31m100\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6unn1jib.scala:22:26 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            s += numerals(n / \e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \    Found:    Long\n\e[31m   |\e[0m                          Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6unn1jib.scala:24:14\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            s += tens(n /\
    \ \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of String - did you mean String.!=?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6unn1jib.scala:24:22 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            s += tens(n / \e[31m10\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \     Found:    Long\n\e[31m   |\e[0m                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6unn1jib.scala:26:14 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            s += hundreds(n)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6unn1jib.scala:26:26 --------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \            s += hundreds(n)\n\e[31m\e[31m   |\e[0m                         \
    \ ^\e[0m\n\e[31m   |\e[0m                          Found:    (n : Long)\n\e[31m\
    \   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        if (number >= 100) {\n            val multiplesOfOneHundred\
    \ = floor(number / 100)\n            result += multiplesOfOneHundred * \"c\"\n\
    \            number -= multiplesOfOneHundred * 100\n        }\n        if (number\
    \ >= 90) {\n            result += \"xc\"\n            number -= 90\n        }\n\
    \        if (number >= 50) {\n            result += \"l\"\n            number\
    \ -= 50\n        }\n        if (number >= 40) {\n            result += \"xl\"\n\
    \            number -= 40\n        }\n        if (number >= 10) {\n          \
    \  val multiplesOfTen = floor(number / 10)\n            result += multiplesOfTen\
    \ * \"x\"\n            number -= multiplesOfTen * 10\n        }\n        if (number\
    \ >= 9) {\n            result += \"ix\"\n            number -= 9\n        }\n\
    \        if (number >= 5) {\n            result += \"v\"\n            number -=\
    \ 5\n        }\n        if (number >= 4) {\n            result += \"iv\"\n   \
    \         number -= 4\n        }\n        if (number >= 1) {\n            result\
    \ += number * \"i\"\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnx_hra3.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result += multiplesOfOneHundred * \e[31m\"\
    c\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         value += is not a member of String - did you mean String.!=?\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpxnx_hra3.scala:18:44 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result += multiplesOfOneHundred * \e[31m\"\
    c\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m*\e[0m in \e[33mclass\e[0m \e[35mDouble\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Double\n\e[31m   |\e[0m (x: Long):\
    \ Double\n\e[31m   |\e[0m (x: Int): Double\n\e[31m   |\e[0m (x: Char): Double\n\
    \e[31m   |\e[0m (x: Short): Double\n\e[31m   |\e[0m (x: Byte): Double\n\e[31m\
    \   |\e[0mmatch arguments ((\e[32m\"c\"\e[0m : String))\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxnx_hra3.scala:19:19 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            number -= multiplesOfOneHundred * \e[31m100\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    value -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpxnx_hra3.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            number -= \e[31m90\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnx_hra3.scala:27:19\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            number -= \e\
    [31m50\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxnx_hra3.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number -= \e[31m40\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did y"
  stdout: ''
  timestamp: 1660010364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var string = new StringBuilder()\n        var remainder = number\n     \
    \   while (remainder >= 1000) {\n            string += \"m\"\n            remainder\
    \ -= 1000\n        }\n        if (remainder >= 900) {\n            string += \"\
    cm\"\n            remainder -= 900\n        }\n        if (remainder >= 500) {\n\
    \            string += \"d\"\n            remainder -= 500\n        }\n      \
    \  if (remainder >= 400) {\n            string += \"cd\"\n            remainder\
    \ -= 400\n        }\n        while (remainder >= 100) {\n            string +=\
    \ \"c\"\n            remainder -= 100\n        }\n        if (remainder >= 90)\
    \ {\n            string += \"xc\"\n            remainder -= 90\n        }\n  \
    \      if (remainder >= 50) {\n            string += \"l\"\n            remainder\
    \ -= 50\n        }\n        if (remainder >= 40) {\n            string += \"xl\"\
    \n            remainder -= 40\n        }\n        while (remainder >= 10) {\n\
    \            string += \"x\"\n            remainder -= 10\n        }\n       \
    \ if (remainder >= 9) {\n            string += \"ix\"\n            remainder -=\
    \ 9\n        }\n        if (remainder >= 5) {\n            string += \"v\"\n \
    \           remainder -= 5\n        }\n        if (remainder >= 4) {\n       \
    \     string += \"iv\"\n            remainder -= 4\n        }\n        while (remainder\
    \ >= 1) {\n            string += \"i\"\n            remainder -= 1\n        }\n\
    \        return string.toString()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoy55myo9.scala:18:22\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            string += \e[31m\"\
    m\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    (\e[32m\"m\"\e[0m : String)\n\e[31m   |\e[0m\
    \                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpoy55myo9.scala:22:22 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            string += \e[31m\"cm\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                      ^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (\e[32m\"cm\"\e[0m : String)\n\e[31m   |\e[0m                      Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoy55myo9.scala:26:22\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            string += \e[31m\"\
    d\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    (\e[32m\"d\"\e[0m : String)\n\e[31m   |\e[0m\
    \                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpoy55myo9.scala:30:22 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            string += \e[31m\"cd\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                      ^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (\e[32m\"cd\"\e[0m : String)\n\e[31m   |\e[0m                      Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoy55myo9.scala:34:22\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            string += \e[31m\"\
    c\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    (\e[32m\"c\"\e[0m : String)\n\e[31m   |\e[0m\
    \                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatc"
  stdout: ''
  timestamp: 1660010365
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var n = number; var s = \"\";\n        while (n >= 1000) {\n           \
    \ s += \"m\"; n -= 1000;\n        }\n        if (n >= 900) {\n            s +=\
    \ \"cm\"; n -= 900;\n        }\n        if (n >= 500) {\n            s += \"d\"\
    ; n -= 500;\n        }\n        if (n >= 400) {\n            s += \"cd\"; n -=\
    \ 400;\n        }\n        while (n >= 100) {\n            s += \"c\"; n -= 100;\n\
    \        }\n        if (n >= 90) {\n            s += \"xc\"; n -= 90;\n      \
    \  }\n        if (n >= 50) {\n            s += \"l\"; n -= 50;\n        }\n  \
    \      if (n >= 40) {\n            s += \"xl\"; n -= 40;\n        }\n        while\
    \ (n >= 10) {\n            s += \"x\"; n -= 10;\n        }\n        if (n >= 9)\
    \ {\n            s += \"ix\"; n -= 9;\n        }\n        if (n >= 5) {\n    \
    \        s += \"v\"; n -= 5;\n        }\n        if (n >= 4) {\n            s\
    \ += \"iv\"; n -= 4;\n        }\n        while (n >= 1) {\n            s += \"\
    i\"; n -= 1;\n        }\n        return s;\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToMiniRomanDigit(digit : Int, letter: Char) : String = {\n      \
    \      if (digit == 0) {\n                return \"\"\n            } else if (digit\
    \ < 4) {\n                return (letter.toString * digit)\n            } else\
    \ if (digit == 4) {\n                return letter.toString + (letter.toUpper).toString\n\
    \            } else if (digit < 9) {\n                return (letter.toUpper).toString\
    \ + (letter.toString * (digit - 5))\n            } else {\n                return\
    \ letter.toString + (letter.toString).toUpper\n            }\n        }\n    \
    \    val thousands = (number % 10000 / 1000).toInt\n        val hundreds = (number\
    \ % 1000 / 100).toInt\n        val tens = (number % 100 / 10).toInt\n        val\
    \ ones = (number % 10).toInt\n        return (intToMiniRomanDigit(thousands, 'm')\
    \ + intToMiniRomanDigit(hundreds, 'c') + intToMiniRomanDigit(tens, 'x') + intToMiniRomanDigit(ones,\
    \ 'i')).toLowerCase\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu9kw1nw4.scala:25:59 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mreturn\e[0m letter.toString + (letter.toString).toUpper\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value toUpper is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1660010365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = new LinkedHashMap[Int, String]\n        numerals.put(1000,\
    \ \"m\")\n        numerals.put(900, \"cm\")\n        numerals.put(500, \"d\")\n\
    \        numerals.put(400, \"cd\")\n        numerals.put(100, \"c\")\n       \
    \ numerals.put(90, \"xc\")\n        numerals.put(50, \"l\")\n        numerals.put(40,\
    \ \"xl\")\n        numerals.put(10, \"x\")\n        numerals.put(9, \"ix\")\n\
    \        numerals.put(5, \"v\")\n        numerals.put(4, \"iv\")\n        numerals.put(1,\
    \ \"i\")\n        var remaining = number\n        var output = \"\"\n        while\
    \ (remaining > 0) {\n            var divided = false\n            for (key <-\
    \ numerals.keys) {\n                if (remaining >= key) {\n                \
    \    remaining -= key\n                    output += numerals(key)\n         \
    \           divided = true\n                    break\n                }\n   \
    \         }\n            if (!divided) remaining = 0\n        }\n        output\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk0of60yk.scala:38:20 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010363
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Given two maps, one mapping number values to roman numerals and\n   \
    \     // another mapping number values to number of times that number should\n\
    \        // appear in the final result, recursively obtain the final result.\n\
    \        def helper(result : String, map1 : Map[Int, String], map2 : Map[Int,\
    \ Int]) : String = {\n            if (map1.isEmpty) result\n            else {\n\
    \                val n = map1.head._1\n                val s = map1.head._2\n\
    \                val e = map2(n)\n                helper(result + s * e, map1.tail,\
    \ map2)\n            }\n        }\n        // Given a number, obtain its roman\
    \ numeral equivalent as a string,\n        // and return it in lowercase.\n  \
    \      def intToMiniRomanHelper(number : Long) : String = {\n            // Given\
    \ a number, obtain the number of times its largest digit\n            // appears\
    \ in that number.\n            def getMaxCount(number : Long) : Int = {\n    \
    \            val d = number.toString.length\n                val e = floor(log10(number)).toInt\n\
    \                return (d - e - 1)\n            }\n            // Given two digits,\
    \ obtain their roman numeral equivalent as a string.\n            def getRoman(a\
    \ : Int, b : Int) : String = {\n                if (a == b) {\n              \
    \      val s = map(b)\n                    return s * a\n                }\n \
    \               else {\n                    val max = List(a, b).max\n       \
    \             val min = List(a, b).min\n                    return map(max) +\
    \ map(min)\n                }\n            }\n            // Given a number and\
    \ its largest digit, obtain its roman numeral\n            // equivalent as a\
    \ string.\n            def intToMiniRomanHelper2(number : Long, n : Int) : String\
    \ = {\n                val d = number.toString.length\n                if (d ==\
    \ 1) {\n                    return map(number.toInt)\n                }\n    \
    \            else if (d == 2) {\n                    val a = number.toString.charAt(0).asDigit\n\
    \                    val b = number.toString.charAt(1).asDigit\n             \
    \       return getRoman(\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvq_bw5rx.scala:59:36 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m                    \e[33mreturn\e[0m getRoman(\n\e[31m\e\
    [31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m     \
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvq_bw5rx.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpvq_bw5rx.scala:40:28 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                    \e[33mval\e[0m \e[36ms\e[0m = map(b)\n\e[31m\e\
    [31m   |\e[0m                            ^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Not found: map\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvq_bw5rx.scala:46:27 ------------------------\e[0m\e[0m\n\e[31m46 |\e\
    [0m                    \e[33mreturn\e[0m map(max) + map(min)\n\e[31m\e[31m   |\e\
    [0m                           ^^^\e[0m\n\e[31m   |\e[0m                      \
    \     Not found: map\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvq_bw5rx.scala:54:27\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m                    \e[33mreturn\e\
    [0m map(number.toInt)\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: map\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvq_bw5rx.scala:78:1 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpvq_bw5rx.scala:61:4 ----------------------------------------\e\
    [0m\e["
  stdout: ''
  timestamp: 1660010367
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbol = Array(\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\")\n  \
    \      val n = number.toInt\n        val sb = new StringBuilder\n        var i\
    \ = 0\n        while (n > 0) {\n            val d = n % 10\n            if (d\
    \ < 4) {\n                for (j <- 0 until d) sb.append(symbol(i))\n        \
    \    } else if (d == 4) {\n                sb.append(symbol(i))\n            \
    \    sb.append(symbol(i + 1))\n            } else if (d < 9) {\n             \
    \   sb.append(symbol(i + 1))\n                for (j <- 0 until d - 5) sb.append(symbol(i))\n\
    \            } else {\n                sb.append(symbol(i))\n                sb.append(symbol(i\
    \ + 2))\n            }\n            n /= 10\n            i += 2\n        }\n \
    \       sb.reverse.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0uzgk6v.scala:33:14 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            n /= \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member of\
    \ Int - did you mean n.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010368
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var x = number\n        val num = List[Long](1000,\
    \ 500, 100, 50, 10, 5, 1)\n        val sym = List[String](\"m\", \"d\", \"c\"\
    , \"l\", \"x\", \"v\", \"i\")\n        var i = 0\n        while (x > 0) {\n  \
    \          val n = x / num(i)\n            val v = sym(i)\n            x %= num(i)\n\
    \            roman += v * n.toInt\n            if (x >= num(i) - num(i + 2)) {\n\
    \                roman += sym(i + 2) + sym(i)\n                x -= num(i) - num(i\
    \ + 2)\n            }\n            i += 2\n        }\n        return roman\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 8\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.intToMiniRoman(tmpxt7__ut_.scala:25)\n\tat Problem$.main(tmpxt7__ut_.scala:35)\n\
    \tat Problem.main(tmpxt7__ut_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010369
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     return List(\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\")(0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpohv88ti8.scala:18)\n\tat Problem.main(tmpohv88ti8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010369
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val minis = List(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\")\n        val tens = List(\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\")\n        val hundreds = List(\"\
    \", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n\
    \        val thousands = List(\"\", \"m\", \"mm\", \"mmm\")\n        return List(\n\
    \            thousands(floor(number / 1000).toInt),\n            hundreds(floor((number\
    \ % 1000) / 100).toInt),\n            tens(floor((number % 100) / 10).toInt),\n\
    \            minis(floor(number % 10).toInt)\n        ).fold(\"\")(_ + _)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     require(number >= 1 && number <= 1000)\n        val m = number / 1000\n\
    \        val c = (number % 1000) / 100\n        val x = (number % 100) / 10\n\
    \        val i = number % 10\n        val md = Vector((\"m\", 1), (\"mm\", 2),\
    \ (\"mmm\", 3))\n        val cd = Vector((\"c\", 1), (\"cc\", 2), (\"ccc\", 3),\
    \ (\"cd\", 4), (\"d\", 5), (\"dc\", 6), (\"dcc\", 7), (\"dccc\", 8), (\"cm\",\
    \ 9))\n        val xd = Vector((\"x\", 1), (\"xx\", 2), (\"xxx\", 3), (\"xl\"\
    , 4), (\"l\", 5), (\"lx\", 6), (\"lxx\", 7), (\"lxxx\", 8), (\"xc\", 9))\n   \
    \     val id = Vector((\"i\", 1), (\"ii\", 2), (\"iii\", 3), (\"iv\", 4), (\"\
    v\", 5), (\"vi\", 6), (\"vii\", 7), (\"viii\", 8), (\"ix\", 9))\n        md(m)\
    \ + cd(c) + xd(x) + id(i)\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrwj48va.scala:24:11\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        md(m) + cd(c) + xd(x)\
    \ + id(i)\n\e[31m\e[31m   |\e[0m           ^\e[0m\n\e[31m   |\e[0m           Found:\
    \    (m : Long)\n\e[31m   |\e[0m           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxrwj48va.scala:24:19 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        md(m) + cd(c) + xd(x) + id(i)\n\e[31m\e[31m \
    \  |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   Found: \
    \   (c : Long)\n\e[31m   |\e[0m                   Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010368
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val map = Map(1 -> \"i\", 2 -> \"ii\", 3 -> \"iii\", 4 -> \"iv\", 5 -> \"\
    v\", 6 -> \"vi\", 7 -> \"vii\", 8 -> \"viii\", 9 -> \"ix\", 10 -> \"x\", 20 ->\
    \ \"xx\", 30 -> \"xxx\", 40 -> \"xl\", 50 -> \"l\", 60 -> \"lx\", 70 -> \"lxx\"\
    , 80 -> \"lxxx\", 90 -> \"xc\", 100 -> \"c\", 200 -> \"cc\", 300 -> \"ccc\", 400\
    \ -> \"cd\", 500 -> \"d\", 600 -> \"dc\", 700 -> \"dcc\", 800 -> \"dccc\", 900\
    \ -> \"cm\", 1000 -> \"m\")\n        val nums = List(1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1)\n        val digits = number.toString.map(_.asDigit).toList\n\
    \        var result = List[Int]()\n        for (i <- 1 to digits.length) {\n \
    \           if (i == 1) result ::= digits(digits.length - i) * pow(10, i - 1).toInt\n\
    \            else result ::= digits(digits.length - i) * pow(10, i - 1).toInt\n\
    \        }\n        result.map(number => map(number)).mkString(\"\").toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: 0\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.intToMiniRoman$$anonfun$2(tmp8ux544hu.scala:23)\n\
    \tat Problem$.intToMiniRoman$$anonfun$adapted$1(tmp8ux544hu.scala:23)\n\tat scala.collection.immutable.List.map(List.scala:250)\n\
    \tat Problem$.intToMiniRoman(tmp8ux544hu.scala:23)\n\tat Problem$.main(tmp8ux544hu.scala:30)\n\
    \tat Problem.main(tmp8ux544hu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var x = number\n        while (x >= 1000) {\n\
    \            roman += \"m\"\n            x -= 1000\n        }\n        while (x\
    \ >= 500) {\n            roman += \"d\"\n            x -= 500\n        }\n   \
    \     while (x >= 100) {\n            roman += \"c\"\n            x -= 100\n \
    \       }\n        while (x >= 50) {\n            roman += \"l\"\n           \
    \ x -= 50\n        }\n        while (x >= 10) {\n            roman += \"x\"\n\
    \            x -= 10\n        }\n        while (x >= 5) {\n            roman +=\
    \ \"v\"\n            x -= 5\n        }\n        while (x >= 1) {\n           \
    \ roman += \"i\"\n            x -= 1\n        }\n        roman\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7x98yq2i.scala:48)\n\tat Problem.main(tmp7x98yq2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010370
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val symbols =\n            Array(\n                ('i', 1),\n         \
    \       ('v', 5),\n                ('x', 10),\n                ('l', 50),\n  \
    \              ('c', 100),\n                ('d', 500),\n                ('m',\
    \ 1000)\n            )\n        var result = new StringBuilder\n        var num\
    \ = number\n        var i = symbols.length - 1\n        while (num > 0) {\n  \
    \          var c = ' '\n            while (i >= 0 && symbols(i)._2 <= num) {\n\
    \                c = symbols(i)._1\n                num -= symbols(i)._2\n   \
    \         }\n            result.append(c)\n            i -= 1\n        }\n   \
    \     result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9adej1ju.scala:40)\n\tat Problem.main(tmp9adej1ju.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010371
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1) return \"\"\n        var num = number\n        var str =\
    \ \"\"\n        while (num >= 1000) {\n            str += \"m\"\n            num\
    \ -= 1000\n        }\n        if (num >= 900) {\n            str += \"cm\"\n \
    \           num -= 900\n        }\n        if (num >= 500) {\n            str\
    \ += \"d\"\n            num -= 500\n        }\n        if (num >= 400) {\n   \
    \         str += \"cd\"\n            num -= 400\n        }\n        while (num\
    \ >= 100) {\n            str += \"c\"\n            num -= 100\n        }\n   \
    \     if (num >= 90) {\n            str += \"xc\"\n            num -= 90\n   \
    \     }\n        if (num >= 50) {\n            str += \"l\"\n            num -=\
    \ 50\n        }\n        if (num >= 40) {\n            str += \"xl\"\n       \
    \     num -= 40\n        }\n        while (num >= 10) {\n            str += \"\
    x\"\n            num -= 10\n        }\n        if (num >= 9) {\n            str\
    \ += \"ix\"\n            num -= 9\n        }\n        if (num >= 5) {\n      \
    \      str += \"v\"\n            num -= 5\n        }\n        if (num >= 4) {\n\
    \            str += \"iv\"\n            num -= 4\n        }\n        while (num\
    \ >= 1) {\n            str += \"i\"\n            num -= 1\n        }\n       \
    \ return str\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010370
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = Vector(\n            Vector(\"\",\"i\",\"ii\",\"iii\",\"iv\"\
    ,\"v\",\"vi\",\"vii\",\"viii\",\"ix\"),\n            Vector(\"\",\"x\",\"xx\"\
    ,\"xxx\",\"xl\",\"l\",\"lx\",\"lxx\",\"lxxx\",\"xc\"),\n            Vector(\"\"\
    ,\"c\",\"cc\",\"ccc\",\"cd\",\"d\",\"dc\",\"dcc\",\"dccc\",\"cm\"),\n        \
    \    Vector(\"\",\"m\",\"mm\",\"mmm\",\"mv\",\"v\",\"vm\",\"vmm\",\"vmmm\",\"\
    mx\"),\n            Vector(\"\",\"x\",\"xx\",\"xxx\",\"xl\",\"l\",\"lx\",\"lxx\"\
    ,\"lxxx\",\"xc\")\n        )\n        def intToMiniRomanHelper(number : Long,\
    \ index : Int) : String = {\n            if (number == 0) \"\"\n            else\
    \ roman(index)((number % 10).toInt) + intToMiniRomanHelper(number / 10, index\
    \ + 1)\n        }\n        intToMiniRomanHelper(number, 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphx9azjp7.scala:29)\n\tat Problem.main(tmphx9azjp7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        val result = new StringBuilder\n        while\
    \ (num >= 1000) {\n            result.append(\"m\")\n            num -= 1000\n\
    \        }\n        if (num >= 900) {\n            result.append(\"cm\")\n   \
    \         num -= 900\n        }\n        while (num >= 500) {\n            result.append(\"\
    d\")\n            num -= 500\n        }\n        if (num >= 400) {\n         \
    \   result.append(\"cd\")\n            num -= 400\n        }\n        while (num\
    \ >= 100) {\n            result.append(\"c\")\n            num -= 100\n      \
    \  }\n        if (num >= 90) {\n            result.append(\"xc\")\n          \
    \  num -= 90\n        }\n        while (num >= 50) {\n            result.append(\"\
    l\")\n            num -= 50\n        }\n        if (num >= 40) {\n           \
    \ result.append(\"xl\")\n            num -= 40\n        }\n        while (num\
    \ >= 10) {\n            result.append(\"x\")\n            num -= 10\n        }\n\
    \        if (num >= 9) {\n            result.append(\"ix\")\n            num -=\
    \ 9\n        }\n        while (num >= 5) {\n            result.append(\"v\")\n\
    \            num -= 5\n        }\n        if (num >= 4) {\n            result.append(\"\
    iv\")\n            num -= 4\n        }\n        while (num >= 1) {\n         \
    \   result.append(\"i\")\n            num -= 1\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // First, convert number to an array of digits in base 10,\n        // then\
    \ convert each digit to a base 5 number\n        // Then, map each base 5 number\
    \ to the proper roman numeral, i.e.\n        // (0, 1, 2, 3, 4) => ('', 'i', 'v',\
    \ 'x', 'l')\n        // Note: This is not a very efficient solution, but it does\
    \ not rely on\n        // any mutable state, which is the basis of the original\
    \ problem.\n        // Also, this solution does not need to know the length of\
    \ number,\n        // so, for example, if the problem was to convert a long (64-bit\
    \ integer)\n        // instead of an int (32-bit integer), this solution would\
    \ not have to change.\n        // I don't know how efficient this solution is,\
    \ but it seems to be fast enough.\n        // I was able to solve the problem\
    \ in under a minute using this solution.\n        val toRoman = (digit : Long)\
    \ => {\n            if (digit < 0 || digit > 4) \"\"\n            else if (digit\
    \ == 1) \"i\"\n            else if (digit == 2) \"v\"\n            else if (digit\
    \ == 3) \"x\"\n            else if (digit == 4) \"l\"\n            else \"\"\n\
    \        }\n        val toBase5 = (digit : Long) => {\n            if (digit <\
    \ 0 || digit > 9) 0\n            else if (digit == 0) 0\n            else if (digit\
    \ == 1) 1\n            else if (digit == 2) 2\n            else if (digit == 3)\
    \ 3\n            else if (digit == 4) 4\n            else if (digit == 5) 2\n\
    \            else if (digit == 6) 3\n            else if (digit == 7) 4\n    \
    \        else if (digit == 8) 3\n            else if (digit == 9) 4\n        \
    \    else 0\n        }\n        val toDigits = (number : Long) => {\n        \
    \    if (number < 10) Array(number)\n            else toDigits(number / 10) :+\
    \ (number % 10)\n        }\n        (toDigits(number) map toBase5) map toRoman\
    \ mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpis7vw2wb.scala:50:17 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33melse\e[0m toDigits(number / \e[31m10\e\
    [0m) :+ (number % \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\
    \e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mtoDigits\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpis7vw2wb.scala:52:43\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m        (toDigits(number) map\
    \ toBase5) map toRoman mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                          Found:    (toRoman : Long => String)\n\e[31m   |\e\
    [0m                                    Required: Int => Any\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010371
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = number\n        var res = \"\"\n        while (num > 0) {\n  \
    \          if (num >= 1000) {\n                res += \"m\"\n                num\
    \ -= 1000\n            } else if (num >= 900) {\n                res += \"cm\"\
    \n                num -= 900\n            } else if (num >= 500) {\n         \
    \       res += \"d\"\n                num -= 500\n            } else if (num >=\
    \ 400) {\n                res += \"cd\"\n                num -= 400\n        \
    \    } else if (num >= 100) {\n                res += \"c\"\n                num\
    \ -= 100\n            } else if (num >= 90) {\n                res += \"xc\"\n\
    \                num -= 90\n            } else if (num >= 50) {\n            \
    \    res += \"l\"\n                num -= 50\n            } else if (num >= 40)\
    \ {\n                res += \"xl\"\n                num -= 40\n            } else\
    \ if (num >= 10) {\n                res += \"x\"\n                num -= 10\n\
    \            } else if (num >= 9) {\n                res += \"ix\"\n         \
    \       num -= 9\n            } else if (num >= 5) {\n                res += \"\
    v\"\n                num -= 5\n            } else if (num >= 4) {\n          \
    \      res += \"iv\"\n                num -= 4\n            } else if (num >=\
    \ 1) {\n                res += \"i\"\n                num -= 1\n            }\n\
    \        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010372
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var input = number\n        var result = \"\"\n        val numbers = new\
    \ Array[String](10)\n        numbers(0) = \"\"\n        numbers(1) = \"i\"\n \
    \       numbers(2) = \"ii\"\n        numbers(3) = \"iii\"\n        numbers(4)\
    \ = \"iv\"\n        numbers(5) = \"v\"\n        numbers(6) = \"vi\"\n        numbers(7)\
    \ = \"vii\"\n        numbers(8) = \"viii\"\n        numbers(9) = \"ix\"\n    \
    \    var div = input / 10\n        var mod = input % 10\n        result = result\
    \ + numbers(mod.toInt)\n        input = div\n        if (input == 0) return result\n\
    \        div = input / 10\n        mod = input % 10\n        if (mod == 4) result\
    \ = \"xl\" + result\n        else {\n            if (mod == 9) result = \"xc\"\
    \ + result\n            else {\n                if (mod == 5) result = \"l\" +\
    \ result\n                else {\n                    result = numbers(mod.toInt).replace(\"\
    i\", \"x\") + result\n                }\n            }\n        }\n        input\
    \ = div\n        if (input == 0) return result\n        div = input / 10\n   \
    \     mod = input % 10\n        if (mod == 4) result = \"cd\" + result\n     \
    \   else {\n            if (mod == 9) result = \"cm\" + result\n            else\
    \ {\n                if (mod == 5) result = \"d\" + result\n                else\
    \ {\n                    result = numbers(mod.toInt).replace(\"i\", \"c\") + result\n\
    \                }\n            }\n        }\n        input = div\n        if\
    \ (input == 0) return result\n        div = input / 10\n        mod = input %\
    \ 10\n        result = numbers(mod.toInt).replace(\"i\", \"m\") + result\n   \
    \     return result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010371
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumeral = new StringBuilder()\n        var remainder = number\n\
    \        while (remainder > 0) {\n            if (remainder >= 1000) {\n     \
    \           romanNumeral.append(\"m\")\n                remainder -= 1000\n  \
    \          } else if (remainder >= 900) {\n                romanNumeral.append(\"\
    cm\")\n                remainder -= 900\n            } else if (remainder >= 500)\
    \ {\n                romanNumeral.append(\"d\")\n                remainder -=\
    \ 500\n            } else if (remainder >= 400) {\n                romanNumeral.append(\"\
    cd\")\n                remainder -= 400\n            } else if (remainder >= 100)\
    \ {\n                romanNumeral.append(\"c\")\n                remainder -=\
    \ 100\n            } else if (remainder >= 90) {\n                romanNumeral.append(\"\
    xc\")\n                remainder -= 90\n            } else if (remainder >= 50)\
    \ {\n                romanNumeral.append(\"l\")\n                remainder -=\
    \ 50\n            } else if (remainder >= 40) {\n                romanNumeral.append(\"\
    xl\")\n                remainder -= 40\n            } else if (remainder >= 10)\
    \ {\n                romanNumeral.append(\"x\")\n                remainder -=\
    \ 10\n            } else if (remainder >= 9) {\n                romanNumeral.append(\"\
    ix\")\n                remainder -= 9\n            } else if (remainder >= 5)\
    \ {\n                romanNumeral.append(\"v\")\n                remainder -=\
    \ 5\n            } else if (remainder >= 4) {\n                romanNumeral.append(\"\
    iv\")\n                remainder -= 4\n            } else if (remainder >= 1)\
    \ {\n                romanNumeral.append(\"i\")\n                remainder -=\
    \ 1\n            }\n        }\n        romanNumeral.toString()\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010375
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def lookup(x : Long) : Char = x match {\n            case 1l => 'i'\n  \
    \          case 5l => 'v'\n            case 10l => 'x'\n            case 50l =>\
    \ 'l'\n            case 100l => 'c'\n            case 500l => 'd'\n          \
    \  case 1000l => 'm'\n        }\n        def helper(x : Long, tens : Long) : String\
    \ = {\n            if (x == 0) return \"\"\n            val (m, n) = (x / tens,\
    \ x % tens)\n            if (m == 4) return lookup(tens) + lookup(tens * 5) +\
    \ helper(n, tens)\n            if (m == 9) return lookup(tens) + lookup(tens *\
    \ 10) + helper(n, tens)\n            if (m >= 5) return lookup(tens * 5) + helper(x\
    \ - 5 * tens, tens)\n            lookup(tens) + helper(n, tens)\n        }\n \
    \       helper(number, 1l)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyngzpklt.scala:35)\n\tat Problem.main(tmpyngzpklt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val map = Map[Long, String](\n            1l -> \"i\",\n            4l ->\
    \ \"iv\",\n            5l -> \"v\",\n            9l -> \"ix\",\n            10l\
    \ -> \"x\",\n            40l -> \"xl\",\n            50l -> \"l\",\n         \
    \   90l -> \"xc\",\n            100l -> \"c\",\n            400l -> \"cd\",\n\
    \            500l -> \"d\",\n            900l -> \"cm\",\n            1000l ->\
    \ \"m\")\n        var rest = number\n        var result = \"\"\n        while\
    \ (rest > 0) {\n            val factor = (rest).toString.length - 1\n        \
    \    val power = pow(10, factor).toLong\n            val div = (rest / power)\
    \ * power\n            if (map.contains(div)) {\n                result += map(div)\n\
    \                rest -= div\n            } else {\n                val newdiv\
    \ = power\n                result += map(newdiv)\n                rest -= newdiv\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmq8_l0k8.scala:50)\n\tat Problem.main(tmpmq8_l0k8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val lookup : Array[(Long, Char)] = Array((1l, 'i'), (5l, 'v'), (10l, 'x'),\
    \ (50l, 'l'), (100l, 'c'), (500l, 'd'), (1000l, 'm'))\n      def helper(n : Long,\
    \ result : String) : String = n match {\n        case n if n == 0 => result\n\
    \        case n if n < 4 => helper(n - 1, result + lookup(0)._2)\n        case\
    \ n if n == 4 => helper(n - 4, result + lookup(0)._2 + lookup(1)._2)\n       \
    \ case n if n < 9 => helper(n - 5, result + lookup(1)._2)\n        case n if n\
    \ == 9 => helper(n - 9, result + lookup(0)._2 + lookup(2)._2)\n        case n\
    \ if n < 40 => helper(n - 10, result + lookup(2)._2)\n        case n if n < 50\
    \ => helper(n - 40, result + lookup(2)._2 + lookup(3)._2)\n        case n if n\
    \ < 90 => helper(n - 50, result + lookup(3)._2)\n        case n if n < 100 =>\
    \ helper(n - 90, result + lookup(2)._2 + lookup(4)._2)\n        case n if n <\
    \ 400 => helper(n - 100, result + lookup(4)._2)\n        case n if n < 500 =>\
    \ helper(n - 400, result + lookup(4)._2 + lookup(5)._2)\n        case n if n <\
    \ 900 => helper(n - 500, result + lookup(5)._2)\n        case n if n < 1000 =>\
    \ helper(n - 900, result + lookup(4)._2 + lookup(6)._2)\n        case n if n <\
    \ 4000 => helper(n - 1000, result + lookup(6)._2)\n        case n if n < 5000\
    \ => helper(n - 4000, result + lookup(6)._2 + lookup(5)._2)\n        case n if\
    \ n < 9000 => helper(n - 5000, result + lookup(5)._2)\n        case n if n < 10000\
    \ => helper\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptce6i0ti.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptce6i0ti.scala:33:31\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mcase\e[0m n \e\
    [33mif\e[0m n < \e[31m10000\e[0m => helper\n\e[31m\e[31m   |\e[0m            \
    \                   ^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \  Found:    (Long, String) => String\n\e[31m   |\e[0m                       \
    \        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptce6i0ti.scala:52:1 ---------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmptce6i0ti.scala:35:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m35 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val r = new StringBuilder()\n        var remaining = number\n        while\
    \ (remaining >= 1000) {\n            r.append(\"m\")\n            remaining -=\
    \ 1000\n        }\n        while (remaining >= 500) {\n            r.append(\"\
    d\")\n            remaining -= 500\n        }\n        while (remaining >= 100)\
    \ {\n            r.append(\"c\")\n            remaining -= 100\n        }\n  \
    \      while (remaining >= 50) {\n            r.append(\"l\")\n            remaining\
    \ -= 50\n        }\n        while (remaining >= 10) {\n            r.append(\"\
    x\")\n            remaining -= 10\n        }\n        while (remaining >= 5) {\n\
    \            r.append(\"v\")\n            remaining -= 5\n        }\n        while\
    \ (remaining >= 1) {\n            r.append(\"i\")\n            remaining -= 1\n\
    \        }\n        return r.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphmxq_j6n.scala:48)\n\tat Problem.main(tmphmxq_j6n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0 || number > 1000) throw new Exception(\"Invalid number \"\
    \ + number)\n        var result = new StringBuilder\n        var remainder = number\n\
    \        val mapper = Map(1000 -> \"m\", 900 -> \"cm\", 500 -> \"d\", 400 -> \"\
    cd\", 100 -> \"c\", 90 -> \"xc\", 50 -> \"l\", 40 -> \"xl\", 10 -> \"x\", 9 ->\
    \ \"ix\", 5 -> \"v\", 4 -> \"iv\", 1 -> \"i\")\n        while (remainder > 0)\
    \ {\n            val n : Int = mapper.keys.toList.filter(n => n <= remainder).max\n\
    \            val s : String = mapper(n)\n            result.append(s)\n      \
    \      remainder -= n\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\";\n        while (number > 0) {\n            if (number\
    \ >= 1000) {\n                result += \"m\";\n                number -= 1000;\n\
    \            } else if (number >= 900) {\n                result += \"cm\";\n\
    \                number -= 900;\n            } else if (number >= 500) {\n   \
    \             result += \"d\";\n                number -= 500;\n            }\
    \ else if (number >= 400) {\n                result += \"cd\";\n             \
    \   number -= 400;\n            } else if (number >= 100) {\n                result\
    \ += \"c\";\n                number -= 100;\n            } else if (number >=\
    \ 90) {\n                result += \"xc\";\n                number -= 90;\n  \
    \          } else if (number >= 50) {\n                result += \"l\";\n    \
    \            number -= 50;\n            } else if (number >= 40) {\n         \
    \       result += \"xl\";\n                number -= 40;\n            } else if\
    \ (number >= 10) {\n                result += \"x\";\n                number -=\
    \ 10;\n            } else if (number >= 9) {\n                result += \"ix\"\
    ;\n                number -= 9;\n            } else if (number >= 5) {\n     \
    \           result += \"v\";\n                number -= 5;\n            } else\
    \ if (number >= 4) {\n                result += \"iv\";\n                number\
    \ -= 4;\n            } else if (number >= 1) {\n                result += \"i\"\
    ;\n                number -= 1;\n            }\n        }\n        return result;\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp81y7k50_.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                number -= \e[31m1000\e[0m;\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp81y7k50_.scala:22:23 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m                number -= \e[31m900\e[0m;\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp81y7k50_.scala:25:23 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                number -= \e[31m500\e[0m;\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp81y7k50_.scala:28:23 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                number -= \e[31m400\e[0m;\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp81y7k50_.scala:31:23\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                number -=\
    \ \e[31m100\e[0m;\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              value -= is not a member of Long - did you mean number.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp81y7k50_.scala:34:23 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                number -= \e[31m90\e[0m;\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -=\
    \ is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp81y7k50_.scala:37:23 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m                number -= \e[31m50\e[0m;\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp81"
  stdout: ''
  timestamp: 1660010377
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0) {\n            return \"\"\n        }\n        if (number\
    \ >= 1000) {\n            return \"m\" + intToMiniRoman(number - 1000)\n     \
    \   }\n        if (number >= 900) {\n            return \"cm\" + intToMiniRoman(number\
    \ - 900)\n        }\n        if (number >= 500) {\n            return \"d\" +\
    \ intToMiniRoman(number - 500)\n        }\n        if (number >= 400) {\n    \
    \        return \"cd\" + intToMiniRoman(number - 400)\n        }\n        if (number\
    \ >= 100) {\n            return \"c\" + intToMiniRoman(number - 100)\n       \
    \ }\n        if (number >= 90) {\n            return \"xc\" + intToMiniRoman(number\
    \ - 90)\n        }\n        if (number >= 50) {\n            return \"l\" + intToMiniRoman(number\
    \ - 50)\n        }\n        if (number >= 40) {\n            return \"xl\" + intToMiniRoman(number\
    \ - 40)\n        }\n        if (number >= 10) {\n            return \"x\" + intToMiniRoman(number\
    \ - 10)\n        }\n        if (number >= 9) {\n            return \"ix\" + intToMiniRoman(number\
    \ - 9)\n        }\n        if (number >= 5) {\n            return \"v\" + intToMiniRoman(number\
    \ - 5)\n        }\n        if (number >= 4) {\n            return \"iv\" + intToMiniRoman(number\
    \ - 4)\n        }\n        if (number >= 1) {\n            return \"i\" + intToMiniRoman(number\
    \ - 1)\n        }\n        \"\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tval romanNumerals = new Array[String](4)\n    \tromanNumerals(0) = \"i\"\n\
    \    \tromanNumerals(1) = \"v\"\n    \tromanNumerals(2) = \"x\"\n    \tromanNumerals(3)\
    \ = \"l\"\n    \tvar position = -1\n    \twhile (number > 0) {\n    \t\tval digit\
    \ = (number % 10).toInt\n    \t\tif (digit == 1) {\n    \t\t\tif (position ==\
    \ -1) {\n    \t\t\t\tposition = 0\n    \t\t\t} else {\n    \t\t\t\tposition +=\
    \ 1\n    \t\t\t}\n    \t\t} else if (digit == 2) {\n    \t\t\tif (position ==\
    \ -1) {\n    \t\t\t\tposition = 0\n    \t\t\t} else {\n    \t\t\t\tposition +=\
    \ 1\n    \t\t\t}\n    \t\t\tromanNumerals(position) = romanNumerals(position)\
    \ + romanNumerals(position)\n    \t\t} else if (digit == 3) {\n    \t\t\tif (position\
    \ == -1) {\n    \t\t\t\tposition = 0\n    \t\t\t} else {\n    \t\t\t\tposition\
    \ += 1\n    \t\t\t}\n    \t\t\tromanNumerals(position) = romanNumerals(position)\
    \ + romanNumerals(position) + romanNumerals(position)\n    \t\t} else if (digit\
    \ == 4) {\n    \t\t\tif (position == -1) {\n    \t\t\t\tposition = 0\n    \t\t\
    \t} else {\n    \t\t\t\tposition += 1\n    \t\t\t}\n    \t\t\tromanNumerals(position)\
    \ = romanNumerals(position) + romanNumerals(position + 1)\n    \t\t} else if (digit\
    \ == 5) {\n    \t\t\tif (position == -1) {\n    \t\t\t\tposition = 0\n    \t\t\
    \t} else {\n    \t\t\t\tposition += 1\n    \t\t\t}\n    \t\t\tromanNumerals(position)\
    \ = romanNumerals\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3ry7trjw.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3ry7trjw.scala:56:34\
    \ --------------------\e[0m\e[0m\n\e[31m56 |\e[0m    \t\t\tromanNumerals(position)\
    \ = romanNumerals\n\e[31m\e[31m   |\e[0m    \t\t\t                          ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    (romanNumerals :\
    \ Array[String])\n\e[31m   |\e[0m                               Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp3ry7trjw.scala:58:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m58 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) {\n            return \"\"\n        }\n\
    \        val romans = List((\"m\", 1000), (\"cm\", 900), (\"d\", 500), (\"cd\"\
    , 400), (\"c\", 100), (\"xc\", 90), (\"l\", 50), (\"xl\", 40), (\"x\", 10), (\"\
    ix\", 9), (\"v\", 5), (\"iv\", 4), (\"i\", 1))\n        var copy = number\n  \
    \      var result = \"\"\n        while (copy > 0) {\n            var rem = copy\n\
    \            for (roman <- romans) {\n                if (rem >= roman._2) {\n\
    \                    result += roman._1\n                    rem -= roman._2\n\
    \                }\n            }\n            copy = rem\n        }\n       \
    \ return result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnyztb3tc.scala:36)\n\tat Problem.main(tmpnyztb3tc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToRoman(n : Long, s : String, p : Long) : String = {\n          \
    \  if (n >= p * 1000) intToRoman(n, s + \"m\", p * 1000)\n            else if\
    \ (n >= p * 900) intToRoman(n - p * 900, s + \"cm\", p)\n            else if (n\
    \ >= p * 500) intToRoman(n - p * 500, s + \"d\", p)\n            else if (n >=\
    \ p * 400) intToRoman(n - p * 400, s + \"cd\", p)\n            else if (n >= p\
    \ * 100) intToRoman(n - p * 100, s + \"c\", p)\n            else if (n >= p *\
    \ 90) intToRoman(n - p * 90, s + \"xc\", p)\n            else if (n >= p * 50)\
    \ intToRoman(n - p * 50, s + \"l\", p)\n            else if (n >= p * 40) intToRoman(n\
    \ - p * 40, s + \"xl\", p)\n            else if (n >= p * 10) intToRoman(n - p\
    \ * 10, s + \"x\", p)\n            else if (n >= p * 9) intToRoman(n - p * 9,\
    \ s + \"ix\", p)\n            else if (n >= p * 5) intToRoman(n - p * 5, s + \"\
    v\", p)\n            else if (n >= p * 4) intToRoman(n - p * 4, s + \"iv\", p)\n\
    \            else if (n >= p) intToRoman(n - p, s + \"i\", p)\n            else\
    \ s\n        }\n        intToRoman(number, \"\", 1l).toLowerCase\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphyc00brm.scala:47)\n\tat Problem.main(tmphyc00brm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = number.toString.map(_.asDigit)\n        val roman : Array[Char]\
    \ = Array.fill(3 * digits.length)(' ')\n        val digitsToRoman : Array[Array[Char]]\
    \ = Array(Array(' ','I','II','III','IV','V','VI','VII','VIII','IX'),\n       \
    \                                                 Array(' ','X','XX','XXX','XL','L','LX','LXX','LXXX','XC'),\n\
    \                                                        Array(' ','C','CC','CCC','CD','D','DC','DCC','DCCC','CM'))\n\
    \        for (digit <- 0 until digits.length) {\n            val index = digits.length\
    \ - digit - 1\n            roman(index * 3) = digitsToRoman(0)(digits(digit))\n\
    \            roman(index * 3 + 1) = digitsToRoman(1)(digits(digit))\n        \
    \    roman(index * 3 + 2) = digitsToRoman(2)(digits(digit))\n        }\n     \
    \   roman.mkString(\"\").trim\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpfy0qa1ce.scala:17:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdigitsToRoman\e[0m : \e\
    [35mArray\e[0m[\e[35mArray\e[0m[\e[35mChar\e[0m]] = Array(Array(\e[31m' '\e[0m,\e\
    [31m'I'\e[0m,\e[31m'II','\e[0mIII\e[31m','\e[0mIV\e[31m','\e[0mV\e[31m','\e[0mVI\e\
    [31m','\e[0mVII\e[31m','\e[0mVIII\e[31m','\e[0mIX'),\n\e[31m\e[31m   |\e[0m  \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0msymbol literal 'II is no longer supported,\n\e[31m   |\e[0muse a\
    \ string literal \"II\" or an application Symbol(\"II\") instead,\n\e[31m   |\e\
    [0mor enclose in braces '{II} if you want a quoted expression.\n\e[31m   |\e[0mFor\
    \ now, you can also `import language.deprecated.symbolLiterals` to accept\n\e\
    [31m   |\e[0mthe idiom, but this possibility might no longer be available in the\
    \ future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfy0qa1ce.scala:17:72 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdigitsToRoman\e[0m : \e\
    [35mArray\e[0m[\e[35mArray\e[0m[\e[35mChar\e[0m]] = Array(Array(\e[31m' '\e[0m,\e\
    [31m'I'\e[0m,\e[31m'II','\e[0mIII\e[31m','\e[0mIV\e[31m','\e[0mV\e[31m','\e[0mVI\e\
    [31m','\e[0mVII\e[31m','\e[0mVIII\e[31m','\e[0mIX'),\n\e[31m\e[31m   |\e[0m  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                               ')' expected, but character literal\
    \ found\n\e[31m\e[31m-- Error: /tmp/tmpfy0qa1ce.scala:17:110 ----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdigitsToRoman\e[0m : \e\
    [35mArray\e[0m[\e[35mArray\e[0m[\e[35mChar\e[0m]] = Array(Array(\e[31m' '\e[0m,\e\
    [31m'I'\e[0m,\e[31m'II','\e[0mIII\e[31m','\e[0mIV\e[31m','\e[0mV\e[31m','\e[0mVI\e\
    [31m','\e[0mVII\e[31m','\e[0mVIII\e[31m','\e[0mIX'),\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                         unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpfy0qa1ce.scala:18:70\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0"
  stdout: ''
  timestamp: 1660010379
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = Map(1 -> \"i\", 2 -> \"ii\", 3 -> \"iii\", 4 -> \"iv\", 5\
    \ -> \"v\", 6 -> \"vi\", 7 -> \"vii\", 8 -> \"viii\", 9 -> \"ix\", 10 -> \"x\"\
    , 40 -> \"xl\", 50 -> \"l\", 90 -> \"xc\", 100 -> \"c\", 400 -> \"cd\", 500 ->\
    \ \"d\", 900 -> \"cm\", 1000 -> \"m\")\n        var numberToConvert = number\n\
    \        var result = \"\"\n        var n = 1000\n        while (numberToConvert\
    \ > 0) {\n            if (numberToConvert >= n) {\n                result += numerals(n)\n\
    \                numberToConvert -= n\n            }\n            else {\n   \
    \             n /= 10\n            }\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_suozsu.scala:31)\n\tat Problem.main(tmp9_suozsu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var digits = getDigits(number)\n        var I\
    \ = 1; var IV = 4; var V = 5; var IX = 9; var X = 10; var XL = 40; var L = 50;\
    \ var XC = 90; var C = 100; var CD = 400; var D = 500; var CM = 900; var M = 1000\n\
    \        for (i <- 0 until digits.length) {\n            val digit = digits(i)\n\
    \            if (digit == 0)\n                result = append(result, \"\")\n\
    \            else if (digit >= 1 && digit <= 3)\n                result = append(result,\
    \ multiply(numberRoman(I), digit))\n            else if (digit == 4)\n       \
    \         result = append(result, numberRoman(IV))\n            else if (digit\
    \ >= 5 && digit <= 8)\n                result = append(result, append(numberRoman(V),\
    \ multiply(numberRoman(I), digit - 5)))\n            else if (digit == 9)\n  \
    \              result = append(result, numberRoman(IX))\n            else if (digit\
    \ == 10)\n                result = append(result, numberRoman(X))\n          \
    \  else if (digit >= 11 && digit <= 13)\n                result = append(result,\
    \ multiply(numberRoman(X), digit - 10))\n            else if (digit == 14)\n \
    \               result = append(result, numberRoman(XL))\n            else if\
    \ (digit >= 15 && digit <= 18)\n                result = append(result, append(numberRoman(L),\
    \ multiply(numberRoman(X), digit - 15)))\n            else if (digit == 19)\n\
    \                result = append(result, numberRoman(XC))\n            else if\
    \ (digit == 20)\n                result = append(result, numberRoman(C))\n   \
    \         else if (digit >= 21 && digit <= 23)\n                result = append(result,\
    \ multiply(numberRoman(C), digit - 20))\n            else if (digit == 24)\n \
    \               result = append(result, numberRoman(CD))\n            else if\
    \ (digit >= 25 && digit <= 28)\n                result = append(result, append(numberRoman(D),\
    \ multiply(numberRoman(C), digit - 25)))\n            else if (digit == 29)\n\
    \                result = append(result, numberRoman(CM))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf3l7zyqr.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf3l7zyqr.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e\
    [36mdigits\e[0m = getDigits(number)\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: getDigits\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf3l7zyqr.scala:21:25\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                result =\
    \ append(result, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: append\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf3l7zyqr.scala:23:25\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                result =\
    \ append(result, multiply(numberRoman(I), digit))\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: append\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf3l7zyqr.scala:23:40\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                result =\
    \ append(result, multiply(numberRoman(I), digit))\n\e[31m\e[31m   |\e[0m     \
    \                                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                             Not found: multiply\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpf3l7zyqr.scala:23:49 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                result = append(result, multiply(numberRoman(I),\
    \ digit))\n\e[31m\e[31m   |\e[0m                                             \
    \    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \          Not found: n"
  stdout: ''
  timestamp: 1660010380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def convert(x : Int, y : String, z : String, w : String) : String = {\n\
    \            if (x < 4) y * x\n            else if (x == 4) y + z\n          \
    \  else if (x < 9) z + y * (x - 5)\n            else z + w\n        }\n      \
    \  val ones = number % 10\n        val tens = (number / 10) % 10\n        val\
    \ hundreds = (number / 100) % 10\n        val thousands = (number / 1000) % 10\n\
    \        convert(thousands, \"m\", \"\", \"\") + convert(hundreds, \"c\", \"d\"\
    , \"m\") + convert(tens, \"x\", \"l\", \"c\") + convert(ones, \"i\", \"v\", \"\
    x\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpfflg3k.scala:25:16\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        convert(thousands, \e\
    [31m\"m\"\e[0m, \e[31m\"\"\e[0m, \e[31m\"\"\e[0m) + convert(hundreds, \e[31m\"\
    c\"\e[0m, \e[31m\"d\"\e[0m, \e[31m\"m\"\e[0m) + convert(tens, \e[31m\"x\"\e[0m,\
    \ \e[31m\"l\"\e[0m, \e[31m\"c\"\e[0m) + convert(ones, \e[31m\"i\"\e[0m, \e[31m\"\
    v\"\e[0m, \e[31m\"x\"\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Found:    (thousands : Long)\n\e[31m   |\e\
    [0m                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptpfflg3k.scala:25:50 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        convert(thousands, \e[31m\"m\"\e[0m, \e[31m\"\"\e[0m, \e[31m\"\
    \"\e[0m) + convert(hundreds, \e[31m\"c\"\e[0m, \e[31m\"d\"\e[0m, \e[31m\"m\"\e\
    [0m) + convert(tens, \e[31m\"x\"\e[0m, \e[31m\"l\"\e[0m, \e[31m\"c\"\e[0m) + convert(ones,\
    \ \e[31m\"i\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"x\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                  ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                             Found:    (hundreds : Long)\n\e\
    [31m   |\e[0m                                             Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpfflg3k.scala:25:85 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        convert(thousands, \e[31m\"m\"\e[0m, \e[31m\"\
    \"\e[0m, \e[31m\"\"\e[0m) + convert(hundreds, \e[31m\"c\"\e[0m, \e[31m\"d\"\e\
    [0m, \e[31m\"m\"\e[0m) + convert(tens, \e[31m\"x\"\e[0m, \e[31m\"l\"\e[0m, \e\
    [31m\"c\"\e[0m) + convert(ones, \e[31m\"i\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"x\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                                                \
    \                                     ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                    Found:    (tens : Long)\n\e[31m   |\e[0m\
    \                                                 Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptp"
  stdout: ''
  timestamp: 1660010380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // I think that this way is more interesting and readable,\n        // plus\
    \ it can handle more than 1000 in case needed.\n        // Credits to http://www.dailyfreecode.com/code/convert-decimal-roman-number-1098.aspx\n\
    \        val digits = Array(\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\"\
    , \"vii\", \"viii\", \"ix\")\n        val roman = Array(\"\", \"x\", \"xx\", \"\
    xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\")\n        val thousand\
    \ = Array(\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\")\n        val result = new StringBuilder()\n        var t = (number /\
    \ 1000).toInt\n        result.append(thousand(t))\n        var h = ((number %\
    \ 1000) / 100).toInt\n        result.append(roman(h))\n        var te = ((number\
    \ % 100) / 10).toInt\n        result.append(roman(te))\n        var o = (number\
    \ % 10).toInt\n        result.append(digits(o))\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpatlstj47.scala:34)\n\tat Problem.main(tmpatlstj47.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \ \tval romans = List(\"m\",\"cm\",\"d\",\"cd\",\"c\",\"xc\",\"l\",\"xl\",\"x\"\
    ,\"ix\",\"v\",\"iv\",\"i\")\n        val numerals = List(1000,900,500,400,100,90,50,40,10,9,5,4,1)\n\
    \        val numeralsIndex = numerals.indexOf(number)\n        if (numeralsIndex\
    \ == -1) {\n        \tval nextHighest = (number / 10) * 10\n        \tval nextHighestIndex\
    \ = numerals.indexOf(nextHighest)\n        \tval nextHighestRoman = romans(nextHighestIndex)\n\
    \        \tnextHighestRoman + intToMiniRoman(number - nextHighest)\n        }\
    \ else {\n        \tromans(numeralsIndex)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4g82e6rl.scala:16:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnumerals\e[0m = List(\e\
    [31m1000\e[0m,\e[31m900\e[0m,\e[31m500\e[0m,\e[31m400\e[0m,\e[31m100\e[0m,\e[31m90\e\
    [0m,\e[31m50\e[0m,\e[31m40\e[0m,\e[31m10\e[0m,\e[31m9\e[0m,\e[31m5\e[0m,\e[31m4\e\
    [0m,\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   Incompatible\
    \ combinations of tabs and spaces in indentation prefixes.\n\e[31m   |\e[0m  \
    \ Previous indent : 4 spaces, 1 tab\n\e[31m   |\e[0m   Latest indent   : 8 spaces\n\
    \e[31m\e[31m-- Error: /tmp/tmp4g82e6rl.scala:17:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnumeralsIndex\e[0m = numerals.indexOf(number)\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   Incompatible combinations\
    \ of tabs and spaces in indentation prefixes.\n\e[31m   |\e[0m   Previous indent\
    \ : 4 spaces, 1 tab\n\e[31m   |\e[0m   Latest indent   : 8 spaces\n\e[31m\e[31m--\
    \ Error: /tmp/tmp4g82e6rl.scala:18:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (numeralsIndex == -\e[31m1\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   Incompatible combinations\
    \ of tabs and spaces in indentation prefixes.\n\e[31m   |\e[0m   Previous indent\
    \ : 4 spaces, 1 tab\n\e[31m   |\e[0m   Latest indent   : 8 spaces\n3 errors found\n"
  stdout: ''
  timestamp: 1660010378
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def convertDigit(digit : Int, ones : Char, fives : Char, tens : Char) :\
    \ String = digit match {\n            case 0 => \"\"\n            case 1 => ones.toString\n\
    \            case 2 => ones.toString + ones.toString\n            case 3 => ones.toString\
    \ + ones.toString + ones.toString\n            case 4 => ones.toString + fives.toString\n\
    \            case 5 => fives.toString\n            case 6 => fives.toString +\
    \ ones.toString\n            case 7 => fives.toString + ones.toString + ones.toString\n\
    \            case 8 => fives.toString + ones.toString + ones.toString + ones.toString\n\
    \            case 9 => ones.toString + tens.toString\n        }\n        var current\
    \ = number.toInt\n        val result = new StringBuilder\n        while (current\
    \ > 0) {\n            val currentDigit = current % 10\n            current /=\
    \ 10\n            result.insert(0, convertDigit(currentDigit, 'i', 'v', 'x'))\n\
    \        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi3oifwi2.scala:37)\n\tat Problem.main(tmpi3oifwi2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val charMap = Map(1 -> \"i\", 5 -> \"v\", 10 -> \"x\", 50 -> \"l\", 100\
    \ -> \"c\", 500 -> \"d\", 1000 -> \"m\")\n        val groupMap = Map(1 -> 3, 10\
    \ -> 2, 100 -> 1)\n        def getRomanGroup(intGroup : Int, powerOfTen : Int)\
    \ : String = {\n            if (intGroup < 4)\n                charMap(powerOfTen)\
    \ * intGroup\n            else if (intGroup == 4)\n                charMap(powerOfTen)\
    \ + charMap(powerOfTen * 5)\n            else if (intGroup == 5)\n           \
    \     charMap(powerOfTen * 5)\n            else if (intGroup < 9)\n          \
    \      charMap(powerOfTen * 5) + charMap(powerOfTen) * (intGroup - 5)\n      \
    \      else\n                charMap(powerOfTen) + charMap(powerOfTen * 10)\n\
    \        }\n        def getRoman(number : Long) : String = {\n            if (number\
    \ == 0)\n                \"\"\n            else {\n                val powerOfTen\
    \ = pow(10, groupMap(number.toString.length - 1)).toInt\n                val intGroup\
    \ = (number / powerOfTen).toInt\n                getRomanGroup(intGroup, powerOfTen)\
    \ + getRoman(number % powerOfTen)\n            }\n        }\n        getRoman(number).toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.runtime.BoxesRunTime.equalsNumNum(BoxesRunTime.java:148)\n\
    \tat scala.runtime.BoxesRunTime.equalsNumObject(BoxesRunTime.java:138)\n\tat scala.runtime.BoxesRunTime.equals2(BoxesRunTime.java:127)\n\
    \tat scala.runtime.BoxesRunTime.equals(BoxesRunTime.java:119)\n\tat scala.collection.mutable.HashMap$Node.findNode(HashMap.scala:621)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:88)\n\tat Problem$.getRomanGroup$1(tmp9bo8j_x6.scala:19)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\
    \tat Problem$.getRoman$1(tmp9bo8j_x6.scala:35)\n\tat Problem$.getRoman$1(tmp9bo8j"
  stdout: ''
  timestamp: 1660010381
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val map = Map(1 -> \"i\", 5 -> \"v\", 10 -> \"x\", 50 -> \"l\", 100 -> \"\
    c\", 500 -> \"d\", 1000 -> \"m\")\n        val roman = number.toString.reverse.toList.zipWithIndex.map\
    \ {case (digit, exponent) => {\n            val exp = pow(10, exponent).toInt\n\
    \            val digitInt = digit.toString.toInt\n            val multipliers\
    \ = (digitInt / 5) + 1\n            val romanDigit = map(exp)\n            val\
    \ romanLetter = map(exp * multipliers)\n            romanDigit.reverse.toList.map(x\
    \ => {\n                val value = if (x == '0') 0 else 1\n                if\
    \ (value <= digitInt % 5) romanLetter else romanDigit\n            }).mkString(\"\
    \")\n        }}.mkString(\"\")\n        roman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: 2\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.$anonfun$1(tmp1kzqykde.scala:21)\n\
    \tat scala.collection.immutable.List.map(List.scala:246)\n\tat Problem$.intToMiniRoman(tmp1kzqykde.scala:26)\n\
    \tat Problem$.main(tmp1kzqykde.scala:30)\n\tat Problem.main(tmp1kzqykde.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010382
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumeralMap = Map(1l -> \"i\", 5l -> \"v\", 10l -> \"x\", 50l ->\
    \ \"l\", 100l -> \"c\", 500l -> \"d\", 1000l -> \"m\")\n        var numerals =\
    \ new ListBuffer[String]\n        var numberCopy = number\n        var numeral\
    \ : String = null\n        while (numberCopy > 0) {\n            val place = pow(10,\
    \ (numberCopy.toString.length - 1)).toLong\n            val digit = numberCopy\
    \ / place\n            if (digit > 0) {\n                if (digit < 4) numeral\
    \ = romanNumeralMap(place) * digit.toInt\n                else if (digit == 4)\
    \ numeral = romanNumeralMap(place) + romanNumeralMap(place * 5)\n            \
    \    else if (digit < 9) numeral = romanNumeralMap(place * 5) + romanNumeralMap(place)\
    \ * (digit.toInt - 5)\n                else numeral = romanNumeralMap(place) +\
    \ romanNumeralMap(place * 10)\n                numerals += numeral\n         \
    \   }\n            numberCopy -= digit * place\n        }\n        numerals.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010382
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var dict = Map[Int, String]()\n        dict += (1 -> \"i\")\n        dict\
    \ += (5 -> \"v\")\n        dict += (10 -> \"x\")\n        dict += (50 -> \"l\"\
    )\n        dict += (100 -> \"c\")\n        dict += (500 -> \"d\")\n        dict\
    \ += (1000 -> \"m\")\n        var result = new StringBuilder()\n        var power\
    \ = 0\n        var n = number\n        while (n > 0) {\n            var digit\
    \ = (n % 10).toInt\n            n /= 10\n            if (digit == 4) {\n     \
    \           result.insert(0, dict(pow(10, power).toInt).charAt(0))\n         \
    \       result.insert(0, dict(5 * pow(10, power).toInt).charAt(0))\n         \
    \   } else if (digit == 9) {\n                result.insert(0, dict(pow(10, power).toInt).charAt(0))\n\
    \                result.insert(0, dict(10 * pow(10, power).toInt).charAt(0))\n\
    \            } else {\n                if (digit >= 5) {\n                   \
    \ digit -= 5\n                    result.insert(0, dict(5 * pow(10, power).toInt).charAt(0))\n\
    \                }\n                for (i <- 1 to digit) {\n                \
    \    result.insert(0, dict(pow(10, power).toInt).charAt(0))\n                }\n\
    \            }\n            power += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpof51vqjy.scala:49)\n\tat Problem.main(tmpof51vqjy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0 || number > 1000)\n            throw new IllegalArgumentException(\"\
    Restrictions: 1 <= num <= 1000\")\n        var result = \"\"\n        var copy\
    \ = number\n        var div = copy / 100\n        for (i <- 1 to div) {\n    \
    \        result += \"c\"\n        }\n        copy -= div * 100\n        div =\
    \ copy / 50\n        for (i <- 1 to div) {\n            result += \"l\"\n    \
    \    }\n        copy -= div * 50\n        div = copy / 10\n        for (i <- 1\
    \ to div) {\n            result += \"x\"\n        }\n        copy -= div * 10\n\
    \        div = copy / 5\n        for (i <- 1 to div) {\n            result +=\
    \ \"v\"\n        }\n        copy -= div * 5\n        for (i <- 1 to copy) {\n\
    \            result += \"i\"\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt6tvbuu4.scala:20:23\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to div) {\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (div : Long)\n\e[31m   |\e[0m\
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpt6tvbuu4.scala:25:23 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m (i <- \e[31m1\e[0m to div) {\n\e[31m\e\
    [31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m                \
    \       Found:    (div : Long)\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt6tvbuu4.scala:30:23\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to div) {\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (div : Long)\n\e[31m   |\e[0m\
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpt6tvbuu4.scala:35:23 --------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33mfor\e[0m (i <- \e[31m1\e[0m to div) {\n\e[31m\e\
    [31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m                \
    \       Found:    (div : Long)\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt6tvbuu4.scala:39:23\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to copy) {\n\e[31m\e[31m   |\e[0m                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (copy : Long)\n\e[31m   |\e\
    [0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010381
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val chars = Array(\n            Array('i', 'v', 'x'),\n            Array('x',\
    \ 'l', 'c'),\n            Array('c', 'd', 'm'),\n            Array('m', '_', '_')\n\
    \        )\n        val digits = number.toString.map(_.asDigit).toArray\n    \
    \    var s = \"\"\n        for (i <- 0 until digits.length) {\n            val\
    \ digit = digits(digits.length - i - 1)\n            if (digit == 9) s = chars(i)(0)\
    \ + chars(i)(2) + s\n            else if (digit >= 5) {\n                s = chars(i)(1)\
    \ + chars(i)(0).toString * (digit - 5) + s\n            } else if (digit == 4)\
    \ {\n                s = chars(i)(0) + chars(i)(1) + s\n            } else {\n\
    \                s = chars(i)(0).toString * digit + s\n            }\n       \
    \ }\n        s\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9sdz5sb6.scala:37)\n\tat Problem.main(tmp9sdz5sb6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val map1 = Map(1000 -> \"m\", 900 -> \"cm\", 500 -> \"d\", 400 -> \"cd\"\
    , 100 -> \"c\", 90 -> \"xc\", 50 -> \"l\", 40 -> \"xl\", 10 -> \"x\", 9 -> \"\
    ix\", 5 -> \"v\", 4 -> \"iv\", 1 -> \"i\")\n        val map2 = Map(0 -> \"\",\
    \ 1 -> \"i\", 2 -> \"ii\", 3 -> \"iii\", 4 -> \"iv\", 5 -> \"v\", 6 -> \"vi\"\
    , 7 -> \"vii\", 8 -> \"viii\", 9 -> \"ix\")\n        val map3 = Map(0 -> \"\"\
    , 1 -> \"x\", 2 -> \"xx\", 3 -> \"xxx\", 4 -> \"xl\", 5 -> \"l\", 6 -> \"lx\"\
    , 7 -> \"lxx\", 8 -> \"lxxx\", 9 -> \"xc\")\n        val map4 = Map(0 -> \"\"\
    , 1 -> \"c\", 2 -> \"cc\", 3 -> \"ccc\", 4 -> \"cd\", 5 -> \"d\", 6 -> \"dc\"\
    , 7 -> \"dcc\", 8 -> \"dccc\", 9 -> \"cm\")\n        val map5 = Map(0 -> \"\"\
    , 1 -> \"m\", 2 -> \"mm\", 3 -> \"mmm\")\n        var result = \"\"\n        var\
    \ temp = number\n        result += map5(temp / 1000)\n        temp %= 1000\n \
    \       result += map4(temp / 100)\n        temp %= 100\n        result += map3(temp\
    \ / 10)\n        temp %= 10\n        result += map2(temp)\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi28ozxu5.scala:22:15 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        result += map5(temp / \e[31m1000\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a\
    \ member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi28ozxu5.scala:22:23 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        result += map5(temp / \e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \   Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi28ozxu5.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        result += map4(temp / \e[31m100\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a\
    \ member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi28ozxu5.scala:24:23 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        result += map4(temp / \e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi28ozxu5.scala:26:15 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        result += map3(temp / \e[31m10\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a\
    \ member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi28ozxu5.scala:26:23 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        result += map3(temp / \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-"
  stdout: ''
  timestamp: 1660010383
