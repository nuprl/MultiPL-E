name: HumanEval_69_search
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // You are given a non-empty array list of positive integers.\
  \ Return the greatest integer that is greater than \n    // zero, and has a frequency\
  \ greater than or equal to the value of the integer itself. \n    // The frequency\
  \ of an integer is the number of times it appears in the array list.\n    // If\
  \ no such a value exist, return -1.\n    // Examples:\n    // >>> search((new ArrayList<Long>(Arrays.asList((long)4l,\
  \ (long)1l, (long)2l, (long)2l, (long)3l, (long)1l))))\n    // (2l)\n    // >>>\
  \ search((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)2l, (long)3l,\
  \ (long)3l, (long)3l, (long)4l, (long)4l, (long)4l))))\n    // (3l)\n    // >>>\
  \ search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)4l, (long)4l,\
  \ (long)4l))))\n    // (-1l)\n    public static long search(ArrayList<Long> lst)\
  \ {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)5l, (long)5l, (long)1l))))\
  \ == (1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)4l, (long)1l,\
  \ (long)4l, (long)1l, (long)4l, (long)4l)))) == (4l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)3l,\
  \ (long)3l)))) == (-1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)8l,\
  \ (long)8l, (long)8l, (long)8l, (long)8l, (long)8l, (long)8l, (long)8l)))) == (8l));\n\
  \    assert(search((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)3l,\
  \ (long)2l, (long)2l)))) == (2l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)7l, (long)8l, (long)8l, (long)4l, (long)8l, (long)7l, (long)3l, (long)9l,\
  \ (long)6l, (long)5l, (long)10l, (long)4l, (long)3l, (long)6l, (long)7l, (long)1l,\
  \ (long)7l, (long)4l, (long)10l, (long)8l, (long)1l)))) == (1l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)8l, (long)2l)))) == (2l));\n\
  \    assert(search((new ArrayList<Long>(Arrays.asList((long)6l, (long)7l, (long)1l,\
  \ (long)8l, (long)8l, (long)10l, (long)5l, (long)8l, (long)5l, (long)3l, (long)10l))))\
  \ == (1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)8l, (long)8l,\
  \ (long)3l, (long)6l, (long)5l, (long)6l, (long)4l)))) == (-1l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)6l, (long)9l, (long)6l, (long)7l, (long)1l,\
  \ (long)4l, (long)7l, (long)1l, (long)8l, (long)8l, (long)9l, (long)8l, (long)10l,\
  \ (long)10l, (long)8l, (long)4l, (long)10l, (long)4l, (long)10l, (long)1l, (long)2l,\
  \ (long)9l, (long)5l, (long)7l, (long)9l)))) == (1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)9l, (long)10l, (long)1l, (long)3l)))) == (1l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)6l, (long)9l, (long)7l, (long)5l, (long)8l,\
  \ (long)7l, (long)5l, (long)3l, (long)7l, (long)5l, (long)10l, (long)10l, (long)3l,\
  \ (long)6l, (long)10l, (long)2l, (long)8l, (long)6l, (long)5l, (long)4l, (long)9l,\
  \ (long)5l, (long)3l, (long)10l)))) == (5l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)1l))))\
  \ == (1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)8l, (long)8l,\
  \ (long)10l, (long)6l, (long)4l, (long)3l, (long)5l, (long)8l, (long)2l, (long)4l,\
  \ (long)2l, (long)8l, (long)4l, (long)6l, (long)10l, (long)4l, (long)2l, (long)1l,\
  \ (long)10l, (long)2l, (long)1l, (long)1l, (long)5l)))) == (4l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)10l, (long)4l, (long)8l, (long)2l,\
  \ (long)10l, (long)5l, (long)1l, (long)2l, (long)9l, (long)5l, (long)5l, (long)6l,\
  \ (long)3l, (long)8l, (long)6l, (long)4l, (long)10l)))) == (2l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)6l, (long)10l, (long)1l, (long)6l,\
  \ (long)9l, (long)10l, (long)8l, (long)6l, (long)8l, (long)7l, (long)3l)))) == (1l));\n\
  \    assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)2l, (long)4l,\
  \ (long)1l, (long)5l, (long)1l, (long)5l, (long)2l, (long)5l, (long)7l, (long)7l,\
  \ (long)7l, (long)3l, (long)10l, (long)1l, (long)5l, (long)4l, (long)2l, (long)8l,\
  \ (long)4l, (long)1l, (long)9l, (long)10l, (long)7l, (long)10l, (long)2l, (long)8l,\
  \ (long)10l, (long)9l, (long)4l)))) == (4l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)6l, (long)4l, (long)2l, (long)8l, (long)7l, (long)5l, (long)6l, (long)4l,\
  \ (long)10l, (long)4l, (long)6l, (long)3l, (long)7l, (long)8l, (long)8l, (long)3l,\
  \ (long)1l, (long)4l, (long)2l, (long)2l, (long)10l, (long)7l)))) == (4l));\n  \
  \  assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)8l, (long)6l,\
  \ (long)10l, (long)2l, (long)6l, (long)10l, (long)2l, (long)7l, (long)8l, (long)10l,\
  \ (long)3l, (long)8l, (long)2l, (long)6l, (long)2l, (long)3l, (long)1l)))) == (2l));\n\
  \    assert(search((new ArrayList<Long>(Arrays.asList((long)5l, (long)5l, (long)3l,\
  \ (long)9l, (long)5l, (long)6l, (long)3l, (long)2l, (long)8l, (long)5l, (long)6l,\
  \ (long)10l, (long)10l, (long)6l, (long)8l, (long)4l, (long)10l, (long)7l, (long)7l,\
  \ (long)10l, (long)8l)))) == (-1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)10l))))\
  \ == (-1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)9l, (long)7l,\
  \ (long)7l, (long)2l, (long)4l, (long)7l, (long)2l, (long)10l, (long)9l, (long)7l,\
  \ (long)5l, (long)7l, (long)2l)))) == (2l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)5l,\
  \ (long)4l, (long)10l, (long)2l, (long)1l, (long)1l, (long)10l, (long)3l, (long)6l,\
  \ (long)1l, (long)8l)))) == (1l));\n    assert(search((new ArrayList<Long>(Arrays.asList((long)7l,\
  \ (long)9l, (long)9l, (long)9l, (long)3l, (long)4l, (long)1l, (long)5l, (long)9l,\
  \ (long)1l, (long)2l, (long)1l, (long)1l, (long)10l, (long)7l, (long)5l, (long)6l,\
  \ (long)7l, (long)6l, (long)7l, (long)7l, (long)6l)))) == (1l));\n    assert(search((new\
  \ ArrayList<Long>(Arrays.asList((long)3l, (long)10l, (long)10l, (long)9l, (long)2l))))\
  \ == (-1l));\n    }\n\n}\n"
completions: ["        int max = -1;\n        for (int i : lst) {\n            if\
    \ (max < 0 || i >= max)\n                max = i;\n        }\n        return max;",
  "        Map<Long, Integer> map = new TreeMap<>();\n        for (Long i : lst) {\n\
    \            if (map.containsKey(i))\n                map.put(i, map.get(i) +\
    \ 1);\n            else\n                map.put(i, 1);\n        }\n        for\
    \ (Long i : map.keySet())\n            if (map.get(i) >= l.size() * 2)\n     \
    \           return i;\n        return -1;", "        long freq = lst.get(0l).getAsLong();\n\
    \        long value = lst.get(0l).getAsLong();\n        for(long i = 1l; i < lst.size();\
    \ i++) {\n            freq = lst.get(i).getAsLong();\n            if (freq <=\
    \ value) break;\n            else if (freq > value) value = freq;\n        }\n\
    \        return value;", "        long result = -1l;\n        long max = -1l;\n\
    \        for(long i : lst) {\n            if(i>0) {\n                max = Math.max(max,\
    \ i);\n            }\n        }\n        if(max>0) {\n            long freq =\
    \ Collections.frequency(lst, max);\n            if(freq>=max) {\n            \
    \    result = max;\n            }\n        }\n        return result;", "     \
    \   if (lst.isEmpty()) return -1;\n        long max = 0;\n        long count =\
    \ 1;\n        for (Long v : lst) {\n            count += 1;\n            if (v\
    \ > max) max = v;\n        }\n        if (count >= max) return -1;\n        for\
    \ (Long v : lst) {\n            if (v == max) break;\n            if (v > max)\
    \ max = v;\n        }\n        return max;", "        // Create a map to store\
    \ the frequency of integers\n        Map<Long, Long> freq = new TreeMap<>();\n\
    \        for (Long integer : lst) {\n            if (freq.containsKey(integer))\
    \ {\n                freq.put(integer, freq.get(integer) + 1);\n            }\
    \ else {\n                freq.put(integer, 1L);\n            }\n        }\n\n\
    \        // Return the greatest integer that is greater than 0\n        return\
    \ freq.entrySet().stream().max(Map.Entry.comparingByValue()).getKey();", "   \
    \     long max = Long.MIN_VALUE;\n        for (long num : lst) {\n           \
    \ if (num > max) {\n                max = num;\n            }\n        }\n   \
    \     return max;", "        // Create an array to hold frequencies of each integer\n\
    \        long[] freq = new long[(int) lst.size()];\n        int count = 0;\n\n\
    \        // Iterate through each element in array and find frequency and increment\
    \ by 1\n        for (long l : lst) {\n            freq[(int) l] = ++count;\n \
    \       }\n\n        // Now iterate through frequency array and find greatest\
    \ frequency\n        long result = Long.MIN_VALUE;\n        for (int i = 0; i\
    \ < freq.length; i++) {\n            if (freq[i] > result) {\n               \
    \ result = freq[i];\n            }\n        }\n        return result < 0 ? -1\
    \ : result;", "        if (lst.size() == 0) {\n            return -1;\n      \
    \  }\n        Collections.sort(lst);\n        long result = lst.get(0);\n    \
    \    long max = lst.get(0);\n        for (long i : lst) {\n            if (i >\
    \ max) {\n                max = i;\n                result = i;\n            }\
    \ else if (i > result) {\n                result = i;\n            }\n       \
    \ }\n        return result;", "        int n = lst.size();\n        long[] nums\
    \ = new long[n];\n        int maxIndex = 0;\n        int maxVal = lst.get(0);\n\
    \        for (int i = 0; i < n; i++) {\n            nums[i] = lst.get(i);\n  \
    \          if (nums[i] > maxVal) {\n                maxVal = nums[i];\n      \
    \          maxIndex = i;\n            }\n        }\n        if (maxVal == 0) {\n\
    \            return -1;\n        }\n        long[] max = new long[n];\n      \
    \  for (int i = 0; i < n; i++) {\n            if (nums[i] > maxVal) {\n      \
    \          max[i] = nums[i];\n            } else {\n                max[i] = maxVal;\n\
    \            }\n        }\n        int counter = 0;\n        for (int i = 0; i\
    \ < maxIndex; i++) {\n            for (int j = 0; j < n; j++) {\n            \
    \    if (max[j] == max[i]) {\n                    counter++;\n               \
    \     break;\n                }\n            }\n        }\n        if (counter\
    \ == n) {\n            return maxVal;\n        } else {\n            return -1;\n\
    \        }", "        long frequency = lst.stream().filter(l -> l > 0).count();\n\
    \        return frequency > lst.stream().filter(l -> l == frequency).findFirst().get()\
    \ ? frequency : -1;", "        // Write your code here.\n        HashMap<Long,\
    \ Long> map = new HashMap<>();\n        for(Long x:lst){\n            if(map.containsKey(x)){\n\
    \                map.put(x, map.get(x)+1);\n            }\n            else{\n\
    \                map.put(x, 1l);\n            }\n        }\n        Set<Long>\
    \ set = map.entrySet();\n        Long max = set.stream().max((e1, e2) -> e1.getValue()\
    \ - e2.getValue()).get().getKey();\n        for(Long x:set){\n            if(map.get(x.getKey())\
    \ >= max){\n                return -1;\n            }\n        }\n        return\
    \ max;", "        long res = -1;\n        long max = 0;\n        for(long l: lst)\
    \ {\n            if(l > 0 && Collections.frequency(lst, l) >= l) {\n         \
    \       max = Math.max(max, l);\n            }\n        }\n        if(max > 0)\
    \ {\n            res = max;\n        }\n        return res;", "        long max\
    \ = -1;\n        long maxFreq = -1;\n        for (long i : lst) {\n          \
    \  if (max < 0 || maxFreq < 0 || i < 0 || i > max) {\n                max = i;\n\
    \                maxFreq = 1;\n            } else if (maxFreq < i) {\n       \
    \         max = i;\n                maxFreq = i;\n            }\n        }\n \
    \       return max;", "        HashMap<Long, Integer> map = new HashMap<>();\n\
    \        for (long val : lst) {\n            if (map.containsKey(val)) {\n   \
    \             map.put(val, map.get(val) + 1);\n            } else {\n        \
    \        map.put(val, 1);\n            }\n        }\n        if (map.isEmpty())\
    \ {\n            return -1;\n        }\n        for (Map.Entry<Long, Integer>\
    \ entry : map.entrySet()) {\n            if (entry.getValue() >= map.get(0)) {\n\
    \                return entry.getKey();\n            }\n        }\n        return\
    \ -1;", "        long max;\n        long maxFreq;\n        long maxLarger;\n \
    \       \n        max = -1l;\n        maxFreq = -1;\n        for(Long num : lst)\
    \ {\n            long freq = Collections.frequency(lst, num);\n            if(freq\
    \ >= maxFreq) {\n                max = num;\n                maxFreq = freq;\n\
    \            }\n            if(freq > maxFreq) {\n                maxLarger =\
    \ num;\n                maxFreq = freq;\n            }\n        }\n        return\
    \ maxLarger;", "        if (lst.isEmpty()) {\n            return -1;\n       \
    \ }\n        Map<Long, Long> freqMap = lst.stream().collect(groupingBy(Function.identity(),\
    \ counting()));\n        long largest = 0L;\n        long largest_freq = 0L;\n\
    \        for (Map.Entry<Long, Long> e : freqMap.entrySet()) {\n            long\
    \ freq = e.getValue();\n            if (freq >= largest_freq) {\n            \
    \    largest = e.getKey();\n                largest_freq = freq;\n           \
    \ }\n        }\n        return largest;", "        Arrays.sort(lst);\n       \
    \ ArrayList list = new ArrayList();\n        int count = 0;\n        for (Long\
    \ l : lst) {\n            long v = l.longValue();\n            count = (count\
    \ + 1) % 10;\n            if (list.contains(v)) {\n                int index =\
    \ list.indexOf(v);\n                list.remove(index);\n                list.add(index,\
    \ l.longValue());\n            } else {\n                list.add(l);\n      \
    \      }\n        }\n        if (count <= 0) {\n            return -1;\n     \
    \   }\n        long v = lst.stream().reduce((a, b) -> b.longValue() - a.longValue()).orElse(-1l).longValue();\n\
    \        if (list.contains(v)) {\n            return v;\n        } else {\n  \
    \          return -1;\n        }", "        long max = -1;\n        HashMap<Long,\
    \ Long> hm = new HashMap<Long, Long>();\n        for (long val : lst) {\n    \
    \        hm.put(val, hm.getOrDefault(val, 0L) + 1);\n            if (hm.getOrDefault(val,\
    \ 0L) > max) {\n                max = hm.getOrDefault(val, 0L);\n            }\n\
    \        }\n        return max;", "        if (lst.isEmpty()) return -1;\n   \
    \     long max = lst.get(0);\n        Long maxCount = null;\n        for (long\
    \ l : lst) {\n            if (l.equals(max)) {\n                maxCount = Long.valueOf(max);\n\
    \            }\n            max = Math.max(max, l);\n        }\n        return\
    \ maxCount == null ? -1 : maxCount;", "        // Complete the function here\n\
    \        long res = -1;\n        for (long num : lst) {\n            if (num >=\
    \ 0) {\n                long count = lst.stream().filter(a -> a == num).count();\n\
    \                if (count > res) {\n                    res = num;\n        \
    \        }\n            }\n        }\n        return res;", "        long maxVal\
    \ = -1l;\n        long maxFreq = -1;\n        Set<Long> set = new TreeSet<>();\n\
    \        lst.stream().filter(i -> set.contains(i)).forEach((i) -> {\n        \
    \    long freq = set.count(i);\n            if (maxFreq < freq || maxFreq == -1\
    \ && freq > 0) maxFreq = freq;\n            if (maxVal < i && freq >= i) maxVal\
    \ = i;\n            set.add(i);\n        });\n        return maxVal;", "     \
    \   Collections.sort(lst);\n        for(int i = 0; i< lst.size(); i++) {\n   \
    \         if((i+1)==lst.size() || lst.get(i+1)<lst.get(i) || lst.get(i)<0) {\n\
    \                return -1;\n            }\n        }\n        return lst.get(lst.size()-1);",
  "        Set<Long> longSet = lst.stream().map(Number::longValue).collect(Collectors.toSet());\n\
    \        Long greatest = Long.MIN_VALUE;\n        Long highestFreq = Long.MIN_VALUE;\n\
    \        for (Long i : longSet) {\n            if (highestFreq < i && i > 0) {\n\
    \                highestFreq = i;\n                greatest = i;\n           \
    \ }\n        }\n        return greatest == Long.MIN_VALUE ? -1 : greatest;", " \
    \       long maxVal = -1;\n        long maxCount = 0;\n        for(Long val: lst)\n\
    \            if(val > 0 && lst.get((int)val) > maxCount) {\n                maxVal\
    \ = val;\n                maxCount = lst.get((int)val);\n            }\n     \
    \   return maxVal;", "        long maxVal = -1;\n        int maxFreq = -1;\n\n\
    \        for(Long number : lst) {\n            long val = number.longValue();\n\
    \            if(val >= 0 && val == maxVal) {\n                // no need for a\
    \ new search or any additional calculations, just keep comparing the value\n \
    \               // if the current value is the highest so far\n              \
    \  if(maxFreq < val) {\n                    maxFreq = val;\n                 \
    \   maxVal = val;\n                }\n            } else if (maxVal > 0 && val\
    \ >= 0 && val == maxVal) {\n                // if the current value is still the\
    \ highest but this value has increased frequency and \n                // it is\
    \ higher than the previous maxVal, keep it\n                if(maxFreq < val)\
    \ {\n                    maxFreq = val;\n                    maxVal = val;\n \
    \               } else if (maxFreq == val) {\n                    // the frequency\
    \ didn't increase, so if the previous was the max, then \n                   \
    \ // it must have been this one since we already have a higher frequency \n  \
    \                  // so just keep it\n                    maxVal = val;\n   \
    \             }\n            }\n        }\n\n        return maxVal;", "      \
    \  long retVal = -1;\n        for (long l : lst) {\n            long f = Collections.frequency(lst,\
    \ l);\n            if (f > 0 && f >= retVal) {\n                retVal = l;\n\
    \            }\n        }\n        return retVal;", "        // write your code\
    \ here\n        if (lst.size() == 0) return -1;\n        if (lst.get(0) == 0)\
    \ return lst.get(0);\n        Map<Long, Long> map = new HashMap<Long, Long>();\n\
    \        for (Long x : lst) {\n            map.put(x, map.getOrDefault(Long.MAX_VALUE,\
    \ 0) + 1);\n        }\n        if (map.size() == 0) {\n            return -1;\n\
    \        }\n        long maxValue = Collections.max(map.values());\n        for\
    \ (Map.Entry<Long, Long> entry : map.entrySet()) {\n            if (entry.getValue()\
    \ >= maxValue) {\n                return entry.getKey();\n            }\n    \
    \    }\n        return -1;", "        if (lst.isEmpty()) {\n            return\
    \ -1l;\n        }\n        Map<Long, Long> freq = new HashMap<Long, Long>();\n\
    \        for (Long l : lst) {\n            freq.put(l, freq.getOrDefault(l, 0l)\
    \ + 1);\n        }\n        Long max = null;\n        for (Long l : freq.keySet())\
    \ {\n            if (freq.containsKey(max) && freq.containsKey(l)) {\n       \
    \         continue;\n            }\n            if (freq.containsKey(max) && freq.get(l)\
    \ >= freq.get(max)) {\n                continue;\n            }\n            max\
    \ = l;\n        }\n        return max;", "        if (lst.isEmpty()) return -1l;\n\
    \        \n        long maxFreq = lst.get(0);\n        \n        for (int i =\
    \ 1; i < lst.size(); i++) {\n            long freq = lst.get(i);\n           \
    \ \n            if (freq > maxFreq) {\n                maxFreq = freq;\n     \
    \           maxIndex = i;\n            }\n        }\n        \n        return\
    \ maxFreq;", "        long[] arr=new long[lst.length];\n        long ans=-1;\n\
    \        for(int i=0;i<arr.length;i++) {\n            arr[i]=lst.get(i);\n   \
    \     }\n        for(int i=arr.length-1;i>0;i--) {\n            for(int j=i+1;j<arr.length;j++)\
    \ {\n                if(arr[i]==arr[j]) {\n                    arr[j]=0;\n   \
    \                 if(ans < arr[i]) {\n                        ans=arr[i];\n  \
    \                  }\n                    arr[i]=0;\n                }\n     \
    \       }\n        }\n        return ans;", "        long max = lst.stream().filter(e\
    \ -> e > 0l).max(Long::compareTo).get();\n        long maxCount = 0;\n       \
    \ for (long e : lst) {\n            if (e > 0l && e > max) max = e;\n        \
    \    ++maxCount;\n        }\n        return max > 0 ? max : -1;", "        HashMap<Long,\
    \ Long> map = new HashMap<Long, Long>();\n        for (Long i : lst) {\n     \
    \       if (map.get(i) == null) {\n                map.put(i, 1l);\n         \
    \   } else {\n                map.put(i, map.get(i) + 1);\n            }\n   \
    \     }\n        Long result = -1;\n        for (Long i : map.keySet()) {\n  \
    \          if (map.get(i) >= 1l) {\n                result = i;\n            }\n\
    \        }\n        return result;", "        long retVal = -1;\n        HashMap<Long,\
    \ Long> hm = Arrays.stream(lst).collect(HashMap::new, (m, e) -> m.put(e, m.getOrDefault(e,\
    \ 0) + 1), (m1, m2) -> m1.putAll(m2));\n        for (long e : hm.keySet()) {\n\
    \            if (hm.get(e) >= retVal) {\n                retVal = hm.get(e);\n\
    \            }\n        }\n        return retVal;", "        \n        long maxVal\
    \ = -1;\n        long maxFreq = -1;\n        for (long i : lst) {\n          \
    \  if (maxVal < 0) {\n                maxVal = i;\n                maxFreq = i;\n\
    \            } else if (i < maxVal) {\n                maxVal = i;\n         \
    \       maxFreq = i;\n            } else if (i == maxVal) {\n                maxFreq++;\n\
    \            }\n        }\n        if (maxFreq >= maxVal) {\n            return\
    \ maxVal;\n        } else {\n            return -1;\n        }", "        // TODO:\
    \ Write your answer here\n        int max = -1;\n        long freq = 0;\n    \
    \    Iterator<Long> it = lst.iterator();\n        int i = 0;\n        while(it.hasNext()){\n\
    \            freq++;\n            Long value = it.next();\n            if(freq\
    \ >= value){\n                max = freq;\n                freq = 0;\n       \
    \         i = 1;\n            }\n            else if(max < value){\n         \
    \       max = value;\n                freq = freq - 1;\n            }\n      \
    \      i++;\n        }\n        if(max > -1){\n            return max;\n     \
    \   }\n        return -1;", "        long maxVal = lst.get(0);\n        long minVal\
    \ = lst.get(0);\n\n        int val = 1;\n\n        for(int i = 1; i < lst.size();\
    \ i++) {\n            long val = lst.get(i);\n\n            int freq = Collections.frequency(lst,\
    \ val);\n            \n            if(freq > val) {\n                val = 0;\n\
    \            }\n            if(freq > maxVal) {\n                maxVal = val;\n\
    \            }\n            if(freq < minVal) {\n                minVal = val;\n\
    \            }\n        }\n\n        if(minVal <= 0) {\n            return -1;\n\
    \        }\n        return maxVal;", "        if (lst.isEmpty()) {\n         \
    \   return -1;\n        }\n        long freq = lst.get(fst.first());\n       \
    \ int pos = 0;\n        for (int i = 0; i < lst.size(); i++) {\n            if\
    \ (lst.get(i) != fst.get()) {\n                pos = i;\n            }\n     \
    \   }\n        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i)\
    \ != fst.get()) {\n                continue;\n            }\n            if (lst.get(i)\
    \ > 0) {\n                freq++;\n            } else {\n                return\
    \ -1;\n            }\n            if (lst.get(i) == fst.get() && lst.get(pos)\
    \ > freq && lst.get(pos) == lst.get(pos)) {\n                return lst.get(pos);\n\
    \            }\n        }\n        return -1;", "        Arrays.stream(lst).boxed().sorted((a,\
    \ b) -> Long.compare(a, b))\n                .reduce((l, r) -> {\n           \
    \         if(Long.compare(l, r) == 0) {\n                        return -1;\n\
    \                    }\n                    if(Long.compare(l, r) > 0) {\n   \
    \                     return l;\n                    }\n                    return\
    \ r;\n                });\n        return -1;", "        TreeMap<Long,Integer>\
    \ map = new TreeMap<>();\n        for (Long num : lst) {\n            int count\
    \ = map.get(num);\n            map.put(num, count + 1);\n        }\n        Long\
    \ max = map.firstKey();\n        for (Map.Entry<Long,Integer> entry : map.entrySet())\
    \ {\n            if (entry.getValue() >= entry.getKey() && entry.getValue() >\
    \ max)\n                max = entry.getKey();\n        }\n        return max ==\
    \ null ? -1l : max;", "        ArrayList<Long> copy = new ArrayList<>(lst);\n\
    \        Arrays.sort(copy);\n        long freq = Collections.frequency(copy, 0);\n\
    \        boolean first = true;\n        for(long n : copy) {\n            long\
    \ r = search(n, freq, first);\n            first = false;\n            return\
    \ r;\n        }\n        return -1;", "        int n = lst.size();\n        \n\
    \        Collections.sort(lst);\n        \n        if (n > 1) { // if there is\
    \ at least 2 or more occurrences we need to return -1\n            \n        \
    \    int freq = 1;\n            long max;\n            \n            for (int\
    \ i = 1; i < n; i++) {\n                if (lst.get(i) - lst.get(i-1) > 0) {\n\
    \                    freq++;\n                } else {\n                    break;\n\
    \                }\n            }\n            \n            if (freq > lst.get(0)\
    \ && freq >= n) {\n                max = lst.get(0);\n            } else {\n \
    \               max = -1;\n            }\n            \n            for (int i\
    \ = 0; i < n; i++) {\n                if (lst.get(i) == freq) {\n            \
    \        max = lst.get(i);\n                    break;\n                }\n  \
    \              if (lst.get(i) > freq) {\n                    max = lst.get(i);\n\
    \                }\n            }\n            \n            return max;\n   \
    \     } else {\n            return -1;\n        }", "        if (lst.size() <\
    \ 2) return -1l;\n        HashMap<Long, Integer> map = new HashMap<>();\n    \
    \    for (Long v : lst) {\n            map.mergeIfAbsent(v, 1L, (v1, v2) -> v2);\n\
    \        }\n        Set<Map.Entry<Long, Integer>> set = map.entrySet();\n    \
    \    for (Map.Entry<Long, Integer> entry : set) {\n            Integer val = entry.getValue();\n\
    \            if (val > 0) return entry.getKey();\n        }\n        return -1l;",
  "        long max = -1l;\n        long maxValue = -1l;\n        for (long i : lst)\
    \ {\n            if (maxValue < i)\n                maxValue = i;\n          \
    \  if (maxValue > 0)\n                max = i;\n        }\n        return max;",
  "        long maxVal = -1;\n        long freqOfMaxVal = -1;\n\n        for(long\
    \ i : lst) {\n            if(freqOfMaxVal == -1 || freqOfMaxVal >= i) {\n    \
    \            maxVal = i;\n                freqOfMaxVal = lst.stream().filter((x)\
    \ -> x == i).count();\n            }\n        }\n\n        return maxVal;", " \
    \       long max = 0;\n        Map<Long, Long> freqs = new HashMap<Long, Long>();\n\
    \        for (long i : lst) {\n            if (freqs.get(i) == null) {\n     \
    \           freqs.put(i, 1l);\n            } else {\n                freqs.put(i,\
    \ freqs.get(i) + 1);\n            }\n        }\n        for (Map.Entry<Long, Long>\
    \ e : freqs.entrySet()) {\n            if (e.getValue() >= max) {\n          \
    \      max = e.getValue();\n            }\n        }\n        return max == 0\
    \ ? -1 : (long) max;", "        if (lst.isEmpty()) {\n            return -1;\n\
    \        }\n        long maxVal = 0;\n        long maxFreq = 0;\n        for (Long\
    \ i : lst) {\n            long freq = lst.stream().filter(v -> v.equals(i)).count();\n\
    \            if (freq > maxFreq) {\n                maxFreq = freq;\n        \
    \        maxVal = i;\n            }\n        }\n        return maxVal;", "   \
    \     long max = -1;\n        long max = lst.get(0);\n        for (int i = 1;\
    \ i < lst.size(); i++) {\n            if (lst.get(i) > max) {\n              \
    \  max = lst.get(i);\n            }\n        }\n        return max;", "      \
    \  long max = -1;\n        int count = 0;\n        for (Long i : lst) {\n    \
    \        count++;\n            if (i > 0)\n                if (count > max)\n\
    \                    max = count;\n            else\n                count--;\n\
    \        }\n        return max;", "        long maxVal = Long.MIN_VALUE, maxFreq\
    \ = Long.MIN_VALUE;\n        for (Long val : lst) {\n            if (val > maxVal)\
    \ {\n                maxVal = val;\n            }\n            if (val > maxFreq)\
    \ {\n                maxFreq = val;\n            }\n        }\n        return\
    \ maxVal > 0 ? maxVal : -1;", "        List<Long> freq = lst.stream().collect(Collectors.groupingBy(Function.identity(),\
    \ Collectors.counting()));\n        freq.stream().filter(f->f.get()>=lst.get(0)).findAny().orElse(-1);\n\
    \        return freq.get(lst.get(0));", "        List<Long> sortedLst = lst.stream().sorted().collect(Collectors.toList());\n\
    \        \n        long first = sortedLst.get(0); // first value\n        long\
    \ max = first;\n        int cnt = 0;\n        \n        for (int i = 0; i < sortedLst.size();\
    \ i++) {\n            if (sortedLst.get(i) > 0 && sortedLst.get(i) <= max) {\n\
    \                cnt++;\n                max = sortedLst.get(i);\n           \
    \ }\n        }\n        \n        if (cnt >= sortedLst.size() || max <= 0) {\n\
    \            return -1L;\n        }\n        \n        for (int i = 0; i < sortedLst.size();\
    \ i++) {\n            if (sortedLst.get(i) > 0 && sortedLst.get(i) == max) {\n\
    \                return (long)i;\n            }\n        }\n        \n       \
    \ return -1L;", "        long maxVal = -1;\n        int maxCount = 0;\n      \
    \  for (long val : lst) {\n            if (val == 0)\n                continue;\n\
    \            if (maxVal == -1 || val > maxVal) {\n                maxVal = val;\n\
    \                maxCount = 0;\n            } else {\n                ++maxCount;\n\
    \            }\n        }\n        return maxVal;", "        if (lst.isEmpty())\
    \ {\n            return -1;\n        }\n        Arrays.sort(lst);\n        int\
    \ l = lst.size();\n        long maxI = lst.get(0);\n        for (int i = 1; i\
    \ < l; i++) {\n            if (lst.get(i) < lst.get(i - 1)) {\n              \
    \  return -1;\n            }\n            if (lst.get(i) == maxI) {\n        \
    \        if (lst.get(l-1) - lst.get(i) >= 2) {\n                    return lst.get(l-1);\n\
    \                }\n            }\n            else\n            {\n         \
    \       maxI = lst.get(i);\n            }\n        }\n        return maxI;", '        return
    lst.stream().filter(n -> n>=0L).max(Comparator.comparingLong(n -> n)).orElse(-1L);',
  "        int max = 0;\n        HashMap<Long, Integer> map = new HashMap<>();\n \
    \       for (long ele : lst) {\n            Integer freq = map.get(ele);\n   \
    \         if (freq != null) {\n                if (freq > max) {\n           \
    \         max = freq;\n                }\n            } else {\n             \
    \   map.put(ele, new Integer(1));\n            }\n        }\n        if (map.containsKey(0l))\
    \ {\n            map.put(0l, new Integer(1));\n        }\n        for (Map.Entry<Long,\
    \ Integer> entry : map.entrySet()) {\n            if (entry.getValue() > max)\
    \ {\n                max = entry.getValue();\n            }\n        }\n     \
    \   if (max < 0) {\n            return -1l;\n        }\n        return max;",
  "        long result = -1;\n        for (long num : lst) {\n            if (num\
    \ > 0) {\n                long freq = lst\n                        .stream()\n\
    \                        .filter(x -> x == num)\n                        .count();\n\
    \                if (freq >= num) {\n                    result = num;\n     \
    \           }\n            }\n        }\n        return result;", "        if\
    \ (lst.size() == 0) {\n            return -1l;\n        }\n        long result\
    \ = 0;\n        for (long num : lst) {\n            if (result >= num) {\n   \
    \             break;\n            }\n            if (num >= 0) {\n           \
    \     result += num;\n            }\n        }\n        return result;", "   \
    \     int i = lst.size() - 1;\n        int j = 0;\n        long max = 0;\n   \
    \     HashMap<Long, Integer> count = new HashMap<>();\n        for(; i >= 0; i--)\
    \ {\n            if (count.containsKey(lst.get(i))) {\n                count.put(lst.get(i),\
    \ count.get(i) + 1);\n            } else {\n                count.put(lst.get(i),\
    \ 1);\n            }\n        }\n        int count = 0;\n        for (Integer\
    \ val : count.values()) {\n            count++;\n            if (count > max)\
    \ {\n                max = count;\n                j = i;\n            }\n   \
    \     }\n        if (j >= 0) {\n            return lst.get(j);\n        } else\
    \ {\n            return -1;\n        }", "        long greatestVal = -1;\n   \
    \     long greatestFreq = 0;\n        for (long e : lst) {\n            if (e\
    \ > 0 && e >= greatestFreq) {\n                greatestVal = e;\n            \
    \    greatestFreq = e;\n            } else if (e > 0 && e < greatestFreq) {\n\
    \                greatestFreq = e;\n            }\n        }\n        if (greatestVal\
    \ != -1) {\n            return greatestVal;\n        } else {\n            return\
    \ -1;\n        }", "        long result = 0;\n        long max;\n        long\
    \ temp;\n        for(long i : lst) {\n            temp = i;\n            max =\
    \ i;\n            for(long j : lst) {\n                if(j == temp) {\n     \
    \               max = j;\n                    break;\n                }\n    \
    \        }\n            if(!lst.contains(max)) {\n                result = -1;\n\
    \                break;\n            }\n        }\n        if(result > 0 && !lst.contains(result))\
    \ {\n            result = -1;\n        }\n        return result;", "        Collections.sort(lst);\n\
    \        if (lst.isEmpty()) {\n            return -1;\n        }\n        long\
    \ max = lst.get(0);\n        long min = lst.get(0);\n        for (long l : lst)\
    \ {\n            if (l > max) {\n                max = l;\n            }\n   \
    \         if (l < min) {\n                min = l;\n            }\n        }\n\
    \        if (min == max) {\n            return min;\n        }\n        long answer\
    \ = max;\n        for (long l : lst) {\n            if (l >= min) {\n        \
    \        answer = Math.max(answer, l + 1);\n            }\n        }\n       \
    \ return answer < 0 ? -1 : answer;", "        // write your code here\n      \
    \  LongSummaryStatistics stat = lst.stream()\n                .collect(Collectors.summarizingLong(Long::longValue));\n\
    \        return lst.stream()\n                .max(Comparator.comparingLong(Long::longValue))\n\
    \                .filter(x -> x.getLongValue() >= stat.getCount(x) && x.getLongValue()>0)\n\
    \                .map(x -> x.getLongValue())\n                .orElse(-1);", " \
    \       // Create a map of keys to counts\n        Map<Long, Long> map = new TreeMap<Long,\
    \ Long>();\n        // Add each element of the list to the map with the count\
    \ of 1 \n        lst.forEach((e) -> map.put(e, 1l));\n        // Get the entries\
    \ in the map\n        Iterator<Map.Entry<Long, Long>> iter = map.entrySet().iterator();\n\
    \        // Sort the entries from greatest to least frequency.\n        Iterator<Map.Entry<Long,\
    \ Long>> iter2 = map.entrySet().stream().sorted(Map.Entry.comparingByValue()).iterator();\n\
    \        // Find the least frequency entry and return the key associated with\
    \ it.\n        if (iter.hasNext()) {\n            Map.Entry<Long, Long> first\
    \ = iter.next();\n            // If the least frequency entry is larger than the\
    \ value of the least frequency entry, it is the greatest \n            // frequency\
    \ entry.\n            if (first.getValue() > iter2.getValue().getValue()) {\n\
    \                return first.getKey();\n            }\n        }\n        //\
    \ The frequency of every number must be greater than or equal to the value of\
    \ the number itself. So\n        // return the greatest entry of the map if it\
    \ exists.\n        if (iter2.hasNext()) {\n            Map.Entry<Long, Long> first\
    \ = iter2.next();\n            if (first.getValue() > map.get(first.getKey()))\
    \ {\n                return first.getKey();\n            }\n        }\n      \
    \  // If no entry in the map has a frequency greater than or equal to the value\
    \ of the number itself, return -1.\n        return -1l;", "        int index =\
    \ findIndex(lst);\n        if (index != -1)\n            return lst.get(index);\n\
    \        return -1;", "        long maxVal = Long.MIN_VALUE, maxCount = Long.MIN_VALUE;\n\
    \        for (Long l : lst) {\n            if (maxCount < l) {\n             \
    \   maxCount = l;\n                maxVal = l;\n            }\n        }\n   \
    \     return maxVal > 0 ? maxVal : -1;", "        Long max = -1l;\n        int\
    \ counter = 0;\n        for (Long value : lst) {\n            if (value > max)\
    \ {\n                counter = 0;\n                max = value;\n            }\n\
    \            else if (value == max) {\n                counter++;\n          \
    \  }\n            else if (counter > 0) {\n                return -1l;\n     \
    \       }\n        }\n        return max;", "        return lst.stream()\n   \
    \             .max(Comparator.comparingLong(item -> item.intValue()))\n      \
    \          .orElse(-1l);", "        long maxFreq = 0;\n        long maxVal = 0;\n\
    \n        List<Long> list = lst.stream().distinct().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n\
    \        Collections.sort(list);\n\n        for (long i : list) {\n          \
    \  long freq = list.stream().filter(j -> j == i).count();\n            if (freq\
    \ > maxFreq) {\n                maxFreq = freq;\n                maxVal = i;\n\
    \            }\n        }\n        return maxVal;", "        long val = -1;\n\
    \        long maxV = -1;\n        for (long num : lst) {\n            if (num\
    \ < val) val = num;\n            else if (num > maxV) maxV = num;\n        }\n\
    \        return maxV;", "        if (lst.size() < 1) return -1;\n        Map<Long,\
    \ Long> map = new HashMap<Long, Long>();\n        for (Long i : lst) {\n     \
    \       Long prev = map.putIfAbsent(i, 0L);\n            if (prev != null && prev\
    \ > 0) map.put(i, map.get(prev) + 1);\n        }\n        for (Long i : map.keySet())\
    \ {\n            if (map.get(i) > 0 && map.get(i) == lst.get(lst.indexOf(i)))\
    \ return i;\n        }\n        return -1;", "        long maxIndex = 0;\n   \
    \     int maxCount = 0;\n        for (Long v : lst) {\n            if (v > 0)\
    \ {\n                if (v.intValue() > maxCount) {\n                    maxCount\
    \ = v.intValue();\n                    maxIndex = v;\n                } else if\
    \ (v.intValue() == maxCount) {\n                    maxCount = v.intValue();\n\
    \                    maxIndex = v;\n                }\n            }\n       \
    \ }\n        return maxIndex;", "        return lst.stream()\n               \
    \ .max(Comparator.comparing(l -> l > 0))\n                .orElse(-1);", "   \
    \     long max = 0;\n        long curr = 0;\n        for (long n : lst) {\n  \
    \          curr += n;\n            if (curr > max)\n                max = curr;\n\
    \        }\n        return max > 0 ? max : -1;", "        int minIndex = Collections.minIndex(lst);\n\
    \        int maxIndex = Collections.maxIndex(lst);\n        long first = lst.get(minIndex);\n\
    \        long second = lst.get(maxIndex);\n        if(second > first){\n     \
    \       return -1;\n        }\n        if(first < 0){\n            return -1;\n\
    \        }\n        Set<Long> seen = new HashSet<Long>();\n        for(int i :\
    \ lst){\n            if(seen.contains(i)){\n                continue;\n      \
    \      }\n            seen.add(i);\n            int freq = Collections.frequency(lst,\
    \ i);\n            if(freq >= first){\n                return i;\n           \
    \ }\n        }\n        return -1;", "        long max = lst.get(0), min = lst.get(0);\n\
    \        for(int i = 1; i < lst.size(); i++){\n            long curr = lst.get(i);\n\
    \            if(curr > max){\n                max = curr;\n            }else if(curr\
    \ < min){\n                min = curr;\n            }\n        }\n        return\
    \ (lst.indexOf(min) > lst.indexOf(max)) ? -1 : max;", "        \n        // Sort\
    \ the list on the first element of each\n        lst = lst.stream().sorted(Comparator.comparing(Long::longValue)).collect(Collectors.toList());\n\
    \n        // First sort the list on the frequency of element of the list\n   \
    \     lst = lst.stream().sorted(Comparator.comparingLong(x -> lst.get(x).intValue())).collect(Collectors.toList());\n\
    \n        // Then, sort the list on the frequency of element of the sorted list\n\
    \        lst = lst.stream().sorted(Comparator.comparingLong(x -> lst.get(x).intValue()))\n\
    \                .collect(Collectors.toMap(x -> x, x -> lst.get(x).intValue(),\
    \ (x, y) -> y, LinkedHashMap::new));\n\n        Long max = null;\n        for\
    \ (Long v : lst.values()) {\n            if (v == 0) return -1;\n            if\
    \ (max != null) return max;\n            max = v;\n        }\n\n        return\
    \ max;", "        long max = 0;\n        int max = -1;\n        int cnt = 0;\n\
    \        for(int i = 0; i< lst.size(); i++) {\n            if(lst.get(i) > 0)\
    \ {\n                if(max < 0 || cnt < lst.get(i)) {\n                    max\
    \ = lst.get(i);\n                    cnt = lst.get(i);\n                }\n  \
    \              else {\n                    cnt += lst.get(i);\n              \
    \  }\n            }\n        }\n        if(max < 0 || cnt < lst.get(0)) {\n  \
    \          max = lst.get(0);\n            cnt = lst.get(0);\n        }\n     \
    \   return cnt;", "        Map<Long, Long> map = new TreeMap<>();\n        for\
    \ (Long i : lst) {\n            map.put(i, map.getOrDefault(i, 0l) + 1);\n   \
    \     }\n        Long max = Collections.max(map.keySet());\n        Long result\
    \ = map.get(max);\n        return result != null ? result : -1l;", "        ArrayList<Long>\
    \ freqs = new ArrayList<Long>();\n        for(long n : lst) {\n            freqs.add(n,\
    \ freqs.getOrDefault(n,0)+1);\n        }\n        long max = freqs.stream().max(Comparator.comparing(Long::longValue)).orElse(-1l);\n\
    \        long maxFreq = freqs.stream().filter(p -> p.longValue() == max).count();\n\
    \        return maxFreq == freqs.stream().filter(p -> p.longValue() == max).count()\
    \ ? max : -1l;", "        if (lst.isEmpty()) return -1l;\n        Set<Long> freq\
    \ = lst.stream().map(e -> new AbstractMap.SimpleEntry<>(e, 1l)).collect(Collectors.groupingBy(Map.Entry::getKey,\
    \ Collectors.counting()));\n        TreeMap<Long, Long> tm = new TreeMap<>(freq);\n\
    \        long max = 0;\n        for (Map.Entry<Long, Long> e : tm.entrySet())\
    \ {\n            if (e.getValue() > max) {\n                max = e.getValue();\n\
    \            }\n        }\n        return max > 0 ? max : -1;", '        return
    lst.stream().filter(i -> i > 0).max((a, b) -> b.compareTo(a)).map(Object::toString).orElse(-1l);',
  "        Collections.sort(lst);\n        int N = lst.size();\n        long max =\
    \ 0;\n        long max = lst.get(0);\n        for(int i=1; i<=N; i++) {\n    \
    \        if(lst.get(i) > max) {\n                max = lst.get(i);\n         \
    \   }\n            if(lst.get(i) == max && i > N) {\n                return -1;\n\
    \            }\n        }\n        return max;", "        long max_val = -1;\n\
    \        long max_freq = -1;\n\n        for (long x : lst) {\n            if (max_freq\
    \ == -1 || x >= max_freq) {\n                max_val = x;\n                max_freq\
    \ = x;\n            }\n            else if (x >= max_freq) {\n               \
    \ max_freq = x;\n            }\n        }\n\n        return max_val;", "     \
    \   if (lst.isEmpty()) return -1l;\n        long max = -1l;\n        Map<Long,\
    \ Long> frequency = lst.stream().collect(Collectors.toMap(Function.identity(),\
    \ i -> 1l));\n        for (int i = 0; i < lst.size(); i++) {\n            if (frequency.getOrDefault(lst.get(i),\
    \ 0l) >= lst.get(i)) {\n                max = Math.max(max, lst.get(i));\n   \
    \         }\n            if (frequency.getOrDefault(lst.get(i), 0l) >= i) {\n\
    \                frequency.put(lst.get(i), frequency.getOrDefault(lst.get(i),\
    \ 0l) + 1);\n            }\n        }\n        return max;", "        int count\
    \ = 0; // counts the number of occurrences of the integer\n        long result\
    \ = -1; // returns the result if the given condition is met\n        for (Long\
    \ i : lst) {\n            if (i >= 0) {\n                count++; // counts the\
    \ number of occurrences of the integer\n                result += i; // sums the\
    \ occurrences of the integer\n            }\n        }\n        if (count == lst.size())\
    \ {\n            return result;\n        }\n        else {\n            return\
    \ -1;\n        }", "        long maxVal = lst.stream().reduce((a, b) -> Math.max(a,\
    \ b));\n        long freq = lst.stream().filter(x -> x >= maxVal).count();\n \
    \       if (maxVal != -1 && freq >= maxVal) {\n            return maxVal;\n  \
    \      }\n        return -1;", "        long ans = -1l;\n        Collections.sort(lst);\n\
    \        System.out.println(lst);\n        \n        for(Long value : lst) {\n\
    \            if(value >= 0l && ans > value) {\n                ans = value;\n\
    \            }\n        }\n        \n        return ans;", "        Collections.sort(lst);\n\
    \        for (long x : lst) {\n            if (x > 0) return x;\n        }\n \
    \       return -1;", "        Long max = lst.get(0);\n        int count = 1, freq\
    \ = 1;\n        for (long i : lst) {\n            if (freq > 0) {\n          \
    \      freq = freq * i / count;\n                if (freq > max) {\n         \
    \           max = freq;\n                }\n            }\n            count =\
    \ count * i;\n        }\n        return max == 0 ? -1 : max;", "        Arrays.sort(lst);\n\
    \        int len = lst.size();\n        if (len > 0) {\n            Long val =\
    \ lst.get(0);\n            int freq = 1;\n            int j = 1;\n           \
    \ while (j < len) {\n                if (val == lst.get(j)) {\n              \
    \      freq++;\n                    j++;\n                } else {\n         \
    \           if (freq >= lst.get(j)) {\n                        return val;\n \
    \                   }\n                    freq = j + 1;\n                   \
    \ val = lst.get(j);\n                    j = 1;\n                }\n         \
    \   }\n        }\n        return -1l;", "        if (lst.size() == 0) return -1;\n\
    \        int max = 0;\n        for (long n : lst) {\n            if (n > 0) {\n\
    \                max = Math.max(max, n);\n            }\n            if (n ==\
    \ 0 || (n != lst.stream().filter(x -> x == n).count())) {\n                return\
    \ -1;\n            }\n        }\n        return max;", "        if (lst.size()\
    \ == 0) {\n            return -1;\n        }\n        TreeMap<Long, Long> freq\
    \ = new TreeMap<Long, Long>();\n        for (Long val : lst) {\n            freq.put(val,\
    \ freq.getOrDefault(val, 0) + 1l);\n        }\n        return freq.lastEntry().getValue()\
    \ > 0 ? freq.lastEntry().getKey() : -1;", "        long max = -1;\n        long\
    \ value = -1;\n        for (long l : lst) {\n            if (max < 0 || l > max)\
    \ {\n                max = l;\n                value = -1;\n            }\n  \
    \          else if (value >= 0 && l == value) {\n                ++value;\n  \
    \          }\n        }\n        return max;", "        long largestNumber;\n\
    \        long freqNumber;\n        \n        for (long number : lst) {\n     \
    \       if (number == 0) {\n                continue;\n            }\n       \
    \     freqNumber = 0;\n            for (long i : lst) {\n                if (i\
    \ == number) {\n                    freqNumber++;\n                }\n       \
    \     }\n            if (freqNumber >= number) {\n                largestNumber\
    \ = number;\n                break;\n            }\n        }\n        return\
    \ largestNumber;", "        Long max = new Long(0);\n        Long maxFreq = new\
    \ Long(0);\n        for (Long i : lst) {\n            if (i > max) {\n       \
    \         max = i;\n            }\n            if (i.equals(max)) {\n        \
    \        maxFreq++;\n            }\n        }\n        if (maxFreq >= max.longValue())\
    \ {\n            return max;\n        }\n        return -1l;", "        int max\
    \ = -1;\n        long curr = -1;\n        for (Long val : lst) {\n           \
    \ if (val >= 0) {\n                if (max == -1) {\n                    max =\
    \ val;\n                    curr = val;\n                } else if (max != 0)\
    \ {\n                    curr = (long)Math.max(curr, max);\n                 \
    \   max = 0;\n                }\n            }\n        }\n        return curr;",
  "        if (lst != null && !lst.isEmpty()) {\n            Collections.sort(lst);\n\
    \            return findGreatest(lst);\n        }\n        return -1;", "    \
    \    Map<Long, Long> frequency = new HashMap<>();\n        for( long val : lst\
    \ ){\n            if( !frequency.containsKey(val) ){\n                frequency.put(val,\
    \ 0l);\n            }\n            frequency.put(val, frequency.get(val) + 1);\n\
    \        }\n        for( long val : frequency.keySet() ){\n            if( frequency.get(val)\
    \ >= val ){\n                return val;\n            }\n        }\n        return\
    \ -1l;", "        long maxVal = lst.get(0);\n        long maxFreq = lst.get(0);\n\
    \        for (long i = 1; i < lst.size(); i++) {\n            long freq = lst.get(i);\n\
    \            if (freq >= maxFreq) {\n                maxFreq = freq;\n       \
    \         maxVal = i;\n            }\n        }\n        return maxVal;", "  \
    \      ArrayList<Long> newList = new ArrayList<Long>(lst);\n        if (newList.size()\
    \ == 0) {\n            return -1;\n        }\n        Set<Long> unique = new HashSet<Long>(newList);\n\
    \        unique.remove(-1);\n        if (unique.size() > 1) {\n            return\
    \ -1;\n        }\n        return newList.get(0);", "        long maxFreq = -1;\n\
    \        long maxVal = -1;\n        int maxIdx = 0;\n        for(long val : lst)\
    \ {\n            if(val > maxVal) {\n                maxFreq = maxIdx;\n     \
    \           maxVal = val;\n                maxIdx = lst.indexOf(val);\n      \
    \      }\n        }\n        if(maxIdx < 0) return -1;\n        return lst.get(maxFreq);",
  "        long maxCount = 0;\n        for (long number : lst) {\n            if (number\
    \ > 0) {\n                Map<Long, Long> counts = new HashMap<Long, Long>();\n\
    \                for (long count : lst) {\n                    counts.merge(count,\
    \ 1L, Long::sum);\n                }\n                Long frequency = counts.get(number);\n\
    \                if (frequency >= maxCount) {\n                    maxCount =\
    \ frequency;\n                }\n            }\n        }\n        return maxCount\
    \ == 0 ? -1 : maxCount;", "        HashMap<Long, Long> h = new HashMap<Long, Long>();\n\
    \        for (Long l : lst)\n            h.put(l, h.getOrDefault(l, 0L) + 1);\n\
    \        Long max = h.get(0);\n        for (Long l : h.keySet())\n           \
    \ if (l > max)\n                max = l;\n        if (max > 0)\n            return\
    \ max;\n        return -1;", "        if (lst.isEmpty()) return -1;\n        long\
    \ m = Collections.max(lst);\n        long f = Collections.frequency(lst, m);\n\
    \        return f >= m ? m : -1;", "        Map<Long, Long> freq = new HashMap<>();\n\
    \        for (Long val : lst) {\n            freq.put(val, freq.get(val) == null\
    \ ? 0 : freq.get(val) + 1);\n        }\n        if (freq.values().stream().filter(\
    \ i -> i > 0 ).count() < freq.values().stream().mapToLong(i->i).min() ) {\n  \
    \          return -1;\n        }\n        return freq.values().stream().filter(\
    \ i -> i > 0 ).reduce((a, b) -> b > a ? b : a).orElse(-1);", "        long max\
    \ = 0;\n        for(long i : lst)\n            if (i > 0) \n                max\
    \ += i;\n        if (max == 0) return -1;\n        long freq = lst.stream().filter(i\
    \ -> i > 0).count();\n        return Math.max(max, freq);", "        long res\
    \ = -1;\n        if (lst.stream().anyMatch(x -> x > 0))\n            res = findMax(lst,\
    \ Collections.frequency(lst, 0));\n        return res;", "        int n = lst.size();\n\
    \        if (n == 0)\n            return -1;\n        // find max value\n    \
    \    long maxVal = Long.MIN_VALUE, maxCount = 0, maxIdx = 0;\n        for (int\
    \ i = 0; i < n; i++) {\n            long val = lst.get(i);\n            if (val\
    \ > maxVal)\n                maxVal = val;\n            long count = Collections.frequency(lst,\
    \ val);\n            if (count > maxCount)\n                maxCount = count;\n\
    \            if (count > 0)\n                maxIdx = i;\n        }\n        //\
    \ find all vals greater than max\n        List<Long> biggerVals = lst.stream()\n\
    \                .filter((Long val) -> val > maxVal)\n                .collect(Collectors.toList());\n\
    \        // find all vals greater than max with counts\n        List<Tuple2<Long,\
    \ Long>> biggerCounts = biggerVals.stream()\n                .map(val -> Tuples.pair(val,\
    \ Collections.frequency(lst, val)))\n                .collect(Collectors.toList());\n\
    \        // find max with counts\n        Tuple2<Long, Long> maxWithCounts = biggerCounts.stream()\n\
    \                .max(Comparator.comparing(t -> t._2()))\n                .orElse(Tuples.pair(maxVal,\
    \ 0));\n        return maxWithCounts._1;", "        final int N = (int)lst.get(0);\n\
    \        long ret = 0;\n        for(int i = 1; i < lst.size(); i++) {\n      \
    \      int freq = (int)lst.get(i);\n            if (freq < N) {\n            \
    \    ret = Math.max(ret, freq);\n            } else\n                ret++;\n\
    \        }\n        return -1;", "        long maxVal = -1;\n        long freq\
    \ = -1;\n        if (lst.isEmpty()) return -1;\n        long val = lst.get(0);\n\
    \        for (long i : lst) {\n            freq += 1;\n            if (val !=\
    \ i && freq >= i) {\n                freq = -1;\n                val = i;\n  \
    \          }\n        }\n        maxVal = val > 0 ? val : -1;\n        return\
    \ maxVal;", "        int max = -1;\n        int freq = -1;\n        for (long\
    \ i : lst) {\n            if (freq == -1 || freq < i) {\n                freq\
    \ = 1;\n                max = i;\n            } else {\n                freq *=\
    \ i;\n            }\n        }\n        return max;", "        HashMap<Long, Long>\
    \ freq = new HashMap<Long, Long>();\n\n        for (long value : lst) {\n    \
    \        Long count = freq.get(value);\n            freq.put(value, count + (count\
    \ == null ? 1 : 0));\n        }\n\n        Long greatest = freq.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\n\
    \n        return freq.entrySet().stream().filter(e -> e.getValue() == greatest).findFirst().map(Map.Entry::getKey).orElse(-1);",
  "        long max = Long.MIN_VALUE;\n        long max = Long.MIN_VALUE;\n      \
    \  for (long l : lst) {\n            if (max <= 0) {\n                return -1;\n\
    \            }\n            if (l > max) {\n                max = l;\n       \
    \     }\n        }\n        return max;", "        long max = -1;\n        ArrayList\
    \ <Long> freq = new ArrayList <Long> ();\n        for (long x : lst) {\n     \
    \       if (freq.contains(x)) {\n                freq.remove(x);\n           \
    \ }\n            freq.add(x);\n            if (x > max) {\n                max\
    \ = x;\n            }\n        }\n        if (max > 0) {\n            return max;\n\
    \        }\n        else {\n            return -1;\n        }", "        long\
    \ max = -1;\n        long maxVal = 0;\n        int cnt = 1;\n        for (long\
    \ val : lst) {\n            if (val > maxVal) {\n                maxVal = val;\n\
    \                max = cnt;\n            }\n            cnt += 1;\n        }\n\
    \        if (maxVal == 0)\n            return -1;\n        return max;", "   \
    \     Map<Long, Long> map = new TreeMap<>();\n        for (Long i : lst) {\n \
    \           map.put(i, map.getOrDefault(i, 0L) + 1);\n        }\n        long\
    \ greatest = Long.MIN_VALUE;\n        long currMaxFreq = -1;\n        for (Map.Entry<Long,\
    \ Long> entry : map.entrySet()) {\n            if (currMaxFreq < entry.getValue())\
    \ {\n                currMaxFreq = entry.getValue();\n                greatest\
    \ = entry.getKey();\n            }\n        }\n        return greatest;", "  \
    \      long maxFreq = -1;\n        long maxInt = -1;\n\n        boolean hasNonZeroFreq\
    \ = lst.stream().anyMatch(x -> x != 0);\n        if (hasNonZeroFreq) {\n     \
    \       long sum = lst.stream().reduce(0, (acc, val) -> acc + val); // sum of\
    \ all values\n            long freq = lst.stream().filter(x -> x != 0).count();\
    \ // number of values that are not 0\n            long intVal = lst.stream().min(Comparator.naturalOrder())\
    \ // get min value (by value)\n                    .orElse(-1l); // if there's\
    \ no min (by value), set to -1\n\n            if (intVal == -1l) intVal = freq;\
    \ // if intVal is -1, set to freq\n            if (intVal == freq) intVal = 0;\
    \ // if intVal is freq, set to 0\n\n            freq = freq + intVal;\n\n    \
    \        minFreq = freq; // store this min freq\n            maxInt = intVal;\
    \ // store this max int\n            maxFreq = sum - freq; // store this max freq\
    \ minus freq since we've already found a min freq\n\n        }\n\n        return\
    \ hasNonZeroFreq ? maxInt : maxFreq;\n", "        int count = lst.stream().filter(p\
    \ -> p > 0).count();\n        int max = 0;\n        for(long l : lst) {\n    \
    \        if(l > max) {\n                max = l;\n            }\n        }\n \
    \       return max == 0 ? -1 : max;", "        long maxCount = 0;\n        for\
    \ (long num : lst) {\n            if (num == 0 || num < 0) {\n               \
    \ return -1;\n            }\n            long count = lst.stream().filter(i ->\
    \ i==num).count();\n            if (count >= maxCount) {\n                return\
    \ maxCount;\n            }\n            maxCount = count;\n        }\n       \
    \ return -1;", "        long max = -1;\n        for(long i : lst){\n         \
    \   if( i > 0 ){\n                if( (i+max) >= 0 && (i+max) >= i ) max = i;\n\
    \            }\n        }\n        return max;", "        Long greatestLong =\
    \ null;\n        Set<Long> unique = new HashSet<Long>();\n        for (Long i\
    \ : lst) {\n            if (!unique.add(i)) {\n                unique.add(i);\n\
    \                if (greatestLong == null || i > greatestLong) {\n           \
    \         greatestLong = i;\n                }\n            }\n        }\n   \
    \     return unique.contains(greatestLong) ? greatestLong : -1;", "        return\
    \ lst.stream()\n                .max(Comparator.comparingLong(l -> l))\n     \
    \           .orElse(-1l);", "        if (lst == null || lst.isEmpty()) return\
    \ -1L;\n\n        TreeMap<Long, Integer> freq = new TreeMap<>();\n        for\
    \ (long l : lst) {\n            freq.put(l, (long) freq.get(l) + 1);\n       \
    \ }\n\n        return freq.lastEntry().getValue() > 0 ? freq.lastEntry().getKey()\
    \ : -1L;", "        long max = -1;\n        long frequency = 1;\n        for (long\
    \ i : lst)\n            frequency += 1;\n        for (long i : lst)\n        \
    \    if (i > 0 && i == lst.get(frequency - 1)) {\n                frequency =\
    \ frequency - 1;\n                max = i;\n            }\n        return max;",
  '        return lst.stream().filter(s -> s > 0l).map(x -> lst.stream().filter(e
    -> e == x).count()).max().orElse(-1l);', "        long largest = -1;\n       \
    \ long frequency = 0;\n        for (Long i : lst)\n            if (i >= frequency)\
    \ {\n                frequency = i;\n                largest = i;\n          \
    \  }\n        return largest;", "        long max = -1l;\n        Arrays.sort(lst);\n\
    \        int count = 0;\n        for(int i=0; i<lst.size(); i++){\n          \
    \  count++;\n            if(lst.get(i) > max){\n                max = lst.get(i);\n\
    \            }\n        }\n        return max >= count ? max : -1;", "       \
    \ HashMap<Long, Long> frequency = lst.stream().collect(Collectors.groupingBy(Function.identity(),\
    \ Collectors.counting()));\n        for (Map.Entry<Long, Long> entry : frequency.entrySet())\
    \ {\n            if (entry.getValue() >= entry.getKey()) {\n                return\
    \ entry.getKey();\n            }\n        }\n        return -1l;", "        long\
    \ max = lst.stream().max(Long::compare).get();\n        long freq = lst\n    \
    \            .stream()\n                .filter(elem -> elem.longValue() == max)\n\
    \                .count();\n        if (freq > 0) {\n            return max;\n\
    \        }\n        return -1;", "        long max = -1;\n        long curr =\
    \ null;\n        for (long i : lst) {\n            if (max == -1 || max < i) {\n\
    \                max = i;\n                curr = i;\n            } else if (max\
    \ > i && max >= curr) {\n                curr = i;\n            }\n        }\n\
    \        return max;", "        if (lst.isEmpty()) return -1L;\n        Map<Long,\
    \ Long> map = new HashMap<>();\n        for (int i = 0; i < lst.size(); i++) {\n\
    \            long val = lst.get(i);\n            if (map.containsKey(val)) {\n\
    \                map.put(val, map.get(val) + 1);\n            } else {\n     \
    \           map.put(val, 1L);\n            }\n        }\n        for (Map.Entry<Long,\
    \ Long> e : map.entrySet()) {\n            if (e.getValue() >= e.getKey() && e.getKey()\
    \ > 0) {\n                return e.getKey();\n            }\n        }\n     \
    \   return -1L;", "        long maxFreq = -1;\n        long maxVal = -1;\n   \
    \     for (Long value : lst) {\n            if (value > 0 && !maxVal.equals(-1)\
    \ && !maxFreq.equals(-1)) {\n                // check if the current frequency\
    \ is greater than or equal to the current value\n                if (maxFreq >=\
    \ maxVal) {\n                    maxFreq = maxVal;\n                }\n      \
    \      }\n            else {\n                // else if there is no such value\
    \ in the array, we set the current frequency to -1\n                maxFreq =\
    \ -1;\n            }\n            // else if there is a current value that is\
    \ greater or equal than the current frequency, we update the current value\n \
    \           maxVal = value;\n        }\n        return maxFreq == -1 ? -1 : maxVal;",
  "        long max = Long.MIN_VALUE;\n        long max = lst.get(0);\n        for\
    \ (Long val : lst) {\n            if (val == max) {\n                continue;\n\
    \            }\n            if (val > max) {\n                max = val;\n   \
    \         }\n        }\n        if (max == 0) {\n            return -1;\n    \
    \    }\n        for (long val : lst) {\n            if (val == max) {\n      \
    \          continue;\n            }\n            if (val > max) {\n          \
    \      max = val;\n            }\n        }\n        return max;", "        long\
    \ maxVal = -1;\n        int freq = -1;\n        for(Long val : lst) {\n      \
    \      freq = Collections.frequency(lst, val);\n            if(freq >= val) break;\n\
    \            maxVal = val;\n        }\n        return maxVal;", "        long\
    \ max = -1;\n        long frequency = -1;\n        for(long i : lst) {\n     \
    \       frequency += 1;\n            if(frequency > i && frequency > max) {\n\
    \                max = i;\n                frequency = 1;\n            } else\
    \ if(frequency == i && frequency > max) {\n                max = i;\n        \
    \        frequency = 1;\n            }\n        }\n        return max;", "   \
    \     if (lst.isEmpty()) return -1;\n        long max = 0;\n        long cur =\
    \ 0;\n        for (long i : lst) {\n            while (true) {\n             \
    \   cur = i;\n                for (int j = 0; j <= i; ++j) {\n               \
    \     if (lst.get(j) > cur) break;\n                }\n                if (j ==\
    \ i) break;\n                cur++;\n                if (cur > max) max = cur;\n\
    \            }\n        }\n        return max;", "        Arrays.sort(lst);\n\
    \        return lst.stream().filter(x -> x > 0).collect(Collectors.toList()).get(0);",
  "        if (lst.size() == 0) return -1;\n        TreeMap<Long, Long> tm = new TreeMap<>();\n\
    \        for (Long e : lst) tm.put(e, 0);\n        for (Long e : lst) {\n    \
    \        long x = tm.get(e);\n            if (x >= e) x = e;\n            tm.put(e,\
    \ x + 1);\n        }\n        Long max = tm.lastEntry().getValue();\n        if\
    \ (max == 1) return max;\n        TreeMap<Long, Long> newtm = new TreeMap<>();\n\
    \        for (Map.Entry<Long, Long> entry : tm.entrySet()) {\n            newtm.put(entry.getKey(),\
    \ entry.getValue());\n        }\n        for (Map.Entry<Long, Long> entry : newtm.entrySet())\
    \ {\n            if (entry.getValue() < max) {\n                max = entry.getValue();\n\
    \            }\n        }\n        return max;", "        Set<Long> map = new\
    \ HashSet<Long>(lst);\n        List<Long> list = lst.stream().sorted().collect(Collectors.toList());\n\
    \        Long max = list.stream().max(Long::compareTo).orElse(-1l);\n        Long\
    \ maxFreq = list.stream().filter(elem -> elem.equals(max)).count();\n        return\
    \ maxFreq > map.get(max) ? max : -1;", "        long mostFrequent = lst.get(0);\
    \ // start at the first element\n        int frequencyOfMostFrequent = 1;\n  \
    \      for (Long l : lst) {\n            if (l == mostFrequent) frequencyOfMostFrequent++;\n\
    \            else {\n                if (frequencyOfMostFrequent > 1) return -1l;\n\
    \                if (frequencyOfMostFrequent == 1) { // found a match\n      \
    \              if (l > mostFrequent) mostFrequent = l;\n                    frequencyOfMostFrequent\
    \ = 1;\n                }\n            }\n        }\n        return mostFrequent;",
  "        Set<Long> set = new HashSet<>();\n        for (int i : lst) {\n       \
    \     set.add(i, 1);\n        }\n        for (Long i : set) {\n            if\
    \ (i > 0) return i;\n        }\n        return -1;", "        long max = Long.MIN_VALUE;\n\
    \        long curr = lst.get(0);\n        long freq = lst.get(0);\n        for\
    \ (long l: lst) {\n            if (l != curr) {\n                max = Math.max(max,\
    \ curr);\n            }\n            long newFreq = lst.get(l) - 1;\n        \
    \    if (newFreq >= freq) {\n                freq = newFreq;\n            }\n\
    \            curr = l;\n        }\n        return max < Long.MIN_VALUE ? Long.MIN_VALUE\
    \ : max;", "        // write your code in Java 7\n        return -1;", "     \
    \   long min = lst.get(0l), max = Long.MIN_VALUE;\n        for (Long l : lst)\
    \ {\n            if (min > l) min = l;\n            if (max < l) max = l;\n  \
    \      }\n        if (min > 0) return min;\n        int n = lst.size();\n    \
    \    Set<Long> set = new HashSet<>(lst);\n        for (int i = 0; i < n; i++)\
    \ {\n            if (set.contains(i) && set.size() >= i + 1) return i;\n     \
    \   }\n        return -1l;", "        long retVal = -1;\n        List<Integer>\
    \ lstCopy = lst.stream().map(x -> new Integer(x)).collect(Collectors.toList());\n\
    \        lstCopy.stream().filter(i -> lstCopy.contains(i)).filter(x -> lst.contains(x)).count()\
    \ <= 1 ? retVal = lstCopy.stream().filter(x -> lstCopy.contains(x)).findFirst().orElse(-1)\
    \ : retVal = lstCopy.stream().filter(x -> lstCopy.contains(x)).collect(Collectors.toList()).stream().max(Comparator.comparing(x\
    \ -> lstCopy.stream().filter(y -> lstCopy.contains(y)).filter(z -> lst.contains(z)).count())).get();\n\
    \        return retVal;", "        if (lst.isEmpty()) return -1l; // no such value\n\
    \        long maxVal = -1l;\n        long curVal = lst.get(0);\n        int maxCount\
    \ = 0;\n        for (int i = 1; i < lst.size(); i++) {\n            curVal = lst.get(i);\n\
    \            if (curVal == -1l) return -1l; // no such value\n            int\
    \ cnt = lst.get(i).intValue();\n            if (cnt > maxCount) {\n          \
    \      maxVal = curVal;\n                maxCount = cnt;\n            }\n    \
    \    }\n        return maxVal;", "        int len = lst.size();\n        int maxIndex\
    \ = -1;\n        long maxValue = -1;\n        for (int i = 0; i < len; i++) {\n\
    \            long value = lst.get(i);\n            if (value > 0) {\n        \
    \        int count = 1;\n                for (int j = i + 1; j < len; j++) {\n\
    \                    if (lst.get(j) == value) {\n                        count++;\n\
    \                    }\n                }\n                if (count >= maxValue)\
    \ {\n                    maxValue = count;\n                    maxIndex = value;\n\
    \                }\n            }\n        }\n        return maxIndex == -1 ?\
    \ -1 : maxIndex;", "        ArrayList<Long> freq = new ArrayList<Long>();\n  \
    \      for(Long i : lst) {\n            freq.add(i);\n        }\n        Collections.sort(freq,\
    \ Comparator.comparingLong(Long::valueOf));\n        int max = freq.indexOf(1l);\n\
    \        if(max == -1) {\n            return -1l;\n        }\n        for(Integer\
    \ i = (int)min(freq.get(0l), freq.size()); i <= freq.size(); i++) {\n        \
    \    if(freq.indexOf(i) != -1) {\n                max = i;\n                break;\n\
    \            }\n        }\n        return lst.get(max);", "        int largestFreq\
    \ = getLargestFreq(lst.stream().collect(toList()));\n        return largestFreq\
    \ == -1 ? -1 : (lst.stream().filter(n -> n < largestFreq).collect(toList()).stream().max(Long::compareTo).orElse(-1));",
  "        Set<Long> set = new TreeSet<>(lst);\n        if (set.isEmpty()) {\n   \
    \         return -1;\n        }\n        long maxVal = set.first();\n        long\
    \ maxFreq = set.size();\n        for (long val : set) {\n            if (val !=\
    \ maxVal) {\n                maxVal = val;\n                maxFreq = Collections.frequency(lst,\
    \ val);\n            }\n        }\n        return maxVal;", "        long result\
    \ = -1;\n        long max = 0;\n        for (long val : lst) {\n            max\
    \ = Math.max(max, val);\n        }\n\n        for (long val : lst) {\n       \
    \     long freq = lst.stream().filter(x -> x > val).count();\n            if (freq\
    \ >= val) {\n                result = val;\n                break;\n         \
    \   }\n        }\n\n        return result;", "        if (lst.isEmpty()) {\n \
    \           return -1;\n        }\n        \n        final long zero = 0;\n  \
    \      \n        // Find a key in the map.\n        Optional<Map.Entry<Long, Long>>\
    \ entry = lst.stream().map(val -> (val)).boxed().collect(Collectors.toMap(Function.identity(),\
    \ \n                val -> 1l, \n                (k, v) -> v+1, \n           \
    \     HashMap::new));\n        \n        if (entry.isPresent()) {\n          \
    \  final Map.Entry<Long, Long> entry = entry.get();\n            if (entry.getValue()\
    \ >= entry.getKey() && entry.getValue() > 0) {\n                return entry.getKey();\n\
    \            }\n        }\n        \n        // If no key was found, find the\
    \ maximum value in the list.\n        Optional<Long> max = lst.stream().reduce((a,\
    \ b) -> a > b ? a : b);\n        \n        return max.isPresent() ? max.get()\
    \ : -1;", "        // Write your code here\n        int n = lst.size();\n    \
    \    Map<Long, Long> m = new HashMap<>();\n        for (int i = 0; i < n; i++)\
    \ {\n            if (m.containsKey(lst.get(i))) {\n                m.merge(lst.get(i),\
    \ lst.get(i), Long::sum);\n            } else {\n                m.put(lst.get(i),\
    \ 1l);\n            }\n        }\n        if (m.isEmpty()) {\n            return\
    \ -1;\n        }\n        for (Map.Entry<Long, Long> entry : m.entrySet()) {\n\
    \            if (entry.getValue() > lst.size() * 1.0 / n) {\n                return\
    \ -1;\n            }\n        }\n        long max = Long.MIN_VALUE;\n        for\
    \ (Map.Entry<Long, Long> entry : m.entrySet()) {\n            if (entry.getValue()\
    \ > max) {\n                max = entry.getValue();\n            }\n        }\n\
    \        return max;", "        long freq = 0;\n        ArrayList<Long> newArr\
    \ = new ArrayList<>();\n        for (Long i : lst) {\n            if (i > 0) freq++;\n\
    \            newArr.add(i);\n        }\n        if (freq == 0)\n            return\
    \ -1;\n        else\n            return newArr.get(newArr.size() - 1);", "   \
    \     Arrays.sort(lst);\n        long max = -1;\n        long freq = lst.get(lst.size()-1);\n\
    \        for(long i = 0; i < lst.size(); i++) {\n            freq = lst.get(i);\n\
    \            if (freq >= freq) {\n                max = freq;\n              \
    \  break;\n            }\n        }\n        return max;", "        Set<Long>\
    \ frequency = new HashSet<Long>();\n        for (Long i : lst) {\n           \
    \ frequency.add(i);\n        }\n        long max = Long.MIN_VALUE;\n        for\
    \ (Long i : frequency) {\n            if (i > max) {\n                max = i;\n\
    \            }\n            if (frequency.get(i) >= i) {\n                frequency.remove(i);\n\
    \            }\n        }\n        if (frequency.isEmpty()) {\n            return\
    \ -1;\n        }\n        return max;", "        long max = 0;\n        int count\
    \ = 0;\n        for (long i : lst) {\n            if (i >= 0) {\n            \
    \    count++;\n                max = Math.max(max, i);\n            }\n      \
    \  }\n        if (count <= 0) {\n            return -1;\n        }\n        Map<Long,\
    \ Integer> map = new TreeMap<>();\n        for (long i : lst) {\n            if\
    \ (i >= 0) {\n                map.put(i, map.getOrDefault(i, 0) + 1);\n      \
    \      }\n        }\n        if (map.containsKey(max)) {\n            return max;\n\
    \        }\n        return -1;", "        ArrayList < Long > freq = new ArrayList\
    \ < Long > (lst.size());\n        for (int i = 0; i < lst.size(); i++) {\n   \
    \         freq.add (lst.get(i));\n        }\n        int max = -1;\n        long\
    \ maxFreq = -1;\n        for (Long elem : freq) {\n            if (maxFreq < 0\
    \ || elem > maxFreq) {\n                maxFreq = elem;\n                max =\
    \ elem;\n            }\n        }\n        return max;", "        long maxValue\
    \ = -1;\n        int maxCount = 0;\n        for (Long l : lst) {\n           \
    \ int count = Collections.frequency(lst, l);\n            if (count > maxCount)\
    \ {\n                maxCount = count;\n                maxValue = l;\n      \
    \      }\n        }\n        return maxValue;", "        long max = -1;\n    \
    \    long maxFreq = -1;\n        for (long num : lst) {\n            long freq\
    \ = lst.count(num);\n            if (freq >= maxFreq) {\n                maxFreq\
    \ = freq;\n                max = num;\n            }\n        }\n        return\
    \ max;", "        // Your Code Here\n        \n        Set<Long> set = new HashSet<>();\n\
    \        Set<Long> freq = new HashSet<>();\n        for(Long i: lst){\n      \
    \      freq.add(i);\n            if(freq.contains(i))\n                freq.remove(i);\n\
    \            set.add(i);\n        }\n        if (set.size()==0)\n            return\
    \ -1;\n        \n        for(Long i: set){\n            if(freq.contains(i))\n\
    \                freq.remove(i);\n        }\n        if(freq.size()==0)\n    \
    \        return -1;\n        \n        \n        Iterator<Long> it=set.iterator();\n\
    \        while(it.hasNext()){\n            long i=it.next();\n            if(freq.contains(i))\n\
    \                freq.remove(i);\n        }\n        if(freq.size()==0)\n    \
    \        return -1;\n        \n        \n        long greatest=0;\n        long\
    \ current=lst.get(0);\n        \n        for(Long i : set){\n            long\
    \ freq=freq.contains(i) ? freq.get(i) : 0;\n            if(freq>current){\n  \
    \              current=i;\n                greatest=i;\n            }\n      \
    \  }\n        return greatest;", "        long val = 0;\n        val =  lst.stream().filter(l->l>0l).map(l\
    \ ->l).reduce(Math::max).orElse(-1l);\n        return val;", "        HashMap<Long,\
    \ Long> counts = new HashMap<Long, Long>();\n        lst.forEach(v -> counts.merge(v,\
    \ 1L, Long::sum));\n        return lst.stream().min(Long::compareTo).filter(t\
    \ -> counts.get(t) >= t).findFirst().get();", "        if (lst.size() <= 0) return\
    \ -1;\n        Set<Long> set = new TreeSet<>(lst);\n        Long result = set.stream().filter((x)\
    \ -> x > 0).max(Long::compareTo).get();\n        if (result != null)\n       \
    \     return result.intValue();\n        else return -1;", "        final HashMap<Long,\
    \ Integer> freqMap = new HashMap<Long, Integer>();\n        lst.stream().forEachOrdered(n\
    \ -> freqMap.put(n, freqMap.getOrDefault(n,0) + 1));\n        return lst.stream().max((a,b)\
    \ -> freqMap.get(a) > freqMap.get(b) ? a : b)\n                .get();", "   \
    \     long result = -1;\n        if (lst.isEmpty()) return result;\n        Set<Long>\
    \ set = new HashSet<>();\n        for (Long l : lst) {\n            if (set.contains(l))\
    \ {\n                if (set.size() > 1) {\n                    set.add(l);\n\
    \                    if (set.size() > set.lastElement()) {\n                 \
    \       set.clear();\n                        set.add(l);\n                  \
    \  }\n                }\n            } else {\n                set.add(l);\n \
    \               if (set.size() == 1) {\n                    result = l;\n    \
    \            }\n            }\n        }\n        return result;", "        ArrayList<Long>\
    \ freq = new ArrayList<>();\n        long maxFreq = -1;\n        long maxVal =\
    \ -1;\n        for (long val : lst) {\n            if (freq.stream().filter(f\
    \ -> f == val).count() == 0) {\n                freq.add(val);\n             \
    \   if (val > maxVal) {\n                    maxFreq = maxVal;\n             \
    \       maxVal = val;\n                } else if (val == maxVal) {\n         \
    \           maxFreq = val;\n                }\n            }\n        }\n    \
    \    return maxFreq == -1 ? -1 : maxVal;", "        if (lst.isEmpty()) return\
    \ -1l;\n        long maxval = lst.get(0l);\n        long curfreq = 0l;\n     \
    \   for (Long val: lst) {\n            if (val > 0l) {\n                curfreq++;\n\
    \            }\n            if (curfreq >= maxfreq) {\n                maxfreq\
    \ = curfreq;\n                maxval = val;\n            }\n        }\n      \
    \  return maxval;", "        long res = -1;\n        if (lst.size() == 0) return\
    \ res;\n        for (long i : lst) {\n            if (i >= 0) \n             \
    \   for (long j : lst) {\n                    if (j < i) {\n                 \
    \       continue;\n                    } else if (j == i) {\n                \
    \        j++;\n                    }\n                    if (i >= j && j > res\
    \ && j <= (long)Integer.MAX_VALUE / i) {\n                        res = j;\n \
    \                   }\n                }\n        }\n        return res;", " \
    \       List<Long> sortedLst = lst.stream().sorted().collect(Collectors.toList());\n\
    \        for (long l : sortedLst) {\n            long freq = Collections.frequency(lst,\
    \ l);\n            if (freq >= l) {\n                return l;\n            }\n\
    \        }\n        return -1;", "        long maxVal = lst.get(0);\n        for\
    \ (int i = 0; i < lst.size(); ++i) {\n            if (lst.get(i) >= maxVal) {\n\
    \                maxVal = lst.get(i);\n            }\n        }\n        return\
    \ maxVal;", "        int n = lst.size();\n        if (n == 0) return -1;\n   \
    \     Map<Long, Long> m = new HashMap<>();\n        for (Long i : lst) {\n   \
    \         long f = m.get(i);\n            if (f == 0) m.put(i, 1);\n         \
    \   else m.put(i, ++f);\n        }\n        for (Map.Entry<Long, Long> i : m.entrySet())\
    \ {\n            if(i.getValue() > n) {\n                return -1;\n        \
    \    }\n        }\n        return m.get(Collections.max(m.entrySet()));", "  \
    \      long max = 0;\n        for(long l : lst) {\n            max = Math.max(max,\
    \ l);\n            max = Math.min(max, l);\n        }\n        return max;", " \
    \       int n = lst.size();\n        int max = 0;\n        for (long l : lst)\
    \ {\n            int t = Collections.frequency(lst, l);\n            if (max <\
    \ t && t >= 0) {\n                max = t;\n            }\n        }\n       \
    \ if (max == -1) {\n            throw new RuntimeException(\"Empty List\");\n\
    \        }\n        return max;", "        if(lst.size() < 1) return -1;\n   \
    \     \n        HashMap<Long,Long> hm = new HashMap<>();\n        \n        for(Long\
    \ i : lst)\n            if(hm.containsKey(i)) {\n                hm.put(i,hm.get(i)\
    \ + 1);\n            } else {\n                hm.put(i, 1l);\n            }\n\
    \        \n        for(Long i : lst) {\n            if(hm.get(i) > 0) return i;\n\
    \        }\n        \n        return -1;", "        long n = lst.size();\n   \
    \     if(n==0)\n            return -1l;\n        long max = -1l;\n        for(int\
    \ i = 0; i < n; i++) {\n            if(lst.contains(i))\n                if(lst.size()>1l)\
    \ {\n                    long temp = 1;\n                    for(int j = 0; j\
    \ < i; j++)\n                        temp *= lst.size();\n                   \
    \ if(temp>max)\n                        max = temp;\n                }\n     \
    \           else\n                    max = i;\n        }\n        return max;",
  "        long highest = 0l;\n        for (long i : lst) {\n            long freq\
    \ = Collections.frequency(lst, i);\n            if (freq >= i) {\n           \
    \     highest = i;\n            }\n        }\n        return highest == 0l ? -1\
    \ : highest;", "        // TODO: write your code here\n        long max = (long)\
    \ Math.pow(2, lst.size());\n        long freq = -1;\n        for(long i : lst)\
    \ {\n            if(freq == -1) {\n                freq = 1;\n               \
    \ max = i;\n            }\n            freq += i;\n            if(max > freq)\
    \ {\n                freq = max;\n            }\n        }\n        return freq;",
  '        ', "        long max = -1;\n        long freq = 0;\n        for (Long i\
    \ : lst) {\n            if (freq > i.longValue()) break;\n            freq +=\
    \ 1;\n            if (freq > i.longValue()) {\n                max = i;\n    \
    \            freq = i.longValue();\n            }\n        }\n        return max;",
  "        long max = -1;\n        long freq = lst.get(0);\n        for (long elem\
    \ : lst) {\n            if (elem == freq) {\n                ++freq;\n       \
    \     } else {\n                if (freq > 0 && max < elem) {\n              \
    \      max = elem;\n                }\n                freq = elem;\n        \
    \    }\n        }\n        return max;", "        long max = -1;\n        long\
    \ freq = -1;\n        for (Long i : lst) {\n            freq++;\n            if\
    \ (freq > i) {\n                freq = i;\n            }\n            if (max\
    \ < 0) {\n                max = freq;\n            } else if (freq > max) {\n\
    \                max = freq;\n            }\n        }\n        return max;",
  "        Map<Long, Integer> map = new TreeMap<>();\n        lst.stream().forEach(e\
    \ -> map.put(new Long(e), map.getOrDefault(new Long(e), 0) + 1));\n        boolean\
    \ exists = false;\n        for (Long e : map.keySet()) {\n            if (map.get(e)\
    \ >= map.get(new Long(e))) {\n                exists = true;\n               \
    \ return e;\n            }\n        }\n        if (exists) {\n            return\
    \ -1;\n        } else {\n            return -1;\n        }", "        long[] arr\
    \ = lst.stream().mapToLong(Long::longValue).toArray();\n        Arrays.sort(arr);\n\
    \        int min = arr[0];\n        for(int i = 1; i < arr.length; i++) {\n  \
    \          if(arr[i] > min) {\n                min = arr[i];\n            }\n\
    \        }\n        return min >= 0 ? min : -1;", "        if (lst.size() == 0)\
    \ {\n            return -1;\n        }\n        TreeMap<Long, Integer> map = new\
    \ TreeMap<>();\n        for (Long el : lst) {\n            Integer count = map.get(el);\n\
    \            if (count == null) {\n                map.put(el, 1);\n         \
    \   } else {\n                map.put(el, count + 1);\n            }\n       \
    \ }\n        for (Entry<Long, Integer> entry : map.entrySet()) {\n           \
    \ if (entry.getValue() >= entry.getKey()) {\n                return entry.getKey();\n\
    \            }\n        }\n        return -1;", "        if(lst.size() <= 1) return\
    \ -1;\n        long largest = 0;\n        int index = -1;\n        for(long l:\
    \ lst) {\n            if((l = lst.stream().filter(i -> i > 0).count())\n     \
    \           && lst.stream().filter(i -> i == l).count() >= l) {\n            \
    \    index = l;\n            }\n        }\n        if(index != -1 && index >=\
    \ largest) largest = index;\n        return largest == -1 ? -1 : (lst.stream().filter(i\
    \ -> i > 0).count() == 0) ? -1 : largest;", "        Set<Long> set = new HashSet<>();\n\
    \        for (long i : lst) {\n            if (set.contains(i)) {\n          \
    \      set.add(i);\n            } else {\n                Long val = i;\n    \
    \            while (set.contains(val)) {\n                    set.add(val);\n\
    \                    val = val + 1;\n                }\n                set.add(val);\n\
    \            }\n        }\n        Set<Long> res = new HashSet<>();\n        for\
    \ (long i : set) {\n            if (res.contains(i)) {\n                res.add(i);\n\
    \            } else {\n                res.add(-1);\n            }\n        }\n\
    \        long result = res.stream().mapToLong(Long::longValue).max().orElse(-1);\n\
    \        return result;", "        ArrayList<Long> longs = new ArrayList<>();\n\
    \        for(Long x : lst) {\n            if(longs.contains(x)) {\n          \
    \      longs.set(longs.indexOf(x), x + 1);\n            } else {\n           \
    \     longs.add(x);\n            }\n        }\n        long max = Long.MIN_VALUE;\n\
    \        for(int i = 0; i <= longs.size(); i++) {\n            for(int j = i+1;\
    \ j <= longs.size(); j++) {\n                if((longs.get(i) + longs.get(j))\
    \ > max) {\n                    max = longs.get(i) + longs.get(j);\n         \
    \       }\n            }\n        }\n        return max;", "        if (lst.isEmpty())\
    \ {\n            return -1l;\n        }\n\n        Map<Long, Long> freq = new\
    \ HashMap<>();\n        for (Long i : lst) {\n            freq.putIfAbsent(i,\
    \ 0L);\n            freq.put(i, freq.get() + 1);\n        }\n        Long maxKey\
    \ = freq.keySet().stream().max(Long::compare).get();\n        Long maxFreq = freq.keySet().stream().filter(k\
    \ -> k.equals(maxKey)).count();\n        Long max = freq.keySet().stream().filter(k\
    \ -> k.equals(maxKey)).max(Long::compare).get();\n        if (maxFreq >= max)\
    \ {\n            return maxKey;\n        }\n        return -1l;", "        if(lst.size()\
    \ > 0) {\n            ArrayList<Long> lstCopy = new ArrayList<>(lst);\n      \
    \      Arrays.sort(lstCopy);\n            return search(lstCopy);\n        }\n\
    \        return -1;", "        Set<Long> set = new HashSet<>(lst);\n        int\
    \ idx = Collections.binarySearch(set, (long)0);\n        if (idx>=0) return lst.get(idx);\n\
    \        if (idx<0) idx = -idx-1;\n        long max = lst.get(idx);\n        for\
    \ (int i=idx+1; i<lst.size(); ++i) {\n            long val = lst.get(i);\n   \
    \         if (set.remove(val)) {\n                set.add((long)val);\n      \
    \          max = Math.max(val, max);\n            }\n        }\n        return\
    \ max;", "        boolean isFound = false;\n        int maxValue = -1;\n     \
    \   long maxFreq = -1;\n\n        for (long value: lst) {\n            long count\
    \ = lst.stream().filter(v -> v == value).count();\n\n            if (count > maxFreq)\
    \ {\n                maxFreq = count;\n                maxValue = value;\n   \
    \         }\n\n            if (count >= value) {\n                isFound = true;\n\
    \            }\n\n        }\n\n        if (!isFound) return -1;\n\n        return\
    \ maxValue;", "        Set<Long> set = new HashSet<>();\n        for (Long value\
    \ : lst) {\n            if (!set.add(value)) {\n                return -1;\n \
    \           }\n        }\n        Long max = lst.stream().max(Long::compare).get();\n\
    \        for (Long value : lst) {\n            if (value > max) {\n          \
    \      return -1;\n            }\n            if (lst.stream().filter(x -> x ==\
    \ value).count() < set.size()) {\n                return -1;\n            }\n\
    \        }\n        return max;", "        if (lst.isEmpty()) {\n            return\
    \ -1;\n        }\n        long maxVal = lst.get(0);\n        long maxCount = 0;\n\
    \        for (Long val : lst) {\n            if (maxCount >= maxVal) {\n     \
    \           return -1;\n            }\n            if (maxVal != val && maxCount\
    \ >= val) {\n                return -1;\n            }\n            maxCount =\
    \ maxCount + val;\n            maxVal = maxVal;\n        }\n        return maxVal;",
  "        // write your code here\n        if(lst.size()==0) return -1;\n       \
    \ Arrays.sort(lst);\n        \n        long max_element=0;\n        long max_element_count=1L;\n\
    \        \n        for(int i=0;i<lst.size();i++)\n        {\n            if(lst.get(i)!=lst.get(i-1))\n\
    \            {\n                if(max_element_count>lst.get(i))\n           \
    \     {\n                    max_element=lst.get(i);\n                    max_element_count=lst.get(i);\n\
    \                }\n            }\n        }\n        return max_element;", " \
    \       int freq = 0;\n        int i = 0;\n        long maxVal = -1;\n\n     \
    \   if (lst == null) {\n            return -1;\n        }\n\n        for (i =\
    \ 0; i <= lst.size(); i++) {\n            if (lst.get(i) > 0) {\n            \
    \    freq += (long)lst.get(i);\n            }\n        }\n        for (i = freq;\
    \ i >= 0; i--) {\n            if (lst.get(i) > 0) {\n                maxVal =\
    \ lst.get(i);\n                break;\n            }\n        }\n        return\
    \ maxVal;", "        LongStream.range(lst.get(0), lst.get(lst.size())).filter((i)->{\n\
    \            return ((lst.indexOf(i) > lst.indexOf(i-1))&&(lst.get(i)/lst.get(i-1)\
    \ >= i));\n        }).findAny().orElse(-1l);", "        ArrayList<Long> unique\
    \ = new ArrayList<>();\n        unique.addAll(lst);\n\n        Collections.sort(unique);\n\
    \n        long maxVal = unique.get(0);\n\n        for (long x : unique) {\n  \
    \          if (x > maxVal) {\n                maxVal = x;\n            }\n   \
    \     }\n\n        long freq = unique.size();\n\n        for (int i = 0; i < unique.size();\
    \ i++) {\n            if (freq < unique.get(i)) {\n                return -1;\n\
    \            }\n        }\n\n        return maxVal;", "        long max_freq =\
    \ -1;\n        long max_num = 0;\n        for (long num : lst) {\n           \
    \ long freq = Collections.frequency(lst, num);\n            if (freq >= max_freq\
    \ && freq >= num) {\n                max_freq = freq;\n                max_num\
    \ = num;\n            }\n        }\n        if (max_freq < -1) {\n           \
    \ return -1;\n        }\n        return max_num;"]
stop_tokens:
- "\n    }\n"
