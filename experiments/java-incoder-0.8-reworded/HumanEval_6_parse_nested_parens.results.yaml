language: java
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_levels = new ArrayList<Long>();\n\
    \        ArrayList<String> input = new ArrayList<String>();\n        ArrayList<String>\
    \ output = new ArrayList<String>();\n\n        paren_string = paren_string.trim();\n\
    \        int pos = paren_string.indexOf(\"(\");\n        while (pos != -1) {\n\
    \            String word = paren_string.substring(0, pos);\n            input.addAll(Arrays.asList(word));\n\
    \            paren_string = paren_string.substring(pos + 1).trim();\n        \
    \    pos = paren_string.indexOf(\"(\");\n        }\n\n        input.add(paren_string);\n\
    \        List<String> list = new ArrayList<String>(input);\n        list.stream().filter(n\
    \ -> !n.isEmpty()).forEach(x -> {\n            output.add(x + \"\");\n       \
    \     if (x.equals(\"(\")) {\n                parseNestedParens(x + \", \" + output);\n\
    \            }\n        });\n\n        max_levels.add(new ArrayList<Long>(Arrays.asList(input.size(),\
    \ output.size())));\n        for (int i = 0; i < output.size(); i++) {\n     \
    \       Long max_value = max_levels.get(i).get(0).get(0);\n            Long value\
    \ = 0;\n            for (int j = 0; j < output.size(); j++) {\n              \
    \  Long new_value = max_levels.get(j).get(i).get(0);\n                if (max_value\
    \ < new_value) {\n                    max_value = new_value;\n               \
    \     value = j;\n                }\n            }\n            max_levels.get(value).set(i,\
    \ new ArrayList<Long>(Arrays.asList(output.size())));\n        }\n        return\
    \ max_levels;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr507ghi1.java:37: error: no suitable constructor found for ArrayList(List<Integer>)\n\
    \        max_levels.add(new ArrayList<Long>(Arrays.asList(input.size(), output.size())));\n\
    \                       ^\n    constructor ArrayList.ArrayList(int) is not applicable\n\
    \      (argument mismatch; no instance(s) of type variable(s) T exist so that\
    \ List<T> conforms to int)\n    constructor ArrayList.ArrayList(Collection<? extends\
    \ Long>) is not applicable\n      (argument mismatch; inference variable T has\
    \ incompatible bounds\n          lower bounds: Long,Object\n          lower bounds:\
    \ Integer)\n  where T is a type-variable:\n    T extends Object declared in method\
    \ <T>asList(T...)\n/tmp/tmpr507ghi1.java:39: error: cannot find symbol\n     \
    \       Long max_value = max_levels.get(i).get(0).get(0);\n                  \
    \                            ^\n  symbol:   method get(int)\n  location: class\
    \ Long\n/tmp/tmpr507ghi1.java:40: error: incompatible types: int cannot be converted\
    \ to Long\n            Long value = 0;\n                         ^\n/tmp/tmpr507ghi1.java:42:\
    \ error: cannot find symbol\n                Long new_value = max_levels.get(j).get(i).get(0);\n\
    \                                                  ^\n  symbol:   method get(int)\n\
    \  location: class Long\n/tmp/tmpr507ghi1.java:45: error: incompatible types:\
    \ int cannot be converted to Long\n                    value = j;\n          \
    \                  ^\n/tmp/tmpr507ghi1.java:48: error: no suitable constructor\
    \ found for ArrayList(List<Integer>)\n            max_levels.get(value).set(i,\
    \ new ArrayList<Long>(Arrays.asList(output.size())));\n                      \
    \                   ^\n    constructor ArrayList.ArrayList(int) is not applicable\n\
    \      (argument mismatch; no instance(s) of type variable(s) T exist so that\
    \ List<T> conforms to int)\n    constructor ArrayList.ArrayList(Collection<? extends\
    \ Long>) is not applicable\n      (argument mismatch; inference variable T has\
    \ incompatible bounds\n          lower bounds: Long,Object\n          lower bounds:\
    \ Integer)\n  where T is a type-variable:\n    T extend"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> tokens = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> results = new ArrayList<>();\n        List<String>\
    \ parens = new ArrayList<>();\n        parens.add(paren_string);\n        parens.forEach(\n\
    \            s -> {\n                String s_lower = s.toLowerCase();\n     \
    \           Matcher matcher = Pattern.compile(\"\\\\(|\\\\)\").matcher(s_lower);\n\
    \                StringBuffer sb = new StringBuffer();\n                while\
    \ (matcher.find()) {\n                    matcher.appendReplacement(sb, \"\");\n\
    \                    matcher.appendTail(sb);\n                }\n            \
    \    if (s_lower.contains(\")\")) {\n                    String result = sb.toString();\n\
    \                    Matcher matcher = Pattern.compile(\"\\\\(|\\\\)\").matcher(result);\n\
    \                    while (matcher.find()) {\n                        matcher.appendReplacement(sb,\
    \ \"\");\n                        matcher.appendTail(sb);\n                  \
    \  }\n                    results.add(Long.parseLong(sb.toString()));\n      \
    \          }\n            }\n        );\n        return results.isEmpty() ? null\
    \ : results;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppuu8mri0.java:22: error: cannot find symbol\n                Matcher\
    \ matcher = Pattern.compile(\"\\\\(|\\\\)\").matcher(s_lower);\n             \
    \   ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmppuu8mri0.java:22:\
    \ error: cannot find symbol\n                Matcher matcher = Pattern.compile(\"\
    \\\\(|\\\\)\").matcher(s_lower);\n                                  ^\n  symbol:\
    \   variable Pattern\n  location: class Problem\n/tmp/tmppuu8mri0.java:30: error:\
    \ cannot find symbol\n                    Matcher matcher = Pattern.compile(\"\
    \\\\(|\\\\)\").matcher(result);\n                    ^\n  symbol:   class Matcher\n\
    \  location: class Problem\n/tmp/tmppuu8mri0.java:30: error: cannot find symbol\n\
    \                    Matcher matcher = Pattern.compile(\"\\\\(|\\\\)\").matcher(result);\n\
    \                                      ^\n  symbol:   variable Pattern\n  location:\
    \ class Problem\n4 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   paren_string = paren_string.replaceAll(\"\\\\(|\\\\)\", \"\");\n        String[]\
    \ parens = paren_string.split(\"\\\\s+\");\n        for(int i = 0; i < parens.length;\
    \ i++) {\n            result.add(new Long(parens.length - i));\n        }\n  \
    \      return result;\n    }\n    public static void main(String[] args) {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpi3_dqqf4.java:24)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       Matcher m = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(paren_string);\n\
    \        while (m.find()) {\n            Matcher mm = Pattern.compile(\"\\\\((.*?)\\\
    \\)\").matcher(m.group());\n            while (mm.find()) {\n                result.add(Long.parseLong(mm.group().replace(\"\
    )\", \"\")));\n            }\n        }\n        return result;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqtuzc8xz.java:16: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(paren_string);\n        ^\n \
    \ symbol:   class Matcher\n  location: class Problem\n/tmp/tmpqtuzc8xz.java:16:\
    \ error: cannot find symbol\n        Matcher m = Pattern.compile(\"\\\\((.*?)\\\
    \\)\").matcher(paren_string);\n                    ^\n  symbol:   variable Pattern\n\
    \  location: class Problem\n/tmp/tmpqtuzc8xz.java:18: error: cannot find symbol\n\
    \            Matcher mm = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(m.group());\n\
    \            ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpqtuzc8xz.java:18:\
    \ error: cannot find symbol\n            Matcher mm = Pattern.compile(\"\\\\((.*?)\\\
    \\)\").matcher(m.group());\n                         ^\n  symbol:   variable Pattern\n\
    \  location: class Problem\n4 errors\n"
  stdout: ''
  timestamp: 1660011437
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // TODO\n        return null;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke\
    \ \"java.util.ArrayList.equals(Object)\" because the return value of \"Problem.parseNestedParens(String)\"\
    \ is null\n\tat Problem.main(tmpnw8hnj49.java:19)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_levels_of_nesting = new ArrayList<Long>();\n\
    \        ArrayList<Long> current_levels_of_nesting = new ArrayList<Long>();\n\
    \        Long levels_of_nesting_at_current_level;\n        for (String level_of_nesting\
    \ : paren_string.split(\" \")) {\n            levels_of_nesting_at_current_level\
    \ = parseNestedParens(level_of_nesting);\n            current_levels_of_nesting.add(levels_of_nesting_at_current_level);\n\
    \            max_levels_of_nesting.add(Math.max(levels_of_nesting_at_current_level,\
    \ max_levels_of_nesting.get(max_levels_of_nesting.size() - 1)));\n        }\n\
    \        return max_levels_of_nesting;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf6_0yk9l.java:19: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n            levels_of_nesting_at_current_level = parseNestedParens(level_of_nesting);\n\
    \                                                                  ^\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> results = new ArrayList<>();\n    \
    \    Stack<String> stack = new Stack<>();\n        for (String nested: paren_string.split(\"\
    \\\\s+\")) {\n            if (!nested.equals(\"(\")) {\n                stack.push(nested);\n\
    \            } else {\n                while (!stack.empty()) {\n            \
    \        if (nested.equals(stack.pop())) {\n                        results.add(results.size()\
    \ - 1);\n                    }\n                }\n            }\n        }\n\
    \        Collections.reverse(results);\n        return results;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe8htt3tb.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n                        results.add(results.size() - 1);\n        \
    \                                           ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, 0);\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3pxs5oew.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ 0);\n               ^\n  required: String\n  found:    String,int\n  reason:\
    \ actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // The algorithm is as follows:\n        // 1. Go through\
    \ each character of the input.\n        // 2. If the character is '(' or '[' or\
    \ '{', then output '(' to the output.\n        //    Otherwise, if ')' is encountered,\
    \ then output the string and reset the\n        //    output string.\n       \
    \ // 3. Otherwise, if the character is ')', then output the string and set the\n\
    \        //    output string to empty.\n        // 4. If the character is ')',\
    \ then the output string has been output to the\n        //    output string,\
    \ so output an empty string.\n        // 5. Otherwise, if the character is '}',\
    \ then output the string and reset the\n        //    output string.\n       \
    \ // 6. Otherwise, if the character is ']', then output the string and set the\n\
    \        //    output string to empty.\n        // 7. Otherwise, if the character\
    \ is ']', then the output string has been output\n        //    to the output\
    \ string, so output an empty string.\n        // 8. Otherwise, the character is\
    \ unrecognized. The input was unrecognized. If the\n        //    input is empty,\
    \ return null.\n\n        // Initialize the output string with the empty string\n\
    \        String output = \"\";\n\n        // Iterate through the input string\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            // Keep\
    \ track of the current character\n            char character = paren_string.charAt(i);\n\
    \n            // If the current character is one of '(', '[', '{', then output\
    \ '(' to the output\n            if (character == '(' || character == '[' || character\
    \ == '{') {\n                output = output + \"(\" + character;\n          \
    \  }\n            // Otherwise\n            else if (character == ')') {\n   \
    \             // Output the output string to the output string and reset it\n\
    \                output = output + output;\n                output = \"\";\n \
    \           }\n            // Otherwise\n            else if (character == '}')\
    \ {\n                // Output the output string to the output string and reset\
    \ it\n                output = output + output;\n                output = \"\"\
    ;\n            }\n            // Otherwise\n            else if (character ==\
    \ ']') {\n                // Output the output string to the output string and\
    \ reset it\n                output = output + output;\n                output\
    \ = \"\";\n            }\n            // Otherwise\n            else {\n     \
    \           // The input string was unrecognized\n                return null;\n\
    \            }\n        }\n\n        // If the input string was empty, then output\
    \ null\n        return output;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbtntpus0.java:71: error: incompatible types: String cannot be converted\
    \ to ArrayList<Long>\n        return output;\n               ^\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_levels = new ArrayList<>();\n\
    \        Arrays.stream(paren_string.split(\" \"))\n              .map(s -> {\n\
    \                  List<String> stack = new ArrayList<>();\n                 \
    \ for (char c : s.toCharArray()) {\n                      stack.push(c);\n   \
    \               }\n                  return stack;\n              })\n       \
    \       .flatMap(Arrays::stream)\n              .distinct()\n              .sorted()\n\
    \              .forEachOrdered(s -> {\n                  // push all stacks into\
    \ a HashSet\n                  HashSet<Long> stack_set = new HashSet<>();\n  \
    \                for (char c : s.toCharArray()) {\n                      stack_set.add(Long.valueOf(c));\n\
    \                  }\n\n                  // pop out stacks one by one\n     \
    \             while (!stack_set.equals(stack_set)) {\n                      Long\
    \ stack = stack_set.iterator().next();\n                      stack_set.remove(stack);\n\
    \                      stack_set.add(stack - 1);\n                  }\n\n    \
    \              // get the deepest stack from HashSet\n                  deepest_levels.add(stack_set.size());\n\
    \              });\n        return deepest_levels;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi0esjvwz.java:20: error: cannot find symbol\n                 \
    \     stack.push(c);\n                           ^\n  symbol:   method push(char)\n\
    \  location: variable stack of type List<String>\n/tmp/tmpi0esjvwz.java:24: error:\
    \ incompatible types: cannot infer type-variable(s) R\n              .flatMap(Arrays::stream)\n\
    \                      ^\n    (argument mismatch; invalid method reference\n \
    \     no suitable method found for stream(List<String>)\n          method Arrays.<T#2>stream(T#2[])\
    \ is not applicable\n            (cannot infer type-variable(s) T#2\n        \
    \      (argument mismatch; List<String> cannot be converted to T#2[]))\n     \
    \     method Arrays.<T#3>stream(T#3[],int,int) is not applicable\n           \
    \ (cannot infer type-variable(s) T#3\n              (actual and formal argument\
    \ lists differ in length))\n          method Arrays.stream(int[]) is not applicable\n\
    \            (argument mismatch; List<String> cannot be converted to int[])\n\
    \          method Arrays.stream(long[]) is not applicable\n            (argument\
    \ mismatch; List<String> cannot be converted to long[])\n          method Arrays.stream(double[])\
    \ is not applicable\n            (argument mismatch; List<String> cannot be converted\
    \ to double[]))\n  where R,T#1,T#2,T#3 are type-variables:\n    R extends Object\
    \ declared in method <R>flatMap(Function<? super T#1,? extends Stream<? extends\
    \ R>>)\n    T#1 extends Object declared in interface Stream\n    T#2 extends Object\
    \ declared in method <T#2>stream(T#2[])\n    T#3 extends Object declared in method\
    \ <T#3>stream(T#3[],int,int)\n/tmp/tmpi0esjvwz.java:42: error: incompatible types:\
    \ int cannot be converted to Long\n                  deepest_levels.add(stack_set.size());\n\
    \                                                   ^\nNote: Some messages have\
    \ been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_depths = new ArrayList<>();\n\
    \        ArrayList<Long> depths = new ArrayList<>();\n        boolean found_close_paren_paren\
    \ = false;\n        int open_paren = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                if\
    \ (depths.get(open_paren + 1) != -1)\n                    throw new RuntimeException(\"\
    unbalanced parenthesis at index \" + i);\n                depths.add(open_paren\
    \ + 1);\n            }\n            if (paren_string.charAt(i) == ')') {\n   \
    \             if (depths.get(open_paren) != -1)\n                    throw new\
    \ RuntimeException(\"unbalanced parenthesis at index \" + i);\n              \
    \  if (depths.size() != open_paren + 1)\n                    throw new RuntimeException(\"\
    invalid parenthesis at index \" + i);\n                depths.remove(depths.size()\
    \ - 1);\n            }\n            if (paren_string.charAt(i) == '(') {\n   \
    \             open_paren++;\n            }\n            if (paren_string.charAt(i)\
    \ == ')') {\n                open_paren--;\n                found_close_paren_paren\
    \ = true;\n            }\n        }\n        if (depths.size() != 0 || found_close_paren_paren)\n\
    \            throw new RuntimeException(\"invalid parenthesis at index \" + paren_string.length());\n\
    \        // If depths.size() == 0, then there were no matching close parenthesis.\
    \ We simply return empty.\n        if (depths.size() == 0)\n            return\
    \ new ArrayList<Long>();\n        // We have matching close parenthesis at index\
    \ 0 and at least one matching open parenthesis at index\n        // depths.size()\
    \ - 1. We have to return the deepest depth of nesting starting from open parenthesis.\n\
    \        long max_depth = 0;\n        for (int i = 0; i < depths.size(); i++)\
    \ {\n            if (depths.get(i) > max_depth)\n                max_depth = depths.get(i);\n\
    \        }\n        for (int i = 0; i < depths.size(); i++) {\n            if\
    \ (depths.get(i) == max_depth) {\n                nested_depths.add(max_depth);\n\
    \            }\n        }\n        return nested_depths;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpude59zxx.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n                depths.add(open_paren + 1);\n                     \
    \                 ^\nNote: Some messages have been simplified; recompile with\
    \ -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011437
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.isEmpty())\n            return new\
    \ ArrayList<Long>();\n\n        ArrayList<Long> nesting = new ArrayList<Long>();\n\
    \        ArrayList<String> groups = new ArrayList<String>();\n        ArrayList<String>\
    \ group_strings = new ArrayList<String>();\n\n        boolean inside_group = false;\n\
    \        boolean in_group = false;\n        StringBuilder sb = new StringBuilder();\n\
    \n        for (int i = 0; i < paren_string.length(); i++) {\n            char\
    \ c = paren_string.charAt(i);\n\n            if (c == ')') {\n               \
    \ nesting.add(Long.parseLong(sb.toString()));\n                sb.setLength(0);\n\
    \                group_strings.add(sb.toString());\n                groups.add(sb.toString());\n\
    \                inside_group = false;\n                in_group = false;\n  \
    \          } else if (c == '(') {\n                if (sb.length() > 0) {\n  \
    \                  group_strings.add(sb.toString());\n                    groups.add(sb.toString());\n\
    \                }\n                sb.setLength(0);\n                inside_group\
    \ = true;\n                in_group = false;\n            } else if (c == ' ')\
    \ {\n                if (sb.length() > 0) {\n                    group_strings.add(sb.toString());\n\
    \                    groups.add(sb.toString());\n                }\n         \
    \       sb.setLength(0);\n            } else {\n                if (inside_group)\
    \ {\n                    sb.append(c);\n                } else {\n           \
    \         in_group = true;\n                    sb.append(c);\n              \
    \  }\n            }\n        }\n\n        if (sb.length() > 0) {\n           \
    \ group_strings.add(sb.toString());\n            groups.add(sb.toString());\n\
    \        }\n\n        for (String g : group_strings) {\n            ArrayList<Long>\
    \ group_nesting = parseNestedParens(g);\n            for (long l : group_nesting)\
    \ {\n                nesting.add(l);\n            }\n        }\n\n        return\
    \ nesting;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NumberFormatException: For input\
    \ string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat Problem.parseNestedParens(tmpahaufppi.java:30)\n\tat Problem.main(tmpahaufppi.java:75)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_level_list = new ArrayList<Long>();\n\
    \        ArrayList<ArrayList<Long>> level_list = new ArrayList<ArrayList<Long>>();\n\
    \n        // Initialize the level_list\n        ArrayList<Long> level = new ArrayList<Long>();\n\
    \        level.add(0l);\n        level_list.add(level);\n\n        // Start parsing\
    \ from first character and push back the level\n        int index = 0;\n     \
    \   while(index < paren_string.length()) {\n            if(paren_string.charAt(index)\
    \ == '(') {\n                level.add(0l);\n                level_list.add(level);\n\
    \                level = new ArrayList<Long>();\n                index++;\n  \
    \              continue;\n            }\n            int end_level = level.get(level.size()\
    \ - 1);\n            int new_level = end_level + 1;\n            level.set(new_level,\
    \ level.get(level.size() - 1) + 1);\n            while(level.size() > 1 && paren_string.charAt(index)\
    \ == ')') {\n                index++;\n                end_level = level.get(level.size()\
    \ - 1);\n                new_level = end_level + 1;\n                level.set(new_level,\
    \ level.get(level.size() - 1) + 1);\n            }\n            index++;\n   \
    \     }\n        // Return the deepest level\n        return max_level_list;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp15nd49bw.java:33: error: incompatible types: Long cannot be converted\
    \ to int\n            int end_level = level.get(level.size() - 1);\n         \
    \                            ^\n/tmp/tmp15nd49bw.java:38: error: incompatible\
    \ types: Long cannot be converted to int\n                end_level = level.get(level.size()\
    \ - 1);\n                                     ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        int paren_level = 0;\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        paren_string = paren_string.replaceAll(\"\\\
    \\(|\\\\)\", \"\");\n        for(int i=0; i < paren_string.length(); i++) {\n\
    \            if(paren_string.charAt(i) == '(') {\n                result.add(new\
    \ Long(paren_level));\n                paren_level++;\n            }\n       \
    \     else if(paren_string.charAt(i) == ')') {\n                result.add(new\
    \ Long(paren_level));\n                paren_level--;\n            }\n       \
    \ }\n        for(int i=0; i < paren_level; i++) {\n            result.add(new\
    \ Long(paren_level));\n        }\n        Collections.sort(result);\n        return\
    \ result;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprrpqdf2w.java:35)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String []tokens = paren_string.split(\" \");\n    \
    \    ArrayList<Long> deepest_level = new ArrayList<Long>();\n        for(String\
    \ token:tokens){\n            try{\n                deepest_level.add(new Long(Integer.parseInt(token)));\n\
    \            }catch(NumberFormatException ex){\n                deepest_level.add(new\
    \ Long(0));\n            }\n        }\n        Arrays.sort(deepest_level);\n \
    \       return deepest_level;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp16_otz8e.java:19: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                deepest_level.add(new Long(Integer.parseInt(token)));\n\
    \                                  ^\n/tmp/tmp16_otz8e.java:21: warning: [removal]\
    \ Long(long) in Long has been deprecated and marked for removal\n            \
    \    deepest_level.add(new Long(0));\n                                  ^\n/tmp/tmp16_otz8e.java:24:\
    \ error: no suitable method found for sort(ArrayList<Long>)\n        Arrays.sort(deepest_level);\n\
    \              ^\n    method Arrays.sort(int[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to int[])\n    method Arrays.sort(long[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to long[])\n    method Arrays.sort(short[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to short[])\n    method Arrays.sort(char[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to char[])\n    method Arrays.sort(byte[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to byte[])\n    method Arrays.sort(float[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to float[])\n    method Arrays.sort(double[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to double[])\n    method Arrays.sort(Object[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<? super T#1>) is\
    \ not applicable\n      (cannot infer type-variable(s) T#1\n        (actual and\
    \ formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in me"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.isEmpty()) {\n            return new\
    \ ArrayList<Long>(Arrays.asList(0l));\n        }\n\n        ArrayList<Long> nesting_levels\
    \ = new ArrayList<Long>(Arrays.asList(0l));\n        Stack<String> stack = new\
    \ Stack<>();\n        stack.add(paren_string);\n\n        while (stack.size()\
    \ > 0) {\n            String current_group = stack.pop();\n            if (current_group.equals(paren_string))\
    \ {\n                nesting_levels.add(0l);\n            } else {\n         \
    \       Matcher matcher = Pattern.compile(\"\\\\(([^()]+)|([^()]+\\\\([^()]*\\\
    \\))*\\\\)\").matcher(current_group);\n                matcher.find();\n     \
    \           String opening = matcher.group(1);\n                String closing\
    \ = matcher.group(2);\n                String next_group = matcher.group(3);\n\
    \                if (opening == null) {\n                    // No opening parenthesis\
    \ found on the group\n                    Matcher matcher_closing = Pattern.compile(\"\
    \\\\(([^()]+)|([^()]+\\\\([^()]*\\\\))*\\\\)\").matcher(closing);\n          \
    \          matcher_closing.find();\n                    String opening_closing\
    \ = matcher_closing.group(1);\n                    if (opening_closing == null)\
    \ {\n                        nesting_levels.add(0l);\n                    } else\
    \ {\n                        Matcher matcher_next_group = Pattern.compile(\"\\\
    \\(([^()]+)|([^()]+\\\\([^()]*\\\\))*\\\\)\").matcher(next_group);\n         \
    \               matcher_next_group.find();\n                        String opening_next_group\
    \ = matcher_next_group.group(1);\n                        if (opening_next_group\
    \ == null) {\n                            nesting_levels.add(0l);\n          \
    \              } else {\n                            Matcher matcher_opening_closing\
    \ = Pattern.compile(\"\\\\(([^()]+)|([^()]+\\\\([^()]*\\\\))*\\\\)\").matcher(opening_closing);\n\
    \                            matcher_opening_closing.find();\n               \
    \             String opening_closing_closing = matcher_opening_closing.group(1);\n\
    \                            if (opening_closing_closing == null) {\n        \
    \                        nesting_levels.add(0l);\n                           \
    \ } else {\n                                Matcher matcher_opening_next_group\
    \ = Pattern.compile(\"\\\\(([^()]+)|([^()]+\\\\([^()]*\\\\))*\\\\)\").matcher(opening_next_group);\n\
    \                                matcher_opening_next_group.find();\n        \
    \                        String opening_next_group_closing = matcher_opening_next_group.group(1);\n\
    \                                if (opening_next_group_closing == null) {\n \
    \                                   nesting_levels.add(0l);\n                \
    \                } else {\n                                    Matcher matcher_opening_opening_closing\
    \ = Pattern.compile(\"\\\\(([^()\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0shubotk.java:59: error: unclosed string literal\n            \
    \                        Matcher matcher_opening_opening_closing = Pattern.compile(\"\
    \\\\(([^()\n                                                                 \
    \                             ^\n/tmp/tmp0shubotk.java:61: error: illegal start\
    \ of expression\n    public static void main(String[] args) {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011437
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parens = new ArrayList<>();\n     \
    \   parens.add(0l);\n        if (paren_string == null || paren_string.isEmpty())\
    \ {\n            return parens;\n        }\n        char[] paren_characters =\
    \ paren_string.toCharArray();\n        int i = 0;\n        int paren_length =\
    \ paren_characters.length;\n        for (; i < paren_length; i++) {\n        \
    \    if (paren_characters[i] == '(') {\n                int opening_paren_index\
    \ = i;\n                for (; i < paren_length; i++) {\n                    if\
    \ (paren_characters[i] == ')') {\n                        break;\n           \
    \         }\n                    if (paren_characters[i] == ' ') {\n         \
    \               parens.add(parens.get(opening_paren_index));\n               \
    \         opening_paren_index = i;\n                    }\n                }\n\
    \            }\n        }\n        return parens;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgfdgjv6u.java:40)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Initialize two variables\n        ArrayList<Long>\
    \ results = new ArrayList<>();\n        boolean paren_open = false;\n        boolean\
    \ in_paren = false;\n        ArrayList<Long> opening_count = new ArrayList<>();\n\
    \        ArrayList<Long> closing_count = new ArrayList<>();\n        long temp\
    \ = 0;\n\n        // Add first level of opening parens\n        while (paren_string.charAt(0)\
    \ == '(') {\n            temp++;\n            opening_count.add(temp);\n     \
    \       paren_open = true;\n        }\n        opening_count.add(0, 0);\n\n  \
    \      // Keep traversing until there is no more opening\n        while (paren_string.charAt(0)\
    \ != ')') {\n            if (paren_open) {\n                if (paren_string.charAt(0)\
    \ == ')') {\n                    // If we are now closing a paren\n          \
    \          closing_count.add(temp);\n                    results.add(temp);\n\
    \                    paren_open = false;\n                } else {\n         \
    \           // If we are now opening another paren\n                    opening_count.add(temp);\n\
    \                    in_paren = true;\n                }\n            } else {\n\
    \                // If we are not in a paren\n                if (paren_string.charAt(0)\
    \ == '(') {\n                    temp++;\n                    opening_count.add(temp);\n\
    \                    paren_open = true;\n                    in_paren = true;\n\
    \                }\n            }\n            paren_string = paren_string.substring(1);\n\
    \        }\n\n        // If we are still in parens\n        if (in_paren) {\n\
    \            // Add the closing paren\n            closing_count.add(temp);\n\
    \            results.add(temp);\n        }\n\n        // Add the remaining closing\
    \ parens to the end of our result\n        results.addAll(closing_count);\n  \
    \      return results;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyk0hnx4w.java:29: error: incompatible types: int cannot be converted\
    \ to Long\n        opening_count.add(0, 0);\n                             ^\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n1 error\n"
  stdout: ''
  timestamp: 1660011437
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_list = new ArrayList<>();\n \
    \       int i = 0, j = paren_string.length() - 1, count = 0;\n        boolean\
    \ open = true;\n        while (i < j) {\n            if (paren_string.charAt(i)\
    \ == ')') {\n                if (open) {\n                    paren_list.add(count);\n\
    \                    count = 0;\n                }\n                open = !open;\n\
    \            } else if (paren_string.charAt(i) == '(') {\n                count++;\n\
    \            }\n            i++;\n        }\n        paren_list.add(count);\n\
    \        return paren_list;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy4mbhu8r.java:21: error: incompatible types: int cannot be converted\
    \ to Long\n                    paren_list.add(count);\n                      \
    \             ^\n/tmp/tmpy4mbhu8r.java:30: error: incompatible types: int cannot\
    \ be converted to Long\n        paren_list.add(count);\n                     \
    \  ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> groups = Arrays.asList(paren_string.split(\"\
    \ \"));\n        Stack<String> s = new Stack<>();\n        \n        for(String\
    \ group: groups){\n            if(group.equals(\"(\")) s.push(\"(\");\n      \
    \      else if(group.equals(\")\")) s.pop();\n            else if(!s.isEmpty()\
    \ && s.peek().equals(\"(\")) s.push(\")\");\n            else s.push(group);\n\
    \        }\n        ArrayList<Long> maxDepth = new ArrayList<Long>(Arrays.asList(2l));\n\
    \        while(!s.isEmpty()){\n            if(s.peek().equals(\"(\")) s.pop();\n\
    \            String next_group = s.peek();\n            if(next_group.equals(\"\
    (\")) s.push(\"(\");\n            else if(!maxDepth.get(maxDepth.size()-1).longValue()+1\
    \ < Long.parseLong(next_group))\n                maxDepth.add(new ArrayList<Long>(Arrays.asList(Long.parseLong(next_group))));\n\
    \            else s.pop();\n        }\n        return maxDepth;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnmvg6rvt.java:29: error: bad operand type long for unary operator\
    \ '!'\n            else if(!maxDepth.get(maxDepth.size()-1).longValue()+1 < Long.parseLong(next_group))\n\
    \                    ^\n/tmp/tmpnmvg6rvt.java:30: error: incompatible types: ArrayList<Long>\
    \ cannot be converted to Long\n                maxDepth.add(new ArrayList<Long>(Arrays.asList(Long.parseLong(next_group))));\n\
    \                             ^\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_levels = new ArrayList<Long>();\n\
    \        Stack<Integer> stack = new Stack<Integer>();\n        \n        Set<String>\
    \ paren_string_set = new HashSet<String>();\n        \n        paren_string =\
    \ paren_string.trim();\n        paren_string_set.addAll(Arrays.asList(paren_string.split(\"\
    \ \")));\n        \n        for(String s : paren_string_set) {\n            if(s.matches(\"\
    \\\\([\\\\(\\\\)\\\\[\\\\]]*\\\\)\")) {\n                String curr_parenthesis\
    \ = s;\n                \n                while(!stack.empty()) {\n          \
    \          int curr_level = stack.pop();\n                    \n             \
    \       if(paren_string.contains(curr_parenthesis)) {\n                      \
    \  if(curr_level >= max_levels.size()) {\n                            max_levels.add(curr_level);\n\
    \                        } else if(curr_level < max_levels.size()) {\n       \
    \                     max_levels.set(curr_level, (max_levels.get(curr_level) +\
    \ 1));\n                        }\n                        break;\n          \
    \          }\n                    \n                    if(curr_level > 0) {\n\
    \                        stack.add(curr_level - 1);\n                        break;\n\
    \                    }\n                    \n                    if(curr_level\
    \ == 0) {\n                        stack.push(-1);\n                        break;\n\
    \                    }\n                    \n                    curr_parenthesis\
    \ = paren_string.substring(curr_parenthesis.length() - 1);\n                 \
    \   \n                    if(curr_parenthesis.length() == 0) {\n             \
    \           stack.push(-1);\n                        break;\n                \
    \    }\n                }\n            }\n        }\n        \n        ArrayList\
    \ res = new ArrayList();\n        \n        for(Long l : max_levels) {\n     \
    \       res.add(l);\n        }\n        \n        return res;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3mi6by5a.java:32: error: incompatible types: int cannot be converted\
    \ to Long\n                            max_levels.add(curr_level);\n         \
    \                                  ^\nNote: /tmp/tmp3mi6by5a.java uses unchecked\
    \ or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n1 error\n"
  stdout: ''
  timestamp: 1660011437
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        long max_level = 0;\n        // For each group we check\
    \ the current level of nesting and add it to a list.\n        // If the group\
    \ has maximum level then we add it to our list as well.\n        // Otherwise\
    \ we check if the current level of nesting is less than the maximum level.\n \
    \       for (String group : paren_string.split(\"\\\\ \")) {\n            ArrayList<Long>\
    \ levels = new ArrayList<>();\n            long level = 0;\n            // For\
    \ each of the group in the string we add them to a list until the deepest level\
    \ of nesting \n            // is reached.\n            for (String group_string\
    \ : group.split(\"\\\\(\")) {\n                boolean flag = true;\n        \
    \        for (String group_string2 : group_string.split(\"\\\\)\")) {\n      \
    \              if (group_string2.trim().isEmpty()) {\n                       \
    \ continue;\n                    }\n                    if (group_string2.contains(\"\
    (\")) {\n                        level = level + 1;\n                    }\n \
    \                   if (group_string2.contains(\")\")) {\n                   \
    \     level = level - 1;\n                    }\n                    levels.add(level);\n\
    \                    if (level > max_level) {\n                        flag =\
    \ false;\n                    }\n                }\n                if (flag)\
    \ {\n                    max_level = level;\n                }\n            }\n\
    \            // Once we get the level of nesting we add it to the list.\n    \
    \        if (max_level > 0) {\n                levels.add(max_level);\n      \
    \      }\n            // Add the level of nesting to our result list.\n      \
    \      for (long level : levels) {\n                result.add(level);\n     \
    \       }\n        }\n        // Return result.\n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmg5z0rro.java:50: error: variable level is already defined in method\
    \ parseNestedParens(String)\n            for (long level : levels) {\n       \
    \               ^\n/tmp/tmpmg5z0rro.java:51: error: cannot find symbol\n     \
    \           result.add(level);\n                ^\n  symbol:   variable result\n\
    \  location: class Problem\n/tmp/tmpmg5z0rro.java:55: error: cannot find symbol\n\
    \        return result;\n               ^\n  symbol:   variable result\n  location:\
    \ class Problem\n3 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   if (paren_string == null || paren_string.isEmpty()) {\n            return\
    \ levels;\n        }\n        paren_string = paren_string.trim();\n        int\
    \ open_parentheses_cnt = 0;\n        int max_open_parentheses_cnt = 0;\n     \
    \   int closed_parentheses_cnt = 0;\n        boolean open = false;\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') {\n                open = true;\n                open_parentheses_cnt++;\n\
    \            } else if (c == ')') {\n                open = false;\n         \
    \       closed_parentheses_cnt++;\n                if (open_parentheses_cnt ==\
    \ max_open_parentheses_cnt) {\n                    max_open_parentheses_cnt++;\n\
    \                }\n            } else if (open) {\n                levels.add(Long.valueOf(String.valueOf(c)));\n\
    \            }\n        }\n        if (closed_parentheses_cnt < open_parentheses_cnt)\
    \ {\n            throw new RuntimeException(\"Parentheses count mismatch: \" +\
    \ paren_string);\n        }\n        return levels;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpeql9nlnm.java:45)\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>(Arrays.asList(0l));\n\
    \        ArrayList<String> groups = paren_string.split(\"\\\\s+\");\n        for(String\
    \ group : groups) {\n            long curr_size = 1;\n            String curr_piece\
    \ = null;\n            for(int i = 0, len = group.length(); i < len; i++) {\n\
    \                char c = group.charAt(i);\n                if(c == '(') {\n \
    \                   curr_piece = curr_piece == null ? \"\" : curr_piece;\n   \
    \                 curr_piece += c;\n                } else if(c == ')') {\n  \
    \                  if(curr_piece == null) {\n                        result.add(0l);\n\
    \                    } else {\n                        result.add(result.size()\
    \ + curr_size);\n                    }\n                    curr_piece = null;\n\
    \                } else if(c == '(') {\n                    curr_size++;\n   \
    \             } else if(c == ')') {\n                    curr_size--;\n      \
    \          }\n            }\n        }\n        return result;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxqufjeau.java:16: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> groups = paren_string.split(\"\
    \\\\s+\");\n                                                     ^\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_paren_levels = new ArrayList<Long>();\n\
    \n        // Loop through each group of parentheses\n        for (int i = 0; i\
    \ < paren_string.length(); i++) {\n            // If it is the first group of\
    \ parentheses, set this group as the new parenthesis level.\n            if (i\
    \ == 0) {\n                nested_paren_levels.add(Long.valueOf(paren_string.charAt(i)));\n\
    \                continue;\n            }\n\n            // If it is the last\
    \ group of parentheses, add the current group's closing parenthesis level to it.\n\
    \            if (paren_string.charAt(i) == ')') {\n                nested_paren_levels.add(nested_paren_levels.get(nested_paren_levels.size())\
    \ - 1);\n            }\n\n            // If it is the opening parenthesis, decrement\
    \ the level\n            if (paren_string.charAt(i) == '(') {\n              \
    \  nested_paren_levels.set(nested_paren_levels.size() - 1, nested_paren_levels.get(nested_paren_levels.size()\
    \ - 1) - 1);\n            }\n        }\n\n        // The levels are in descending\
    \ order.\n        return nested_paren_levels.subList(0, nested_paren_levels.size()\
    \ - 1);\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsfmdbal_.java:37: error: incompatible types: List<Long> cannot\
    \ be converted to ArrayList<Long>\n        return nested_paren_levels.subList(0,\
    \ nested_paren_levels.size() - 1);\n                                         \
    \ ^\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> group_list = new ArrayList<Long>();\n\
    \        \n        // First parse paren_string into a list of groups\n       \
    \ ArrayDeque<String> groups = new ArrayDeque<String>();\n        String[] strings\
    \ = paren_string.split(\" \");\n        for (String string : strings) {\n    \
    \        if (string.equals(\"(\") || string.equals(\")\")) {\n               \
    \ groups.add(string);\n            }\n        }\n        \n        // Then iterate\
    \ through the groups and find out how many inner groups are there\n        int\
    \ inner_count = 0;\n        while (groups.peek() != null) {\n            String\
    \ group = groups.poll();\n            \n            // Add all the inner groups\
    \ to the stack\n            group_list.clear();\n            ArrayDeque<String>\
    \ inner_groups = new ArrayDeque<String>();\n            for (String string : strings)\
    \ {\n                if (string.equals(\"(\") || string.equals(\")\")) {\n   \
    \                 inner_groups.add(string);\n                }\n            }\n\
    \            \n            // Find the deepest level of nesting for each group\n\
    \            ArrayDeque<Integer> nest_level = new ArrayDeque<Integer>();\n   \
    \         for (String string : inner_groups) {\n                nest_level.add(0,\
    \ (nest_level.size() + 1) * 2);\n            }\n            \n            while\
    \ (!inner_groups.isEmpty()) {\n                int curr_level = nest_level.poll();\n\
    \                if (curr_level == group_list.size()) {\n                    group_list.add(new\
    \ Long(group_list.size()));\n                }\n                \n           \
    \     int next_level = nest_level.poll();\n                \n                if\
    \ (next_level < curr_level) {\n                    group_list.add(new Long(group_list.size()),\
    \ new Long(curr_level));\n                    group_list.add(new Long(curr_level),\
    \ new Long(next_level));\n                }\n            }\n            \n   \
    \         inner_count++;\n        }\n        \n        // Return the group_list\n\
    \        return group_list;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpihhs8mbd.java:43: error: method add in class ArrayDeque<E> cannot\
    \ be applied to given types;\n                nest_level.add(0, (nest_level.size()\
    \ + 1) * 2);\n                          ^\n  required: Integer\n  found:    int,int\n\
    \  reason: actual and formal argument lists differ in length\n  where E is a type-variable:\n\
    \    E extends Object declared in class ArrayDeque\n/tmp/tmpihhs8mbd.java:49:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                    group_list.add(new Long(group_list.size()));\n          \
    \                         ^\n/tmp/tmpihhs8mbd.java:55: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                    group_list.add(new\
    \ Long(group_list.size()), new Long(curr_level));\n                          \
    \         ^\n/tmp/tmpihhs8mbd.java:55: warning: [removal] Long(long) in Long has\
    \ been deprecated and marked for removal\n                    group_list.add(new\
    \ Long(group_list.size()), new Long(curr_level));\n                          \
    \                                      ^\n/tmp/tmpihhs8mbd.java:55: error: incompatible\
    \ types: Long cannot be converted to int\n                    group_list.add(new\
    \ Long(group_list.size()), new Long(curr_level));\n                          \
    \         ^\n/tmp/tmpihhs8mbd.java:56: warning: [removal] Long(long) in Long has\
    \ been deprecated and marked for removal\n                    group_list.add(new\
    \ Long(curr_level), new Long(next_level));\n                                 \
    \  ^\n/tmp/tmpihhs8mbd.java:56: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                    group_list.add(new Long(curr_level),\
    \ new Long(next_level));\n                                                   \
    \      ^\n/tmp/tmpihhs8mbd.java:56: error: incompatible types: Long cannot be\
    \ converted to int\n                    group_list.add(new Long(curr_level), new\
    \ Long(next_level));\n                                   ^\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n3 "
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> list = new ArrayList<>(Arrays.asList(paren_string.split(\"\
    \ \")));\n        long current_depth = 0;\n        ArrayList<Long> parens = new\
    \ ArrayList<>(list.size());\n        for (String s : list) {\n            long\
    \ paren_depth = 0;\n            String remainder = null;\n            if (s.equals(\"\
    (\")) {\n                paren_depth++;\n            }\n            else if (s.equals(\"\
    )\")) {\n                paren_depth--;\n                remainder = list.remove(list.size()\
    \ - 1);\n            }\n            if (paren_depth > current_depth) {\n     \
    \           parens.add(current_depth);\n            }\n            current_depth\
    \ = paren_depth;\n            if (paren_depth != 0) {\n                parens.add(paren_depth);\n\
    \            }\n            if (remainder != null) {\n                list.add(remainder);\n\
    \            }\n        }\n        return parens;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppryfgu01.java:42)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Return an empty list if input is empty\n       \
    \ if (paren_string.isEmpty()) {\n            return new ArrayList<>();\n     \
    \   }\n        // Remove spaces from begining and end of string\n        paren_string\
    \ = paren_string.trim();\n        ArrayList<Long> paren_levels = new ArrayList<>();\n\
    \n        // Initialize left and right pointers\n        int left = 0;\n     \
    \   int right = paren_string.length() - 1;\n\n        while (left < right) {\n\
    \            int cur_level = paren_string.charAt(left) - '(';\n            paren_levels.add(cur_level);\n\
    \n            // Move left pointer to next opening paren\n            left++;\n\
    \            if (paren_string.charAt(left) == '(') {\n                left++;\n\
    \                right--;\n            }\n        }\n\n        return paren_levels;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdch0sig1.java:29: error: incompatible types: int cannot be converted\
    \ to Long\n            paren_levels.add(cur_level);\n                        \
    \     ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        int open_brackets = 0;\n        ArrayList<Long> levels_of_nesting\
    \ = new ArrayList<>();\n        for (char c : paren_string.toCharArray()) {\n\
    \            if (c == '(') open_brackets++;\n            else if (c == ')') open_brackets--;\n\
    \            if (open_brackets == 0) {\n                levels_of_nesting.add(Long.valueOf(paren_string.length()));\n\
    \            }\n        }\n        return levels_of_nesting;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmppnta_1d9.java:27)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_list = new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l));\n        Set<String> parens_set = paren_string.split(\"\
    [ \\(\\)]\");\n        for (String single_parens : parens_set) {\n           \
    \ Set<String> temp_set = single_parens.split(\"[ ()()]\");\n            deepest_list.add(deepest_max(temp_set));\n\
    \        }\n        return deepest_list;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi7mtsf6q.java:16: error: illegal escape character\n        Set<String>\
    \ parens_set = paren_string.split(\"[ \\(\\)]\");\n                          \
    \                              ^\n/tmp/tmpi7mtsf6q.java:16: error: illegal escape\
    \ character\n        Set<String> parens_set = paren_string.split(\"[ \\(\\)]\"\
    );\n                                                          ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<Long>();\n \
    \       int opening_count = 0;\n        int closings_count = 0;\n\n        for\
    \ (int i = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            if (c == '(') {\n                opening_count++;\n             \
    \   if (opening_count == 1)\n                    levels.add(1l);\n           \
    \     else if (opening_count == 2)\n                    levels.add(2l);\n    \
    \            else if (opening_count == 3)\n                    levels.add(3l);\n\
    \                else\n                    throw new RuntimeException(\"Invalid\
    \ parenthesis count \" + paren_string);\n            } else if (c == ')') {\n\
    \                closings_count++;\n                if (closings_count == 1)\n\
    \                    levels.add(1l);\n                else if (closings_count\
    \ == 2)\n                    levels.add(2l);\n                else if (closings_count\
    \ == 3)\n                    levels.add(3l);\n                else\n         \
    \           throw new RuntimeException(\"Invalid parenthesis count \" + paren_string);\n\
    \            } else if (c == ' ') {\n                levels.add(1l);\n       \
    \     }\n        }\n        return levels;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.RuntimeException: Invalid parenthesis\
    \ count (()()) ((())) () ((())()())\n\tat Problem.parseNestedParens(tmpd22sne3m.java:30)\n\
    \tat Problem.main(tmpd22sne3m.java:48)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<Long> levels = new ArrayList<>();\n        stack<String>\
    \ stack = new stack<>();\n        StringTokenizer str_tok = new StringTokenizer(paren_string,\
    \ \" \");\n        while (str_tok.hasMoreElements()) {\n            String element\
    \ = str_tok.nextToken();\n            if (element.equals(\"(\")) {\n         \
    \       stack.push(element);\n            } else if (element.equals(\")\")) {\n\
    \                while (!stack.isEmpty()) {\n                    if (stack.peek().equals(\"\
    (\")) {\n                        levels.add((long) levels.size());\n         \
    \               stack.pop();\n                    } else {\n                 \
    \       break;\n                    }\n                }\n                stack.pop();\n\
    \            }\n        }\n        levels.add((long) levels.size());\n       \
    \ levels.add((long) levels.size());\n        return new ArrayList<>(levels);\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz35p5s2s.java:16: error: cannot find symbol\n        stack<String>\
    \ stack = new stack<>();\n        ^\n  symbol:   class stack\n  location: class\
    \ Problem\n/tmp/tmpz35p5s2s.java:16: error: cannot find symbol\n        stack<String>\
    \ stack = new stack<>();\n                                  ^\n  symbol:   class\
    \ stack\n  location: class Problem\n2 errors\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // A group is represented as a string with one character\
    \ on one side.\n        // E.g. \"(()())\" has two groups: \"(\" and \"()\"\n\
    \        // We split each group with two characters so that we can check whether\
    \ the current character\n        // is inside one of these groups. In order to\
    \ check the current character, we convert it to long.\n        // We don't need\
    \ to worry about the character being outside of the group.\n        // We also\
    \ handle the last group of parentheses, where the length is always 1.\n      \
    \  // We use a list to store the maximum length of the groups. We use ArrayList\
    \ since we expect to\n        // add elements to it often and ArrayList is more\
    \ efficient than LinkedList in such cases.\n        // Since we expect long values\
    \ to be added, we use Long class rather than primitive long.\n        ArrayList<Long>\
    \ max_depth = new ArrayList<>(25);\n\n        // Iterate over each character in\
    \ string.\n        for (char ch : paren_string.toCharArray()) {\n            //\
    \ Convert each character to a long.\n            long ch_long = Long.parseLong(String.valueOf(ch));\n\
    \            // Iterate over each group. There are two types of groups: parentheses\n\
    \            // and non-parentheses. We keep track of whether there are non-parentheses\
    \ groups (or not)\n            // by using a boolean. We don't need to worry about\
    \ the last group.\n            for (String group : Arrays.asList(\"()\", \"()()\"\
    )) {\n                // Check to see if the current character belongs to the\
    \ group.\n                if (ch_long % 2 == 0 && group.contains(String.valueOf(ch)))\
    \ {\n                    // If the current character is inside the group, update\
    \ max_depth to current group\n                    // length and set is_inside\
    \ to true.\n                    max_depth.add(ch_long);\n                    boolean\
    \ is_inside = false;\n                    for (long len : max_depth) {\n     \
    \                   if (len == 1) {\n                            is_inside = true;\n\
    \                            break;\n                        }\n             \
    \       }\n                    if (is_inside) {\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        //\
    \ Return the maximum depth of nested parenthesis.\n        return max_depth;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NumberFormatException: For input\
    \ string: \"(\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat Problem.parseNestedParens(tmp_rz1w7li.java:29)\n\tat Problem.main(tmp_rz1w7li.java:56)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_level = new ArrayList<Long>();\n\
    \        ArrayList<String> groups = new ArrayList<String>();\n        int open_brackets\
    \ = 0;\n        int close_brackets = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            String current_char = paren_string.substring(i, paren_string.length());\n\
    \            if (current_char.equals(\"(\")) {\n                open_brackets++;\n\
    \            }\n            if (current_char.equals(\")\")) {\n              \
    \  close_brackets++;\n            }\n            if (open_brackets > close_brackets)\
    \ {\n                String curr_group = paren_string.substring(i, i + 1);\n \
    \               groups.add(curr_group);\n            }\n        }\n        Arrays.stream(groups.toArray(new\
    \ String[groups.size()])).collect(Collectors.groupingBy(s -> s, Collectors.counting())).forEach((k,\
    \ v) -> {\n            Long max_level = v.stream().max(Long::compareTo).get();\n\
    \            if (max_level > deepest_level.get(0)) {\n                deepest_level\
    \ = new ArrayList<Long>();\n            }\n            deepest_level.add(max_level);\n\
    \        });\n        return deepest_level;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt9gkd158.java:33: error: cannot find symbol\n            Long max_level\
    \ = v.stream().max(Long::compareTo).get();\n                              ^\n\
    \  symbol:   method stream()\n  location: variable v of type Long\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Use of regular expressions could eliminate some\
    \ of this code.\n        // This code can use some more optimizations.\n     \
    \   ArrayList<Long> result = new ArrayList<>();\n        if (paren_string == null\
    \ || paren_string.isEmpty()) {\n            return result;\n        }\n      \
    \  paren_string = paren_string.replace(\"()\", \"\");\n        paren_string =\
    \ paren_string.replace(\"()\", \"\")\n                .replaceAll(\"[^()]+\",\
    \ \"\");\n        String[] group_str = paren_string.split(\" +\");\n        Matcher\
    \ matcher = Pattern.compile(\"^\\\\(([^()]*)\\\\)$\").matcher(group_str[0]);\n\
    \        if (matcher.find()) {\n            result.add(Long.parseLong(matcher.group(1)));\n\
    \            for (int i = 1; i < group_str.length; i++) {\n                matcher\
    \ = Pattern.compile(\"^\\\\(([^()]*)\\\\)$\").matcher(group_str[i]);\n       \
    \         if (matcher.find()) {\n                    String group = matcher.group(1);\n\
    \                    int pos = 0;\n                    int next_open_bracket =\
    \ group.indexOf('(');\n                    int next_closed_bracket = group.indexOf(')',\
    \ pos);\n                    while (next_open_bracket != -1 && next_closed_bracket\
    \ != -1) {\n                        if (next_open_bracket - pos == next_closed_bracket\
    \ - next_open_bracket) {\n                            result.add(Long.parseLong(group.substring(pos\
    \ + 1, next_open_bracket)));\n                            pos = next_closed_bracket;\n\
    \                            next_open_bracket = group.indexOf('(', pos);\n  \
    \                          next_closed_bracket = group.indexOf(')', pos);\n  \
    \                      }\n                        else {\n                   \
    \         pos = next_open_bracket;\n                            next_open_bracket\
    \ = group.indexOf('(', pos);\n                            next_closed_bracket\
    \ = group.indexOf(')', pos);\n                        }\n                    }\n\
    \                }\n            }\n        }\n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn9ntbkt3.java:25: error: cannot find symbol\n        Matcher matcher\
    \ = Pattern.compile(\"^\\\\(([^()]*)\\\\)$\").matcher(group_str[0]);\n       \
    \ ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpn9ntbkt3.java:25:\
    \ error: cannot find symbol\n        Matcher matcher = Pattern.compile(\"^\\\\\
    (([^()]*)\\\\)$\").matcher(group_str[0]);\n                          ^\n  symbol:\
    \   variable Pattern\n  location: class Problem\n/tmp/tmpn9ntbkt3.java:29: error:\
    \ cannot find symbol\n                matcher = Pattern.compile(\"^\\\\(([^()]*)\\\
    \\)$\").matcher(group_str[i]);\n                          ^\n  symbol:   variable\
    \ Pattern\n  location: class Problem\n3 errors\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting_levels = new ArrayList<Long>();\n\
    \        StringTokenizer st = new StringTokenizer(paren_string);\n        boolean\
    \ inParen = false;\n        while (st.hasMoreTokens()) {\n            String token\
    \ = st.nextToken();\n            if (token.equals(\"(\")) {\n                if\
    \ (inParen) {\n                    nesting_levels.add(new Long(nesting_levels.size()));\n\
    \                    inParen = false;\n                }\n            } else if\
    \ (token.equals(\")\")) {\n                if (!inParen) {\n                 \
    \   nesting_levels.add(new Long(nesting_levels.size()));\n                }\n\
    \            } else if (inParen) {\n                long l = nesting_levels.get(nesting_levels.size()\
    \ - 1);\n                if (new Long(l).equals(new Long(token.charAt(0)))) {\n\
    \                    nesting_levels.add(new Long(nesting_levels.size()));\n  \
    \              }\n            }\n        }\n        return nesting_levels;\n \
    \   }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxgww2fdb.java:39)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_levels_of_nesting = new ArrayList<>();\n\
    \        if (paren_string.isEmpty()) return deepest_levels_of_nesting;\n\n   \
    \     List<String> parens = Arrays.asList(paren_string.split(\"\\\\s*\\\\(|\\\\\
    )\\\\s*\"));\n        for (String paren : parens) {\n            try {\n     \
    \           deepest_levels_of_nesting.add(new Long(paren.length()));\n       \
    \     } catch (NumberFormatException e) {\n                // We are not interested\
    \ in those exceptions.\n            }\n        }\n\n        Arrays.sort(deepest_levels_of_nesting);\n\
    \        return deepest_levels_of_nesting;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0r2_8xve.java:21: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                deepest_levels_of_nesting.add(new\
    \ Long(paren.length()));\n                                              ^\n/tmp/tmp0r2_8xve.java:27:\
    \ error: no suitable method found for sort(ArrayList<Long>)\n        Arrays.sort(deepest_levels_of_nesting);\n\
    \              ^\n    method Arrays.sort(int[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to int[])\n    method Arrays.sort(long[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to long[])\n    method Arrays.sort(short[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to short[])\n    method Arrays.sort(char[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to char[])\n    method Arrays.sort(byte[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to byte[])\n    method Arrays.sort(float[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to float[])\n    method Arrays.sort(double[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to double[])\n    method Arrays.sort(Object[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to Object[])\n    method Arrays.<T#1>sort(T#1[],Comparator<? super T#1>) is\
    \ not applicable\n      (cannot infer type-variable(s) T#1\n        (actual and\
    \ formal argument lists differ in length))\n    method Arrays.<T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>) is not applicable\n      (cannot infer type-variable(s) T#2\n  \
    \      (actual and formal argument lists differ in length))\n  where T#1,T#2 are\
    \ type-variables:\n    T#1 extends Object declared in method <T#1>sort(T#1[],Comparator<?\
    \ super T#1>)\n    T#2 extends Object declared in method <T#2>sort(T#2[],int,int,Comparator<?\
    \ super T#2>)\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n1 error\n1 warning\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> list_of_parens = new ArrayList<Long>(10);\n\
    \        StringTokenizer tok = new StringTokenizer(paren_string);\n        boolean\
    \ is_in_nested_group = false;\n        long current_level = 1;\n        while(tok.hasMoreTokens())\
    \ {\n            String token_str = tok.nextToken();\n            if((token_str.equals(\"\
    (\")) is_in_nested_group = true;\n            else if((token_str.equals(\")\"\
    ))) is_in_nested_group = false;\n\n            if(is_in_nested_group) {\n    \
    \            current_level++;\n                list_of_parens.add(current_level);\n\
    \            }\n        }\n        return list_of_parens;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmcl3fkar.java:21: error: ')' expected\n            if((token_str.equals(\"\
    (\")) is_in_nested_group = true;\n                                      ^\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_levels = new ArrayList<>();\n\
    \        ArrayList<Integer> paren_groups = new ArrayList<>();\n        for (int\
    \ i = 0; i < paren_string.length(); i++) {\n            char ch = paren_string.charAt(i);\n\
    \            if (ch == '(') paren_groups.add(i);\n            if (ch == ')') {\n\
    \                long total_parentheses = paren_groups.get(paren_groups.size()\
    \ - 1);\n                paren_levels.set(paren_levels.size() - 1, total_parentheses);\n\
    \                paren_groups.remove(paren_groups.size() - 1);\n            }\n\
    \        }\n        return paren_levels;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.IndexOutOfBoundsException: Index\
    \ -1 out of bounds for length 0\n\tat java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:64)\n\
    \tat java.base/jdk.internal.util.Preconditions.outOfBoundsCheckIndex(Preconditions.java:70)\n\
    \tat java.base/jdk.internal.util.Preconditions.checkIndex(Preconditions.java:266)\n\
    \tat java.base/java.util.Objects.checkIndex(Objects.java:359)\n\tat java.base/java.util.ArrayList.set(ArrayList.java:441)\n\
    \tat Problem.parseNestedParens(tmpa_pp8yo4.java:22)\n\tat Problem.main(tmpa_pp8yo4.java:29)\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_level = new ArrayList<Long>();\n\
    \        // Step 1: count the parentheses in the string\n        int n_par = 0;\n\
    \        int opening_brackets = paren_string.indexOf('(');\n        int closing_brackets\
    \ = paren_string.lastIndexOf(')');\n        while (opening_brackets >= 0) {\n\
    \            n_par++;\n            opening_brackets = paren_string.indexOf('(',\
    \ opening_brackets + 1);\n        }\n        while (closing_brackets > -1) {\n\
    \            n_par--;\n            closing_brackets = paren_string.lastIndexOf(')',\
    \ closing_brackets - 1);\n        }\n\n        // Step 2: count the parentheses\
    \ in the group\n        int group_opening_brackets = paren_string.indexOf('(');\n\
    \        int group_closing_brackets = paren_string.lastIndexOf(')');\n       \
    \ while (group_opening_brackets >= 0) {\n            int group_open_parens = paren_string.indexOf('(',\
    \ group_opening_brackets + 1);\n            int group_close_parens = paren_string.lastIndexOf(')',\
    \ group_close_parens + 1);\n            if (group_open_parens <= group_close_parens)\
    \ {\n                for (int i = group_open_parens; i < group_close_parens; i++)\
    \ {\n                    n_par++;\n                }\n            }\n        \
    \    else {\n                for (int i = group_open_parens; i < group_closing_brackets;\
    \ i++) {\n                    n_par--;\n                }\n            }\n   \
    \         group_opening_brackets = paren_string.indexOf('(', group_open_parens\
    \ + 1);\n            group_closing_brackets = paren_string.lastIndexOf(')', group_close_parens\
    \ + 1);\n        }\n        max_level.clear();\n        // Step 3: fill the max\
    \ level list with appropriate number of levels\n        for (int i = 0; i < n_par;\
    \ i++) {\n            max_level.add(1l);\n        }\n        max_level.add(n_par);\n\
    \n        // Step 4: count the levels of nesting\n        int level = 1;\n   \
    \     while (paren_string.indexOf(')', level) >= 0) {\n            paren_string\
    \ = paren_string.substring(level + 1);\n            level++;\n            max_level.add(level);\n\
    \        }\n        max_level.add(level);\n\n        // Step 5: get the max level\
    \ for every group\n        StringBuilder sb = new StringBuilder();\n        boolean\
    \ found = false;\n        for (int i = 0; i < max_level.size(); i++) {\n     \
    \       while (paren_string.indexOf('(', i) >= 0) {\n                found = true;\n\
    \                sb.append(paren_string.substring(0, i));\n                paren_string\
    \ = paren_string.substring(i + 1);\n            }\n            if (!found) {\n\
    \                sb.append(paren_string);\n                sb.append(\" \");\n\
    \                sb.append(new ArrayList<Long>(Arrays.as\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyw56kemq.java:76: error: ')' expected\n                sb.append(new\
    \ ArrayList<Long>(Arrays.as\n                                                \
    \       ^\n/tmp/tmpyw56kemq.java:78: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   long level = 0;\n        long max_level = Long.MAX_VALUE;\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (char c : paren_string.toCharArray())\
    \ {\n            switch (c) {\n                case '(':\n                   \
    \ level++;\n                    sb.append(c);\n                    break;\n  \
    \              case ')':\n                    level--;\n                    sb.append(c);\n\
    \                    break;\n                case ' ':\n                    if\
    \ (level > max_level) {\n                        max_level = level;\n        \
    \            }\n                    sb.append(c);\n                    break;\n\
    \                default:\n                    sb.append(c);\n               \
    \     break;\n            }\n        }\n        result.add(max_level);\n     \
    \   for (String paren : sb.toString().split(\" \")) {\n            result.add(parseNestedParens(paren));\n\
    \        }\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdzch206.java:42: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n            result.add(parseNestedParens(paren));\n  \
    \                                      ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> resultList = new ArrayList<>();\n \
    \       ArrayList<Long> tempList = new ArrayList<>();\n        boolean flag =\
    \ true;\n        for(char c : paren_string.toCharArray()) {\n            if(c\
    \ == '(' || c == ')') flag = !flag;\n            if(flag)\n                tempList.add(c);\n\
    \            else\n                tempList.remove(c-'0');\n        }\n      \
    \  for(long l : tempList)\n            resultList.add(l);\n        return Collections.max(resultList);\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp01ybrpl2.java:21: error: incompatible types: char cannot be converted\
    \ to Long\n                tempList.add(c);\n                             ^\n\
    /tmp/tmp01ybrpl2.java:27: error: incompatible types: inference variable T has\
    \ incompatible bounds\n        return Collections.max(resultList);\n         \
    \                     ^\n    lower bounds: ArrayList<Long>,Long,Object,Comparable<?\
    \ super T>\n    lower bounds: Long\n  where T is a type-variable:\n    T extends\
    \ Object,Comparable<? super T> declared in method <T>max(Collection<? extends\
    \ T>)\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_level_array = new ArrayList<Long>();\n\
    \        ArrayList<String> paren_groups = paren_string.split(\"\\\\s+\");\n  \
    \      for (String group : paren_groups) {\n            ArrayList<Long> sub_level_array\
    \ = parseNestedParens(group);\n            if (nested_level_array.size() <= sub_level_array.size())\
    \ {\n                nested_level_array.addAll(sub_level_array);\n           \
    \ }\n        }\n        return nested_level_array;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiq12eb2k.java:16: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> paren_groups = paren_string.split(\"\
    \\\\s+\");\n                                                           ^\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> list = Arrays.asList(paren_string.trim().split(\"\
    \\\\s\"));\n        ArrayList<Long> list2 = new ArrayList<>();\n        int count\
    \ = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(0);\n\
    \        while (!stack.isEmpty()) {\n            String currParen = list.get(stack.pop());\n\
    \            int size = stack.isEmpty() ? list.size() : stack.pop();\n       \
    \     if (currParen.equals(\"(\")) {\n                stack.push(size + 1);\n\
    \            } else if (currParen.equals(\")\")) {\n                if (stack.size()\
    \ > 0) {\n                    int size = stack.pop();\n                    list2.add(new\
    \ Long(size));\n                    stack.push(size + 1);\n                }\n\
    \            } else if (currParen.equals(\" \")) {\n                list2.add(new\
    \ Long(size));\n            }\n        }\n        return list2;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6s5f30w3.java:27: error: variable size is already defined in method\
    \ parseNestedParens(String)\n                    int size = stack.pop();\n   \
    \                     ^\n/tmp/tmp6s5f30w3.java:28: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                    list2.add(new\
    \ Long(size));\n                              ^\n/tmp/tmp6s5f30w3.java:32: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \              list2.add(new Long(size));\n                          ^\n1 error\n\
    2 warnings\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // TODO: Implement this function\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkpoy63y9.java:16: error: missing return statement\n    }\n    ^\n\
    1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_list = new ArrayList<>();\n   \
    \     ArrayList<String> max_groups = new ArrayList<>();\n        ArrayList<ArrayList<Long>>\
    \ nested_lists = new ArrayList<>();\n        ArrayList<ArrayList<Long>> unnested_lists\
    \ = new ArrayList<>();\n\n        for (char c : paren_string.toCharArray()) {\n\
    \            if (c == '(' || c == '{' || c == '[') {\n                nested_lists.add(new\
    \ ArrayList<Long>());\n            } else if (c == ')' || c == '}' || c == ']')\
    \ {\n                nested_lists.get(0).add(1l);\n            } else if (c ==\
    \ ' ' || c == ',') {\n                unnested_lists.add(new ArrayList<Long>());\n\
    \            } else if (c == '}' || c == ']') {\n                nested_lists.remove(0);\n\
    \            } else if (c == ']') {\n                max_list = max_list.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \                unnested_lists.remove(0);\n            }\n        }\n\n     \
    \   for (ArrayList<Long> nested_list : nested_lists) {\n            ArrayList<Long>\
    \ temp_nested_list = nested_list.stream().collect(Collectors.toList());\n    \
    \        max_list = max_list.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \            max_list = max_list.stream().filter(max -> nested_list.stream().anyMatch(max_list\
    \ -> max_list.equals(max)))\n                    .collect(Collectors.toList());\n\
    \            max_list = new ArrayList<>(max_list);\n            max_list.add(Long.valueOf(temp_nested_list.size()));\n\
    \            max_list.addAll(temp_nested_list);\n        }\n\n        return max_list;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppxmy1885.java:30: error: incompatible types: cannot infer type-variable(s)\
    \ R\n                max_list = max_list.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \                                                    ^\n    (argument mismatch;\
    \ invalid method reference\n      method stream in interface Collection<E> cannot\
    \ be applied to given types\n        required: no arguments\n        found:  \
    \  Long\n        reason: actual and formal argument lists differ in length)\n\
    \  where R,T,E are type-variables:\n    R extends Object declared in method <R>flatMap(Function<?\
    \ super T,? extends Stream<? extends R>>)\n    T extends Object declared in interface\
    \ Stream\n    E extends Object declared in interface Collection\n/tmp/tmppxmy1885.java:36:\
    \ error: incompatible types: inference variable R has incompatible bounds\n  \
    \          ArrayList<Long> temp_nested_list = nested_list.stream().collect(Collectors.toList());\n\
    \                                                                           ^\n\
    \    equality constraints: List<T#2>\n    lower bounds: ArrayList<Long>,Object\n\
    \  where R,A,T#1,T#2 are type-variables:\n    R extends Object declared in method\
    \ <R,A>collect(Collector<? super T#1,A,R>)\n    A extends Object declared in method\
    \ <R,A>collect(Collector<? super T#1,A,R>)\n    T#1 extends Object declared in\
    \ interface Stream\n    T#2 extends Object declared in method <T#2>toList()\n\
    /tmp/tmppxmy1885.java:37: error: incompatible types: cannot infer type-variable(s)\
    \ R\n            max_list = max_list.stream().flatMap(Collection::stream).collect(Collectors.toList());\n\
    \                                                ^\n    (argument mismatch; invalid\
    \ method reference\n      method stream in interface Collection<E> cannot be applied\
    \ to given types\n        required: no arguments\n        found:    Long\n   \
    \     reason: actual and formal argument lists differ in length)\n  where R,T,E\
    \ are type-variables:\n    R extends Object declared in method <R>flatMap(Function<?\
    \ super T,? extends Stream<? extends R>>)\n    T extends Object declared in int"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   List<String> paren_list = Arrays.asList(paren_string.trim().split(\"\\\\s+\"\
    ));\n        Stack<String> stack = new Stack<>();\n        for (String s: paren_list)\
    \ {\n            if (s.equals(\"(\")) {\n                stack.push(\"(\");\n\
    \            } else if (s.equals(\")\")) {\n                if (stack.size() ==\
    \ 0) {\n                    throw new RuntimeException(\"unmatched \")\");\n \
    \               } else if (stack.peek().equals(\"(\")) {\n                   \
    \ throw new RuntimeException(\"unmatched (\");\n                }\n          \
    \      String pop = stack.pop();\n                result.add(new Long(pop));\n\
    \            }\n        }\n        if (stack.size() != 0) {\n            throw\
    \ new RuntimeException(\"unmatched \" + stack.pop());\n        }\n        return\
    \ result;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp06ztzaug.java:23: error: unclosed string literal\n            \
    \        throw new RuntimeException(\"unmatched \")\");\n                    \
    \                                        ^\n1 error\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_group = new ArrayList<Long>();\n\
    \        ArrayList<Long> paren_group2 = new ArrayList<Long>();\n        ArrayList<Long>\
    \ paren_group3 = new ArrayList<Long>();\n        ArrayList<Long> paren_group4\
    \ = new ArrayList<Long>();\n        ArrayList<Long> paren_group5 = new ArrayList<Long>();\n\
    \        ArrayList<Long> paren_group6 = new ArrayList<Long>();\n        ArrayList<Long>\
    \ paren_group7 = new ArrayList<Long>();\n\n        paren_string = paren_string.replaceAll(\"\
    \ \", \"\");\n\n        for(int i = 0; i < paren_string.length(); i++) {\n   \
    \         char current = paren_string.charAt(i);\n\n            if(current ==\
    \ '(') {\n                paren_group.add(new Long(i));\n                paren_group2.add(new\
    \ Long(i));\n                paren_group3.add(new Long(i));\n                paren_group4.add(new\
    \ Long(i));\n                paren_group5.add(new Long(i));\n                paren_group6.add(new\
    \ Long(i));\n                paren_group7.add(new Long(i));\n            }\n \
    \           else if(current == ')') {\n                paren_group.remove(paren_group.size()\
    \ - 1);\n                paren_group2.remove(paren_group2.size() - 1);\n     \
    \           paren_group3.remove(paren_group3.size() - 1);\n                paren_group4.remove(paren_group4.size()\
    \ - 1);\n                paren_group5.remove(paren_group5.size() - 1);\n     \
    \           paren_group6.remove(paren_group6.size() - 1);\n                paren_group7.remove(paren_group7.size()\
    \ - 1);\n                paren_group.add(new Long(i));\n                paren_group2.add(new\
    \ Long(i));\n                paren_group3.add(new Long(i));\n                paren_group4.add(new\
    \ Long(i));\n                paren_group5.add(new Long(i));\n                paren_group6.add(new\
    \ Long(i));\n                paren_group7.add(new Long(i));\n            }\n \
    \           else if(current == '(') {\n                paren_group2.remove(paren_group2.size()\
    \ - 1);\n                paren_group3.remove(paren_group3.size() - 1);\n     \
    \           paren_group4.remove(paren_group4.size() - 1);\n                paren_group5.remove(paren_group5.size()\
    \ - 1);\n                paren_group6.remove(paren_group6.size() - 1);\n     \
    \           paren_group7.remove(paren_group7.size() - 1);\n                paren_group2.add(new\
    \ Long(i));\n                paren_group3.add(new Long(i));\n                paren_group4.add(new\
    \ Long(i));\n                paren_\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5koj096g.java:63: error: not a statement\n                paren_\n\
    \                ^\n/tmp/tmp5koj096g.java:63: error: ';' expected\n          \
    \      paren_\n                      ^\n/tmp/tmp5koj096g.java:65: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n    ^\n3\
    \ errors\n"
  stdout: ''
  timestamp: 1660011439
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.length() <= 0)\n            return\
    \ new ArrayList<Long>();\n\n        StringTokenizer tok = new StringTokenizer(paren_string,\
    \ \" \");\n        ArrayList<Long> result = new ArrayList<Long>();\n        long\
    \ currentLevel = 0;\n        boolean inGroup = false;\n        while (tok.hasMoreTokens())\
    \ {\n            String t = tok.nextToken();\n            if (t.equals(\"(\"))\
    \ {\n                currentLevel++;\n                inGroup = true;\n      \
    \      }\n            else if (t.equals(\")\")) {\n                currentLevel--;\n\
    \                inGroup = false;\n            }\n            else if (t.equals(\"\
    (\") && !inGroup) {\n                result.add(currentLevel);\n            }\n\
    \        }\n\n        if (currentLevel > 0)\n            return result;\n    \
    \    else\n            return new ArrayList<Long>();\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqljtjynp.java:43)\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Create our input array list\n        ArrayList<Long>\
    \ input_list = new ArrayList<>();\n        // Loop through our input string\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            // If\
    \ it is the first character, then add it to our input arraylist\n            if\
    \ (paren_string.charAt(i) == ')') {\n                input_list.add(input_list.get(i));\n\
    \                // If we're in the second opening bracket\n            } else\
    \ if (paren_string.charAt(i) == '(') {\n                Long last_index = input_list.get(i-1);\n\
    \                // If this is the second opening bracket, increment our list\
    \ size\n                if (last_index != null) input_list.add(last_index + 1);\n\
    \                // If this is the first opening bracket, add it to the list at\
    \ 0\n                else {\n                    input_list.add(0);\n        \
    \        }\n            }\n        }\n        // Return the final list with our\
    \ data\n        return input_list;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppcz6m1j4.java:29: error: incompatible types: int cannot be converted\
    \ to Long\n                    input_list.add(0);\n                          \
    \         ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String input = paren_string;\n        String input_array[]\
    \ = paren_string.split(\" \");\n        ArrayList<Long> result = new ArrayList<>();\n\
    \        ArrayList<String> result_array = new ArrayList<>();\n        ArrayList<String>\
    \ temp_array = new ArrayList<>();\n        ArrayList<String> temp_result_array\
    \ = new ArrayList<>();\n        ArrayList<Long> result_temp = new ArrayList<>();\n\
    \        Long temp = 0;\n        Long result_temp2 = 1;\n        Long result2\
    \ = 0;\n        Long temp2 = 0;\n        for(String s: input_array) {\n      \
    \      if(s.length()==0) {\n                result_temp2.add(result2);\n     \
    \           result2 = 1;\n                result_temp.add(result_temp2);\n   \
    \             result_temp2.add(result2);\n                temp2 = 1;\n       \
    \     } else {\n                if(s.equals(\"(\")) {\n                    temp_array.add(s);\n\
    \                } else if(s.equals(\")\")) {\n                    temp = Long.parseLong(temp_array.get(temp_array.size()-1));\n\
    \                    if(result2>temp) {\n                        result_temp2.add(result2);\n\
    \                        result2 = temp;\n                        result_temp.add(result_temp2);\n\
    \                        result_temp2.add(result2);\n                        temp2\
    \ = 1;\n                    }\n                    temp_array.remove(temp_array.size()-1);\n\
    \                } else {\n                    temp2 = temp + Long.parseLong(s);\n\
    \                    result_temp2.add(result2);\n                    result2 =\
    \ temp2;\n                    result_temp.add(result_temp2);\n               \
    \     result_temp2.add(result2);\n                    temp2 = 1;\n           \
    \     }\n            }\n        }\n        for(Long l : result_temp) {\n     \
    \       result.add(l);\n        }\n        return result;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbem0db1l.java:22: error: incompatible types: int cannot be converted\
    \ to Long\n        Long temp = 0;\n                    ^\n/tmp/tmpbem0db1l.java:23:\
    \ error: incompatible types: int cannot be converted to Long\n        Long result_temp2\
    \ = 1;\n                            ^\n/tmp/tmpbem0db1l.java:24: error: incompatible\
    \ types: int cannot be converted to Long\n        Long result2 = 0;\n        \
    \               ^\n/tmp/tmpbem0db1l.java:25: error: incompatible types: int cannot\
    \ be converted to Long\n        Long temp2 = 0;\n                     ^\n/tmp/tmpbem0db1l.java:28:\
    \ error: cannot find symbol\n                result_temp2.add(result2);\n    \
    \                        ^\n  symbol:   method add(Long)\n  location: variable\
    \ result_temp2 of type Long\n/tmp/tmpbem0db1l.java:29: error: incompatible types:\
    \ int cannot be converted to Long\n                result2 = 1;\n            \
    \              ^\n/tmp/tmpbem0db1l.java:31: error: cannot find symbol\n      \
    \          result_temp2.add(result2);\n                            ^\n  symbol:\
    \   method add(Long)\n  location: variable result_temp2 of type Long\n/tmp/tmpbem0db1l.java:32:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \ temp2 = 1;\n                        ^\n/tmp/tmpbem0db1l.java:39: error: cannot\
    \ find symbol\n                        result_temp2.add(result2);\n          \
    \                          ^\n  symbol:   method add(Long)\n  location: variable\
    \ result_temp2 of type Long\n/tmp/tmpbem0db1l.java:42: error: cannot find symbol\n\
    \                        result_temp2.add(result2);\n                        \
    \            ^\n  symbol:   method add(Long)\n  location: variable result_temp2\
    \ of type Long\n/tmp/tmpbem0db1l.java:43: error: incompatible types: int cannot\
    \ be converted to Long\n                        temp2 = 1;\n                 \
    \               ^\n/tmp/tmpbem0db1l.java:48: error: cannot find symbol\n     \
    \               result_temp2.add(result2);\n                                ^\n\
    \  symbol:   method add(Long)\n  location: variable result_temp2 of type Long\n\
    /tmp/tmpbem0db1l.java:51:"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> level = new ArrayList<Long>();\n  \
    \      level.add(0l);\n        level.add(0l);\n        String[] paren_split =\
    \ paren_string.split(\"\\\\s+\");\n        List<Long> nested = new ArrayList<Long>();\n\
    \        for (String s : paren_split) {\n            if (s.startsWith(\"(\"))\
    \ {\n                nested.add((long) level.get(1));\n                level.add(0l);\n\
    \            } else if (s.startsWith(\")\")) {\n                level.add((long)\
    \ level.get(0));\n                level.remove(0);\n                nested.add((long)\
    \ level.get(0));\n            } else if (s.startsWith(\"(\")) {\n            \
    \    level.add((long) level.get(1));\n                nested.add(0l);\n      \
    \      } else {\n                level.add((long) level.get(0));\n           \
    \     nested.add(0l);\n            }\n        }\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        for (int i = 0; i < nested.size(); ++i) {\n\
    \            result.add((long) nested.get(i));\n        }\n        return result;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpx3kkdrka.java:43)\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.length() <= 0)\n            return\
    \ new ArrayList<Long>(Collections.singletonList(0));\n\n        // A list to store\
    \ all the level counts of nesting levels.\n        ArrayList<Long> nesting_levels\
    \ = new ArrayList<Long>(4);\n\n        // A list to store all the left parentheses.\n\
    \        List<String> parentheses = new ArrayList<String>();\n\n        // A stack\
    \ used to maintain parentheses nesting level.\n        Stack<String> parentheses_stack\
    \ = new Stack<>();\n\n        // A temporary stack to store left parenthesis.\n\
    \        Stack<String> temp_parentheses_stack = new Stack<>();\n\n        // A\
    \ temporary list to store the output of this function.\n        ArrayList<Long>\
    \ output_values = new ArrayList<Long>(4);\n\n        // Iterate over all the characters\
    \ in the input string. \n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            if (paren_string.charAt(i) == '(' || paren_string.charAt(i) ==\
    \ '[') {\n                // Push left parentheses.\n                parentheses_stack.push(paren_string.charAt(i));\n\
    \            } else if (paren_string.charAt(i) == ')' || paren_string.charAt(i)\
    \ == ']') {\n                // Pop left parentheses.\n                parentheses_stack.pop();\n\
    \            } else if (paren_string.charAt(i) == '(' || paren_string.charAt(i)\
    \ == ')') {\n                // Push left parentheses.\n                parentheses_stack.push(paren_string.charAt(i));\n\
    \            } else if (paren_string.charAt(i) == ']') {\n                // Pop\
    \ left parentheses.\n                parentheses_stack.pop();\n            } else\
    \ {\n                // If no parentheses are found, then it is an ending parentheses.\n\
    \                if (parentheses_stack.isEmpty())\n                    break;\n\
    \n                // If we have found an opening parentheses, then it is a right\
    \ parentheses.\n                // And we need to increase nesting level.\n  \
    \              if (parentheses_stack.peek() == '(') {\n                    nesting_levels.add(Long.valueOf(nesting_levels.get(nesting_levels.size()\
    \ - 1) + 1));\n                }\n\n                // If we have found an opening\
    \ square bracket, then it is a right square bracket.\n                // And we\
    \ need to increase nesting level.\n                if (parentheses_stack.peek()\
    \ == '[') {\n                    nesting_levels.add(Long.valueOf(nesting_levels.get(nesting_levels.size()\
    \ - 1) + 1));\n                }\n            }\n        }\n\n        // Iterate\
    \ over all the characters in the input string again. \n        for (int i = 0;\
    \ i < paren_string.length(); i++) {\n            if (paren_string.charAt(i) ==\
    \ '(' || paren_string.charAt(i) == '[') {\n                // If parentheses are\
    \ found then we need to push left parentheses onto a stack.\n                parentheses_stack.push(paren_string.charAt(i));\n\
    \            } else if (paren_string.charAt(i) == ')' || paren_string.charAt(i)\
    \ == ']') {\n                // Pop left parentheses.\n                parentheses_\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0ngcq6qe.java:73: error: not a statement\n                parentheses_\n\
    \                ^\n/tmp/tmp0ngcq6qe.java:73: error: ';' expected\n          \
    \      parentheses_\n                            ^\n/tmp/tmp0ngcq6qe.java:75:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n    ^\n3 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_list = new ArrayList<>();\n \
    \       long parentheses_level = 1;\n        \n        // Split the string into\
    \ groups of parentheses.\n        String[] paren_groups = paren_string.split(\"\
    \\\\s\");\n        \n        // For each of the groups, parse each group and add\
    \ it to the list if it is not empty.\n        for (String paren_group : paren_groups)\
    \ {\n            paren_group = paren_group.replace(\"(\", \"\").replace(\")\"\
    , \"\");\n            \n            paren_list = addParenthesisLevel(paren_list,\
    \ parentheses_level, paren_group);\n        }\n        \n        return paren_list;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67habqjn.java:25: error: cannot find symbol\n            paren_list\
    \ = addParenthesisLevel(paren_list, parentheses_level, paren_group);\n       \
    \                  ^\n  symbol:   method addParenthesisLevel(ArrayList<Long>,long,String)\n\
    \  location: class Problem\n1 error\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting_levels = new ArrayList<Long>();\n\
    \        Stack<String> pars = new Stack<String>();\n        String pars_str =\
    \ \"\";\n        int parens_cnt = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                pars.push(c);\n                parens_cnt++;\n          \
    \  } else if (c == ')') {\n                pars_str += pars.peek();\n        \
    \        pars.pop();\n                parens_cnt--;\n            }\n         \
    \   if (parens_cnt > 0) {\n                pars_str += c;\n            }\n   \
    \     }\n        // Find max level of nesting\n        while (pars_str.contains(\"\
    (\")) {\n            nesting_levels.add(Long.parseLong(pars_str));\n         \
    \   pars_str = pars_str.substring(0, pars_str.indexOf(\"(\"));\n        }\n  \
    \      return nesting_levels;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv0l42q2w.java:22: error: incompatible types: char cannot be converted\
    \ to String\n                pars.push(c);\n                          ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n1 error\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   StringTokenizer tokenizer = new StringTokenizer(paren_string);\n        while\
    \ (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                levels.add(1l);\n   \
    \         } else if (token.equals(\")\")) {\n                levels.add(levels.stream().mapToLong(level\
    \ -> level - 1).sum());\n            }\n        }\n        return levels;\n  \
    \  }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_w7idqtq.java:28)\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        StringTokenizer st = new StringTokenizer(paren_string);\n\
    \        ArrayList<Long> level = new ArrayList<Long>();\n        int currLevel\
    \ = 1;\n        while(st.hasMoreTokens()) {\n            String token = st.nextToken();\n\
    \            if(token.equals(\"(\")) {\n                level.add(Long.valueOf(currLevel));\n\
    \                currLevel++;\n            } else if(token.equals(\")\")) {\n\
    \                level.add(Long.valueOf(currLevel));\n                currLevel--;\n\
    \            }\n        }\n        return level;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmm4qnekg.java:31)\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.length() == 0) return new ArrayList<Long>();\n\
    \        ArrayList<Long> deepest_level_of_nesting = new ArrayList<Long>();\n \
    \       ArrayList<Long> current_level_of_nesting = new ArrayList<Long>();\n  \
    \      ArrayList<Long> left_brackets = new ArrayList<Long>();\n        ArrayList<Long>\
    \ right_brackets = new ArrayList<Long>();\n        ArrayList<Long> stack = new\
    \ ArrayList<Long>();\n        for (int i = 0; i < paren_string.length(); i++)\
    \ {\n            char ch = paren_string.charAt(i);\n            if (ch == '(')\
    \ left_brackets.add(i);\n            if (ch == ')') right_brackets.add(i);\n \
    \           if (ch == ' ') {\n                for (int j = left_brackets.size();\
    \ j < right_brackets.size(); j++) {\n                    stack.add(left_brackets.get(j));\n\
    \                    stack.add(right_brackets.get(j));\n                    int\
    \ new_depth = stack.size();\n                    stack.remove(stack.size() - 1);\n\
    \                    if (new_depth > deepest_level_of_nesting.size()) {\n    \
    \                    deepest_level_of_nesting.clear();\n                     \
    \   deepest_level_of_nesting.add((Long)stack.get((stack.size() - 1)));\n     \
    \               } else if (new_depth == deepest_level_of_nesting.size()) {\n \
    \                       deepest_level_of_nesting.add((Long)stack.get((stack.size()\
    \ - 1)));\n                    }\n                    stack.remove(stack.size()\
    \ - 1);\n                }\n                left_brackets.clear();\n         \
    \       right_brackets.clear();\n                stack.clear();\n            }\n\
    \        }\n        return deepest_level_of_nesting;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvb9yppap.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n            if (ch == '(') left_brackets.add(i);\n                \
    \                             ^\n/tmp/tmpvb9yppap.java:24: error: incompatible\
    \ types: int cannot be converted to Long\n            if (ch == ')') right_brackets.add(i);\n\
    \                                              ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   ArrayList<Long> last_level = new ArrayList<>();\n        ArrayList<Long> current_level\
    \ = new ArrayList<>();\n        boolean isParenthesis = false;\n        boolean\
    \ isNesting = false;\n        boolean addParenthesis = false;\n        boolean\
    \ addNesting = false;\n        for (char ch : paren_string.toCharArray()) {\n\
    \            if (ch == '(') {\n                current_level.add(0l);\n      \
    \          addParenthesis = true;\n            }\n            else if (ch == ')')\
    \ {\n                current_level.remove(0);\n                addParenthesis\
    \ = false;\n            }\n            else if (ch == '(' && addParenthesis) {\n\
    \                addNesting = true;\n            }\n            else if (ch ==\
    \ ')' && addParenthesis) {\n                addNesting = false;\n            }\n\
    \            else if (ch == ')' && addNesting) {\n                result.add(current_level.get(0));\n\
    \                last_level.add(current_level.get(0));\n                current_level.remove(0);\n\
    \            }\n            else if (ch == ')' && !addNesting) {\n           \
    \     result.add(current_level.get(0));\n                current_level.remove(0);\n\
    \            }\n            else if (ch == '(' && !addNesting) {\n           \
    \     current_level.add(0l);\n                last_level.add(0l);\n          \
    \      addNesting = true;\n            }\n            else {\n               \
    \ current_level.add(0l);\n                last_level.add(0l);\n              \
    \  addNesting = false;\n            }\n        }\n        return result;\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3f_20r42.java:60)\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   paren_string = paren_string.trim();\n        paren_string = paren_string.replaceAll(\"\
    \\\\s+\", \" \"); // remove spaces and trim\n        paren_string = paren_string.replaceAll(\"\
    (?<=\\\\))(?=\\\\()\", \"\"); // remove any nesting within parens\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(\\\\s*(\\\\(.*?\\\\)\\\\s*)+\\\\s*\\\\)\",\
    \ \"$1\"); // remove empty groups and trim them all\n        paren_string = paren_string.replaceAll(\"\
    \\\\(.*?\\\\)\", \"\"); // remove any empty groups\n        paren_string = paren_string.replaceAll(\"\
    \\\\s*\\\\(\\\\s*\\\\)\\\\s*\", \"()\"); // remove any extra spaces surrounding\
    \ nested parentheses\n        for (String group: paren_string.split(\"\\\\s+\"\
    )) {\n            group = group.replaceAll(\"(^\\\\s*\\\\(\\\\s*)|(\\\\s*)\\\\\
    s*$)\", \"\"); // remove leading and trailing spaces\n            group = group.replaceAll(\"\
    \\\\(.*?\\\\)\", \"\"); // remove any empty groups\n            group = group.replaceAll(\"\
    \\\\(\\\\s*\\\\)\\\\s*\", \"()\"); // remove any extra spaces surrounding nested\
    \ parentheses\n            if (group.length() > 0) {\n                result.add(Long.valueOf(group.length()));\n\
    \            }\n        }\n        return result;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.regex.PatternSyntaxException: Unmatched\
    \ closing ')' near index 20\n(^\\s*\\(\\s*)|(\\s*)\\s*$)\n                   \
    \ ^\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1787)\n\
    \tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\
    \tat java.base/java.lang.String.replaceAll(String.java:2942)\n\tat Problem.parseNestedParens(tmp9yr_wq6d.java:23)\n\
    \tat Problem.main(tmp9yr_wq6d.java:33)\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, 0);\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3pxs5oew.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ 0);\n               ^\n  required: String\n  found:    String,int\n  reason:\
    \ actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        Stack<Long> stack = new Stack<Long>();\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        Long curr_level = 0;\n        Long\
    \ num_levels = 0;\n        for(char c : paren_string.toCharArray()) {\n      \
    \      if(c == '(' || c == '{' || c == '[') {\n                stack.push(curr_level);\n\
    \                curr_level++;\n            }\n            if(c == ')' || c ==\
    \ '}' || c == ']') {\n                curr_level = stack.pop();\n            \
    \    num_levels = curr_level;\n            }\n        }\n        while(!stack.isEmpty())\
    \ {\n            num_levels--;\n            stack.pop();\n        }\n        result.add(num_levels);\n\
    \        return result;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo3btuh12.java:17: error: incompatible types: int cannot be converted\
    \ to Long\n        Long curr_level = 0;\n                          ^\n/tmp/tmpo3btuh12.java:18:\
    \ error: incompatible types: int cannot be converted to Long\n        Long num_levels\
    \ = 0;\n                          ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_level = new ArrayList<>();\n\
    \        int counter = 0;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ deepest_level.add(counter);\n            else if (c == ')') deepest_level.remove(deepest_level.get(deepest_level.size()\
    \ - 1));\n            counter++;\n        }\n        return deepest_level;\n \
    \   }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwlzag6w9.java:19: error: incompatible types: int cannot be converted\
    \ to Long\n            if (c == '(') deepest_level.add(counter);\n           \
    \                                 ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String str = paren_string;\n        ArrayList<Long>\
    \ ls = new ArrayList<Long>();\n        ArrayList<String> strs = new ArrayList<String>();\n\
    \        ArrayList<String> output = new ArrayList<String>();\n        // Remove\
    \ trailing parentheses\n        str = str.trim().replaceAll(\"\\\\)$\", \"\");\n\
    \        str = str.trim().replaceAll(\"\\\\(+$\", \"\");\n        str = str.trim().replaceAll(\"\
    \\\\)+$\", \"\");\n        str = str.trim().replaceAll(\"\\\\(+\", \"\");\n  \
    \      str = str.trim().replaceAll(\"\\\\)+\", \"\");\n\n        // Split string\
    \ into groups of nested parentheses and remove them\n        str = str.replaceAll(\"\
    \\\\(|\\\\)\", \"\");\n        String[] strs = str.split(\"\\\\)|\\\\(\");\n \
    \       Arrays.stream(strs).forEach(s -> {\n            if (s.trim().equals(\"\
    ()\")) {\n                ls.add(0l);\n            } else {\n                strs.add(s);\n\
    \            }\n        });\n\n        // Use a stack to find deepest level of\
    \ nesting\n        Stack<Long> stack = new Stack<Long>();\n        Arrays.stream(strs).forEach(s\
    \ -> {\n            long level = 1;\n            for (char c : s.toCharArray())\
    \ {\n                if ((c == '(') && (stack.peek() < level)) {\n           \
    \         stack.push(level);\n                } else if ((c == '(') && (stack.peek()\
    \ > level)) {\n                    stack.peek() = level;\n                   \
    \ level++;\n                } else if (stack.peek() >= level) {\n            \
    \        level--;\n                }\n            }\n        });\n\n        //\
    \ Append the deepest level\n        stack.peek()++;\n        stack.forEach((level)\
    \ -> {\n            output.add(level + \"\");\n        });\n\n        // Return\
    \ the array list\n        return ls;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1fbmae4y.java:28: error: variable strs is already defined in method\
    \ parseNestedParens(String)\n        String[] strs = str.split(\"\\\\)|\\\\(\"\
    );\n                 ^\n/tmp/tmp1fbmae4y.java:33: error: cannot find symbol\n\
    \                strs.add(s);\n                    ^\n  symbol:   method add(String)\n\
    \  location: variable strs of type String[]\n/tmp/tmp1fbmae4y.java:45: error:\
    \ unexpected type\n                    stack.peek() = level;\n               \
    \               ^\n  required: variable\n  found:    value\n/tmp/tmp1fbmae4y.java:54:\
    \ error: unexpected type\n        stack.peek()++;\n                  ^\n  required:\
    \ variable\n  found:    value\n4 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> level_stack = new ArrayList<Long>();\n\
    \        ArrayList<Long> level_count = new ArrayList<Long>();\n        HashSet<Long>\
    \ paren_set = new HashSet<Long>();\n        int level = 0;\n        for(int i\
    \ = 0; i < paren_string.length(); i++) {\n            char c = paren_string.charAt(i);\n\
    \            // Check for open paren\n            if(c == '(') {\n           \
    \     // Push element into stack\n                level_stack.add(level);\n  \
    \              paren_set.add(level);\n                level++;\n            }\n\
    \            // Check for close paren\n            if(c == ')') {\n          \
    \      // Get the maximum depth of the stack\n                long max_level =\
    \ Collections.max(level_stack);\n                // If this level exists in our\
    \ count, add 1 to it\n                if(level_count.contains(max_level)) {\n\
    \                    level_count.set(level_stack.indexOf(max_level), level_count.get(level_stack.indexOf(max_level))+1);\n\
    \                } else {\n                    level_count.add(max_level);\n \
    \               }\n                // Pop the element from stack\n           \
    \     level_count = level_count.subList(0, level_stack.indexOf(max_level));\n\
    \                level_stack = level_stack.subList(1, level_stack.indexOf(max_level));\n\
    \                level--;\n            }\n        }\n        // Add the leftover\
    \ stack elements\n        level_count = level_count.subList(0, level_stack.size());\n\
    \        level_stack = level_stack.subList(1, level_stack.size());\n        //\
    \ Return the list with maximum levels\n        return level_count;\n    }\n  \
    \  public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6li358il.java:24: error: incompatible types: int cannot be converted\
    \ to Long\n                level_stack.add(level);\n                         \
    \       ^\n/tmp/tmp6li358il.java:25: error: incompatible types: int cannot be\
    \ converted to Long\n                paren_set.add(level);\n                 \
    \             ^\n/tmp/tmp6li358il.java:39: error: incompatible types: List<Long>\
    \ cannot be converted to ArrayList<Long>\n                level_count = level_count.subList(0,\
    \ level_stack.indexOf(max_level));\n                                         \
    \        ^\n/tmp/tmp6li358il.java:40: error: incompatible types: List<Long> cannot\
    \ be converted to ArrayList<Long>\n                level_stack = level_stack.subList(1,\
    \ level_stack.indexOf(max_level));\n                                         \
    \        ^\n/tmp/tmp6li358il.java:45: error: incompatible types: List<Long> cannot\
    \ be converted to ArrayList<Long>\n        level_count = level_count.subList(0,\
    \ level_stack.size());\n                                         ^\n/tmp/tmp6li358il.java:46:\
    \ error: incompatible types: List<Long> cannot be converted to ArrayList<Long>\n\
    \        level_stack = level_stack.subList(1, level_stack.size());\n         \
    \                                ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n6 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       Matcher m = Pattern.compile(\"\\\\(|\\\\)\")\n                .matcher(paren_string);\n\
    \        int count = 0;\n        while (m.find()) {\n            if (m.start()\
    \ != 0) {\n                result.add(new Long(count));\n            }\n     \
    \       result.add(new Long(m.end() + 1));\n            count++;\n        }\n\
    \        if (count > 0) {\n            result.add(new Long(count));\n        }\n\
    \        return result;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp33v2ia56.java:16: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"\\\\(|\\\\)\")\n        ^\n  symbol:   class Matcher\n \
    \ location: class Problem\n/tmp/tmp33v2ia56.java:16: error: cannot find symbol\n\
    \        Matcher m = Pattern.compile(\"\\\\(|\\\\)\")\n                    ^\n\
    \  symbol:   variable Pattern\n  location: class Problem\n/tmp/tmp33v2ia56.java:21:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                result.add(new Long(count));\n                           ^\n\
    /tmp/tmp33v2ia56.java:27: warning: [removal] Long(long) in Long has been deprecated\
    \ and marked for removal\n            result.add(new Long(count));\n         \
    \              ^\n2 errors\n2 warnings\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.trim().equals(\"\"))\n           \
    \ return new ArrayList<Long>();\n        ArrayList<Long> result_list = new ArrayList<Long>();\n\
    \        StringTokenizer tokens = new StringTokenizer(paren_string, \"( )\");\n\
    \        while (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\
    \            result_list.add(paren_length(token));\n        }\n        return\
    \ result_list;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjnae54ee.java:21: error: cannot find symbol\n            result_list.add(paren_length(token));\n\
    \                            ^\n  symbol:   method paren_length(String)\n  location:\
    \ class Problem\n1 error\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 4
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_pars = new ArrayList<>();\n\
    \        String[] split_parens = paren_string.split(\" \");\n        for(String\
    \ str : split_parens) {\n            String[] split_str = str.split(\"(\");\n\
    \            for(String str2 : split_str) {\n                String[] split_str2\
    \ = str2.split(\")\");\n                for(String str3 : split_str2) {\n    \
    \                String[] split_str3 = str3.split(\")(\");\n                 \
    \   for(String str4 : split_str3) {\n                        String[] split_str4\
    \ = str4.split(\")(\");\n                        for(String str5 : split_str4)\
    \ {\n                            String[] split_str5 = str5.split(\")(\");\n \
    \                           for(String str6 : split_str5) {\n                \
    \                String[] split_str6 = str6.split(\")(\");\n                 \
    \               for(String str7 : split_str6) {\n                            \
    \        String[] split_str7 = str7.split(\")(\");\n                         \
    \           for(String str8 : split_str7) {\n                                \
    \        String[] split_str8 = str8.split(\")(\");\n                         \
    \               for(String str9 : split_str8) {\n                            \
    \                String[] split_str9 = str9.split(\")(\");\n                 \
    \                           for(String str10 : split_str9) {\n               \
    \                                 String[] split_str10 = str10.split(\")(\");\n\
    \                                                for(String str11 : split_str10)\
    \ {\n                                                    String[] split_str11\
    \ = str11.split(\")(\");\n                                                   \
    \ for(String str12 : split_str11) {\n                                        \
    \                String[] split_str12 = str12.split(\")(\");\n               \
    \                                         for(String str13 : split_str12) {\n\
    \                                                            String[] split_str13\
    \ = str13.split(\")(\");\n                                                   \
    \         for(String str14 : split_str13) {\n                                \
    \                                String[] split_str14 = str14.split(\")(\");\n\
    \                                                                for(String str15\
    \ : split_str14) {\n                                                         \
    \           String[] split_str15 = str15.split(\")(\");\n                    \
    \                                                for(String str16 : split_str15)\
    \ {\n                                                                        String[]\
    \ split_str16 = str16.split(\")(\");\n                                       \
    \                                 for(String str17 : split_str16) {\n        \
    \                                                                    String[]\
    \ split_str17 = str17.split(\")(\");\n                                       \
    \                                     for(String str18 : split_str17) {\n    \
    \                                                                            String[]\
    \ split_str18 = str18.split(\")(\");\n                                       \
    \                                         for(String str19 : split_str18) {\n\
    \                                                                            \
    \        String[] split_str19 = str19.split(\")(\");\n                       \
    \                                                             for(String str20\
    \ : split_str19) {\n                                                         \
    \                               String[] split_str20 = str20.split(\")(\");\n\
    \                                                                            \
    \            nested_pars.add(Long.parseLong(str20));\n                       \
    \                                                 }\n                        \
    \                                            }\n                             \
    \                                   }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphi1_24ft.java:62: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n1 error\nprinting javac parameters\
    \ to: /work/arjunguha-research-group/repos/polyglot-codegen-evaluation/src/javac.20220808_221720.args\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Use recursion to keep track of depth of parenthesis\n\
    \        // and make a new list to return\n        ArrayList<Long> max_levels\
    \ = new ArrayList<>();\n        ArrayList<Long> result = new ArrayList<>();\n\
    \        boolean has_parentheses = true;\n\n        // Use a stack to hold nested\
    \ parentheses\n        Deque<String> stack = new ArrayDeque<>();\n        // Use\
    \ a set to keep track of parentheses opened by previous parenthesis\n        Set<String>\
    \ parentheses_opened = new HashSet<>();\n        // Use a set to keep track of\
    \ parentheses closed by previous parenthesis\n        Set<String> parentheses_closed\
    \ = new HashSet<>();\n        // Use a set to keep track of parentheses that have\
    \ been seen before\n        // Used to avoid duplicate parenthesis\n        Set<String>\
    \ parentheses_seen = new HashSet<>();\n\n        // Get all the parentheses and\
    \ put them in the stack\n        for (char character : paren_string.toCharArray())\
    \ {\n            if (character == '(') {\n                stack.push(\"\"); //\
    \ Open the parentheses in the stack\n            } else if (character == ')')\
    \ {\n                String current_stack = stack.pop();\n                if (current_stack\
    \ == null) {\n                    has_parentheses = false;\n                }\
    \ else {\n                    // Add 1 to depth and check if it's a nested one\n\
    \                    long depth = Long.parseLong(current_stack) + 1;\n       \
    \             if (max_levels.size() <= depth) {\n                        max_levels.set(depth,\
    \ 1l);\n                        result.add(depth);\n                    } else\
    \ {\n                        max_levels.set(depth, Math.max(max_levels.get(depth),\
    \ 1l));\n                    }\n                }\n            }\n        }\n\n\
    \        if (has_parentheses) {\n            // Now pop from the stack to get\
    \ the maximum level of nesting\n            String current_stack = stack.pop();\n\
    \            // Add 1 to depth and check if it's a nested one\n            long\
    \ depth = Long.parseLong(current_stack) + 1;\n            if (max_levels.size()\
    \ <= depth) {\n                max_levels.set(depth, 1l);\n                result.add(depth);\n\
    \            } else {\n                max_levels.set(depth, Math.max(max_levels.get(depth),\
    \ 1l));\n            }\n        }\n        return result;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1ikfcsr6.java:43: error: incompatible types: possible lossy conversion\
    \ from long to int\n                        max_levels.set(depth, 1l);\n     \
    \                                  ^\n/tmp/tmp1ikfcsr6.java:46: error: incompatible\
    \ types: possible lossy conversion from long to int\n                        max_levels.set(depth,\
    \ Math.max(max_levels.get(depth), 1l));\n                                    \
    \                                  ^\n/tmp/tmp1ikfcsr6.java:58: error: incompatible\
    \ types: possible lossy conversion from long to int\n                max_levels.set(depth,\
    \ 1l);\n                               ^\n/tmp/tmp1ikfcsr6.java:61: error: incompatible\
    \ types: possible lossy conversion from long to int\n                max_levels.set(depth,\
    \ Math.max(max_levels.get(depth), 1l));\n                                    \
    \                          ^\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n4 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   if (paren_string.trim().isEmpty())\n            return result;\n\n       \
    \ String[] paren_strings = paren_string.trim().split(\"\\\\s\");\n        ArrayList<Integer>\
    \ nesting = new ArrayList<>();\n\n        // Count the number of opening brackets\
    \ that have been encountered\n        // and store them in a stack\n        Stack<Integer>\
    \ open_brackets = new Stack<>();\n        // We start counting nesting levels\
    \ from zero.\n        int i = 0;\n        while (i < paren_strings.length) {\n\
    \            String current = paren_strings[i];\n            if (current.equals(\"\
    (\"))\n                open_brackets.push(0);\n            else if (current.equals(\"\
    )\"))\n                open_brackets.pop();\n            else if (open_brackets.isEmpty()\
    \ || open_brackets.peek() != 0) {\n                nesting.add((long) nesting.size());\n\
    \                result.add(nesting.size());\n            }\n            i++;\n\
    \        }\n\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14hzt08m.java:34: error: incompatible types: long cannot be converted\
    \ to Integer\n                nesting.add((long) nesting.size());\n          \
    \                  ^\n/tmp/tmp14hzt08m.java:35: error: incompatible types: int\
    \ cannot be converted to Long\n                result.add(nesting.size());\n \
    \                                      ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011440
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Find each pair with '(' and ')'\n        final String\
    \ nestedBracketsRegex = \"\\\\(([^()]*+|(?R))\\\\)\";\n        final Pattern nestedBracketsPattern\
    \ = Pattern.compile(nestedBracketsRegex);\n        // Find each pair with '['\
    \ and ']'\n        final String nestedBracketsRegex2 = \"\\\\[([^\\\\[\\\\]]*+|(?R))\\\
    \\]\";\n        final Pattern nestedBracketsPattern2 = Pattern.compile(nestedBracketsRegex2);\n\
    \        // Find each pair with '{' and '}'\n        final String nestedBracketsRegex3\
    \ = \"\\\\{([^\\\\{\\\\}]*+|(?R))\\\\}\";\n        final Pattern nestedBracketsPattern3\
    \ = Pattern.compile(nestedBracketsRegex3);\n        \n        final Matcher nestedBracketsMatcher\
    \ = nestedBracketsPattern.matcher(paren_string);\n        final Matcher nestedBracketsMatcher2\
    \ = nestedBracketsPattern2.matcher(paren_string);\n        final Matcher nestedBracketsMatcher3\
    \ = nestedBracketsPattern3.matcher(paren_string);\n\n        final String matchedString1\
    \ = nestedBracketsMatcher.replaceAll(\"[$1]\");\n        final String matchedString2\
    \ = nestedBracketsMatcher2.replaceAll(\"[$1]\");\n        final String matchedString3\
    \ = nestedBracketsMatcher3.replaceAll(\"[$1]\");\n        \n        \n       \
    \ ArrayList<Long> result = new ArrayList<Long>();\n        Matcher nestedBracketsMatcher3\
    \ = nestedBracketsPattern3.matcher(matchedString1);\n        Matcher nestedBracketsMatcher2\
    \ = nestedBracketsPattern2.matcher(matchedString2);\n        Matcher nestedBracketsMatcher1\
    \ = nestedBracketsPattern1.matcher(matchedString3);\n        while(nestedBracketsMatcher1.find()\
    \ || nestedBracketsMatcher2.find() || nestedBracketsMatcher3.find()) {\n     \
    \       if (nestedBracketsMatcher1.find()) {\n                result.add(Long.parseLong(nestedBracketsMatcher1.group(1)));\n\
    \            }\n            if (nestedBracketsMatcher2.find()) {\n           \
    \     result.add(Long.parseLong(nestedBracketsMatcher2.group(1)));\n         \
    \   }\n            if (nestedBracketsMatcher3.find()) {\n                result.add(Long.parseLong(nestedBracketsMatcher3.group(1)));\n\
    \            }\n        }\n        \n        \n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsx2lnizj.java:17: error: cannot find symbol\n        final Pattern\
    \ nestedBracketsPattern = Pattern.compile(nestedBracketsRegex);\n            \
    \  ^\n  symbol:   class Pattern\n  location: class Problem\n/tmp/tmpsx2lnizj.java:17:\
    \ error: cannot find symbol\n        final Pattern nestedBracketsPattern = Pattern.compile(nestedBracketsRegex);\n\
    \                                              ^\n  symbol:   variable Pattern\n\
    \  location: class Problem\n/tmp/tmpsx2lnizj.java:20: error: cannot find symbol\n\
    \        final Pattern nestedBracketsPattern2 = Pattern.compile(nestedBracketsRegex2);\n\
    \              ^\n  symbol:   class Pattern\n  location: class Problem\n/tmp/tmpsx2lnizj.java:20:\
    \ error: cannot find symbol\n        final Pattern nestedBracketsPattern2 = Pattern.compile(nestedBracketsRegex2);\n\
    \                                               ^\n  symbol:   variable Pattern\n\
    \  location: class Problem\n/tmp/tmpsx2lnizj.java:23: error: cannot find symbol\n\
    \        final Pattern nestedBracketsPattern3 = Pattern.compile(nestedBracketsRegex3);\n\
    \              ^\n  symbol:   class Pattern\n  location: class Problem\n/tmp/tmpsx2lnizj.java:23:\
    \ error: cannot find symbol\n        final Pattern nestedBracketsPattern3 = Pattern.compile(nestedBracketsRegex3);\n\
    \                                               ^\n  symbol:   variable Pattern\n\
    \  location: class Problem\n/tmp/tmpsx2lnizj.java:25: error: cannot find symbol\n\
    \        final Matcher nestedBracketsMatcher = nestedBracketsPattern.matcher(paren_string);\n\
    \              ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpsx2lnizj.java:26:\
    \ error: cannot find symbol\n        final Matcher nestedBracketsMatcher2 = nestedBracketsPattern2.matcher(paren_string);\n\
    \              ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpsx2lnizj.java:27:\
    \ error: cannot find symbol\n        final Matcher nestedBracketsMatcher3 = nestedBracketsPattern3.matcher(paren_string);\n\
    \              ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpsx2lnizj.java:35:\
    \ error: cannot find symbol\n        Matcher nest"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<Long> levels = new ArrayList<>();\n        for\
    \ (char c : paren_string.toCharArray()) {\n            switch (c) {\n        \
    \        case '(':\n                    levels.add(0l);\n                    break;\n\
    \                case ')':\n                    levels.add(levels.get(levels.size()\
    \ - 1l));\n                    break;\n                default:\n            \
    \        if (Character.isLetterOrDigit(c)) {\n                        levels.add(1l);\n\
    \                    }\n            }\n        }\n        return levels;\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkrcrfcw8.java:22: error: incompatible types: possible lossy conversion\
    \ from long to int\n                    levels.add(levels.get(levels.size() -\
    \ 1l));\n                                                        ^\n/tmp/tmpkrcrfcw8.java:30:\
    \ error: incompatible types: List<Long> cannot be converted to ArrayList<Long>\n\
    \        return levels;\n               ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parsed_list = new ArrayList<Long>();\n\
    \        if (paren_string.trim().isEmpty()) {\n            return parsed_list;\n\
    \        }\n        String[] split_string = paren_string.trim().split(\"\\\\s+\"\
    );\n        for (String s : split_string) {\n            parsed_list.add(parseParens(s));\n\
    \        }\n        return parsed_list;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2mawkgsv.java:21: error: cannot find symbol\n            parsed_list.add(parseParens(s));\n\
    \                            ^\n  symbol:   method parseParens(String)\n  location:\
    \ class Problem\n1 error\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Parse the string into a nested parenthesis groups\
    \ and store into a HashSet\n        HashSet<String> nested_paren_groups = HashSet<String>();\n\
    \        for (String group : paren_string.split(\" \")) {\n            nested_paren_groups.add(group);\n\
    \        }\n        ArrayList<Long> max_nesting_levels = new ArrayList<Long>();\n\
    \        // Go through each of the groups and find their deepest level of nesting\n\
    \        for (String group : nested_paren_groups) {\n            String deepest_level_of_nesting\
    \ = group;\n            int depth = 1;\n            while (!nested_paren_groups.contains(deepest_level_of_nesting))\
    \ {\n                deepest_level_of_nesting = \"(\" + deepest_level_of_nesting\
    \ + \")\";\n                depth++;\n            }\n            max_nesting_levels.add(depth);\n\
    \        }\n        return max_nesting_levels;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvro0dnx4.java:16: error: -> expected\n        HashSet<String> nested_paren_groups\
    \ = HashSet<String>();\n                                                     \
    \          ^\n1 error\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   StringBuilder buffer = new StringBuilder();\n        for (String str : paren_string.split(\"\
    \\\\s+\")) {\n            buffer.append(str);\n            buffer.append(\" \"\
    );\n        }\n        buffer.deleteCharAt(buffer.length() - 1);\n        buffer.trim();\n\
    \        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <\
    \ buffer.length(); i++) {\n            char c = buffer.charAt(i);\n          \
    \  if (c == '(') {\n                sb.append(buffer.substring(i + 1, buffer.length()));\n\
    \            }\n            else if (c == ')') {\n                Long l = Long.valueOf(sb);\n\
    \                result.add(l);\n                sb.deleteCharAt(sb.length() -\
    \ 1);\n                sb.trim();\n            }\n            else if (c == '\\\
    \\') {\n                String str = sb.toString();\n                int escaped_char\
    \ = buffer.charAt(i);\n                if (escaped_char == '\\\\') {\n       \
    \             i++;\n                    String escaped_str = buffer.substring(i\
    \ + 1, buffer.length());\n                    result.add(Long.valueOf(escaped_str));\n\
    \                    sb.deleteCharAt(sb.length() - 1);\n                    sb.deleteCharAt(sb.length()\
    \ - 1);\n                    sb.trim();\n                }\n            }\n  \
    \          else {\n                sb.append(c);\n            }\n        }\n \
    \       ArrayList<Long> result_list = new ArrayList<>();\n        result_list.add(Long.valueOf(sb));\n\
    \        ArrayList<Long> result_list_deep = new ArrayList<>();\n        for (Long\
    \ l : result) {\n            int level = Integer.parseInt(sb.toString());\n  \
    \          result_list_deep.add(l);\n            if (level == 0)\n           \
    \     break;\n            else\n                sb.deleteCharAt(sb.length() -\
    \ 1);\n        }\n        return result_list_deep;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvii76swv.java:22: error: cannot find symbol\n        buffer.trim();\n\
    \              ^\n  symbol:   method trim()\n  location: variable buffer of type\
    \ StringBuilder\n/tmp/tmpvii76swv.java:30: error: no suitable method found for\
    \ valueOf(StringBuilder)\n                Long l = Long.valueOf(sb);\n       \
    \                      ^\n    method Long.valueOf(String) is not applicable\n\
    \      (argument mismatch; StringBuilder cannot be converted to String)\n    method\
    \ Long.valueOf(long) is not applicable\n      (argument mismatch; StringBuilder\
    \ cannot be converted to long)\n/tmp/tmpvii76swv.java:33: error: cannot find symbol\n\
    \                sb.trim();\n                  ^\n  symbol:   method trim()\n\
    \  location: variable sb of type StringBuilder\n/tmp/tmpvii76swv.java:44: error:\
    \ cannot find symbol\n                    sb.trim();\n                      ^\n\
    \  symbol:   method trim()\n  location: variable sb of type StringBuilder\n/tmp/tmpvii76swv.java:52:\
    \ error: no suitable method found for valueOf(StringBuilder)\n        result_list.add(Long.valueOf(sb));\n\
    \                            ^\n    method Long.valueOf(String) is not applicable\n\
    \      (argument mismatch; StringBuilder cannot be converted to String)\n    method\
    \ Long.valueOf(long) is not applicable\n      (argument mismatch; StringBuilder\
    \ cannot be converted to long)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n5 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String[] paren_strings = paren_string.trim().split(\"\
    \ +\");\n\n        ArrayList<Long> max_level = new ArrayList<Long>();\n      \
    \  // Keep track of current level of nesting.\n        long level = 0;\n     \
    \   for (String sub_string : paren_strings) {\n            ArrayList<Long> sub_levels\
    \ = parseNestedParens(sub_string);\n            if (sub_levels.size() > level)\
    \ {\n                max_level = sub_levels;\n            }\n            level\
    \ += sub_levels.size();\n        }\n        max_level.add(level);\n        return\
    \ max_level;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.regex.PatternSyntaxException: Stack\
    \ overflow during pattern compilation near index 0\n +\n^\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1432)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\
    \tat java.base/java.lang.String.split(String.java:3153)\n\tat java.base/java.lang.String.split(String.java:3199)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:15)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\
    \tat Problem.parseNestedParens(tmp8lsvpe8v.java:21)\n\tat Problem.parseNestedParens(tmp8lsvp"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nestedParens = new ArrayList<>();\n\
    \        Stack<String> parenStack = new Stack<>();\n        boolean inParen =\
    \ false;\n        boolean lastIsParen = false;\n        Long lastLevel = null;\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char c\
    \ = paren_string.charAt(i);\n            if (c == '(') {\n                if (lastIsParen)\
    \ {\n                    lastIsParen = false;\n                    parenStack.pop();\n\
    \                    lastLevel = parenStack.peek();\n                }\n     \
    \           else {\n                    parenStack.push(c);\n                \
    \    inParen = true;\n                }\n            }\n            else if (c\
    \ == '(') {\n                if (!inParen) {\n                    parenStack.push(c);\n\
    \                    inParen = true;\n                }\n            }\n     \
    \       else if (c == ')') {\n                if (inParen) {\n               \
    \     parenStack.pop();\n                    inParen = false;\n              \
    \  }\n                else {\n                    if (lastLevel != null && lastLevel.longValue()\
    \ >= nestedParens.size()) {\n                        nestedParens.add(lastLevel.longValue());\n\
    \                    }\n                }\n            }\n            else if\
    \ (c == ')') {\n                if (!inParen) {\n                    parenStack.pop();\n\
    \                    inParen = false;\n                }\n            }\n    \
    \        else if (c == '\\n' || c == ' ') {\n                if (inParen) {\n\
    \                    parenStack.pop();\n                    inParen = false;\n\
    \                }\n            }\n            else {\n                lastIsParen\
    \ = false;\n                lastLevel = null;\n            }\n        }\n    \
    \    return nestedParens;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj6phd_cg.java:26: error: incompatible types: String cannot be converted\
    \ to Long\n                    lastLevel = parenStack.peek();\n              \
    \                                 ^\n/tmp/tmpj6phd_cg.java:29: error: incompatible\
    \ types: char cannot be converted to String\n                    parenStack.push(c);\n\
    \                                    ^\n/tmp/tmpj6phd_cg.java:35: error: incompatible\
    \ types: char cannot be converted to String\n                    parenStack.push(c);\n\
    \                                    ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Get the groups of nested parentheses separated by\
    \ spaces.\n        ArrayList<ArrayList<String>> groups = paren_string.split(\"\
    ( )\");\n        // Initialize the result array list.\n        ArrayList<Long>\
    \ res = new ArrayList<>();\n        // Initialize a long variable to store the\
    \ deepest level of nesting.\n        long maxNesting = 1;\n        // Loop through\
    \ each group of parentheses and calculate the deepest level of nesting.\n    \
    \    for (ArrayList<String> group : groups) {\n            // Get the length of\
    \ each parentheses.\n            int len = 0;\n            // Loop to get the\
    \ length of each parentheses.\n            for (String s : group) {\n        \
    \        len += s.length();\n            }\n            // Get the number of parentheses.\n\
    \            int numOfParentheses = group.length() - len;\n            // Get\
    \ the length of the deepest parentheses.\n            long deepness = numOfParentheses\
    \ * maxNesting;\n            // Update the deepest level of nesting if needed.\n\
    \            if (deepness > maxNesting) {\n                maxNesting = deepness;\n\
    \            }\n            // Add the number of parentheses to the result array.\n\
    \            res.add(deepness);\n        }\n        // Return the result array\
    \ list.\n        return res;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpffa4xi1p.java:16: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<ArrayList<String>>\n        ArrayList<ArrayList<String>>\
    \ groups = paren_string.split(\"( )\");\n                                    \
    \                            ^\n/tmp/tmpffa4xi1p.java:30: error: cannot find symbol\n\
    \            int numOfParentheses = group.length() - len;\n                  \
    \                      ^\n  symbol:   method length()\n  location: variable group\
    \ of type ArrayList<String>\n2 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>(Arrays.asList(1l,\
    \ 1l, 1l, 1l, 1l));\n        for(String group: paren_string.trim().split(\" \"\
    )) {\n            String innermost_level = \"\";\n            int depth = 0;\n\
    \            for(char c: group.toCharArray()) {\n                if(c == '(')\
    \ {\n                    depth++;\n                    innermost_level += c;\n\
    \                } else if(c == ')') {\n                    depth--;\n       \
    \             innermost_level += c;\n                    if(depth == 0) result.add(Long.valueOf(innermost_level.length()));\n\
    \                }\n            }\n        }\n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_kaxdx5u.java:33)\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Your code goes here\n        return null;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke\
    \ \"java.util.ArrayList.equals(Object)\" because the return value of \"Problem.parseNestedParens(String)\"\
    \ is null\n\tat Problem.main(tmpp9rwvyq4.java:19)\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> answer = new ArrayList<>();\n     \
    \   List<String> groups = paren_string.trim().split(\"\\\\s+\");\n        for\
    \ (String group : groups) {\n            if (group.isEmpty()) continue;\n    \
    \        Long current_level = 1l;\n            boolean last_char_open = false;\n\
    \            boolean last_char_close = false;\n            for (int i = 0; i <\
    \ group.length(); i++) {\n                char c = group.charAt(i);\n        \
    \        if (last_char_open) {\n                    if (c == '(') current_level++;\n\
    \                    else if (c == ')') current_level--;\n                   \
    \ if (current_level == 0) {\n                        answer.add(current_level);\n\
    \                        last_char_open = false;\n                        last_char_close\
    \ = false;\n                    }\n                }\n                if ((last_char_open\
    \ && last_char_close) || (c == '(' && !last_char_open) || (c == ')' && !last_char_close))\
    \ {\n                    last_char_open = last_char_close ? (c == ')') : (c ==\
    \ '(');\n                    last_char_close = c;\n                }\n       \
    \     }\n        }\n        return answer;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5bfule30.java:16: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> groups = paren_string.trim().split(\"\
    \\\\s+\");\n                                                       ^\n/tmp/tmp5bfule30.java:35:\
    \ error: incompatible types: char cannot be converted to boolean\n           \
    \         last_char_close = c;\n                                      ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        int level = 0;\n        long current_sum = 0;\n   \
    \     ArrayList<Long> sums = new ArrayList<Long>();\n        Scanner scanner =\
    \ new Scanner(paren_string);\n        while(scanner.hasNext()) {\n           \
    \ if (scanner.hasNextInt()) current_sum += scanner.nextInt();\n            else\
    \ if (scanner.hasNextLong()) current_sum += scanner.nextLong();\n            else\
    \ throw new RuntimeException(\"Invalid input!\");\n            level++;\n    \
    \        if (scanner.hasNext()) {\n                sums.add(current_sum);\n  \
    \              current_sum = 0;\n                level--;\n            }\n   \
    \     }\n        scanner.close();\n        if (level > 0) sums.add(current_sum);\n\
    \        return sums;\n    }\n    public static void main(String[] args) {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.RuntimeException: Invalid input!\n\
    \tat Problem.parseNestedParens(tmpxac7441l.java:22)\n\tat Problem.main(tmpxac7441l.java:35)\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> maxLevels = new ArrayList<Long>();\n\
    \        if (paren_string.length() <= 0) {\n            return maxLevels;\n  \
    \      }\n\n        // Convert string into array of characters and split into\
    \ groups\n        String[] groups = paren_string.split(\" \");\n\n        // For\
    \ each of the groups\n        for (String group : groups) {\n            // If\
    \ this group has more opening parentheses than closing parentheses, set the max\
    \ levels to this\n            // group\n            if (group.matches(\".*\\\\\
    (.*\\\\)$\"))\n                maxLevels.add(1l);\n\n            // Otherwise,\
    \ this group has more than one level of nesting\n            else if (group.matches(\"\
    .*\\\\(.*\\\\)+.*\"))\n                // Get the index of the last parenthesis\
    \ in this group\n                int last_index = group.lastIndexOf(')');\n  \
    \              // Increment the max level of nesting by one for each opening parenthesis\
    \ \n                // between last_index and (group.length() - 1)\n         \
    \       maxLevels.add(last_index + 1 - (group.length() - 1));\n        }\n\n \
    \       // Return the max levels\n        return maxLevels;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptsz_hzka.java:33: error: variable declaration not allowed here\n\
    \                int last_index = group.lastIndexOf(')');\n                  \
    \  ^\n1 error\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       paren_string = paren_string.trim();\n        if (paren_string.isEmpty())\
    \ {\n            return result;\n        }\n\n        String[] par_lists = paren_string.split(\"\
    \\\\s+\");\n        for (String par : par_lists) {\n            long level_of_nesting\
    \ = 0;\n            par = par.trim();\n            if (par.isEmpty()) {\n    \
    \            continue;\n            }\n            par = par.replace(\"(\", \"\
    \");\n            par = par.replace(\")\", \"\");\n            par = par.replaceAll(\"\
    \\\\s\", \"\");\n\n            String[] par_lists_2 = par.split(\"\\\\)\\\\s\"\
    );\n\n            for (String par_2 : par_lists_2) {\n                par_2 =\
    \ par_2.trim();\n                if (par_2.isEmpty()) {\n                    continue;\n\
    \                }\n                par_2 = par_2.replace(\"(\", \"\");\n    \
    \            par_2 = par_2.replace(\")\", \"\");\n                par_2 = par_2.replaceAll(\"\
    \\\\s\", \"\");\n                level_of_nesting = Math.max(level_of_nesting,\
    \ par_2.length());\n            }\n            result.add(level_of_nesting);\n\
    \        }\n\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_gevh7ic.java:50)\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   // We need to keep track of how many open/close parentheses we see in each\
    \ group\n        // This is also the number of parentheses we expect to be in\
    \ each group\n        Map<String, Integer> open_close_paren_count = new HashMap<>();\n\
    \        open_close_paren_count.put(\"()\", -1);\n        open_close_paren_count.put(\"\
    {}\", -1);\n\n        // Go through the groups and track how many open and close\
    \ parentheses we see in each group\n        for (String group : paren_string.split(\"\
    \ \")) {\n            open_close_paren_count.put(group, open_close_paren_count.get(group)\
    \ + 1);\n        }\n\n        // Now we go through the groups and see if we can\
    \ figure out how many groups will be there\n        // E.g. (()) will have a group\
    \ of one open and one close parentheses, while\n        // ((())) will have a\
    \ group of two open and one close parentheses.\n        // We then add this to\
    \ the result.\n        int group_size = 0;\n        for (String group : open_close_paren_count.keySet())\
    \ {\n            if (open_close_paren_count.get(group) == 1) {\n             \
    \   result.add(group_size);\n            }\n            group_size = group_size\
    \ + open_close_paren_count.get(group);\n        }\n\n        // And we add one\
    \ more group to the result because we expect to have one more group of parens\n\
    \        result.add(group_size);\n\n        return result;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoofi2_m6.java:34: error: incompatible types: int cannot be converted\
    \ to Long\n                result.add(group_size);\n                         \
    \  ^\n/tmp/tmpoofi2_m6.java:40: error: incompatible types: int cannot be converted\
    \ to Long\n        result.add(group_size);\n                   ^\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        Stack<Long> s = new Stack<Long>();\n        // Stack\
    \ will contain (size of string) long values\n        for (String s : paren_string.split(\"\
    \ \")) {\n            if (s.matches(\".*\\\\(.*\\\\).*\")) {\n               \
    \ String sub_s = \"\";\n                // For each opening bracket, push it into\
    \ the stack first\n                for (int i = 0; i < s.length(); i++) {\n  \
    \                  String ch = s.substring(i, i + 1);\n                    if\
    \ (ch.equals(\"(\")) {\n                        s.push(new Long(Long.parseLong(sub_s));\n\
    \                    }\n                    if (ch.equals(\")\")) {\n        \
    \                String top_s = s.pop().toString();\n                        if\
    \ (top_s.equals(\"(\")) {\n                            // This is an edge case\
    \ where there can be no opening bracket\n                            // but an\
    \ ending bracket but we still need to push the closing bracket into the stack.\n\
    \                            s.push(new Long(Long.parseLong(sub_s.substring(0,\
    \ sub_s.length() - 1)));\n                            break;\n               \
    \         }\n                        sub_s = \"\";\n                    }\n  \
    \                  sub_s += ch;\n                }\n            }\n        }\n\
    \        // Return the stack\n        return new ArrayList<Long>(s);\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i99nwqk.java:24: error: ')' expected\n                       \
    \ s.push(new Long(Long.parseLong(sub_s));\n                                  \
    \                            ^\n/tmp/tmp2i99nwqk.java:31: error: ')' expected\n\
    \                            s.push(new Long(Long.parseLong(sub_s.substring(0,\
    \ sub_s.length() - 1)));\n                                                   \
    \                                                ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_list = new ArrayList<>();\n \
    \       Stack<String> opening_stack = new Stack<>();\n        Stack<String> closing_stack\
    \ = new Stack<>();\n        List<Long> levels = new ArrayList<>();\n\n       \
    \ for (int i = 0; i < paren_string.length(); i++) {\n            if (paren_string.charAt(i)\
    \ == '(') {\n                opening_stack.add(paren_string.substring(i, i + 1));\n\
    \                levels.add(0);\n            }\n            else if (paren_string.charAt(i)\
    \ == ')') {\n                if (opening_stack.isEmpty()) {\n                \
    \    throw new RuntimeException(\"Unexpected end of parens.\");\n            \
    \    }\n                closing_stack.add(paren_string.substring(i, i + 1));\n\
    \                while (opening_stack.peek().equals(closing_stack.pop())) {\n\
    \                    levels.add(0, levels.get(0) + 1);\n                }\n  \
    \              opening_stack.pop();\n            }\n            else if (paren_string.charAt(i)\
    \ == ' ') {\n                levels.add(levels.get(levels.size() - 1) + 1);\n\
    \            }\n        }\n        if (opening_stack.isEmpty()) {\n          \
    \  throw new RuntimeException(\"Unexpected end of parens.\");\n        }\n\n \
    \       while (levels.size() > 1) {\n            paren_list.add(levels.get(levels.size()\
    \ - 2));\n            levels.remove(levels.size() - 1);\n        }\n        return\
    \ paren_list;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp129ontsj.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n                levels.add(0);\n                           ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n\n   \
    \     StringBuilder stringBuilder = new StringBuilder();\n        for (char character\
    \ : paren_string.toCharArray()) {\n            switch (character) {\n        \
    \        case '(':\n                    stringBuilder.append('(');\n         \
    \           break;\n                case ')':\n                    stringBuilder.append(')');\n\
    \                    break;\n                default:\n                    stringBuilder.append(character);\n\
    \                    break;\n            }\n        }\n\n        ArrayList <Long>\
    \ paras = new ArrayList<>();\n        for (String para_str : stringBuilder.toString().split(\"\
    \\\\s+\")) {\n            paras.add(Long.parseLong(para_str));\n        }\n\n\
    \        levels.add(0l);\n        int level = 1;\n        for (long para_val :\
    \ paras) {\n            if (level > levels.size()) {\n                levels.add(level);\n\
    \            } else {\n                int new_level = levels.get(level);\n  \
    \              if (levels.get(level - 1) < new_level) {\n                    levels.add(level,\
    \ new_level);\n                }\n            }\n            level++;\n      \
    \  }\n        return levels;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8giuz1g.java:41: error: incompatible types: int cannot be converted\
    \ to Long\n                levels.add(level);\n                           ^\n\
    /tmp/tmp_8giuz1g.java:43: error: incompatible types: Long cannot be converted\
    \ to int\n                int new_level = levels.get(level);\n               \
    \                           ^\n/tmp/tmp_8giuz1g.java:45: error: incompatible types:\
    \ int cannot be converted to Long\n                    levels.add(level, new_level);\n\
    \                                      ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_parentheses_levels = new ArrayList<>();\n\
    \        ArrayList<Long> parentheses_levels = new ArrayList<>();\n        ArrayList<String>\
    \ groups = new ArrayList<>();\n        ArrayList<Long> parentheses_lengths = new\
    \ ArrayList<>();\n        ArrayList<Long> parentheses_levels_tmp = new ArrayList<>();\n\
    \        ArrayList<Long> parentheses_lengths_tmp = new ArrayList<>();\n      \
    \  ArrayList<Long> parentheses_lengths_tmp2 = new ArrayList<>();\n        ArrayList<String>\
    \ group_tmp = new ArrayList<>();\n        ArrayList<Long> level_tmp = new ArrayList<>();\n\
    \        int startIndex = 0;\n        boolean matchFound = false;\n        boolean\
    \ matchFound2 = false;\n        while (!paren_string.equals(\"\") && parentheses_lengths.size()\
    \ < (paren_string.length() - 1)) {\n            if (paren_string.charAt(0) ==\
    \ '(') {\n                parentheses_lengths.add(parentheses_lengths.get(startIndex));\n\
    \                parentheses_lengths_tmp.clear();\n                parentheses_levels.add(parentheses_levels.get(startIndex));\n\
    \                parentheses_levels_tmp.clear();\n                parentheses_lengths_tmp2.clear();\n\
    \                groups.add(group_tmp);\n                group_tmp.clear();\n\
    \                level_tmp.clear();\n                parentheses_lengths.add(parentheses_lengths.get(startIndex));\n\
    \                startIndex++;\n            } else if (paren_string.charAt(0)\
    \ == ')') {\n                parentheses_lengths_tmp.add(parentheses_lengths_tmp.get(startIndex));\n\
    \                parentheses_lengths_tmp2.clear();\n                parentheses_levels_tmp.add(parentheses_levels_tmp.get(startIndex));\n\
    \                startIndex++;\n            } else if (paren_string.charAt(0)\
    \ == ' ') {\n                group_tmp.clear();\n                level_tmp.clear();\n\
    \                parentheses_lengths_tmp.add(parentheses_lengths_tmp.get(startIndex));\n\
    \                parentheses_lengths_tmp2.clear();\n                parentheses_levels_tmp.add(parentheses_levels_tmp.get(startIndex));\n\
    \                startIndex++;\n            } else {\n                group_tmp.add(paren_string.charAt(0));\n\
    \                level_tmp.add(parentheses_lengths.get(startIndex));\n       \
    \     }\n            if (paren_string.charAt(startIndex) == ')') {\n         \
    \       parentheses_lengths_tmp2.add(parentheses_lengths.get(startIndex));\n \
    \               parentheses_lengths_tmp.clear();\n                parentheses_levels_tmp.add(parentheses_levels.get(startIndex));\n\
    \                parentheses_levels_tmp2.clear();\n                parentheses_lengths_tmp.add(parentheses_lengths.get(startIndex));\n\
    \                startIndex++;\n            } else if (paren_string.charAt(startIndex)\
    \ == ' ') {\n                parentheses_lengths_tmp2.add(parentheses_lengths.get(startIndex));\n\
    \                parentheses_lengths_tmp.clear();\n                parentheses_levels_tmp\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8hbtkkwn.java:65: error: not a statement\n                parentheses_levels_tmp\n\
    \                ^\n/tmp/tmp8hbtkkwn.java:65: error: ';' expected\n          \
    \      parentheses_levels_tmp\n                                      ^\n/tmp/tmp8hbtkkwn.java:67:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n    ^\n3 errors\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Declare variables and input variables.\n       \
    \ ArrayList<Long> results = new ArrayList<Long>();\n        int curLevel = 0;\n\
    \        int i;\n        int j;\n        char ch;\n        boolean endOfParen\
    \ = false;\n        boolean inParen = false;\n        long level = 0;\n      \
    \  boolean found = false;\n\n        // For each character, check if it is an\
    \ open paren\n        for (i = 0; i < paren_string.length(); i++) {\n        \
    \    ch = paren_string.charAt(i);\n\n            if (inParen) {\n            \
    \    inParen = false;\n                if (ch == '(') {\n                    //\
    \ If we hit an open paren, increment the level and start a new paren level\n \
    \                   level++;\n                }\n                else if (ch ==\
    \ ')') {\n                    // If we hit a close paren, decrement the level\
    \ and end the paren level\n                    level--;\n                }\n \
    \               // If we hit a close paren and we've reached a level of zero,\
    \ store the result\n                // and set the flags to indicate we've reached\
    \ the end of the input.\n                else if (level == 0) {\n            \
    \        results.add(level);\n                    endOfParen = true;\n       \
    \             inParen = false;\n                }\n            }\n           \
    \ // If we've reached the end of the input, and we have an open paren then store\n\
    \            // the level value and start a new paren level\n            else\
    \ if (endOfParen && ch == '(') {\n                level++;\n                inParen\
    \ = true;\n            }\n            // If we've reached the end of the input,\
    \ and we have an open paren then store\n            // the level value and start\
    \ a new paren level\n            else if (endOfParen && ch == ')') {\n       \
    \         level--;\n            }\n            // If we're at the end of our input,\
    \ and we hit a close paren, end the level and\n            // store it.\n    \
    \        else if (endOfParen) {\n                endOfParen = false;\n       \
    \         results.add(level);\n                inParen = false;\n            }\n\
    \            // Otherwise, just store whatever character we found (including spaces)\
    \ since\n            // it isn't part of a paren.\n            else {\n      \
    \          results.add(ch);\n            }\n        }\n\n        return results;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8qknry2y.java:69: error: incompatible types: char cannot be converted\
    \ to Long\n                results.add(ch);\n                            ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       \n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : paren_string.split(\" \")) {\n            String temp = s;\n            if\
    \ (temp.equals(\"(\")) {\n                stack.push(\"(\");\n            } else\
    \ if (temp.equals(\")\")) {\n                stack.pop();\n            } else\
    \ {\n                String temp = stack.pop() + temp;\n                result.add(Long.valueOf(temp));\n\
    \                stack.push(temp);\n            }\n        }\n        \n     \
    \   return result;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphsi5d2j6.java:25: error: variable temp is already defined in method\
    \ parseNestedParens(String)\n                String temp = stack.pop() + temp;\n\
    \                       ^\n1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_parens = new ArrayList<Long>();\n\
    \        paren_string = paren_string.replaceAll(\"\\\\s\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"(\", \"\\\\(\");\n        paren_string = paren_string.replaceAll(\"\
    )\", \"\\\\)\");\n        paren_string = paren_string.replaceAll(\"\\\\(\", \"\
    \\\\(\");\n        paren_string = paren_string.replaceAll(\"\\\\)\", \"\\\\)\"\
    );\n        paren_string = paren_string.replaceAll(\"\\\\{\", \"\\\\[\");\n  \
    \      paren_string = paren_string.replaceAll(\"\\\\}\", \"\\\\]\");\n       \
    \ paren_string = paren_string.replaceAll(\"\\\\[\", \"\\\\[\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\]\", \"\\\\]\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(\", \"\\\\(\");\n        paren_string = paren_string.replaceAll(\"\\\\)\"\
    , \"\\\\)\");\n        paren_string = paren_string.replaceAll(\"\\\\{\", \"\\\\\
    [\");\n        paren_string = paren_string.replaceAll(\"\\\\}\", \"\\\\]\");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\[\", \"\\\\[\");\n     \
    \   paren_string = paren_string.replaceAll(\"\\\\]\", \"\\\\]\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\{\", \"\\\\[\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\}\", \"\\\\]\");\n        paren_string = paren_string.replaceAll(\"\\\\[\"\
    , \"\\\\[\");\n        paren_string = paren_string.replaceAll(\"\\\\]\", \"\\\\\
    ]\");\n        paren_string = paren_string.replaceAll(\"\\\\(\", \"\\\\(\");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\)\", \"\\\\)\");\n     \
    \   paren_string = paren_string.replaceAll(\"\\\\{\", \"\\\\[\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\}\", \"\\\\]\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\[\", \"\\\\[\");\n        paren_string = paren_string.replaceAll(\"\\\\]\"\
    , \"\\\\]\");\n        paren_string = paren_string.replaceAll(\"\\\\{\", \"\\\\\
    [\");\n        paren_string = paren_string.replaceAll(\"\\\\}\", \"\\\\]\");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\[\", \"\\\\[\");\n     \
    \   paren_string = paren_string.replaceAll(\"\\\\]\", \"\\\\]\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\{\", \"\\\\[\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\}\", \"\\\\]\");\n        paren_string = paren_string.replaceAll(\"\\\\\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7dthdf4q.java:47: error: unclosed string literal\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\\n                                         \
    \      ^\n1 error\n"
  stdout: ''
  timestamp: 1660011441
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Write your code here\n        return null;\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke\
    \ \"java.util.ArrayList.equals(Object)\" because the return value of \"Problem.parseNestedParens(String)\"\
    \ is null\n\tat Problem.main(tmpo6jjlhk0.java:19)\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>(paren_string.length());\n\
    \        Stack<String> stack = new Stack<String>();\n        Stack<Integer> levels\
    \ = new Stack<Integer>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            if (paren_string.charAt(i) == '(') {\n                stack.push(paren_string.charAt(i));\n\
    \                levels.push(0);\n            } else if (paren_string.charAt(i)\
    \ == ')') {\n                if (levels.isEmpty()) {\n                    throw\
    \ new IllegalArgumentException(\"Nested parentheses are not allowed.\");\n   \
    \             } else {\n                    int level = levels.pop();\n      \
    \              if (level > result.size() - 1) {\n                        result.add(new\
    \ Long(level));\n                    }\n                    result.add(new Long(level\
    \ + 1));\n                }\n            } else if (paren_string.charAt(i) ==\
    \ ' ') {\n                // We ignore space as we do not support multiple spaces\
    \ in a row.\n            } else if (!level.isEmpty() && paren_string.charAt(i)\
    \ == ')') {\n                levels.pop();\n            } else if (paren_string.charAt(i)\
    \ == '(') {\n                stack.push(paren_string.charAt(i));\n           \
    \     levels.push(1);\n            } else {\n                throw new IllegalArgumentException(\"\
    Invalid parenthesis at index \" + i + \": \" + paren_string.charAt(i));\n    \
    \        }\n        }\n        throw new IllegalArgumentException(\"Invalid parenthesis:\
    \ \" + paren_string);\n    }\n    public static void main(String[] args) {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa8qlhpe7.java:20: error: incompatible types: char cannot be converted\
    \ to String\n                stack.push(paren_string.charAt(i));\n           \
    \                                   ^\n/tmp/tmpa8qlhpe7.java:28: warning: [removal]\
    \ Long(long) in Long has been deprecated and marked for removal\n            \
    \            result.add(new Long(level));\n                                  \
    \ ^\n/tmp/tmpa8qlhpe7.java:30: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                    result.add(new Long(level\
    \ + 1));\n                               ^\n/tmp/tmpa8qlhpe7.java:34: error: cannot\
    \ find symbol\n            } else if (!level.isEmpty() && paren_string.charAt(i)\
    \ == ')') {\n                        ^\n  symbol:   variable level\n  location:\
    \ class Problem\n/tmp/tmpa8qlhpe7.java:37: error: incompatible types: char cannot\
    \ be converted to String\n                stack.push(paren_string.charAt(i));\n\
    \                                              ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n2 warnings\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String[] nested_parens = paren_string.split(\" \");\n\
    \        List<Long> list_of_nested_parens = new ArrayList<>();\n        list_of_nested_parens.add(Long.valueOf(nested_parens.length));\n\
    \n        for (String nested_paren: nested_parens) {\n            List<Long> level_of_nesting\
    \ = new ArrayList<>();\n            level_of_nesting.add(Long.valueOf(nested_paren.length()));\n\
    \n            nested_parens = nested_paren.split(\"\\\\(\");\n            for\
    \ (String nested_parens: nested_parens) {\n                List<Long> level_of_nesting_of_nested_parens\
    \ = new ArrayList<>();\n                level_of_nesting_of_nested_parens.add(Long.valueOf(nested_parens.length()));\n\
    \n                nested_parens = nested_paren.split(\"\\\\)\");\n           \
    \     for (String nested_parens: nested_parens) {\n                    level_of_nesting_of_nested_parens.add(Long.valueOf(nested_parens.length()));\n\
    \                }\n                level_of_nesting.addAll(level_of_nesting_of_nested_parens);\n\
    \            }\n            list_of_nested_parens.addAll(level_of_nesting);\n\
    \        }\n        return list_of_nested_parens;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprmfj7mzo.java:24: error: variable nested_parens is already defined\
    \ in method parseNestedParens(String)\n            for (String nested_parens:\
    \ nested_parens) {\n                        ^\n/tmp/tmprmfj7mzo.java:28: error:\
    \ incompatible types: String[] cannot be converted to String\n               \
    \ nested_parens = nested_paren.split(\"\\\\)\");\n                           \
    \                       ^\n/tmp/tmprmfj7mzo.java:29: error: for-each not applicable\
    \ to expression type\n                for (String nested_parens: nested_parens)\
    \ {\n                                           ^\n  required: array or java.lang.Iterable\n\
    \  found:    String\n/tmp/tmprmfj7mzo.java:29: error: variable nested_parens is\
    \ already defined in method parseNestedParens(String)\n                for (String\
    \ nested_parens: nested_parens) {\n                            ^\n/tmp/tmprmfj7mzo.java:36:\
    \ error: incompatible types: List<Long> cannot be converted to ArrayList<Long>\n\
    \        return list_of_nested_parens;\n               ^\n5 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_nested_level = new ArrayList<>();\n\
    \        ArrayList<Long> current_level = new ArrayList<>();\n\n        // For\
    \ each of the group in the string.\n        for (String group : paren_string.split(\"\
    \ \")) {\n            ArrayList<Long> new_current_level = new ArrayList<>();\n\
    \            // for each opening parenthesis in the group.\n            for (int\
    \ i = 0; i < group.length(); i++) {\n                // if the current character\
    \ is a right parenthesis.\n                if (group.charAt(i) == '(') {\n   \
    \                 new_current_level.add(current_level.size() + 1);\n         \
    \       }\n                // if the current character is a left parenthesis.\n\
    \                else if (group.charAt(i) == ')') {\n                    if (current_level.size()\
    \ == 0) {\n                        // we ignore this group because there is no\
    \ opening parenthesis found in the group\n                        // ignore group\n\
    \                        continue;\n                    }\n                  \
    \  current_level.add(current_level.get(current_level.size()) - 1);\n         \
    \       }\n            }\n            if (new_current_level.size() > max_nested_level.size())\
    \ {\n                max_nested_level = new_current_level;\n            }\n  \
    \      }\n\n        // return the list of nested level\n        return max_nested_level;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa9bi3s82.java:25: error: incompatible types: int cannot be converted\
    \ to Long\n                    new_current_level.add(current_level.size() + 1);\n\
    \                                                               ^\nNote: Some\
    \ messages have been simplified; recompile with -Xdiags:verbose to get full output\n\
    1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   for (String current_level : paren_string.split(\" \")) {\n            ArrayList<Long>\
    \ current_level_levels = new ArrayList<>();\n            levels.add(current_level_levels);\n\
    \            for (String current_group : current_level.split(\"(\")) {\n     \
    \           String current_level_group = current_group;\n                for (String\
    \ group : current_level_group.split(\")\")) {\n                    current_level_group\
    \ = \"(\" + group + \")\";\n                }\n                ArrayList<Long>\
    \ current_level_group_levels = new ArrayList<>();\n                current_level_group\
    \ = \"(\" + current_level_group + \")\";\n                current_level_group_levels.add(0l);\n\
    \                levels.get(levels.size() - 1).add(current_level_group_levels);\n\
    \            }\n        }\n        ArrayList<Long> max_levels = Collections.max(levels);\n\
    \        return max_levels;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy7k7x6cy.java:18: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n            levels.add(current_level_levels);\n      \
    \                 ^\n/tmp/tmpy7k7x6cy.java:27: error: cannot find symbol\n   \
    \             levels.get(levels.size() - 1).add(current_level_group_levels);\n\
    \                                             ^\n  symbol:   method add(ArrayList<Long>)\n\
    \  location: class Long\n/tmp/tmpy7k7x6cy.java:30: error: incompatible types:\
    \ inference variable T has incompatible bounds\n        ArrayList<Long> max_levels\
    \ = Collections.max(levels);\n                                               \
    \     ^\n    lower bounds: ArrayList<Long>,Long,Object,Comparable<? super T>\n\
    \    lower bounds: Long\n  where T is a type-variable:\n    T extends Object,Comparable<?\
    \ super T> declared in method <T>max(Collection<? extends T>)\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parens = new ArrayList<>();\n     \
    \   // \"(()()) ((())) () ((())()())\"\n        StringBuilder sb = new StringBuilder();\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (c == '(')\
    \ {\n                sb.append(\"(\");\n            } else if (c == ')') {\n \
    \               sb.append(\")\");\n            } else if (c == '{') {\n      \
    \          sb.append(\"{\");\n            } else if (c == '}') {\n           \
    \     sb.append(\"}\");\n            }\n        }\n        String parens_str =\
    \ sb.toString();\n        // \"(()()) ((())) () ((())()())\"\n        Matcher\
    \ matcher = Pattern.compile(\"\\\\(([^)]+)\\\\)\").matcher(parens_str);\n    \
    \    while (matcher.find()) {\n            parens.add(Long.valueOf(matcher.group(1)));\n\
    \        }\n        parens.sort();\n        return parens;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsqabdrdj.java:31: error: cannot find symbol\n        Matcher matcher\
    \ = Pattern.compile(\"\\\\(([^)]+)\\\\)\").matcher(parens_str);\n        ^\n \
    \ symbol:   class Matcher\n  location: class Problem\n/tmp/tmpsqabdrdj.java:31:\
    \ error: cannot find symbol\n        Matcher matcher = Pattern.compile(\"\\\\\
    (([^)]+)\\\\)\").matcher(parens_str);\n                          ^\n  symbol:\
    \   variable Pattern\n  location: class Problem\n/tmp/tmpsqabdrdj.java:35: error:\
    \ method sort in class ArrayList<E> cannot be applied to given types;\n      \
    \  parens.sort();\n              ^\n  required: Comparator<? super Long>\n  found:\
    \    no arguments\n  reason: actual and formal argument lists differ in length\n\
    \  where E is a type-variable:\n    E extends Object declared in class ArrayList\n\
    3 errors\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, new ArrayList<Long>());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp26ntaqfs.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ new ArrayList<Long>());\n               ^\n  required: String\n  found:    String,ArrayList<Long>\n\
    \  reason: actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // This code assumes that each open and closing paren\
    \ are separated by a single space.\n        // For each open paren, find the deepest\
    \ level of nesting.\n        // For each closing paren, find the number of opening\
    \ parens needed to close it.\n        // The answer is the maximum of both results.\n\
    \        // If the input string has no parentheses, then return an empty list.\n\
    \        // In all other cases, return an empty list and the answer (0).\n   \
    \     // To find the number of opening parentheses, iterate through the input\
    \ string and\n        // keep a running sum of the number of open parentheses.\n\
    \        // To find the number of closing parentheses, keep a running sum of the\
    \ number of closing parentheses.\n        // If you encounter an opening parentheses\
    \ followed by a closing parentheses,\n        // then the closing parentheses\
    \ count should be incremented.\n        // If you encounter an opening parentheses\
    \ followed by a closing parentheses and\n        // the running sum exceeds the\
    \ running count of the opening parentheses, then\n        // the closing parentheses\
    \ count should be incremented.\n        // If you encounter an opening parentheses\
    \ followed by a closing parentheses and\n        // the running sum is equal to\
    \ the running count of the opening parentheses,\n        // then just count the\
    \ parentheses itself.\n        // You can use the following formula to calculate\
    \ the number of parentheses needed:\n        // running count of opening parentheses\
    \ * (running count of closing parentheses - running count of opening parentheses)\n\
    \        int count_opening_paren_sum = 0;\n        int count_closing_paren_sum\
    \ = 0;\n        int count_paren_sum = 0;\n        for (int i = 0; i < paren_string.length();\
    \ ++i) {\n            char ch = paren_string.charAt(i);\n            if (ch ==\
    \ '(') {\n                ++count_opening_paren_sum;\n            } else if (ch\
    \ == ')') {\n                ++count_closing_paren_sum;\n            } else if\
    \ (ch == '(' && count_opening_paren_sum > count_closing_paren_sum) {\n       \
    \         ++count_paren_sum;\n            } else if (ch == ')' && count_closing_paren_sum\
    \ > count_opening_paren_sum) {\n                ++count_paren_sum;\n         \
    \   }\n        }\n        if (count_paren_sum > count_opening_paren_sum) {\n \
    \           return new ArrayList<Long>();\n        }\n        return new ArrayList<Long>()\
    \ {\n            {\n                add(count_paren_sum);\n            }\n   \
    \     };\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpltufprxg.java:54: error: incompatible types: int cannot be converted\
    \ to Long\n                add(count_paren_sum);\n                    ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_level = new ArrayList<Long>();\n\
    \        for (String group: paren_string.split(\" \")) {\n            long level\
    \ = parseNestedParens(group);\n            deepest_level.add(level);\n       \
    \ }\n        return deepest_level;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3quofdpl.java:17: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to long\n            long level = parseNestedParens(group);\n \
    \                                         ^\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> return_val = new ArrayList<Long>();\n\
    \        ArrayList<String> tokens = new ArrayList<String>();\n        String[]\
    \ temp_strings = paren_string.split(\" \");\n        for (String s : temp_strings)\
    \ {\n            int open = 0;\n            for (int i = 0; i < s.length(); i++)\
    \ {\n                char c = s.charAt(i);\n                if (c == '(') {\n\
    \                    open++;\n                } else if (c == ')') {\n       \
    \             open--;\n                }\n                tokens.add(String.valueOf(c));\n\
    \                if (open == 0) {\n                    break;\n              \
    \  }\n            }\n        }\n        for (String token : tokens) {\n      \
    \      long num = 0;\n            boolean negative = false;\n            if (token.startsWith(\"\
    -\")) {\n                negative = true;\n                token = token.substring(1);\n\
    \            }\n            if (token.contains(\"-\")) {\n                String\
    \ numbers = token.substring(token.indexOf('-') + 1);\n                String[]\
    \ numbers_array = numbers.split(\" \");\n                for (String number :\
    \ numbers_array) {\n                    if (number.startsWith(\"-\")) {\n    \
    \                    num *= -1;\n                        number = number.substring(1);\n\
    \                    }\n                    try {\n                        long\
    \ d = Long.parseLong(number);\n                        num += d;\n           \
    \         } catch (NumberFormatException e) {\n                        num +=\
    \ (long) (Double.parseDouble(number));\n                    }\n              \
    \  }\n            }\n            if (negative) {\n                num = -num;\n\
    \            }\n            long d = 1;\n            for (int i = 0; i < token.length();\
    \ i++) {\n                char c = token.charAt(i);\n                switch (c)\
    \ {\n                    case '0': d *= 10; break;\n                    case '1':\
    \ d *= 10; break;\n                    case '2': d *= 10; break;\n           \
    \         case '3': d *= 10; break;\n                    case '4': d *= 10; break;\n\
    \                    case '5': d *= 10; break;\n                    case '6':\
    \ d *= 10; break;\n                    case '7': d *= 10; break;\n           \
    \         case '8': d *= 10; break;\n                    case '9': d *= 10; break;\n\
    \                    case '+': d *= 10; break;\n                    case '-':\
    \ d /= 10; break;\n                    default: return return_val;\n         \
    \       }\n            }\n            num /= d;\n            return_val.add(num);\n\
    \        }\n        return return_val;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp7nbb0xci.java:84)\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> count = new ArrayList<>();\n      \
    \  // Create a Stack to hold the positions of parentheses.\n        Stack<Integer>\
    \ parentheses = new Stack<>();\n        // A boolean to determine whether parentheses\
    \ have already been processed.\n        boolean has_processed = false;\n     \
    \   for (int i = 0; i < paren_string.length(); i++) {\n            char ch = paren_string.charAt(i);\n\
    \            // If the character is a '(' character, push it into the stack.\n\
    \            if (ch == '(') {\n                parentheses.push(parentheses.size());\n\
    \            }\n            // If the character is a ')' character, pop a parentheses\
    \ from the stack.\n            else if (ch == ')') {\n                long current_level\
    \ = parentheses.size() - 1;\n                // If we pop the entire stack, we\
    \ are at the deepest level of nesting.\n                if (current_level == 0)\
    \ {\n                    count.add(count.size());\n                }\n       \
    \         // Otherwise, we are on the second or third level of nesting.\n    \
    \            else {\n                    long highest_level = count.get(count.size()\
    \ - 1);\n                    count.remove(count.size() - 1);\n               \
    \     // If we just popped the second level of nesting, we still want to add the\
    \ new number of nesting levels.\n                    count.add(highest_level +\
    \ count.size());\n                }\n                has_processed = true;\n \
    \           }\n            // If we just processed a parentheses character,\n\
    \            // we need to add another level of nesting.\n            if (has_processed)\
    \ {\n                long current_level = parentheses.size() - 1;\n          \
    \      count.add(count.size());\n            }\n        }\n        return count;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfq1s5gl_.java:31: error: incompatible types: int cannot be converted\
    \ to Long\n                    count.add(count.size());\n                    \
    \                    ^\n/tmp/tmpfq1s5gl_.java:46: error: incompatible types: int\
    \ cannot be converted to Long\n                count.add(count.size());\n    \
    \                                ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> ret = new ArrayList<Long>();\n    \
    \    int nparens = 0;\n        for (char c : paren_string.toCharArray()) {\n \
    \           if (c == '(') {\n                nparens++;\n            } else if\
    \ (c == ')') {\n                nparens--;\n            }\n            if (nparens\
    \ > 0) {\n                ret.add(new Long(nparens));\n            }\n       \
    \ }\n        return ret;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2y_gs0k2.java:30)\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // This recursive call will eventually lead to a stack\
    \ overflow.\n        ArrayList<Long> max_level = parseNestedParens_aux(paren_string,\
    \ 0L, 0L);\n        return max_level;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfmngkt4z.java:16: error: cannot find symbol\n        ArrayList<Long>\
    \ max_level = parseNestedParens_aux(paren_string, 0L, 0L);\n                 \
    \                   ^\n  symbol:   method parseNestedParens_aux(String,long,long)\n\
    \  location: class Problem\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   List<String> words = Arrays.stream(paren_string.trim().split(\"\\\\s+\")).filter(s\
    \ -> !s.isEmpty()).collect(Collectors.toList());\n        if (words.size() ==\
    \ 0) {\n            return levels;\n        }\n        boolean end_of_parens =\
    \ false;\n        for (int i = 0; i < words.size() && !end_of_parens; i++) {\n\
    \            if (words.get(i).equals(\")\")) {\n                end_of_parens\
    \ = true;\n            }\n            if (words.get(i).equals(\"(\")) {\n    \
    \            if (levels.size() >= 2) {\n                    //return levels; //uncommenting\
    \ this will show an error \"error: return statement outside of function\"\n  \
    \                  String previous = levels.get(levels.size() - 2);\n        \
    \            if (previous.equals(\"(\")) {\n                        levels.add(levels.get(levels.size()\
    \ - 1) + 1l);\n                    } else {\n                        levels.add(levels.get(levels.size()\
    \ - 1l));\n                    }\n                }\n                levels.add(1l);\n\
    \            }\n        }\n        return levels;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq27lvaty.java:28: error: incompatible types: Long cannot be converted\
    \ to String\n                    String previous = levels.get(levels.size() -\
    \ 2);\n                                                ^\n/tmp/tmpq27lvaty.java:32:\
    \ error: incompatible types: possible lossy conversion from long to int\n    \
    \                    levels.add(levels.get(levels.size() - 1l));\n           \
    \                                                 ^\nNote: Some messages have\
    \ been simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parens = new ArrayList<Long>();\n \
    \       if (paren_string.isEmpty()) {\n            return parens;\n        }\n\
    \n        ArrayList<String> groups = new ArrayList<String>();\n        Matcher\
    \ m = Pattern.compile(\"( *)\").matcher(paren_string);\n        m.usePattern(Pattern.compile(\"\
    ( )+\"));\n        while (m.find()) {\n            groups.add(m.group());\n  \
    \      }\n        if (groups.isEmpty()) {\n            return parens;\n      \
    \  }\n\n        ArrayList<Long> stack = new ArrayList<Long>();\n        stack.add(0l);\n\
    \        for (int i = 0; i < groups.size(); i++) {\n            String group =\
    \ groups.get(i);\n            String nested = null;\n            if (group.length()\
    \ == 1) {\n                nested = group;\n            } else {\n           \
    \     int level = group.indexOf(')');\n                if (level > -1) {\n   \
    \                 nested = group.substring(0, level);\n                }\n   \
    \             if (nested == null) {\n                    nested = group;\n   \
    \             }\n            }\n            if (nested == null) {\n          \
    \      nested = \"\";\n            }\n\n            stack.clear();\n         \
    \   Matcher m2 = Pattern.compile(nested).matcher(paren_string);\n            m2.usePattern(Pattern.compile(nested\
    \ + \" *\"));\n            while (m2.find()) {\n                stack.add(m2.start());\n\
    \            }\n\n            if (stack.size() > parens.size()) {\n          \
    \      parens.clear();\n                parens.addAll(stack);\n            } else\
    \ {\n                int k = parens.size();\n                while (k < stack.size())\
    \ {\n                    parens.add(0l);\n                    k++;\n         \
    \       }\n                parens.add(stack.size());\n            }\n        }\n\
    \n        return parens;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwlzgtu30.java:21: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"( *)\").matcher(paren_string);\n        ^\n  symbol:   class\
    \ Matcher\n  location: class Problem\n/tmp/tmpwlzgtu30.java:21: error: cannot\
    \ find symbol\n        Matcher m = Pattern.compile(\"( *)\").matcher(paren_string);\n\
    \                    ^\n  symbol:   variable Pattern\n  location: class Problem\n\
    /tmp/tmpwlzgtu30.java:22: error: cannot find symbol\n        m.usePattern(Pattern.compile(\"\
    ( )+\"));\n                     ^\n  symbol:   variable Pattern\n  location: class\
    \ Problem\n/tmp/tmpwlzgtu30.java:51: error: cannot find symbol\n            Matcher\
    \ m2 = Pattern.compile(nested).matcher(paren_string);\n            ^\n  symbol:\
    \   class Matcher\n  location: class Problem\n/tmp/tmpwlzgtu30.java:51: error:\
    \ cannot find symbol\n            Matcher m2 = Pattern.compile(nested).matcher(paren_string);\n\
    \                         ^\n  symbol:   variable Pattern\n  location: class Problem\n\
    /tmp/tmpwlzgtu30.java:52: error: cannot find symbol\n            m2.usePattern(Pattern.compile(nested\
    \ + \" *\"));\n                          ^\n  symbol:   variable Pattern\n  location:\
    \ class Problem\n/tmp/tmpwlzgtu30.java:66: error: incompatible types: int cannot\
    \ be converted to Long\n                parens.add(stack.size());\n          \
    \                           ^\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n7 errors\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Parse the string and split it into groups separated\
    \ by space\n        List<String> parsed_string = Arrays.stream(paren_string.split(\"\
    \\\\s+\")).collect(Collectors.toList());\n        // Create a stack to store nested\
    \ parentheses\n        Stack<String> stack = new Stack<>();\n        // Loop through\
    \ each group of nested parentheses and store them in the stack\n        for (String\
    \ group : parsed_string) {\n            // If current parentheses group has nested\
    \ parentheses push that group onto the stack\n            if (group.matches(\"\
    .*\\\\(.*\\\\).*\")) {\n                stack.push(group);\n            } else\
    \ {\n                // If current parentheses group doesn't have nested parentheses,\
    \ pop the top element from the stack\n                while (!stack.isEmpty()\
    \ && stack.peek().matches(String.format(\".*\\\\(.*\\\\).*\"))) {\n          \
    \          stack.peek().replaceAll(\"\\\\(|\\\\)\", \"\");\n                 \
    \   stack.peek().trim();\n                }\n                // If the stack size\
    \ is 0, the group is inside parentheses and has maximum nesting level\n      \
    \          if (stack.size() == 0) {\n                    // Get maximum nesting\
    \ level of current group\n                    int max_nest_level = 0;\n      \
    \              // For each level of nesting, add 1 to the max nesting level\n\
    \                    for (int j = 0; j < group.length(); j++) {\n            \
    \            // If this character is opening parentheses, increase nesting level\n\
    \                        if (group.charAt(j) == '(') {\n                     \
    \       max_nest_level++;\n                        } else {\n                \
    \            // If this character is closing parentheses, decrease nesting level\n\
    \                            if (group.charAt(j) == ')') {\n                 \
    \               max_nest_level--;\n                            }\n           \
    \             }\n                    }\n                    // Add current group\
    \ with max nesting level to the output list\n                    stack.add(String.valueOf(max_nest_level));\n\
    \                } else {\n                    // Else stack is not empty and\
    \ current group has maximum nesting level\n                    stack.add(group);\n\
    \                }\n            }\n        }\n        // Get the output list by\
    \ popping off each element from the stack\n        return Arrays.stream(stack).collect(Collectors.toList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpg7eju6bp.java:55: error: no suitable method found for stream(Stack<String>)\n\
    \        return Arrays.stream(stack).collect(Collectors.toList());\n         \
    \            ^\n    method Arrays.<T#1>stream(T#1[]) is not applicable\n     \
    \ (cannot infer type-variable(s) T#1\n        (argument mismatch; Stack<String>\
    \ cannot be converted to T#1[]))\n    method Arrays.<T#2>stream(T#2[],int,int)\
    \ is not applicable\n      (cannot infer type-variable(s) T#2\n        (actual\
    \ and formal argument lists differ in length))\n    method Arrays.stream(int[])\
    \ is not applicable\n      (argument mismatch; Stack<String> cannot be converted\
    \ to int[])\n    method Arrays.stream(long[]) is not applicable\n      (argument\
    \ mismatch; Stack<String> cannot be converted to long[])\n    method Arrays.stream(double[])\
    \ is not applicable\n      (argument mismatch; Stack<String> cannot be converted\
    \ to double[])\n  where T#1,T#2 are type-variables:\n    T#1 extends Object declared\
    \ in method <T#1>stream(T#1[])\n    T#2 extends Object declared in method <T#2>stream(T#2[],int,int)\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string.length() <= 0)\n            throw\
    \ new IllegalArgumentException(\"Input must be a non-empty string\");\n\n    \
    \    ArrayList<Long> deepest_levels = new ArrayList<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        ArrayList<String> nested_levels = new ArrayList<>();\n\
    \n        String[] groups = paren_string.split(\" \");\n        for (String group\
    \ : groups) {\n            char opening_char;\n            char closing_char;\n\
    \            long level;\n\n            int start_opening = 0, end_opening;\n\
    \            int start_closing = 0, end_closing;\n\n            if (nested_levels.size()\
    \ > 0) {\n                end_opening = nested_levels.get(nested_levels.size()\
    \ - 1).lastIndexOf(')');\n                end_closing = nested_levels.get(nested_levels.size()\
    \ - 1).lastIndexOf('(');\n                start_opening = nested_levels.get(nested_levels.size()\
    \ - 1).lastIndexOf('(');\n                start_closing = nested_levels.get(nested_levels.size()\
    \ - 1).lastIndexOf(')');\n            }\n\n            if (group.length() == 0)\
    \ {\n                throw new IllegalArgumentException(\"Input must be a non-empty\
    \ string\");\n            }\n\n            // We only care about the outermost\
    \ nested parentheses.\n            if (nested_levels.size() == 0) {\n        \
    \        if (nested_levels.contains(\"\")) {\n                    sb.append(\"\
    \");\n                }\n                else {\n                    throw new\
    \ IllegalArgumentException(\"Input must be a non-empty string\");\n          \
    \      }\n            }\n            else {\n                if (nested_levels.size()\
    \ > 1) {\n                    throw new IllegalArgumentException(\"Input must\
    \ be a non-empty string\");\n                }\n                if (nested_levels.get(0)\
    \ == \"\") {\n                    throw new IllegalArgumentException(\"Input must\
    \ be a non-empty string\");\n                }\n            }\n\n            if\
    \ (group.charAt(0) == '(') {\n                // If this parenthesis is nested,\
    \ increase the level by one.\n                opening_char = '(';\n          \
    \      closing_char = ')';\n                level = Long.MAX_VALUE;\n        \
    \    }\n            else if (group.charAt(0) == ')') {\n                // If\
    \ this parenthesis is nested, decrease the level by one.\n                opening_char\
    \ = ')';\n                closing_char = '(';\n                level = Long.MIN_VALUE;\n\
    \            }\n            else {\n                opening_char = '(';\n    \
    \            closing_char = ')';\n                level = Long.MAX_VALUE;\n  \
    \          }\n\n            sb.append(group.substring(0, (end_opening - start_opening)));\n\
    \            nested_levels.add(group.substring(start_opening, end_opening));\n\
    \            level = level + 1;\n            deepest_levels.add(level);\n    \
    \        sb.append(opening_char);\n\n            // Recursion.\n            StringBuilder\
    \ s_sub_levels = new StringBuilder();\n            s_sub_levels.append(nested_levels.subList(0,\
    \ nested_levels.size() - 1));\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpexevffkk.java:88: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, 0);\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3pxs5oew.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ 0);\n               ^\n  required: String\n  found:    String,int\n  reason:\
    \ actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011438
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Initialize our variables\n        long total_paren_level\
    \ = 0;\n        ArrayList<Long> highest_levels_of_paren = new ArrayList<>();\n\
    \        // Iterate over the string\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                total_paren_level++;\n     \
    \       } else if (c == ')') {\n                total_paren_level--;\n       \
    \     }\n            if (total_paren_level > highest_levels_of_paren.size()) {\n\
    \                highest_levels_of_paren.add(total_paren_level);\n           \
    \ }\n        }\n        return highest_levels_of_paren;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_w3vlgix.java:32)\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting = new ArrayList<Long>();\n\
    \        paren_string = paren_string.replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(+\", \"(\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\)+\", \")\");\n        paren_string = paren_string.replaceAll(\"\\\\)\\\\\
    (\", \"()\");\n        paren_string = paren_string.replaceAll(\"\\\\)\\\\)\",\
    \ \"()\");\n        paren_string = paren_string.replaceAll(\"\\\\)\\\\(\", \"\
    ()\");\n\n        paren_string = paren_string.replaceAll(\"\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwiapr_2b.java:23: error: unclosed string literal\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\
    \\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\\
    ()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\
    \\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\(([^\\\\()]+?)(\\\\\
    (([^\n                                               ^\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>(25);\n\
    \        if (paren_string == null || paren_string.isEmpty()) {\n            return\
    \ result;\n        }\n\n        // Parse and count levels of nesting\n       \
    \ List<String> groups = Arrays.asList(paren_string.split(\"\\\\s\", -1));\n  \
    \      long level = 0;\n        for (String group : groups) {\n            if\
    \ (!group.contains(\"(\")) {\n                level++;\n                continue;\n\
    \            }\n            level++;\n            int open_brackets = 1;\n   \
    \         for (int i = 0; i < group.length(); i++) {\n                if (group.charAt(i)\
    \ == '(') {\n                    open_brackets++;\n                } else if (group.charAt(i)\
    \ == ')') {\n                    open_brackets--;\n                    if (open_brackets\
    \ == 0) {\n                        break;\n                    }\n           \
    \     }\n            }\n            result.add(level);\n        }\n\n        //\
    \ Find the deepest level of nesting\n        level = Long.MAX_VALUE;\n       \
    \ for (Long level : result) {\n            if (level < level) {\n            \
    \    level = level;\n            }\n        }\n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpccmviyad.java:45: error: variable level is already defined in method\
    \ parseNestedParens(String)\n        for (Long level : result) {\n           \
    \       ^\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> results = new ArrayList<Long>();\n\
    \        Stack<String> stack_of_strings = new Stack<String>();\n\n        // Split\
    \ string by spaces separating nested parentheses.\n        String[] words = paren_string.split(\"\
    \ \");\n        // Iterate through words.\n        for (int i = 0; i < words.length;\
    \ i++) {\n            // Remove parentheses and split words into two parts.\n\
    \            String word_left = words[i];\n            String word_right = words[words.length\
    \ - 1 - i];\n            ArrayList<String> left_parens = word_left.split(\"(\"\
    );\n            ArrayList<String> right_parens = word_right.split(\")\");\n\n\
    \            // Add length of nested parentheses to results.\n            results.add((long)\
    \ (left_parens.size() + right_parens.size()));\n\n            // Add left parentheses\
    \ until there is a closing parenthesis.\n            while (left_parens.size()\
    \ > 0 && left_parens.get(0).equals(\"(\")) {\n                stack_of_strings.push(left_parens.get(0));\n\
    \                left_parens.remove(0);\n            }\n\n            // Add right\
    \ parentheses until there is a closing parenthesis.\n            while (right_parens.size()\
    \ > 0 && right_parens.get(0).equals(\"(\")) {\n                stack_of_strings.push(right_parens.get(0));\n\
    \                right_parens.remove(0);\n            }\n\n            // Continue\
    \ adding words to stack of strings until stack only has parentheses.\n       \
    \     while (stack_of_strings.size() > 0 && stack_of_strings.pop().equals(\"(\"\
    )) {\n                left_parens.add(stack_of_strings.pop());\n            }\n\
    \n            // Continue adding words to stack of strings until stack only has\
    \ parentheses.\n            while (stack_of_strings.size() > 0 && stack_of_strings.pop().equals(\"\
    (\")) {\n                right_parens.add(stack_of_strings.pop());\n         \
    \   }\n        }\n        return results;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmmam2c2x.java:25: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n            ArrayList<String> left_parens =\
    \ word_left.split(\"(\");\n                                                  \
    \         ^\n/tmp/tmpmmam2c2x.java:26: error: incompatible types: String[] cannot\
    \ be converted to ArrayList<String>\n            ArrayList<String> right_parens\
    \ = word_right.split(\")\");\n                                               \
    \              ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_list = new ArrayList<Long>();\n\
    \        paren_list.clear();\n        int max_level = 0;\n        Stack<Integer>\
    \ stack = new Stack<Integer>();\n        for(int i=0; i<paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if(c == '(')\
    \ {\n                stack.push(i);\n            } else if(c == ')') {\n     \
    \           if((stack.peek()+1) == i) {\n                    stack.pop();\n  \
    \              } else {\n                    paren_list.add(stack.peek()+1);\n\
    \                }\n            } else if(stack.isEmpty()) {\n               \
    \ throw new RuntimeException(\"Invalid parentheses!\");\n            }\n     \
    \   }\n        return paren_list;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk3wqszac.java:27: error: incompatible types: int cannot be converted\
    \ to Long\n                    paren_list.add(stack.peek()+1);\n             \
    \                                  ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> return_array = new ArrayList<Long>();\n\
    \        long curr_level = 0;\n        for(int i = 0; i < paren_string.length();\
    \ i++) {\n            if(paren_string.charAt(i) == '(')\n                curr_level++;\n\
    \            if(paren_string.charAt(i) == ')')\n                curr_level--;\n\
    \            long current_level = 0;\n            for(; curr_level > current_level;\
    \ current_level++)\n                return_array.add((long) current_level);\n\
    \        }\n        return return_array;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxp7o0e5m.java:29)\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_levels = new ArrayList<>();\n\
    \        ArrayList<Long> current_level = new ArrayList<>();\n        \n      \
    \  for(String group: paren_string.split(\" \")) {\n            String group_level\
    \ = group.replace(\"(\", \"\").replace(\")\", \"\");\n            \n         \
    \   ArrayList<Long> current_group = new ArrayList<>();\n            for(char c:\
    \ group_level.toCharArray()) {\n                if(c == '(') current_group.add(current_level.size());\n\
    \                if(c == ')') current_level.add(current_group.size());\n     \
    \       }\n            current_level.addAll(current_group);\n            \n  \
    \          deepest_levels.addAll(current_level);\n        }\n        \n      \
    \  return deepest_levels;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplf78vk_e.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n                if(c == '(') current_group.add(current_level.size());\n\
    \                                                                 ^\n/tmp/tmplf78vk_e.java:24:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \ if(c == ')') current_level.add(current_group.size());\n                    \
    \                                             ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> groups = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> result = new ArrayList<>();\n        parseGroups(groups,\
    \ 0, result);\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphkt1hloj.java:17: error: cannot find symbol\n        parseGroups(groups,\
    \ 0, result);\n        ^\n  symbol:   method parseGroups(List<String>,int,ArrayList<Long>)\n\
    \  location: class Problem\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested = new ArrayList<>();\n     \
    \   // Go through the input string char by char and collect all the brackets group\n\
    \        int len = paren_string.length();\n        for (int i = 0; i < len; i++)\
    \ {\n            if (paren_string.charAt(i) == '(') {\n                nested.add(nested.size());\n\
    \            } else if (paren_string.charAt(i) == ')') {\n                nested.add(nested.size()\
    \ - 1);\n            }\n        }\n        // Convert the nested lists into list\
    \ of integers\n        return nested.stream().map(x -> (long)x).collect(Collectors.toList());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyb1__yq9.java:20: error: incompatible types: int cannot be converted\
    \ to Long\n                nested.add(nested.size());\n                      \
    \                ^\n/tmp/tmpyb1__yq9.java:22: error: incompatible types: int cannot\
    \ be converted to Long\n                nested.add(nested.size() - 1);\n     \
    \                                    ^\n/tmp/tmpyb1__yq9.java:26: error: incompatible\
    \ types: inference variable R has incompatible bounds\n        return nested.stream().map(x\
    \ -> (long)x).collect(Collectors.toList());\n                                \
    \                        ^\n    equality constraints: List<T#2>\n    lower bounds:\
    \ ArrayList<Long>,Object\n  where R,A,T#1,T#2 are type-variables:\n    R extends\
    \ Object declared in method <R,A>collect(Collector<? super T#1,A,R>)\n    A extends\
    \ Object declared in method <R,A>collect(Collector<? super T#1,A,R>)\n    T#1\
    \ extends Object declared in interface Stream\n    T#2 extends Object declared\
    \ in method <T#2>toList()\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting_level = new ArrayList<>();\n\
    \        StringTokenizer tokenizer = new StringTokenizer(paren_string);\n    \
    \    tokenizer.useDelimiter(\" \");\n\n        // The first element is the string\
    \ without nesting levels, i.e. \"(()()) ((())) () ((())()())\".\n        // The\
    \ second element is the deepest level of nesting, i.e. \"((long)2l, (long)3l,\
    \ (long)1l, (long)3l)\".\n        if (tokenizer.hasMoreTokens()) {\n         \
    \   String tok = tokenizer.nextToken();\n            nesting_level.add(new Long(tok.length()));\n\
    \        }\n\n        while (tokenizer.hasMoreTokens()) {\n            String\
    \ tok = tokenizer.nextToken();\n            if (tok.equals(\"(\")) {\n       \
    \         nesting_level.add(new Long(1));\n            }\n            else if\
    \ (tok.equals(\")\")) {\n                Long max_level = nesting_level.remove(0);\n\
    \                nesting_level.add(new Long(max_level + 1));\n            }\n\
    \            else if (tok.equals(\"[\")) {\n                nesting_level.add(new\
    \ Long(2));\n            }\n            else if (tok.equals(\"]\")) {\n      \
    \          Long max_level = nesting_level.remove(0);\n                nesting_level.add(new\
    \ Long(max_level + 1));\n            }\n        }\n\n        return nesting_level;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgz_z3t6n.java:17: error: cannot find symbol\n        tokenizer.useDelimiter(\"\
    \ \");\n                 ^\n  symbol:   method useDelimiter(String)\n  location:\
    \ variable tokenizer of type StringTokenizer\n/tmp/tmpgz_z3t6n.java:23: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \          nesting_level.add(new Long(tok.length()));\n                      \
    \        ^\n/tmp/tmpgz_z3t6n.java:29: warning: [removal] Long(long) in Long has\
    \ been deprecated and marked for removal\n                nesting_level.add(new\
    \ Long(1));\n                                  ^\n/tmp/tmpgz_z3t6n.java:33: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \              nesting_level.add(new Long(max_level + 1));\n                 \
    \                 ^\n/tmp/tmpgz_z3t6n.java:36: warning: [removal] Long(long) in\
    \ Long has been deprecated and marked for removal\n                nesting_level.add(new\
    \ Long(2));\n                                  ^\n/tmp/tmpgz_z3t6n.java:40: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \              nesting_level.add(new Long(max_level + 1));\n                 \
    \                 ^\n1 error\n5 warnings\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_level = new ArrayList<Long>();\n\
    \        // Convert the string into a tree with each node having two children\n\
    \        Node tree = paren_string.chars().mapToObj(i -> new Node(i))\n       \
    \     .collect(Collectors.toMap(Node::getChar, n -> new ArrayList<Node>() {\n\
    \                ArrayList <Node> children;\n                {\n             \
    \       children = new ArrayList<Node>();\n                    n.children.add(children);\n\
    \                }\n                public Node getChild(int i) {\n          \
    \          return children.get(i);\n                }\n            }, (a, b) ->\
    \ {\n                a.children.add(b);\n                return a;\n         \
    \   }));\n        // Scan the tree to find the deepest level at each node\n  \
    \      for(int i=0;i<tree.size();i++) {\n            Node node = tree.get(i);\n\
    \            int count = 0;\n            // Count all nodes at each level until\
    \ we hit a node with no children\n            while(node.children.size() == 0)\
    \ {\n                count++;\n                node = node.getChild(count);\n\
    \            }\n            // Store the highest level at that node\n        \
    \    max_level.add(new Long(count));\n        }\n        return max_level;\n \
    \   }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp01bvfrl0.java:17: error: cannot find symbol\n        Node tree\
    \ = paren_string.chars().mapToObj(i -> new Node(i))\n        ^\n  symbol:   class\
    \ Node\n  location: class Problem\n/tmp/tmp01bvfrl0.java:17: error: cannot find\
    \ symbol\n        Node tree = paren_string.chars().mapToObj(i -> new Node(i))\n\
    \                                                           ^\n  symbol:   class\
    \ Node\n  location: class Problem\n/tmp/tmp01bvfrl0.java:18: error: cannot find\
    \ symbol\n            .collect(Collectors.toMap(Node::getChar, n -> new ArrayList<Node>()\
    \ {\n                                      ^\n  symbol:   variable Node\n  location:\
    \ class Problem\n/tmp/tmp01bvfrl0.java:18: error: cannot find symbol\n       \
    \     .collect(Collectors.toMap(Node::getChar, n -> new ArrayList<Node>() {\n\
    \                                                                        ^\n \
    \ symbol:   class Node\n  location: class Problem\n/tmp/tmp01bvfrl0.java:19: error:\
    \ cannot find symbol\n                ArrayList <Node> children;\n           \
    \                ^\n  symbol: class Node\n/tmp/tmp01bvfrl0.java:24: error: cannot\
    \ find symbol\n                public Node getChild(int i) {\n               \
    \        ^\n  symbol: class Node\n/tmp/tmp01bvfrl0.java:21: error: cannot find\
    \ symbol\n                    children = new ArrayList<Node>();\n            \
    \                                 ^\n  symbol: class Node\n/tmp/tmp01bvfrl0.java:33:\
    \ error: cannot find symbol\n            Node node = tree.get(i);\n          \
    \  ^\n  symbol:   class Node\n  location: class Problem\n/tmp/tmp01bvfrl0.java:41:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \            max_level.add(new Long(count));\n                          ^\n8 errors\n\
    1 warning\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Use a list to store the final list of parenthesis\
    \ level.\n        ArrayList<Long> paren_level_stack = new ArrayList<>();\n   \
    \     // Use a map to store the level count for each parenthesis\n        Map<String,\
    \ Long> paren_level_count_map = new HashMap<>();\n        List<String> paren_groups\
    \ = paren_string.split(\" +\");\n        // For each parenthesis group\n     \
    \   for (String paren_group: paren_groups) {\n            int group_paren_level\
    \ = paren_group.length();\n            // If this parenthesis group is already\
    \ in the map, then add the parenthesis level to it's value\n            if (paren_level_count_map.containsKey(paren_group))\
    \ {\n                paren_level_count_map.put(paren_group, paren_level_count_map.get(paren_group)\
    \ + group_paren_level);\n            }\n            else {\n                //\
    \ If this parenthesis group doesn't exist in the map, initialize the value to\
    \ 1\n                paren_level_count_map.put(paren_group, group_paren_level);\n\
    \            }\n            // Push the parenthesis group to the stack\n     \
    \       paren_level_stack.add(paren_level_count_map.get(paren_group));\n     \
    \   }\n        // Pop the final parenthesis group (which is on the stack)\n  \
    \      paren_level_stack.remove(0);\n        // Return the final list\n      \
    \  return paren_level_stack;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmaweoajx.java:19: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> paren_groups = paren_string.split(\"\
    \ +\");\n                                                      ^\n/tmp/tmpmaweoajx.java:29:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \ paren_level_count_map.put(paren_group, group_paren_level);\n               \
    \                                        ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> paren_strings = Arrays.asList(paren_string.split(\"\
    \\\\s\"));\n        Map<String, Long> count_map = paren_strings.stream()\n   \
    \             .map(s -> s.matches(\"^\\\\(.*\\\\)$\") ? s.replace(\"(\", \"\\\\\
    (\").replace(\")\", \"\\\\)\") : s)\n                .collect(Collectors.groupingBy(s\
    \ -> s, Collectors.counting()));\n        Map<String, Long> max_map = paren_strings.stream()\n\
    \                .map(s -> s.matches(\"^\\\\(.*\\\\)$\") ? s.replace(\"(\", \"\
    \\\\(\").replace(\")\", \"\\\\)\") : s)\n                .collect(Collectors.toMap(s\
    \ -> s, s -> Long.MAX_VALUE, Math::max));\n        List<String> keys_to_remove\
    \ = max_map.keySet().stream()\n                .filter(s -> count_map.get(s) ==\
    \ max_map.get(s))\n                .collect(Collectors.toList());\n        List<Long>\
    \ result = keys_to_remove.stream().map(s -> max_map.get(s)).collect(Collectors.toList());\n\
    \        return result;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp17ns76hb.java:26: error: incompatible types: List<Long> cannot\
    \ be converted to ArrayList<Long>\n        return result;\n               ^\n\
    1 error\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Initialize a list to return for each group found\
    \ in the string.\n        ArrayList<Long> list_to_return = new ArrayList<>();\n\
    \        String[] group_splits = paren_string.split(\"\\\\)\\\\s\\\\(\");\n  \
    \      for (String group_string : group_splits) {\n            // Initialize a\
    \ counter and a temporary string for storing the current group value.\n      \
    \      long group_counter = 0;\n            String current_group_val = \"\";\n\
    \            // Loop through each character in the current group.\n          \
    \  for (int i = 0; i < group_string.length(); i++) {\n                // If the\
    \ current character is not a parenthesis, increment the counter and continue to\
    \ the next group.\n                if (group_string.charAt(i) != '(') {\n    \
    \                group_counter++;\n                    continue;\n           \
    \     }\n                // If the current character is a parenthesis, increment\
    \ the counter and add the current group value to the\n                // temporary\
    \ string and continue to the next group.\n                group_counter++;\n \
    \               current_group_val += group_string.charAt(i);\n            }\n\
    \            // If the current group's value is not empty add the counter to the\
    \ list to return for the current group.\n            if (!current_group_val.isEmpty())\
    \ {\n                list_to_return.add(group_counter);\n            }\n     \
    \   }\n        // Return the list with the deepest level of nesting of the parenthesis.\n\
    \        return list_to_return;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpe13dlw3f.java:43)\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       ArrayList<String> groups = paren_string.split(\" \");\n        for (int\
    \ i = 0; i < groups.size(); ++i) {\n            if (groups.get(i).equals(\"(\"\
    )) {\n                result.add(new Long(i));\n                groups.set(i);\n\
    \                String nest_str = groups.subList(i + 1, groups.size()).stream().findFirst().get();\n\
    \                for (String s: nest_str.split(\"(?<=\\\\()(?=\\\\))\"))\n   \
    \                 result.add(new Long(Integer.parseInt(s)));\n               \
    \ groups.set(i + 1);\n            }\n        }\n        return result;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgd4qmro8.java:16: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> groups = paren_string.split(\"\
    \ \");\n                                                     ^\n/tmp/tmpgd4qmro8.java:19:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                result.add(new Long(i));\n                           ^\n/tmp/tmpgd4qmro8.java:20:\
    \ error: method set in class ArrayList<E> cannot be applied to given types;\n\
    \                groups.set(i);\n                      ^\n  required: int,String\n\
    \  found:    int\n  reason: actual and formal argument lists differ in length\n\
    \  where E is a type-variable:\n    E extends Object declared in class ArrayList\n\
    /tmp/tmpgd4qmro8.java:23: warning: [removal] Long(long) in Long has been deprecated\
    \ and marked for removal\n                    result.add(new Long(Integer.parseInt(s)));\n\
    \                               ^\n/tmp/tmpgd4qmro8.java:24: error: method set\
    \ in class ArrayList<E> cannot be applied to given types;\n                groups.set(i\
    \ + 1);\n                      ^\n  required: int,String\n  found:    int\n  reason:\
    \ actual and formal argument lists differ in length\n  where E is a type-variable:\n\
    \    E extends Object declared in class ArrayList\n3 errors\n2 warnings\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Declare a list to store the results\n        ArrayList<Long>\
    \ results = new ArrayList<>();\n        // Declare variables to store the parenthesis\
    \ groups\n        String group1 = \"\", group2 = \"\", group3 = \"\";\n      \
    \  // The current level of nesting level of parentheses.\n        int current_level\
    \ = 0;\n        // For every group\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            // For every character in the group\n            for (int\
    \ j = 0; j < paren_string.charAt(i); j++) {\n                // If the character\
    \ is an open parenthesis\n                if (paren_string.charAt(i) == '(') {\n\
    \                    // Increment the level of nesting\n                    current_level++;\n\
    \                    // If the level of nesting is greater than the previous level\n\
    \                    if (current_level > results.size()) {\n                 \
    \       // Add the current level of nesting\n                        results.add(current_level);\n\
    \                    }\n                    // If the level of nesting equals\
    \ the previous level\n                    if (current_level == results.size())\
    \ {\n                        // Add the current level of nesting with the count\
    \ of open parenthesis\n                        results.add(current_level);\n \
    \                   } else if (current_level < results.size()) {\n           \
    \             // Add the current level of nesting with the count of closed parenthesis\n\
    \                        results.add(current_level - 1);\n                   \
    \ }\n                // If the character is an open parenthesis\n            \
    \    } else if (paren_string.charAt(i) == ')') {\n                    // Decrement\
    \ the level of nesting\n                    current_level--;\n               \
    \ // If the level of nesting equals the previous level\n                } else\
    \ if (current_level == results.size()) {\n                    // Add the current\
    \ level of nesting with the count of open parenthesis\n                    results.add(current_level);\n\
    \                }\n            }\n        }\n        return results;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyp8c67mp.java:32: error: incompatible types: int cannot be converted\
    \ to Long\n                        results.add(current_level);\n             \
    \                       ^\n/tmp/tmpyp8c67mp.java:37: error: incompatible types:\
    \ int cannot be converted to Long\n                        results.add(current_level);\n\
    \                                    ^\n/tmp/tmpyp8c67mp.java:40: error: incompatible\
    \ types: int cannot be converted to Long\n                        results.add(current_level\
    \ - 1);\n                                                  ^\n/tmp/tmpyp8c67mp.java:49:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \     results.add(current_level);\n                                ^\nNote: Some\
    \ messages have been simplified; recompile with -Xdiags:verbose to get full output\n\
    4 errors\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       ArrayList<Long> nested = new ArrayList<Long>();\n        ArrayList<Long>\
    \ stack = new ArrayList<Long>();\n\n        paren_string = paren_string.replaceAll(\"\
    (()|\\\\)|\\\\{|\\\\}|\\\\,|\\\\.|;|:|\\\\[|\\\\]|!\", \"\");\n        paren_string\
    \ = paren_string.trim();\n\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                nested.add(Long.valueOf(stack.size()));\n\
    \                stack.push(Long.valueOf(stack.size()));\n            } else if\
    \ (c == ')') {\n                while (nested.size() > 0) {\n                \
    \    Long level_of_nesting = nested.get(nested.size() - 1);\n                \
    \    while (stack.size() > level_of_nesting) {\n                        stack.pop();\n\
    \                    }\n                    nested.remove(nested.size() - 1);\n\
    \                }\n            } else if (c == '{') {\n                nested.add(Long.valueOf(stack.size()));\n\
    \                stack.push(Long.valueOf(stack.size()));\n            } else if\
    \ (c == '}') {\n                while (nested.size() > 0) {\n                \
    \    Long level_of_nesting = nested.get(nested.size() - 1);\n                \
    \    while (stack.size() > level_of_nesting) {\n                        stack.pop();\n\
    \                    }\n                    nested.remove(nested.size() - 1);\n\
    \                }\n            } else if (c == ',') {\n                while\
    \ (nested.size() > 0) {\n                    Long level_of_nesting = nested.get(nested.size()\
    \ - 1);\n                    while (stack.size() > level_of_nesting) {\n     \
    \                   stack.pop();\n                    }\n                    nested.remove(nested.size()\
    \ - 1);\n                }\n            } else if (c == ':') {\n             \
    \   while (nested.size() > 0) {\n                    Long level_of_nesting = nested.get(nested.size()\
    \ - 1);\n                    while (stack.size() > level_of_nesting) {\n     \
    \                   stack.pop();\n                    }\n                    nested.remove(nested.size()\
    \ - 1);\n                }\n            } else if (c == '[') {\n             \
    \   while (nested.size() > 0) {\n                    Long level_of_nesting = nested.get(nested.size()\
    \ - 1);\n                    while (stack.size() > level_of_nesting) {\n     \
    \                   stack.pop();\n                    }\n                    nested.remove(nested.size()\
    \ - 1);\n                }\n            } else if (c == ']') {\n             \
    \   while (nested.size() > 0) {\n                    Long level_of_nesting = nested.get(nested.size()\
    \ - 1);\n                    while (stack.size() > level_of_nesting) {\n     \
    \                   stack.pop();\n                    }\n                    nested.remove(nested.size()\
    \ - 1);\n                }\n            } else if (c == '.') {\n             \
    \   while (nested.size() > 0) {\n                    Long level_of_nesting = nested.get(nested.size()\
    \ - 1);\n                    \n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp926rhl57.java:82: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n1 error\n"
  stdout: ''
  timestamp: 1660011443
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Using a stack to keep track of parentheses level\n\
    \        ArrayList<Long> levels = new ArrayList<Long>();\n        ArrayList<Long>\
    \ stack_tops = new ArrayList<Long>();\n        stack_tops.add(Long.MIN_VALUE);\n\
    \        stack_tops.add(Long.MIN_VALUE);\n        stack_tops.add(Long.MIN_VALUE);\n\
    \        for (int i = 0; i < paren_string.length(); i++) {\n            char ch\
    \ = paren_string.charAt(i);\n            if (ch == '(') stack_tops.peek()++;\n\
    \            else if (ch == ')') {\n                stack_tops.poll();\n     \
    \           if (stack_tops.size() > 0) {\n                    stack_tops.add(Long.MIN_VALUE);\n\
    \                }\n            }\n            else if (ch != ' ' && ch != '\\\
    t' && ch != '\\r' && ch != '\\n') {\n                stack_tops.peek()++;\n  \
    \          }\n            if (stack_tops.size() > 0) {\n                stack_tops.poll();\n\
    \            }\n            if (ch == ')' && stack_tops.size() == 0) {\n     \
    \           levels.add(stack_tops.get(0));\n            }\n        }\n       \
    \ return levels;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvszbo2t4.java:23: error: cannot find symbol\n            if (ch\
    \ == '(') stack_tops.peek()++;\n                                     ^\n  symbol:\
    \   method peek()\n  location: variable stack_tops of type ArrayList<Long>\n/tmp/tmpvszbo2t4.java:25:\
    \ error: cannot find symbol\n                stack_tops.poll();\n            \
    \              ^\n  symbol:   method poll()\n  location: variable stack_tops of\
    \ type ArrayList<Long>\n/tmp/tmpvszbo2t4.java:31: error: cannot find symbol\n\
    \                stack_tops.peek()++;\n                          ^\n  symbol:\
    \   method peek()\n  location: variable stack_tops of type ArrayList<Long>\n/tmp/tmpvszbo2t4.java:34:\
    \ error: cannot find symbol\n                stack_tops.poll();\n            \
    \              ^\n  symbol:   method poll()\n  location: variable stack_tops of\
    \ type ArrayList<Long>\n4 errors\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> depths = new ArrayList<>();\n     \
    \   // Loop through each string and check for \"(\" \")\" pairs.\n        for\
    \ (String s : paren_string.split(\" \")) {\n            // If it starts with \"\
    (\" \")\" then keep track of depth\n            if (s.startsWith(\"(\") && s.endsWith(\"\
    )\")) {\n                depths.add(Long.parseLong(s.substring(1, s.length() -\
    \ 1)));\n                continue;\n            }\n            // If it starts\
    \ with \"(\" \")\" then check if we have reached a depth of zero\n           \
    \ if (s.startsWith(\"(\") && depths.size() == 0) {\n                depths.add(Long.parseLong(s.substring(1,\
    \ s.length() - 1)));\n                continue;\n            }\n            //\
    \ If not then recurse with the remaining string\n            depths.add(parseNestedParens(s));\n\
    \        }\n        return depths;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x1tzw6p.java:29: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n            depths.add(parseNestedParens(s));\n      \
    \                                  ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> list_to_return = new ArrayList<Long>();\n\
    \        StringTokenizer tokenizer = new StringTokenizer(paren_string);\n    \
    \    while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken();\n\
    \            if (token.equals(\"(\")) {\n                list_to_return.add(new\
    \ Long(1));\n            } else if (token.equals(\")\")) {\n                Long\
    \ current_level = list_to_return.get(list_to_return.size() - 1);\n           \
    \     if (current_level == null) {\n                    // We have reached the\
    \ last level of nesting\n                    // So just add this closing parenthesis\
    \ level to the list\n                    list_to_return.add(new Long(1));\n  \
    \              } else {\n                    // This is an intermediate level\
    \ of nesting\n                    // So just add the number to the list\n    \
    \                list_to_return.add(current_level);\n                }\n     \
    \       }\n        }\n        Collections.sort(list_to_return);\n        return\
    \ list_to_return;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfb7hpl9a.java:38)\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nestedParens = new ArrayList<Long>();\n\
    \        // Use recursion until no more groups are found.\n        parseNestedParens(paren_string,\
    \ 0, nestedParens);\n        return nestedParens;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplf3ixr55.java:17: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        parseNestedParens(paren_string, 0,\
    \ nestedParens);\n        ^\n  required: String\n  found:    String,int,ArrayList<Long>\n\
    \  reason: actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> list = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> nestedParens = new ArrayList<>();\n        Stack<Long>\
    \ parens = new Stack<>();\n        Long level = 0;\n        for (int i = 0; i\
    \ < list.size(); i++) {\n            String word = list.get(i);\n            if\
    \ (word.equals(\"(\")) {\n                parens.push(level);\n              \
    \  level++;\n            } else if (word.equals(\")\")) {\n                if\
    \ (parens.isEmpty()) {\n                    return null;\n                }\n\
    \                Long level = parens.pop();\n                nestedParens.add(level);\n\
    \            } else {\n                if (parens.isEmpty()) {\n             \
    \       nestedParens.add(Long.valueOf(word));\n                } else {\n    \
    \                Long level = parens.pop();\n                    nestedParens.add(level);\n\
    \                    nestedParens.add(Long.valueOf(word));\n                }\n\
    \            }\n        }\n        if (parens.isEmpty()) {\n            return\
    \ null;\n        }\n        return nestedParens;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbrn9yebl.java:18: error: incompatible types: int cannot be converted\
    \ to Long\n        Long level = 0;\n                     ^\n/tmp/tmpbrn9yebl.java:28:\
    \ error: variable level is already defined in method parseNestedParens(String)\n\
    \                Long level = parens.pop();\n                     ^\n/tmp/tmpbrn9yebl.java:34:\
    \ error: variable level is already defined in method parseNestedParens(String)\n\
    \                    Long level = parens.pop();\n                         ^\n\
    3 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parentheses_level = Arrays.asList();\n\
    \        ArrayList<String> nested_parens = Arrays.asList();\n        List<String>\
    \ nested_parens_list = new ArrayList<>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            String current_char = paren_string.substring(i, i + 1);\n\
    \            if (current_char.equals(\"\")) {\n                parentheses_level.add(0l);\n\
    \                nested_parens_list.add(nested_parens);\n                parentheses_level.stream().mapToLong(l\
    \ -> l).forEach(parentheses_level::add);\n                nested_parens = new\
    \ ArrayList<>();\n            } else if (nested_parens.stream().noneMatch(p ->\
    \ p.contains(current_char))) {\n                nested_parens.add(current_char);\n\
    \            } else {\n                parentheses_level.add(new Long(nested_parens.size()));\n\
    \                nested_parens_list.add(nested_parens);\n                parentheses_level.stream().mapToLong(l\
    \ -> l).forEach(parentheses_level::add);\n                parentheses_level.stream().forEachOrdered(l\
    \ -> nested_parens.remove(nested_parens.stream().filter(p -> p.equals(current_char)).findFirst().get()));\n\
    \            }\n        }\n        parentheses_level.stream().mapToLong(l -> l).forEach(parentheses_level::add);\n\
    \        return parentheses_level;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnm4phlom.java:15: error: incompatible types: no instance(s) of\
    \ type variable(s) T exist so that List<T> conforms to ArrayList<Long>\n     \
    \   ArrayList<Long> parentheses_level = Arrays.asList();\n                   \
    \                                      ^\n  where T is a type-variable:\n    T\
    \ extends Object declared in method <T>asList(T...)\n/tmp/tmpnm4phlom.java:16:\
    \ error: incompatible types: no instance(s) of type variable(s) T exist so that\
    \ List<T> conforms to ArrayList<String>\n        ArrayList<String> nested_parens\
    \ = Arrays.asList();\n                                                       ^\n\
    \  where T is a type-variable:\n    T extends Object declared in method <T>asList(T...)\n\
    /tmp/tmpnm4phlom.java:22: error: incompatible types: ArrayList<String> cannot\
    \ be converted to String\n                nested_parens_list.add(nested_parens);\n\
    \                                       ^\n/tmp/tmpnm4phlom.java:28: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \              parentheses_level.add(new Long(nested_parens.size()));\n      \
    \                                ^\n/tmp/tmpnm4phlom.java:29: error: incompatible\
    \ types: ArrayList<String> cannot be converted to String\n                nested_parens_list.add(nested_parens);\n\
    \                                       ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n4 errors\n1 warning\n"
  stdout: ''
  timestamp: 1660011444
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // This implementation is straightforward and can be\
    \ optimised easily.\n        // The idea is to keep track of the positions where\n\
    \        // the parentheses are nested. Once we find these,\n        // we print\
    \ the maximum depth.\n        int num_left_bracket = 0;\n        int num_right_bracket\
    \ = 0;\n        ArrayList<Integer> positions = new ArrayList<Integer>();\n   \
    \     for (int i = 0; i < paren_string.length(); ++i) {\n            char c =\
    \ paren_string.charAt(i);\n            switch (c) {\n            case '(':\n \
    \               num_left_bracket++;\n                break;\n            case\
    \ ')':\n                num_right_bracket++;\n                break;\n       \
    \     case '(':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '<':\n            case '>':\n\
    \            case '(':\n            case ')':\n            case '[':\n       \
    \     case ']':\n            case '{':\n            case '}':\n            case\
    \ '<':\n            case '>':\n                positions.add(i);\n           \
    \     break;\n            }\n        }\n        for (int i = 0; i < positions.size();\
    \ ++i) {\n            int start = positions.get(i);\n            int end = positions.get(i\
    \ + 1);\n            int depth = 0;\n            while (start < end) {\n     \
    \           char c = paren_string.charAt(start);\n                switch (c) {\n\
    \                case '(':\n                    depth++;\n                   \
    \ break;\n                case ')':\n                    depth--;\n          \
    \          break;\n                }\n                ++start;\n            }\n\
    \            positions.remove(i + 1);\n            positions.add(i, depth);\n\
    \        }\n        ArrayList<Long> depths = new ArrayList<Long>();\n        for\
    \ (int i = 0; i < positions.size(); ++i) {\n            int start = positions.get(i);\n\
    \            int end = positions.get(i + 1);\n            depths.add(end - start);\n\
    \            positions.remove(i + 1);\n        }\n        Arrays.sort(depths);\n\
    \        return depths;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp05_rk2my.java:31: error: duplicate case label\n            case\
    \ '(':\n            ^\n/tmp/tmp05_rk2my.java:38: error: duplicate case label\n\
    \            case '(':\n            ^\n/tmp/tmp05_rk2my.java:39: error: duplicate\
    \ case label\n            case ')':\n            ^\n/tmp/tmp05_rk2my.java:40:\
    \ error: duplicate case label\n            case '[':\n            ^\n/tmp/tmp05_rk2my.java:41:\
    \ error: duplicate case label\n            case ']':\n            ^\n/tmp/tmp05_rk2my.java:42:\
    \ error: duplicate case label\n            case '{':\n            ^\n/tmp/tmp05_rk2my.java:43:\
    \ error: duplicate case label\n            case '}':\n            ^\n/tmp/tmp05_rk2my.java:44:\
    \ error: duplicate case label\n            case '<':\n            ^\n/tmp/tmp05_rk2my.java:45:\
    \ error: duplicate case label\n            case '>':\n            ^\n/tmp/tmp05_rk2my.java:73:\
    \ error: incompatible types: int cannot be converted to Long\n            depths.add(end\
    \ - start);\n                           ^\n/tmp/tmp05_rk2my.java:76: error: no\
    \ suitable method found for sort(ArrayList<Long>)\n        Arrays.sort(depths);\n\
    \              ^\n    method Arrays.sort(int[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to int[])\n    method Arrays.sort(long[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to long[])\n    method Arrays.sort(short[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to short[])\n    method Arrays.sort(char[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to char[])\n    method Arrays.sort(byte[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to byte[])\n    method Arrays.sort(float[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> cannot be converted\
    \ to float[])\n    method Arrays.sort(double[]) is not applicable\n      (argument\
    \ mismatch; ArrayList<Long> cannot be converted to double[])\n    method Arrays.sort(Object[])\
    \ is not applicable\n      (argument mismatch; ArrayList<Long> canno"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       \n        //We need to handle paren strings like:\n        // \"(()()\"\
    \n        // \"(((()))\"\n        // \"(((())))\"\n        \n        // First\
    \ split all the paren strings into an array\n        ArrayList<String> paren_strings\
    \ = paren_string.trim().split(\"\\\\s+\");\n        \n        // Now find all\
    \ the opening parens\n        ArrayList<String> opening_parens = new ArrayList<String>();\n\
    \        \n        // Now loop through all the strings in the array and see if\
    \ they are opening parens\n        for(String string : paren_strings) {\n    \
    \        if(!string.startsWith(\"(\")) {\n                opening_parens.add(string);\n\
    \            }\n        }\n        \n        // Now we know how many opening parens\
    \ we have\n        // We need to keep track of how many opening parens we see\
    \ in each level\n        Map<Integer, Integer> paren_count = new HashMap<Integer,\
    \ Integer>();\n        \n        // Now we go through the paren strings and increment\
    \ the count in paren_count for each level\n        // We do this in two steps:\n\
    \        // 1. loop through all the opening_parens\n        // 2. loop through\
    \ the string and count how many opening_parens we see in each level\n        for(int\
    \ i = 0; i < opening_parens.size(); i++) {\n            String opening_paren =\
    \ opening_parens.get(i);\n            \n            // Increment the count for\
    \ the level\n            int level = paren_count.get(opening_parens.size());\n\
    \            paren_count.put(opening_parens.size(), level + 1);\n            \n\
    \            // Now lets see if we can find another closing paren in the string\n\
    \            for(int j = 0; j < paren_strings.size(); j++) {\n               \
    \ if(paren_strings.get(j).endsWith(opening_paren)) {\n                    String\
    \ closing_paren = paren_strings.get(j).substring(0, paren_strings.get(j).length()\
    \ - opening_paren.length());\n                    int level_with_parens = paren_count.get(opening_parens.size());\n\
    \                    \n                    // We found a closing paren! Increment\
    \ the count in the paren_count map for the level now\n                    paren_count.put(opening_parens.size(),\
    \ level_with_parens + 1);\n                    \n                    // We now\
    \ have the count of parens in each level\n                    result.add(paren_count.get(opening_parens.size()));\n\
    \                    \n                    // We return now\n                \
    \    break;\n                }\n            }\n        }\n        \n        //\
    \ We return the result list\n        return result;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp4hcqxqg.java:23: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> paren_strings = paren_string.trim().split(\"\
    \\\\s+\");\n                                                                 \
    \  ^\n/tmp/tmpp4hcqxqg.java:60: error: incompatible types: Integer cannot be converted\
    \ to Long\n                    result.add(paren_count.get(opening_parens.size()));\n\
    \                                              ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, new ArrayList<Long>());\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp26ntaqfs.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ new ArrayList<Long>());\n               ^\n  required: String\n  found:    String,ArrayList<Long>\n\
    \  reason: actual and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011442
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // TODO: Handle other kinds of nesting.\n        ArrayList<Long>\
    \ nested_levels = new ArrayList<Long>();\n        HashMap<String, ArrayList<Long>>\
    \ paren_map = new HashMap<String, ArrayList<Long>>();\n        ArrayList<String>\
    \ paren_keys = new ArrayList<String>();\n        paren_map.put(paren_string, paren_keys);\n\
    \        paren_keys.add(paren_string);\n        boolean in_paren = false;\n  \
    \      for(int i = 0; i < paren_string.length(); i++) {\n            char current_char\
    \ = paren_string.charAt(i);\n            if(in_paren == true) {\n            \
    \    if(current_char == '(') {\n                    in_paren = false;\n      \
    \          } else if(current_char == ')') {\n                    String paren_string_to_add\
    \ = paren_keys.get(paren_keys.size() - 1);\n                    ArrayList<Long>\
    \ levels = paren_map.get(paren_string_to_add);\n                    if(levels\
    \ == null) {\n                        levels = new ArrayList<Long>();\n      \
    \                  paren_map.put(paren_string_to_add, levels);\n             \
    \       }\n                    levels.add((long)1);\n                    paren_keys.remove(paren_keys.size()\
    \ - 1);\n                    nested_levels.add(levels.get((levels.size() -1))\
    \ );\n                }\n            }\n            else if(current_char == '(')\
    \ {\n                in_paren = true;\n            }\n            else if(current_char\
    \ == ')') {\n                in_paren = false;\n                String paren_string_to_add\
    \ = paren_keys.get(paren_keys.size() - 1);\n                ArrayList<Long> levels\
    \ = paren_map.get(paren_string_to_add);\n                if(levels == null) {\n\
    \                    levels = new ArrayList<Long>();\n                    paren_map.put(paren_string_to_add,\
    \ levels);\n                }\n                levels.add((long)1);\n        \
    \        paren_keys.remove(paren_keys.size() - 1);\n                nested_levels.add(levels.get((levels.size()\
    \ -1)) );\n            }\n        }\n        ArrayList<Long> deepest_levels =\
    \ new ArrayList<Long>();\n        for(ArrayList<Long> levels : paren_map.values())\
    \ {\n            int max_level = -1;\n            String max_level_str = -1;\n\
    \            for(int level : levels) {\n                if(level > max_level)\
    \ {\n                    max_level = level;\n                    max_level_str\
    \ = String.valueOf(level);\n                }\n            }\n            deepest_levels.add(new\
    \ Long(max_level_str));\n        }\n        return deepest_levels;\n    }\n  \
    \  public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd4cwxhre.java:19: error: incompatible types: ArrayList<String>\
    \ cannot be converted to ArrayList<Long>\n        paren_map.put(paren_string,\
    \ paren_keys);\n                                    ^\n/tmp/tmpd4cwxhre.java:58:\
    \ error: incompatible types: int cannot be converted to String\n            String\
    \ max_level_str = -1;\n                                   ^\n/tmp/tmpd4cwxhre.java:59:\
    \ error: incompatible types: Long cannot be converted to int\n            for(int\
    \ level : levels) {\n                            ^\n/tmp/tmpd4cwxhre.java:65:\
    \ warning: [removal] Long(String) in Long has been deprecated and marked for removal\n\
    \            deepest_levels.add(new Long(max_level_str));\n                  \
    \             ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n3 errors\n1 warning\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result_list = new ArrayList<Long>();\n\
    \        long curr_level = 0;\n        long last_open_paren = 0;\n        long\
    \ last_close_paren = 0;\n        for(String str : paren_string.split(\"\\\\s+\"\
    )) {\n            result_list.add(str.length());\n            for(String str2\
    \ : str.split(\"\\\\(\")) {\n                result_list.set(result_list.size()\
    \ - 1, result_list.get(result_list.size() - 1) + curr_level);\n              \
    \  if(str2.length() > 1) {\n                    curr_level++;\n              \
    \      if(curr_level == last_open_paren) {\n                        result_list.set(result_list.size()\
    \ - 1, result_list.get(result_list.size() - 1) + last_close_paren);\n        \
    \                curr_level--;\n                    }\n                    if(curr_level\
    \ == last_close_paren) {\n                        result_list.set(result_list.size()\
    \ - 1, result_list.get(result_list.size() - 1) + last_open_paren);\n         \
    \               curr_level--;\n                    }\n                }\n    \
    \        }\n            last_open_paren = curr_level;\n            last_close_paren\
    \ = curr_level;\n            curr_level = 0;\n        }\n        result_list.add(result_list.size());\n\
    \        return result_list;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5swo3fkb.java:20: error: incompatible types: int cannot be converted\
    \ to Long\n            result_list.add(str.length());\n                      \
    \                ^\n/tmp/tmp5swo3fkb.java:39: error: incompatible types: int cannot\
    \ be converted to Long\n        result_list.add(result_list.size());\n       \
    \                                 ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Convert paren_string into a string\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\s+\", \"\");\n        // Use stack to track\
    \ each level of nesting\n        ArrayList<Long> stack = new ArrayList<Long>();\n\
    \        // Use recursion to compute depth of each level of nesting\n        ArrayList<Long>\
    \ depths = paren_string.substring(0, paren_string.indexOf('(')).split(\"\\\\s+\"\
    );\n        long maxDepth = 0;\n        for (long depth : depths) {\n        \
    \    if (depth > maxDepth) {\n                maxDepth = depth;\n            }\n\
    \        }\n        // Initialize result list with maxDepth + 1 items\n      \
    \  ArrayList<Long> results = new ArrayList<Long>();\n        results.add(maxDepth\
    \ + 1);\n        // For each nested level of nesting, append the deepest level\
    \ into the result list\n        for (long i = 1; i < maxDepth + 1; i++) {\n  \
    \          while (stack.size() <= i) {\n                stack.add(0);\n      \
    \      }\n            stack.set(i, stack.get(i - 1));\n            // If at the\
    \ deepest level, append the depth into the result list\n            if (stack.get(i)\
    \ == maxDepth) {\n                results.add(maxDepth);\n            } else {\n\
    \                // Otherwise append the depth of each of the children of the\
    \ current level\n                for (long j = 0; j < depths.get(i); j++) {\n\
    \                    results.add(stack.get(stack.size() - 1) + j + 1);\n     \
    \           }\n            }\n        }\n        return results;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpes62opbi.java:20: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<Long>\n        ArrayList<Long> depths = paren_string.substring(0,\
    \ paren_string.indexOf('(')).split(\"\\\\s+\");\n                            \
    \                                                               ^\n/tmp/tmpes62opbi.java:33:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \ stack.add(0);\n                          ^\n/tmp/tmpes62opbi.java:35: error:\
    \ incompatible types: possible lossy conversion from long to int\n           \
    \ stack.set(i, stack.get(i - 1));\n                                     ^\n/tmp/tmpes62opbi.java:37:\
    \ error: incompatible types: possible lossy conversion from long to int\n    \
    \        if (stack.get(i) == maxDepth) {\n                          ^\n/tmp/tmpes62opbi.java:41:\
    \ error: incompatible types: possible lossy conversion from long to int\n    \
    \            for (long j = 0; j < depths.get(i); j++) {\n                    \
    \                            ^\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n5 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<>();\n     \
    \   paren_string.trim().replaceAll(\"(\\\\d+\\\\s)+\", \" $1\").split(\" \");\n\
    \        for (String sub_string : paren_string) {\n            result.add(getMaxDepth(sub_string));\n\
    \        }\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdc7wrv9u.java:17: error: for-each not applicable to expression\
    \ type\n        for (String sub_string : paren_string) {\n                   \
    \              ^\n  required: array or java.lang.Iterable\n  found:    String\n\
    /tmp/tmpdc7wrv9u.java:18: error: cannot find symbol\n            result.add(getMaxDepth(sub_string));\n\
    \                       ^\n  symbol:   method getMaxDepth(String)\n  location:\
    \ class Problem\n2 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> return_array = new ArrayList<Long>();\n\
    \        StringTokenizer tok = new StringTokenizer(paren_string);\n        while\
    \ (tok.hasMoreTokens()) {\n            String cur_token = tok.nextToken();\n \
    \           if (cur_token.startsWith(\"(\")) {\n                return_array.add((long)return_array.size());\n\
    \            } else if (cur_token.startsWith(\")\") || cur_token.startsWith(\"\
    (\")) {\n                return_array.remove((long)return_array.size()-1);\n \
    \           }\n        }\n        return return_array;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_lzckqkr.java:28)\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Split strings into nested parentheses.\n       \
    \ String[] parts = paren_string.split(\" \");\n        // Initialize depth to\
    \ 0.\n        int depth = 0;\n        // Initialize results to an empty list.\n\
    \        ArrayList<Long> result = new ArrayList<>();\n        // Iterate through\
    \ all the parts.\n        for (String part : parts) {\n            // If current\
    \ part contains nested parentheses, increase the depth.\n            if (part.contains(\"\
    (\")) {\n                depth++;\n            }\n            // If the current\
    \ part contains nested parentheses and we are at the deepest level of nesting,\
    \ add it to the results.\n            if (part.contains(\"(\") && depth > 0) {\n\
    \                result.add(new Long(depth));\n            }\n        }\n    \
    \    // Return the results.\n        return result;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcw41l87p.java:36)\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_levels = new ArrayList<>();\n\
    \        HashSet<String> current_group_set;\n        HashMap<String, ArrayList<String>>\
    \ current_group = new HashMap<>();\n        for (String group : paren_string.split(\"\
    \ \")) {\n            current_group_set = new HashSet<>();\n            current_group.put(group,\
    \ current_group_set);\n            for (int i = 0; i < group.length(); i++) {\n\
    \                char c = group.charAt(i);\n                if (c == '(') {\n\
    \                    current_group_set.add(\"(\");\n                } else if\
    \ (c == ')') {\n                    if (current_group_set.contains(\"(\")) {\n\
    \                        current_group_set.remove(current_group_set.size() - 1);\n\
    \                    }\n                    nested_levels.add(Long.valueOf(current_group_set.size()));\n\
    \                }\n            }\n        }\n        return nested_levels;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsqfaa5fs.java:20: error: incompatible types: HashSet<String> cannot\
    \ be converted to ArrayList<String>\n            current_group.put(group, current_group_set);\n\
    \                                     ^\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // We are just working with single dimensional arrays,\
    \ so we are able to use Arrays.asList.\n        // We are using Long here to represent\
    \ integer numbers with up to 19 digits (i.e., numbers with more than 19 digits\
    \ are represented differently by Long).\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        // If there are no more parentheses in the string, return empty array.\n\
    \        if (!paren_string.isEmpty()) {\n            try {\n                String\
    \ s = paren_string.substring(0, paren_string.length() - 1);\n                for\
    \ (String s_next : s.split(\"\\\\s+\")) {\n                    res.add(new Long(s_next));\n\
    \                }\n            } catch (NumberFormatException exc) {\n      \
    \          System.out.println(\"Invalid input.\");\n            }\n        }\n\
    \        return res;\n    }\n    public static void main(String[] args) {\n  \
    \  assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpg3e5d_4g.java:32)\n"
  stdout: 'Invalid input.

    '
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Declare a new array to store the result in\n   \
    \     ArrayList<Long> max_level = new ArrayList<Long>();\n        // Declare a\
    \ variable to store the deepest level found so far\n        long deepest_level\
    \ = 0;\n        // Declare a variable to store the current level of nesting\n\
    \        long current_level = 0;\n        String[] parts = paren_string.split(\"\
    \ \");\n        for (String part : parts) {\n            // If this is the first\
    \ nested parenthesis, make it the current level\n            if (current_level\
    \ == 0) {\n                current_level = Integer.parseInt(part);\n         \
    \       // If the current level is greater than deepest level, we update the deepest\
    \ level\n                if (current_level > deepest_level) deepest_level = current_level;\n\
    \            }\n            // If this is the second nested parenthesis, we make\
    \ current_level equal to deepest_level\n            if (current_level == deepest_level)\
    \ {\n                // If the current level is greater than deepest level, make\
    \ current_level equal to deepest_level\n                if (current_level > deepest_level)\
    \ deepest_level = current_level;\n                // Otherwise, make current_level\
    \ equal to current_level + 1\n                else current_level++;\n        \
    \    }\n            // If this is the third nested parenthesis, we make current_level\
    \ equal to deepest_level\n            if (current_level == deepest_level) {\n\
    \                // If the current level is greater than deepest level, make current_level\
    \ equal to deepest_level\n                if (current_level > deepest_level) deepest_level\
    \ = current_level;\n                // Otherwise, make current_level equal to\
    \ current_level + 1\n                else current_level++;\n            }\n  \
    \          // If the current_level is not equal to the deepest level, then the\
    \ parentheses are not nested properly\n            if (current_level > deepest_level)\
    \ {\n                deepest_level = current_level;\n            }\n         \
    \   // If this is the final nested parenthesis, we add it to the max_level array\n\
    \            if (current_level == deepest_level) {\n                max_level.add(deepest_level);\n\
    \            }\n        }\n        return max_level;\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NumberFormatException: For input\
    \ string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:654)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat Problem.parseNestedParens(tmps4_l5fn2.java:25)\n\tat Problem.main(tmps4_l5fn2.java:55)\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> output = new ArrayList<Long>();\n \
    \       ArrayList<Long> level_stack = new ArrayList<Long>();\n        ArrayList<Long>\
    \ current_level = new ArrayList<Long>();\n        ArrayList<Long> deepest_level\
    \ = new ArrayList<Long>();\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char c = paren_string.charAt(i);\n            if (c == '(')\
    \ {\n                current_level.add(i);\n            } else if (c == ')') {\n\
    \                boolean has_deepest_level = false;\n                if (level_stack.size()\
    \ == 0) {\n                    deepest_level.add(current_level.get(0));\n    \
    \            } else {\n                    int deepest_level_top = level_stack.size()\
    \ - 1;\n                    ArrayList<Long> current_level_top = current_level.remove(deepest_level_top);\n\
    \                    int current_level_length = current_level_top.size() - 1;\n\
    \                    boolean has_deepest_level_top = false;\n                \
    \    for (int k = 0; k < deepest_level.size() && has_deepest_level_top == false;\
    \ k++) {\n                        int deepest_level_top_k = deepest_level.size()\
    \ - 1;\n                        ArrayList<Long> current_level_top_k = current_level.remove(deepest_level_top_k);\n\
    \                        int current_level_top_k_length = current_level_top_k.size()\
    \ - 1;\n                        if (current_level_top_k_length == deepest_level_top)\
    \ {\n                            deepest_level.add(current_level_top.get(0));\n\
    \                            has_deepest_level_top = true;\n                 \
    \       }\n                    }\n                }\n                output.add(deepest_level.get(0));\n\
    \                current_level.add(i);\n                level_stack.add(deepest_level);\n\
    \            } else if (c == ' ') {\n                if (level_stack.size() >\
    \ 0) {\n                    ArrayList<Long> level_list = level_stack.get(level_stack.size()\
    \ - 1);\n                    current_level.add(level_list.get(0));\n         \
    \           level_list.add(current_level);\n                    level_stack.remove(level_stack.size()\
    \ - 1);\n                }\n                current_level.add(i);\n          \
    \  }\n        }\n        if (level_stack.size() > 0) {\n            ArrayList<Long>\
    \ level_list = level_stack.get(level_stack.size() - 1);\n            ArrayList<Long>\
    \ current_level_top = current_level.remove(level_stack.size() - 1);\n        \
    \    current_level.add(0, level_list);\n            current_level.add(0, current_level_top);\n\
    \            output.add(deepest_level.get(0));\n        }\n        output.add(deepest_level.get(0));\n\
    \        ArrayList<Long> output_copy = new ArrayList<Long>(output);\n        for\
    \ (Long i : output_copy) {\n            if (i >= 1L && i <= 3L)\n            \
    \    continue;\n            if (i == 1L)\n                i = 2L;\n          \
    \  else if (i == 2L)\n                i = 3L;\n            else if (i == 3L)\n\
    \n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq924iv4g.java:73: error: illegal start of statement\n    }\n  \
    \  ^\n/tmp/tmpq924iv4g.java:74: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   List<String> levelsOfParenthesis = paren_string.split(\"\\\\s+\");\n     \
    \   System.out.println(levelsOfParenthesis);\n        for (int i = 0; i < levelsOfParenthesis.size();\
    \ i++) {\n            if (levelsOfParenthesis.get(i).contains(\"(\")) {\n    \
    \            levels.add(Long.valueOf(levelsOfParenthesis.get(i).split(\"\\\\(\"\
    )[1]));\n            }\n        }\n        System.out.println(\"Levels of parenthesis:\
    \ \" + levels);\n        return levels;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpixhloqp0.java:16: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> levelsOfParenthesis = paren_string.split(\"\
    \\\\s+\");\n                                                             ^\n1\
    \ error\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        long max_nesting = 0;\n        // Loop through each\
    \ group (the groups are separated by spaces)\n        for (String group : paren_string.split(\"\
    \ \")) {\n            // Loop through each opening bracket\n            for (int\
    \ i = 0; i < group.length(); i++) {\n                // Loop to find if there\
    \ are any closing brackets\n                boolean found = false;\n         \
    \       for (int j = i; j < group.length() && found == false; j++) {\n       \
    \             // If closing bracket found\n                    if (group.charAt(j)\
    \ == ')') {\n                        // Update max nesting and stop searching\n\
    \                        max_nesting = Math.max(max_nesting, j - i);\n       \
    \                 found = true;\n                    }\n                }\n  \
    \              // If no closing bracket found within that group\n            \
    \    if (found == false) {\n                    break;\n                }\n  \
    \          }\n        }\n        // Return max nesting of each group\n       \
    \ return new ArrayList<Long>(Arrays.asList(max_nesting));\n    }\n    public static\
    \ void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) ()\
    \ ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpt4o1q68b.java:40)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        final String FINAL = \"()\";\n        final String\
    \ EMPTY = \"\";\n\n        List<String> split_strings = Arrays.asList(paren_string.split(\"\
    \ \"));\n        ArrayList<Long> depths = new ArrayList<Long>();\n        ArrayList<Long>\
    \ nestings = new ArrayList<Long>();\n\n        int index = 0;\n        while (index\
    \ < split_strings.size()-1) {\n            String current_string = split_strings.get(index);\n\
    \            String next_string = split_strings.get(index+1);\n            if\
    \ (!current_string.equals(FINAL)) {\n                depths.add(Long.valueOf(EMPTY));\n\
    \                nestings.add(Long.valueOf(EMPTY));\n            }\n         \
    \   else if (next_string.equals(FINAL)) {\n                depths.add(Long.valueOf(EMPTY));\n\
    \                nestings.add(Long.valueOf(EMPTY));\n            }\n         \
    \   else {\n                long cur_depth = depths.get(depths.size()-1);\n  \
    \              long next_depth = Long.valueOf(EMPTY);\n\n                for (int\
    \ i=index+1; i<split_strings.size(); i++) {\n                    String temp_string\
    \ = split_strings.get(i);\n                    if (!temp_string.equals(FINAL))\
    \ {\n                        next_depth = Long.valueOf(EMPTY);\n             \
    \       }\n                    else if (next_string.equals(FINAL)) {\n       \
    \                 next_depth = Long.valueOf(EMPTY);\n                    }\n \
    \                   else {\n                        next_depth = Long.valueOf(depths.get(depths.size()-1)+1);\n\
    \                    }\n\n                    if (Long.valueOf(cur_depth) <= next_depth)\
    \ {\n                        break;\n                    }\n                }\n\
    \n                depths.add(next_depth);\n                nestings.add(cur_depth);\n\
    \            }\n            index++;\n        }\n\n        return new ArrayList<Long>(depths);\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NumberFormatException: For input\
    \ string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.valueOf(Long.java:1163)\n\
    \tat Problem.parseNestedParens(tmpo_9q1l0l.java:27)\n\tat Problem.main(tmpo_9q1l0l.java:64)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        int count = 0;\n        ArrayList<Long> nesting_list\
    \ = new ArrayList<Long>();\n        int last_paren = 0;\n        boolean paren_stack\
    \ = false;\n        for (int i = 0; i < paren_string.length(); ++i) {\n      \
    \      if (paren_string.charAt(i) == '(') paren_stack = true;\n            else\
    \ if (paren_stack && paren_string.charAt(i) == ')') {\n                ++count;\n\
    \                nesting_list.add(new Long(count));\n                paren_stack\
    \ = false;\n            } else if (paren_string.charAt(i) == ')') {\n        \
    \        ++count;\n            } else if (paren_string.charAt(i) == ')' && paren_string.charAt(i\
    \ - 1) != '(') {\n                nesting_list.add(new Long(count));\n       \
    \         paren_stack = false;\n                count--;\n            }\n    \
    \    }\n        if (paren_stack) nesting_list.add(new Long(count));\n        return\
    \ nesting_list;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp64gcyugn.java:37)\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       stack<String> inpar = null;\n        stack<String> inpar2 = null;\n  \
    \      for(String s:paren_string.split(\" \")) {\n            String ss[] = s.split(\"\
    \\\\(\");\n            if(inpar == null || !inpar.empty()){\n                inpar.push(s);\n\
    \            } else {\n                inpar2 = new stack<>();\n             \
    \   inpar2.push(s);\n                inpar2 = inpar;\n                while (!inpar2.empty()){\n\
    \                    String ss[] = inpar2.pop().split(\"\\\\)\");\n          \
    \          if(ss == null || ss.length < 2) {\n                        inpar2 =\
    \ null;\n                    } else {\n                        result.add(Long.parseLong(ss.toString().trim()));\n\
    \                    }\n                }\n                inpar = null;\n   \
    \         }\n        }\n        return result;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj_y8rh80.java:16: error: cannot find symbol\n        stack<String>\
    \ inpar = null;\n        ^\n  symbol:   class stack\n  location: class Problem\n\
    /tmp/tmpj_y8rh80.java:17: error: cannot find symbol\n        stack<String> inpar2\
    \ = null;\n        ^\n  symbol:   class stack\n  location: class Problem\n/tmp/tmpj_y8rh80.java:23:\
    \ error: cannot find symbol\n                inpar2 = new stack<>();\n       \
    \                      ^\n  symbol:   class stack\n  location: class Problem\n\
    /tmp/tmpj_y8rh80.java:27: error: variable ss is already defined in method parseNestedParens(String)\n\
    \                    String ss[] = inpar2.pop().split(\"\\\\)\");\n          \
    \                 ^\n4 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> list = new ArrayList<Long>(Arrays.asList((long)0l));\n\
    \n        // Step 1: Parse string: find matching paranthesis\n        long level\
    \ = 0; // current level of parenthesis\n        long parenthesis = 0; // number\
    \ of open paranthesis\n        boolean is_parenthesis_open = false; // true if\
    \ we're inside a parenthesis\n        for (char c : paren_string.toCharArray())\
    \ {\n            if (c == '(') {\n                if (parenthesis <= 0) {\n  \
    \                  is_parenthesis_open = true;\n                    level++;\n\
    \                } else {\n                    is_parenthesis_open = false;\n\
    \                }\n            } else if (c == ')' && is_parenthesis_open) {\n\
    \                parenthesis--;\n                if (parenthesis == 0) {\n   \
    \                 list.add(level);\n                    level = 0;\n         \
    \       }\n            } else if (c == ' ' && is_parenthesis_open) {\n       \
    \         // ignore space if is outside of parenthesis\n            } else {\n\
    \                parenthesis++;\n            }\n        }\n        return list;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmph9qtn128.java:44)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting = new ArrayList<>();\n    \
    \    // Use a stack to keep track of the number of open parentheses encounters.\n\
    \        Stack<Integer> stack_open_parens = new Stack<>();\n        // For each\
    \ character in the string.\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            // If the character is opening parenthesis.\n          \
    \  if (paren_string.charAt(i) == '(') {\n                // Push the number of\
    \ open parenthesis onto the stack and increment the count.\n                stack_open_parens.push(0);\n\
    \            } else {\n                // If the character is closing parenthesis.\n\
    \                if (paren_string.charAt(i) == ')') {\n                    //\
    \ Pop the number of open parenthesis from the stack and decrement it.\n      \
    \              stack_open_parens.pop();\n                } else {\n          \
    \          // If the character is NOT opening/closing parenthesis.\n         \
    \           if (!(paren_string.charAt(i) == ' ')) {\n                        //\
    \ If the number of open parenthesis is greater than zero.\n                  \
    \      if (stack_open_parens.size() > 0) {\n                            // If\
    \ the number of open parenthesis is equal to the number of closing parentheses.\n\
    \                            if (stack_open_parens.size() == paren_string.charAt(i))\
    \ {\n                                // If the number of open parenthesis is greater\
    \ than the maximum number of parentheses.\n                                if\
    \ (stack_open_parens.size() > nesting.size())\n                              \
    \      nesting.add(new Long(stack_open_parens.peek()));\n                    \
    \        } else {\n                                // Else, if the number of open\
    \ parenthesis is less than the maximum number of parentheses.\n              \
    \                  nesting.add(new Long(stack_open_parens.peek()));\n        \
    \                    }\n                        }\n                        //\
    \ If the number of open parenthesis is zero.\n                        else {\n\
    \                            nesting.add(new Long(0));\n                     \
    \   }\n                    }\n                }\n            }\n        }\n  \
    \      return nesting;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmphhxdqw5c.java:55)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // This code is from GeeksForGeeks - https://www.geeksforgeeks.org/dynamic-programming-set-10-nested-parentheses/\n\
    \        ArrayList<Long> answer = new ArrayList<Long>();\n        int m = paren_string.length();\n\
    \        boolean is_empty = paren_string.trim().equals(\"\");\n        if(is_empty)\
    \ return answer;\n\n        // Initialize max_level to -1 to mark invalid state\n\
    \        int max_level = -1;\n\n        // Initialize stack to store strings with\
    \ one level of parenthesis\n        Stack<String> stack = new Stack<>();\n   \
    \     for(int i=0; i<m; i++) {\n            // Check for valid parenthesis\n \
    \           if(paren_string.charAt(i) == '(') stack.add(\"(\" + (i+1) + \")\"\
    );\n            else if(paren_string.charAt(i) == ')') stack.add(\"(\" + (i+1)\
    \ + \")\");\n            else if(i>0) stack.add(paren_string.substring(0,i) +\
    \ \"(\" + (i+1) + \")\" + paren_string.substring(i+1,m));\n\n            // Check\
    \ and update max_level\n            int curr = i+1;\n            int prev=0;\n\
    \            while(curr<m) {\n                if(stack.peek().equals(\"(\" + (prev+1)+\
    \ \")\")) {\n                    if(stack.peek().equals(\"(\" + (prev+1)+ \")\"\
    ) && !stack.peek().equals(\"(\"+ (curr+1)+ \")\")) max_level = curr-prev;\n  \
    \                  else max_level = curr-prev;\n                }\n          \
    \      prev = curr;\n                curr++;\n            }\n\n            //\
    \ If max_level is invalid, pop out all items inside stack and append as new items\n\
    \            while(max_level>=0 && stack.size()>0) {\n                String temp\
    \ = stack.pop();\n                answer.add(Long.parseLong(temp));\n        \
    \    }\n        }\n\n        // If stack is empty append answer as new item\n\
    \        if(stack.size()>0) {\n            answer.add(Long.parseLong(stack.pop()));\n\
    \        }\n\n        return answer;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NumberFormatException: For input\
    \ string: \"(1)\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat Problem.parseNestedParens(tmpq00wnr8v.java:47)\n\tat Problem.main(tmpq00wnr8v.java:59)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result_list = new ArrayList<>();\n\
    \        ArrayList<Long> current_list = new ArrayList<>();\n        ArrayList<Long>\
    \ temp_list = new ArrayList<>();\n        ArrayList<Long> temp_max_list = new\
    \ ArrayList<>();\n        for (String one_string : paren_string.split(\" \"))\
    \ {\n            if (one_string.trim().length() == 0) {\n                result_list.add(current_list);\n\
    \                current_list = new ArrayList<>();\n            } else {\n   \
    \             temp_list.clear();\n                temp_list.add(new Long(one_string.length()));\n\
    \                for (String two_string : one_string.split(\"\\\\(\")) {\n   \
    \                 if (two_string.trim().length() == 0) {\n                   \
    \     temp_list.add(new Long(0));\n                    } else {\n            \
    \            temp_list.add(new Long(one_string.length() - two_string.length()\
    \ + one_string.indexOf(two_string) + two_string.length()));\n                \
    \    }\n                }\n                temp_list = Collections.max(temp_list);\n\
    \                result_list.add(temp_list);\n                temp_list.clear();\n\
    \                for (Long max_value : temp_list) {\n                    current_list.add(new\
    \ Long(max_value.longValue()));\n                }\n            }\n        }\n\
    \        return result_list;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiczidsvs.java:21: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n                result_list.add(current_list);\n     \
    \                           ^\n/tmp/tmpiczidsvs.java:25: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                temp_list.add(new\
    \ Long(one_string.length()));\n                              ^\n/tmp/tmpiczidsvs.java:28:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                        temp_list.add(new Long(0));\n                       \
    \               ^\n/tmp/tmpiczidsvs.java:30: warning: [removal] Long(long) in\
    \ Long has been deprecated and marked for removal\n                        temp_list.add(new\
    \ Long(one_string.length() - two_string.length() + one_string.indexOf(two_string)\
    \ + two_string.length()));\n                                      ^\n/tmp/tmpiczidsvs.java:33:\
    \ error: incompatible types: inference variable T has incompatible bounds\n  \
    \              temp_list = Collections.max(temp_list);\n                     \
    \                      ^\n    lower bounds: ArrayList<Long>,Long,Object,Comparable<?\
    \ super T>\n    lower bounds: Long\n  where T is a type-variable:\n    T extends\
    \ Object,Comparable<? super T> declared in method <T>max(Collection<? extends\
    \ T>)\n/tmp/tmpiczidsvs.java:34: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Long\n                result_list.add(temp_list);\n        \
    \                        ^\n/tmp/tmpiczidsvs.java:37: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                    current_list.add(new\
    \ Long(max_value.longValue()));\n                                     ^\nNote:\
    \ Some messages have been simplified; recompile with -Xdiags:verbose to get full\
    \ output\n3 errors\n4 warnings\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        HashSet<Long> levels = new HashSet<>();\n        List<Long>\
    \ paren_levels = new ArrayList<>();\n\n        Matcher m = Pattern.compile(\"\\\
    \\((.*?)\\\\)\").matcher(paren_string);\n        while (m.find()) {\n        \
    \    String inner = m.group(1);\n            Matcher m1 = Pattern.compile(\"\\\
    \\((.*?)\\\\)\").matcher(inner);\n            while (m1.find()) {\n          \
    \      String nested = m1.group(1);\n                Matcher m2 = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(nested);\n                while (m2.find()) {\n   \
    \                 String grand = m2.group(1);\n                    Matcher m3\
    \ = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(grand);\n                   \
    \ while (m3.find()) {\n                        String greater = m3.group(1);\n\
    \                        Matcher m4 = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(greater);\n\
    \                        while (m4.find()) {\n                            String\
    \ greater_m4 = m4.group(1);\n                            Matcher m5 = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(greater_m4);\n                            while (m5.find())\
    \ {\n                                String greater_m5 = m5.group(1);\n      \
    \                          Matcher m6 = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(greater_m5);\n\
    \                                while (m6.find()) {\n                       \
    \             String greater_m6 = m6.group(1);\n                             \
    \       Matcher m7 = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(greater_m6);\n\
    \                                    while (m7.find()) {\n                   \
    \                     String greater_m7 = m7.group(1);\n                     \
    \                   Matcher m8 = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(greater_m7);\n\
    \                                        while (m8.find()) {\n               \
    \                             String greater_m8 = m8.group(1);\n             \
    \                               Matcher m9 = Pattern.compile(\"\\\\((.*?)\\\\\
    )\").matcher(greater_m8);\n                                            while (m9.find())\
    \ {\n                                                String greater_m9 = m9.group(1);\n\
    \                                                Matcher m10 = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(greater_m9);\n                                    \
    \            while (m10.find()) {\n                                          \
    \          String greater_m10 = m10.group(1);\n                              \
    \                      Matcher m11 = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(greater_m10);\n\
    \                                                    while (m11.find()) {\n  \
    \                                                      String greater_m11 = m11.group(1);\n\
    \                                                        Matcher m12 = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(greater_m11);\n                                   \
    \                     while (m12.find()) {\n                                 \
    \                           String great\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpotxqgk41.java:56: error: ';' expected\n                       \
    \                                     String great\n                         \
    \                                               ^\n/tmp/tmpotxqgk41.java:58: error:\
    \ illegal start of expression\n    public static void main(String[] args) {\n\
    \    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011445
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> groups = paren_string.trim().split(\"\\\
    \\s\");\n        ArrayList<Long> levels = new ArrayList<>();\n        List<String>\
    \ stack = new ArrayList<>();\n        stack.push(\"(\");\n        for (int i =\
    \ 0; i < groups.size(); i++) {\n            String group = groups.get(i);\n  \
    \          if (group.equals(\"(\")) {\n                stack.push(\"(\");\n  \
    \          } else if (group.equals(\")\")) {\n                String last_level\
    \ = stack.pop();\n                String current_level = stack.pop();\n      \
    \          if (last_level.equals(\"(\") && current_level.equals(\"(\")) {\n  \
    \                  levels.add((long) levels.size());\n                }\n    \
    \            stack.push(group);\n            } else {\n                stack.push(group);\n\
    \            }\n        }\n        levels.add((long) levels.size());\n       \
    \ return levels;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpekzpvdww.java:15: error: incompatible types: String[] cannot be\
    \ converted to List<String>\n        List<String> groups = paren_string.trim().split(\"\
    \\\\s\");\n                                                       ^\n/tmp/tmpekzpvdww.java:18:\
    \ error: cannot find symbol\n        stack.push(\"(\");\n             ^\n  symbol:\
    \   method push(String)\n  location: variable stack of type List<String>\n/tmp/tmpekzpvdww.java:22:\
    \ error: cannot find symbol\n                stack.push(\"(\");\n            \
    \         ^\n  symbol:   method push(String)\n  location: variable stack of type\
    \ List<String>\n/tmp/tmpekzpvdww.java:24: error: cannot find symbol\n        \
    \        String last_level = stack.pop();\n                                  \
    \       ^\n  symbol:   method pop()\n  location: variable stack of type List<String>\n\
    /tmp/tmpekzpvdww.java:25: error: cannot find symbol\n                String current_level\
    \ = stack.pop();\n                                            ^\n  symbol:   method\
    \ pop()\n  location: variable stack of type List<String>\n/tmp/tmpekzpvdww.java:29:\
    \ error: cannot find symbol\n                stack.push(group);\n            \
    \         ^\n  symbol:   method push(String)\n  location: variable stack of type\
    \ List<String>\n/tmp/tmpekzpvdww.java:31: error: cannot find symbol\n        \
    \        stack.push(group);\n                     ^\n  symbol:   method push(String)\n\
    \  location: variable stack of type List<String>\n7 errors\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        String[] split = paren_string.split(\" \");\n     \
    \   ArrayList max_list = new ArrayList();\n        for (int i = 0; i < split.length;\
    \ i++) {\n            String group = split[i];\n            if (group.contains(\"\
    (\")) {\n                Long max_level = parseNestingLevel(group);\n        \
    \        max_list.add(max_level);\n            }\n        }\n        return (ArrayList<Long>)\
    \ max_list;\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0s1dmh82.java:20: error: cannot find symbol\n                Long\
    \ max_level = parseNestingLevel(group);\n                                 ^\n\
    \  symbol:   method parseNestingLevel(String)\n  location: class Problem\nNote:\
    \ /tmp/tmp0s1dmh82.java uses unchecked or unsafe operations.\nNote: Recompile\
    \ with -Xlint:unchecked for details.\n1 error\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_parens = new ArrayList<>();\n\
    \        ArrayDeque<Integer> stack = new ArrayDeque<>();\n        for (int i =\
    \ 0; i < paren_string.length(); i++) {\n            char cur_char = paren_string.charAt(i);\n\
    \            if (cur_char == '(') {\n                stack.push(1);\n        \
    \    } else if (cur_char == ')') {\n                if (stack.isEmpty()) {\n \
    \                   return nested_parens;\n                } else {\n        \
    \            int num_open_parens = stack.pop();\n                    if (num_open_parens\
    \ == 0) {\n                        nested_parens.add(Long.valueOf(stack.peek()));\n\
    \                    }\n                }\n            }\n        }\n        throw\
    \ new IllegalArgumentException(\"No matching closing paren found.\");\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.IllegalArgumentException: No matching\
    \ closing paren found.\n\tat Problem.parseNestedParens(tmpfgcgkc_z.java:32)\n\t\
    at Problem.main(tmpfgcgkc_z.java:35)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string == null || paren_string.isEmpty())\
    \ return new ArrayList<Long>();\n\n        // Split string on spaces to get string\
    \ groups. \n        // \"(()()) has maximum two levels of nesting while ((()))\
    \ has three.\"\n        String[] strs = paren_string.split(\" +\");\n\n      \
    \  // Initialize to empty lists\n        ArrayList<Long> max_groups = new ArrayList<Long>();\n\
    \        ArrayList<Long> max_group_levels = new ArrayList<Long>();\n\n       \
    \ // For each of the strs, split on \")\" to get string groups. \n        // E.g.\
    \ \"(()()) ((())) () ((())()())\"\n        for (String str : strs) {\n       \
    \     String[] strs2 = str.split(\"\\\\)\");\n\n            // For each of the\
    \ strs2, split on \")\" to get string levels. \n            // E.g. \"(()()) has\
    \ maximum two levels of nesting while ((())) has three.\"\n            for (String\
    \ str2 : strs2) {\n                String[] strs3 = str2.split(\"\\\\)\");\n\n\
    \                // For each of the strs3, split on \")\" to get string levels.\
    \ \n                // E.g. \"(()()) has maximum two levels of nesting while ((()))\
    \ has three.\"\n                for (String str3 : strs3) {\n                \
    \    String[] strs4 = str3.split(\"\\\\)\");\n                    for (String\
    \ str4 : strs4) {\n                        String[] strs5 = str4.split(\"\\\\\
    )\");\n                        for (String str5 : strs5) {\n                 \
    \           String[] strs6 = str5.split(\"\\\\)\");\n                        \
    \    for (String str6 : strs6) {\n                                String[] strs7\
    \ = str6.split(\"\\\\)\");\n                                for (String str7 :\
    \ strs7) {\n                                    String[] strs8 = str7.split(\"\
    \\\\)\");\n                                    for (String str8 : strs8) {\n \
    \                                       String[] strs9 = str8.split(\"\\\\)\"\
    );\n                                        for (String str9 : strs9) {\n    \
    \                                        ArrayList<Long> levels = parseNestedParens(str9);\n\
    \                                            if (levels.size() > max_group_levels.size())\
    \ max_group_levels = levels;\n                                        }\n    \
    \                                }\n                                }\n      \
    \                      }\n                        }\n                    }\n \
    \               }\n            }\n        }\n\n        // Add each of the max\
    \ group levels to max_groups\n        for (Long level : max_group_levels) {\n\
    \            max_groups.add(level);\n        }\n\n        // Return the max groups\
    \ as a list\n        return max_groups;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.regex.PatternSyntaxException: Stack\
    \ overflow during pattern compilation near index 0\n +\n^\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1432)\n\tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\
    \tat java.base/java.lang.String.split(String.java:3153)\n\tat java.base/java.lang.String.split(String.java:3199)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:19)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\
    \tat Problem.parseNestedParens(tmpc02dpfwz.java:50)\n\tat Problem.parseNestedParens(tmpc02dp"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        int max_level = 0;\n        HashSet<Long> visited =\
    \ new HashSet<Long>();\n        Stack<String> stack = new Stack<>();\n       \
    \ ArrayList<Long> result_list = new ArrayList<>();\n        // Put the string\
    \ into a set of groups that can contain parenthesis.\n        String[] nested_paren_groups\
    \ = paren_string.split(\" \");\n        for (String nested_paren_group : nested_paren_groups)\
    \ {\n            if (nested_paren_group.equals(\"(\")) {\n                stack.push(nested_paren_group);\n\
    \            } else {\n                // if the string is not empty, pop all\
    \ the items from the stack.\n                // and add the popped element to\
    \ the result_list\n                if (stack.size() > 0) {\n                 \
    \   String popped_element = stack.pop();\n                    result_list.add(Long.valueOf(popped_element));\n\
    \                }\n            }\n        }\n        // if the stack is not empty,\
    \ add it to the result_list.\n        if (stack.size() > 0) {\n            result_list.add(Long.valueOf(stack.pop()));\n\
    \        }\n        // keep track of the max level of nested parenthesis\n   \
    \     for (Long result : result_list) {\n            if (visited.contains(result))\
    \ {\n                System.out.println(\"The result is duplicate.\");\n     \
    \           return null;\n            }\n            visited.add(result);\n  \
    \          if (max_level < result.intValue()) {\n                max_level = result.intValue();\n\
    \            }\n        }\n        // the max level is now the deepest level of\
    \ nesting in the parenthesis string.\n        return result_list;\n    }\n   \
    \ public static void main(String[] args) {\n    assert(parseNestedParens((\"(()())\
    \ ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpchmfxmod.java:52)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string == null || paren_string.isEmpty())\
    \ {\n            return null;\n        }\n\n        List<String> input_list =\
    \ Arrays.asList(paren_string.split(\" \"));\n        ArrayList<Long> output_list\
    \ = new ArrayList<>();\n        for (int i = 0; i < input_list.size(); i++) {\n\
    \            String current_input = input_list.get(i);\n            if (current_input.isEmpty())\
    \ {\n                continue;\n            }\n            long temp_output =\
    \ 0;\n            for (int j = i + 1; j < input_list.size(); j++) {\n        \
    \        String next_input = input_list.get(j);\n                if (next_input.isEmpty())\
    \ {\n                    continue;\n                }\n                String\
    \ next_input_2 = input_list.get(j + 1);\n                String temp_input = input_list.get(j);\n\
    \                int index_of_opening_parenthese = temp_input.indexOf('(');\n\
    \                int index_of_closing_parenthese = temp_input.lastIndexOf(')');\n\
    \                int index_of_opening_parenthesis = next_input_2.indexOf('(');\n\
    \                int index_of_closing_parenthesis = next_input_2.lastIndexOf(')');\n\
    \                if (index_of_closing_parenthesis == -1 && index_of_closing_parenthesis\
    \ != index_of_opening_parenthesis) {\n                    continue;\n        \
    \        }\n                if (index_of_closing_parenthesis == index_of_opening_parenthesis)\
    \ {\n                    if (next_input.contains(\" \")) {\n                 \
    \       continue;\n                    }\n                    if (next_input.contains(\"\
    (\")) {\n                        continue;\n                    }\n          \
    \      }\n                if (index_of_closing_parenthesis > index_of_opening_parenthesis)\
    \ {\n                    temp_output += index_of_closing_parenthesis - index_of_opening_parenthesis;\n\
    \                }\n                temp_output += next_input.indexOf(\"(\") -\
    \ next_input.indexOf(\")\");\n                temp_output += next_input_2.indexOf(\"\
    (\") - next_input_2.indexOf(\")\");\n            }\n            output_list.add(temp_output);\n\
    \        }\n\n        return output_list;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException:\
    \ Index 4 out of bounds for length 4\n\tat java.base/java.util.Arrays$ArrayList.get(Arrays.java:4165)\n\
    \tat Problem.parseNestedParens(tmpjqh0445v.java:32)\n\tat Problem.main(tmpjqh0445v.java:61)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   StringTokenizer tokenizer = new StringTokenizer(paren_string, \" ()\");\n\
    \        StringBuilder current_level = new StringBuilder();\n        tokenizer.nextToken();\n\
    \        while (tokenizer.hasMoreTokens()) {\n            current_level.append(tokenizer.nextToken());\n\
    \            if (current_level.length() > 0 && !current_level.equals(\"(\")) {\n\
    \                if (current_level.equals(\")\")) {\n                    levels.add(new\
    \ Long(levels.size() - 1));\n                } else {\n                    levels.add(new\
    \ Long(levels.size()));\n                }\n                levels.add(new Long(levels.size()));\n\
    \                levels.add(new Long(levels.size()));\n                levels.add(new\
    \ Long(levels.size()));\n                current_level = new StringBuilder();\n\
    \            }\n        }\n        if (levels.size() > 0) {\n            levels.add(new\
    \ Long(levels.size() - 1));\n        }\n        return levels;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.NoSuchElementException\n\tat java.base/java.util.StringTokenizer.nextToken(StringTokenizer.java:347)\n\
    \tat Problem.parseNestedParens(tmp45_khqp5.java:18)\n\tat Problem.main(tmp45_khqp5.java:39)\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_nestings = new ArrayList<Long>();\n\
    \        ArrayList<Long> max_nestings = new ArrayList<Long>();\n        char[]\
    \ paren_chars = paren_string.toCharArray();\n        long max_level = 0;\n   \
    \     boolean has_parentheses = true;\n        long depth = 0;\n        // We\
    \ will use parentheses as the indicator to see if we can parse as many nested\
    \ parentheses\n        // as possible.\n        // If we can't parse any parentheses,\
    \ we will only parse the parentheses we saw.\n        // If we can parse as many\
    \ parentheses as possible, we will parse the parentheses we saw\n        // until\
    \ we run out of parentheses.\n        for (int i = 0; i < paren_chars.length;\
    \ i++) {\n            char c = paren_chars[i];\n            // If we can't parse\
    \ any parentheses, we will only parse the parentheses we saw.\n            if\
    \ (c == '(') {\n                has_parentheses = true;\n            }\n     \
    \       // If we found a closing parentheses, we will parse all parentheses we\
    \ saw that were\n            // inside parentheses until we run out of parentheses.\n\
    \            if (c == ')') {\n                // If we have reached a parentheses\
    \ that was never parsed, we need to parse the closing\n                // parentheses.\n\
    \                if (has_parentheses) {\n                    has_parentheses =\
    \ false;\n                    for (int j = i; j + 1 < paren_chars.length; j++)\
    \ {\n                        char c_j = paren_chars[j];\n                    \
    \    if (c_j == '(') {\n                            has_parentheses = true;\n\
    \                            break;\n                        }\n             \
    \       }\n                }\n            }\n            // If we found the end\
    \ of the parentheses string without seeing any opening\n            // parentheses,\
    \ we can parse all parentheses we saw that were inside parentheses.\n        \
    \    if (!has_parentheses) {\n                for (int j = i; j < paren_chars.length;\
    \ j++) {\n                    char c_j = paren_chars[j];\n                   \
    \ if (c_j == '(') {\n                        has_parentheses = true;\n       \
    \                 break;\n                    }\n                }\n         \
    \   }\n            // If we found a parentheses that was never parsed, we need\
    \ to parse the parentheses we saw.\n            if (!has_parentheses) {\n    \
    \            for (int j = i; j + 1 < paren_chars.length; j++) {\n            \
    \        char c_j = paren_chars[j];\n                    if (c_j == '(') {\n \
    \                       has_parentheses = true;\n                        break;\n\
    \                    }\n                }\n            }\n            // If we\
    \ found a closing parentheses, we need to find the depth of the parentheses we\
    \ saw.\n            if (c == ')') {\n                depth--;\n            }\n\
    \            // If we found an opening parentheses, we need to find the depth\
    \ of the parentheses we saw.\n            if (c == '(') {\n                depth++;\n\
    \            }\n            // If we found two consecutive closing parentheses,\
    \ we need to find the deepest nesting of\n            // parentheses we \n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjg5_uym7.java:80: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n1 error\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_level = new ArrayList<Long>();\n\
    \        ArrayList<Long> level = new ArrayList<Long>();\n        ArrayList<Long>\
    \ parens = new ArrayList<Long>();\n        StringBuilder temp = new StringBuilder();\n\
    \        Long deepest_count = -1;\n        for (int i = 0; i < paren_string.length();\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            if (ch ==\
    \ '(' || ch == '[') {\n                level.clear();\n                parens.add(new\
    \ Long(i));\n                temp.append(ch);\n                deepest_level.add(new\
    \ Long(0));\n                deepest_count = -1;\n            } else if (ch ==\
    \ ')' || ch == ']') {\n                if (level.size() > deepest_level.get(deepest_level.size()\
    \ - 1)) {\n                    deepest_level.set(deepest_level.size() - 1, new\
    \ Long(level.size()));\n                    deepest_count++;\n               \
    \ }\n                level.add(new Long(level.size()));\n                temp.append(ch);\n\
    \                parens.add(new Long(parens.size() - 1));\n            } else\
    \ if (ch == ' ' || ch == '\\t') {\n                level.add(new Long(0));\n \
    \           } else {\n                temp.append(ch);\n            }\n      \
    \  }\n        if (parens.size() > 0) {\n            level.add(new Long(0));\n\
    \            deepest_level.add(new Long(0));\n        }\n        ArrayList<Long>\
    \ res = new ArrayList<Long>();\n        for (int i = 0; i < level.size(); i++)\
    \ {\n            if (deepest_level.get(i) != -1) {\n                res.add(deepest_level.get(i)\
    \ - level.get(i));\n            } else {\n                res.add(level.get(i));\n\
    \            }\n        }\n        return res;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8n600nr8.java:19: error: incompatible types: int cannot be converted\
    \ to Long\n        Long deepest_count = -1;\n                             ^\n\
    /tmp/tmp8n600nr8.java:24: warning: [removal] Long(long) in Long has been deprecated\
    \ and marked for removal\n                parens.add(new Long(i));\n         \
    \                  ^\n/tmp/tmp8n600nr8.java:26: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                deepest_level.add(new\
    \ Long(0));\n                                  ^\n/tmp/tmp8n600nr8.java:27: error:\
    \ incompatible types: int cannot be converted to Long\n                deepest_count\
    \ = -1;\n                                ^\n/tmp/tmp8n600nr8.java:30: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \                  deepest_level.set(deepest_level.size() - 1, new Long(level.size()));\n\
    \                                                                ^\n/tmp/tmp8n600nr8.java:33:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                level.add(new Long(level.size()));\n                        \
    \  ^\n/tmp/tmp8n600nr8.java:35: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                parens.add(new Long(parens.size()\
    \ - 1));\n                           ^\n/tmp/tmp8n600nr8.java:37: warning: [removal]\
    \ Long(long) in Long has been deprecated and marked for removal\n            \
    \    level.add(new Long(0));\n                          ^\n/tmp/tmp8n600nr8.java:43:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \            level.add(new Long(0));\n                      ^\n/tmp/tmp8n600nr8.java:44:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \            deepest_level.add(new Long(0));\n                              ^\n\
    2 errors\n8 warnings\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> stack = new ArrayList<>();\n      \
    \  ArrayList<Long> parans = new ArrayList<>();\n        char[] input_chars = paren_string.toCharArray();\n\
    \        int input_length = input_chars.length;\n        int open_paren = 0;\n\
    \        int close_paren = 0;\n        boolean end_paren = false;\n\n        //\
    \ Find first '('\n        while(open_paren < input_length) {\n            if(input_chars[open_paren]\
    \ == '(') {\n                stack.push(open_paren);\n                open_paren++;\n\
    \            } else if(input_chars[open_paren] == '(') {\n                parans.add(stack.pop());\n\
    \                open_paren++;\n            } else {\n                open_paren++;\n\
    \            }\n        }\n\n        // For remaining '('\n        while(close_paren\
    \ < input_length) {\n            if(input_chars[close_paren] == ')') {\n     \
    \           end_paren = true;\n                close_paren++;\n              \
    \  while(close_paren < input_length) {\n                    if(input_chars[close_paren]\
    \ == ')') {\n                        end_paren = false;\n                    \
    \    close_paren++;\n                    } else {\n                        close_paren++;\n\
    \                    }\n                }\n                if(end_paren) {\n \
    \                   break;\n                }\n            } else {\n        \
    \        if(open_paren >= stack.size()) {\n                    stack.push(new\
    \ Long(1));\n                    open_paren++;\n                } else {\n   \
    \                 Long curr_pos = stack.get(stack.size() - 1);\n             \
    \       Long new_pos = new Long(curr_pos.getValue() + 1);\n                  \
    \  parans.add(new_pos);\n                    stack.push(new_pos);\n          \
    \          open_paren++;\n                }\n            }\n        }\n\n    \
    \    while(stack.size() > 0) {\n            Long curr_pos = stack.get(stack.size()\
    \ - 1);\n            Long new_pos = new Long(curr_pos.getValue() + 1);\n     \
    \       parans.add(new_pos);\n            stack.push(new_pos);\n        }\n\n\
    \        return parans;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj27xcn0t.java:26: error: cannot find symbol\n                stack.push(open_paren);\n\
    \                     ^\n  symbol:   method push(int)\n  location: variable stack\
    \ of type ArrayList<Long>\n/tmp/tmpj27xcn0t.java:29: error: cannot find symbol\n\
    \                parans.add(stack.pop());\n                                ^\n\
    \  symbol:   method pop()\n  location: variable stack of type ArrayList<Long>\n\
    /tmp/tmpj27xcn0t.java:54: warning: [removal] Long(long) in Long has been deprecated\
    \ and marked for removal\n                    stack.push(new Long(1));\n     \
    \                          ^\n/tmp/tmpj27xcn0t.java:54: error: cannot find symbol\n\
    \                    stack.push(new Long(1));\n                         ^\n  symbol:\
    \   method push(Long)\n  location: variable stack of type ArrayList<Long>\n/tmp/tmpj27xcn0t.java:58:\
    \ error: cannot find symbol\n                    Long new_pos = new Long(curr_pos.getValue()\
    \ + 1);\n                                                    ^\n  symbol:   method\
    \ getValue()\n  location: variable curr_pos of type Long\n/tmp/tmpj27xcn0t.java:60:\
    \ error: cannot find symbol\n                    stack.push(new_pos);\n      \
    \                   ^\n  symbol:   method push(Long)\n  location: variable stack\
    \ of type ArrayList<Long>\n/tmp/tmpj27xcn0t.java:68: error: cannot find symbol\n\
    \            Long new_pos = new Long(curr_pos.getValue() + 1);\n             \
    \                               ^\n  symbol:   method getValue()\n  location:\
    \ variable curr_pos of type Long\n/tmp/tmpj27xcn0t.java:70: error: cannot find\
    \ symbol\n            stack.push(new_pos);\n                 ^\n  symbol:   method\
    \ push(Long)\n  location: variable stack of type ArrayList<Long>\n7 errors\n1\
    \ warning\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        return parseNestedParens(paren_string, new ArrayList<Long>(),\
    \ new ArrayList<Long>());\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpei41v83h.java:15: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        return parseNestedParens(paren_string,\
    \ new ArrayList<Long>(), new ArrayList<Long>());\n               ^\n  required:\
    \ String\n  found:    String,ArrayList<Long>,ArrayList<Long>\n  reason: actual\
    \ and formal argument lists differ in length\n1 error\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Return an empty list if the input string is null\n\
    \        if (paren_string == null || paren_string.isEmpty()) {\n            return\
    \ new ArrayList<Long>();\n        }\n        // Initialize stack variables for\
    \ parsing the string\n        ArrayDeque<String> stack = new ArrayDeque<String>();\n\
    \        ArrayDeque<String> out = new ArrayDeque<String>();\n        // Initialize\
    \ count variables for parsing the string\n        Integer paren_counter = 0;\n\
    \        Integer paren_counter_2 = 1;\n        // Iterate through the string until\
    \ we find the end paren\n        for (int i = 0; i < paren_string.length(); ++i)\
    \ {\n            // Push all the symbols into the stack variable\n           \
    \ stack.push(paren_string.substring(i, i + 1));\n        }\n        // Iterate\
    \ through the string and parse the symbols\n        while (true) {\n         \
    \   // Pop one element from stack\n            String elem = stack.pop();\n  \
    \          // If the stack variable is empty, stop parsing and return the list\n\
    \            if (elem.isEmpty()) {\n                break;\n            }\n  \
    \          // Increment the count for parsing the string\n            if (elem.equals(\"\
    (\")) {\n                paren_counter++;\n            }\n            if (elem.equals(\"\
    (\")) {\n                paren_counter_2++;\n            }\n            // If\
    \ the counter is odd number of parenthesis, append the element to the output variable\n\
    \            if (paren_counter % 2 == 1) {\n                out.add(elem);\n \
    \           }\n            // If the counter of the second group is even number,\
    \ append the element to the output variable\n            if (paren_counter_2 %\
    \ 2 == 0) {\n                out.add(elem);\n            }\n        }\n      \
    \  // Return the output variable\n        return new ArrayList<Long>(out);\n \
    \   }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiwgfar4b.java:55: error: no suitable constructor found for ArrayList(ArrayDeque<String>)\n\
    \        return new ArrayList<Long>(out);\n               ^\n    constructor ArrayList.ArrayList(int)\
    \ is not applicable\n      (argument mismatch; ArrayDeque<String> cannot be converted\
    \ to int)\n    constructor ArrayList.ArrayList(Collection<? extends Long>) is\
    \ not applicable\n      (argument mismatch; ArrayDeque<String> cannot be converted\
    \ to Collection<? extends Long>)\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> results = new ArrayList<Long>();\n\n\
    \        // Create stack to store each level of nesting level\n        Stack<Long>\
    \ levelStack = new Stack<Long>();\n\n        // This variable will store each\
    \ level of nesting level, pushed onto each levelStack\n        long currentLevel\
    \ = 0;\n\n        // Iterate through each character in the string\n        for\
    \ (char c : paren_string.toCharArray()) {\n            // If char is not a parenthese,\
    \ move on\n            if (c != '(') {\n                continue;\n          \
    \  }\n\n            // If levelStack is empty, means we are at level 0\n     \
    \       // We will push current level of nesting onto levelStack\n           \
    \ // When we pop it, we know we need to add 1 to the current level stored in levelStack\n\
    \            // Since stack is LIFO, popped item will be at the top\n        \
    \    if (levelStack.isEmpty()) {\n                levelStack.push(currentLevel);\n\
    \            }\n\n            // Pop item from the stack and add 1 to level\n\
    \            currentLevel = levelStack.pop() + 1;\n            // Push level onto\
    \ levelStack\n            levelStack.push(currentLevel);\n\n            // Keep\
    \ on going through until we meet ')'\n            while (c == ')') {\n       \
    \         // If current level is not the same as levelStack top, means we are\
    \ at a new level\n                // So we will push it onto levelStack and update\
    \ currentLevel\n                if (currentLevel != levelStack.peek()) {\n   \
    \                 levelStack.push(currentLevel);\n                    currentLevel\
    \ = levelStack.peek();\n                }\n\n                // If we meet ')'\
    \ at current level, means we need to add one to currentLevel\n               \
    \ // We do that by popping items and add 1 to current level\n                currentLevel--;\n\
    \                levelStack.pop();\n            }\n\n            // Push level\
    \ onto levelStack\n            levelStack.push(currentLevel);\n        }\n\n \
    \       // If we still have levelStack items, means we have not meet closing bracket\
    \ for all levels\n        // So the result should be last level stored in levelStack\n\
    \        // So we pop it from levelStack and add it to results list\n        results.add(levelStack.pop());\n\
    \        return results;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpgcdmfyo8.java:69)\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<Long>();\n \
    \       boolean start_paren = true;\n        for (int i=0; i<paren_string.length();\
    \ i++) {\n            char ch = paren_string.charAt(i);\n            if (ch ==\
    \ '(') {\n                if (start_paren) {\n                    levels.add(1l);\n\
    \                } else {\n                    start_paren = true;\n         \
    \           levels.add(0l);\n                }\n            } else if (ch == ')')\
    \ {\n                start_paren = false;\n                levels.add(levels.get(levels.size()-1)+1);\n\
    \            } else {\n                start_paren = false;\n                levels.add(0l);\n\
    \            }\n        }\n        return levels;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5w85khr1.java:37)\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<String> parens = Arrays.asList(paren_string.split(\"\
    \\\\ \"));\n        ArrayList<Long> max_level = new ArrayList<>();\n        ArrayList<Long>\
    \ level = new ArrayList<>();\n        ArrayList<Long> max_depth = new ArrayList<>();\n\
    \        ArrayList<Long> depth = new ArrayList<>();\n        for (String p: parens)\
    \ {\n            if (isOuterParens(p)) {\n                level.add(p.length());\n\
    \            } else if (isInnerParens(p)) {\n                depth.add(p.length());\n\
    \            }\n            if (depth.isEmpty()) {\n                return null;\n\
    \            }\n        }\n        depth.add(level.get(0).longValue());\n    \
    \    Long sum = 0;\n        for (long d: depth) {\n            sum += d;\n   \
    \     }\n        depth.set(0, sum);\n        for (int i = 0; i < level.size();\
    \ i++) {\n            long l = level.get(i);\n            while (l != 1) {\n \
    \               l /= 10;\n            }\n            while (depth.get(i) < l)\
    \ {\n                depth.set(i, depth.get(i) + 1);\n            }\n        \
    \    if (depth.get(i) > max_depth.get(i)) {\n                max_depth.set(i,\
    \ depth.get(i));\n            }\n        }\n        ArrayList<Long> out = new\
    \ ArrayList<>();\n        for (int i = 0; i < max_depth.size(); i++) {\n     \
    \       out.add(max_depth.get(i));\n        }\n        ArrayList<Long> temp =\
    \ new ArrayList<>();\n        for (long d: max_depth) {\n            while (d\
    \ > 1) {\n                temp.add(d);\n                d /= 10;\n           \
    \ }\n            while (temp.get(i) < d) {\n                temp.set(i, temp.get(i)\
    \ + 1);\n            }\n            if (temp.get(i) > max_level.get(i)) {\n  \
    \              max_level.set(i, temp.get(i));\n            }\n        }\n    \
    \    out.addAll(0, max_level);\n        ArrayList<Long> res = new ArrayList<>();\n\
    \        for (Long l: out) {\n            if (l != 0) {\n                res.add(l);\n\
    \            }\n        }\n        return res;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbfgyfcu8.java:21: error: cannot find symbol\n            if (isOuterParens(p))\
    \ {\n                ^\n  symbol:   method isOuterParens(String)\n  location:\
    \ class Problem\n/tmp/tmpbfgyfcu8.java:22: error: incompatible types: int cannot\
    \ be converted to Long\n                level.add(p.length());\n             \
    \                     ^\n/tmp/tmpbfgyfcu8.java:23: error: cannot find symbol\n\
    \            } else if (isInnerParens(p)) {\n                       ^\n  symbol:\
    \   method isInnerParens(String)\n  location: class Problem\n/tmp/tmpbfgyfcu8.java:24:\
    \ error: incompatible types: int cannot be converted to Long\n               \
    \ depth.add(p.length());\n                                  ^\n/tmp/tmpbfgyfcu8.java:31:\
    \ error: incompatible types: int cannot be converted to Long\n        Long sum\
    \ = 0;\n                   ^\n/tmp/tmpbfgyfcu8.java:58: error: cannot find symbol\n\
    \            while (temp.get(i) < d) {\n                            ^\n  symbol:\
    \   variable i\n  location: class Problem\n/tmp/tmpbfgyfcu8.java:59: error: cannot\
    \ find symbol\n                temp.set(i, temp.get(i) + 1);\n               \
    \          ^\n  symbol:   variable i\n  location: class Problem\n/tmp/tmpbfgyfcu8.java:59:\
    \ error: cannot find symbol\n                temp.set(i, temp.get(i) + 1);\n \
    \                                    ^\n  symbol:   variable i\n  location: class\
    \ Problem\n/tmp/tmpbfgyfcu8.java:61: error: cannot find symbol\n            if\
    \ (temp.get(i) > max_level.get(i)) {\n                         ^\n  symbol:  \
    \ variable i\n  location: class Problem\n/tmp/tmpbfgyfcu8.java:61: error: cannot\
    \ find symbol\n            if (temp.get(i) > max_level.get(i)) {\n           \
    \                                 ^\n  symbol:   variable i\n  location: class\
    \ Problem\n/tmp/tmpbfgyfcu8.java:62: error: cannot find symbol\n             \
    \   max_level.set(i, temp.get(i));\n                              ^\n  symbol:\
    \   variable i\n  location: class Problem\n/tmp/tmpbfgyfcu8.java:62: error: cannot\
    \ find symbol\n                max_level.set(i, temp.get(i));\n              \
    \                            ^\n  symbol:   v"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> output_list = new ArrayList<Long>(Arrays.asList((long)1l));\n\
    \        ArrayList<Long> paren_list = new ArrayList<Long>(Arrays.asList((long)1l));\n\
    \        ArrayList<Long> left_paren_list = new ArrayList<Long>(Arrays.asList((long)1l));\n\
    \        ArrayList<Long> right_paren_list = new ArrayList<Long>(Arrays.asList((long)1l));\n\
    \        int left_paren_pos = -1;\n        int right_paren_pos = -1;\n       \
    \ int paren_level = -1;\n        int left_paren_count = 0;\n        for (int i\
    \ = 0; i < paren_string.length(); i++) {\n            char ch = paren_string.charAt(i);\n\
    \            if (ch == '(') {\n                left_paren_list.add(left_paren_pos);\n\
    \                left_paren_pos++;\n                left_paren_count++;\n    \
    \        } else if (ch == ')') {\n                right_paren_list.add(right_paren_pos);\n\
    \                right_paren_pos++;\n                left_paren_count--;\n   \
    \         }\n            if (left_paren_pos == -1 && right_paren_pos == -1 &&\
    \ paren_level == -1) {\n                paren_list.clear();\n                paren_list.add(left_paren_count);\n\
    \                paren_list.trimToSize();\n                if (paren_list.size()\
    \ != 0) {\n                    paren_list.trimToSize();\n                }\n \
    \               for (int j = 0; j < paren_list.size() && paren_list.get(j) > 0;\
    \ j++) {\n                    output_list.add(Long.valueOf(paren_list.get(j)));\n\
    \                }\n                left_paren_list = new ArrayList<Long>();\n\
    \                right_paren_list = new ArrayList<Long>();\n                paren_level\
    \ = 0;\n            } else {\n                if (left_paren_pos != -1) {\n  \
    \                  int left_paren_pos = left_paren_list.get(left_paren_pos);\n\
    \                    int left_paren_count = left_paren_list.get(left_paren_pos\
    \ + 1);\n                    if (left_paren_pos == right_paren_pos) {\n      \
    \                  if (paren_level > 0) {\n                            paren_list.remove(left_paren_pos);\n\
    \                            paren_list.trimToSize();\n                      \
    \      for (int j = 0; j < paren_list.size() && paren_list.get(j) > 0; j++) {\n\
    \                                output_list.add(Long.valueOf(paren_list.get(j)));\n\
    \                            }\n                            left_paren_list.remove(left_paren_pos);\n\
    \                            left_paren_list.trimToSize();\n                 \
    \       }\n                        paren_list.add(left_paren_count);\n       \
    \                 paren_list.trimToSize();\n                        for (int j\
    \ = 0; j < paren_list.size() && paren_list.get(j) > 0; j++) {\n              \
    \              output_list.add(Long.valueOf(paren_list.get(j)));\n           \
    \             }\n                        left_paren_list = new ArrayList<Long>();\n\
    \                        right_paren_list = new ArrayList<Long>();\n         \
    \               paren_level = -1;\n                    } else {\n            \
    \            if (left_\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpurcyk15v.java:70: error: ')' expected\n                       \
    \ if (left_\n                                 ^\n/tmp/tmpurcyk15v.java:71: error:\
    \ illegal start of statement\n    }\n    ^\n/tmp/tmpurcyk15v.java:72: error: illegal\
    \ start of expression\n    public static void main(String[] args) {\n    ^\n3\
    \ errors\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> result = new ArrayList<Long>();\n \
    \       ArrayList<String> input_strings = Arrays.asList(paren_string.split(\"\
    \ \"));\n\n        // for each of the group\n        for (String input_string\
    \ : input_strings) {\n            // add the first level of nesting\n        \
    \    if (input_string.startsWith(\"(\")) {\n                result.add(1L);\n\
    \            }\n            // add a level of nesting if there are more parentheses\
    \ in the input string\n            else if (input_string.contains(\"(\")) {\n\
    \                result.add(2L);\n            }\n            // otherwise do nothing\n\
    \            else {\n                result.add(0L);\n            }\n        }\n\
    \n        return result;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpki8koa9t.java:16: error: incompatible types: no instance(s) of\
    \ type variable(s) T exist so that List<T> conforms to ArrayList<String>\n   \
    \     ArrayList<String> input_strings = Arrays.asList(paren_string.split(\" \"\
    ));\n                                                       ^\n  where T is a\
    \ type-variable:\n    T extends Object declared in method <T>asList(T...)\n1 error\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_parens = new ArrayList<Long>();\n\
    \        ArrayList<String> nested_strings = new ArrayList<String>();\n       \
    \ ArrayList<String> last_nested_strings = new ArrayList<String>();\n        ArrayList<Long>\
    \ last_nested_parens = new ArrayList<Long>();\n        ArrayList<Long> deepest_nested_parens\
    \ = new ArrayList<Long>();\n        ArrayList<Long> deepest_nested_parens_index\
    \ = new ArrayList<Long>();\n        ArrayList<Long> last_nested_level = deepest_nested_parens;\n\
    \        for(int i = 0; i < paren_string.length(); i++) {\n            String\
    \ ch = paren_string.substring(i, i+1);\n            if(ch == \"(\") {\n      \
    \          nested_parens.add(Long.valueOf(1));\n                nested_strings.add(ch);\n\
    \                last_nested_strings.add(ch);\n                last_nested_level.add(Long.valueOf(1));\n\
    \                last_nested_parens.add(Long.valueOf(1));\n                deepest_nested_parens.add(Long.valueOf(1));\n\
    \                deepest_nested_parens_index.add(Long.valueOf(1));\n         \
    \   } else if(ch == \")\") {\n                String last_nested_string = \"\"\
    ;\n                for(int j = 0; j < last_nested_strings.size(); j++)\n     \
    \               if(last_nested_strings.get(j).equals(ch)) {\n                \
    \        last_nested_string = last_nested_strings.get(j);\n                  \
    \      break;\n                    }\n                last_nested_strings.add(last_nested_string);\n\
    \                if(last_nested_strings.size() > 1) {\n                    last_nested_level.add(Long.valueOf(last_nested_strings.size()\
    \ - 1));\n                    last_nested_parens.add(last_nested_parens.get(last_nested_strings.size()\
    \ - 1));\n                } else {\n                    last_nested_level.add(Long.valueOf(0));\n\
    \                    last_nested_parens.add(Long.valueOf(0));\n              \
    \  }\n                String last_nested_paren_string = String.valueOf(last_nested_parens.get(last_nested_strings.size()\
    \ - 1));\n                if(last_nested_paren_string.length() == 1) {\n     \
    \               last_nested_paren_string = String.valueOf(last_nested_paren_string.charAt(0))\
    \ + last_nested_paren_string;\n                }\n                String last_nested_string\
    \ = String.valueOf(last_nested_strings.get(last_nested_strings.size() - 1));\n\
    \                if(last_nested_strings.size() > 1) {\n                    last_nested_string\
    \ = String.valueOf(last_nested_strings.get(last_nested_strings.size() - 2)) +\
    \ last_nested_string;\n                }\n                last_nested_parens.set(last_nested_strings.size()\
    \ - 1, Long.valueOf(Long.parseLong(last_nested_paren_string)));\n            \
    \    last_nested_string.remove(last_nested_strings.size() - 1);\n            \
    \    deepest_nested_parens.set(last_nested_strings.size() - 1, Long.valueOf(Long.parseLong(last_nested_string)));\n\
    \                last_nested_string.remove(last_nested_strings.size() - 1);\n\
    \                deepest_nested_parens_index.set(last_nested_string\n    }\n \
    \   public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm051s_0v.java:59: error: ')' expected\n                deepest_nested_parens_index.set(last_nested_string\n\
    \                                                                  ^\n/tmp/tmpm051s_0v.java:61:\
    \ error: illegal start of expression\n    public static void main(String[] args)\
    \ {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Recursively calls itself until we reach the lowest\
    \ level of nesting or the input string is empty\n        if(paren_string.isEmpty())\
    \ {\n            return new ArrayList<Long>();\n        } else {\n           \
    \ // Split string into an array with one item per group of nested parentheses.\n\
    \            String[] groups = paren_string.split(\" \");\n            // Create\
    \ empty list for storing group lengths\n            ArrayList<Long> group_lengths\
    \ = new ArrayList<Long>();\n            // Traverse groups to process nested groups\
    \ and append to group_lengths\n            for(String group: groups) {\n     \
    \           // If the group is empty, do nothing.\n                if(group.isEmpty())\
    \ {\n                    continue;\n                }\n                // Parse\
    \ group\n                ArrayList<Long> group_lengths_temp = parseNestedParens(group);\n\
    \                // Append length of each nested group to group_lengths\n    \
    \            group_lengths.addAll(group_lengths_temp);\n            }\n      \
    \      // Return group_lengths list\n            return group_lengths;\n     \
    \   }\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat java.base/java.lang.StringLatin1.indexOf(StringLatin1.java:203)\n\
    \tat java.base/java.lang.String.indexOf(String.java:2421)\n\tat java.base/java.lang.String.indexOf(String.java:2378)\n\
    \tat java.base/java.lang.String.split(String.java:3110)\n\tat java.base/java.lang.String.split(String.java:3199)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:20)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\
    \tat Problem.parseNestedParens(tmp6x4r2ph0.java:30)\n\tat Problem.parse"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        List<Long> list_of_parens = new ArrayList<>();\n  \
    \      // Use a stack to store each parenthesis level\n        Stack<Integer>\
    \ stack = new Stack<>();\n        // Keep track of brackets which have already\
    \ been matched.\n        // For example, in the string \"(((()))\" the first three\
    \ parenthesis are matched.\n        // The inner parentheses are matched first.\
    \ The outer parenthesis pair is matched last.\n        // The inner parentheses\
    \ match is added to the stack. Once a closing parenthesis is matched, we push\n\
    \        // the opening parentheses onto the stack and remove the matching opening\
    \ parentheses from the list.\n        // When an opening parenthesis is matched,\
    \ we add the opening parenthesis to the stack (pushing the\n        // matching\
    \ closing parentheses onto the stack). The list should now contain only outer\
    \ parenthesis.\n        boolean bracket_match = false;\n        int parenthesis_level\
    \ = 0;\n        Matcher m = Pattern.compile(\"\\\\(|\\\\)\").matcher(paren_string);\n\
    \        // Loop through the input string, incrementing the level of nesting for\
    \ each matching parenthesis\n        while(m.find()) {\n            if(m.group(1)\
    \ != null) {\n                bracket_match = true;\n            }\n         \
    \   if(!bracket_match) {\n                stack.push(parenthesis_level);\n   \
    \             list_of_parens.add(parenthesis_level);\n                parenthesis_level++;\n\
    \            }\n        }\n        // When a closing parenthesis is matched, we\
    \ add the closing parenthesis to the stack and decrement the level\n        //\
    \ of nesting and push onto the list.\n        while(!stack.isEmpty()) {\n    \
    \        list_of_parens.add(stack.pop() - 1);\n            parenthesis_level--;\n\
    \        }\n        return list_of_parens;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0ba63gj0.java:27: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"\\\\(|\\\\)\").matcher(paren_string);\n        ^\n  symbol:\
    \   class Matcher\n  location: class Problem\n/tmp/tmp0ba63gj0.java:27: error:\
    \ cannot find symbol\n        Matcher m = Pattern.compile(\"\\\\(|\\\\)\").matcher(paren_string);\n\
    \                    ^\n  symbol:   variable Pattern\n  location: class Problem\n\
    /tmp/tmp0ba63gj0.java:35: error: incompatible types: int cannot be converted to\
    \ Long\n                list_of_parens.add(parenthesis_level);\n             \
    \                      ^\n/tmp/tmp0ba63gj0.java:42: error: incompatible types:\
    \ int cannot be converted to Long\n            list_of_parens.add(stack.pop()\
    \ - 1);\n                                           ^\n/tmp/tmp0ba63gj0.java:45:\
    \ error: incompatible types: List<Long> cannot be converted to ArrayList<Long>\n\
    \        return list_of_parens;\n               ^\nNote: Some messages have been\
    \ simplified; recompile with -Xdiags:verbose to get full output\n5 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList <Long> nest_levels = new ArrayList <Long>\
    \ ();\n        // The idea is to keep track of the number of open parentheses\
    \ in each group.\n        // Keep track of the deepest nesting level by iterating\
    \ through each group recursively.\n        ArrayList <Long> deepest_level = null;\n\
    \        // Keep track of the current open parentheses level\n        long current_level\
    \ = 1;\n        // Keep track of the total number of open parentheses in current\
    \ nesting level\n        long total_levels = 0;\n        // Keep track of the\
    \ total number of open parentheses in all nesting levels\n        long total_num_open_parens\
    \ = 0;\n        // Keep track of whether a group is open or closed in current\
    \ nesting level\n        boolean current_group_is_open = false;\n        // Keep\
    \ track of the current group\n        ArrayList <String> current_group = new ArrayList\
    \ <String>();\n        // Keep track of whether the current group is open or closed\n\
    \        boolean current_group_is_closed = false;\n        // Keep track of whether\
    \ a group is open or closed in current nesting level\n        boolean current_group_is_open\
    \ = false;\n        // Keep track of the current level\n        long current_level\
    \ = 1;\n        // Keep track of the current group string\n        String current_group_string\
    \ = \"\";\n        // Keep track of the group string\n        boolean current_group_is_closed\
    \ = false;\n        // Keep track of the group string\n        boolean current_group_is_open\
    \ = false;\n        for (char c : paren_string.toCharArray()) {\n            if\
    \ (c == '(') {\n                current_group_is_open = true;\n              \
    \  current_group_is_closed = false;\n                current_group_string = \"\
    \";\n                total_levels += current_level;\n                current_level\
    \ += 1;\n            } else if (c == '(') {\n                if (current_group_is_open)\
    \ {\n                    current_group_string = \"\";\n                    current_group_is_closed\
    \ = false;\n                    current_group_is_open = false;\n             \
    \       current_level -= 1;\n                } else {\n                    current_group_is_open\
    \ = true;\n                    current_group_is_closed = false;\n            \
    \        current_group_string = \"\";\n                    current_level += 1;\n\
    \                }\n            } else if (c == ')') {\n                current_group_is_open\
    \ = false;\n                current_group_is_closed = true;\n                if\
    \ (current_group_is_closed) {\n                    current_group_string = \"\"\
    ;\n                    current_level -= 1;\n                }\n            } else\
    \ if (c == ')') {\n                current_group_is_open = false;\n          \
    \      current_group_is_closed = true;\n                if (current_group_is_closed)\
    \ {\n                    current_group_string = \"\";\n                    current_level\
    \ -= 1;\n                }\n            } else if (c == '(') {\n             \
    \   current_group_is_open = false;\n                current_group_is_closed =\
    \ false;\n                total_levels += current_level;\n                current_level\
    \ += 1;\n            }\n            if (current_group_is_open) {\n           \
    \     current_group_string = current_group_string + c;\n            }\n      \
    \      if (current_group_\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbr6e94rz.java:83: error: ')' expected\n            if (current_group_\n\
    \                              ^\n/tmp/tmpbr6e94rz.java:84: error: illegal start\
    \ of statement\n    }\n    ^\n/tmp/tmpbr6e94rz.java:85: error: illegal start of\
    \ expression\n    public static void main(String[] args) {\n    ^\n3 errors\n"
  stdout: ''
  timestamp: 1660011446
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Initialize max value\n        ArrayList<Long> max_val\
    \ = new ArrayList<>();\n        // Initialize a map\n        HashMap<Long, Integer>\
    \ map = new HashMap<>();\n        // Initialize a stack list\n        ArrayList<Long>\
    \ stack = new ArrayList<>();\n        // Initialize a counter\n        Integer\
    \ level = 1;\n        // Initialize an additional stack to store all nested parenthesis\n\
    \        ArrayList<Long> nesting_stack = new ArrayList<>();\n        // Iterate\
    \ over input string\n        for(char c : paren_string.toCharArray()) {\n    \
    \        // If char is parenthesis, add it to a stack\n            if(c == '(')\
    \ {\n                stack.add(Long.valueOf(1));\n            } else if(c == ')')\
    \ {\n                // If current level is greater than max, update max\n   \
    \             if(level > max_val.size()) {\n                    max_val = stack;\n\
    \                }\n                // If current level is equal to max, add stack\
    \ to map of nesting\n                else if(level == max_val.size()) {\n    \
    \                map.putAll(nesting_stack);\n                }\n             \
    \   // If current level is less than max, add stack to map\n                else\
    \ {\n                    map.put(Long.valueOf(level), max_val.size());\n     \
    \           }\n                // Update nesting level\n                level--;\n\
    \                // Remove current level from stack\n                stack.remove(nesting_stack.size());\n\
    \                // Add current level to stack\n                nesting_stack.add(Long.valueOf(level));\n\
    \            } else {\n                // Add char to map\n                map.put(Long.valueOf(level),\
    \ map.getOrDefault(Long.valueOf(level), 0l));\n                // Add char to\
    \ stack\n                stack.add(Long.valueOf(1));\n            }\n        }\n\
    \        // If current level is greater than max, update max\n        if(level\
    \ > max_val.size()) {\n            max_val = stack;\n        }\n        // If\
    \ current level is equal to max, add stack to map of nesting\n        else if(level\
    \ == max_val.size()) {\n            map.putAll(nesting_stack);\n        }\n  \
    \      // If current level is less than max, add stack to map\n        else {\n\
    \            map.put(Long.valueOf(level), max_val.size());\n        }\n      \
    \  // Update nesting level\n        level--;\n        // Add stack to map\n  \
    \      map.put(Long.valueOf(level), max_val.size());\n        // Update nesting\
    \ level\n        level--;\n        // Add stack to map\n        map.put(Long.valueOf(level),\
    \ max_val.size());\n        // Update nesting level\n        level--;\n      \
    \  // Return map\n        return max_val;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppy3kxe_s.java:37: error: incompatible types: ArrayList<Long> cannot\
    \ be converted to Map<? extends Long,? extends Integer>\n                    map.putAll(nesting_stack);\n\
    \                               ^\n/tmp/tmppy3kxe_s.java:51: error: incompatible\
    \ types: long cannot be converted to Integer\n                map.put(Long.valueOf(level),\
    \ map.getOrDefault(Long.valueOf(level), 0l));\n                              \
    \                                                     ^\n/tmp/tmppy3kxe_s.java:62:\
    \ error: incompatible types: ArrayList<Long> cannot be converted to Map<? extends\
    \ Long,? extends Integer>\n            map.putAll(nesting_stack);\n          \
    \             ^\nNote: Some messages have been simplified; recompile with -Xdiags:verbose\
    \ to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nesting = new ArrayList<Long>();\n\
    \        String s = paren_string;\n        ArrayList<String> paren_groups = paren_string.split(\"\
    \\\\s+\");\n        paren_groups.forEach(s -> {\n            String[] sub = s.split(\"\
    \\\\(\");\n            sub.forEach(t -> {\n                try {\n           \
    \         Long l = Long.parseLong(t);\n                    if (l > 0) {\n    \
    \                    nesting.add(l);\n                    }\n                }\
    \ catch (NumberFormatException e) {\n                    Arrays.stream(sub).forEach(a\
    \ -> {\n                        System.out.println(a + \" does not represent a\
    \ number.\");\n                    });\n                }\n            });\n \
    \       });\n        if (nesting.size() > 1) {\n            ArrayList<Long> l\
    \ = new ArrayList<Long>();\n            Collections.sort(nesting);\n         \
    \   Long biggest = nesting.get(0);\n            l.add(biggest);\n            nesting.forEach(biggest\
    \ -> {\n                if (biggest == biggest + 1) {\n                    biggest\
    \ = biggest + 2;\n                }\n                l.add(biggest);\n       \
    \     });\n            return l;\n        }\n        return nesting;\n    }\n\
    \    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp581uv50i.java:17: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        ArrayList<String> paren_groups = paren_string.split(\"\
    \\\\s+\");\n                                                           ^\n/tmp/tmp581uv50i.java:18:\
    \ error: variable s is already defined in method parseNestedParens(String)\n \
    \       paren_groups.forEach(s -> {\n                             ^\n/tmp/tmp581uv50i.java:20:\
    \ error: cannot find symbol\n            sub.forEach(t -> {\n               ^\n\
    \  symbol:   method forEach((t)->{ try[...]; } })\n  location: variable sub of\
    \ type String[]\n/tmp/tmp581uv50i.java:38: error: variable biggest is already\
    \ defined in method parseNestedParens(String)\n            nesting.forEach(biggest\
    \ -> {\n                            ^\n4 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_level = new ArrayList<Long>();\n\
    \        ArrayList<String> paren_list = new ArrayList<String>();\n        paren_list\
    \ = paren_string.split(\" \");\n        for (String each_paren : paren_list) {\n\
    \            if (each_paren.matches(\"[^\\\\(\\\\)]*\")) {\n                paren_string\
    \ = paren_string.replaceAll(each_paren, \"\");\n            } else {\n       \
    \         paren_string = paren_string.replaceAll(\"\\\\(\" + each_paren + \"\\\
    \\)\", \"\");\n                Long new_level = new Long(paren_string.length());\n\
    \                paren_string = paren_string.replaceAll(each_paren, \"\");\n \
    \               if (max_level.stream().noneMatch(level -> new_level.compareTo(level)\
    \ == 0))\n                    max_level.add(new_level);\n            }\n     \
    \   }\n        return max_level;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpetto7vg3.java:17: error: incompatible types: String[] cannot be\
    \ converted to ArrayList<String>\n        paren_list = paren_string.split(\" \"\
    );\n                                       ^\n/tmp/tmpetto7vg3.java:23: warning:\
    \ [removal] Long(long) in Long has been deprecated and marked for removal\n  \
    \              Long new_level = new Long(paren_string.length());\n           \
    \                      ^\n1 error\n1 warning\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> list_of_parens = new ArrayList<>();\n\
    \        ArrayList<String> nested_strings = new ArrayList<>();\n        int index\
    \ = 0;\n        for (char character : paren_string.toCharArray()) {\n        \
    \    if (character == '(') {\n                nested_strings.add(paren_string.substring(index,\
    \ paren_string.length()));\n                index += 1;\n            } else if\
    \ (character == ')') {\n                nested_strings.add(paren_string.substring(index,\
    \ paren_string.length()));\n                list_of_parens.add(new ArrayList<>(nested_strings));\n\
    \                nested_strings = new ArrayList<>();\n                index +=\
    \ 1;\n            } else if (character == ' ') {\n                // ignore\n\
    \            } else {\n                nested_strings.add(character);\n      \
    \          index += 1;\n            }\n        }\n        list_of_parens.add(new\
    \ ArrayList<>(nested_strings));\n        return list_of_parens;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprgr2ma_k.java:24: error: incompatible types: cannot infer type\
    \ arguments for ArrayList<>\n                list_of_parens.add(new ArrayList<>(nested_strings));\n\
    \                                                ^\n    reason: no instance(s)\
    \ of type variable(s) E exist so that ArrayList<E> conforms to Long\n  where E\
    \ is a type-variable:\n    E extends Object declared in class ArrayList\n/tmp/tmprgr2ma_k.java:30:\
    \ error: incompatible types: char cannot be converted to String\n            \
    \    nested_strings.add(character);\n                                   ^\n/tmp/tmprgr2ma_k.java:34:\
    \ error: incompatible types: cannot infer type arguments for ArrayList<>\n   \
    \     list_of_parens.add(new ArrayList<>(nested_strings));\n                 \
    \                       ^\n    reason: no instance(s) of type variable(s) E exist\
    \ so that ArrayList<E> conforms to Long\n  where E is a type-variable:\n    E\
    \ extends Object declared in class ArrayList\nNote: Some messages have been simplified;\
    \ recompile with -Xdiags:verbose to get full output\n3 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nest = new ArrayList<Long>();\n   \
    \     Arrays.stream(paren_string.split(\" \")).map(s -> parseNestedParens(s, nest)).max(Comparator.naturalOrder());\n\
    \        return nest;\n    }\n    public static void main(String[] args) {\n \
    \   assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3sox6ttm.java:16: error: method parseNestedParens in class Problem\
    \ cannot be applied to given types;\n        Arrays.stream(paren_string.split(\"\
    \ \")).map(s -> parseNestedParens(s, nest)).max(Comparator.naturalOrder());\n\
    \                                                        ^\n  required: String\n\
    \  found:    String,ArrayList<Long>\n  reason: actual and formal argument lists\
    \ differ in length\n/tmp/tmp3sox6ttm.java:16: error: incompatible types: inference\
    \ variable T has incompatible bounds\n        Arrays.stream(paren_string.split(\"\
    \ \")).map(s -> parseNestedParens(s, nest)).max(Comparator.naturalOrder());\n\
    \                                                                            \
    \       ^\n    lower bounds: Comparable<? super T>\n    lower bounds: Object\n\
    \  where T is a type-variable:\n    T extends Comparable<? super T> declared in\
    \ method <T>naturalOrder()\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Initialize result list\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        // Initialize stack to hold all groups\n\
    \        ArrayList<String> stack = new ArrayList<String>();\n        // Add first\
    \ group to the stack\n        stack.push(paren_string);\n        // While there\
    \ are groups left\n        while (stack.size() > 0) {\n            // Pop last\
    \ element from the stack\n            String temp = stack.remove(stack.size()\
    \ - 1);\n            // If it has only one group, add it to the result and continue\n\
    \            if (temp.contains(\")\")) {\n                result.add(new Long(temp.length()\
    \ - 1));\n                continue;\n            }\n            // If the last\
    \ element in the stack is a \")\", it means it is the deepest level of parentheses\n\
    \            if (temp.equals(\")\")) {\n                // If the stack size is\
    \ 1, the deepest level of parentheses is 1.\n                if (stack.size()\
    \ == 1) {\n                    result.add(new Long(1));\n                    continue;\n\
    \                }\n                // Otherwise, the deepest level of parentheses\
    \ is its parent index\n                result.add(new Long(stack.size() - 1));\n\
    \            }\n            // If it has 2 groups, recursively add them to the\
    \ stack\n            else if (temp.contains(\"()\")) {\n                stack.add(temp.substring(temp.lastIndexOf(\"\
    (\") + 1, temp.length() - 1));\n            }\n            // If it has 1 group,\
    \ it is a single character group\n            else if (temp.equals(\"(\")) {\n\
    \                // If the stack size is 1, the deepest level of parentheses is\
    \ 1.\n                if (stack.size() == 1) {\n                    result.add(new\
    \ Long(1));\n                    continue;\n                }\n              \
    \  // Otherwise, the deepest level of parentheses is its parent index\n      \
    \          result.add(new Long(stack.size() - 1));\n            }\n          \
    \  // If the last element in the stack is \")\", it means it is already in the\
    \ deepest level of parentheses\n            else {\n                // If the\
    \ stack size is 1, the deepest level of parentheses is 1.\n                if\
    \ (stack.size() == 1) {\n                    result.add(new Long(1));\n      \
    \              continue;\n                }\n                // Otherwise, the\
    \ deepest level of parentheses is its parent index\n                result.add(new\
    \ Long(stack.size() - 1));\n            }\n        }\n        // Return the result\n\
    \        return result;\n    }\n    public static void main(String[] args) {\n\
    \    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzmz8uceb.java:20: error: cannot find symbol\n        stack.push(paren_string);\n\
    \             ^\n  symbol:   method push(String)\n  location: variable stack of\
    \ type ArrayList<String>\n/tmp/tmpzmz8uceb.java:27: warning: [removal] Long(long)\
    \ in Long has been deprecated and marked for removal\n                result.add(new\
    \ Long(temp.length() - 1));\n                           ^\n/tmp/tmpzmz8uceb.java:34:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                    result.add(new Long(1));\n                              \
    \ ^\n/tmp/tmpzmz8uceb.java:38: warning: [removal] Long(long) in Long has been\
    \ deprecated and marked for removal\n                result.add(new Long(stack.size()\
    \ - 1));\n                           ^\n/tmp/tmpzmz8uceb.java:48: warning: [removal]\
    \ Long(long) in Long has been deprecated and marked for removal\n            \
    \        result.add(new Long(1));\n                               ^\n/tmp/tmpzmz8uceb.java:52:\
    \ warning: [removal] Long(long) in Long has been deprecated and marked for removal\n\
    \                result.add(new Long(stack.size() - 1));\n                   \
    \        ^\n/tmp/tmpzmz8uceb.java:58: warning: [removal] Long(long) in Long has\
    \ been deprecated and marked for removal\n                    result.add(new Long(1));\n\
    \                               ^\n/tmp/tmpzmz8uceb.java:62: warning: [removal]\
    \ Long(long) in Long has been deprecated and marked for removal\n            \
    \    result.add(new Long(stack.size() - 1));\n                           ^\n1\
    \ error\n7 warnings\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Create three arrays to store the result\n      \
    \  ArrayList<Long> paren_level0 = new ArrayList<>();\n        ArrayList<Long>\
    \ paren_level1 = new ArrayList<>();\n        ArrayList<Long> paren_level2 = new\
    \ ArrayList<>();\n\n        // Parse the paren_string\n        StringBuilder sb\
    \ = new StringBuilder();\n        Matcher m = Pattern.compile(\"\\\\(\\\\s*\\\\\
    (([^()]*)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n        while (m.find())\
    \ {\n            sb.append(m.group(1));\n            paren_level1.add(Long.parseLong(sb.toString()));\n\
    \            sb.delete(0, sb.length());\n        }\n        m = Pattern.compile(\"\
    \\\\(\\\\s*\\\\(([^()]*)\\\\s*\\\\)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n\
    \        while (m.find()) {\n            sb.append(m.group(1));\n            paren_level2.add(Long.parseLong(sb.toString()));\n\
    \            sb.delete(0, sb.length());\n        }\n        m = Pattern.compile(\"\
    \\\\(\\\\s*\\\\(([^()]*)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n \
    \       while (m.find()) {\n            sb.append(m.group(1));\n            paren_level0.add(Long.parseLong(sb.toString()));\n\
    \            sb.delete(0, sb.length());\n        }\n\n        // Find the deepest\
    \ level of nesting in the paren_level[1-3]\n        long max_level = 1;\n    \
    \    for (Long l : paren_level0) {\n            max_level = max(max_level, l);\n\
    \        }\n        for (Long l : paren_level1) {\n            max_level = max(max_level,\
    \ l);\n        }\n        for (Long l : paren_level2) {\n            max_level\
    \ = max(max_level, l);\n        }\n\n        // Return the result to the caller\n\
    \        ArrayList<Long> result = new ArrayList<>(max_level);\n        long i\
    \ = 0;\n        for (Long l : paren_level0) {\n            result.add(l);\n  \
    \          i++;\n        }\n        for (Long l : paren_level1) {\n          \
    \  result.add(l);\n            i++;\n        }\n        for (Long l : paren_level2)\
    \ {\n            result.add(l);\n            i++;\n        }\n        return result;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp43ufcyxk.java:22: error: cannot find symbol\n        Matcher m\
    \ = Pattern.compile(\"\\\\(\\\\s*\\\\(([^()]*)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n\
    \        ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmp43ufcyxk.java:22:\
    \ error: cannot find symbol\n        Matcher m = Pattern.compile(\"\\\\(\\\\s*\\\
    \\(([^()]*)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n              \
    \      ^\n  symbol:   variable Pattern\n  location: class Problem\n/tmp/tmp43ufcyxk.java:28:\
    \ error: cannot find symbol\n        m = Pattern.compile(\"\\\\(\\\\s*\\\\(([^()]*)\\\
    \\s*\\\\)\\\\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n            ^\n \
    \ symbol:   variable Pattern\n  location: class Problem\n/tmp/tmp43ufcyxk.java:34:\
    \ error: cannot find symbol\n        m = Pattern.compile(\"\\\\(\\\\s*\\\\(([^()]*)\\\
    \\s*\\\\)\\\\s*\\\\).*\").matcher(paren_string);\n            ^\n  symbol:   variable\
    \ Pattern\n  location: class Problem\n/tmp/tmp43ufcyxk.java:44: error: cannot\
    \ find symbol\n            max_level = max(max_level, l);\n                  \
    \      ^\n  symbol:   method max(long,Long)\n  location: class Problem\n/tmp/tmp43ufcyxk.java:47:\
    \ error: cannot find symbol\n            max_level = max(max_level, l);\n    \
    \                    ^\n  symbol:   method max(long,Long)\n  location: class Problem\n\
    /tmp/tmp43ufcyxk.java:50: error: cannot find symbol\n            max_level = max(max_level,\
    \ l);\n                        ^\n  symbol:   method max(long,Long)\n  location:\
    \ class Problem\n/tmp/tmp43ufcyxk.java:54: error: cannot infer type arguments\
    \ for ArrayList<>\n        ArrayList<Long> result = new ArrayList<>(max_level);\n\
    \                                 ^\n8 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> levels = new ArrayList<>();\n     \
    \   levels.add(0l);\n        ArrayList<ArrayList<Long>> stack = new ArrayList<>();\n\
    \        stack.add(levels);\n        for (String parens : paren_string.trim().split(\"\
    \\\\s+\")) {\n            if (parens.length() > 0) {\n                ArrayList<Long>\
    \ current_levels = stack.get(stack.size() - 1);\n                long current_levels_size\
    \ = current_levels.size();\n                long levels_size = current_levels.size()\
    \ + 1;\n                current_levels.add(levels_size);\n                ArrayList<Long>\
    \ current_levels_copy = new ArrayList<>(current_levels);\n                stack.add(current_levels_copy);\n\
    \                for (String depth : parens.trim().split(\"\\\\(\")) {\n     \
    \               if (depth.length() > 0) {\n                        current_levels_copy.add(0l);\n\
    \                        stack.add(current_levels_copy);\n                   \
    \ } else {\n                        ArrayList<Long> current_levels_copy = stack.get(stack.size()\
    \ - 1);\n                        current_levels_copy.remove(current_levels_copy.size()\
    \ - 1);\n                        current_levels_copy.add(0l);\n              \
    \          stack.add(current_levels_copy);\n                    }\n          \
    \      }\n                stack.remove(stack.size() - 1);\n                levels_size\
    \ = current_levels.size();\n                levels.add(levels_size);\n       \
    \     }\n        }\n        return levels;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmv_vhnxv.java:32: error: variable current_levels_copy is already\
    \ defined in method parseNestedParens(String)\n                        ArrayList<Long>\
    \ current_levels_copy = stack.get(stack.size() - 1);\n                       \
    \                 ^\n1 error\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_levels = new ArrayList<Long>();\n\
    \        // We need to parse the string and find the largest level of nested parentheses.\n\
    \        // We need to store the position in string of each level of nesting and\
    \ the value for each level\n        // of nesting.\n        // For example:\n\
    \        // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n       \
    \ // [(1,2), (1,3), (2,1), (3,1), (4,1), (4,2)]\n        // (1) The largest level\
    \ of nesting is at index 1 with value 2.\n        // (2) The largest level of\
    \ nesting is at index 1 with value 3.\n        // (3) The largest level of nesting\
    \ is at index 2 with value 1.\n        // (4) The largest level of nesting is\
    \ at index 3 with value 1.\n        // (5) The largest level of nesting is at\
    \ index 4 with value 1.\n        // (6) The largest level of nesting is at index\
    \ 4 with value 2.\n        // We need to find all these levels of nesting and\
    \ store them in a map with key as the index of level\n        // and value as\
    \ the position in string.\n        // We can use a map to store the max level\
    \ of nesting and the position of nesting in a string as long\n        // as the\
    \ key is the index of the level and the value is the position in string.\n   \
    \     Map<Integer, ArrayList<Integer>> max_levels_map = new HashMap<Integer, ArrayList<Integer>>();\n\
    \        Map<Integer, Integer> levels_map = new HashMap<Integer, Integer>();\n\
    \        int level = 0;\n        int position = 0;\n        boolean flag = false;\n\
    \        int current_level = 1;\n        for (int i = 0; i < paren_string.length();\
    \ ++i) {\n            char current = paren_string.charAt(i);\n            switch\
    \ (current) {\n                case '(':\n                    if (flag) {\n  \
    \                      current_level++;\n                        levels_map.put(current_level,\
    \ position);\n                        flag = false;\n                    }\n \
    \                   break;\n                case ')':\n                    if\
    \ (!flag) {\n                        current_level--;\n                      \
    \  levels_map.put(current_level, position);\n                        flag = true;\n\
    \                    }\n                    break;\n                case ' ':\n\
    \                    if (flag) {\n                        current_level++;\n \
    \                       levels_map.put(current_level, position);\n           \
    \             flag = false;\n                        max_levels_map.put(level,\
    \ max_levels);\n                        max_levels = new ArrayList<Long>();\n\
    \                    } else {\n                        max_levels.add(Long.parseLong(paren_string.substring(position,\
    \ i)));\n                        flag = true;\n                        position\
    \ = i;\n                    }\n                    break;\n                default:\n\
    \                    if (flag) {\n                        max_levels.add(Long.parseLong(paren_string.substring(position,\
    \ i)));\n                        flag = false;\n                        position\
    \ = i;\n                    }\n                    break;\n            }\n   \
    \     }\n        // If the string ends with space add the last max level\n   \
    \     if (\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmped0ejh6g.java:79: error: illegal start of expression\n    }\n \
    \   ^\n1 error\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> results = new ArrayList<>();\n    \
    \    HashMap<String, ArrayList<Long>> paren_map = paren_string.chars().mapToObj(i\
    \ -> Character.toString((char) i)).collect(Collectors.groupingBy(str -> str, Collectors.mapping(str\
    \ -> str, Collectors.toList())));\n        for (String key: paren_map.keySet())\
    \ {\n            ArrayList<Long> levels = paren_map.get(key);\n            for\
    \ (long level : levels) {\n                if (!results.contains(level)) results.add(level);\n\
    \            }\n        }\n        return results; // results is List<long> of\
    \ levels\n    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm3kt01cu.java:16: error: incompatible types: inference variable\
    \ R has incompatible bounds\n        HashMap<String, ArrayList<Long>> paren_map\
    \ = paren_string.chars().mapToObj(i -> Character.toString((char) i)).collect(Collectors.groupingBy(str\
    \ -> str, Collectors.mapping(str -> str, Collectors.toList())));\n           \
    \                                                                            \
    \                                      ^\n    equality constraints: Map<K,D>\n\
    \    lower bounds: HashMap<String,ArrayList<Long>>,Object\n  where R,A#1,T#1,K,T#2,A#2,D\
    \ are type-variables:\n    R extends Object declared in method <R,A#1>collect(Collector<?\
    \ super T#1,A#1,R>)\n    A#1 extends Object declared in method <R,A#1>collect(Collector<?\
    \ super T#1,A#1,R>)\n    T#1 extends Object declared in interface Stream\n   \
    \ K extends Object declared in method <T#2,K,A#2,D>groupingBy(Function<? super\
    \ T#2,? extends K>,Collector<? super T#2,A#2,D>)\n    T#2 extends Object declared\
    \ in method <T#2,K,A#2,D>groupingBy(Function<? super T#2,? extends K>,Collector<?\
    \ super T#2,A#2,D>)\n    A#2 extends Object declared in method <T#2,K,A#2,D>groupingBy(Function<?\
    \ super T#2,? extends K>,Collector<? super T#2,A#2,D>)\n    D extends Object declared\
    \ in method <T#2,K,A#2,D>groupingBy(Function<? super T#2,? extends K>,Collector<?\
    \ super T#2,A#2,D>)\n1 error\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> max_level = new ArrayList<>();\n  \
    \      StringTokenizer tokens = new StringTokenizer(paren_string, \" \");\n  \
    \      while (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n\
    \            boolean is_start = true;\n            ArrayList<Long> levels = new\
    \ ArrayList<>();\n            while (true) {\n                try {\n        \
    \            Class<?> class_to_get_length = Class.forName(\"java.util.ArrayList\"\
    );\n                    Object length_instance = class_to_get_length.getConstructor(String.class).newInstance(token);\n\
    \                    Method get_length = class_to_get_length.getMethod(\"get\"\
    );\n                    Object length_value = get_length.invoke(length_instance);\n\
    \                    Class<?> class_to_get_length = Class.forName(\"java.util.ArrayList\"\
    );\n                    Class<?> class_to_get_length = Class.forName(\"java.util.ArrayList\"\
    );\n                    Method add_length = class_to_get_length.getMethod(\"add\"\
    , Object.class);\n                    add_length.invoke(levels, length_value);\n\
    \                    is_start = false;\n                    break;\n         \
    \       } catch (ClassNotFoundException e) {\n                    e.printStackTrace();\n\
    \                } catch (NoSuchMethodException e) {\n                    e.printStackTrace();\n\
    \                } catch (InstantiationException e) {\n                    e.printStackTrace();\n\
    \                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n\
    \                } catch (InvocationTargetException e) {\n                   \
    \ e.printStackTrace();\n                }\n            }\n            if (is_start)\
    \ {\n                max_level.add(Math.max(levels.stream().mapToLong(Long::longValue).sum(),\
    \ 1l));\n            }\n        }\n        return max_level;\n    }\n    public\
    \ static void main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((()))\
    \ () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l,\
    \ (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l, (long)3l, (long)4l)))));\n\
    \    assert(parseNestedParens((\"(()(())((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpomkdiurp.java:27: error: variable class_to_get_length is already\
    \ defined in method parseNestedParens(String)\n                    Class<?> class_to_get_length\
    \ = Class.forName(\"java.util.ArrayList\");\n                             ^\n\
    /tmp/tmpomkdiurp.java:28: error: variable class_to_get_length is already defined\
    \ in method parseNestedParens(String)\n                    Class<?> class_to_get_length\
    \ = Class.forName(\"java.util.ArrayList\");\n                             ^\n\
    2 errors\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> groups = new ArrayList<>();\n     \
    \   HashMap<String, Integer> nesting_counts = new HashMap<>();\n        StringBuilder\
    \ paren_strings = new StringBuilder(paren_string);\n\n        int curly_count\
    \ = 0;\n        boolean is_escaped = false;\n        while (!paren_strings.toString().equals(\"\
    (\")) {\n            paren_strings = new StringBuilder(paren_strings.toString().substring(1));\n\
    \            paren_strings.delete(0, 1);\n            String group = paren_strings.toString();\n\
    \            paren_strings.delete(0, 1);\n            String next_group = paren_strings.toString();\n\
    \            paren_strings.delete(0, 1);\n            if (nesting_counts.containsKey(group))\
    \ {\n                int nesting_count = nesting_counts.get(group);\n        \
    \        nesting_count++;\n                nesting_counts.put(group, nesting_count);\n\
    \            } else {\n                nesting_counts.put(group, 0);\n       \
    \     }\n            if (nesting_counts.get(group) > nesting_counts.containsValue(group))\
    \ {\n                groups.add(Long.valueOf(group));\n            }\n       \
    \     if (nesting_counts.containsKey(next_group)) {\n                int nesting_count\
    \ = nesting_counts.get(next_group);\n                nesting_count--;\n      \
    \          nesting_counts.put(next_group, nesting_count);\n            } else\
    \ {\n                nesting_counts.put(next_group, 0);\n            }\n     \
    \       is_escaped = !is_escaped;\n            curly_count++;\n        }\n   \
    \     List<Long> groups_list = new ArrayList<>();\n        groups_list.addAll(groups);\n\
    \        groups_list.removeAll(groups.stream().filter((x) -> !nesting_counts.containsValue(x)).collect(Collectors.toList()));\n\
    \        ArrayList<Long> finalResult = new ArrayList<>();\n        for (int i\
    \ = 0; i < groups_list.size(); i++) {\n            String group_to_check = groups_list.get(i).toString();\n\
    \            if (!nesting_counts.containsValue(group_to_check)) {\n          \
    \      continue;\n            }\n            Long group = new Long(groups_list.get(i).toString());\n\
    \            while (nesting_counts.get(group_to_check) > nesting_counts.get(group))\
    \ {\n                group = new Long(group.toString());\n            }\n    \
    \        finalResult.add(group);\n        }\n        return finalResult;\n   \
    \ }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8ljqs3ad.java:35: error: bad operand types for binary operator\
    \ '>'\n            if (nesting_counts.get(group) > nesting_counts.containsValue(group))\
    \ {\n                                          ^\n  first type:  Integer\n  second\
    \ type: boolean\n/tmp/tmp8ljqs3ad.java:57: warning: [removal] Long(String) in\
    \ Long has been deprecated and marked for removal\n            Long group = new\
    \ Long(groups_list.get(i).toString());\n                         ^\n/tmp/tmp8ljqs3ad.java:59:\
    \ warning: [removal] Long(String) in Long has been deprecated and marked for removal\n\
    \                group = new Long(group.toString());\n                       \
    \ ^\n1 error\n2 warnings\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> nested_levels = new ArrayList<Long>();\n\
    \n        StringTokenizer stringTokenizer = new StringTokenizer(paren_string);\n\
    \n        while (stringTokenizer.hasMoreTokens()) {\n            String token\
    \ = stringTokenizer.nextToken();\n            if (token.equals(\"(\")) {\n   \
    \             nested_levels.add((long) nested_levels.size());\n            } else\
    \ if (token.equals(\")\")) {\n                nested_levels.remove(nested_levels.size()\
    \ - 1);\n            } else if (nested_levels.size() > 0) {\n                nested_levels.add((long)\
    \ nested_levels.size());\n            }\n        }\n        return nested_levels;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplpzjd5eh.java:32)\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // TODO: Use a stack to store each open and close paren\n\
    \        ArrayList<Long> opening_parens = new ArrayList<>();\n        ArrayList<Long>\
    \ closing_parens = new ArrayList<>();\n        // TODO: Use a map/hashmap to store\
    \ each pair of (openingParen, closingParen).\n        // The value should indicate\
    \ the number of levels of nesting.\n        HashMap<Long, Long> open_map = new\
    \ HashMap<>();\n        open_map.put(0l, 0l);\n        open_map.put(1l, 0l);\n\
    \        open_map.put(2l, 0l);\n        open_map.put(3l, 0l);\n        open_map.put(4l,\
    \ 0l);\n        open_map.put(5l, 0l);\n\n        HashMap<Long, Long> close_map\
    \ = new HashMap<>();\n        close_map.put(0l, 0l);\n        close_map.put(1l,\
    \ 0l);\n        close_map.put(2l, 0l);\n        close_map.put(3l, 0l);\n     \
    \   close_map.put(4l, 0l);\n        close_map.put(5l, 0l);\n        \n       \
    \ HashMap<Long, Integer> level_count = new HashMap<>();\n        level_count.put(0l,\
    \ 0l);\n        level_count.put(1l, 0l);\n        level_count.put(2l, 0l);\n \
    \       level_count.put(3l, 0l);\n        level_count.put(4l, 0l);\n        level_count.put(5l,\
    \ 0l);\n        \n        ArrayList<Long> results = new ArrayList<>();\n\n   \
    \     // Iterate through the input string and parse each pair of parentheses into\
    \ a long.\n        for(int i = 0; i < paren_string.length(); i++) {\n        \
    \    String currentParen = paren_string.substring(i, i + 1);\n            String\
    \ nextParen = paren_string.substring(i + 1, i + 2);\n\n            if( currentParen.equals(\"\
    (\")) {\n                opening_parens.add(Long.parseLong(nextParen));\n    \
    \            close_map.put(opening_parens.get(opening_parens.size() - 1), opening_parens.get(opening_parens.size()\
    \ - 1) + 1l);\n                level_count.put(opening_parens.get(opening_parens.size()\
    \ - 1), opening_parens.get(opening_parens.size() - 1) + 1l);\n               \
    \ open_map.put(opening_parens.get(opening_parens.size() - 1), opening_parens.get(opening_parens.size()\
    \ - 1) + 1l);\n            } else if( currentParen.equals(\")\")) {\n        \
    \        closing_parens.add(Long.parseLong(nextParen));\n                open_map.put(closing_parens.get(closing_parens.size()\
    \ - 1), closing_parens.get(closing_parens.size() - 1) + 1l);\n               \
    \ level_count.put(closing_parens.get(closing_parens.size() - 1), closing_parens.get(\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpan0uvypo.java:60: error: illegal start of expression\n    }\n \
    \   ^\n/tmp/tmpan0uvypo.java:61: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // The regex to find out if there is an even number\
    \ of left and right parentheses pairing\n        Pattern p = Pattern.compile(\"\
    \\\\((\\\\((?<left>)\\\\{2,}(?<right>)\\\\{2,\\\\})\\\\)\");\n        Matcher\
    \ m = p.matcher(paren_string);\n        ArrayList<Long> ans = new ArrayList<>();\n\
    \        while (m.find()) {\n            ans.add(new Long(m.group(1).length()));\n\
    \        }\n        return ans;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplr7zq5kn.java:16: error: cannot find symbol\n        Pattern p\
    \ = Pattern.compile(\"\\\\((\\\\((?<left>)\\\\{2,}(?<right>)\\\\{2,\\\\})\\\\\
    )\");\n        ^\n  symbol:   class Pattern\n  location: class Problem\n/tmp/tmplr7zq5kn.java:16:\
    \ error: cannot find symbol\n        Pattern p = Pattern.compile(\"\\\\((\\\\\
    ((?<left>)\\\\{2,}(?<right>)\\\\{2,\\\\})\\\\)\");\n                    ^\n  symbol:\
    \   variable Pattern\n  location: class Problem\n/tmp/tmplr7zq5kn.java:17: error:\
    \ cannot find symbol\n        Matcher m = p.matcher(paren_string);\n        ^\n\
    \  symbol:   class Matcher\n  location: class Problem\n3 errors\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> return_array = new ArrayList<Long>();\n\
    \        for (int i=0; i<paren_string.length(); ++i) {\n            String current_char\
    \ = paren_string.substring(i, paren_string.length());\n            if (current_char.equals(\"\
    (\") || current_char.equals(\")\")) {\n                return_array.add(Long.valueOf(current_char.hashCode()));\n\
    \                return_array.add(Long.valueOf(1));\n            } else {\n  \
    \              return_array.add(Long.valueOf(paren_string.indexOf(\"(\", i+1)));\n\
    \                return_array.add(Long.valueOf(1));\n            }\n        }\n\
    \        return return_array;\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfzlpoikg.java:29)\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> paren_levels = new ArrayList<Long>();\n\
    \n        // This stack will help us keep track of how many open parens are contained\
    \ within a level of nesting.\n        Stack<Long> paren_level_stack = new Stack<Long>();\n\
    \n        // For each open paren, pop the top of paren_level_stack and increment\
    \ that level.\n        for (char ch : paren_string.toCharArray()) {\n        \
    \    if (ch == '(') {\n                paren_level_stack.push(paren_level_stack.size());\n\
    \            } else if (ch == ')') {\n                paren_level_stack.pop();\n\
    \            }\n        }\n\n        // At each level of nesting except the last\
    \ one (which is the deepest nesting),\n        // add the number of open parens\
    \ contained within that level.\n        for (int level = 0; level < paren_level_stack.size();\
    \ level++) {\n            paren_levels.add(paren_level_stack.get(level));\n  \
    \      }\n\n        return paren_levels;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7zsy_fhq.java:23: error: incompatible types: int cannot be converted\
    \ to Long\n                paren_level_stack.push(paren_level_stack.size());\n\
    \                                                             ^\nNote: Some messages\
    \ have been simplified; recompile with -Xdiags:verbose to get full output\n1 error\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        // Define a stack data structure to store current level.\n\
    \        Stack<Long> nesting_stack = new Stack<Long>();\n        // Define a temporary\
    \ array list to store current level nested parentheses\n        // and store the\
    \ current level in it.\n        ArrayList<Long> stack = new ArrayList<Long>();\n\
    \        // Parse the input string for each group of nested parentheses.\n   \
    \     for (String paren_string : paren_string.split(\" \")) {\n            //\
    \ If current level is zero then push current level to nesting_stack\n        \
    \    // and push parens to stack.\n            if (nesting_stack.size() == 0)\
    \ {\n                nesting_stack.push(Long.parseLong(paren_string));\n     \
    \           stack.clear();\n                stack.push(Long.parseLong(paren_string));\n\
    \            } else {\n                // If current level is greater then 0 then\
    \ push current level\n                // to nesting_stack and push parens to stack.\n\
    \                if (nesting_stack.size() > 0 && nesting_stack.get(nesting_stack.size()\
    \ - 1) < Long.parseLong(paren_string)) {\n                    nesting_stack.push(Long.parseLong(paren_string));\n\
    \                    stack.clear();\n                    stack.push(Long.parseLong(paren_string));\n\
    \                }\n                // If current level is less then 0 then pop\
    \ current level and\n                // push parens to stack.\n              \
    \  else if (nesting_stack.size() < Long.parseLong(paren_string)) {\n         \
    \           nesting_stack.pop();\n                    stack.clear();\n       \
    \             stack.push(Long.parseLong(paren_string));\n                }\n \
    \           }\n        }\n        // Pop all elements in nesting_stack and return\
    \ the stack.\n        ArrayList<Long> result = new ArrayList<Long>();\n      \
    \  while (nesting_stack.size() > 0) {\n            result.add(nesting_stack.pop());\n\
    \        }\n        return result;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprtmhykmj.java:21: error: variable paren_string is already defined\
    \ in method parseNestedParens(String)\n        for (String paren_string : paren_string.split(\"\
    \ \")) {\n                    ^\n/tmp/tmprtmhykmj.java:27: error: cannot find\
    \ symbol\n                stack.push(Long.parseLong(paren_string));\n        \
    \             ^\n  symbol:   method push(long)\n  location: variable stack of\
    \ type ArrayList<Long>\n/tmp/tmprtmhykmj.java:34: error: cannot find symbol\n\
    \                    stack.push(Long.parseLong(paren_string));\n             \
    \            ^\n  symbol:   method push(long)\n  location: variable stack of type\
    \ ArrayList<Long>\n/tmp/tmprtmhykmj.java:41: error: cannot find symbol\n     \
    \               stack.push(Long.parseLong(paren_string));\n                  \
    \       ^\n  symbol:   method push(long)\n  location: variable stack of type ArrayList<Long>\n\
    4 errors\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> deepest_nesting = new ArrayList<Long>();\n\
    \        if (paren_string.length() <= 0) {\n            deepest_nesting.add(0);\n\
    \            return deepest_nesting;\n        }\n        paren_string = paren_string.trim();\n\
    \        paren_string = paren_string.replaceAll(\"(\\\\()|\\\\)\", \"\")\n   \
    \             .replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \ \", \"\")\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\[\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\]\", \"\");\n        paren_string = paren_string.replaceAll(\"\\\\{\", \"\"\
    );\n        paren_string = paren_string.replaceAll(\"\\\\}\", \"\");\n       \
    \ paren_string = paren_string.replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\" \", \"\")\n                .replaceAll(\"\\\\s+\"\
    , \" \");\n        paren_string = paren_string.replaceAll(\"\\\\[\", \"\");\n\
    \        paren_string = paren_string.replaceAll(\"\\\\]\", \"\");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\{\", \"\");\n        paren_string = paren_string.replaceAll(\"\
    \\\\}\", \"\");\n        paren_string = paren_string.replaceAll(\"\\\\)\", \"\"\
    )\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \ \", \"\")\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\(\", \"\")\n                .replaceAll(\"\\\
    \\s+\", \" \");\n        paren_string = paren_string.replaceAll(\" \", \"\")\n\
    \                .replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \\\\(\", \"\")\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\" \", \"\")\n                .replaceAll(\"\\\\s+\"\
    , \" \");\n        paren_string = paren_string.replaceAll(\"\\\\)\", \"\")\n \
    \               .replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \ \", \"\")\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\"\\\\)\", \"\")\n                .replaceAll(\"\\\
    \\s+\", \" \");\n        paren_string = paren_string.replaceAll(\" \", \"\")\n\
    \                .replaceAll(\"\\\\s+\", \" \");\n        paren_string = paren_string.replaceAll(\"\
    \\\\)\", \"\")\n                .replaceAll(\"\\\\s+\", \" \");\n        paren_string\
    \ = paren_string.replaceAll(\" \", \"\")\n                .replaceAll(\"\\\\s+\"\
    , \" \");\n        paren_string\n    }\n    public static void main(String[] args)\
    \ {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0nq14aok.java:60: error: not a statement\n        paren_string\n\
    \        ^\n/tmp/tmp0nq14aok.java:60: error: ';' expected\n        paren_string\n\
    \                    ^\n2 errors\n"
  stdout: ''
  timestamp: 1660011447
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> parentheses_nesting_level = new ArrayList<Long>();\n\
    \        parentheses_nesting_level.add(0);\n        ArrayList<Long> parentheses_group\
    \ = new ArrayList<Long>();\n        parentheses_group.add(0);\n        // Parsing\
    \ input string for nested parentheses.\n        Matcher nestedPAtterns = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(paren_string);\n        while(nestedPAtterns.find())\
    \ {\n            // If there are parentheses in the group, decrease the level\
    \ of nesting.\n            if(parentheses_group.size() > 0) {\n              \
    \  parentheses_nesting_level.get(parentheses_group.size() - 1)--;\n          \
    \  }\n            // If there are parentheses in the nesting level, increase the\
    \ level of nesting.\n            if(parentheses_nesting_level.size() > 0) {\n\
    \                parentheses_nesting_level.get(parentheses_nesting_level.size()\
    \ - 1)++;\n            }\n            // Add the level of nesting to the list.\n\
    \            parentheses_nesting_level.add(parentheses_nesting_level.get(parentheses_group.size()\
    \ - 1));\n            parentheses_group.add(parentheses_nesting_level.size() -\
    \ 1);\n        }\n        // Return the list of nested parentheses groups.\n \
    \       return parentheses_group;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkxtug6_2.java:16: error: incompatible types: int cannot be converted\
    \ to Long\n        parentheses_nesting_level.add(0);\n                       \
    \               ^\n/tmp/tmpkxtug6_2.java:18: error: incompatible types: int cannot\
    \ be converted to Long\n        parentheses_group.add(0);\n                  \
    \            ^\n/tmp/tmpkxtug6_2.java:20: error: cannot find symbol\n        Matcher\
    \ nestedPAtterns = Pattern.compile(\"\\\\((.*?)\\\\)\").matcher(paren_string);\n\
    \        ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmpkxtug6_2.java:20:\
    \ error: cannot find symbol\n        Matcher nestedPAtterns = Pattern.compile(\"\
    \\\\((.*?)\\\\)\").matcher(paren_string);\n                                 ^\n\
    \  symbol:   variable Pattern\n  location: class Problem\n/tmp/tmpkxtug6_2.java:24:\
    \ error: unexpected type\n                parentheses_nesting_level.get(parentheses_group.size()\
    \ - 1)--;\n                                             ^\n  required: variable\n\
    \  found:    value\n/tmp/tmpkxtug6_2.java:28: error: unexpected type\n       \
    \         parentheses_nesting_level.get(parentheses_nesting_level.size() - 1)++;\n\
    \                                             ^\n  required: variable\n  found:\
    \    value\n/tmp/tmpkxtug6_2.java:32: error: incompatible types: int cannot be\
    \ converted to Long\n            parentheses_group.add(parentheses_nesting_level.size()\
    \ - 1);\n                                                                   ^\n\
    Note: Some messages have been simplified; recompile with -Xdiags:verbose to get\
    \ full output\n7 errors\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> results = new ArrayList<Long>();\n\
    \        Matcher matcher = Pattern.compile(\"\\\\(([^\\\\(\\\\)]+)\\\\)\").matcher(paren_string);\n\
    \        while (matcher.find()) {\n            String group = matcher.group(1);\n\
    \            StringBuilder groupString = new StringBuilder();\n            boolean\
    \ inBraces = false;\n            for (char c : group.toCharArray()) {\n      \
    \          if (inBraces) {\n                    switch (c) {\n               \
    \         case '(':\n                            groupString.append(\"(\");\n\
    \                            break;\n                        case ')':\n     \
    \                       groupString.append(\")\");\n                         \
    \   break;\n                        default:\n                            groupString.append(c);\n\
    \                            break;\n                    }\n                }\
    \ else {\n                    switch (c) {\n                        case '(':\n\
    \                            inBraces = true;\n                            break;\n\
    \                        case ')':\n                            inBraces = false;\n\
    \                            break;\n                        default:\n      \
    \                      groupString.append(c);\n                            break;\n\
    \                    }\n                }\n            }\n            try {\n\
    \                Long result = Long.parseLong(groupString.toString());\n     \
    \           results.add(result);\n            } catch (NumberFormatException nfe)\
    \ {\n                // Do nothing\n            }\n        }\n        return results;\n\
    \    }\n    public static void main(String[] args) {\n    assert(parseNestedParens((\"\
    (()()) ((())) () ((())()())\")).equals((new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))));\n    assert(parseNestedParens((\"() (())\
    \ ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l, (long)2l,\
    \ (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9t2dm4ip.java:16: error: cannot find symbol\n        Matcher matcher\
    \ = Pattern.compile(\"\\\\(([^\\\\(\\\\)]+)\\\\)\").matcher(paren_string);\n \
    \       ^\n  symbol:   class Matcher\n  location: class Problem\n/tmp/tmp9t2dm4ip.java:16:\
    \ error: cannot find symbol\n        Matcher matcher = Pattern.compile(\"\\\\\
    (([^\\\\(\\\\)]+)\\\\)\").matcher(paren_string);\n                          ^\n\
    \  symbol:   variable Pattern\n  location: class Problem\n2 errors\n"
  stdout: ''
  timestamp: 1660011448
- exit_code: -1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        ArrayList<Long> groups = new ArrayList<>();\n     \
    \   Stack<String> stack_1 = new Stack<>();\n        stack_1.push(paren_string);\n\
    \        ArrayList<Long> group = new ArrayList<>();\n        while(stack_1.size()\
    \ > 0) {\n            String stack_1_element = stack_1.pop();\n            String[]\
    \ elements = stack_1_element.split(\" \");\n            for (String element :\
    \ elements) {\n                if(element.equals(\"(\") || element.equals(\")\"\
    )) {\n                    group.add(Long.valueOf(element));\n                }\
    \ else {\n                    stack_1.push(element);\n                }\n    \
    \        }\n            if(group.size() > 0) {\n                groups.add(new\
    \ Long(group.size()));\n                group.clear();\n            }\n      \
    \  }\n        if(group.size() > 0) {\n            groups.add(new Long(group.size()));\n\
    \        }\n        return groups;\n    }\n    public static void main(String[]\
    \ args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((new\
    \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660011453
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l, (long)1l, (long)3l)))\n    public static ArrayList<Long> parseNestedParens(String\
    \ paren_string) {\n        if (paren_string == null || paren_string.isEmpty())\
    \ return null;\n        ArrayList<Long> results = new ArrayList<>();\n       \
    \ // Use stack to parse nested parentheses.\n        Deque<Long> stack = new ArrayDeque<>();\n\
    \        // Use stack to track maximum levels of nested parentheses.\n       \
    \ Deque<Integer> level_stack = new ArrayDeque<>();\n        // Use set to avoid\
    \ adding duplicate parentheses.\n        Set<Long> parsed_parentheses_set = Collections.newSetFromMap(new\
    \ HashMap<>());\n        // Parse the string and add parentheses to the set.\n\
    \        for (char c : paren_string.toCharArray()) {\n            if (c == '(')\
    \ stack.push(1l);\n            else if (c == ')') {\n                if (level_stack.isEmpty()\
    \ || level_stack.isLast()) {\n                    results.add(Long.valueOf(level_stack.peek()));\n\
    \                    level_stack.pop();\n                } else {\n          \
    \          Integer level = level_stack.pop();\n                    if (level_stack.peek()\
    \ < level) level_stack.push(level);\n                }\n            } else if\
    \ ((c == '[') || (c == '{') || (c == '(')) {\n                if (stack.peek()\
    \ >= 1l) {\n                    parsed_parentheses_set.add(stack.peek());\n  \
    \                  stack.pop();\n                } else {\n                  \
    \  stack.pop();\n                }\n            } else {\n                stack.push(c);\n\
    \            }\n        }\n        return results;\n    }\n    public static void\
    \ main(String[] args) {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)1l, (long)3l)))));\n\
    \    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
    \ (long)2l, (long)3l, (long)4l)))));\n    assert(parseNestedParens((\"(()(())((())))\"\
    )).equals((new ArrayList<Long>(Arrays.asList((long)4l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4drkae_a.java:27: error: cannot find symbol\n                if\
    \ (level_stack.isEmpty() || level_stack.isLast()) {\n                        \
    \                                ^\n  symbol:   method isLast()\n  location: variable\
    \ level_stack of type Deque<Integer>\n/tmp/tmp4drkae_a.java:42: error: incompatible\
    \ types: char cannot be converted to Long\n                stack.push(c);\n  \
    \                         ^\nNote: Some messages have been simplified; recompile\
    \ with -Xdiags:verbose to get full output\n2 errors\n"
  stdout: ''
  timestamp: 1660011448
