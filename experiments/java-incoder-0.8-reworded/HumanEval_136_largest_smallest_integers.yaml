name: HumanEval_136_largest_smallest_integers
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Create a function that returns a pair (a, b), where 'a'\
  \ is\n    // the largest of negative integers, and 'b' is the smallest\n    // of\
  \ positive integers in an array array list.\n    // If there is no negative or positive\
  \ integers, return them as null.\n    // Examples:\n    // >>> largestSmallestIntegers((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l,\
  \ (long)7l))))\n    // Pair.with(Optional.of(Optional.empty()), Optional.of(1l))\n\
  \    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList())))\n  \
  \  // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))\n\
  \    // >>> largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l))))\n\
  \    // Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()))\n\
  \    public static Pair<Optional<Long>, Optional<Long>> largestSmallestIntegers(ArrayList<Long>\
  \ lst) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(largestSmallestIntegers((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)4l, (long)1l, (long)3l, (long)5l,\
  \ (long)7l)))).equals(Pair.with(Optional.of(Optional.empty()), Optional.of(1l))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)4l, (long)1l, (long)3l, (long)5l, (long)7l, (long)0l)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(1l))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)3l, (long)2l, (long)4l, (long)5l, (long)6l, (long)-2l)))).equals(Pair.with(-2l,\
  \ 1l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)4l,\
  \ (long)5l, (long)3l, (long)6l, (long)2l, (long)7l, (long)-7l)))).equals(Pair.with(-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)7l,\
  \ (long)3l, (long)8l, (long)4l, (long)9l, (long)2l, (long)5l, (long)-9l)))).equals(Pair.with(-9l,\
  \ 2l)));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList()))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)0l)))).equals(Pair.with(Optional.of(Optional.empty()),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l,\
  \ (long)-3l, (long)-5l, (long)-6l)))).equals(Pair.with(Optional.of(-1l), Optional.of(Optional.empty()))));\n\
  \    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-1l,\
  \ (long)-3l, (long)-5l, (long)-6l, (long)0l)))).equals(Pair.with(Optional.of(-1l),\
  \ Optional.of(Optional.empty()))));\n    assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l,\
  \ (long)-4l, (long)-4l, (long)-3l, (long)1l)))).equals(Pair.with(-3l, 1l)));\n \
  \   assert(largestSmallestIntegers((new ArrayList<Long>(Arrays.asList((long)-6l,\
  \ (long)-4l, (long)-4l, (long)-3l, (long)-100l, (long)1l)))).equals(Pair.with(-3l,\
  \ 1l)));\n    }\n\n}\n"
completions: ["        // If there are no negative or positive integers\n        if(lst.stream().noneMatch(i\
    \ -> i < 0l)) {\n            return Pair.with(Optional.empty(), Optional.of(Optional.empty()));\n\
    \        }\n\n        // Get the largest positive integer\n        Optional<Long>\
    \ maxPosInList = lst.stream().filter(i -> i >= 0l).max(Comparator.naturalOrder());\n\
    \n        // Get the smallest negative integer\n        Optional<Long> minNegInList\
    \ = lst.stream().filter(i -> i < 0l).min(Comparator.naturalOrder());\n\n     \
    \   // Return the pair\n        return Pair.with(maxPosInList, minNegInList);",
  "        if (lst.isEmpty()) return null;\n        ArrayList<Long> copy = lst;\n\
    \        Collections.sort(copy);\n        Pair<Optional<Long>, Optional<Long>>\
    \ largestPositive = largest(copy, 0);\n        Pair<Optional<Long>, Optional<Long>>\
    \ smallestNegative = smallest(copy, 0);\n        if (largestPositive == null)\
    \ largestPositive = Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if (smallestNegative == null) smallestNegative = Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        return Pair.with(largestPositive, smallestNegative);",
  "        int n = lst.size();\n        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        Optional<Long> positive;\n        Optional<Long> negative;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (lst.get(i) < 0) {\n             \
    \   negative = Optional.of(lst.get(i));\n            } else {\n              \
    \  positive = Optional.of(lst.get(i));\n            }\n            res.add(i);\n\
    \        }\n        if (res.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        if (res.size() <= 2) {\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        long largest = lst.stream().max(Comparator.naturalOrder()).get();\n\
    \        long smallest = lst.stream().min(Comparator.naturalOrder()).get();\n\
    \        if (largest < 0) {\n            negative = Optional.of(Optional.empty());\n\
    \        }\n        if (smallest > 0) {\n            positive = Optional.of(Optional.empty());\n\
    \        }\n        return Pair.with(Optional.of(Optional.of(largest)), Optional.of(Optional.of(smallest)));",
  "        // TODO: Complete this function\n        if (lst.isEmpty()) {\n       \
    \     return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        long maxLong = lst.get(0);\n        long minLong = lst.get(0);\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ minLong) {\n                minLong = lst.get(i);\n            } else if (lst.get(i)\
    \ > maxLong) {\n                maxLong = lst.get(i);\n            }\n       \
    \ }\n        return Pair.with(Optional.of(Optional.of(-maxLong)), Optional.of(Optional.of(minLong)));",
  "        Optional<Long> largest = Optional.empty();\n        Optional<Long> smallest\
    \ = Optional.empty();\n        if (lst.isEmpty()) {\n            return new Pair<>(largest,\
    \ smallest);\n        }\n        ArrayList<Long> copy = new ArrayList<>(lst);\n\
    \        Collections.sort(copy);\n        copy.remove(copy.size() - 1);\n    \
    \    for (Long i : copy) {\n            if (i < 0) {\n                largest\
    \ = Optional.of(i);\n            } else if (i > 0) {\n                smallest\
    \ = Optional.of(i);\n            }\n        }\n        return new Pair<>(largest,\
    \ smallest);", "        Optional<Optional<Long>> a = Optional.empty();\n     \
    \   Optional<Optional<Long>> b = Optional.empty();\n        for (Long val : lst)\
    \ {\n            Optional<Long> aInd = Optional.of(val);\n            if (a.isPresent()\
    \ && a.isPresent() && val < a.orElse(null)) {\n                a = Optional.empty();\n\
    \            }\n            if (a.isPresent() && a.isPresent() && val > a.orElse(null))\
    \ {\n                b = Optional.empty();\n            }\n            if (b.isPresent()\
    \ && val < b.orElse(null)) {\n                b = Optional.of(val);\n        \
    \    }\n            if (b.isPresent() && val > b.orElse(null)) {\n           \
    \     a = Optional.of(val);\n            }\n        }\n        return Pair.with(a,\
    \ b);", "        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        ArrayList<Long> positive = new ArrayList<>(lst);\n\
    \        ArrayList<Long> negative = new ArrayList<>(lst.stream().filter(v -> v\
    \ < 0L).collect(Collectors.toList()));\n        if (positive.isEmpty()) {\n  \
    \          return Pair.with(Optional.empty(), Optional.empty());\n        } else\
    \ if (negative.isEmpty()) {\n            return Pair.with(Optional.of(Optional.of(Collections.max(positive))),\
    \ Optional.of(Collections.min(positive)));\n        } else {\n            return\
    \ Pair.with(Optional.of(Collections.max(positive).orElse(0L)), Optional.of(Collections.min(negative).orElse(0L)));\n\
    \        }", "        long max = -Long.MIN_VALUE;\n        long min = 0L;\n  \
    \      for (long i : lst) {\n            if (i < min) {\n                min =\
    \ i;\n            } else if (i > max) {\n                max = i;\n          \
    \  }\n        }\n        return new Pair<>(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  '        return largestSmallestIntegers(lst, 0l, Collections.emptyList(), 0, false);',
  "        if (lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
    \        if (lst.get(0) < Long.MIN_VALUE) return Pair.of(Optional.of(Optional.of(Long.MIN_VALUE)),\
    \ Optional.empty());\n        Optional<Long> minIn = Optional.empty();\n     \
    \   Optional<Long> maxIn = Optional.empty();\n        Optional<Long> minOut =\
    \ Optional.empty();\n        Optional<Long> maxOut = Optional.empty();\n     \
    \   for (Long val : lst) {\n            minIn = minIn.map(a -> a > val ? a : val);\n\
    \            maxIn = maxIn.map(a -> a < val ? a : val);\n            minOut =\
    \ minOut.map(a -> a < val ? a : val);\n            maxOut = maxOut.map(a -> a\
    \ > val ? a : val);\n        }\n        return Pair.of(minIn, maxIn);", "    \
    \    long max = Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n        for\
    \ (Long l : lst) {\n            if (l < min) min = l;\n            if (l > max)\
    \ max = l;\n        }\n        return Pair.withOptional(Optional.of(min), Optional.of(max));",
  "        if (lst.size() < 3) {\n            return Pair.with(Optional.empty(), Optional.empty());\n\
    \        }\n        long min = lst.get(0);\n        long max = lst.get(0);\n \
    \       for (long i : lst) {\n            if (i < 0) {\n                min =\
    \ i;\n            } else if (i > max) {\n                max = i;\n          \
    \  }\n        }\n        return Pair.with(Optional.of(max), Optional.of(min));",
  "        List<Pair<Long, Long>> result = new ArrayList<>();\n        Optional<Long>\
    \ largest = Optional.empty();\n        Optional<Long> smallest = Optional.empty();\n\
    \        for (Long i : lst) {\n            if (i > 0) {\n                result.add(Pair.with(largest,\
    \ smallest));\n                largest = Optional.of(i);\n            } else if\
    \ (i < 0) {\n                smallest = Optional.of(i);\n            }\n     \
    \   }\n        if (result.isEmpty()) {\n            return Pair.with(largest,\
    \ smallest);\n        } else {\n            return Pair.with(largest, smallest);\n\
    \        }", "        int n = lst.size();\n        // Initialize min and max to\
    \ null.\n        Optional<Long> min = Optional.empty();\n        Optional<Long>\
    \ max = Optional.empty();\n        for(int i = 0; i < n; i++) {\n            //\
    \ Skip zero values - they don't have minimum or maximum.\n            if(lst.get(i)\
    \ < 0) continue;\n            \n            // If current element is less than\
    \ min (doesn't exist yet),\n            // set min to current element.\n     \
    \       if(!min.isPresent() || lst.get(i) < min.get()) {\n                min\
    \ = Optional.of(lst.get(i));\n            }\n            \n            // If current\
    \ element is greater than max (doesn't exist yet),\n            // set max to\
    \ current element.\n            if(!max.isPresent() || lst.get(i) > max.get())\
    \ {\n                max = Optional.of(lst.get(i));\n            }\n        }\n\
    \        \n        // If all elements in the list are positive,\n        // return\
    \ a pair with max and min values set.\n        if(lst.size() == n) {\n       \
    \     return Pair.of(min.orElse(null), max.orElse(null));\n        }\n       \
    \ \n        // If all elements in the list are negative,\n        // return a\
    \ pair with max and min values set as null.\n        else if(lst.size() == n)\
    \ {\n            return Pair.of(null, null);\n        }\n        \n        //\
    \ If none of the elements are positive, return a pair with min and max\n     \
    \   // values set as null.\n        else {\n            return Pair.of(null, null);\n\
    \        }", "        ArrayList<Long> negativeIntegersAndPositiveIntegersToReturn\
    \ = new ArrayList<>();\n\n        // Iterate over the array list, find all negative\
    \ numbers and store them.\n        for (long i : lst) {\n            if (i < 0)\
    \ {\n                negativeIntegersAndPositiveIntegersToReturn.add(i);\n   \
    \         }\n        }\n\n        // Iterate over the array list again, find all\
    \ positive numbers and store them.\n        for (long i : lst) {\n           \
    \ if (i >= 0) {\n                negativeIntegersAndPositiveIntegersToReturn.add(i);\n\
    \            }\n        }\n\n        Optional<Long> positiveIntegersAndNegativeIntegers\
    \ = Optional.empty();\n        Optional<Long> negativeIntegersAndPositiveIntegers\
    \ = Optional.empty();\n\n        // If there are both negative and positive numbers\
    \ in the array, return all of them.\n        if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ > 0 && positiveIntegersAndNegativeIntegersToReturn.size() > 0) {\n         \
    \   positiveIntegersAndNegativeIntegers = Optional.of(Math.min(...negativeIntegersAndPositiveIntegersToReturn));\n\
    \            negativeIntegersAndPositiveIntegers = Optional.of(Math.max(...positiveIntegersAndNegativeIntegersToReturn));\n\
    \        }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ > 0 && positiveIntegersAndNegativeIntegersToReturn.size() == 0) {\n        \
    \    positiveIntegersAndNegativeIntegers = Optional.of(Math.max(...negativeIntegersAndPositiveIntegersToReturn));\n\
    \        }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ == 0 && positiveIntegersAndNegativeIntegersToReturn.size() > 0) {\n        \
    \    negativeIntegersAndPositiveIntegers = Optional.of(Math.min(...positiveIntegersAndNegativeIntegersToReturn));\n\
    \        }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ == 0 && positiveIntegersAndNegativeIntegersToReturn.size() == 0) {\n       \
    \     positiveIntegersAndNegativeIntegers = Optional.of(Optional.empty());\n \
    \       }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ == 0 && positiveIntegersAndNegativeIntegersToReturn.size() == 0) {\n       \
    \     positiveIntegersAndNegativeIntegers = Optional.of(Optional.empty());\n \
    \           negativeIntegersAndPositiveIntegers = Optional.of(Optional.empty());\n\
    \        }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ > 0) {\n            positiveIntegersAndNegativeIntegers = Optional.of(Math.max(...positiveIntegersAndNegativeIntegersToReturn));\n\
    \        }\n        else if (negativeIntegersAndPositiveIntegersToReturn.size()\
    \ > 0) {\n            positiveIntegersAndNegativeIntegers = Optional.of(Math.min(...positiveIntegersAndNegativeIntegersTo",
  "        Optional<Long> minInts = Optional.empty();\n        Optional<Long> maxInts\
    \ = Optional.empty();\n        for (Long i: lst) {\n            if (minInts.isPresent()\
    \ && i.compareTo(minInts.get()) < 0) {\n                minInts = Optional.empty();\n\
    \            } else if (maxInts.isPresent() && i.compareTo(maxInts.get()) > 0)\
    \ {\n                maxInts = Optional.empty();\n            } else if (minInts.isPresent()\
    \ && i.compareTo(minInts.get()) == 0) {\n                minInts = Optional.of(i);\n\
    \            } else if (maxInts.isPresent() && i.compareTo(maxInts.get()) == 0)\
    \ {\n                maxInts = Optional.of(i);\n            } else if (minInts.isPresent()\
    \ && i.compareTo(minInts.get()) > 0) {\n                minInts = Optional.of(i);\n\
    \            } else if (maxInts.isPresent() && i.compareTo(maxInts.get()) < 0)\
    \ {\n                maxInts = Optional.of(i);\n            } else if (minInts.isPresent()\
    \ && i.compareTo(minInts.get()) == 0) {\n                minInts = Optional.of(i);\n\
    \            } else if (maxInts.isPresent() && i.compareTo(maxInts.get()) > 0)\
    \ {\n                maxInts = Optional.of(i);\n            } else {\n       \
    \         minInts = Optional.of(i);\n                maxInts = Optional.of(i);\n\
    \            }\n        }\n        if (minInts.isPresent() && maxInts.isPresent())\
    \ {\n            return Pair.of(Optional.of(minInts.get()), Optional.of(maxInts.get()));\n\
    \        } else if (minInts.isPresent() && !maxInts.isPresent()) {\n         \
    \   return Pair.of(Optional.of(minInts.get()), Optional.of(Optional.empty()));\n\
    \        } else if (!minInts.isPresent() && maxInts.isPresent()) {\n         \
    \   return Pair.of(Optional.of(Optional.empty()), Optional.of(maxInts.get()));\n\
    \        } else if (!minInts.isPresent() && !maxInts.isPresent()) {\n        \
    \    return Pair.of(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        return Pair.of(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        ArrayList<Long> l = new ArrayList<>();\n        l.addAll(lst);\n      \
    \  l.sort(Comparator.naturalOrder());\n        int sign = 0;\n        Optional<Long>\
    \ first = Optional.empty();\n        Optional<Long> second = Optional.empty();\n\
    \        for (long i : l) {\n            if (i < 0) {\n                if (sign\
    \ == 0)\n                    first = Optional.of(i);\n                sign = 1;\n\
    \            }\n            else if (i == 0) {\n                if (sign == 0)\n\
    \                    second = Optional.of(i);\n                sign = 1;\n   \
    \         }\n            else {\n                sign = 0;\n            }\n  \
    \      }\n        return Pair.with(first, second);", "        // Create an empty\
    \ Optional\n        Optional<Long> a = Optional.empty();\n        // Create an\
    \ empty Optional\n        Optional<Long> b = Optional.empty();\n\n        // Iterate\
    \ through each element in the list\n        for(int i = 0; i < lst.size(); i++)\
    \ {\n            // If current element is negative, create a and set that to that\
    \ value\n            if(lst.get(i) < 0) {\n                a = Optional.of(lst.get(i));\n\
    \            } else {\n                // If current element is positive, create\
    \ b and set that to that value\n                b = Optional.of(lst.get(i));\n\
    \            }\n        }\n        return Pair.of(a, b);", "        if (lst.isEmpty())\
    \ {\n            return new Pair<>(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        Arrays.sort(lst);\n        int smallestIdx = 0;\n        int\
    \ largestIdx = lst.size() - 1;\n        while (smallestIdx <= largestIdx) {\n\
    \            Optional<Long> aOpt = Optional.of(lst.get(smallestIdx));\n      \
    \      Optional<Long> bOpt = Optional.of(lst.get(largestIdx));\n            if\
    \ (aOpt.isPresent() && bOpt.isPresent()) {\n                return new Pair<>(Optional.of(aOpt),\
    \ Optional.of(bOpt));\n            }\n            smallestIdx++;\n           \
    \ largestIdx--;\n        }\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Collections.sort(lst);\n        Optional<Long>\
    \ result = lst.stream().filter(i -> i >= 0l).findFirst();\n        if (result.isPresent()\
    \ && lst.stream().noneMatch(i -> i < 0l))\n            return Pair.with(result,\
    \ Optional.empty());\n        result = lst.stream().filter(i -> i < 0l).findFirst();\n\
    \        if (result.isPresent() && lst.stream().noneMatch(i -> i >= 0l))\n   \
    \         return Pair.with(Optional.empty(), result);\n        return Pair.with(Optional.empty(),\
    \ Optional.empty());", "        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        ArrayList<Long> neg = new ArrayList<Long>();\n\
    \        ArrayList<Long> pos = new ArrayList<Long>();\n        Long maxA = null;\n\
    \        Long minB = null;\n        for (Long i: lst) {\n            if (i < 0l)\
    \ {\n                neg.add(i);\n            }\n            if (i > 0l) {\n \
    \               pos.add(i);\n            }\n        }\n        maxA = neg.get(neg.size()\
    \ - 1);\n        minB = pos.get(0l);\n        ArrayList<Long> temp = new ArrayList<Long>(lst);\n\
    \        temp.removeAll(pos);\n        temp.removeAll(neg);\n        Collections.sort(temp);\n\
    \        for (Long i: temp) {\n            if (maxA < i) {\n                maxA\
    \ = i;\n            }\n            if (minB > i) {\n                minB = i;\n\
    \            }\n        }\n        return Pair.with(Optional.of(Optional.of(maxA)),\
    \ Optional.of(Optional.of(minB)));", "        // Create an array list where every\
    \ element is either 0 or 1.\n        // If the element is not 0, it's negative,\
    \ and if it is 1, it's positive.\n        ArrayList<Integer> lst2 = (ArrayList<Integer>)\
    \ lst;\n        ArrayList<Integer> lst3 = new ArrayList<Integer>();\n        for\
    \ (Integer i : lst2) {\n            if (i > 0) {\n                lst3.add(1);\n\
    \            } else {\n                lst3.add(0);\n            }\n        }\n\
    \        // Initialize an array list to hold the pairs.\n        ArrayList<Pair<Optional<Long>,\
    \ Optional<Long>>> list = new ArrayList<Pair<Optional<Long>, Optional<Long>>>();\n\
    \        // Create an array of boolean values where every index corresponds to\
    \ a pair of numbers,\n        // and every index with value true means that the\
    \ corresponding element is in the pair.\n        boolean[] bools = new boolean[lst3.size()];\n\
    \        // While we haven't found any negative or positive numbers in the list,\n\
    \        // and while we have not yet found a negative number that is the maximum\n\
    \        // of the negative numbers in the list, we keep searching for a pair\
    \ that\n        // contains all the negative numbers in the list. The search continues\
    \ until\n        // we find one that contains a positive number.\n        while\
    \ (lst3.isEmpty() == false && lst2.isEmpty() == false) {\n            // Initialize\
    \ an array list to hold the current pair of numbers in the pair,\n           \
    \ // then add the current pair at the end of the current pair if it's negative.\n\
    \            ArrayList<Pair<Optional<Long>, Optional<Long>>> currentPair = new\
    \ ArrayList<Pair<Optional<Long>, Optional<Long>>>();\n            Pair<Optional<Long>,\
    \ Optional<Long>> currentPairOfNums = new Pair<Optional<Long>, Optional<Long>>();\n\
    \            // While we haven't found any negative number in the list of numbers.\n\
    \            while (lst3.isEmpty() == false) {\n                // If the current\
    \ number in the list of numbers is not positive,\n                // add it to\
    \ the list of numbers that are negative.\n                if (lst3.get(0) <= 0)\
    \ {\n                    lst2.add(0, lst3.get(0));\n                    lst3.remove(0);\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            // While we haven't found any negative number in the\
    \ list of numbers.\n            while (lst2.isEmpty() == false) {\n          \
    \      // If the current number in the list of numbers is not positive,\n    \
    \            // add it to the list of numbers that are positive.\n           \
    \     if (lst2.get(0) > 0) {\n                    lst3.add(0, lst2.get(0));\n\
    \                    lst2.remove(0);\n                } else {\n             \
    \       break;\n                }\n            }\n            // While the list\
    \ has elements and at least one of the elements is positive,\n            // add\
    \ the current pair to the list of pairs.\n            while (lst3.size() > 0 ||\
    \ lst2.size() > 0) {\n                // If the boolean at that position is false,\
    \ that means that we\n                // haven't found the ", "        Optional<Long>\
    \ maxVal = Optional.empty();\n        Optional<Long> minVal = Optional.empty();\n\
    \        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ 0) {\n                maxVal = Optional.of(Optional.of(lst.get(i)));\n     \
    \       }\n            if (lst.get(i) > 0) {\n                minVal = Optional.of(Optional.of(lst.get(i)));\n\
    \            }\n        }\n        if (maxVal.isPresent() && minVal.isPresent())\
    \ {\n            return Pair.with(maxVal, minVal);\n        }\n        return\
    \ Pair.with(maxVal, minVal);", "        int n = lst.size();\n        long largest\
    \ = Long.MIN_VALUE;\n        long smallest = Long.MAX_VALUE;\n        for (int\
    \ i = 0; i < n; i++) {\n            long x = lst.get(i);\n            if (x <\
    \ 0) {\n                if (largest < x) { largest = x; }\n            }\n   \
    \         if (x > 0) {\n                if (smallest > x) { smallest = x; }\n\
    \            }\n        }\n        if (largest == Long.MIN_VALUE) {\n        \
    \    largest = Long.MIN_VALUE;\n        }\n        if (smallest == Long.MAX_VALUE)\
    \ {\n            smallest = Long.MAX_VALUE;\n        }\n        return Pair.with(Optional.of(Optional.of(largest)),\
    \ Optional.of(smallest));", "        List<Long> arr = new ArrayList<>();\n   \
    \     for (int i = 0; i < lst.size(); i++) {\n            arr.add((int) lst.get(i));\n\
    \        }\n        Optional<Long> a = Optional.empty();\n        Optional<Long>\
    \ b = Optional.empty();\n        List<Long> posArr = new ArrayList<>();\n    \
    \    List<Long> negArr = new ArrayList<>();\n        List<Long> a2 = new ArrayList<>();\n\
    \        List<Long> b2 = new ArrayList<>();\n        for (Long val : arr) {\n\
    \            if (val < 0) {\n                negArr.add(val);\n            } else\
    \ {\n                posArr.add(val);\n            }\n        }\n        if (posArr.isEmpty()\
    \ && negArr.isEmpty()) {\n            a = Optional.of(Optional.empty());\n   \
    \         b = Optional.of(Optional.empty());\n        } else {\n            if\
    \ (posArr.isEmpty() && !negArr.isEmpty()) {\n                a2 = negArr;\n  \
    \              b = Optional.of(Optional.of(negArr.size()));\n            } else\
    \ {\n                a2 = posArr;\n                b = Optional.of(Optional.of(posArr.size()));\n\
    \            }\n        }\n        return new Pair<>(Optional.of(a), b);", " \
    \       // Your code here\n        int minIndex = Collections.min(lst.stream().mapToInt(Integer::intValue)).intValue();\n\
    \        int maxIndex = Collections.max(lst.stream().mapToInt(Integer::intValue)).intValue();\n\
    \        Optional<Long> minO = lst.stream().filter(n -> n > 0).findFirst();\n\
    \        Optional<Long> maxO = lst.stream().filter(n -> n < 0).findFirst();\n\
    \        if (minIndex < maxIndex) {\n            return Pair.with(minO, maxO);\n\
    \        } else {\n            return Pair.with(maxO, minO);\n        }", "  \
    \      Optional<Long> a = Optional.empty();\n        Optional<Long> b = Optional.empty();\n\
    \        if (lst == null) {\n            return Pair.with(a, b);\n        }\n\
    \        Optional<Long> firstOptional = lst.stream().findFirst();\n        if\
    \ (!firstOptional.isPresent()) {\n            return Pair.with(a, b);\n      \
    \  }\n        if (firstOptional.get() < 0) {\n            a = firstOptional;\n\
    \        } else {\n            b = firstOptional;\n        }\n        return Pair.with(a,\
    \ b);", "        long min = Long.MAX_VALUE;\n        long max = Long.MIN_VALUE;\n\
    \        for (Long val : lst) {\n            min = Math.min(val, min);\n     \
    \       max = Math.max(val, max);\n        }\n        return Pair.with(Optional.of(Optional.of(min)),\
    \ Optional.of(Optional.of(max)));", "        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        for (Long i : lst) {\n\
    \            if (i.compareTo(Long.MIN_VALUE) > 0) {\n                a = Optional.of(i);\n\
    \                break;\n            }\n            if (i.compareTo(Long.MIN_VALUE)\
    \ < 0) {\n                b = Optional.of(i);\n                break;\n      \
    \      }\n        }\n        return Pair.with(a, b);", "        Comparator<Long>\
    \ cmp = Comparator.comparing(i -> -lst.get(i));\n        int max = 0;\n      \
    \  for (int i = 0; i < lst.size(); i++) {\n            max = lst.get(i).compareTo(cmp.thenComparing(cmp).get(i));\n\
    \        }\n        return new Pair<>(Optional.of(lst.get(max)), Optional.of(cmp.thenComparing(cmp).get(max)));",
  "        Integer smallestPositive = lst.stream().min(Comparator.naturalOrder()).orElse(null);\n\
    \        Integer smallestNegative = lst.stream().max(Comparator.naturalOrder()).orElse(null);\n\
    \        Optional<Integer> minOption = Optional.ofNullable(smallestPositive);\n\
    \        Optional<Integer> maxOption = Optional.ofNullable(smallestNegative);\n\
    \        if(smallestNegative > smallestPositive) {\n            minOption = Optional.of(smallestNegative);\n\
    \            maxOption = Optional.of(smallestPositive);\n        }\n        return\
    \ Pair.of(minOption, maxOption);", "        if(lst == null || lst.isEmpty()){\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        Map<Long,Long> positiveToNegative = lst.stream().collect(Collectors.toMap(Long::longValue,\n\
    \                Long::min));\n        Map<Long,Long> negativeToPositive = lst.stream().collect(Collectors.toMap(Long::min),\n\
    \                Long::longValue);\n        Pair<Optional<Long>, Optional<Long>>\
    \ pair = Pair.with(\n                Optional.of(Optional.of(positiveToNegative.containsKey(0l)\
    \ ? positiveToNegative.get(0l) : 0l)),\n                Optional.of(negativeToPositive.containsKey(0l)\
    \ ? negativeToPositive.get(0l) : 0l));\n        return pair;", "        if(lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        Optional<Long> first = lst.get(0);\n        Optional<Long>\
    \ second = lst.get(0);\n\n        for(int i = 1; i < lst.size(); i++) {\n    \
    \        Long currentValue = lst.get(i);\n            if(currentValue < 0) {\n\
    \                first = Optional.of(currentValue);\n            } else if(currentValue\
    \ > 0) {\n                second = Optional.of(currentValue);\n            } else\
    \ {\n                first = Optional.empty();\n                second = Optional.empty();\n\
    \            }\n        }\n\n        return Pair.with(first, second);", "    \
    \    Comparator<Long> comparator = Comparator.comparingLong(n -> Math.abs(n));\n\
    \        Optional<Optional<Long>> mostNegative = Optional.empty();\n        Optional<Optional<Long>>\
    \ mostPositive = Optional.empty();\n        Optional<Optional<Long>> leastNegative\
    \ = Optional.empty();\n        Optional<Optional<Long>> leastPositive = Optional.empty();\n\
    \        for (Long n : lst) {\n            Optional<Optional<Long>> currentOptional\
    \ = Optional.of(Optional.empty());\n            if (n < 0l) {\n              \
    \  mostNegative = currentOptional;\n            }\n            if (n > 0l) {\n\
    \                mostPositive = currentOptional;\n            }\n            if\
    \ (n < 0l && n > 0l) {\n                leastNegative = currentOptional;\n   \
    \         }\n            if (n < 0l || n > 0l) {\n                leastPositive\
    \ = currentOptional;\n            }\n        }\n        if (mostNegative.isPresent())\
    \ {\n            mostNegative = mostNegative.flatMap(Optional::of).orElse(mostNegative);\n\
    \        }\n        if (mostPositive.isPresent()) {\n            mostPositive\
    \ = mostPositive.flatMap(Optional::of).orElse(mostPositive);\n        }\n    \
    \    if (leastNegative.isPresent()) {\n            leastNegative = leastNegative.flatMap(Optional::of).orElse(leastNegative);\n\
    \        }\n        if (leastPositive.isPresent()) {\n            leastPositive\
    \ = leastPositive.flatMap(Optional::of).orElse(leastPositive);\n        }\n  \
    \      return Pair.with(mostNegative, mostPositive).andThen(Pair.with(leastNegative,\
    \ leastPositive));", "        Optional<Long> smallest = null;\n        Optional<Long>\
    \ largest = null;\n        for (Long i : lst) {\n            if (smallest == null\
    \ || i > smallest.get()) {\n                smallest = Optional.of(i);\n     \
    \       }\n            if (largest == null || i < largest.get()) {\n         \
    \       largest = Optional.of(i);\n            }\n        }\n        return Pair.with(smallest,\
    \ largest);", "        long max = Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            min = Math.min(min, i);\n         \
    \   max = Math.max(max, i);\n        }\n        return new Pair<>(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(min)));", "        // Complete this function\n     \
    \   Optional<Long> min = null;\n        Optional<Long> max = null;\n        for(Long\
    \ l : lst) {\n            if (min == null || l < min.orElse(-1l)) {\n        \
    \        min = Optional.of(l);\n            }\n            if (max == null ||\
    \ l > max.orElse(0l)) {\n                max = Optional.of(l);\n            }\n\
    \        }\n        if (min != null && max != null) {\n            return Pair.of(min,max);\n\
    \        }\n        return Pair.of(Optional.empty(), Optional.empty());", "  \
    \      int count = 0;\n        long max = Integer.MIN_VALUE;\n        long min\
    \ = Long.MAX_VALUE;\n        long sum = 0;\n        Optional<Long> max = Optional.empty();\n\
    \        Optional<Long> min = Optional.empty();\n        for (Long i : lst) {\n\
    \            if (i < 0) {\n                count++;\n                if (max <\
    \ Integer.MIN_VALUE) {\n                    max = Integer.MIN_VALUE;\n       \
    \         }\n                max = i;\n            } else if (i >= 0) {\n    \
    \            count++;\n                if (min > Long.MAX_VALUE) {\n         \
    \           min = Long.MAX_VALUE;\n                }\n                min = i;\n\
    \            }\n            sum += i;\n        }\n        if (count == 0) {\n\
    \            return Pair.with(max, min);\n        }\n        if (sum < 0) {\n\
    \            return Pair.with(max, min);\n        }\n        if (sum > 0) {\n\
    \            return Pair.with(max, min);\n        }\n        if (max == Integer.MIN_VALUE)\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        if (min == Long.MAX_VALUE) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        if (min == Integer.MIN_VALUE\
    \ && max == Long.MAX_VALUE) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        return Pair.with(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(min)));", "        Set<Long> positive = new HashSet<>();\n\
    \        Set<Long> negative = new HashSet<>();\n        for (long value : lst)\
    \ {\n            if (value > 0) {\n                positive.add(value);\n    \
    \        } else {\n                negative.add(value);\n            }\n     \
    \   }\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        ArrayList<Long> lstCopy = new ArrayList<>(lst);\n        Collections.sort(lstCopy);\n\
    \        Long max = lstCopy.get(0);\n        Long min = lstCopy.get(lstCopy.size()\
    \ - 1);\n        if (lstCopy.size() == 1) {\n            return Pair.with(Optional.of(max),\
    \ Optional.of(min));\n        }\n        List<Long> neg = new ArrayList<>();\n\
    \        List<Long> pos = new ArrayList<>();\n        for (int i = 0; i < lstCopy.size();\
    \ i++) {\n            if (lstCopy.get(i) < 0) {\n                neg.add(lstCopy.get(i));\n\
    \            } else {\n                pos.add(lstCopy.get(i));\n            }\n\
    \        }\n        if (neg.size() > 0) {\n            max = neg.get(neg.size()\
    \ - 1);\n            neg.remove(neg.size() - 1);\n        } else if (neg.size()\
    \ == 0 && pos.size() > 0) {\n            max = pos.get(0);\n            pos.remove(0);\n\
    \        }\n        if (pos.size() > 0) {\n            min = pos.get(0);\n   \
    \         pos.remove(0);\n        } else if (pos.size() == 0 && neg.size() > 0)\
    \ {\n            min = neg.get(0);\n            neg.remove(0);\n        }\n  \
    \      if (neg.size() > 0 && pos.size() > 0) {\n            if (max < neg.get(neg.size()\
    \ - 1)) {\n                max = neg.get(neg.size() - 1);\n                neg.remove(neg.size()\
    \ - 1);\n            }\n            max = max(max, pos.get(pos.size() - 1));\n\
    \            pos.remove(pos.size() - 1);\n        } else if (neg.size() == 0 &&\
    \ pos.size() > 0) {\n            max = pos.get(0);\n            pos.remove(0);\n\
    \            min = max(min, pos.get(pos.size() - 1));\n            pos.remove(pos.size()\
    \ - 1);\n        } else if (pos.size() == 0 && neg.size() > 0) {\n           \
    \ max = neg.get(0);\n            neg.remove(0);\n            min = max(min, neg.get(neg.size()\
    \ - 1));\n            neg.remove(neg.size() - 1);\n        }\n        return Pair.with(Optional.of(max),\
    \ Optional.of(min));", "        long largest = 0;\n        long smallest = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            if (i < 0) {\n                if (largest\
    \ < i) {\n                    largest = i;\n                }\n            } else\
    \ if (i > 0 && smallest > i) {\n                smallest = i;\n            }\n\
    \        }\n        return new Pair<>(Optional.of(Optional.of(largest)), Optional.of(Optional.of(smallest)));",
  "        if (lst.isEmpty())\n            return new Pair<>(Optional.empty(), Optional.empty());\n\
    \        long largest = Long.MIN_VALUE;\n        long smallest = Long.MAX_VALUE;\n\
    \        for (int i = 0; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ 0)\n                largest = Math.max(largest, lst.get(i));\n            else\n\
    \                smallest = Math.min(smallest, lst.get(i));\n        }\n     \
    \   return new Pair<>(Optional.of(Optional.of(largest)), Optional.of(Optional.of(smallest)));",
  "        Optional<Long> largest = Optional.empty();\n        Optional<Long> smallest\
    \ = Optional.empty();\n        for (Long i : lst) {\n            if (i.signum()\
    \ < 0) {\n                if (!largest.isPresent()) {\n                    largest\
    \ = Optional.of(i);\n                } else if (largest.get() > i) {\n       \
    \             largest = Optional.of(i);\n                }\n            } else\
    \ {\n                if (!smallest.isPresent()) {\n                    smallest\
    \ = Optional.of(i);\n                } else if (smallest.get() < i) {\n      \
    \              smallest = Optional.of(i);\n                }\n            }\n\
    \        }\n        return Pair.with(largest, smallest);", "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        Comparator<Long> cmp = Comparator.comparingLong(Long::longValue);\n\
    \        Optional<Long> largest = Optional.empty();\n        Optional<Long> smallest\
    \ = Optional.empty();\n        for (long i : lst) {\n            if (cmp.compare(i,\
    \ 0) < 0) {\n                if (largest.isPresent()) {\n                    Optional<Long>\
    \ tmp = Optional.of(largest.get());\n                    largest = Optional.empty();\n\
    \                    smallest = Optional.of(i);\n                    if (tmp.orElse(Optional.empty())\
    \ > Optional.of(i)) {\n                        smallest = tmp;\n             \
    \       }\n                } else {\n                    largest = Optional.of(i);\n\
    \                    smallest = Optional.empty();\n                }\n       \
    \     }\n            if (cmp.compare(i, 0) > 0) {\n                if (smallest.isPresent())\
    \ {\n                    Optional<Long> tmp = Optional.of(smallest.get());\n \
    \                   smallest = Optional.empty();\n                    largest\
    \ = Optional.of(i);\n                    if (tmp.orElse(Optional.empty()) < Optional.of(i))\
    \ {\n                        largest = tmp;\n                    }\n         \
    \       } else {\n                    largest = Optional.of(i);\n            \
    \        smallest = Optional.empty();\n                }\n            }\n    \
    \    }\n        if (smallest.isPresent() && largest.isPresent()) {\n         \
    \   return Pair.with(smallest, largest);\n        }\n        if (smallest.isPresent())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), smallest);\n\
    \        }\n        if (largest.isPresent()) {\n            return Pair.with(largest,\
    \ Optional.of(Optional.empty()));\n        }\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Set<Long> s = new HashSet<Long>();\n\
    \        for (Long l : lst) {\n            if (s.contains(l)) {\n            \
    \    continue;\n            }\n            else {\n                s.add(l);\n\
    \            }\n        }\n\n        Optional<Long> a = Optional.empty();\n  \
    \      Optional<Long> b = Optional.empty();\n        for (Long l : lst) {\n  \
    \          long min = l;\n            long max = l;\n            if (s.contains(l))\
    \ {\n                max = l;\n            }\n            else {\n           \
    \     if (max < min) {\n                    max = l;\n                }\n    \
    \        }\n            a.ifPresent(a -> {\n                if (a > max) {\n \
    \                   max = a;\n                }\n            });\n           \
    \ b.ifPresent(b -> {\n                if (b < min) {\n                    min\
    \ = b;\n                }\n            });\n        }\n        return Pair.with(a,\
    \ b);", "        return lst.stream().sorted().reduce(\n                (left,\
    \ right) -> {\n                    if (left.isPresent() && right.isPresent())\
    \ {\n                        if (left.get() < right.get()) {\n               \
    \             return left;\n                        } else {\n               \
    \             return right;\n                        }\n                    }\
    \ else if (left.isPresent()) {\n                        return left;\n       \
    \             } else if (right.isPresent()) {\n                        return\
    \ right;\n                    } else {\n                        return null;\n\
    \                    }\n                });", "        List<Long> positive = new\
    \ ArrayList<Long>();\n        List<Long> negative = new ArrayList<Long>();\n\n\
    \        Collections.sort(lst);\n\n        long max = lst.get(0);\n        long\
    \ min = lst.get(0);\n\n        for (long i : lst) {\n            if (i < 0) {\n\
    \                negative.add(i);\n            } else {\n                positive.add(i);\n\
    \            }\n            max = Math.max(max, i);\n            min = Math.min(min,\
    \ i);\n        }\n\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        ArrayList<Long> lst2 = new ArrayList<>();\n        boolean flag = true;\n\
    \        for (Long i : lst) {\n            if (i < 0) flag = false;\n        \
    \    lst2.add(i);\n        }\n        if (flag) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long max = lst2.get(0);\n\
    \        long min = lst2.get(0);\n        for (int i = 1; i < lst2.size(); i++)\
    \ {\n            if (lst2.get(i) > max) {\n                max = lst2.get(i);\n\
    \            }\n            if (lst2.get(i) < min) {\n                min = lst2.get(i);\n\
    \            }\n        }\n        return Pair.with(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(min)));", "        Optional<Long> minValue = Optional.empty();\n\
    \        Optional<Long> maxValue = Optional.empty();\n        for (Long l : lst)\
    \ {\n            if (l<0) {\n                minValue = Optional.of(l);\n    \
    \        }\n            else if (l>0) {\n                maxValue = Optional.of(l);\n\
    \            }\n        }\n        if (minValue.isPresent()) {\n            if\
    \ (maxValue.isPresent()) {\n                return Pair.with(minValue, maxValue);\n\
    \            }\n            return Pair.with(minValue, Optional.empty());\n  \
    \      }\n        if (maxValue.isPresent()) {\n            return Pair.with(Optional.empty(),\
    \ maxValue);\n        }\n        return Pair.with(Optional.empty(), Optional.empty());",
  "        List<Long> list = new ArrayList<>();\n        for (long i : lst) {\n  \
    \          if (i >= 0) {\n                list.add(i);\n            }\n      \
    \  }\n        if (list.size() == 0) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n\n        Collections.sort(list);\n        Long\
    \ firstNegative = list.get(0);\n        Long firstPositive = list.get(list.size()\
    \ - 1);\n        if (firstNegative > firstPositive) {\n            return Pair.with(Optional.of(firstNegative),\
    \ Optional.of(firstPositive));\n        }\n        return Pair.with(Optional.of(firstPositive),\
    \ Optional.of(firstNegative));", "        Optional<Long> maxNegative = Optional.empty();\n\
    \        Optional<Long> minPositive = Optional.empty();\n        if(lst.stream().noneMatch(num\
    \ -> num < 0L)) {\n            Optional<Long> max = lst.stream().max(Long::compareTo);\n\
    \            maxNegative = Optional.of(max);\n        }\n        if(lst.stream().noneMatch(num\
    \ -> num > 0L)) {\n            Optional<Long> min = lst.stream().min(Long::compareTo);\n\
    \            minPositive = Optional.of(min);\n        }\n        if(maxNegative.isPresent()\
    \ && minPositive.isPresent()) {\n            return Pair.with(maxNegative, minPositive);\n\
    \        }\n        if(maxNegative.isPresent()) {\n            return Pair.with(maxNegative,\
    \ Optional.of(Optional.empty()));\n        }\n        if(minPositive.isPresent())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), minPositive);\n\
    \        }\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        boolean anyNegativeOrPositive = false;\n        for (long num : lst) {\n\
    \            anyNegativeOrPositive = num >= 0l && anyNegativeOrPositive;\n   \
    \     }\n        if (anyNegativeOrPositive) {\n            int smallestNumberIndex\
    \ = lst.indexOf(Collections.min(lst));\n            return new Pair<>(Optional.of(Optional.of(lst.get(smallestNumberIndex))),\
    \ Optional.of(Optional.of(lst.get(smallestNumberIndex))));\n        } else {\n\
    \            return new Pair<>(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }", "        Set<Long> positive = new HashSet<>();\n        Set<Long>\
    \ negative = new HashSet<>();\n        for (Long i : lst) {\n            if(i>0)\
    \ positive.add(i);\n            else negative.add(i);\n        }\n        if(positive.isEmpty())\
    \ return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if(negative.isEmpty()) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        if(positive.isEmpty() || negative.isEmpty())\
    \ return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Optional<Long> a = Optional.of(Collections.max(positive));\n        Optional<Long>\
    \ b = Optional.of(Collections.min(negative));\n        return Pair.with(a, Optional.of(b));",
  "        Optional<Long> min = Optional.empty();\n        Optional<Long> max = Optional.empty();\n\
    \        for (long i : lst) {\n            min = min.orElse(i.longValue() < min.orElse(0)\
    \ ? i : min);\n            max = max.orElse(i.longValue() > max.orElse(0) ? i\
    \ : max);\n        }\n        return Pair.of(min.map(Optional::of).orElse(Optional.empty()),\
    \ max.map(Optional::of).orElse(Optional.empty()));", "        Optional<Long> a\
    \ = Optional.empty();\n        Optional<Long> b = Optional.empty();\n        \n\
    \        if (lst.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        \n        for(Long x: lst)\
    \ {\n            long y = Math.abs(x); // y = -x\n            if (y < 0) {\n \
    \               if (a.isPresent() == false) {\n                    a = Optional.of(x);\n\
    \                }\n            } else {\n                if (b.isPresent() ==\
    \ false) {\n                    b = Optional.of(x);\n                }\n     \
    \       }\n        }\n        \n        return Pair.with(a, b);", "        if\
    \ (lst.isEmpty()) return null;\n        Set<Long> s = new TreeSet<>(lst);\n  \
    \      Optional<Long> max = Optional.of(Optional.of(Long.MIN_VALUE));\n      \
    \  for (Long i : s) {\n            Optional<Long> curr = Optional.of(i);\n   \
    \         Optional<Long> prev = null;\n            for (Long j : s) {\n      \
    \          Optional<Long> next = Optional.of(j);\n                if (prev ==\
    \ null || next.isPresent() && prev.get() < next.get()) {\n                   \
    \ prev = next;\n                }\n            }\n            if (curr.isPresent()\
    \ && prev.isPresent() && curr.orElse(prev) < prev.orElse(curr)) {\n          \
    \      max = Optional.of(curr);\n            }\n        }\n        return Pair.with(max,\
    \ s.isEmpty() ? Optional.of(Optional.empty()) : Optional.of(s.first()));", " \
    \       Optional<Long> smallest = Optional.empty();\n        Optional<Long> largest\
    \ = Optional.empty();\n        for(Long i : lst) {\n            if(i.longValue()\
    \ > 0) {\n                smallest = Optional.of(i.longValue());\n           \
    \ } else {\n                largest = Optional.of(i.longValue());\n          \
    \  }\n        }\n        if(smallest.isPresent() && largest.isPresent()) {\n \
    \           return Pair.of(smallest, largest);\n        }\n        return Pair.of(Optional.empty(),\
    \ Optional.empty());", '        return lst.stream().max(Comparator.naturalOrder()).map(l
    -> Pair.with(Optional.of(Optional.of(l)), Optional.of(l))).orElse(Pair.with(Optional.of(Optional.empty()),
    Optional.of(Optional.empty())));', "        if (lst.size() > 0) {\n          \
    \  Optional<Long> maxOpt = null;\n            Optional<Long> minOpt = null;\n\
    \            for (int i = 0; i < lst.size(); i++) {\n                Long n =\
    \ lst.get(i);\n                if (maxOpt == null || n < 0 && n < minOpt.get())\
    \ {\n                    maxOpt = Optional.of(n);\n                } else if (n\
    \ < 0 && n > minOpt.get()) {\n                    minOpt = Optional.of(n);\n \
    \               }\n            }\n            return Pair.with(maxOpt, minOpt);\n\
    \        } else {\n            return Pair.with(Optional.empty(), Optional.empty());\n\
    \        }", "        long min = -10000l; long max = 10000l;\n        Optional<Long>\
    \ smallest = Optional.empty(); Optional<Long> largest = Optional.empty();\n\n\
    \        for (int i = 0; i < lst.size(); ++i) {\n            if (lst.get(i) <\
    \ min) {\n                min = lst.get(i);\n            } else if (lst.get(i)\
    \ > max) {\n                max = lst.get(i);\n            }\n        }\n    \
    \    \n        if (min < 0) { smallest = Optional.of(Optional.empty()); } else\
    \ { smallest = Optional.of(Optional.of(min)); }\n        if (max < 0) { largest\
    \ = Optional.of(Optional.empty()); } else { largest = Optional.of(Optional.of(max));\
    \ }\n        return Pair.with(smallest, largest);", "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        long max = 0;\n        long min = 0;\n        for (long num\
    \ : lst) {\n            max = Math.max(max, num);\n            min = Math.min(min,\
    \ num);\n        }\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        Optional<Long> max = Collections.max(lst);\n        Optional<Long> min\
    \ = Collections.min(lst);\n        return Pair.with(max, min);", "        Set<Long>\
    \ set = new HashSet<>();\n        ArrayList<Long> noNegative = new ArrayList<>();\n\
    \        ArrayList<Long> noPositive = new ArrayList<>();\n        for (Long i\
    \ : lst) {\n            if (i < 0) noNegative.add(i);\n            else if (i\
    \ >= 0) noPositive.add(i);\n            else set.add(i);\n        }\n        if\
    \ (noNegative.isEmpty()) return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if (noPositive.isEmpty()) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        if (noNegative.size() > noPositive.size())\
    \ {\n            Pair<Optional<Long>, Optional<Long>> ls = new Pair<>(Optional.of(Optional.of((long)\
    \ Collections.min(set))),\n                    Optional.of(Optional.of((long)\
    \ Collections.max(set))));\n            return ls;\n        } else {\n       \
    \     Pair<Optional<Long>, Optional<Long>> ps = new Pair<>(Optional.of(Optional.of((long)\
    \ Collections.min(set))),\n                    Optional.of(Optional.of((long)\
    \ Collections.max(set))));\n            return ps;\n        }", "        int n\
    \ = lst.size();\n        Pair<Optional<Long>, Optional<Long>> ret = null;\n  \
    \      if(n < 2) return ret;\n        for(long a : lst) {\n            for(long\
    \ b : lst) {\n                if((a < 0 && b > 0) || (a > 0 && b < 0)) {\n   \
    \                 if(ret == null) ret = Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n                    if(ret.first.map(Optional::of).orElse(Optional.empty())\
    \ < a)\n                        ret.first = Optional.of(a);\n                \
    \    if(ret.second.map(Optional::of).orElse(Optional.empty()) > b)\n         \
    \               ret.second = Optional.of(b);\n                }\n            }\n\
    \        }\n        return ret;", "        List<Long> sortedList = lst.stream().sorted().collect(toList());\n\
    \n        Optional<Long> smallestInteger = Optional.empty();\n        Optional<Long>\
    \ largestInteger = Optional.empty();\n\n        Long firstElem = sortedList.get(0);\n\
    \        if (firstElem < 0) {\n            smallestInteger = Optional.of(firstElem);\n\
    \            largestInteger = Optional.of(firstElem);\n        } else {\n    \
    \        for (int i = 1; i < sortedList.size(); i++) {\n                Long curr\
    \ = sortedList.get(i);\n                if (curr < 0) {\n                    smallestInteger\
    \ = Optional.of(curr);\n                    break;\n                } else if\
    \ (curr > 0) {\n                    largestInteger = Optional.of(curr);\n    \
    \                break;\n                }\n            }\n        }\n\n     \
    \   return Pair.with(smallestInteger, largestInteger);", "        // Find the\
    \ maximum and minimum numbers in the list.\n        long largest = max(lst);\n\
    \        long smallest = min(lst);\n\n        // If there is no negative or positive\
    \ integers, return them as nulls.\n        if (largest < 0 || smallest < 0) {\n\
    \            return Pair.with(Optional.empty(), Optional.empty());\n        }\n\
    \n        // Otherwise return them as (largest, smallest).\n        return Pair.with(Optional.of(Optional.of(largest)),\
    \ Optional.of(Optional.of(smallest)));", "        Optional<Optional<Long>> a =\
    \ Optional.empty();\n        Optional<Optional<Long>> b = Optional.empty();\n\
    \        boolean flag = false;\n        for (long x : lst) {\n            Optional<Long>\
    \ y = Optional.ofNullable(x);\n            if (!flag) {\n                a = y;\n\
    \                flag = true;\n            }\n            else if (y instanceof\
    \ Long && y > a) {\n                a = y;\n            }\n            else if\
    \ (y instanceof Long && y < b) {\n                b = y;\n            }\n    \
    \    }\n        return new Pair<>(a, b);", "        List<Long> negInts = lst.stream()\n\
    \                .filter(i -> i < 0l)\n                .collect(toList());\n \
    \       List<Long> posInts = lst.stream()\n                .filter(i -> i >= 0l)\n\
    \                .collect(toList());\n        if (negInts.size() > posInts.size())\
    \ {\n            return Pair.with(Optional.of(negInts.get(0l)), Optional.of(posInts.get(0l)));\n\
    \        }\n        return Pair.with(Optional.of(posInts.get(0l)), Optional.of(negInts.get(0l)));",
  "        Optional<Long> min = Optional.empty();\n        Optional<Long> max = Optional.empty();\n\
    \        for (Long v : lst) {\n            if (v < 0) {\n                min =\
    \ Optional.of(v);\n            } else if (v > 0) {\n                max = Optional.of(v);\n\
    \            }\n        }\n        return Pair.with(min, max);", "        long\
    \ largest = Collections.max(lst);\n        long smallest = Collections.min(lst);\n\
    \        return Pair.with(Optional.of(Optional.of(largest)), Optional.of(Optional.of(smallest)));",
  "        // We want to go through the array\n        // and for each element, see\
    \ if it is a positive integer\n        // or negative. If it is negative, return\
    \ Optional.empty()\n        // and if it is a positive integer, return the largest\n\
    \        // of all the negative and positive integers and also the\n        //\
    \ smallest positive integer.\n        // We also want to keep track of which positive\
    \ and negative\n        // integers we encounter, since if we encounter a positive\n\
    \        // integer again, we can just return that instead.\n        // For any\
    \ non-negative or non-positive integer, we check\n        // if we have seen it\
    \ before. If we have seen it before, we\n        // simply return the last two\
    \ seen integers and the largest\n        // positive integer.\n\n        // For\
    \ each element in the array...\n        for (Long element : lst) {\n         \
    \   // If this element is a negative integer...\n            if (element < 0l)\
    \ {\n                // If we have seen it before, return the last two seen\n\
    \                // integers and the largest positive integer\n              \
    \  if (seenPositiveIntegers.get(element).isPresent()) {\n                    return\
    \ Pair.with(seenPositiveIntegers.get(element), Optional.of(Optional.empty()));\n\
    \                }\n                // Otherwise, add it to a map of seen positive\
    \ integers\n                // and return the largest positive integer if we encounter\
    \ it\n                // again later\n                seenPositiveIntegers.put(element,\
    \ Optional.of(Optional.empty()));\n            } else {\n                // If\
    \ we have seen it before, return it\n                if (seenNegativeIntegers.get(element).isPresent())\
    \ {\n                    return Pair.with(seenNegativeIntegers.get(element), Optional.of(Optional.empty()));\n\
    \                }\n                // Otherwise, add it to a map of seen negative\
    \ integers\n                // and return the smallest negative integer if we\
    \ encounter it\n                // again later\n                seenNegativeIntegers.put(element,\
    \ Optional.of(Optional.empty()));\n            }\n        }\n\n        // Return\
    \ null if there are no negative or positive integers\n        if (seenPositiveIntegers.isEmpty()\
    \ && seenNegativeIntegers.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n\n        // For any positive integer\
    \ (not negative), return the largest\n        // of all the negative and positive\
    \ integers and the smallest positive\n        // integer\n        Optional<Long>\
    \ positiveInteger;\n        if (seenPositiveIntegers.containsKey(1l)) {\n    \
    \        positiveInteger = seenPositiveIntegers.get(1l);\n        } else {\n \
    \           positiveInteger = Optional.empty();\n        }\n\n        Optional<Long>\
    \ negativeInteger;\n        if (seenNegativeIntegers.containsKey(1l)) {\n    \
    \        negativeInteger = seenNegativeIntegers.get(1l);\n        } else {\n \
    \           negativeInteger = Optional.empty();\n        }\n\n        if (positiveInteger.isPresent()\
    \ && negativeInteger.", "        // Write your code here\n        long max;\n\
    \        long min;\n        if (lst.isEmpty()) {\n            return new Pair<>(Optional.empty(),\
    \ Optional.empty());\n        }\n        for (Long num : lst) {\n            if\
    \ (num < 0) {\n                max = num;\n            } else if (num > 0) {\n\
    \                min = num;\n            }\n        }\n        if (max > min)\
    \ {\n            return new Pair<>(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));\n\
    \        } else {\n            return new Pair<>(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }", "        Optional<Long> maxNegative\
    \ = lst.stream().filter(n -> n < 0).findAny();\n        Optional<Long> minPositive\
    \ = lst.stream().filter(n -> n >= 0).findAny();\n        if (maxNegative.isPresent()\
    \ && minPositive.isPresent()) {\n            return Pair.with(Optional.of(maxNegative),\
    \ Optional.of(minPositive));\n        } else if (maxNegative.isPresent()) {\n\
    \            return Pair.with(Optional.of(maxNegative), Optional.empty());\n \
    \       } else if (minPositive.isPresent()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(minPositive));\n        } else {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }", "        List<Long> positive =\
    \ new ArrayList<>();\n        List<Long> negative = new ArrayList<>();\n     \
    \   for (Long i : lst)\n            if (i < 0L)\n                negative.add(i);\n\
    \            else\n                positive.add(i);\n        Optional<Long> minPositive\
    \ = Optional.of(Optional.of(Collections.min(positive)));\n        Optional<Long>\
    \ maxNegative = Optional.of(Optional.of(Collections.max(negative)));\n       \
    \ return new Pair<>(minPositive, maxNegative);", "        Arrays.sort(lst);\n\
    \        if (lst.isEmpty()) return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Optional<Long> a = Optional.empty();\n        Optional<Long> b = Optional.empty();\n\
    \        long maxNegative = lst.get(0l);\n        long minPositive = lst.get(lst.size()-1);\n\
    \        if (maxNegative > 0 && minPositive < 0) {\n            a = Optional.of(maxNegative);\n\
    \            b = Optional.of(minPositive);\n        } else if (maxNegative > 0)\
    \ {\n            a = Optional.of(maxNegative);\n            b = Optional.empty();\n\
    \        } else if (minPositive < 0) {\n            a = Optional.empty();\n  \
    \          b = Optional.of(minPositive);\n        }\n        return Pair.with(a,\
    \ b);", "        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n\n        long smallest = lst.get(0);\n     \
    \   long largest = lst.get(0);\n        for (long i : lst) {\n            if (i\
    \ < smallest && i > largest) {\n                smallest = i;\n              \
    \  largest = i;\n            } else if (i > smallest) {\n                largest\
    \ = i;\n            } else if (i < largest) {\n                smallest = i;\n\
    \            }\n        }\n        return Pair.with(Optional.of(Optional.of(largest)),\
    \ Optional.of(Optional.of(smallest)));", "        Collections.sort(lst);\n   \
    \     if (lst.size() == 0) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        Optional<Long> a = Optional.of(Optional.of(lst.size()));\n\
    \        Optional<Long> b = Optional.of(Optional.of(lst.get(0)));\n        for\
    \ (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) > lst.get(i-1))\
    \ {\n                b = Optional.of(Optional.of(lst.get(i)));\n            }\
    \ else {\n                a = Optional.of(Optional.of(lst.get(i)));\n        \
    \    }\n        }\n        return Pair.with(a, b);", "        Optional<Long> res\
    \ = Optional.empty();\n        Optional<Long> pos = Optional.empty();\n      \
    \  Optional<Long> neg = Optional.empty();\n        for(int i=0;i<lst.size();i++)\
    \ {\n            final long l = lst.get(i);\n            if (l>0) {\n        \
    \        if (pos.isPresent() && l<pos.get()) {\n                    res = Optional.of(Optional.empty());\n\
    \                    pos = Optional.empty();\n                    neg = Optional.of(Optional.empty());\n\
    \                }\n                pos = Optional.of(Optional.of(l));\n     \
    \       }\n            else {\n                if (neg.isPresent() && l>=neg.get())\
    \ {\n                    res = Optional.of(Optional.empty());\n              \
    \      pos = Optional.empty();\n                    neg = Optional.of(Optional.empty());\n\
    \                }\n                neg = Optional.of(Optional.of(l));\n     \
    \       }\n        }\n        return Pair.with(res, pos);", "        boolean neg\
    \ = false;\n        if (lst.stream().anyMatch(a -> a < 0l)) {\n            neg\
    \ = true;\n        }\n        Pair<Optional<Long>, Optional<Long>> p = Pair.with(\n\
    \            Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\n\
    \        for (int i = 0; i < lst.size(); i++) {\n            Long l = lst.get(i);\n\
    \            if (l < 0) {\n                p.left.ifPresent(l -> {\n         \
    \           if (neg) {\n                        if (p.right.isPresent()) {\n \
    \                           Optional<Long> nL = Optional.of(p.right.get());\n\
    \                            Optional<Long> nR = Optional.of(l);\n           \
    \                 Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n      \
    \                          nR, Optional.empty());\n                          \
    \  p = Pair.with(p.left, Optional.of(n));\n                        } else {\n\
    \                            Optional<Long> nL = Optional.of(l);\n           \
    \                 Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n      \
    \                          Optional.empty(), nL);\n                          \
    \  p = Pair.with(p.left, n);\n                        }\n                    }\
    \ else {\n                        if (p.right.isPresent()) {\n               \
    \             Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n          \
    \                      p.right.get(), Optional.of(l));\n                     \
    \       p = Pair.with(p.left, n);\n                        } else {\n        \
    \                    Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n   \
    \                             Optional.empty(), Optional.of(l));\n           \
    \                 p = Pair.with(p.left, n);\n                        }\n     \
    \               }\n                });\n            } else if (neg) {\n      \
    \          if (p.left.isPresent()) {\n                    Optional<Long> nL =\
    \ Optional.of(l);\n                    Optional<Long> nR = Optional.of(p.left.get());\n\
    \                    Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n   \
    \                     nR, Optional.empty());\n                    p = Pair.with(Optional.of(n),\
    \ p.right);\n                } else {\n                    Optional<Long> nL =\
    \ Optional.of(l);\n                    Pair<Optional<Long>, Optional<Long>> n\
    \ = Pair.with(\n                        Optional.empty(), nL);\n             \
    \       p = Pair.with(Optional.empty(), n);\n                }\n            }\
    \ else {\n                if (p.left.isPresent()) {\n                    Pair<Optional<Long>,\
    \ Optional<Long>> n = Pair.with(\n                        p.left.get(), Optional.of(l));\n\
    \                    p = Pair.with(p.right, n);\n                } else {\n  \
    \                  Pair<Optional<Long>, Optional<Long>> n = Pair.with(\n     \
    \                   Optional.empty(), Optional.of(l));\n", "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.empty(), Optional.empty());\n     \
    \   }\n\n        Comparator<Long> cmp = (Long i1, Long i2) -> (i1 > i2) ? 1 :\
    \ -1;\n        ArrayList<Long> cmpLst = new ArrayList<>(cmp.compare(lst.get(0),\
    \ lst.get(0)));\n\n        Optional<Long> largest = Optional.empty();\n      \
    \  Optional<Long> smallest = Optional.empty();\n\n        for (int i = 0; i <\
    \ lst.size() - 1; i++) {\n            if (cmp.get(lst.get(i)) < 0) {\n       \
    \         if (largest.isEmpty()) {\n                    largest = Optional.of(lst.get(i));\n\
    \                } else if (lst.get(i) < largest.get()) {\n                  \
    \  largest = Optional.of(lst.get(i));\n                }\n            } else {\n\
    \                if (smallest.isEmpty()) {\n                    smallest = Optional.of(lst.get(i));\n\
    \                } else if (lst.get(i) > smallest.get()) {\n                 \
    \   smallest = Optional.of(lst.get(i));\n                }\n            }\n  \
    \          cmpLst.add(lst.get(i));\n        }\n\n        return Pair.with(largest,\
    \ smallest);", "        boolean negatives = false;\n        boolean positives\
    \ = false;\n\n        for (long l : lst) {\n            if (l < 0) {\n       \
    \         negatives = true;\n            } else if (l > 0) {\n               \
    \ positives = true;\n            }\n        }\n\n        if (negatives && positives)\
    \ {\n            return Pair.with(Optional.of(Optional.of(-Math.max(lst))), Optional.of(Math.min(lst)));\n\
    \        } else if (negatives) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        } else if (positives) {\n         \
    \   return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        long max = Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n      \
    \  for (Long v : lst) {\n            if (v < 0) max = Math.max(max, v);\n    \
    \        else if (v > 0) min = Math.min(min, v);\n        }\n        return new\
    \ Pair<>(Optional.of(Optional.ofNullable(max)), Optional.of(Optional.ofNullable(min)));",
  "        if (lst.isEmpty())\n            return Pair.of(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        Optional<Long> minOptional = Optional.of(Optional.empty());\n\
    \        Optional<Long> maxOptional = Optional.of(Optional.empty());\n       \
    \ for (Long num : lst) {\n            if (num < 0l)\n                minOptional\
    \ = Optional.of(Optional.empty());\n            else if (num > 0l)\n         \
    \       maxOptional = Optional.of(Optional.empty());\n            else\n     \
    \           minOptional = Optional.of(Optional.of(num));\n            maxOptional\
    \ = maxOptional.orElse(Optional.of(Optional.of(num)));\n        }\n        return\
    \ Pair.of(minOptional, maxOptional);", "        long largest = Long.MIN_VALUE;\n\
    \        long smallest = Long.MAX_VALUE;\n        for (Long i : lst) {\n     \
    \       if (i < 0)\n                smallest = i;\n            else if (i > 0)\n\
    \                largest = i;\n        }\n        return Pair.of(Optional.of(Optional.of(largest)),\
    \ Optional.of(Optional.of(smallest)));", "        if (lst.isEmpty()) return new\
    \ Pair<Optional<Long>, Optional<Long>>(Optional.empty(), Optional.empty());\n\
    \        Collections.sort(lst);\n        int min = Integer.MIN_VALUE;\n      \
    \  Optional<Long> max = null;\n        for (Long i: lst) {\n            int cmp\
    \ = i < 0 ? -1 : 1;\n            if (cmp < 0) {\n                if (max == null\
    \ || cmp > max.getValue()) {\n                    max = Optional.of(i);\n    \
    \            }\n            } else {\n                if (min == null || cmp <\
    \ min.getValue()) {\n                    min = i;\n                }\n       \
    \     }\n        }\n        return new Pair<>(max, Optional.of(min));", "    \
    \    Optional<Long> maxLst = Optional.empty();\n        Optional<Long> minLst\
    \ = Optional.empty();\n        for (Long num : lst) {\n            if (num < 0l)\
    \ continue;\n            if (maxLst.isPresent() && maxLst.isPresent() < (long)num)\
    \ {\n                maxLst = Optional.empty();\n            }\n            if\
    \ (minLst.isPresent() && minLst.isPresent() > (long)num) {\n                minLst\
    \ = Optional.empty();\n            }\n            if (minLst.isPresent() && minLst.get()\
    \ > num) {\n                minLst = Optional.empty();\n            }\n      \
    \      if (maxLst.isPresent() && maxLst.get() < num) {\n                maxLst\
    \ = Optional.empty();\n            }\n        }\n        return Pair.of(maxLst,\
    \ minLst);", "        Optional<Long> max;\n        Optional<Long> min;\n     \
    \   if (lst.isEmpty()) return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Set<Long> set = new HashSet<>();\n        for (long i : lst) {\n    \
    \        if (set.add(i)) continue;\n            max = Optional.of(i);\n      \
    \      min = Optional.empty();\n            set.clear();\n            continue;\n\
    \        }\n        max = Optional.of(Optional.empty());\n        min = Optional.empty();\n\
    \        for (long i : lst) {\n            if (set.add(i)) continue;\n       \
    \     if (i < 0l && i >= 0l) max = Optional.of(i);\n            if (i > 0l &&\
    \ i <= 0l) min = Optional.of(i);\n            set.clear();\n        }\n      \
    \  if (min.isPresent()) {\n            min = Optional.of(Optional.empty());\n\
    \            for (long i : lst) {\n                if (set.add(i)) continue;\n\
    \                if (i >= 0l) min = Optional.of(i);\n                set.clear();\n\
    \            }\n        }\n        return Pair.with(min, max);", "        int\
    \ firstNonZeroIndex = -1;\n        Long firstNonZero = Long.MIN_VALUE;\n     \
    \   Pair<Optional<Long>, Optional<Long>> result = Pair.with(Optional.empty(),\
    \ Optional.empty());\n        for (Long num : lst) {\n            if (num > 0)\
    \ {\n                if (num > firstNonZero) {\n                    firstNonZeroIndex\
    \ = lst.indexOf(num);\n                    firstNonZero = num;\n             \
    \   }\n            }\n        }\n        if (firstNonZeroIndex == -1) {\n    \
    \        return result;\n        }\n        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        int firstIndex = firstNonZeroIndex\
    \ + 1;\n        int lastIndex = firstIndex - 1;\n        while (firstIndex < lastIndex)\
    \ {\n            Optional<Long> c = lst.stream().filter(v -> v >= firstNonZero).map(v\
    \ -> v - firstNonZero).findFirst();\n            Optional<Long> d = lst.stream().filter(v\
    \ -> v <= firstNonZero).map(v -> v - firstNonZero).findFirst();\n            Optional<Long>\
    \ aAndB = Optional.empty();\n            if (c.isPresent() && d.isPresent()) {\n\
    \                aAndB = Optional.of(Pair.with(Optional.of(firstNonZero), Optional.of(firstNonZero)));\n\
    \            } else if (c.isPresent() && !d.isPresent()) {\n                aAndB\
    \ = Optional.of(Pair.with(Optional.of(firstNonZero), Optional.empty()));\n   \
    \         } else if (!c.isPresent() && d.isPresent()) {\n                aAndB\
    \ = Optional.of(Pair.with(Optional.empty(), Optional.of(firstNonZero)));\n   \
    \         }\n            if (aAndB.isPresent()) {\n                result = aAndB;\n\
    \                break;\n            }\n            firstIndex++;\n          \
    \  lastIndex--;\n        }\n        return result;", "        Optional<Long> a\
    \ = Optional.empty();\n        Optional<Long> b = Optional.empty();\n        for(int\
    \ i = 0; i < lst.size(); i++){\n            if((lst.get(i) < 0l)){\n         \
    \       a = Optional.of(lst.get(i));\n            }\n            if((lst.get(i)\
    \ > 0l)){\n                b = Optional.of(lst.get(i));\n            }\n     \
    \   }\n        return Pair.with(a, b);", "        Optional<Long> min = null;\n\
    \        Optional<Long> max = null;\n        for (Long i : lst) {\n          \
    \  if (i.signum() < 0) {\n                min = Optional.ofNullable(i);\n    \
    \        } else if (i.signum() > 0) {\n                max = Optional.ofNullable(i);\n\
    \            }\n        }\n        return min.map(n -> Pair.of(Optional.ofNullable(n),\
    \ max)).orElseGet(() -> Pair.of(min, max));", "        // 1. Create a pair with\
    \ the largest negative integer to smallest\n        // positive integer in the\
    \ array list.\n        // 2. Create a pair with the smallest positive integer\
    \ to largest\n        // negative integer in the array list.\n        Optional<Long>\
    \ maxInt = Optional.empty();\n        Optional<Long> minInt = Optional.empty();\n\
    \        Optional<Long> minPosInt = Optional.empty();\n        Optional<Long>\
    \ maxNegInt = Optional.empty();\n\n        for (Long i : lst) {\n            if\
    \ (i < 0l) {\n                maxInt = Optional.of(i);\n            } else if\
    \ (i >= 0l) {\n                minInt = Optional.of(i);\n            }\n     \
    \       if (i < 0l) {\n                minPosInt = Optional.of(i);\n         \
    \   } else if (i >= 0l) {\n                maxNegInt = Optional.of(i);\n     \
    \       }\n        }\n        return Pair.with(maxInt, minInt);", "        //\
    \ Write your code here\n        Optional<Long> smallest = Optional.empty();\n\
    \        Optional<Long> largest = Optional.empty();\n        Long max = Long.MIN_VALUE;\n\
    \        Long min = Long.MAX_VALUE;\n        for(Long i : lst) {\n           \
    \ if(i.compareTo(max) < 0) {\n                max = i;\n                largest\
    \ = Optional.of(i);\n            } else if (i.compareTo(min) > 0) {\n        \
    \        min = i;\n                smallest = Optional.of(i);\n            }\n\
    \        }\n        if(!smallest.isPresent() || !largest.isPresent()) {\n    \
    \        return Pair.of(largest, smallest);\n        } else {\n            return\
    \ Pair.of(Optional.of(max), Optional.of(min));\n        }", "        Optional<Long>\
    \ minValue = Optional.empty();\n        Optional<Long> maxValue = Optional.empty();\n\
    \        for(Long l : lst) {\n            Optional<Long> x = Optional.of(l);\n\
    \            Optional<Long> y = Optional.of(-l);\n            minValue = minValue.flatMap(min\
    \ -> x.flatMap(x -> y.map(y -> Optional.of(Math.max(min, Math.min(x, y))))));\n\
    \            maxValue = maxValue.flatMap(max -> x.flatMap(x -> y.map(y -> Optional.of(Math.min(max,\
    \ Math.max(x, y))))));\n        }\n        return Pair.of(minValue, maxValue);",
  "        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(), Optional.empty());\n\
    \        }\n        double max = Long.MIN_VALUE;\n        double min = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            if (i < min) {\n                min\
    \ = i;\n            }\n            if (i > max) {\n                max = i;\n\
    \            }\n        }\n        Optional<Long> max = Optional.of(max);\n  \
    \      Optional<Long> min = Optional.of(min);\n        ArrayList<Long> filtered\
    \ = new ArrayList<Long>();\n        for (long i : lst) {\n            if (i >\
    \ max && i < min) {\n                filtered.add(i);\n            }\n       \
    \ }\n        if (filtered.isEmpty()) {\n            return Pair.with(max, min);\n\
    \        }\n        max = Long.MIN_VALUE;\n        min = Long.MAX_VALUE;\n   \
    \     for (long i : filtered) {\n            if (i < min) {\n                min\
    \ = i;\n            }\n            if (i > max) {\n                max = i;\n\
    \            }\n        }\n        return Pair.with(max, min);", "        boolean\
    \ negative = true;\n        long largest = 0l;\n        long smallest = Long.MIN_VALUE;\n\
    \        Optional<Long> firstOptional = Optional.empty();\n        for (Long i\
    \ : lst) {\n            if (negative && i >= 0l) {\n                smallest =\
    \ Math.min(smallest, i);\n            }\n            if (i < 0l) {\n         \
    \       negative = false;\n                first = i;\n            }\n       \
    \     if (largest < i) {\n                largest = i;\n            }\n      \
    \      if (firstOptional.isPresent() && smallest==Long.MIN_VALUE && largest==Long.MAX_VALUE\
    \ && !lst.isEmpty()) {\n                return Pair.with(firstOptional, Optional.of(largest));\n\
    \            }\n        }\n        if (negative && !lst.isEmpty()) {\n       \
    \     return Pair.with(firstOptional, Optional.of(smallest));\n        }\n   \
    \     return Pair.with(firstOptional, Optional.empty());", "        if (lst.isEmpty())\
    \ return Pair.with(Optional.empty(), Optional.empty());\n        long a = 0;\n\
    \        long b = 0;\n        for (long i : lst) {\n            if (i < 0) a =\
    \ i;\n            else b = i;\n        }\n        return Pair.with(Optional.of(Optional.of(b)),\
    \ Optional.of(Optional.of(a)));", "        Map<Long, Integer> counts = new HashMap<>();\n\
    \        for (Long i : lst) {\n            int j = counts.get(i);\n          \
    \  if (j < 0)\n                counts.put(i, j = j + 1);\n            else\n \
    \               counts.put(i, j = j - 1);\n        }\n\n        return Pair.with(\n\
    \            Optional.of(counts.entrySet().stream().max().map(e -> e.getValue()).orElse(0)),\n\
    \            Optional.of(counts.entrySet().stream().min().map(e -> e.getValue()).orElse(Integer.MAX_VALUE))\n\
    \        );", "        // Write your logic here\n        Optional<Long> min =\
    \ Optional.empty();\n        Optional<Long> max = Optional.empty();\n        for(int\
    \ i=0;i<lst.size();i++) {\n            if(lst.get(i) < 0) {\n                max\
    \ = Optional.of(Optional.of(lst.get(i)));\n            } else if(lst.get(i) >\
    \ 0) {\n                min = Optional.of(Optional.of(lst.get(i)));\n        \
    \    }\n        }\n        return Pair.with(min,max);", "        List<Long> positives\
    \ = lst.stream().filter(value -> value > 0l).collect(Collectors.toList());\n \
    \       if (positives.size() == 0) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        List<Long> negatives = lst.stream().filter(value\
    \ -> value < 0l).collect(Collectors.toList());\n        if (negatives.size() ==\
    \ 0) {\n            return Pair.with(Optional.of(Optional.empty()), Optional.empty());\n\
    \        }\n        return Pair.with(Optional.of(Optional.of(Collections.max(positives))),\
    \ Optional.of(Collections.min(negatives)));", "        Optional<Long> smallestInt\
    \ = Optional.empty();\n        Optional<Long> largestInt = Optional.empty();\n\
    \        \n        lst.removeIf( i -> {\n            if(i < 0){\n            \
    \    smallestInt = Optional.of(i);\n                return false;\n          \
    \  }\n            \n            largestInt = Optional.of(i);\n            return\
    \ true;\n        });\n        \n        if(smallestInt.isPresent() && largestInt.isPresent()){\n\
    \            return Pair.with(smallestInt, largestInt);\n        }\n        \n\
    \        if(smallestInt.isPresent()){\n            return Pair.with(smallestInt,\
    \ Optional.empty());\n        }\n        \n        if(largestInt.isPresent()){\n\
    \            return Pair.with(Optional.empty(), largestInt);\n        }\n    \
    \    \n        return Pair.with(Optional.empty(), Optional.empty());", "     \
    \   long max = Long.MIN_VALUE;\n        long min = Long.MAX_VALUE;\n        for\
    \ (Long l : lst) {\n            min = Math.min(min, l);\n            max = Math.max(max,\
    \ l);\n        }\n        return new Pair<>(Optional.of(max), Optional.of(min));",
  "        \n        // Find out if there are any negative or positive numbers\n \
    \       // If so, we can use the largestMinus method to get the largest negative\
    \ number, and the smallest\n        // positive number that isn't negative\n\n\
    \        // If the list is not null, we can use the stream API\n        // to\
    \ find out the largest negative number and the smallest positive number that isn't\
    \ negative\n        if (lst != null)\n        {\n            Optional<Long> minValue\
    \ = lst.stream().filter(x -> x < 0l).findFirst();\n            Optional<Long>\
    \ maxValue = lst.stream().filter(x -> x > 0l).findFirst();\n            return\
    \ Pair.of(minValue, maxValue);\n        }\n\n        // Otherwise, we can use\
    \ the null-safe method as we already did\n        else\n        {\n          \
    \  Optional<Long> minValue = Optional.empty();\n            Optional<Long> maxValue\
    \ = Optional.empty();\n            return Pair.of(minValue, maxValue);\n     \
    \   }", "        // TODO: You should not use arraylist as argument here\n\n  \
    \      // Your code here\n        // Write your code here\n\n        // Do not\
    \ write return statement here. Only add lines to your code\n\n        // return\
    \ Optional.of(Optional.empty());\n        return Optional.of(Optional.of(Long.MIN_VALUE));\n",
  "        ArrayList<Long> numbers = lst;\n        if (numbers.isEmpty()) {\n    \
    \        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        ArrayList<Long> sortedNumbers = new ArrayList<Long>(numbers);\n\
    \        Collections.sort(sortedNumbers);\n        Long minValue = numbers.get(0);\n\
    \        Long maxValue = numbers.get(0);\n\n        for (Long number : numbers)\
    \ {\n            if (number < minValue) {\n                minValue = number;\n\
    \            } else if (number > maxValue) {\n                maxValue = number;\n\
    \            }\n        }\n        return Pair.with(Optional.of(Optional.of(minValue)),\
    \ Optional.of(Optional.of(maxValue)));", "        if (lst.isEmpty()) {\n     \
    \       return Pair.with(Optional.empty(), Optional.empty());\n        }\n\n \
    \       // find negative, positive, both\n        Optional<Long> minNegative =\
    \ Optional.empty();\n        Optional<Long> maxPositive = Optional.empty();\n\
    \        boolean maxIsNegative = false;\n        long maxPos = Long.MIN_VALUE;\n\
    \        Optional<Long> minPositive = Optional.empty();\n        boolean minIsNegative\
    \ = false;\n        long minPos = Long.MAX_VALUE;\n\n        for (Long i : lst)\
    \ {\n            if (i < 0) {\n                minIsNegative = true;\n       \
    \     } else if (i > maxPos) {\n                maxIsNegative = true;\n      \
    \          maxPos = i;\n            } else {\n                maxPos = i;\n  \
    \          }\n\n            if (i < 0) {\n                minIsNegative = true;\n\
    \            } else if (i < minPos) {\n                minIsNegative = true;\n\
    \                minPos = i;\n            } else {\n                minPos = i;\n\
    \            }\n        }\n\n        if (minIsNegative) {\n            maxIsNegative\
    \ = true;\n        }\n\n        if (maxIsNegative) {\n            minNegative\
    \ = maxPositive;\n        }\n\n        if (minIsNegative) {\n            minPositive\
    \ = maxPositive;\n        }\n\n        return Pair.with(Optional.of(minPositive),\
    \ Optional.of(maxPositive));", "        long[] arr = lst.stream().mapToLong(l\
    \ -> l).toArray();\n\n        Optional<Optional<Long>> max = Arrays.stream(arr).max(Comparator.naturalOrder());\n\
    \        Optional<Long> largestInteger = max.get();\n\n        Optional<Optional<Long>>\
    \ min = Arrays.stream(arr).min(Comparator.naturalOrder());\n        Optional<Long>\
    \ smallestInteger = min.get();\n\n        return Pair.with(max, min);", "    \
    \    // Check that the list is not empty (it must have at least one element).\n\
    \        if(lst.isEmpty()){\n            return new Pair<Optional<Long>, Optional<Long>>(Optional.empty(),\
    \ Optional.empty());\n        }\n        \n        // Sort list by value descending\n\
    \        Collections.sort(lst);\n        \n        // Get the first element and\
    \ check whether it is negative\n        long min = lst.get(0);\n        boolean\
    \ isMinNegative = min < 0l; // Check if first element < 0\n        \n        //\
    \ Iterate through the list and store the largest and smallest number in an Optional\n\
    \        long max = 0l;\n        long min = 0l;\n        for(int i = 1; i < lst.size();\
    \ i++){\n            long currMax = lst.get(i);\n            if(currMax > max){\n\
    \                max = currMax;\n            }\n            if(currMax < min){\n\
    \                min = currMax;\n            }\n        }\n        \n        //\
    \ Return pair with Optional.of if the array list has negative and positive numbers\n\
    \        return Pair.of(Optional.of(isMinNegative ? min : 0l), Optional.of(max));",
  "        ArrayList<Long> list = Arrays.asList();\n        for(int i =0;i<lst.size();i++)\n\
    \        {\n            if(lst.get(i)<0)\n            {\n                list.add(lst.get(i));\n\
    \            }\n            else if (lst.get(i)>0)\n            {\n          \
    \      list.add(lst.get(i));\n            }\n        }\n        if(list.size()==0)\n\
    \        {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        Arrays.sort(list);\n        Optional<Long> negVal = list.stream().filter(n\
    \ -> n < 0).findFirst();\n        Optional<Long> posVal = list.stream().filter(n\
    \ -> n > 0).findFirst();\n        if(negVal.isPresent())\n        {\n        \
    \    return Pair.with(Optional.of(negVal), posVal);\n        }\n        return\
    \ Pair.with(Optional.of(posVal), Optional.of(posVal));", "        \n        boolean\
    \ negative = true;\n        Long a = null;\n        Long b = null;\n        for\
    \ (Long elem : lst) {\n            if (elem < 0) {\n                negative =\
    \ true;\n                a = elem;\n            } else if (elem > 0) {\n     \
    \           negative = false;\n                b = elem;\n            }\n    \
    \    }\n        return Pair.with(Optional.of(a), Optional.of(b));", "        int\
    \ n = lst.size();\n        if (n == 0) return Pair.with(Optional.empty(), Optional.empty());\n\
    \        if (n == 1) {\n            if (lst.get(0) == 0) return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(lst.get(0)));\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.empty());\n        }\n        List<Long> list = lst.stream()\n    \
    \            .sorted(Comparator.reverseOrder())\n                .collect(Collectors.toList());\n\
    \        // If there is a negative number, we return the first one, otherwise\
    \ the second one.\n        // In case of a tie, we return both anyway.\n     \
    \   if (list.get(0) > 0) return Pair.with(Optional.of(Optional.of(list.get(0))));\n\
    \        return Pair.with(Optional.of(Optional.of(list.get(n - 1))));", "    \
    \    Optional<Long> first = Optional.empty();\n        Optional<Long> second =\
    \ Optional.empty();\n        for (Long val : lst) {\n            if (val < 0)\
    \ first = Optional.of(Optional.of(val));\n            else if (val > 0) second\
    \ = Optional.of(val);\n            else second = Optional.empty();\n        }\n\
    \        return Pair.with(first, second);", "        Comparator<Long> comp = (o1,\
    \ o2) -> {\n            int diff = (int) (o1 - o2);\n            if (diff > 0)\
    \ {\n                return 1;\n            } else if (diff < 0) {\n         \
    \       return -1;\n            } else {\n                return 0;\n        \
    \    }\n        };\n        Collections.sort(lst, comp);\n        return Pair.with(Optional.of(Optional.of(lst.get(lst.size()\
    \ - 1))), Optional.of(Optional.of(lst.get(0))));", "        Optional<Long> smallest\
    \ = lst.stream().min(Comparator.reverseOrder());\n        Optional<Long> largest\
    \ = lst.stream().max(Comparator.naturalOrder());\n        return Pair.of(smallest,\
    \ largest);", "        if (lst.isEmpty()) return Pair.of(Optional.empty(), Optional.empty());\n\
    \        Map<Long, Long> map = new HashMap<>();\n        for (long i : lst) map.putIfAbsent(i,\
    \ i); // Keep a copy of the original list\n        List<Long> values = lst\n \
    \           .stream()\n            .filter(n -> n >= 0)\n            .sorted(Comparator.naturalOrder())\n\
    \            .collect(toList());\n        values.forEach(i -> map.putIfAbsent(i,\
    \ i));\n        Optional<Long> a = Optional.of(Optional.of(map.keySet().stream().max().orElse(Long.MAX_VALUE)));\n\
    \        Optional<Long> b = Optional.of(Optional.of(map.values().stream().min().orElse(-Long.MAX_VALUE)));\n\
    \        return Pair.of(a, b);", "        List<Integer> lstNums = new ArrayList<Integer>();\n\
    \        for(Long num : lst){\n            lstNums.add(Integer.valueOf((int)num));\n\
    \        }\n        boolean positive = false;\n        boolean negative = false;\n\
    \        boolean zero = false;\n        Optional<Long> maxNum = Optional.empty();\n\
    \        Optional<Long> minNum = Optional.empty();\n        for(int i = 0; i <\
    \ lstNums.size(); i++){\n            if(lstNums.get(i) < 0){\n               \
    \ negative = true;\n            }\n            if(lstNums.get(i) > 0){\n     \
    \           positive = true;\n            }\n            if(!positive && !negative\
    \ && !zero){\n                zero = true;\n            }\n        }\n       \
    \ if(lstNums.size() <= 1){\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        if(zero){\n            return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n \
    \       }\n        if(negative && minNum.isPresent()){\n            minNum = minNum.orElse(Optional.empty());\n\
    \            minNum = minNum.orElseGet(() -> lstNums.get(0));\n            return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(minNum));\n        }\n\
    \        if(negative && maxNum.isPresent()){\n            maxNum = maxNum.orElse(Optional.empty());\n\
    \            maxNum = maxNum.orElseGet(() -> lstNums.get(lstNums.size() - 1));\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(maxNum));\n\
    \        }\n        if(positive && maxNum.isPresent()){\n            maxNum =\
    \ maxNum.orElse(Optional.empty());\n            maxNum = maxNum.orElseGet(() ->\
    \ lstNums.get(lstNums.size() - 1));\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(maxNum));\n        }\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        if (lst.isEmpty()) {\n          \
    \  return Pair.with(Optional.empty(), Optional.empty());\n        }\n\n      \
    \  ArrayList<Long> copy = lst.stream().filter(x -> x < 0l).collect(Collectors.toCollection(ArrayList::new));\n\
    \        ArrayList<Long> copy2 = lst.stream().filter(x -> x > 0l).collect(Collectors.toCollection(ArrayList::new));\n\
    \n        if (copy.isEmpty() || copy2.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        return Pair.with(\n                Optional.of(Optional.of(Collections.max(copy,\
    \ Comparator.naturalOrder()))),\n                Optional.of(Collections.min(copy2,\
    \ Comparator.naturalOrder())));", "        Optional<Long> min = Optional.empty();\n\
    \        Optional<Long> max = Optional.empty();\n        for (Long l : lst) {\n\
    \            min = min.flatMap(o -> o.isPresent() ? Optional.of(o.orElse(l)\n\
    \                            : l.isPresent() ? Optional.of(l) : Optional.empty());\n\
    \            max = max.flatMap(o -> o.isPresent() ? Optional.of(o.orElse(l)\n\
    \                            : l.isPresent() ? Optional.of(l) : Optional.empty());\n\
    \        }\n        return max.flatMap(o -> o.isPresent() ? Pair.of(min, o) :\
    \ Pair.of(min, Optional.empty()));", "        long[] arr = lst.toArray(new long[lst.size()]);\n\
    \        Optional<Long> firstNegative = Arrays.stream(arr).filter(a -> a <= 0l).findFirst();\n\
    \        Optional<Long> firstPositive = Arrays.stream(arr).filter(a -> a > 0l).findFirst();\n\
    \        if (firstNegative.isPresent() || firstPositive.isPresent()) {\n     \
    \       return Pair.with(firstNegative, firstPositive);\n        } else {\n  \
    \          return Pair.with(Optional.empty(), Optional.empty());\n        }",
  "        return lst.stream()\n                .filter(i -> !i.equals(0l))\n    \
    \            .mapToLong(Long::longValue)\n                .sorted()\n        \
    \        .max((a, b) -> Integer.compare(b.intValue(), a.intValue()))\n       \
    \         .map(Optional::of)\n                .orElseGet(() -> Optional.of(Optional.empty()));",
  "        ArrayList<Long> lstCopy = new ArrayList<>(lst);\n        Collections.sort(lstCopy);\n\
    \        for (long i : lstCopy)\n            if (i < 0l)\n                return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(Long.valueOf(i)));\n  \
    \      if (lstCopy.isEmpty())\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        return Pair.with(Optional.of(Optional.of(lstCopy.get(0))),\
    \ Optional.of(Optional.of(lstCopy.get(lstCopy.size() - 1))));", "        \n  \
    \      long largestPositive = Long.MIN_VALUE;\n        long largestNegative =\
    \ Long.MAX_VALUE;\n\n        for(long l: lst){\n            if(l > largestPositive)\
    \ {\n                largestPositive = l;\n            }\n            else if(l\
    \ < largestNegative) {\n                largestNegative = l;\n            }\n\
    \        }\n        return Pair.of(Optional.of(largestNegative), Optional.of(largestPositive));",
  "        Set<Long> numbers = new HashSet<>();\n        long largestNumber = Long.MIN_VALUE;\n\
    \        long smallestNumber = Long.MAX_VALUE;\n        for (Long i : lst) {\n\
    \            if (numbers.contains(i)) {\n                long number = i;\n  \
    \              if (number > largestNumber) {\n                    largestNumber\
    \ = number;\n                } else if (number < smallestNumber) {\n         \
    \           smallestNumber = number;\n                }\n            } else {\n\
    \                numbers.add(i);\n            }\n        }\n        Optional<Long>\
    \ largest = Optional.ofNullable(largestNumber);\n        Optional<Long> smallest\
    \ = Optional.ofNullable(smallestNumber);\n        return Pair.with(largest, smallest);",
  "        Collections.sort(lst);\n        long largest = Collections.max(lst);\n\
    \        long smallest = Collections.min(lst);\n        if (largest == smallest)\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(smallest));\n\
    \        } else {\n            return Pair.with(Optional.of(Optional.of(largest)),\
    \ Optional.of(Optional.of(smallest)));\n        }", "        int max = Long.MIN_VALUE;\n\
    \        int min = Long.MAX_VALUE;\n\n        for (int i=0; i<lst.size(); i++)\
    \ {\n            if (lst.get(i) < 0 && lst.get(i) > max) max = lst.get(i);\n \
    \           if (lst.get(i) > 0 && lst.get(i) < min) min = lst.get(i);\n      \
    \  }\n\n        if (min < Long.MAX_VALUE) return Pair.with(Optional.of(Optional.of(min)),\
    \ Optional.of(max));\n        if (max > Long.MIN_VALUE) return Pair.with(Optional.of(Optional.of(max)),\
    \ Optional.of(min));\n\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        long min = 0;\n        long max =\
    \ Long.MIN_VALUE;\n        for(long i : lst) {\n            if(i < 0) min = i;\n\
    \            else if(i > max) max = i;\n        }\n        if(min == max) return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(min));\n        for(long\
    \ i : lst) {\n            if(i < 0) min = i;\n            else if(i > max) max\
    \ = i;\n        }\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(min));",
  "        if (lst.size() == 0) return null;\n        List<Long> positive = new ArrayList<Long>();\n\
    \        List<Long> negative = new ArrayList<Long>();\n\n        for (Long v :\
    \ lst) {\n            if (v >= 0) {\n                positive.add(v);\n      \
    \      } else {\n                negative.add(v);\n            }\n        }\n\
    \        if (positive.size() == 0) return null;\n        if (negative.size() ==\
    \ 0) return Pair.of(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if (positive.size() > negative.size()) {\n            return Pair.of(Optional.of(Optional.of(positive.get(positive.size()\
    \ - 1))), Optional.of(Optional.of(negative.get(negative.size() - 1))));\n    \
    \    } else {\n            return Pair.of(Optional.of(Optional.of(negative.get(negative.size()\
    \ - 1))), Optional.of(Optional.of(positive.get(positive.size() - 1))));\n    \
    \    }", "        Optional<Optional<Long>> maxMin = Stream.of(lst)\n         \
    \   .map(i -> Optional.ofNullable(i).map(Long::longValue))\n            .map(Optional::of).reduce(Optional::max).get();\n\
    \        Optional<Optional<Long>> min = Stream.of(lst)\n            .map(i ->\
    \ Optional.ofNullable(i).map(Long::longValue))\n            .map(Optional::of).reduce(Optional::min).get();\n\
    \        return maxMin.equals(min) ? maxMin : Pair.of(maxMin, min);", "      \
    \  Collections.sort(lst);\n        Optional<Long> max = Optional.empty();\n  \
    \      Optional<Long> min = Optional.empty();\n        for(Long i : lst) {\n \
    \           if(i.compareTo(max.get()) > 0) {\n                max = Optional.of(i);\n\
    \            }\n            if(i.compareTo(min.get()) < 0) {\n               \
    \ min = Optional.of(i);\n            }\n        }\n        if(max.isPresent()\
    \ && min.isPresent()) {\n            return Pair.of(max, min);\n        }\n  \
    \      return Pair.of(max, min);", "        if (lst == null || lst.isEmpty())\
    \ {\n            return Pair.with(Optional.empty(), Optional.empty());\n     \
    \   }\n\n        boolean neg = false;\n        long min = -Long.MAX_VALUE;\n \
    \       long max = Long.MIN_VALUE;\n        for (long num : lst) {\n         \
    \   if (num < min) {\n                min = num;\n            }\n            if\
    \ (num > max) {\n                max = num;\n            }\n            if (num\
    \ < 0) {\n                neg = true;\n            }\n        }\n        if (neg)\
    \ {\n            return Pair.with(Optional.of(Optional.of(-longToIntExact(min))),\
    \ Optional.of(Optional.of(-longToIntExact(max))));\n        }\n        return\
    \ Pair.with(Optional.of(Optional.of(Long.toIntExact(min))), Optional.of(Optional.of(Long.toIntExact(max))));",
  "        Pair<Optional<Long>, Optional<Long>> result = null;\n        for (Long\
    \ i : lst) {\n            Optional<Long> a = Optional.ofNullable(i);\n       \
    \     Optional<Long> b = Optional.empty();\n            if (a.isPresent() && b.isPresent()\
    \ && a.get() <= 0) {\n                b = Optional.of(i);\n            } else\
    \ if (a.isPresent() && a.get() > 0) {\n                a = Optional.ofNullable(a.get());\n\
    \            }\n            if (a != null) {\n                result = Pair.with(a,\
    \ b);\n            }\n        }\n        return result;", "        ArrayList<Long>\
    \ ints = new ArrayList<Long>(lst);\n        ints.removeIf((Long x) -> x < 0L);\n\
    \        ints.removeIf((Long x) -> x == 0L);\n        ints.removeIf((Long x) ->\
    \ x > 0L);\n        if (ints.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        Collections.sort(ints);\n\
    \        if (ints.size() == 1) {\n            return Pair.with(Optional.of(Optional.of(ints.get(0)),\
    \ Optional.empty()), Optional.of(Optional.empty()));\n        }\n        Optional<Long>\
    \ minNegative = Optional.empty();\n        Optional<Long> maxPositive = Optional.empty();\n\
    \        Optional<Long> lastNegative = Optional.of(Optional.empty());\n      \
    \  for (Long i : ints) {\n            if (i < 0L) {\n                if (minNegative.isPresent()\
    \ || maxPositive.isPresent() || lastNegative.isPresent()) {\n                \
    \    Pair<Optional<Long>, Optional<Long>> pair = largestSmallestIntegers(ints);\n\
    \                    minNegative = minNegative.flatMap(y -> pair.first);\n   \
    \                 maxPositive = maxPositive.flatMap(y -> pair.second);\n     \
    \               lastNegative = lastNegative.flatMap(y -> pair.first);\n      \
    \              return pair;\n                }\n                minNegative =\
    \ Optional.of(i);\n            } else if (i > 0L) {\n                if (minNegative.isPresent()\
    \ || maxPositive.isPresent() || lastNegative.isPresent()) {\n                \
    \    Pair<Optional<Long>, Optional<Long>> pair = largestSmallestIntegers(ints);\n\
    \                    minNegative = minNegative.flatMap(y -> pair.first);\n   \
    \                 maxPositive = maxPositive.flatMap(y -> pair.second);\n     \
    \               lastNegative = lastNegative.flatMap(y -> pair.first);\n      \
    \              return pair;\n                }\n                maxPositive =\
    \ Optional.of(i);\n            } else {\n                lastNegative = Optional.of(i);\n\
    \            }\n        }\n        return Pair.with(Optional.of(minNegative),\
    \ Optional.of(maxPositive));", "        // Sort the list.\n        Collections.sort(lst);\n\
    \        // If the list is empty, return the empty optional pair.\n        if\
    \ (lst.isEmpty()) {\n            return Pair.of(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        long max = lst.get(0); //\
    \ Max is first element in list.\n        // If max is negative, return it as empty.\n\
    \        if (max < 0) {\n            return Pair.of(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        // Find first positive number\
    \ in list.\n        for (long i = 1, last = lst.get(0); i <= lst.size(); i++)\
    \ {\n            if (lst.get(i) > last) {\n                last = lst.get(i);\n\
    \            }\n        }\n        // The first number after the last positive\
    \ number is the smallest in list.\n        long smallest = lst.get(lst.size()\
    \ - 1);\n        if (smallest < 0) {\n            return Pair.of(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        return Pair.of(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(smallest)));", "        Optional<Long> large = lst.stream().filter(x\
    \ -> x < 0).findFirst();\n        Optional<Long> small = lst.stream().filter(x\
    \ -> x > 0).findFirst();\n        if (large.isPresent() && small.isPresent())\
    \ {\n            return Pair.of(large, small);\n        }\n        return Pair.of(large,\
    \ small);", "        if (lst.isEmpty()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        long max = Long.MIN_VALUE;\n        long\
    \ min = Long.MAX_VALUE;\n        for (Long i : lst) {\n            long n = i;\n\
    \            if (n < min) min = n;\n            if (n > max) max = n;\n      \
    \  }\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        // TODO: return null, if lst is empty\n        Optional<Long> minOpt =\
    \ lst.stream().min();\n        Optional<Long> maxOpt = lst.stream().max();\n\n\
    \        if (minOpt.isPresent() && maxOpt.isPresent()) {\n            Optional<Long>\
    \ a = minOpt;\n            Optional<Long> b = maxOpt;\n            return Pair.with(a,\
    \ b);\n        }\n\n        if (minOpt.isPresent()) {\n            return Pair.with(minOpt,\
    \ Optional.empty());\n        }\n\n        if (maxOpt.isPresent()) {\n       \
    \     return Pair.with(Optional.empty(), maxOpt);\n        }\n\n        return\
    \ null;", "        long largest = Long.MIN_VALUE;\n        long smallest = Long.MAX_VALUE;\n\
    \        for (long i : lst) {\n            if (i < 0) {\n                smallest\
    \ = Math.min(smallest, i);\n            } else {\n                largest = Math.max(largest,\
    \ i);\n            }\n        }\n        return Pair.with(Optional.of(Optional.of(largest)),\
    \ Optional.of(smallest));", "        ArrayList<Long> negative = new ArrayList<Long>();\n\
    \        ArrayList<Long> positive = new ArrayList<Long>();\n        \n       \
    \ for(int i = 0; i < lst.size(); i++){\n            Long val = lst.get(i);\n \
    \           if(val < 0){\n                negative.add(val);\n            }\n\
    \            else if(val > 0){\n                positive.add(val);\n         \
    \   }\n            \n            \n        }\n        \n        Optional<Long>\
    \ result = Optional.of(Optional.empty());\n        if(negative.size() >= 1){\n\
    \            result = Optional.of(Optional.of(Math.max(negative)));\n        }\n\
    \        if(positive.size() >= 1){\n            result = Optional.of(Optional.of(Math.min(positive)));\n\
    \        }\n        if(result.equals(Optional.empty())){\n            result =\
    \ Optional.of(Optional.of(null));\n        }\n        \n        return Pair.of(result,result);",
  "        long max = Integer.MIN_VALUE;\n        long min = Integer.MAX_VALUE;\n\
    \        for (long value : lst) {\n            if (value > max) {\n          \
    \      max = value;\n            }\n            if (value < min) {\n         \
    \       min = value;\n            }\n        }\n        if (max < min) {\n   \
    \         return Pair.with(Optional.of(Optional.empty()), Optional.of(min));\n\
    \        }\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        final Optional<Long> a = lst.stream().reduce(Long::max).get();\n      \
    \  final Optional<Long> b = lst.stream().reduce(Long::min).get();\n        return\
    \ Pair.with(a, b);", "        ArrayList<Long> sorted = lst.stream().sorted().collect(Collectors.toCollection(ArrayList::new));\n\
    \        long lowest = sorted.get(0l);\n        long highest = sorted.get(sorted.size()\
    \ - 1l);\n\n        Optional<Long> first = Optional.ofNullable(lowest);\n    \
    \    Optional<Long> last = Optional.ofNullable(highest);\n        return Pair.with(first,\
    \ last);", "        Optional<Long> positiveOpt = Optional.empty();\n        Optional<Long>\
    \ negativeOpt = Optional.empty();\n\n        for (Long i : lst) {\n          \
    \  if (i < 0) {\n                negativeOpt = Optional.of(i);\n            }\
    \ else {\n                positiveOpt = Optional.of(i);\n            }\n     \
    \   }\n\n        return Pair.of(positiveOpt, negativeOpt);", "        if (lst.isEmpty())\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        PriorityQueue<Long> pq = new PriorityQueue<>();\n        for (Long i\
    \ : lst)\n            if (i < 0)\n                pq.offer(i);\n            else\
    \ {\n                Optional<Long> min = pq.stream()\n                      \
    \  .filter(i -> i < 0)\n                        .min(Long::compareTo).map(Optional::of);\n\
    \                Optional<Long> max = pq.stream()\n                        .filter(i\
    \ -> i >= 0)\n                        .max(Long::compareTo).map(Optional::of);\n\
    \                return Pair.with(min, max);\n            }\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Optional<Long> smallestPositive =\
    \ Optional.empty();\n        Optional<Long> smallestNegative = Optional.empty();\n\
    \        for (Long num : lst) {\n            if (num < 0l) smallestNegative =\
    \ Optional.of(num);\n            if (num > 0l) smallestPositive = Optional.of(num);\n\
    \        }\n        return smallestPositive.orElse(smallestNegative);", "    \
    \    if (lst.isEmpty()) {\n            return Pair.of(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        // Sort the array in descending\
    \ order\n        Collections.sort(lst);\n        // Find the first negative integer\n\
    \        long first = lst.get(0);\n        int start = 0;\n        long max =\
    \ first;\n        while (start < lst.size() && lst.get(start) < 0) {\n       \
    \     max = lst.get(start);\n            start++;\n        }\n        // Find\
    \ the first positive integer\n        long last = lst.get(lst.size() - 1);\n \
    \       int end = lst.size() - 1;\n        while (end > start && lst.get(end)\
    \ > 0) {\n            last = lst.get(end);\n            end--;\n        }\n  \
    \      if (start == end) {\n            return Pair.of(Optional.of(Optional.of(first)),\
    \ Optional.of(Optional.of(last)));\n        }\n        // Return the largest and\
    \ the smallest integer in the range\n        return Pair.of(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(first)));", "        if (lst.size() <= 0)\n        \
    \    return new Pair<Optional<Long>, Optional<Long>>(null, null);\n        Optional<Long>\
    \ max = Optional.of(Long.MIN_VALUE);\n        Optional<Long> min = Optional.of(Long.MAX_VALUE);\n\
    \        for (Long l : lst) {\n            max = max.isPresent() ? max.orElse(l)\
    \ > l : l.compareTo(max.get()) > 0;\n            min = min.isPresent() ? min.orElse(l)\
    \ < l : l.compareTo(min.get()) < 0;\n        }\n        if (max.isPresent() &&\
    \ min.isPresent())\n            return new Pair<Optional<Long>, Optional<Long>>(max.orElse(null),\
    \ min.orElse(null));\n        else if (max.isPresent())\n            return new\
    \ Pair<Optional<Long>, Optional<Long>>(max.orElse(null), Optional.empty());\n\
    \        else if (min.isPresent())\n            return new Pair<Optional<Long>,\
    \ Optional<Long>>(Optional.empty(), min.orElse(null));\n        else\n       \
    \     return new Pair<Optional<Long>, Optional<Long>>(null, null);", "       \
    \ Optional<Long> positive = lst.stream().filter((x) -> x > 0).findFirst();\n \
    \       Optional<Long> negative = lst.stream().filter((x) -> x < 0).findFirst();\n\
    \        return Pair.with(positive, negative);", "        Optional<Long> minNegative\
    \ = Optional.empty();\n        Optional<Long> maxPositive = Optional.empty();\n\
    \        for (long l: lst) {\n            if (l < 0) {\n                minNegative\
    \ = Optional.of(-l);\n            } else if (l > 0) {\n                maxPositive\
    \ = Optional.of(-l);\n            }\n        }\n        return Pair.of(minNegative,\
    \ maxPositive);", "        Function<ArrayList<Long>, Pair<Optional<Long>, Optional<Long>>>\
    \ func = arr -> {\n            Optional<Long> largest = arr.stream().max((a, b)\
    \ -> Long.compare(a, b)).map(a -> a).get();\n            Optional<Long> smallest\
    \ = arr.stream().min((a, b) -> Long.compare(a, b)).map(a -> a).get();\n      \
    \      return Pair.of(largest, smallest);\n        };\n        return func.apply(lst);",
  "        Optional<Long> max = null;\n        Optional<Long> min = null;\n      \
    \  if (lst.stream().allMatch(x -> x < 0L)) {\n            max = Optional.empty();\n\
    \            min = Optional.of(Long.MAX_VALUE);\n        } else if (lst.stream().allMatch(x\
    \ -> x > 0L)) {\n            min = Optional.empty();\n            max = Optional.of(Long.MIN_VALUE);\n\
    \        } else {\n            min = Optional.of(Long.MAX_VALUE);\n          \
    \  max = Optional.of(Long.MIN_VALUE);\n        }\n        if (min == null || max\
    \ == null || min == max) {\n            min = max = Optional.empty();\n      \
    \  }\n        return Pair.with(min, max);", "        // Your code here\n     \
    \   if (lst.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        ArrayList<Long> lst2 = new\
    \ ArrayList<>();\n        for (Long i : lst) {\n            lst2.add(i);\n   \
    \     }\n        long maxPos = Long.MIN_VALUE;\n        long minPos = Long.MAX_VALUE;\n\
    \        for (Long i : lst) {\n            if (i < 0l) continue;\n           \
    \ if (maxPos < i) {\n                maxPos = i;\n            }\n            if\
    \ (minPos > i) {\n                minPos = i;\n            }\n        }\n    \
    \    return Pair.with(Optional.of(Optional.of(maxPos)), Optional.of(Optional.of(minPos)));",
  "        Arrays.sort(lst);\n        Long minPositive = lst.get(0l);\n        Long\
    \ maxNegative = lst.get(lst.size() - 1l);\n        if (minPositive == null)\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if (maxNegative == null)\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        if (minPositive > maxNegative)\n  \
    \          return Pair.with(Optional.of(Optional.of(maxNegative)), Optional.of(Optional.of(minPositive)));\n\
    \        return Pair.with(Optional.of(Optional.of(minPositive)), Optional.of(Optional.of(maxNegative)));",
  "        if (lst.isEmpty()) return null;\n        Optional<Long> negativeOptional\
    \ = lst.stream().map(Long::valueOf).filter(l -> -l.equals(l))\n              \
    \  .findFirst();\n        if (negativeOptional.isPresent()) {\n            Optional<Long>\
    \ positiveOptional = lst.stream().map(Long::valueOf).filter(l -> l.equals(l))\n\
    \                    .findFirst();\n            return Pair.with(negativeOptional,\
    \ positiveOptional);\n        }\n        return null;", "        Optional<Long>\
    \ smallest = null;\n        Optional<Long> largest = null;\n        for (long\
    \ i : lst) {\n            if (i < 0) {\n                if (smallest == null ||\
    \ i < smallest.get()) {\n                    smallest = Optional.of(i);\n    \
    \            }\n            } else {\n                if (largest == null || i\
    \ > largest.get()) {\n                    largest = Optional.of(i);\n        \
    \        }\n            }\n        }\n        if (smallest == null && largest\
    \ == null) {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        if (smallest == null || largest == null) {\n            return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n \
    \       }\n        return Pair.with(smallest, largest);", "        if (lst.stream().anyMatch(x\
    \ -> x < 0)) // If list contains negative numbers...\n            return Pair.with(Optional.empty(),\
    \ Optional.of(null));\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.of(lst.stream().min(Comparator.naturalOrder()).orElse(null))));",
  "        Long[] arr = lst.toArray(new Long[(int) lst.size()]);\n\n        Long max\
    \ = null;\n        Long min = null;\n        int posSum = 0;\n        int negSum\
    \ = 0;\n\n        for (Long i : arr) {\n            if (i < 0) {\n           \
    \     posSum += i;\n            } else if (i > 0) {\n                negSum +=\
    \ i;\n            }\n        }\n\n        if (negSum > posSum) {\n           \
    \ max = posSum > 0 ? arr[arr.length - 1] : null;\n            min = negSum < 0\
    \ ? arr[arr.length - 1] : null;\n        } else {\n            max = negSum >\
    \ 0 ? arr[arr.length - 1] : null;\n            min = posSum < 0 ? arr[arr.length\
    \ - 1] : null;\n        }\n\n        return Pair.of(Optional.of(max), Optional.of(min));",
  "        Optional<Long> smallest = null;\n        Optional<Long> largest = null;\n\
    \        for (Long elem : lst) {\n            if (elem.equals(Long.MIN_VALUE))\
    \ {\n                smallest = Optional.of(elem);\n            } else if (elem.equals(Long.MAX_VALUE))\
    \ {\n                largest = Optional.of(elem);\n            } else {\n    \
    \            smallest = Optional.empty();\n                largest = Optional.empty();\n\
    \                break;\n            }\n        }\n        if (smallest.isPresent()\
    \ && largest.isPresent()) {\n            return Pair.with(smallest, largest);\n\
    \        }\n        if (smallest == null && largest.isPresent()) {\n         \
    \   return Pair.with(Optional.empty(), largest);\n        }\n        if (smallest\
    \ == null || largest.isPresent()) {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }\n        throw new IllegalArgumentException();",
  "        \n        // Your code here...\n        ArrayList<Long> negative = new\
    \ ArrayList<Long>();\n        ArrayList<Long> positive = new ArrayList<Long>();\n\
    \        for(long l : lst){\n            if (l>0){\n                positive.add(l);\n\
    \            }\n            else if (l<0){\n                negative.add(l);\n\
    \            }\n        }\n        if (negative.isEmpty() && positive.isEmpty())\
    \ {\n            return Pair.of(Optional.empty(), Optional.empty());\n       \
    \ }\n        long max = Collections.max(negative);\n        long min = Collections.min(positive);\n\
    \        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        // Find all negative integers in the array.\n        List<Long> negativeNumbers\
    \ = lst.stream()\n                .filter(x -> x < 0)\n                .collect(Collectors.toList());\n\
    \        // Find all positive integers in the array.\n        List<Long> positiveNumbers\
    \ = lst.stream()\n                .filter(x -> x > 0)\n                .collect(Collectors.toList());\n\
    \        // If there are no negative or positive numbers, return null instead.\n\
    \        if (negativeNumbers.isEmpty() && positiveNumbers.isEmpty()) {\n     \
    \       return Pair.with(Optional.empty(), Optional.empty());\n        }\n   \
    \     Optional<Long> negativeMax = Optional.empty();\n        Optional<Long> negativeMin\
    \ = Optional.empty();\n        Optional<Long> positiveMax = Optional.empty();\n\
    \        Optional<Long> positiveMin = Optional.empty();\n        // Loop through\
    \ the array again and find the largest and smallest numbers.\n        for (long\
    \ i : lst) {\n            if (i < 0) {\n                if (negativeMax.isPresent())\
    \ {\n                    // If there is a negative max, check to make sure it's\
    \ bigger than the new current max.\n                    if (i < negativeMax.get())\
    \ {\n                        negativeMax = Optional.of(new Long(i));\n       \
    \             }\n                } else if (negativeMin.isPresent()) {\n     \
    \               // If there is a negative min, check to make sure it's smaller\
    \ than the new current min.\n                    if (i > negativeMin.get()) {\n\
    \                        negativeMin = Optional.of(new Long(i));\n           \
    \         }\n                } else {\n                    // If there is no negative\
    \ or positive numbers, make a new negative and positive numbers.\n           \
    \         negativeMax = Optional.of(new Long(i));\n                    negativeMin\
    \ = Optional.of(new Long(i));\n                }\n            } else if (i > 0)\
    \ {\n                if (positiveMax.isPresent()) {\n                    // If\
    \ there is a positive max, check to make sure it's bigger than the new current\
    \ max.\n                    if (i > positiveMax.get()) {\n                   \
    \     positiveMax = Optional.of(new Long(i));\n                    }\n       \
    \         } else if (positiveMin.isPresent()) {\n                    // If there\
    \ is a positive min, check to make sure it's smaller than the new current min.\n\
    \                    if (i < positiveMin.get()) {\n                        positiveMin\
    \ = Optional.of(new Long(i));\n                    }\n                } else {\n\
    \                    // If there is no negative or positive numbers, make a new\
    \ negative and positive numbers.\n                    positiveMax = Optional.of(new\
    \ Long(i));\n                    positiveMin = Optional.of(new Long(i));\n   \
    \             }\n            } else {\n                // If there are no negative\
    \ or positive numbers, make a new negative and positive numbers.\n           \
    \     positiveMax = Optional.of(new Long(i));\n                positiveMin = Optional.of(new\
    \ Long(i));\n            }\n        }\n        // Return the smallest and largest\
    \ numbers as pairs.\n        return Pair.with(negative", "        boolean hasNegatives\
    \ = false;\n        boolean hasPositives = false;\n        Optional<Long> negativeInt;\n\
    \        Optional<Long> positiveInt;\n        for (Long number : lst) {\n    \
    \        if (number < 0) {\n                hasNegatives = true;\n           \
    \     negativeInt = Optional.of(number);\n            } else if (number > 0) {\n\
    \                hasPositives = true;\n                positiveInt = Optional.of(number);\n\
    \            }\n        }\n        if (hasNegatives && hasPositives) {\n     \
    \       return Pair.with(Optional.of(negativeInt), Optional.of(positiveInt));\n\
    \        } else if (hasNegatives) {\n            return Pair.with(Optional.of(negativeInt),\
    \ Optional.empty());\n        } else if (hasPositives) {\n            return Pair.with(Optional.empty(),\
    \ Optional.of(positiveInt));\n        } else {\n            return Pair.with(Optional.of(null),\
    \ Optional.of(null));\n        }", "        ArrayList<Long> lst2;\n        Optional<Long>\
    \ largest = Optional.empty();\n        Optional<Long> smallest = Optional.empty();\n\
    \        if(lst.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        for(Long l : lst) {\n  \
    \          if(l > 0 && lst.contains(-l)) {\n                lst2 = new ArrayList<Long>();\n\
    \                for(Long i : lst) {\n                    if(i != l) {\n     \
    \                   lst2.add(-i);\n                    }\n                }\n\
    \                largest = largest.map(o -> l.compareTo(o.longValue()) > 0 ? o\
    \ : largest);\n                smallest = smallest.map(o -> l.compareTo(o.longValue())\
    \ < 0 ? o : smallest);\n                Pair<Optional<Long>, Optional<Long>> ret\
    \ = largestSmallestIntegers(lst2);\n                largest = ret.left;\n    \
    \            smallest = ret.right;\n            }\n        }\n        return Pair.with(Optional.of(largest),\
    \ Optional.of(smallest));", "        Optional<Long> largest = Optional.empty();\n\
    \        Optional<Long> smallest = Optional.empty();\n\n        for (Long num\
    \ : lst) {\n            if (num < 0) {\n                largest = Optional.of(num);\n\
    \            } else if (num > 0) {\n                smallest = Optional.of(num);\n\
    \            }\n        }\n\n        return Pair.with(largest, smallest);", " \
    \       Optional<Optional<Long>> a = Optional.empty();\n        Optional<Optional<Long>>\
    \ b = Optional.empty();\n        for(Long i : lst){\n            if(i<0){\n  \
    \              a = Optional.of(Optional.of(i));\n                if(a.isPresent()){\n\
    \                    b = a;\n                }\n            }\n            else\
    \ if(i>0){\n                b = Optional.of(Optional.of(i));\n               \
    \ if(b.isPresent()){\n                    a = b;\n                }\n        \
    \    }\n        }\n        if(a.isPresent() && b.isPresent()){\n            return\
    \ Pair.with(a, b);\n        }\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));", "        Optional<Optional<Long>> positiveIntsOnly\
    \ = lst.stream()\n                .filter(i -> i > 0)\n                .filter(i\
    \ -> i < 0)\n                .map(i -> Optional.of((long)i))\n               \
    \ .collect(Collectors.toList())\n                .stream().filter(Objects::nonNull)\n\
    \                .min(Comparator.comparingLong(Long::longValue));\n        Optional<Optional<Long>>\
    \ negativeIntsOnly = lst.stream()\n                .filter(i -> i < 0)\n     \
    \           .filter(i -> i > 0)\n                .map(i -> Optional.of((long)i))\n\
    \                .collect(Collectors.toList())\n                .stream().filter(Objects::nonNull)\n\
    \                .min(Comparator.comparingLong(Long::longValue));\n        if(positiveIntsOnly.isPresent()\
    \ && negativeIntsOnly.isPresent()) {\n            return Pair.with(positiveIntsOnly,\
    \ negativeIntsOnly);\n        }\n        return Pair.with(Optional.empty(), Optional.empty());",
  "        ArrayList<Long> arr = new ArrayList<>();\n        for (long i : lst) {\n\
    \            if (i < 0l) {\n                arr.add((long)-il);\n            }\
    \ else {\n                arr.add(i);\n            }\n        }\n        Pair<Optional<Long>,\
    \ Optional<Long>> res = Pair.with(largestElement(arr), smallestElement(arr));\n\
    \        arr.clear();\n        return res;", "        long min = Long.MAX_VALUE;\n\
    \        long max = Long.MIN_VALUE;\n        for(Long num : lst) {\n         \
    \   if(num < min) {\n                min = num;\n            }\n            if(num\
    \ > max) {\n                max = num;\n            }\n        }\n        return\
    \ Pair.withOptional(Optional.of(min), Optional.of(max));", '        return lst.stream().parallel().reduce(new
    Pair<Optional<Long>, Optional<Long>>(), new LargestSmallestIntegers());', "  \
    \      if(lst.isEmpty())\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        Optional<Long> largestInt = Optional.empty();\n\
    \        Optional<Long> smallestInt = Optional.empty();\n        for(Long i :\
    \ lst) {\n            if(i < 0l) {\n                if(largestInt.isPresent())\
    \ {\n                    throw new IllegalArgumentException(\"Can only have one\
    \ negative integer in array!\");\n                }\n                largestInt\
    \ = Optional.of(i);\n            }\n            if(i > 0l) {\n               \
    \ if(smallestInt.isPresent()) {\n                    throw new IllegalArgumentException(\"\
    Can only have one positive integer in array!\");\n                }\n        \
    \        smallestInt = Optional.of(i);\n            }\n        }\n        if(largestInt.isPresent())\
    \ {\n            return Pair.with(largestInt, smallestInt);\n        } else {\n\
    \            return Pair.with(Optional.empty(), Optional.empty());\n        }",
  "        // Get all the negative numbers from the array\n        Arrays.sort(lst);\n\
    \n        // Get all the positive numbers from the array\n        ArrayList<Long>\
    \ posArray = new ArrayList<Long>();\n        for (Long i : lst) {\n          \
    \  if (i < 0l) {\n                posArray.add(i);\n            }\n        }\n\
    \        ArrayList<Long> negArray = new ArrayList<Long>();\n        for (Long\
    \ i : lst) {\n            if (i >= 0l) {\n                negArray.add(i);\n \
    \           }\n        }\n\n        // If there are no negative numbers, return\
    \ the negative and positive numbers as a single pair.\n        if (negArray.isEmpty()\
    \ && posArray.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n\n        // Get the largest negative\
    \ number, and the smallest positive number\n        // If there is no negative\
    \ or positive numbers, return them as null.\n        Optional<Long> largestNegativeOptional\
    \ = Optional.empty();\n        Optional<Long> smallestPositiveOptional = Optional.empty();\n\
    \n        if (negArray.isEmpty()) {\n            largestNegativeOptional = Optional.of(negArray.get(0));\n\
    \            smallestPositiveOptional = Optional.of(posArray.get(0));\n      \
    \  } else if (posArray.isEmpty()) {\n            largestNegativeOptional = Optional.of(Optional.empty());\n\
    \            smallestPositiveOptional = Optional.of(Optional.empty());\n     \
    \   } else {\n            long largestNegative = negArray.get(negArray.size()\
    \ - 1);\n            long smallestPositive = posArray.get(posArray.size() - 1);\n\
    \            if (largestNegative > largestPositive) {\n                largestNegativeOptional\
    \ = Optional.of(largestNegative);\n                smallestPositiveOptional =\
    \ Optional.of(smallestPositive);\n            } else {\n                largestNegativeOptional\
    \ = Optional.of(Optional.empty());\n                smallestPositiveOptional =\
    \ Optional.of(Optional.empty());\n            }\n        }\n\n        return Pair.with(largestNegativeOptional,\
    \ smallestPositiveOptional);", "        long maxNegative = 0, minPositive = Long.MAX_VALUE;\n\
    \        for (Long num : lst) {\n            if (num < 0) {\n                if\
    \ (maxNegative < num)\n                    maxNegative = num;\n            } else\
    \ {\n                if (minPositive > num)\n                    minPositive =\
    \ num;\n            }\n        }\n        return Pair.with(Optional.of(Optional.of(maxNegative)),\
    \ Optional.of(Optional.of(minPositive)));", "        Optional<Long> minInArray\
    \ = lst.stream().min(Long::compare);\n        Optional<Long> maxInArray = lst.stream().max(Long::compare);\n\
    \        return minInArray.isPresent() ? Pair.of(minInArray, maxInArray) : Pair.of(Optional.empty(),\
    \ Optional.empty());", "        // Create a map of Integer keys to Long values.\
    \ If the key is already present, the value should be the same as the old value.\
    \ If the key is not present, the key should be set to a new Long with the value\
    \ null.\n        Map<Integer, Long> map = new HashMap<>();\n        for (Long\
    \ l : lst) {\n            if (map.containsKey(l.intValue())) map.put(l.intValue(),\
    \ map.get(l.intValue()));\n            else map.put(l.intValue(), null);\n   \
    \     }\n        // Create an array list with the Integer keys (sorted by values)\n\
    \        List<Integer> keyList = new ArrayList<>(map.keySet());\n        // Sort\
    \ the array list (by value)\n        Collections.sort(keyList);\n        // Now\
    \ that we have an array of sorted keys, we can use binary search to find the largest\
    \ and smallest integers\n        Optional<Long> largest = keyList.stream().filter(i\
    \ -> map.get(i) != null).reduce((a, b) -> a > b ? a : b).map(i -> map.get(i));\n\
    \        Optional<Long> smallest = keyList.stream().filter(i -> map.get(i) !=\
    \ null).reduce((a, b) -> a < b ? a : b).map(i -> map.get(i));\n        return\
    \ Pair.with(largest, smallest);", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        result.add(0L);\n        result.add(0L);\n        Optional<Long> firstSmallest\
    \ = Optional.of(Optional.empty());\n        Optional<Long> firstLargest = Optional.of(Optional.empty());\n\
    \        for (Long i : lst) {\n            Optional<Long> smallest = Optional.of(Optional.empty());\n\
    \            Optional<Long> largest = Optional.of(Optional.empty());\n       \
    \     if (i < 0L) {\n                result.add(i);\n                Optional<Long>\
    \ smallest2 = Optional.of(Optional.empty());\n                for (Long j : result)\
    \ {\n                    Optional<Long> smallest3 = Optional.of(Optional.empty());\n\
    \                    if (j > i) {\n                        smallest2 = smallest;\n\
    \                        smallest = Optional.of(Optional.empty());\n         \
    \           }\n                    if (j < i) {\n                        result.add(j);\n\
    \                        Optional<Long> smallest4 = Optional.of(Optional.empty());\n\
    \                        if (smallest2.isPresent() && (smallest.isPresent() ||\
    \ (smallest.isPresent() && (smallest2.get() <= smallest.get()))) && largest.isPresent()\
    \ && (j > i)) {\n                            smallest4 = smallest2;\n        \
    \                    smallest = smallest3;\n                        }\n      \
    \                  if (smallest.isPresent() && (smallest.get() <= smallest4.get()))\
    \ {\n                            smallest = smallest2;\n                     \
    \   }\n                        if (j > i) {\n                            largest\
    \ = Optional.of(Optional.empty());\n                        }\n              \
    \      }\n                    if (largest.isPresent() && (j > i)) {\n        \
    \                largest = Optional.of(Optional.empty());\n                  \
    \  }\n                }\n                firstSmallest = smallest;\n         \
    \       firstLargest = largest;\n            }\n            if (firstSmallest.isPresent()\
    \ && firstLargest.isPresent() && (firstSmallest.get() <= firstLargest.get()))\
    \ {\n                firstSmallest = Optional.of(Optional.empty());\n        \
    \        firstLargest = Optional.of(Optional.empty());\n            }\n      \
    \  }\n        Optional<Long> smallest2 = firstSmallest;\n        Optional<Long>\
    \ largest2 = firstLargest;\n        if (smallest2.isPresent() && (firstLargest.isPresent()\
    \ || (smallest2.get() <= firstLargest.get()))) {\n            smallest2 = firstSmallest;\n\
    \            largest2 = firstLargest;\n        }\n        return Pair.with(smallest2, ",
  "        Arrays.sort(lst);\n        ArrayList<Long> copy = new ArrayList<Long>(lst);\n\
    \        if(copy.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        boolean neg = false;\n \
    \       for(Long i : copy) {\n            if(i.longValue() < 0) {\n          \
    \      neg = true;\n                break;\n            }\n        }\n       \
    \ copy.clear();\n        for(Long i : lst) {\n            if(neg) {\n        \
    \        if(i > 0)\n                    copy.add(-i);\n            } else {\n\
    \                if(i>0)\n                    copy.add(i);\n            }\n  \
    \      }\n        if(copy.isEmpty()) {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }\n        Long max = -copy.get(0);\n\
    \        Long min = copy.get(0);\n        boolean changed = false;\n        for(Long\
    \ i : copy) {\n            if(i<min || i>max) {\n                if(min<0)\n \
    \                   min = i; // negative numbers always go before positive ones\n\
    \                else\n                    max = i; // negative numbers always\
    \ go after positive ones\n                changed = true;\n            }\n   \
    \     }\n        if(changed) {\n            return Pair.with(Optional.of(Optional.of(max)),\
    \ Optional.of(Optional.of(min)));\n        } else {\n            return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(Optional.empty()));\n        }", "        List<Pair<Optional<Long>,\
    \ Optional<Long>>> result = new ArrayList<Pair<Optional<Long>, Optional<Long>>>();\n\
    \        for (long l : lst) {\n            if (l < 0)\n                result.add(Pair.with(Optional.of(Optional.of(l)),\
    \ Optional.empty()));\n            else if (l > 0)\n                result.add(Pair.with(Optional.empty(),\
    \ Optional.of(Optional.of(l))));\n        }\n        return Pair.with(result.get(result.size()\
    \ - 1).lhs, result.get(result.size() - 1).rhs);", "        Pair<Optional<Long>,\
    \ Optional<Long>> ret = Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        Optional<Long> largest = Optional.empty();\n        Optional<Long> smallest\
    \ = Optional.empty();\n        for (Long i : lst) {\n            if (i.longValue()\
    \ >= 0) {\n                largest = Optional.of(i).min(largest);\n          \
    \  }\n            else {\n                smallest = Optional.of(i).max(smallest);\n\
    \            }\n        }\n        ret = Pair.with(largest, smallest);\n     \
    \   return ret;", "        int n = lst.size();\n        if (n < 2) return null;\n\
    \        Arrays.sort(lst);\n        Long a = lst.get(n-1);\n        Long b = lst.get(0);\n\
    \        return Pair.with( Optional.of(Optional.of(a)), Optional.of(Optional.of(b))\
    \ );", "        // Write your code here\n        long smallest;\n        long\
    \ largest;\n        for(int i=0;i<lst.size();i++){\n            if(lst.get(i)>0){\n\
    \                if(smallest==0l){\n                    smallest=lst.get(i);\n\
    \                }else if(lst.get(i)<smallest){\n                    smallest=lst.get(i);\n\
    \                }\n            }else{\n                if(largest==0l){\n   \
    \                 largest=lst.get(i);\n                }else if(lst.get(i)>largest){\n\
    \                    largest=lst.get(i);\n                }\n            }\n \
    \       }\n        return Pair.with(Optional.of(Optional.of(largest)), Optional.of(smallest));",
  "        Optional<Long> positiveInts = lst.stream().filter(x -> x >= 0L).findFirst();\n\
    \        Optional<Long> negativeInts = lst.stream().filter(x -> x <= 0L).findFirst();\n\
    \        if (negativeInts.isPresent() && positiveInts.isPresent()) {\n       \
    \     return Pair.with(Optional.of(negativeInts.get()), Optional.of(positiveInts.get()));\n\
    \        }\n        if (negativeInts.isPresent()) {\n            return Pair.with(Optional.of(negativeInts.get()),\
    \ Optional.empty());\n        }\n        if (positiveInts.isPresent()) {\n   \
    \         return Pair.with(Optional.of(positiveInts.get()), Optional.empty());\n\
    \        }\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        long max=-Long.MIN_VALUE;\n        long min=Long.MAX_VALUE;\n        for\
    \ (Long a:lst) {\n            if (a>max) {\n                max=a;\n         \
    \   }\n            if (a<min) {\n                min=a;\n            }\n     \
    \   }\n        return Pair.with(Optional.of(Optional.of(max)), Optional.of(Optional.of(min)));",
  "        // Check list is not empty and at least one element in the list\n     \
    \   if (lst.size() > 0 && lst.stream().anyMatch(i -> i < 0l)) {\n            return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(-1l));\n        }\n   \
    \     else if (lst.size() > 0 && lst.stream().anyMatch(i -> i >= 0l)) {\n    \
    \        return Pair.with(Optional.of(Optional.empty()), Optional.of(-1l));\n\
    \        }\n\n        // Check list is not empty and at least two elements in\
    \ the list\n        if (lst.size() > 1 && lst.stream().anyMatch(i -> i < 0l ||\
    \ i >= 0l)) {\n            // Find the smallest element in list\n            Optional<Long>\
    \ minOptional = lst.stream()\n                                        .filter(i\
    \ -> i >= 0l)\n                                        .min(Comparator::naturalOrder);\n\
    \            if (minOptional.isPresent()) {\n                return Pair.with(Optional.of(minOptional),\
    \ Optional.of(-1l));\n            }\n            else {\n                return\
    \ Pair.with(Optional.of(Optional.empty()), Optional.of(-1l));\n            }\n\
    \        }\n        else if (lst.size() == 1) {\n            // Return only single\
    \ element if it is positive\n            return Pair.with(Optional.of(Optional.of(lst.get(0))),\
    \ Optional.of(-1l));\n        }\n\n        // Return empty Optional if not positive\
    \ and negative integers\n        return Pair.with(Optional.of(Optional.empty()),\
    \ Optional.of(-1l));", "        List<Long> positiveIntegersFromList = new ArrayList<>();\n\
    \        List<Long> negativeIntegersFromList = new ArrayList<>();\n\n        for\
    \ (Long number : lst) {\n            if (number >= 0) {\n                positiveIntegersFromList.add(number);\n\
    \            } else {\n                negativeIntegersFromList.add(number);\n\
    \            }\n        }\n        if (positiveIntegersFromList.isEmpty() && negativeIntegersFromList.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        List<Long> maxPositiveIntegersFromList = positiveIntegersFromList.stream().sorted().collect(Collectors.toList());\n\
    \        List<Long> minNegativeIntegersFromList = negativeIntegersFromList.stream().sorted().collect(Collectors.toList());\n\
    \        Pair<Optional<Long>, Optional<Long>> largest = Pair.with(Optional.of(maxPositiveIntegersFromList),\
    \ Optional.of(minNegativeIntegersFromList));\n        Pair<Optional<Long>, Optional<Long>>\
    \ smallest = Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        if (maxPositiveIntegersFromList.equals(maxPositiveIntegersFromList))\
    \ {\n            return largest;\n        }\n        if (minNegativeIntegersFromList.equals(minNegativeIntegersFromList))\
    \ {\n            return smallest;\n        }\n        Optional<Long> maxValue\
    \ = maxPositiveIntegersFromList.isEmpty() ? Optional.empty() : Optional.of(maxPositiveIntegersFromList.get(0));\n\
    \        Optional<Long> minValue = minNegativeIntegersFromList.isEmpty() ? Optional.empty()\
    \ : Optional.of(minNegativeIntegersFromList.get(0));\n        return Pair.with(largest,\
    \ smallest);", "        Optional<Optional<Long>> firstSmall = Optional.empty();\n\
    \        Optional<Optional<Long>> firstLarge = Optional.empty();\n        for\
    \ (Long l : lst) {\n            Optional<Long> small = Optional.of(l);\n     \
    \       Optional<Long> large = Optional.empty();\n            if (-ll < l) {\n\
    \                large = Optional.of(-ll);\n            }\n            if (firstSmall.orElse(Optional.empty())\
    \ == small) {\n                firstSmall = small;\n                firstLarge\
    \ = large;\n            } else {\n                firstSmall = Optional.of(small);\n\
    \                firstLarge = Optional.of(large);\n            }\n        }\n\
    \        if (firstSmall.orElse(Optional.empty()) != firstLarge) {\n          \
    \  return Pair.with(firstSmall, firstLarge);\n        } else {\n            return\
    \ Pair.with(firstSmall, Optional.empty());\n        }", "        ArrayList<Long>\
    \ filteredLst = new ArrayList<>(lst);\n        ArrayList<Long> negative = new\
    \ ArrayList<>();\n        ArrayList<Long> positive = new ArrayList<>();\n\n  \
    \      for (int i = 0; i < filteredLst.size(); i++) {\n            Long element\
    \ = filteredLst.get(i);\n            if (element < 0) {\n                negative.add(element);\n\
    \            } else {\n                positive.add(element);\n            }\n\
    \        }\n\n        if (negative.size() == 0 && positive.size() == 0) {\n  \
    \          return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        if (negative.size() != 0 && positive.size() != 0) {\n  \
    \          Pair<Optional<Long>, Optional<Long>> maxMin = new Pair<>(largest(negative),\
    \ smallest(positive));\n            return Pair.with(maxMin.getLeft(), maxMin.getRight());\n\
    \        }\n\n        if (negative.size() == 0 && positive.size() != 0) {\n  \
    \          return Pair.with(Optional.of(Optional.empty()), smallest(positive));\n\
    \        }\n\n        if (negative.size() != 0 && positive.size() == 0) {\n  \
    \          return Pair.with(largest(negative), Optional.of(Optional.empty()));\n\
    \        }\n\n        if (negative.size() != 0 && positive.size() != 0) {\n  \
    \          Pair<Optional<Long>, Optional<Long>> maxMin = new Pair<>(largest(negative),\
    \ largest(positive));\n            return Pair.with(maxMin.getLeft(), maxMin.getRight());\n\
    \        }\n\n        return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));",
  "        Set<Long> set = new HashSet<Long>(lst);\n        if (set.size() == 0) {\n\
    \            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n\n        // use minMaxIfPresent with default values\n        Optional<Long>\
    \ min = Optional.empty();\n        Optional<Long> max = Optional.empty();\n  \
    \      Optional<Long> posInv = Optional.empty();\n        Optional<Long> negInv\
    \ = Optional.empty();\n        Optional<Long> maxPosInv = Optional.empty();\n\
    \        Optional<Long> maxNegInv = Optional.empty();\n        Optional<Long>\
    \ minPosInv = Optional.empty();\n        Optional<Long> minNegInv = Optional.empty();\n\
    \        for (Long i : set) {\n            if (i > 0) {\n                minPosInv\
    \ = minPosInv.or(i);\n                maxPosInv = maxPosInv.or(i);\n         \
    \   } else {\n                minNegInv = minNegInv.or(i);\n                maxNegInv\
    \ = maxNegInv.or(i);\n            }\n            if (i < 0) {\n              \
    \  posInv = posInv.or(i);\n                maxPosInv = maxPosInv.or(i);\n    \
    \        } else {\n                negInv = negInv.or(i);\n                maxNegInv\
    \ = maxNegInv.or(i);\n            }\n        }\n        return Pair.with(\n  \
    \              minPosInv.map(Optional::of).orElseGet(() -> minNegInv.map(Optional::of).orElseGet(()\
    \ -> maxNegInv.map(Optional::of).orElseGet(() -> maxPosInv.map(Optional::of).orElseGet(Optional.empty())))),\n\
    \                minNegInv.map(Optional::of).orElseGet(() -> minPosInv.map(Optional::of).orElseGet(()\
    \ -> maxPosInv.map(Optional::of).orElseGet(() -> maxNegInv.map(Optional::of).orElseGet(Optional.empty())))));",
  "        List<Integer> ints = lst.stream().filter(i -> i >= 0l).boxed().collect(Collectors.toList());\n\
    \        int minInt = ints.isEmpty() ? Integer.MIN_VALUE : ints.get(0);\n    \
    \    int maxInt = ints.isEmpty() ? Integer.MAX_VALUE : ints.get(ints.size() -\
    \ 1);\n        return Pair.with(Optional.of(Optional.of(minInt)), Optional.of(Optional.of(maxInt)));",
  "        List<Long> positiveIntegers = lst.stream().filter(i->i>=0).collect(Collectors.toList());\n\
    \        List<Long> negativeIntegers = lst.stream().filter(i->i<0).collect(Collectors.toList());\n\
    \        Optional<Long> minPositiveInteger = Collections.min(positiveIntegers);\
    \ // Optional.empty() if not found\n        Optional<Long> maxNegativeInteger\
    \ = Collections.max(negativeIntegers); // Optional.empty() if not found\n    \
    \    return Pair.with(minPositiveInteger, maxNegativeInteger);", "        if (lst.size()\
    \ == 0) {\n            return Pair.with(Optional.empty(), Optional.empty());\n\
    \        }\n        ArrayList<Long> positive = new ArrayList<>();\n        ArrayList<Long>\
    \ negative = new ArrayList<>();\n        Iterator<Long> it = lst.iterator();\n\
    \        Long maxPos = Long.MIN_VALUE, minPos = Long.MAX_VALUE;\n        while\
    \ (it.hasNext()) {\n            Long val = it.next();\n            if (val < 0)\n\
    \                negative.add(val);\n            else\n                positive.add(val);\n\
    \            if (val > maxPos) {\n                maxPos = val;\n            }\n\
    \            if (val < minPos) {\n                minPos = val;\n            }\n\
    \        }\n        if (maxPos == Long.MIN_VALUE) {\n            return Pair.with(Optional.empty(),\
    \ Optional.of(Long.MIN_VALUE));\n        } else if (minPos == Long.MAX_VALUE)\
    \ {\n            return Pair.with(Optional.of(Long.MAX_VALUE), Optional.empty());\n\
    \        } else {\n            return Pair.with(Optional.of(maxPos), Optional.of(minPos));\n\
    \        }", "        if (lst.stream().anyMatch(x -> x < 0)) return null;\n  \
    \      if (lst.stream().allMatch(x -> x > 0l)) return null;\n        return Pair.with(Optional.of(Optional.of(lst.stream().max(Math::max).orElse(0l))),\
    \ Optional.of(Optional.of(lst.stream().min(Math::min).orElse(0l))));", "     \
    \   Optional<Long> largest = findMax(lst);\n        Optional<Long> smallest =\
    \ findMin(lst);\n        if (largest.isPresent()) {\n            return Pair.with(largest,\
    \ smallest);\n        } else {\n            return Pair.with(Optional.empty(),\
    \ Optional.empty());\n        }", "        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        for (Long v : lst) {\n\
    \            Optional<Long> o1 = Optional.of(v < 0);\n            Optional<Long>\
    \ o2 = Optional.of(v > 0);\n            a = a.orElse(o1).map(v -> Math.max(v,\
    \ a.get()));\n            b = b.orElse(o2).map(v -> Math.min(v, b.get()));\n \
    \       }\n        return Pair.with(a, b);", "        List<Optional<Long>> numbers\
    \ = lst.stream().filter(n -> n > 0).collect(toList());\n        Optional<Long>\
    \ largestNumber = numbers.stream().max(Integer::compareTo).map(Integer::valueOf).findAny();\n\
    \        Optional<Long> smallestNumber = numbers.stream().min(Integer::compareTo).map(Integer::valueOf).findAny();\n\
    \        return Pair.of(largestNumber, smallestNumber);", "        Optional<Optional<Long>>\
    \ optA = null;\n        Optional<Long> min = Optional.empty();\n        for (Long\
    \ val : lst) {\n            if (val < min.orElse(val)) {\n                min\
    \ = Optional.of(val);\n                optA = Optional.of(Optional.of(val));\n\
    \            } else if (val > min.orElse(val)) {\n                optA = Optional.of(optA.orElse(Optional.of(val)));\n\
    \            }\n        }\n        return Pair.with(optA, min);", "        //\
    \ The idea is to find out the max and min values from an array\n        // and\
    \ then find the max and min values from the arrayList.\n        // If there is\
    \ no value in the arrayList, then return \n        // Pair.of(Optional.empty(),\
    \ Optional.empty())\n        if (lst.isEmpty()) return Pair.of(Optional.empty(),\
    \ Optional.empty());\n        Optional<Long> max = Optional.of(Long.MIN_VALUE);\n\
    \        Optional<Long> min = Optional.of(Long.MAX_VALUE);\n        for (Long\
    \ value : lst) {\n            if (value < 0) {\n                max = Optional.max(max,\
    \ Optional.of(value));\n            } else if (value > 0) {\n                min\
    \ = Optional.min(min, Optional.of(value));\n            } else {\n           \
    \     max = Optional.max(max, Optional.empty());\n                min = Optional.min(min,\
    \ Optional.empty());\n            }\n        }\n        return Pair.of(max, min);",
  "        Collections.sort(lst);\n        Collections.reverse(lst);\n        Optional<Long>\
    \ max = Optional.empty();\n        Optional<Long> min = Optional.empty();\n  \
    \      for (Long i : lst) {\n            if (i < 0l) {\n                max =\
    \ Optional.of(Optional.of(i));\n                break;\n            }\n      \
    \      if (max != Optional.empty() && max.get() > i) {\n                max =\
    \ Optional.of(Optional.of(i));\n            }\n            if (min != Optional.empty()\
    \ && min.get() < i) {\n                min = Optional.of(Optional.of(i));\n  \
    \          }\n        }\n        if (max == Optional.empty()) {\n            return\
    \ Pair.with(min, Optional.empty());\n        } else {\n            return Pair.with(max,\
    \ min);\n        }", "        Arrays.sort(lst);\n        Optional<Long> first\
    \ = Optional.of(Optional.empty());\n        Optional<Long> second = Optional.of(lst.get(0));\n\
    \        for (int i = 1; i < lst.size(); i++) {\n            if (lst.get(i) <\
    \ lst.get(i-1)) {\n                first = Optional.of(Optional.of(lst.get(i)));\n\
    \            } else {\n                second = Optional.of(Optional.of(lst.get(i)));\n\
    \            }\n        }\n        return Pair.of(first, second);", "        Optional<Long>\
    \ min = null;\n        Optional<Long> max = null;\n        for (Long l : lst)\
    \ {\n            if (l.isNegative()) {\n                if (min == null) {\n \
    \                   min = Optional.empty();\n                    max = Optional.of(l);\n\
    \                } else if (l<min.get()) {\n                    min = Optional.of(l);\n\
    \                }\n            } else if (l.isPositive()) {\n               \
    \ if (max == null) {\n                    min = Optional.of(l);\n            \
    \        max = Optional.empty();\n                } else if (max.get() < l) {\n\
    \                    max = Optional.of(l);\n                }\n            }\n\
    \        }\n        if (min.isPresent() && max.isPresent()) {\n            return\
    \ Pair.with(min,max);\n        }\n        if (min.isPresent()) {\n           \
    \ return Pair.with(min, Optional.of(max.get()));\n        }\n        if (max.isPresent())\
    \ {\n            return Pair.with(Optional.of(max.get()), max);\n        }\n \
    \       return Pair.with(Optional.empty(), Optional.empty());", "        if (lst.isEmpty())\
    \ {\n            return Pair.with(Optional.of(Optional.empty()), Optional.of(Optional.empty()));\n\
    \        }\n        Arrays.sort(lst);\n        if (lst.contains(Long.MIN_VALUE))\
    \ {\n            return Pair.with(Optional.of(Optional.of(Long.MIN_VALUE)), Optional.empty());\n\
    \        }\n        if (lst.contains(Long.MAX_VALUE)) {\n            return Pair.with(Optional.of(Optional.of(Long.MAX_VALUE)),\
    \ Optional.empty());\n        }\n        Optional<Long> a = Optional.empty();\n\
    \        Optional<Long> b = Optional.empty();\n        for (int i = 0; i < lst.size();\
    \ i++) {\n            if (lst.get(i) < 0) {\n                a = Optional.of(lst.get(i));\n\
    \                break;\n            }\n        }\n        for (int i = lst.size()\
    \ - 1; i >= 0; i--) {\n            if (lst.get(i) > 0) {\n                b =\
    \ Optional.of(lst.get(i));\n                break;\n            }\n        }\n\
    \        return Pair.with(a, b);", "        if (lst.size() <= 0) {\n         \
    \   return new Pair<>(Optional.empty(), Optional.empty());\n        }\n      \
    \  \n        Optional<Long> smallest = Optional.empty();\n        Optional<Long>\
    \ largest = Optional.empty();\n        \n        // sort array in descending order\n\
    \        lst.sort(Comparator.reverseOrder());\n        \n        // find minimum\
    \ number\n        for (int i = 0; i < lst.size(); i++) {\n            if (smallest.isPresent())\
    \ {\n                break;\n            }\n            if (lst.get(i) < 0) {\n\
    \                smallest = Optional.of(lst.get(i));\n            }\n        }\n\
    \        \n        // find maximum number\n        for (int i = lst.size() - 1;\
    \ i >= 0; i--) {\n            if (largest.isPresent()) {\n                break;\n\
    \            }\n            if (lst.get(i) > 0) {\n                largest = Optional.of(lst.get(i));\n\
    \            }\n        }\n        \n        return new Pair<>(smallest, largest);",
  "        if (lst.isEmpty()) {\n            return Pair.of(Optional.empty(), Optional.empty());\n\
    \        }\n        Comparator<Long> cmp = Comparator.reverseOrder();\n      \
    \  ArrayList<Long> lst2 = new ArrayList<>(lst);\n        Collections.sort(lst2,\
    \ cmp);\n        boolean hasNegative = false;\n        boolean hasPositive = false;\n\
    \        Long maxNegative = null, minPositive = null;\n        for (int i = 0;\
    \ i < lst2.size(); i++) {\n            if (lst2.get(i) < 0) {\n              \
    \  hasNegative = true;\n                maxNegative = lst2.get(i);\n         \
    \   } else {\n                hasPositive = true;\n                minPositive\
    \ = lst2.get(i);\n            }\n        }\n        if (hasNegative && hasPositive)\
    \ {\n            return Pair.of(Optional.of(maxNegative), Optional.of(minPositive));\n\
    \        } else if (hasNegative) {\n            return Pair.of(Optional.of(maxNegative),\
    \ Optional.empty());\n        } else if (hasPositive) {\n            return Pair.of(Optional.empty(),\
    \ Optional.of(minPositive));\n        } else {\n            return Pair.of(Optional.of(null),\
    \ Optional.of(null));\n        }", "        ArrayList<Long> neg = new ArrayList<>();\n\
    \        ArrayList<Long> pos = new ArrayList<>();\n        for (long i : lst)\
    \ {\n            if (i < 0l) {\n                neg.add(i);\n            } else\
    \ {\n                pos.add(i);\n            }\n        }\n\n        Pair<Optional<Long>,\
    \ Optional<Long>> pair = Pair.with(largest(neg), smallest(pos));\n        return\
    \ pair;"]
stop_tokens:
- "\n    }\n"
