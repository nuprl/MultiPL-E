name: HumanEval_18_how_many_times
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Find how many times a given substring can be found in the\
  \ original string. Count overlaping cases.\n    // >>> howManyTimes((\"\"), (\"\
  a\"))\n    // (0l)\n    // >>> howManyTimes((\"aaa\"), (\"a\"))\n    // (3l)\n \
  \   // >>> howManyTimes((\"aaaa\"), (\"aa\"))\n    // (3l)\n    public static long\
  \ howManyTimes(String string, String substring) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(howManyTimes((\"\
  \"), (\"x\")) == (0l));\n    assert(howManyTimes((\"xyxyxyx\"), (\"x\")) == (4l));\n\
  \    assert(howManyTimes((\"cacacacac\"), (\"cac\")) == (4l));\n    assert(howManyTimes((\"\
  john doe\"), (\"john\")) == (1l));\n    }\n\n}\n"
completions: ["        // write your code\n        long total = 0;\n        for(int\
    \ i = 0; i < string.length(); i++) {\n            if(string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                total++;\n            }\n        }\n        return total;",
  "        if (string == null || substring == null) {\n            throw new IllegalArgumentException(\"\
    null string\");\n        }\n        final int substringLength = substring.length();\n\
    \        if (string.length() < substringLength) {\n            return 0;\n   \
    \     }\n        char[] charArray = string.toCharArray();\n        Arrays.sort(charArray);\n\
    \        char[] charArraySub = substring.toCharArray();\n        Arrays.sort(charArraySub);\n\
    \        int count = 0;\n        int i = 0;\n        int j = 0;\n        while\
    \ (i < charArray.length && j < charArraySub.length) {\n            if (charArray[i]\
    \ == charArraySub[j]) {\n                i++;\n                j++;\n        \
    \    } else {\n                if (charArray[i] == charArraySub[j]) {\n      \
    \              count += 1;\n                    i++;\n                } else {\n\
    \                    if (i < charArray.length && j < charArraySub.length) {\n\
    \                        if (charArray[i] == charArraySub[j]) {\n            \
    \                count += 1;\n                            i++;\n             \
    \           } else {\n                            if (i < charArray.length &&\
    \ j > 0) {\n                                count += 1;\n                    \
    \            i++;\n                            } else {\n                    \
    \            count += 1;\n                                j--;\n             \
    \               }\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        return count;", '        return
    string.toUpperCase().split(substring).length - string.split(substring).length;',
  '        return string.chars().filter(x -> x==substring.charAt(0)).filter(x -> x==substring.charAt(substring.length()-1)).count();',
  "        long numSubStrings = 0;\n        Set<String> substringSet = new HashSet<>(Arrays.asList(substring.split(\"\
    \")));\n\n        for (String str : string.split(\"\")) {\n            if (str.equals(substring)\
    \ || substringSet.contains(str)) {\n                numSubStrings += 1;\n    \
    \        }\n        }\n        return numSubStrings;", "        if (string.isEmpty()\
    \ || substring.isEmpty()) {\n            return 0l;\n        }\n        long start\
    \ = 0;\n        long end = 0;\n        char[] chars = string.toCharArray();\n\
    \        char[] substrings = substring.toCharArray();\n        start = Arrays.binarySearch(chars,\
    \ substrings, 0, substrings.length);\n        if (start < 0) {\n            start\
    \ = (~start) + 1;\n        }\n        end = start + substrings.length - 1;\n \
    \       end = Arrays.binarySearch(chars, substrings, start, end);\n        if\
    \ (end < 0) {\n            end = start + substrings.length - 1;\n        }\n \
    \       return end - start + 1;", "        return IntStream.range(0,string.length())\n\
    \            .filter(i -> string.substring(0,i).contains(substring))\n       \
    \     .count();", '        return string.substring(string.indexOf(substring) +
    1).replaceAll(substring, (char) 0);', "        long answer = 0l;\n        for\
    \ (String s: string.split(substring)) {\n            answer = answer + s.length();\n\
    \        }\n        return answer;", '        return string.chars().filter(e ->
    e == substring.charAt(0)).count();', "        long result = 0;\n        int i\
    \ = 0;\n        if (string.length() < substring.length()) {\n            for (;\
    \ i < substring.length(); i++) {\n                result += howManyTimes(string.substring(0,\
    \ i + 1), substring);\n            }\n        }\n        if (string.equals(substring))\
    \ {\n            return 1;\n        }\n        if (string.substring(string.length()\
    \ - substring.length()).equals(substring)) {\n            return 1;\n        }\n\
    \        int j = 0;\n        for (; j < string.length() && j < substring.length();\
    \ j++) {\n            int k = string.indexOf(substring, j);\n            while\
    \ (k > 0 && k < string.length()) {\n                k = string.indexOf(substring,\
    \ k + 1);\n            }\n            if (k != -1) {\n                result +=\
    \ howManyTimes(string.substring(0, j + 1), substring);\n                j = k;\n\
    \            }\n        }\n        return result;", "        long count = 0;\n\
    \n        // Step 1: count characters in substring\n        int countSubString\
    \ = string.split(substring).length;\n\n        // Step 2: count characters in\
    \ the whole string\n        int countString = string.length();\n\n        // Step\
    \ 3: count overlaping characters\n        for (int i = 0; i < countString; i++)\
    \ {\n            for (int j = i + 1; j < countString; j++) {\n               \
    \ if (string.charAt(i) == string.charAt(j)) {\n                    count++;\n\
    \                }\n            }\n        }\n\n        // Step 4: Return count\n\
    \        return count;", "        long result = Long.MAX_VALUE;\n        if (string.isEmpty()\
    \ || substring.isEmpty()) return result;\n        Set<String> subset = new HashSet<String>();\n\
    \        subset.add(substring);\n        String lastSubstring = substring;\n \
    \       for (String part : string.split(\"(?<=\\\\G.{\" + substring.length() +\
    \ \",})\")) {\n            Set<String> newSubset = new HashSet<String>();\n  \
    \          newSubset.add(part);\n            if (!subset.equals(newSubset)) {\n\
    \                lastSubstring = part;\n                subset = newSubset;\n\
    \            }\n        }\n        if (!subset.equals(new HashSet<String>()))\
    \ {\n            result += subset.size() - substring.split(\"(?<=\\\\G.{\" + substring.length()\
    \ + \",})\").length;\n        }\n        return result;", "        if (string\
    \ == null || string.isEmpty()) return 0L;\n        if (substring == null || substring.isEmpty())\
    \ return 0L;\n        long count=0L;\n        for(int i=0;i<string.length();i++)\
    \ {\n            if (string.substring(i, i+substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        List<String> list = Arrays.asList((string).split(substring));\n       \
    \ return list.stream().map(s -> s.split(\"\")).flatMap(Arrays::stream).count();",
  '        return string.length() * substring.length();', "        long result = 1;\n\
    \        for(int pos = 0; pos < string.length(); pos++) {\n            if (string.substring(pos).contains(substring))\
    \ {\n                result *= substring.length();\n            }\n        }\n\
    \        return result;", "        long count = string.length() - substring.length();\n\
    \        if (string.length() > substring.length()) {\n            count = howManyTimes(substring,\
    \ string.substring(0, substring.length()));\n        }\n        return count;",
  "        long count = 0l;\n        int i = 0;\n        boolean subStringMatched\
    \ = false;\n        while (i < string.length() && !subStringMatched) {\n     \
    \       count = count + string.indexOf(substring, i) + string.lastIndexOf(substring,\
    \ i);\n            if (string.indexOf(substring, i) > 0) {\n                subStringMatched\
    \ = true;\n                i++;\n            }\n            else {\n         \
    \       i++;\n            }\n        }\n        if (subStringMatched) {\n    \
    \        count++;\n        }\n        return count;", "        if (string == null\
    \ || substring == null) {\n            return 0l;\n        }\n        long cnt\
    \ = 0l;\n        int start = 0;\n        int end = string.length() - substring.length();\n\
    \        while (start < end) {\n            int m = Math.max(Math.min(start +\
    \ substring, end), start);\n            cnt += string.regionMatches(true, m, m,\
    \ substring, 0, substring.length());\n            start = m + 1;\n        }\n\
    \        return cnt;", "        // Create two indexes - one for each of our substrings.\n\
    \        int[] firstIndex = new int[substring.length()];\n        int[] secondIndex\
    \ = new int[substring.length()];\n        // Scan both indexes from 0 to length\
    \ of substring and count the occurrences of each character.\n        for (int\
    \ i = 0; i < firstIndex.length; i++) {\n            for (int j = 0; j < secondIndex.length;\
    \ j++) {\n                if (string.charAt(i) == substring.charAt(j)) {\n   \
    \                 firstIndex[i]++;\n                    secondIndex[j]++;\n  \
    \              }\n            }\n        }\n\n        // If the first occurrence\
    \ of the second substring is larger than the first, swap the two indices.\n  \
    \      if (firstIndex[secondIndex.length - 1] > firstIndex[secondIndex.length\
    \ - 2]) {\n            int tempFirstIndex = firstIndex[secondIndex.length - 1];\n\
    \            firstIndex[secondIndex.length - 1] = firstIndex[secondIndex.length\
    \ - 2];\n            firstIndex[secondIndex.length - 2] = tempFirstIndex;\n  \
    \      }\n\n        // Return the total length of occurrences of the substring.\n\
    \        return firstIndex[secondIndex.length - 1];", '        return count(string,
    substring, String.valueOf(string.indexOf(substring))).sum();', '        return
    howManyTimes(string.toLowerCase(), substring.toLowerCase());', '        return
    findSubStringMatches(string, substring).count();', '        return string.length()
    - string.replace(substring, "").length();', "        long count = 0;\n       \
    \ int len = string.length();\n        int slen = substring.length();\n       \
    \ if (len == 0) {\n            count = slen;\n        }\n        if (len > slen)\
    \ {\n            count = slen;\n        }\n        if (slen == 0) {\n        \
    \    count = 1;\n        }\n        int pos = 0;\n        boolean match = false;\n\
    \        while (pos < len) {\n            if (string.charAt(pos) == substring.charAt(0))\
    \ {\n                count++;\n                pos += 1;\n                match\
    \ = true;\n                while (pos < len && string.charAt(pos) == substring.charAt(slen\
    \ - 1)) {\n                    pos++;\n                    count++;\n        \
    \            match = true;\n                }\n                if (pos == len\
    \ || !match) {\n                    pos = len;\n                }\n          \
    \  } else {\n                pos = len;\n            }\n        }\n        return\
    \ count;", '        return howManyTimes(Arrays.asList(string), Arrays.asList(substring));',
  "        long cnt = 0;\n\n        // Loop through all possible start indices\n \
    \       for (int start = 0; start < string.length() - substring.length() + 1;\
    \ ++start) {\n            // Find all possible end indices\n            for (int\
    \ end = start + 1; end < string.length(); ++end) {\n                // Get substring\n\
    \                String substring2 = string.substring(start, end);\n\n       \
    \         // If substring is same as requested substring\n                if (substring\
    \ == substring2) {\n                    // Increase count\n                  \
    \  ++cnt;\n                }\n            }\n        }\n\n        return cnt;",
  "        long times = string.length() - string.replaceAll(\"(?i)\" + substring,\
    \ \"_\").length();\n        if (string.length() == substring.length()) {\n   \
    \         return times;\n        }\n        if (string.contains(substring)) {\n\
    \            return times + howManyTimes(string.substring(0, string.length() -\
    \ substring.length()), substring);\n        }\n        return times + howManyTimes(string.substring(0,\
    \ string.length() - substring.length()), substring + string.substring(string.length()\
    \ - substring.length()));", "        if (string.contains(substring)) {\n     \
    \       return string.split(substring, -1).length - 1;\n        }\n\n        long\
    \ totalTimes = string.length();\n        long index = string.indexOf(substring);\n\
    \n        if (index != -1) {\n            while (index != -1) {\n            \
    \    index = string.indexOf(substring, index + 1);\n                totalTimes++;\n\
    \            }\n        }\n        return totalTimes;", "        long count =\
    \ 0; // Keep a count of how much time the substring occurs in the main string\n\
    \        // Go through each character in the main string\n        for (char c\
    \ : string.toCharArray()) {\n            // If the character matches the substring,\
    \ increase the count\n            if (c.equals(substring)) {\n               \
    \ count++; // Increment the count by 1\n            }\n        }\n        // Return\
    \ the result\n        return count;", "        int count[] = new int[256];\n \
    \       int pos = 0;\n        while (pos < string.length()) {\n            count[string.charAt(pos)]++;\n\
    \            pos += substring.length();\n        }\n        int ans = 0;\n   \
    \     for (int i = 0; i < (substring == null ? 0 : string.length()); i++) {\n\
    \            ans += count[string.charAt(i)];\n        }\n        return ans;",
  "        long count = 0L;\n        substring = string.toUpperCase().toUpperCase().toUpperCase().substring(substring.length());\n\
    \        if (string.toUpperCase().toUpperCase().toUpperCase().indexOf(substring)\
    \ == -1) {\n            return count;\n        }\n        int lastIndex = string.toUpperCase().toUpperCase().toUpperCase().indexOf(substring);\n\
    \        for (int i = 0; i < substring.length(); i++) {\n            int startIndex\
    \ = lastIndex;\n            lastIndex += substring.length();\n            if (lastIndex\
    \ >= string.toUpperCase().toUpperCase().toUpperCase().length()) {\n          \
    \      lastIndex = string.toUpperCase().toUpperCase().toUpperCase().length() -\
    \ 1;\n            }\n            if (startIndex == string.toUpperCase().toUpperCase().toUpperCase().indexOf(substring,\
    \ lastIndex)) {\n                count++;\n            }\n        }\n        return\
    \ count;", "        long count = 0;\n        for (int i = 0; i < string.length()\
    \ - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        Set<String> set = new HashSet<>();\n        for (int i = 0; i < string.length();\
    \ i++) {\n            if (string.charAt(i) == substring.charAt(0)) {\n       \
    \         for (int j = 1; j < substring.length(); j++) {\n                   \
    \ if (string.charAt(i) == substring.charAt(j)) {\n                        set.add(i+\"\
    \");\n                    }\n                }\n            }\n        }\n   \
    \     return set.size();", '        return howManyTimes(new Tuple (string, substring));',
  "        long count = 1;\n        for (char c : string.toCharArray()) {\n      \
    \      if (c == substring.charAt(0)) {\n                for (char i : string.toCharArray())\
    \ {\n                    if (c == substring\n                        .substring(1)\n\
    \                        .charAt(0)) {\n                        count += howManyTimes(\n\
    \                            string.substring(1)\n                           \
    \     .substring(0, i)\n                                .concat(string.substring(0,\
    \ i + 1)),\n                            substring\n                          \
    \      .substring(1)\n                                .charAt(0));\n         \
    \           }\n                }\n            }\n        }\n        return count;",
  "        \n        // Create a set of characters in the input string that match\
    \ the given substring\n        Set<Character> charSet = new HashSet<>(string.toLowerCase().chars().filter(i\
    \ -> substring.contains(i)).collect(Collectors.toList()));\n        \n       \
    \ // Count how many times each character in string matches the given substring\
    \ by finding the intersection of each character in the input string and the substring.\n\
    \        return string.chars().filter(i -> substring.contains(i))\n          \
    \              .map(i -> String.valueOf(string.charAt(i)).equals(substring) ?\
    \ 1 : 0)\n                        .filter(i -> charSet.contains(i))\n        \
    \                .count();", "        // Create a stream of the string to search.\
    \ Ignore case to make the search case-insensitive.\n        Stream<Character>\
    \ stream = string.chars().mapToObj(c -> (char)c).map(String::toLowerCase);\n \
    \       // Create a stream of the substring. Ignore case to make the search case-insensitive.\n\
    \        Stream<Character> substringStream = substring.chars().mapToObj(c -> (char)c).map(String::toLowerCase);\n\
    \        // Count the number of occurences in the substring.\n        return stream.filter(s\
    \ -> substringStream.anyMatch(s2 -> s.equals(s2)))\n                    .count();",
  '        return howManyTimes(new char[] { string.toLowerCase().charAt(0) }, substring.toLowerCase().toCharArray());',
  '        return stringToLong(stringToArray(string).findAll(substring).size());',
  '        return string.split(substring, -1).length - 1;', "        if (string.equals(substring))\
    \ {\n            return 1;\n        }\n        if (string.indexOf(substring) ==\
    \ -1) {\n            return 0;\n        }\n        return 1 + howManyTimes(string.substring(0,\
    \ string.indexOf(substring)), substring);", "        long count = 0;\n       \
    \ if (string == null || substring == null) {\n            throw new IllegalArgumentException(\"\
    string and substring should be not null.\");\n        }\n        long start =\
    \ 0;\n        long end = string.length() - substring.length();\n        while\
    \ ((end >= 0) && (start < end)) {\n            if ((string.regionMatches(substring,\
    \ start, string, 0, substring.length()))) {\n                count++;\n      \
    \      }\n            start++;\n            end--;\n        }\n        return\
    \ count;", "        // Return 0 if string and substring are the same string\n\
    \        if (string.equals(substring)) {\n            return 0;\n        }\n \
    \       long count = 0;\n        CharSequence seq1 = string.toCharArray();\n \
    \       CharSequence seq2 = substring.toCharArray();\n        // Loop over each\
    \ character of string, compare to substring\n        for (int i = 0; i < seq1.length;\
    \ i++) {\n            if (seq1[i] == seq2[i]) {\n                count++;\n  \
    \          }\n        }\n        // If count is zero string contains substring\n\
    \        if (count == 0) {\n            count = 1;\n        }\n        // Return\
    \ count of substring in string\n        return count;", '        return string.split(substring).length();',
  "        final Pattern pattern = Pattern.compile(substring);\n        final Matcher\
    \ matcher = pattern.matcher(string);\n        long count = 0;\n        int start\
    \ = 0;\n        int end = 0;\n        while (matcher.find()) {\n            end\
    \ = matcher.end();\n            count += (end - start);\n            start = end\
    \ + 1;\n        }\n        return count;", "        Long count = 0L;\n       \
    \ for (String s : string.split(substring)) {\n            count += String.valueOf(s).contains(substring)\
    \ ? 1 : 0;\n        }\n        return count;", "        Set<String> set = substring.chars().mapToObj(i\
    \ -> \"a\").collect(Collectors.toSet());\n        int count = 0;\n        for\
    \ (char c : string.toCharArray()) {\n            if (set.contains(Character.toString(c)))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        long count = 0;\n        for (String letter : string.split(substring))\
    \ {\n            if (substring.contains(letter)) {\n                ++count;\n\
    \            }\n        }\n        return count;", '        return howManyTimes(Arrays.asList(string),
    Arrays.asList(substring));', "        long count = 0;\n        int pos = 0;\n\
    \        int start = 0;\n        pos = string.indexOf(substring, start);\n   \
    \     while (pos != -1) {\n            if (pos > start) {\n                count++;\n\
    \            }\n            start = pos + 1;\n            pos = string.indexOf(substring,\
    \ start);\n        }\n        return count;", "        // return howManyTimes(string.toLowerCase(),\
    \ substring.toLowerCase());\n        // return howManyTimes(string.toUpperCase(),\
    \ substring.toUpperCase());\n        \n        if (string.isEmpty() || substring.isEmpty())\
    \ {\n            return 0;\n        }\n        \n        int index = string.indexOf(substring);\n\
    \        if (index >= 0) {\n            if (index == 0) {\n                return\
    \ 1;\n            }\n            \n            int length = substring.length();\n\
    \            String substringLowerCase = substring.toLowerCase();\n          \
    \  int count = 0;\n            \n            while (index >= 0) {\n          \
    \      \n                count++;\n                index = string.indexOf(substring,\
    \ index + length);\n            }\n            return count;\n        }\n    \
    \    \n        return 0;", "        // Use String.contains() as a cheap way of\
    \ counting how many times a substring occurs in a string.\n        return string.contains(substring);",
  "        Map<Character, Integer> count = new HashMap<Character, Integer>();\n  \
    \      int len = string.length();\n        int sublen = substring.length();\n\
    \        int max = len - sublen + 1;\n        for (int i = 0; i < max; i++) {\n\
    \            String s = string.substring(0, i + sublen);\n            if (count.containsKey(s.charAt(0)))\
    \ {\n                int count = count.get(s.charAt(0));\n                count\
    \ = count + 1;\n                count.put(s.charAt(1), count);\n            }\
    \ else {\n                count.put(s.charAt(0), 1);\n            }\n        }\n\
    \        return count.entrySet().stream().filter(entry -> substring.startsWith(entry.getKey())).count();",
  "        Set<Character> stringSet = HashSet<Character>(string.length());\n     \
    \   for (char character : string.toCharArray())\n            stringSet.add(character);\n\
    \        \n        Set<Character> substringSet = HashSet<Character>(substring.length());\n\
    \        for (char character : substring.toCharArray())\n            substringSet.add(character);\n\
    \        \n        return string.chars().filter(character -> stringSet.contains(character))\n\
    \            .filter(character -> substringSet.contains(character))\n        \
    \    .count();", "        if (string.length() == 0 || substring.length() == 0)\
    \ {\n            return 0l;\n        }\n\n        if (string.indexOf(substring)\
    \ != -1) {\n            return 1l;\n        }\n\n        long count = 0;\n\n \
    \       for (int i = 0; i < string.length(); ++i) {\n            if (string.regionMatches(true,\
    \ i, substring, 0, substring.length())) {\n                count++;\n        \
    \    }\n        }\n\n        return count;", "        long count = Long.MAX_VALUE;\n\
    \        substring = substring.intern();\n        for (String aString : string.split(substring))\
    \ {\n            count += 1;\n        }\n        return count;", "        long\
    \ count = 0;\n        int startIndex = 0;\n        int endIndex = 0;\n       \
    \ int currentIndex = 0;\n        while (currentIndex < string.length()) {\n  \
    \          endIndex = string.indexOf(substring, currentIndex);\n            if\
    \ (endIndex > -1) {\n                count = count + endIndex - startIndex + 1;\n\
    \                startIndex = endIndex + 1;\n                currentIndex = endIndex\
    \ + 1;\n            } else {\n                currentIndex = string.length();\n\
    \            }\n        }\n        return count;", "        if (string == null\
    \ || string.isEmpty()) return 0;\n        if (substring == null || substring.isEmpty())\
    \ return 0;\n        if (string.indexOf( substring ) == -1) return 0;\n      \
    \  return string.indexOf( substring ) - string.lastIndexOf( substring ) + 1;",
  '        return howManyTimes(Arrays.asList(string), Arrays.asList(substring));',
  "        String caseInsensitiveSubstring = substring.substring(0, 1).toUpperCase()\
    \ + substring.substring(1).toLowerCase();\n        long count = 0;\n        if\
    \ (string.length() == 0) {\n            return count;\n        }\n        string\
    \ = string.trim();\n        if (string.equals(substring)) {\n            return\
    \ 1;\n        }\n        if (string.length() == substring.length()) {\n      \
    \      return 1;\n        }\n        for (int i = 0; i < string.length(); i++)\
    \ {\n            if (string.substring(i, i + substring.length()).equals(caseInsensitiveSubstring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        int start = 0;\n        int end = 0;\n        while (start <= string.length()\
    \ - substring.length()) {\n            end = start + substring.length();\n   \
    \         if (string.substring(start, end).equals(substring)) {\n            \
    \    return ((long) 1l);\n            }\n            start++;\n        }\n   \
    \     return 0l;", "        Set<Character> chars = string.chars().mapToObj(c ->\
    \ (char) c).collect(Collectors.toSet());\n        return chars.stream().filter(c\
    \ -> c.equals(substring)).collect(Collectors.toSet()).size();", "        long\
    \ result = 0;\n        for (int i = 0; i < string.length(); i++) {\n         \
    \   long count = 0;\n            String currentSubstring = string.substring(i,\
    \ i + substring.length());\n            if (currentSubstring.equals(substring))\
    \ {\n                count++;\n            }\n            for (int j = i + 1;\
    \ j < string.length(); j++) {\n                String nextSubstring = string.substring(j,\
    \ j + substring.length());\n                if (currentSubstring.equals(nextSubstring))\
    \ {\n                    count++;\n                }\n            }\n        \
    \    result += (count > 1 ? count : 0);\n        }\n        return result;", '        return
    string.length() - substring.length() + string.indexOf(substring) + string.substring(string.indexOf(substring)).indexOf(substring)
    + string.substring(string.indexOf(substring)).indexOf(substring) + 1;', "    \
    \    long count = 0;\n        \n        for (String c : string.split(\"\")) {\n\
    \            if (c.equals(substring)) count++;\n        }\n        \n        return\
    \ count;", "        return string\n                .chars()\n                .filter(c\
    \ -> c == substring.charAt(0))\n                .map(c -> String.format(\"%07d\"\
    , c + 1).charAt(0))\n                .mapToLong(Integer::parseInt)\n         \
    \       .sum();", '        return string.substring(0, string.length() - substring.length()).replaceAll(substring,
    "").length();', "        // Find length of substring and string\n        int len\
    \ = substring.length();\n        int stringLen = string.length();\n        //\
    \ Create an array of size stringLen\n        int[] charArray = new int[stringLen];\n\
    \        // Populate array with count of substring occurences\n        for (int\
    \ i = 0; i < stringLen; i++) {\n            // Get char at position i of string\n\
    \            char c = string.charAt(i);\n            // Increment count of char\
    \ c at position i of string\n            charArray[c]++;\n        }\n        //\
    \ Find count of occurence of substring\n        long count = 0;\n        for (int\
    \ i = 0; i < len; i++) {\n            // Get char at position i of substring\n\
    \            char c = substring.charAt(i);\n            // If character c in array\
    \ of substrings\n            if (charArray[c] > 0) {\n                // Increment\
    \ count of character c\n                count++;\n            }\n        }\n \
    \       // Return result\n        return count;", "        if (string.trim().isEmpty()\
    \ || substring.trim().isEmpty())\n            return 0;\n        char[] stringCharArray\
    \ = string.toCharArray();\n        char[] substringCharArray = substring.toCharArray();\n\
    \        Arrays.sort(stringCharArray);\n        Arrays.sort(substringCharArray);\n\
    \        if (stringCharArray.length < substring.length())\n            return\
    \ 0;\n        ArrayList <Character> stringList = Arrays.asList(stringCharArray);\n\
    \        ArrayList <Character> substringList = Arrays.asList(substringCharArray);\n\
    \        boolean isFirst = true;\n        int count = 0;\n        int i = 0;\n\
    \        for (; substringList.size() > i; i++){\n            if (stringList.get(i)\
    \ != substringList.get(i))\n                count++;\n            else if (isFirst)\n\
    \                isFirst = false;\n        }\n        long l = count * (stringList.size()\
    \ - substringList.size());\n        l = l / substringList.size();\n        if\
    \ (l == 0 && substringList.size() != stringList.size())\n            l += (long)\
    \ stringList.size();\n        return l;", "        long sum = 0;\n        for\
    \ (int i = 0; i < string.length(); i++) {\n            int index = string.indexOf(substring,\
    \ i);\n            if (index != -1) {\n                sum += index - i + 1;\n\
    \                i = index + substring.length();\n            }\n        }\n \
    \       return sum;", "        long totalCount = 0;\n        for(String word :\
    \ string.split(\" \")) {\n            if(word.equals(substring)) {\n         \
    \       totalCount++;\n            }\n        }\n        return totalCount;",
  "        Set<String> set = new HashSet<>();\n        int count = 0;\n        for\
    \ (String s : string.split(substring)) {\n            if (!set.add(s)) {\n   \
    \             count++;\n            }\n        }\n        return count;", "  \
    \      long result = 0;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                if\
    \ (string.charAt(i + substring.length() - 1) == substring.charAt(substring.length()\
    \ - 1)) {\n                    result += 1;\n                } else {\n      \
    \              result += howManyTimes(string.substring(i + 1, i + substring.length()),\
    \ substring);\n                }\n            }\n        }\n        return result;",
  '        return string.split(substring).length;', "        String newString = string.replaceAll(\"\
    [^\" + substring + \"]\", \"\");\n        long sum = 0;\n        for (String s\
    \ : newString.split(substring)) {\n            sum += s.length();\n        }\n\
    \        return sum;", "        long countSubstring = 0;\n        if (string ==\
    \ null || substring == null)\n            return 0;\n        if (string.length()\
    \ == 0)\n            return countSubstring;\n\n        // find the length of substring\n\
    \        int firstIndex = string.indexOf(substring);\n        if (firstIndex ==\
    \ -1) {\n            return countSubstring;\n        }\n\n        // keep track\
    \ of length of substring\n        int length = substring.length();\n\n       \
    \ // walk through original string and keep track of how many times the substring\
    \ appears\n        StringBuilder sb = new StringBuilder(string);\n        for\
    \ (int i = firstIndex; i < string.length(); i++) {\n            char c = string.charAt(i);\n\
    \            if (sb.indexOf(substring, i) == i) {\n                sb.deleteCharAt(i);\n\
    \                countSubstring++;\n            }\n        }\n        return countSubstring;",
  "        int startIndex = string.indexOf(substring);\n        return startIndex\
    \ == -1 ? 0 : 1 + howManyTimes(string.substring(startIndex + substring.length()),\
    \ substring);", "        long count = 0, pos = 0;\n        while (true) {\n  \
    \          pos = string.indexOf(substring, pos);\n            if (pos == -1) return\
    \ count;\n            count++;\n            pos += substring.length();\n     \
    \   }", "        long count = 0;\n        for (int i = 0; i <= string.length()\
    \ - substring.length(); i++) {\n            if (string.regionMatches(true, i,\
    \ substring, 0, substring.length())) {\n                count++;\n           \
    \ }\n        }\n        return count;", "        long count = 0L;\n        for\
    \ (char c : string.toCharArray()) {\n            if (string.startsWith(substring))\
    \ {\n                count += 1;\n            }\n            if (string.endsWith(substring))\
    \ {\n                count += 1;\n            }\n            if (string.contains(substring))\
    \ {\n                count += 1;\n            }\n        }\n        return count;",
  "        long[] arr = new long[string.length() + substring.length()];\n        char[]\
    \ chars = string.toCharArray();\n        char[] subChars = substring.toCharArray();\n\
    \        for (int i = 0; i < chars.length; i++) {\n            for (int j = 0;\
    \ j < subChars.length; j++) {\n                if (chars[i] == subChars[j])\n\
    \                    arr[i + j] = 1;\n            }\n        }\n        return\
    \ IntStream.range(0, arr.length)\n                .filter(i -> arr[i] == 1)\n\
    \                .count();", "        Map<Character, Long> map = string.chars().boxed().collect(Collectors.toMap(c\
    \ -> c, c -> 1l, (c1, c2) -> c1 + c2));\n        map.putAll(substring.chars().boxed().collect(Collectors.toMap(c\
    \ -> c, c -> 1l, (c1, c2) -> c1 + c2)));\n        return map.entrySet().stream().filter(e\
    \ -> e.getValue() > 1).count();", "        if (string.isEmpty() || string.length()\
    \ == 0 || substring.isEmpty() || substring.length() == 0)\n            throw new\
    \ IllegalArgumentException(\"String length should be more than 0\");\n       \
    \ if (string.indexOf(substring) == -1)\n            throw new IllegalArgumentException(\"\
    String doesn't contain substring\");\n        long numOfMatches = 0;\n       \
    \ StringBuilder sb = new StringBuilder(string);\n        while (sb.indexOf(substring)\
    \ > -1) {\n            sb.delete(0, sb.indexOf(substring) + substring.length());\n\
    \            numOfMatches++;\n        }\n        return numOfMatches;", "    \
    \    long result = 1;\n        for (int i = 0; i < string.length() && i < substring.length();\
    \ i++) {\n            if (string.charAt(i) == substring.charAt(i)) result++;\n\
    \        }\n        return result;", '        return howManyTimes(string, substring,
    0);', "        if (string.length() == 0) {\n            return 0;\n        }\n\
    \n        int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                count++;\n\
    \            } else {\n                count = 0;\n            }\n           \
    \ if (string.charAt(i) == substring.charAt(1)) {\n                count += howManyTimes(string.substring(1,\
    \ i + 1), substring);\n            }\n        }\n        return count;", "   \
    \     if (string.isEmpty() || substring.isEmpty()) return 0;\n        \n     \
    \   // Convert string to char array and sort by length\n        char[] charArray\
    \ = string.toCharArray();\n        Arrays.sort(charArray);\n        \n       \
    \ // Find index of a substring within this array\n        int index = Arrays.binarySearch(charArray,\
    \ substring);\n        \n        // If substring is not found, return 0\n    \
    \    if (index == -1) return 0;\n        \n        // If substring is found, return\
    \ the size of the original string minus length of substring + 1\n        return\
    \ (charArray.length - index - substring.length) + 1;", '        return string.chars().filter(c
    -> c == substring.charAt(0)).filter(c -> c == substring.charAt(1)).count();',
  '        return Arrays.stream(string.toLowerCase(Locale.ROOT).split(substring.toLowerCase(Locale.ROOT))).filter(i
    -> i.length() > 0).count();', "        long count = 1l;\n        for (int i =\
    \ 0; i < string.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring))\
    \ {\n                count += 1;\n            }\n        }\n        return count;",
  "        if (string == null || substring == null) return 0l;\n        \n       \
    \ // Find occurrences of substring\n        long occurences = 0;\n        long\
    \ pos = 0;\n        \n        int l = string.length();\n        \n        while\
    \ ((pos = string.indexOf(substring, pos)) != -1) {\n            occurences++;\n\
    \            pos = pos + substring.length();\n        }\n        \n        return\
    \ occurences;", "        Map<String, String> map = new HashMap<String, String>();\n\
    \        final long minChars = substring.length();\n        for (String letter\
    \ : string.split(\"\")) {\n            map.put(letter, map.get(letter) == null\
    \ ? 1 : map.get(letter) + 1);\n        }\n        long count = 0;\n        for\
    \ (String letter : substring.split(\"\")) {\n            String value = map.get(letter);\n\
    \            if (value == null || value.length() < minChars)\n               \
    \ throw new RuntimeException(\"Invalid letter \" + letter);\n            if (value.length()\
    \ > minChars)\n                count += value.length() - minChars;\n        }\n\
    \        return count;", "        // return howManyTimes((\"\"), substring);\n\
    \        return howManyTimes(string.chars(), substring.chars(), 0);", "      \
    \  long count = 0;\n        long index = 0;\n        while(index != string.length())\
    \ {\n            if(string.charAt(index) == substring.charAt(0)) {\n         \
    \       count += (string.charAt(index) == substring.charAt(0));\n            }\n\
    \            else if(string.charAt(index) != substring.charAt(0)) {\n        \
    \        count += (string.charAt(index) != substring.charAt(0));\n           \
    \ }\n            else {\n                index++;\n            }\n        }\n\
    \        return count;", "        if (string == null || substring == null) return\
    \ 0;\n        long matches = 0;\n        int i = 0;\n        int j = 0;\n    \
    \    int count = 0;\n        while (j < string.length()) {\n            if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                count++;\n            }\n       \
    \     j++;\n            if (j >= substring.length()) {\n                i++;\n\
    \                j = 0;\n            }\n        }\n        matches += count;\n\
    \        return matches;", "        long count = 0;\n        if (string == null\
    \ || string.isEmpty()) {\n            return 0;\n        }\n        if (substring\
    \ == null || substring.isEmpty()) {\n            return count;\n        }\n  \
    \      long substringLength = substring.length();\n        string = string.toLowerCase().replaceAll(\"\
    [^a-z]\", \"\");\n        // for each character in substring\n        for (char\
    \ c : substring.toCharArray()) {\n            // if the character is not in the\
    \ string return zero\n            long positionInString = string.indexOf(c);\n\
    \            if (positionInString == -1) {\n                return 0;\n      \
    \      }\n            // count it\n            count++;\n            // if the\
    \ character is at the end of the string then return count otherwise add one to\
    \ count\n            if (c == string.charAt(string.length() - 1)) {\n        \
    \        return count;\n            }\n            count++;\n        }\n     \
    \   return count;", '        return string.split(substring).length - string.split(substring).indexOf(substring)
    + 1;', "        return string.length() - substring.length()\n                +\
    \ ((string.indexOf(substring) > -1) ? 1 : 0)\n                + howManyTimes(string.substring(0,\
    \ string.indexOf(substring))\n                        + substring, substring);",
  "        long count = 0;\n        for (char c : string.toCharArray()) {\n      \
    \      if (c == substring.charAt(0)) {\n                if (string.indexOf(substring,\
    \ 1) == string.lastIndexOf(substring, 1)) {\n                    ++count;\n  \
    \              }\n                ++count;\n            } else if (string.indexOf(substring,\
    \ 1) != string.lastIndexOf(substring, 1)) {\n                ++count;\n      \
    \      }\n        }\n        return count;", "        long times = 0;\n      \
    \  int startIndex = 0;\n        int endIndex = 0;\n        boolean firstTime =\
    \ true;\n        boolean previousCharacter = true;\n\n        // Use a stack to\
    \ keep track of what was already counted.\n        Stack<Integer> stack = new\
    \ Stack<Integer>();\n\n        // Count all overlapping cases (including the first\
    \ occurrence)\n        for (int i = 0; i < string.length(); i++) {\n         \
    \   if (previousCharacter && string.charAt(i) == substring.charAt(0)) {\n    \
    \            startIndex = i;\n                stack.push(i);\n            }\n\
    \            else {\n                if (firstTime) {\n                    endIndex\
    \ = i;\n                    firstTime = false;\n                    times += (endIndex\
    \ - startIndex + 1);\n                    startIndex = 0;\n                  \
    \  previousCharacter = true;\n                } else {\n                    endIndex\
    \ = i;\n                    previousCharacter = false;\n                    times\
    \ += (endIndex - startIndex + 1);\n                }\n            }\n        }\n\
    \n        // The first occurrence is counted because it is counted before the\
    \ loop\n        // begins. If the last occurrence is counted after the loop\n\
    \        // ends, the time will be less than the original substring length.\n\
    \        long resultTimes = times - 1;\n\n        // Remove the elements from\
    \ stack that are in string\n        while (stack.peek() != -1) {\n           \
    \ if (stack.pop() != string.indexOf(substring)) {\n                endIndex =\
    \ stack.peek();\n                times += (endIndex - startIndex + 1);\n     \
    \       }\n        }\n\n        return resultTimes;", "        // return 0 if\
    \ the string is empty\n        if (string.isEmpty()) {\n            return 0L;\n\
    \        }\n        // convert string to an array of characters (char[])\n   \
    \     char[] charArray = string.toCharArray();\n        long total = 0L;\n   \
    \     // find the length of the given substring\n        long index = string.length()\
    \ - substring.length();\n        // iterate through the whole string\n       \
    \ for (long i = 0; i < index; i++) {\n            // iterate through the substring\n\
    \            for (long j = 0; j < substring.length(); j++) {\n               \
    \ // check if the character at the current index is equal to the character at\
    \ the current index\n                if (charArray[i + j] != substring.charAt(j))\
    \ {\n                    break;\n                }\n                // check if\
    \ the character at the current index is equal to the character at the current\
    \ index\n                if (j == substring.length() - 1) {\n                \
    \    total += 1;\n                }\n            }\n        }\n        return\
    \ total;", "        long result = 0;\n        if (string.isEmpty() || substring.isEmpty())\
    \ {\n            return result;\n        }\n        final int length = string.length();\n\
    \        if (substring.length() > length) {\n            substring = substring.substring(0,\
    \ length);\n        }\n        final int slength = substring.length();\n     \
    \   int i = -1;\n        final int j = (slength < 0 ? 0 : -slength);\n       \
    \ for (int k = 0; k < slength; k++) {\n            i = i + 1;\n            if\
    \ (string.charAt(i + k) != substring.charAt(k)) {\n                i += k;\n \
    \               result += i;\n                i = -1;\n                break;\n\
    \            }\n        }\n        for (int k = slength; k < length + 1; k++)\
    \ {\n            i = i + 1;\n            if (string.charAt(i + k) != substring.charAt(k))\
    \ {\n                result += i;\n                i = -1;\n            }\n  \
    \      }\n        return result;", "        int count = 0;\n        // Check whether\
    \ the original string contains the substring\n        if (string.contains(substring))\
    \ {\n            // Split the original string with substring\n            String[]\
    \ s = string.split(substring);\n            // Check whether the substring appears\
    \ in the original string\n            for (int i = 0; i < s.length; i++)\n   \
    \             if (string.contains(substring, i, s.length()))\n               \
    \     count++;\n        }\n        return count;", "        if (string.length()\
    \ < substring.length()) {\n            return 0;\n        }\n        int count\
    \ = 0;\n        int start = string.indexOf(substring);\n        int end = start\
    \ + substring.length();\n        while (start > -1) {\n            count++;\n\
    \            start = string.indexOf(substring, start + substring.length());\n\
    \        }\n        return count;", '        return string.length() - string.replace(substring,
    "").length();', "        List<String> list = Arrays.asList(string.toLowerCase().split(substring.toLowerCase()));\n\
    \        long count = list.stream().filter(s -> s.contains(string.toLowerCase())).count();\n\
    \        return count;", "        int count = 0;\n        int length = string.length();\n\
    \        int substringLength = substring.length();\n        if (substringLength\
    \ == 0) return count;\n        // Use a list to record count for overlapping substring.\n\
    \        ArrayList<String> record = new ArrayList<>();\n        // Use a set to\
    \ prevent duplicated substring count.\n        Set<String> set = new HashSet<>();\n\
    \        // Traverse the original string.\n        for (int i = 0; i < length;\
    \ i++) {\n            // The last character is checked.\n            if (i ==\
    \ length - 1) // No need check if i==length because if i == length, then i + 1\
    \ == length\n                // If current character is same as last character,\
    \ no need to check.\n                if (string.charAt(i) == string.charAt(substringLength\
    \ - 1)) {\n                    // If current substring is same as last substring,\
    \ the count is 1.\n                    if (set.contains(substring)) {\n      \
    \                  count++;\n                    }\n                } else {\n\
    \                    // Add substring to the list if it is not in the set.\n \
    \                   if (!set.contains(substring)) {\n                        set.addAll(Arrays.asList(substring));\n\
    \                    }\n                    // If current character is not same\
    \ as the last character, then we record this substring.\n                    if\
    \ (string.charAt(i) != string.charAt(substringLength - 1)) {\n               \
    \         // Record overlapping substring.\n                        record.add(\"\
    (\" + i + \")\");\n                    }\n                }\n            } //\
    \ end if\n        } // end for\n        // Convert array to list.\n        List<String>\
    \ list = Arrays.asList(record);\n        // Return the count.\n        return\
    \ list.size();\n    } // end howManyTimes\n    // Find how many times a given\
    \ substring can be found in the original string. Count non-overlapping cases.\n\
    \    // >>> howManyTimes((\"\"), (\"a\"))\n    // (0l)\n    // >>> howManyTimes((\"\
    aaa\"), (\"a\"))\n    // (2l)\n    // >>> howManyTimes((\"aaaa\"), (\"a\"))\n\
    \    // (0l)\n    // >>> howManyTimes((\"aaaa\"), (\"aa\"))\n    // (0l)\n   \
    \ // >>> howManyTimes((\"aaaa\"), (\"aaa\"))\n    // (0l)\n    // >>> howManyTimes((\"\
    aaaa\"), (\"aaaa\"))\n    // (0l)\n    public static long howManyTimes2(String\
    \ string, String substring) {\n        int count = 0;\n        int length = string.length();\n\
    \        int substringLength = substring.length();\n        if (substringLength\
    \ == 0) return count;\n        // Use a list to record count for non-overlapping\
    \ substring.\n        ArrayList<String> record = new ArrayList<>();\n        //\
    \ Use a set to prevent duplicated substring count.\n        Set<String> set =\
    \ new HashSet<>();\n        // Traverse the original string.\n        for (int\
    \ i = 0; i < length; i++) {\n            // The last character is checked.", " \
    \       long count = 0;\n        long start = 0;\n        while (start < string.length()\
    \ && string.charAt(start) == substring.charAt(0)) {\n            count++;\n  \
    \          start++;\n        }\n        while (start < string.length() && string.charAt(start)\
    \ != substring.charAt(0)) {\n            count++;\n            start++;\n    \
    \    }\n        return count;", "        int count = 0;\n        long res = 0;\n\
    \        for (char c: string.toCharArray()) {\n            if (string.indexOf(substring,\
    \ c) != -1)\n                count++;\n        }\n        res = count * howManyTimesInternal(string,\
    \ substring, count);\n        return res;", '        return string.indexOf(substring);',
  "        List<String> matches = new ArrayList<>();\n        int count = 0;\n   \
    \     for (int i = 0; i < string.length(); i++) {\n            if (string.substring(i,\
    \ i + substring.length()).equals(substring)) {\n                count++;\n   \
    \             matches.add(string.substring(i, i + substring.length()));\n    \
    \        }\n        }\n        return matches.stream().mapToLong(s -> 1).sum();",
  "        String lowerCaseString = string.toLowerCase();\n        String lowerCaseSubString\
    \ = substring.toLowerCase();\n        return longStream.of(lowerCaseString.split(lowerCaseSubString)).map(s\
    \ -> s.split(\"\")).count();", "        int n = 0;\n        do {\n           \
    \ n = string.indexOf(substring, n + 1);\n        } while (n != -1);\n        return\
    \ n;", "        if (string.isEmpty() || substring.isEmpty()) return 0L;\n    \
    \    if (string.contains(substring))\n            return Long.valueOf(string.split(substring).length\
    \ - 1);\n        else\n            return howManyTimes(string.substring(0, string.lastIndexOf(substring))\
    \ + string.substring(string.lastIndexOf(substring) + 1), substring);", "     \
    \   long count = 0;\n        char[] chars = string.toCharArray();\n        char[]\
    \ charSub = substring.toCharArray();\n        long index = 0;\n        for (char\
    \ ch: chars) {\n            while (index < chars.length && chars[index] == charSub[0])\
    \ {\n                index++;\n            }\n            if (index == chars.length)\
    \ {\n                break;\n            }\n            count++;\n           \
    \ if (index > 0) {\n                while (index < chars.length && chars[index]\
    \ == charSub[1]) {\n                    index++;\n                }\n        \
    \    }\n        }\n        return count;", '        return string.split(substring).length
    - 1;', "        String pattern = string.replaceAll(\"\\\\*\", \".*\").replaceAll(\"\
    \\\\?\", \".\");\n        Pattern regex = Pattern.compile(pattern);\n        Matcher\
    \ regexMatcher = regex.matcher(string);\n\n        long times = 0;\n        while\
    \ (regexMatcher.find()) {\n            times++;\n        }\n\n        String regexPattern\
    \ = string.replaceAll(\"\\\\*\", \"[^a-zA-Z0-9]\").replaceAll(\"\\\\?\", \".\"\
    );\n        Pattern regexPattern = Pattern.compile(regexPattern);\n        Matcher\
    \ regexPatternMatcher = regexPattern.matcher(string);\n        while (regexPatternMatcher.find())\
    \ {\n            times++;\n        }\n\n        long count = 0;\n        int start\
    \ = 0;\n        while (start < string.length()) {\n            int end = start;\n\
    \            while (end < string.length()) {\n                if (string.substring(end,\
    \ end + 1).equals(substring)) {\n                    count++;\n              \
    \  }\n                end++;\n            }\n            start = end;\n      \
    \  }\n        return count;", "        if (string == null || substring == null)\
    \ {\n            throw new IllegalArgumentException();\n        }\n\n        return\
    \ IntStream.rangeClosed(0, string.length() - substring.length())\n           \
    \ .map(start -> IntStream.rangeClosed(0, substring.length())\n               \
    \ .filter(end -> string.regionMatches(substring, start, end, false, true))\n \
    \               .count())\n            .sum();", "        String lowerSubstring\
    \ = \"\";\n        if (substring != null) {\n            lowerSubstring = substring.toLowerCase().replaceAll(\"\
    \ \", \"\");\n        }\n        return howManyTimesImpl(string, lowerSubstring);",
  "        long count = 0;\n        if (string.isEmpty()) {\n            return count;\n\
    \        }\n        if (string.equals(substring)) {\n            count++;\n  \
    \      }\n        boolean startFound = string.startsWith(substring);\n       \
    \ boolean endFound = string.endsWith(substring);\n        boolean containsSubstring\
    \ = string.contains(substring);\n        boolean foundMatch = false;\n       \
    \ boolean foundMatchSubstring = false;\n        for (int i = 0; i < string.length();\
    \ i++) {\n            int sublen = substring.length();\n            String test\
    \ = string.substring(i, sublen);\n            String testSubstring = substring.substring(i,\
    \ sublen);\n            if ((startFound && test.equals(substring))\n         \
    \           || (endFound && test.equals(substring))\n                    || (containsSubstring\
    \ && test.equals(testSubstring))) {\n                count++;\n              \
    \  foundMatch = true;\n            }\n        }\n        if (foundMatch) {\n \
    \           foundMatchSubstring = true;\n        }\n        Set<String> set =\
    \ new HashSet<>();\n        set.addAll(Arrays.asList(string.split(substring)));\n\
    \        set.addAll(Arrays.asList(substring.split(string)));\n        count =\
    \ set.size() - 1;\n        if (startFound && endFound) {\n            return count;\n\
    \        }\n        else if (startFound) {\n            if (containsSubstring\
    \ && foundMatch) {\n                return count + 1;\n            }\n       \
    \     else {\n                return count;\n            }\n        }\n      \
    \  else if (endFound) {\n            if (containsSubstring && foundMatchSubstring)\
    \ {\n                return count + 1;\n            }\n            else {\n  \
    \              return count;\n            }\n        }\n        else if (containsSubstring)\
    \ {\n            if (foundMatch) {\n                return count + 1;\n      \
    \      }\n            else {\n                return count;\n            }\n \
    \       }\n        else {\n            if (foundMatch) {\n                return\
    \ count + 1;\n            }\n            else {\n                return count;\n\
    \            }\n        }", "        long result = 0;\n        int len = string.length();\n\
    \        int[] charIndex = new int[len];\n        int[] charPosition = new int[len];\n\
    \        long start = 0;\n        int index = 0;\n        int position = 0;\n\
    \        for (int i = 0; i < len; i++) {\n            charPosition[i] = string.indexOf(substring,\
    \ i);\n            charIndex[i] = i;\n        }\n        for (index = 0; index\
    \ < len; index++) {\n            if (start != charPosition[index]) {\n       \
    \         if (index == len - 1)\n                    result += 1;\n          \
    \      else {\n                    result += 1 + howManyTimesBetween(\n      \
    \                      string.substring(start, charPosition[index + 1]),\n   \
    \                         substring, charPosition[index + 1]);\n             \
    \   }\n                start = charPosition[index];\n            }\n        }\n\
    \        return result;", "        int counter = 0;\n        long count = 0;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int count =\
    \ 0;\n            for (int j = 0; j < substring.length(); j++) {\n           \
    \     if (string.charAt(i) == substring.charAt(j)) {\n                    count++;\n\
    \                    if (j == substring.length() - 1) {\n                    \
    \    counter++;\n                        if (counter == substring.length()) {\n\
    \                            count++;\n                        }\n           \
    \         }\n                }\n            }\n            if (count > count)\n\
    \                count = count;\n        }\n        return count;", "        long\
    \ count = 1;\n        for (int i = 0; i < string.length(); i++) {\n          \
    \  if (string.substring(i, i + substring.length()).equals(substring)) {\n    \
    \            count++;\n            }\n        }\n        return count;", "   \
    \     int n = string.length();\n        int m = substring.length();\n        long\
    \ ans = 0, pos = 0;\n        for (int i = 0; i < m; ++i) {\n            if (string.charAt(i\
    \ + pos) != substring.charAt(i)) {\n                ans = ans + (n - pos);\n \
    \               pos = 0;\n            } else {\n                ++pos;\n     \
    \       }\n        }\n        ans = ans + (n - pos);\n        return ans;", " \
    \       long count = 0;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                for\
    \ (int j = 1; j < substring.length(); j++) {\n                    if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                        count++;\n              \
    \          i += j - 1;\n                    }\n                }\n           \
    \ }\n        }\n        return count;", "        long count = 0; \n        int\
    \ index = 0;\n        while (index < string.length()) {\n            if (string.substring(index,\
    \ index + substring.length()).equals(substring)) {\n                count++;\n\
    \            }\n            index += substring.length();\n        }\n        return\
    \ count;", "        int index = string.indexOf(substring);\n        if (index\
    \ != -1) {\n            long count = 1;\n            String substringToSearch\
    \ = string.substring(0, index) + string.substring(index + 1, string.length());\n\
    \            index = string.indexOf(substringToSearch);\n            while (index\
    \ != -1) {\n                count++;\n                index = string.indexOf(substringToSearch,\
    \ index + 1);\n            }\n            return count;\n        } else {\n  \
    \          return 0;\n        }", '        return howManyTimes(string.toCharArray(),
    substring.toCharArray(), 0, 0);', '        return count(string, substring, string.indexOf(substring)
    + 1);', "        long count = 0;\n        long startIndex = string.indexOf(substring);\n\
    \        while (startIndex >= 0) {\n            count++;\n            startIndex\
    \ = string.indexOf(substring, startIndex + 1);\n        }\n        return count;",
  '        return howManyTimes(string, substring, 0);', "        long count = 0;\n\
    \        long start = string.indexOf(substring);\n        if (start >= 0) {\n\
    \            while (start > -1) {\n                string =\n                \
    \    string.substring(0, start) +\n                    string.substring(start\
    \ + substring.length()) +\n                    string.substring(start + substring.length(),\
    \ string.length());\n                start = string.indexOf(substring, start +\
    \ 1);\n                count++;\n            }\n        }\n        return count;",
  "        long count = 0;\n        char[] chars = string.toCharArray();\n       \
    \ char[] chars1 = substring.toCharArray();\n        if (chars.length > chars1.length)\
    \ {\n            char[] temp = chars;\n            chars = chars1;\n         \
    \   chars1 = temp;\n        }\n        int j = 0;\n        for (int i = 0; i <\
    \ chars.length; i++) {\n            if (chars[i] == chars1[j]) {\n           \
    \     count++;\n                j++;\n                if (j == chars1.length)\
    \ {\n                    break;\n                }\n            } else {\n   \
    \             count = 0;\n                j = 0;\n            }\n        }\n \
    \       return count;", "        String newString = string.replaceAll(substring,\
    \ \"\");\n        long length = string.length() - newString.length();\n      \
    \  return length / substring.length();", "        long count = Long.MAX_VALUE;\n\
    \        for (int i = 0; i < string.length(); i++) {\n            int start =\
    \ i;\n            int end = string.indexOf(substring, start);\n            if\
    \ (end != -1) {\n                if (end < start) {\n                    count\
    \ = Math.min(count, end);\n                } else {\n                    count\
    \ += end - start;\n                }\n            }\n            start = string.indexOf(substring,\
    \ end);\n            if (start != -1) {\n                count += end - start\
    \ + 1;\n            }\n        }\n        return count;", "        List<String>\
    \ list = string.split(substring);\n        int count = 0;\n        for (String\
    \ s : list) {\n            if (s.equals(substring)) {\n                count++;\n\
    \            }\n        }\n        return count;", "        if (string.contains(substring))\
    \ {\n            return string.length() - string.toLowerCase().indexOf(substring.toLowerCase())\
    \ + string.substring(0, string.toLowerCase().indexOf(substring.toLowerCase())).length()\
    \ - substring.length();\n        } else {\n            return 0;\n        }",
  '        return howManyTimesFaster(string, substring, new HashSet<String>(), new
    HashSet<String>());', "        long count = 0;\n        \n        for (char letter\
    \ : string.toCharArray()) {\n            if (letter == substring.charAt(0)) {\n\
    \                for (int i = 1; i < substring.length(); i++) {\n            \
    \        if (string.charAt(i) == substring.charAt(i)) {\n                    \
    \    count++;\n                    } else if (string.charAt(i) != substring.charAt(i))\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n        }\n        return count;", "        int[] counts = new\
    \ int[substring.length()];\n        char[] chars = string.toCharArray();\n   \
    \     for (int i = 0; i < chars.length; i++) {\n            int index = chars.indexOf(substring,\
    \ i);\n            counts[(int) index] += 1;\n        }\n        return Arrays.stream(counts).filter(i\
    \ -> i != 0).count();", "        long sum = 0;\n        int pos = string.indexOf(substring);\n\
    \        while (pos != -1) {\n            sum += 1;\n            pos = string.indexOf(substring,\
    \ pos + substring.length());\n        }\n        return sum;", "        // Write\
    \ your code here\n        long count = 0;\n        int stringLength = string.length();\n\
    \        int substringLength = substring.length();\n        for(int i = 0; i <\
    \ stringLength - substringLength; i++) {\n            if(string.substring(i, i\
    \ + substringLength).equals(substring)) {\n                count++;\n        \
    \    }\n        }\n        return count;", "        if (string == null || substring.length()\
    \ == 0) return 0;\n\n        // Find position of first occurrence of substring\
    \ in string and save it\n        int stringStartIndex = string.indexOf(substring);\n\
    \        if (stringStartIndex == -1) return 0;\n\n        // Split string into\
    \ substring prefix and suffix\n        String[] prefix = string.substring(0, stringStartIndex);\n\
    \        String[] suffix = string.substring(stringStartIndex + substring.length());\n\
    \        if (suffix.length() == 0) return prefix.length();\n\n        // Recursively\
    \ find how many times suffix can be found in the prefix by finding the number\
    \ of times prefix can be found in the suffix\n        long count = howManyTimes(prefix,\
    \ suffix);\n        if (suffix.length() > 0) {\n            // Find the number\
    \ of times substring can be found in the suffix\n            count += howManyTimes(suffix,\
    \ substring);\n        }\n\n        return count;", '        return howManyTimesImpl(string.split(substring));',
  "        long count = 0;\n        long slength = string.length();\n        long\
    \ ssublength = substring.length();\n        for (int i = 0; i <= slength - ssublength\
    \ + 1; i++) {\n            if (string.subSequence(0, i).equals(substring)) {\n\
    \                count += 1;\n            }\n        }\n        return count;",
  "        return IntStream.range(0, string.length()).filter(i -> string.regionMatches(true,\
    \ i, substring, 0, substring.length()))\n                .count();", "       \
    \ // Split string into list of substrings\n        List<String> stringList = string.split(\"\
    \");\n        List<String> substringList = substring.split(\"\");\n\n        //\
    \ Initialize count with 0\n        long count = 0;\n\n        // Go through substring\
    \ list and check if the current string contains substring\n        for (int i\
    \ = 0; i < substringList.size(); i++) {\n            if (stringList.contains(substringList.get(i)))\
    \ {\n                count++;\n            }\n        }\n\n        return count;",
  '        return howManyTimes(string.toCharArray(), substring.toCharArray());', " \
    \       // O(n) time and O(n) space\n        int count = 0;\n        string =\
    \ string.toLowerCase();\n        substring = substring.toLowerCase();\n      \
    \  int len = string.length();\n        int slen = substring.length();\n      \
    \  for (int i = 0; i != len; ++i) {\n            String sub = string.substring(i,\
    \ i + slen);\n            if (substring.startsWith(sub)) {\n                count\
    \ += 1;\n            }\n        }\n        return count;", "        final long\
    \ result = Long.MIN_VALUE;\n        final List<String> substrings = new ArrayList<>();\n\
    \        substrings.add(substring);\n\n        for (String s : string.split(\"\
    (?<=\\\\G.{0,})\")) {\n            for (String sub : substrings) {\n         \
    \       if (s.startsWith(sub)) {\n                    final long count = substrings.stream()\n\
    \                            .filter(ss -> ss.equals(sub)).count();\n        \
    \            result = Math.max(count, result);\n                    substrings.remove(sub);\n\
    \                }\n            }\n        }\n\n        return result;", "   \
    \     long count = 0;\n        if (string.length() == 0 || substring.length()\
    \ == 0) {\n            return 0;\n        }\n        for(int i = 0; i<string.length()-substring.length();i++)\
    \ {\n            if (string.substring(i,i+substring.length()).equals(substring))\
    \ {\n                count++;\n            }\n        }\n        return count;",
  "        long count = 0;\n        int startIndex = -1;\n        int endIndex = -1;\n\
    \        \n        \n        if (string.length() == 0) {\n            return 0;\n\
    \        }\n        \n        for (int i = 0; i < string.length(); i++) {\n  \
    \          if (string.charAt(i) == substring.charAt(0)) {\n                startIndex\
    \ = i;\n            }\n            else if (string.charAt(i) == substring.charAt(string.length()\
    \ - 1)) {\n                endIndex = i;\n            }\n        }\n        \n\
    \        \n        if (startIndex >= 0 && endIndex >= 0) {\n            \n   \
    \         for (int i = 0; i < string.length(); i++) {\n                if (i <\
    \ startIndex || i >= endIndex) {\n                    count++;\n             \
    \   }\n            }\n        }\n        \n        return count;", "        long\
    \ count = 0; // count the occurrence\n        if (string == null || substring\
    \ == null)\n            return 0;\n        if (string.length() < substring.length())\n\
    \            substring = substring + \"\\0\"; // add null character for substrings\
    \ that are shorter than string\n        \n        string = string.trim(); // remove\
    \ leading and trailing whitespaces\n        substring = substring.trim(); // remove\
    \ leading and trailing whitespaces\n\n        int i = 0, j = 0;\n        // Search\
    \ for the first index\n        while (i < string.length() && j < substring.length())\n\
    \            if (string.charAt(i) == substring.charAt(j))\n                i++;\n\
    \            else\n                j++;\n        \n        // If i is at the end\
    \ or if we didn't find any character\n        if (i >= string.length() || j >=\
    \ substring.length())\n            return 0;\n        // If i is at the beginning\
    \ of string and the substring is not found\n        if (i < substring.length()\
    \ && j >= substring.length())\n            return 0;\n        // If j doesn't\
    \ appear in the substring\n        if (i < substring.length() && j < substring.length())\n\
    \            return 0;\n\n        while (i < string.length() && j < substring.length())\
    \ {\n            if (string.charAt(i) == substring.charAt(j)) {\n            \
    \    count++;\n                i++;\n                j++;\n            }\n   \
    \         else\n                j++;\n        }\n\n        return count;", " \
    \       long result = Long.MAX_VALUE;\n        \n        if (string == null ||\
    \ string.trim().isEmpty() || substring == null || substring.trim().isEmpty())\
    \ {\n            return result;\n        }\n        \n        // Case 1: string\
    \ is empty, return 0.\n        if (string.isEmpty()) {\n            return 0;\n\
    \        }\n        \n        // Case 2: string is full of characters, return\
    \ 1.\n        if (string.length() == substring.length()) {\n            return\
    \ 1;\n        }\n        \n        // Case 3: substring is only a substring, return\
    \ 1.\n        if (string.equals(substring)) {\n            return 1;\n       \
    \ }\n        \n        // Case 4: substring is not a substring, return 2.\n  \
    \      if (string.contains(substring)) {\n            return 2;\n        }\n \
    \       \n        // Case 5: substring is a prefix of string, return 2.\n    \
    \    if (string.startsWith(substring)) {\n            return 2;\n        }\n \
    \       \n        // Case 6: substring is a suffix of string, return 2.\n    \
    \    if (string.endsWith(substring)) {\n            return 2;\n        }\n   \
    \     \n        // Case 7: substring is a prefix or suffix of string, return 3.\n\
    \        if (string.contains(substring) || string.startsWith(substring) || string.endsWith(substring))\
    \ {\n            return 3;\n        }\n        \n        // Case 8: substring\
    \ is not a prefix and suffix of string, return 4.\n        if (string.startsWith(substring)\
    \ || string.endsWith(substring)) {\n            return 4;\n        }\n       \
    \ \n        // Case 9: substring is a prefix or suffix of string, return 4.\n\
    \        if (string.contains(substring) || string.endsWith(substring)) {\n   \
    \         return 4;\n        }\n        \n        // Case 10: substring is not\
    \ a prefix and suffix of string, return 5.\n        if (string.endsWith(substring))\
    \ {\n            return 5;\n        }\n        \n        // Case 11: substring\
    \ is not a prefix and suffix of string, return 5.\n        if (string.contains(substring))\
    \ {\n            return 5;\n        }\n        \n        // Case 12: substring\
    \ is a prefix or suffix of string, return 6.\n        if (string.startsWith(substring)\
    \ || string.contains(substring)) {\n            return 6;\n        }\n       \
    \ \n        // Case 13: substring is not a prefix and suffix of string, return\
    \ 7.\n        if (string.endsWith(substring)) {\n            return 7;\n     \
    \   }\n        \n        // Case 14: substring is not a prefix and suffix of string,\
    \ return 7.\n        if (string.contains(substring)) {\n            return 7;\n\
    \        }\n        \n        // Case 15: substring is a prefix or suffix of string,\
    \ return 8.\n        if (string.startsWith(substring) || string.endsWith(substring))\
    \ {\n            return 8;\n        }\n        \n        // Case 16: substring\
    \ is not a prefix and suffix of string, return 9.\n        if (string.contains(substring))\
    \ {\n            return 9;\n        }\n", "        String s = string.substring(0,substring.length());\n\
    \        long count = 0;\n        for(int i=0; i<string.length()-substring.length()+1;\
    \ i++) {\n            String t = string.substring(i,i+substring.length());\n \
    \           if(t.equals(s)) {\n                count++;\n            }\n     \
    \   }\n        return count;", "        if (string.equals(substring)) {\n    \
    \        return 0l;\n        } else {\n            return string.split(substring).length\
    \ - string.split(substring).length + 1;\n        }", "        long count = 0;\n\
    \        long stringLength = string.length();\n        long substringLength =\
    \ substring.length();\n        int minLength = Math.min(stringLength, substringLength);\n\
    \        int i = 0;\n        while (i < stringLength) {\n            if (string.charAt(i)\
    \ == substring.charAt(0)) {\n                if (i + minLength == stringLength)\n\
    \                    break;\n                i += minLength;\n            }\n\
    \            else {\n                i++;\n                count++;\n        \
    \    }\n        }\n        return count;", '        return string.length() - string.replace(substring,
    "").length();', "        List<String> result = new ArrayList<>();\n\n        long\
    \ times = 0;\n        int index = string.indexOf(substring);\n        while (index\
    \ >= 0) {\n            result.add(string.substring(0, index));\n            string\
    \ = string.substring(index + 1);\n            index = string.indexOf(substring);\n\
    \            times++;\n        }\n\n        Collections.sort(result);\n      \
    \  for (String string : result) {\n            String chars = \"\";\n        \
    \    for (int i = 0; i < string.length(); i++) {\n                chars += string.charAt(i);\n\
    \            }\n            if (chars.equals(substring)) {\n                return\
    \ times;\n            }\n        }\n\n        return 0;", "        long count\
    \ = 0;\n        int n = string.length();\n        int s = substring.length();\n\
    \n        if (n >= s) {\n            for (int i = 0; i <= n - s; i++) {\n    \
    \            if (string.substring(i, i + s).equals(substring)) {\n           \
    \         count++;\n                }\n            }\n        } else {\n     \
    \       System.out.println(string + \" is too short\");\n        }\n        return\
    \ count;", '        return string.length() - string.replaceAll(substring, "").length();',
  "        // Return the number of occurrences.\n        int count = 0;\n        boolean\
    \ found = false;\n        for(int i=0; i < string.length(); i++) {\n         \
    \   // Skip the original string.\n            if(string.charAt(i) == substring.charAt(0))\
    \ {\n                count++;\n                continue;\n            }\n\n  \
    \          // Find the rest of the substring.\n            int index = string.indexOf(substring,\
    \ i+1);\n            found = (index != -1);\n            if((found) && (i == index))\
    \ {\n                // If the original string was a substring, the character\
    \ is found one more time.\n                count++;\n            }\n        }\n\
    \        return (Long.MAX_VALUE == count) ? Long.MAX_VALUE : count;", '        return
    string.toLowerCase().chars().filter(c -> c == substring.toLowerCase().charAt(0)).count()
    + string.matches(substring + "$") ? 1 : 0l;', "        long count = 0; // initialize\
    \ count\n        if (string.length() == 0 || substring.length() == 0) {\n    \
    \        return count; // return 0 if either string is empty\n        }\n    \
    \    if (string.equals(substring)) {\n            return 1; // return 1 if strings\
    \ and substrings are equal\n        }\n\n        // Iterate over each character\
    \ of string and compare it to substring\n        for (int i = 0; i < string.length();\
    \ i++) {\n            String character = string.charAt(i);\n            if (substring.contains(character))\
    \ { // compare current character of string to all characters of substring\n  \
    \              count++; // increase count by 1\n            }\n        }\n   \
    \     return count;", "        long[] count = new long[substring.length() + 1];\n\
    \        for (int i = 0; i <= string.length() - substring.length(); i++) {\n \
    \           int subIndex = 0;\n            for (int j = 0; j < substring.length();\
    \ j++) {\n                if (string.charAt(i + j) != substring.charAt(subIndex++))\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (subIndex == substring.length()) {\n                count[0]++;\n      \
    \      }\n        }\n        return count[substring.length()];", "        if (string.isEmpty()\
    \ || substring.isEmpty()) {\n            return 0L;\n        }\n        long count\
    \ = 0L;\n        int start = string.indexOf(substring);\n        while (start\
    \ != -1) {\n            count++;\n            start = string.indexOf(substring,\
    \ start + substring.length());\n        }\n        return count;", "        Set<Character>\
    \ set = new HashSet<>();\n        for (char c : string.toCharArray()) {\n    \
    \        if (set.contains(c))\n                set.clear();\n            else\n\
    \                set.add(c);\n            if (set.contains(substring))\n     \
    \           set.clear();\n        }\n        return set.size();", '        return
    string.split(substring).length - 1;', "        return longStream.range(0, string.length()\
    \ - substring.length())\n            .mapToObj(i -> new Pair<>(string.substring(i),\
    \ string.substring(i, i + substring.length())))\n            .filter(p -> p.getFirst().equalsIgnoreCase(substring))\n\
    \            .count();", "        long count = 0;\n        if (string == null\
    \ || string == substring) {\n            return count;\n        }\n        if\
    \ (string.length() == 0 || substring.length() == 0) {\n            return count;\n\
    \        }\n        if (string.charAt(0) == substring.charAt(0)) {\n         \
    \   count++;\n            return howManyTimes(string.substring(1), substring);\n\
    \        }\n        int first = 0;\n        int last = string.length() - 1;\n\
    \        while (first < last) {\n            int mid = (first + last) / 2;\n \
    \           int cmp = string.charAt(mid).compareTo(substring.charAt(0));\n   \
    \         if (cmp > 0) {\n                first = mid;\n            } else {\n\
    \                last = mid;\n            }\n        }\n        count += first\
    \ + 1 == last ? 1 : 0;\n        if (first < last) {\n            return howManyTimes(string.substring(first\
    \ + 1, last), substring);\n        }\n        return count;", "        int count\
    \ = 0;\n        if (string.isEmpty()) {\n            return 0;\n        }\n  \
    \      if (substring.isEmpty()) {\n            return count;\n        }\n    \
    \    if (string.equals(substring)) {\n            return 1;\n        }\n     \
    \   for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i)\
    \ == substring.charAt(0)) {\n                String substring1 = substring;\n\
    \                while (substring1.length() > 0) {\n                    substring1\
    \ = substring1.substring(0, substring1.length() - 1);\n                    if\
    \ (string.substring(i, i + substring1.length()).equals(substring1)) {\n      \
    \                  count += 1;\n                    }\n                    i +=\
    \ substring1.length() - 1;\n                }\n            } else {\n        \
    \        int j = i + 1;\n                while (j < string.length() && string.charAt(i)\
    \ == string.charAt(j)) {\n                    j += 1;\n                }\n   \
    \             String substring2 = substring;\n                while (substring2.length()\
    \ > 0) {\n                    substring2 = substring2.substring(substring2.length()\
    \ - 1);\n                    String substring12 = (substring1 + substring2).substring(0,\
    \ substring2.length());\n                    if (string.substring(i, i + substring12.length()).equals(substring12))\
    \ {\n                        count += 1;\n                    }\n            \
    \        i += substring12.length() - 1;\n                }\n            }\n  \
    \      }\n        return count;", "        long result = 0L;\n        int position\
    \ = 0;\n        do {\n            if (string.charAt(position) == substring.charAt(0))\
    \ {\n                result++;\n            }\n            position++;\n     \
    \   } while (position < string.length() && string.charAt(position) == substring.charAt(0));\n\
    \        return result;", "        long total = 0;\n        boolean found = false;\n\
    \        if (string == null || string == \"\" || substring == null || substring\
    \ == \"\") return 0;\n        int index = 0;\n        while (index < string.length())\
    \ {\n            int count = 0;\n            while (index < string.length() &&\
    \ !found) {\n                if (string.charAt(index) == substring.charAt(0))\
    \ {\n                    if (string.charAt(index) == substring.charAt(1)) {\n\
    \                        count++;\n                    } else if (string.charAt(index)\
    \ == substring.charAt(2)) {\n                        count++;\n              \
    \      } else if (string.charAt(index) == substring.charAt(3)) {\n           \
    \             count++;\n                    } else if (string.charAt(index) ==\
    \ substring.charAt(4)) {\n                        count++;\n                 \
    \   } else if (string.charAt(index) == substring.charAt(5)) {\n              \
    \          count++;\n                    } else if (string.charAt(index) == substring.charAt(6))\
    \ {\n                        count++;\n                    } else if (string.charAt(index)\
    \ == substring.charAt(7)) {\n                        count++;\n              \
    \      } else if (string.charAt(index) == substring.charAt(8)) {\n           \
    \             count++;\n                    } else if (string.charAt(index) ==\
    \ substring.charAt(9)) {\n                        count++;\n                 \
    \   }\n                }\n                index++;\n            }\n          \
    \  total += count;\n            if (found == true) {\n                found =\
    \ false;\n            } else {\n                found = true;\n              \
    \  if (index != string.length()) {\n                    index++;\n           \
    \     }\n            }\n        }\n        return total;", "        char[] charArray\
    \ = string.toCharArray();\n        char[] charArray2 = substring.toCharArray();\n\
    \        long sum = 0;\n        for (char c : charArray) {\n            int pos\
    \ = Arrays.binarySearch(charArray2, c);\n            if (pos >= 0) {\n       \
    \         sum += pos;\n            }\n        }\n        return sum;", "     \
    \   List<String> strings = Arrays.asList((string), (string), (string), (string));\n\
    \        List<String> substrings = Arrays.asList((substring), (substring), (substring),\
    \ (substring));\n        long result = 0l;\n        for (String s : strings) {\n\
    \            long count = substrings.stream().filter(sub -> s.indexOf(sub) !=\
    \ -1).count();\n            if (count > 0) {\n                result += (long)\
    \ count;\n            }\n        }\n        return result;", "        long count\
    \ = 0;\n        long len1 = string.length();\n        long len2 = substring.length();\n\
    \        \n        List<String> result = new ArrayList<String>();\n        for\
    \ (int i = 0; i < len1 - len2; ++i) {\n            if (string.substring(i, len1\
    \ + i).equals(substring))\n                result.add(string.substring(i, len1\
    \ + i));\n        }\n        \n        for (String s : result) {\n           \
    \ count+=1;\n        }\n        \n        return count;", "        String cleanedString\
    \ = string.replaceAll(\"[^\" + substring + \"]\", \"\");\n        String cleanedSubString\
    \ = substring.replaceAll(\"[^\" + string + \"]\", \"\");\n\n        return cleanedString.length()\
    \ - cleanedSubString.length();", '        return howManyTimesImpl(string, substring,
    0);', '        return string.chars().filter(c -> c == substring).count() + string.chars().filter(c
    -> c!=substring).count() - string.split(substring).length - 1;', "        return\
    \ Stream.of(string.split(substring))\n                .map(s -> {\n          \
    \          long result = 1;\n                    for (int i = 0; i < s.length();\
    \ i++) {\n                        s = s.substring(0, i) + s.substring(i + 1);\n\
    \                        result = result * (long) Math.pow(2, s.length() - i)\
    \ * s.contains(substring);\n                    }\n                    return\
    \ result;\n                })\n                .sum();", '        return LongStream.range(0,
    string.length() - substring.length()).filter(i -> string.substring(i, i + substring.length()).equals(substring)).count();',
  "        int count = 0;\n        for (int i = 0; i < string.length(); i++) {\n \
    \           if (string.charAt(i) == substring.charAt(0)) {\n                for\
    \ (int j = 1; j < substring.length(); j++) {\n                    if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                        count++;\n              \
    \          i++;\n                        j++;\n                    }\n       \
    \         }\n            }\n        }\n        return count;", "        return\
    \ Arrays.stream(string.toLowerCase().split(\"\"))\n                .mapToLong(s\
    \ -> string.indexOf(substring, 0, s.length()))\n                .sum();", "  \
    \      long result = 0;\n\n        for (int i = 0; i <= string.length(); i++)\
    \ {\n            if (string.indexOf(substring, i) == i)\n                ++result;\n\
    \        }\n\n        return result;", '        return string.indexOf(substring).longValue();',
  '        return howManyTimesImpl(string, substring, 0);', "        int count = 0;\n\
    \        long length = 0;\n        for (int i = 0; i < string.length(); i++) {\n\
    \            if (string.charAt(i) == substring.charAt(0)) {\n                count++;\n\
    \            }\n        }\n        for (int i = 0; i < string.length(); i++) {\n\
    \            int j = i + substring.length();\n            length += string.substring(i,\
    \ j).length();\n            if (i == j) break;\n            if (string.charAt(i)\
    \ == substring.charAt(substring.length() - 1)) {\n                count++;\n \
    \               i++;\n            }\n        }\n        return count;", "    \
    \    long count = 0;\n        for (int i = 0; i < string.length(); i++) {\n  \
    \          if (string.charAt(i) == substring.charAt(0)) {\n                for\
    \ (int j = 1; j < substring.length(); j++) {\n                    if (string.charAt(i)\
    \ == substring.charAt(j)) {\n                        count += 1;\n           \
    \         }\n                }\n            }\n        }\n        return count;",
  "        if (string == null || substring == null || string.isEmpty() || substring.isEmpty())\
    \ {\n            return 0l;\n        }\n        String[] chars = string.split(\"\
    \");\n        String[] chars2 = substring.split(\"\");\n        long[] times =\
    \ new long[chars.length];\n        for(int i = 0; i < chars.length; i++) {\n \
    \           times[i] = chars[i].compareTo(chars2[i]);\n        }\n        int\
    \ minIndex = 0;\n        int maxIndex = times.length - 1;\n        while(true)\
    \ {\n            int mid = (minIndex + maxIndex) / 2;\n            if(times[mid]\
    \ == 0) {\n                return 0l;\n            }\n            if(times[mid]\
    \ < 0) {\n                maxIndex = mid;\n            } else {\n            \
    \    minIndex = mid;\n            }\n        }", '        return string.split(substring).length
    - 1;', "        long result = Long.MAX_VALUE;\n        Set<String> set = new HashSet<>();\n\
    \        for(char c: string.toCharArray()) {\n            for(int i=0; i<substring.length();\
    \ i++) {\n                if(c == substring.charAt(i)) {\n                   \
    \ set.add(c);\n                    break;\n                }\n            }\n\
    \        }\n        for(char c: set.toArray(new char[set.size()])) {\n       \
    \     int count = 0;\n            for(int i=0; i<string.length(); i++) {\n   \
    \             if(c == string.charAt(i)) {\n                    count++;\n    \
    \                break;\n                }\n            }\n            if(count\
    \ > 0) {\n                result = Math.min(result, count-1);\n            }\n\
    \        }\n        return result;", "        if (string.isEmpty())\n        \
    \    return 0;\n\n        return string.toLowerCase().indexOf(substring.toLowerCase())\
    \ + howManyTimes(string.substring(0, string.toLowerCase().indexOf(substring.toLowerCase())),\
    \ substring);", "        long count = 0;\n        long start = string.indexOf(substring);\n\
    \        while (start >= 0) {\n            String nextString = string.substring(start+substring.length(),\
    \ string.length());\n            start = nextString.indexOf(substring);\n    \
    \        count += 1;\n        }\n        return count;", "        long count =\
    \ 0;\n        int i;\n        for(i = 0; i < string.length(); i++) {\n       \
    \     if(string.substring(i, i+substring.length()).equals(substring)) {\n    \
    \            count++;\n            }\n        }\n        return count;", '        return
    string.chars().filter(x -> x == substring.charAt(0)).filter(x -> x == substring.charAt(1)).filter(x
    -> x == substring.charAt(2)).filter(x -> x == substring.charAt(3)).count();',
  '        return string.length() - string.toLowerCase().indexOf(substring.toLowerCase(),
    0l);', '        return string.length() - substring.length() + 1 + string.split(substring).length
    - 1;', "        long sum = 0;\n        int i = 0;\n        int length = string.length();\n\
    \n        while ((i <= length) && (i < length + substring.length())) {\n     \
    \       int start = i;\n            int end = i + substring.length();\n      \
    \      int count = 0;\n            for (; i < length; i++) {\n               \
    \ if (string.charAt(i) == substring.charAt(0)) {\n                    count++;\n\
    \                }\n                if (string.charAt(i) == substring.charAt(end))\
    \ {\n                    count++;\n                }\n                if (string.charAt(i)\
    \ == substring.charAt(end) && end < length) {\n                    count++;\n\
    \                }\n                if (string.charAt(i) == substring.charAt(end)\
    \ && end < length && end + 1 < length) {\n                    count++;\n     \
    \           }\n            }\n            if (count == substring.length()) {\n\
    \                sum += count;\n            }\n            i++;\n        }\n \
    \       return sum;"]
stop_tokens:
- "\n    }\n"
