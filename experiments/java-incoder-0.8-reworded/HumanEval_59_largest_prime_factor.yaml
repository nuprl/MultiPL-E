name: HumanEval_59_largest_prime_factor
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return the largest prime factor of n. Assume n > 1 and is\
  \ not a prime.\n    // >>> largestPrimeFactor((13195l))\n    // (29l)\n    // >>>\
  \ largestPrimeFactor((2048l))\n    // (2l)\n    public static long largestPrimeFactor(long\
  \ n) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(largestPrimeFactor((15l))\
  \ == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l))\
  \ == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l))\
  \ == (29l));\n    }\n\n}\n"
completions: ["        if (n == 1)\n            return 1;\n        if (n == 2)\n \
    \           return 2;\n        Set<Long> factors = new HashSet<>();\n        long\
    \ maxFactor = 1;\n        long maxFactor2 = 1;\n        for (long i = 2; i <=\
    \ Math.sqrt(n); ++i) {\n            if (n % i == 0) {\n                while (n\
    \ % i == 0) {\n                    factors.add(i);\n                    n = n\
    \ / i;\n                    if (n == 1)\n                        return maxFactor;\n\
    \                    ++maxFactor;\n                }\n                while (n\
    \ % i == 0) {\n                    factors.add(i);\n                    n = n\
    \ / i;\n                    maxFactor2 = maxFactor;\n                    if (n\
    \ == 1)\n                        return maxFactor;\n                    maxFactor\
    \ = maxFactor2;\n                }\n            }\n        }\n        if (n >\
    \ 1)\n            factors.add(n);\n        if (factors.size() > 1)\n         \
    \   return factors.stream().max(Comparator.naturalOrder()).get();\n        else\n\
    \            return 1;", "        long max = Long.MIN_VALUE;\n        long maxFactor\
    \ = Long.MIN_VALUE;\n        long maxFactor2 = Long.MIN_VALUE;\n        // We\
    \ only need to test odd numbers up to (n / 2)^2\n        if (n >= (long)Math.sqrt(n))\
    \ {\n            long x = 1;\n            long next = 2;\n            long y =\
    \ (long)Math.sqrt(n);\n            while (true) {\n                // If n divides\
    \ evenly into next,\n                if ((next%2)==0) {\n                    //\
    \ We know that next divides into x by (x % 2) = 0\n                    if ((n%x)==0)\
    \ {\n                        long a = n/x;\n                        // If x is\
    \ a factor of n,\n                        if (a>=x) {\n                      \
    \      // We know that x is less than x^2\n                            // We know\
    \ that x is a factor of n\n                            if (a>y) {\n          \
    \                      // Since x is a factor of n,\n                        \
    \        // we know that x is less than n\n                                //\
    \ and n divides evenly into next\n                                // and next\
    \ divides into x by (x % 2) = 0\n                                // and x is a\
    \ factor of n\n                                // and x is a factor of next\n\
    \                                // Therefore n is a prime factor.\n         \
    \                       maxFactor=x;\n                                maxFactor2=y;\n\
    \                                max=x;\n                            } else {\n\
    \                                // Since x is a factor of n,\n              \
    \                  // we know that x is less than n\n                        \
    \        // and n divides evenly into next\n                                //\
    \ and next divides into x by (x % 2) = 0\n                                // and\
    \ x is not a factor of n\n                                // and x is not a factor\
    \ of next\n                                // Therefore n is not a prime factor.\n\
    \                                max=n;\n                                break;\n\
    \                            }\n                        } else {\n           \
    \                 // Since x is not a factor of n,\n                         \
    \   // we know that x is not a factor of next\n                            //\
    \ Therefore n is not a prime factor.\n                            max=n;\n   \
    \                         break;\n                        }\n                \
    \    } else {\n                        // Since x is not a factor of n,\n    \
    \                    // we know that x is not a factor of next\n             \
    \           // Therefore n is not a prime factor.\n                        max=n;\n\
    \                        break;\n                    }\n                } else\
    \ {\n                    // We know that next divides into x by (x % 2) = 1\n\
    \                    if ((n%x)==1) {\n                        long a = (n/x) +\
    \ 1;\n                        if (a<=x) {\n                            // Since\
    \ x is a factor of n,\n                            // we know that x is less than\
    \ x^2\n                            // and x is a factor of next\n            \
    \                // Therefore n is a prime factor.\n                         \
    \   maxFactor=x;\n                            max=x;\n                        ",
  "        Set<Long> primes = new HashSet<>();\n        for (long x = 2; x < n; x++)\
    \ {\n            if (isPrime(x)) {\n                primes.add(x);\n         \
    \   }\n        }\n        for (long x : primes) {\n            while (n % x ==\
    \ 0) {\n                n = n / x;\n            }\n        }\n        return n;",
  "        if (n <= 1l) throw new RuntimeException(\"n must be greater than 1 and\
    \ is not a prime\");\n        long largestPrimeFactor = 1l;\n        for (long\
    \ currentFactor = 2l; currentFactor < n; currentFactor += 2l) {\n            if\
    \ (n % currentFactor == 0l) break;\n            if (largestPrimeFactor < currentFactor)\
    \ {\n                largestPrimeFactor = currentFactor;\n            }\n    \
    \    }\n        return largestPrimeFactor;", "        long max = n;\n        long\
    \ d = 2;\n\n        while(!isPrime(d) && max > 1) {\n            max /= d;\n \
    \           d++;\n        }\n\n        return max;", "        final long l = (long)\
    \ Math.sqrt(n);\n        return largestPrimeFactor(l, n);", "        if (n % 2\
    \ == 0) {\n            n = n / 2;\n        }\n        if (n % 3 == 0) {\n    \
    \        n = n / 3;\n        }\n        if (n % 5 == 0) {\n            n = n /\
    \ 5;\n        }\n        if (n % 7 == 0) {\n            n = n / 7;\n        }\n\
    \        if (n % 11 == 0) {\n            n = n / 11;\n        }\n        if (n\
    \ % 13 == 0) {\n            n = n / 13;\n        }\n        if (n % 17 == 0) {\n\
    \            n = n / 17;\n        }\n        if (n % 19 == 0) {\n            n\
    \ = n / 19;\n        }\n        if (n % 23 == 0) {\n            n = n / 23;\n\
    \        }\n        if (n % 29 == 0) {\n            n = n / 29;\n        }\n \
    \       if (n % 31 == 0) {\n            n = n / 31;\n        }\n        if (n\
    \ % 37 == 0) {\n            n = n / 37;\n        }\n        if (n % 41 == 0) {\n\
    \            n = n / 41;\n        }\n        if (n % 43 == 0) {\n            n\
    \ = n / 43;\n        }\n        if (n % 47 == 0) {\n            n = n / 47;\n\
    \        }\n        if (n % 53 == 0) {\n            n = n / 53;\n        }\n \
    \       if (n % 59 == 0) {\n            n = n / 59;\n        }\n        if (n\
    \ % 61 == 0) {\n            n = n / 61;\n        }\n        if (n % 67 == 0) {\n\
    \            n = n / 67;\n        }\n        if (n % 71 == 0) {\n            n\
    \ = n / 71;\n        }\n        if (n % 73 == 0) {\n            n = n / 73;\n\
    \        }\n        if (n % 79 == 0) {\n            n = n / 79;\n        }\n \
    \       if (n % 81 == 0) {\n            n = n / 81;\n        }\n        if (n\
    \ % 87 == 0) {\n            n = n / 87;\n        }\n        if (n % 93 == 0) {\n\
    \            n = n / 93;\n        }\n        if (n % 97 == 0) {\n            n\
    \ = n / 97;\n        }\n        return n;", "        long maxFact = 1, maxFactPrime\
    \ = 2;\n        for(long i = 2; i <= Math.sqrt(n); ++i) {\n            if(n%i\
    \ == 0) {\n                maxFact = i;\n                maxFactPrime = n;\n \
    \           }\n            if(n%maxFact == 0) {\n                maxFact = maxFactPrime;\n\
    \                maxFactPrime = n;\n            }\n        }\n        return maxFact;",
  "        long factor = 1;\n        while (!isPrime(n)) {\n            factor++;\n\
    \            while (n % factor == 0) {\n                n /= factor;\n       \
    \     }\n        }\n        return factor;", "        if (n <= 1)\n          \
    \  return n;\n        return largestPrimeFactor(n - 1);", "        long p = 1;\n\
    \        while (p < n) {\n            long next = n%p;\n            if (next >\
    \ 1) return next; //return largest of two\n            else p = p + 1;\n     \
    \   }\n        return n;", "        long max = n;\n        for (long i = 2; i\
    \ <= Math.sqrt(max); i++) {\n            long prime = max;\n            while\
    \ (prime % i > 0) {\n                prime /= i;\n            }\n            if\
    \ (prime > max) {\n                max = prime;\n            }\n        }\n  \
    \      return max;", '        return largestPrimeFactor(n, (long) Math.sqrt(n));',
  "        long[] primeFactorsArray = new long[100];\n        Arrays.fill(primeFactorsArray,\
    \ (long) 0);\n        Arrays.fill(primeFactorsArray, (long) 1);\n        long\
    \ primeFactor = 0;\n        int counter = 0;\n        while (n > 1) {\n      \
    \      if (n % primeFactorsArray[counter] == 0) {\n                primeFactor++;\n\
    \            }\n            else {\n                primeFactorsArray[counter]\
    \ = primeFactor;\n                if (primeFactorsArray[counter] == n) break;\n\
    \            }\n            counter++;\n            n--;\n        }\n        primeFactorsArray[counter]\
    \ = primeFactor;\n        return primeFactorsArray[counter];", "        long maxFact\
    \ = 0;\n        long maxFactI = 0;\n        long m = 2l;\n\n        long i = 1l;\n\
    \        while ((m <= n) && (n % m == 0)) {\n            m = m * i;\n        \
    \    i++;\n        }\n\n        if (m > n) \n            return n;\n\n       \
    \ long fact = 1;\n        while ((m % 2l == 0) && (n % (m / 2l) == 0) && (n %\
    \ (m / 2l) != 0l)) {\n            m = m / 2l;\n            fact++;\n        }\n\
    \n        while (n % (m / 2l) != 0l) {\n            n = n - (m / 2l);\n      \
    \      fact--;\n        }\n\n        if (fact > maxFact) {\n            maxFact\
    \ = fact;\n            maxFactI = m;\n        }\n\n        return maxFactI;",
  "        if(n <= 2) return n;\n\n        long largestPrimeFactor = n;\n        for(long\
    \ i = 3; i * i <= n; i++) {\n            if(n%i == 0)\n                continue;\n\
    \            for(long j = (i+1)*i/(i+1); j <= Math.sqrt(i); j++) {\n         \
    \       if(i%j == 0)\n                    continue;\n                if(j > largestPrimeFactor)\
    \ {\n                    largestPrimeFactor = j;\n                }\n        \
    \    }\n        }\n        return largestPrimeFactor;", "        long largestPrimeFactor\
    \ = 0;\n        PrimeStream primeStream = new PrimeStream();\n        primeStream.push(n);\n\
    \        while (primeStream.size() > 0) {\n            long nextPrime = primeStream.pop();\n\
    \            if (nextPrime > largestPrimeFactor) {\n                largestPrimeFactor\
    \ = nextPrime;\n            }\n            if (nextPrime > 1) {\n            \
    \    primeStream.push(nextPrime - 1);\n            }\n        }\n        return\
    \ largestPrimeFactor;", "        // Sieve of Eratosthenes for prime factors\n\
    \        long i = 2;\n        long[] primes = new long[32];\n        while (true)\
    \ {\n            if (primes[i] != 0) {\n                while (n % primes[i] ==\
    \ 0) {\n                    primes[++i] = 1;\n                }\n            \
    \    if (primes[i] == n) {\n                    return primes[i];\n          \
    \      }\n            }\n            i += 2;\n            if (i >= 32) {\n   \
    \             return n;\n            }\n        }", "        if (n < 2l) return\
    \ 2l;\n        if (n == 2l) return n;\n        if (n % 2l == 1l) return n; //\
    \ 1 divides evenly, therefore the number is not prime\n\n        // Test the number\
    \ against all known primality tests (including trial division)\n        long p\
    \ = 2l;\n        while (n % p == 1l)\n            p = p + 1l;\n        if (p ==\
    \ 3l) return n;\n\n        // Refactor the number into a prime factorization using\
    \ trial division\n        long d = 2l;\n        while (n % d == 1l) {\n      \
    \      d = d + 1l;\n            if (d == 3l) return n; // d can only be 1 or 3\n\
    \        }\n\n        return n;", "        long maxFactor = 0;\n        final\
    \ long n = n;\n        int i = 2;\n        while(i <= n/2) {\n            if(n%i\
    \ == 0) {\n                maxFactor = i;\n                n = n/i;\n        \
    \        i++;\n                continue;\n            }\n            if(i*i >\
    \ n) {\n                maxFactor = i;\n                n = n/i;\n           \
    \     i++;\n                continue;\n            }\n            while(i*i <\
    \ n) {\n                i++;\n            }\n        }\n        return maxFactor;",
  "        if (n < 2) {\n            throw new IllegalArgumentException(\"n > 1\"\
    );\n        }\n        long largestPrimeFactor = n;\n        boolean isPrime =\
    \ true;\n        for(long i = 2; i <= n / 2; i++) {\n            if(n % i == 0)\
    \ {\n                isPrime = false;\n                break;\n            }\n\
    \        }\n        if(isPrime) {\n            long p = n;\n            for(long\
    \ i = 2; i <= n / 2; i++) {\n                if(p * i / n != n) {\n          \
    \          break;\n                }\n                if(p * i < n) {\n      \
    \              largestPrimeFactor = p * i;\n                    break;\n     \
    \           }\n            }\n        }\n        return largestPrimeFactor;",
  '        return largestPrimeFactor(n, n);', "        long primeFactor = 1, largestPrimeFactor\
    \ = 1;\n        for (long i = 2; i <= Math.sqrt(n); i++) {\n            long temp\
    \ = primeFactor * i;\n            if (temp > n) {\n                largestPrimeFactor\
    \ = temp;\n                primeFactor = 1;\n            } else {\n          \
    \      primeFactor = temp;\n            }\n        }\n        return largestPrimeFactor;",
  "        long factor = 1;\n        for (long i = 2; i <= (int) Math.sqrt(n); i++)\
    \ {\n            if (n % i == 0) {\n                factor *= i;\n           \
    \     if (factor < n) break;\n            }\n        }\n        return factor;",
  "        // write your code here\n        long max = 1l;\n        long candidate\
    \ = n;\n        long temp;\n        while(true){\n            if(n>1) if (n%2\
    \ == 0 && candidate%2 == 0) candidate/=2;\n            else if(n%2 == 1 && candidate%2\
    \ == 1) candidate/=2;\n            else break;\n            for(long i = 2l; i\
    \ <= candidate; i++){\n                if(candidate%i == 0){\n               \
    \     temp = candidate;\n                    candidate = i;\n                \
    \    if(temp>max) max = temp;\n                    break;\n                }\n\
    \            }\n        }\n        return max;", "        final long maxPrime\
    \ = Long.MAX_VALUE;\n        long candidate = 2;\n\n        while (true) {\n \
    \           long nextCandidate = (long) Math.sqrt(candidate);\n            while\
    \ (nextCandidate <= n) {\n                nextCandidate = (long) Math.sqrt(nextCandidate);\n\
    \            }\n\n            if (nextCandidate == candidate)\n              \
    \  break;\n            else if (nextCandidate > maxPrime) {\n                maxPrime\
    \ = candidate;\n            }\n\n            candidate = nextCandidate;\n    \
    \    }\n        return maxPrime;", "        // Return the largest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n        if (n < 2) return n;\n     \
    \   long p = 1;\n        while (n != 0) {\n            if (n % p == 0) return\
    \ p;\n            ++p;\n            n /= p;\n        }\n        return p;", " \
    \       long x = 1l;\n        for (long i = 2; i <= n / 2; i++) {\n          \
    \  if (n % i == 0) {\n                x = i;\n                break;\n       \
    \     }\n        }\n        if (n > 1) {\n            return x;\n        } else\
    \ {\n            return n;\n        }", "        \n        if (n <= 1) return\
    \ n;\n        int d = 2;\n        while (n % d == 0) {\n            d = d * 2;\n\
    \        }\n        for (long a = 2; a <= n/d; a++) {\n            if (n % a ==\
    \ 0) {\n                return a;\n            }\n        }\n        return n;",
  "        long[] primeFactors = new long[] {\n            3, // * 2, // * 3, // 4\
    \ * 3, // 8\n            5, // * 3, // * 4, // 16\n            7, // * 4, // *\
    \ 8, // 32\n            9, // * 8, // * 16, // 64\n            11, // * 16, //\
    \ * 32, // 128\n            13, // * 32, // * 64, // 256\n            17, // *\
    \ 64, // * 128, // 512\n            19, // * 128, // * 256, // 1024\n        \
    \    23, // * 256, // * 512, // 2048\n            29, // * 512, // * 1024, //\
    \ 4096\n            31, // * 1024, // * 2048, // 8192\n            37, // * 2048,\
    \ // * 4096, // 16384\n            43, // * 4096, // * 8192, // 32768\n      \
    \      47, // * 8192, // * 16384, // 65536\n            53, // * 16384, // * 32768,\
    \ // 131072\n            59, // * 32768, // * 65536, // 262144\n            61,\
    \ // * 65536, // * 131072, // 524288\n            67, // * 131072, // * 262144,\
    \ // 1048576\n            73, // * 262144, // * 524288, // 2097152\n         \
    \   79, // * 524288, // * 1048576, // 4194304\n            89, // * 1048576, //\
    \ * 2097152, // 8388608\n            97, // * 2097152, // * 8388608, // 16777216\n\
    \            101, // * 8388608, // * 16777216, // 33554432\n            103, //\
    \ * 16777216, // * 33554432, // 67108864\n            107, // * 33554432, // *\
    \ 67108864, // 134217728\n            109, // * 67108864, // * 134217728, // 268435456\n\
    \            113, // * 134217728, // * 268435456, // 536870912\n            117,\
    \ // * 268435456, // * 536870912, // 1073741824\n            125, // * 536870912,\
    \ // * 1073741824, // 2147483648\n            129, // * 1073741824, // * 2147483648,\
    \ // 4294967296\n            131, // * 2147483648, // * 4294967296, // ", "  \
    \      if (n < 2) {\n            return n;\n        }\n        List<Long> factors\
    \ = new ArrayList<>();\n        for (long i = 2; i <= n / 2; i++) {\n        \
    \    if (n % i == 0) {\n                factors.add(i);\n            }\n     \
    \   }\n        if (factors.size() > 0) {\n            long largestPrimeFactor\
    \ = factors.get(0);\n            for (Long factor : factors) {\n             \
    \   while (n % factor == 0) {\n                    largestPrimeFactor = factor;\n\
    \                    n = n / factor;\n                }\n            }\n     \
    \       return largestPrimeFactor;\n        } else {\n            return n;\n\
    \        }", "        long largest_prime_factor = 1;\n        for(long i = 1;\
    \ i <= n; i++){\n            if(n%i == 0){\n                largest_prime_factor\
    \ = i;\n            }\n        }\n        return largest_prime_factor;", "   \
    \     if (n < 2) return n;\n        long[] a = new long[(int) Math.ceil(Math.sqrt(n))];\n\
    \        Arrays.fill(a, (long) n);\n        int n0 = 1;\n        for (int i =\
    \ 1; i < a.length; i++) {\n            if (a[i] > 1) {\n                long j\
    \ = n0;\n                long m = i;\n                while (m > 0 && n % m ==\
    \ 0) {\n                    j = j;\n                    m = m / 2;\n         \
    \       }\n                while (j < i && a[j] * a[i] > n) j++;\n           \
    \     if (j != i) a[i] = a[j];\n                n0 *= a[i];\n            }\n \
    \       }\n        return n0;", "        // The prime factors of n are 1 and n.\n\
    \        List<Long> factors = new ArrayList<>();\n        for (int i = 1; i <=\
    \ n; i++) {\n            while (n % i == 0) {\n                factors.add(i);\n\
    \                n = n / i;\n            }\n        }\n        long largestFactor\
    \ = factors.stream().reduce((a, b) -> Math.max(a, b)).orElse(1);\n        return\
    \ largestFactor;", "        long largestPrimeFactor = 1;\n        BigInteger prime\
    \ = BigInteger.valueOf((long)1);\n        BigInteger limit = new BigInteger(String.valueOf(n));\n\
    \        while (prime.isProbablePrime(limit.bitLength())) {\n            BigInteger\
    \ tmp = prime.divide(limit, BigInteger.ONE, BigInteger.TEN);\n            if (tmp.compareTo(new\
    \ BigInteger(\"1\")) == 0)\n                prime = prime.add(new BigInteger(\"\
    1\"));\n            else\n                prime = tmp;\n            largestPrimeFactor\
    \ = prime.toLong();\n        }\n        return largestPrimeFactor;", '        return
    largestPrimeFactor(n, Long.MAX_VALUE);', "        Set<Long> primes = new HashSet<>();\n\
    \        for (int i = 2; i < n; i++) {\n            if (primes.contains(i)) continue;\n\
    \            if (n % i == 0) {\n                primes.add(i);\n             \
    \   n = n / i;\n            }\n        }\n        return n;", "        // Find\
    \ the largest prime factor of n\n        while (n % 2 == 0) {\n            while\
    \ (n % 3 == 0) {\n                n = n/3;\n            }\n            while (n\
    \ % 5 == 0) {\n                n = n/5;\n            }\n            while (n %\
    \ 7 == 0) {\n                n = n/7;\n            }\n            while (n % 9\
    \ == 0) {\n                n = n/9;\n            }\n            while (n % 11\
    \ == 0) {\n                n = n/11;\n            }\n            while (n % 13\
    \ == 0) {\n                n = n/13;\n            }\n            while (n % 17\
    \ == 0) {\n                n = n/17;\n            }\n            while (n % 19\
    \ == 0) {\n                n = n/19;\n            }\n            while (n % 23\
    \ == 0) {\n                n = n/23;\n            }\n            while (n % 29\
    \ == 0) {\n                n = n/29;\n            }\n            while (n % 31\
    \ == 0) {\n                n = n/31;\n            }\n            while (n % 37\
    \ == 0) {\n                n = n/37;\n            }\n            while (n % 41\
    \ == 0) {\n                n = n/41;\n            }\n            while (n % 43\
    \ == 0) {\n                n = n/43;\n            }\n            while (n % 47\
    \ == 0) {\n                n = n/47;\n            }\n            while (n % 53\
    \ == 0) {\n                n = n/53;\n            }\n            while (n % 59\
    \ == 0) {\n                n = n/59;\n            }\n            while (n % 61\
    \ == 0) {\n                n = n/61;\n            }\n            while (n % 67\
    \ == 0) {\n                n = n/67;\n            }\n            while (n % 71\
    \ == 0) {\n                n = n/71;\n            }\n            while (n % 73\
    \ == 0) {\n                n = n/73;\n            }\n            while (n % 79\
    \ == 0) {\n                n = n/79;\n            }\n            while (n % 81\
    \ == 0) {\n                n = n/81;\n            }\n            while (n % 83\
    \ == 0) {\n                n = n/83;\n            }\n            while (n % 89\
    \ == 0) {\n                n = n/89;\n            }\n            while (n % 97\
    \ == 0) {\n                n = n/97;\n            }\n            while (n % 105\
    \ == 0) {\n                n = n/105;\n            }\n            while (n % 113\
    \ == 0) {\n                n = n/113;\n            }\n            while (n % 121\
    \ == 0) {\n                n = n/121;\n            }\n            while (n % 131\
    \ == 0) {\n                n = n/131;\n            }\n            while (n % 145\
    \ == 0) {\n                n = n/145;\n            }\n            while (n % 151\
    \ == 0) {\n                n = n/151;\n            }\n            while (n % 165\
    \ == 0) {\n                n = n/165;\n            }\n            while (n % 173\
    \ == 0) {\n                n = n/173;\n            }\n            while (n % 185\
    \ == 0) {\n                n = n/185;\n            }\n            while (n % 193\
    \ == 0) {\n                n = n/", "        if (n<2) {\n            return n;\n\
    \        }\n\n        long i = 2;\n        long p = 2;\n        long m = n;\n\n\
    \        while (true) {\n            while (m % i == 0) {\n                p +=\
    \ 1;\n                m /= i;\n            }\n\n            if (m != 1) {\n  \
    \              return p;\n            }\n\n            i += 2;\n        }", " \
    \       // TODO: Implement this method.\n        long p = 2;\n        long q =\
    \ 2;\n        long r = 1;\n        for (;;) {\n            if (p * q >= n) {\n\
    \                return r;\n            }\n            if (n % p == 0) {\n   \
    \             r = q;\n            }\n            p = p * q;\n            q = q\
    \ + 1;\n        }", "        long[] factors = Arrays.stream(new long[] {2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47})\n                .filter(x\
    \ -> n%x == 0)\n                .toArray();\n\n        if (factors.length == 0)\n\
    \            return n;\n\n        long largestFactor = factors[0];\n        for\
    \ (long x : factors)\n            if (x > largestFactor)\n                largestFactor\
    \ = x;\n        return largestFactor;", "        long[] factors = new long[n +\
    \ 1];\n        Arrays.fill(factors, 2);\n        for (int i = 3; i <= n; i +=\
    \ 2) {\n            if (isPrime(i)) {\n                factors[--i] = i;\n   \
    \         }\n        }\n        return factors[0];", "        final Map<Long,\
    \ Long> cache = new HashMap<>();\n        return largestPrimeFactor(n, cache);",
  "        // TODO: Replace with your code\n        long largest_prime = Long.MAX_VALUE;\n\
    \        for (long i = 2; i <= n / 2; i++) {\n            if (n % i == 0) {\n\
    \                while (n % i == 0) {\n                    largest_prime = i;\n\
    \                    n /= i;\n                }\n                break;\n    \
    \        }\n        }\n        return largest_prime;", "        List<Long> factors\
    \ = new ArrayList<>();\n        for (long i = 2; i * i <= n; i++) {\n        \
    \    while (n % i == 0) {\n                factors.add(i);\n                n\
    \ = n / i;\n            }\n        }\n        return Math.max(factors.stream().reduce((a,\
    \ b) -> a * b), 1);", "        Set<Integer> primeFactors = new HashSet<>();\n\
    \        long maxFactor = 0;\n        while (n>1) {\n            int p = 2;\n\
    \            while (!primeFactors.contains(p)) {\n                if (n%p == 0)\
    \ p++;\n                else p = 1;\n            }\n            maxFactor = Math.max(maxFactor,\
    \ p);\n            primeFactors.add(p);\n            n = n/p;\n        }\n   \
    \     return maxFactor;", '        return largestPrimeFactor(n, true);', "   \
    \     long largestPrimeFactor = n;\n        long sqrtn = Math.sqrt(n);\n     \
    \   long i = 3;\n        while (i <= sqrtn) {\n            if (n % i == 0) {\n\
    \                while (n % i == 0) {\n                    n = n / i;\n      \
    \          }\n                if (n > largestPrimeFactor) largestPrimeFactor =\
    \ n;\n            }\n            i = i + 1;\n        }\n        return largestPrimeFactor;",
  "        long f = 2;\n        boolean isPrime = true;\n        for (long i = 2;\
    \ i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                isPrime\
    \ = false;\n                break;\n            }\n        }\n        if (n !=\
    \ 1 && isPrime) {\n            return f;\n        }\n        for (long i = 2;\
    \ ; i++) {\n            long m = i;\n            long p = i;\n            if (n\
    \ % i == 0) {\n                for (long j = 2; j <= (Math.sqrt(n) - 1); j++)\
    \ {\n                    if (n % p == 0) {\n                        m = p;\n \
    \                       p = i + (j / p);\n                    }\n            \
    \    }\n            }\n            if (m == n || m == 1) {\n                return\
    \ f;\n            }\n            if (m > n) {\n                break;\n      \
    \      }\n            f = p;\n            n = m;\n        }\n        return f;",
  "        long largestPrimeFactor = n;\n        long tester = 1;\n        while (tester\
    \ <= n / 2) {\n            if (n % tester == 0) {\n                largestPrimeFactor\
    \ = tester;\n                break;\n            }\n            tester += 1;\n\
    \        }\n        return largestPrimeFactor;", "        if (n <= 1)\n      \
    \      return 1;\n        long max = 1;\n        long min = 2;\n        boolean\
    \ prime = true;\n        for (long i = 2; i <= n / 2; ++i) {\n            if (n\
    \ % i == 0)\n                prime = false;\n        }\n        if (prime) {\n\
    \            for (long i = 2; i <= n / 2; ++i) {\n                if (n % i ==\
    \ 0) {\n                    if (max % i == 0) {\n                        max =\
    \ i;\n                        break;\n                    }\n                \
    \    if (min % i == 0) {\n                        min = i;\n                 \
    \   }\n                }\n            }\n        }\n        if (n > max) {\n \
    \           return max;\n        } else {\n            return n;\n        }",
  "        long max = 1;\n        long temp = n;\n        \n        for (long i =\
    \ 2; i <= temp; i += 1) {\n            if (n % i == 0) {\n                long\
    \ l = (long) Math.sqrt(temp);\n                long q = n / i;\n             \
    \   temp = i;\n                if (q > l && q <= temp) max = i;\n            }\n\
    \        }\n        return max;", "        List<Long> factors = new ArrayList<>();\n\
    \        for (long x = 2; x < (long) Math.sqrt(n); x++) {\n            if (n %\
    \ x == 0) {\n                factors.add(x);\n                while (x % x ==\
    \ 0) {\n                    x /= x;\n                }\n            }\n      \
    \  }\n        if (factors.size() > 0) {\n            long maxFactor = factors.get(0);\n\
    \            factors.removeIf(f -> f > maxFactor);\n            if (factors.size()\
    \ > 0)\n                maxFactor = factors.get(0);\n            return maxFactor;\n\
    \        }\n        return n;", "        long factor = 2;\n        boolean isPrime\
    \ = true;\n        while (factor < n) {\n            while (isPrime && n % factor\
    \ == 0) {\n                isPrime = false;\n            }\n            if (!isPrime\
    \ || n % factor == 0) {\n                factor = factor * 2;\n            } else\
    \ {\n                n = n / factor;\n            }\n        }\n        return\
    \ factor;", "        long res = 1l;\n        while (n % 2 == 0) {\n          \
    \  n = n / 2;\n        }\n        for (long d = 3; d < n; d++) {\n           \
    \ if (n % d == 0) {\n                n = n / d;\n                res = d;\n  \
    \          }\n        }\n        return res;", "        if (n == 1l) return n;\
    \ // 1l = 1 = 1\n        if (n == 0l) return 1l; // 0l = 1\n        if (n >= 2l)\
    \ return largestPrimeFactor(n / 2l) * 2l; // 2l = 2\n        \n        // All\
    \ numbers that do not divide evenly into n are candidates for prime factors.\n\
    \        // We can quickly eliminate these by checking if they can divide evenly\
    \ into n-1.\n        long p = 2l;\n        while (p < n-1l) if (n % p == 0l) return\
    \ p;\n        \n        // Since we know that n is not prime, we can eliminate\
    \ this by checking if\n        // the number is congruent to n-1.\n        long\
    \ q = n - 1l;\n        while (p < q) {\n            if (q % p == 0l) return p;\n\
    \            q = q / p;\n            p++;\n        }\n        // Since n is a\
    \ prime, we can eliminate this by checking if it is congruent to n.\n        return\
    \ q;", "        long largestPrimeFactor = n;\n        long factor = 2;\n     \
    \   while (factor <= n) {\n            while (n % factor == 0) {\n           \
    \     largestPrimeFactor = factor;\n                break;\n            }\n  \
    \          factor++;\n        }\n        return largestPrimeFactor;", "      \
    \  List<Long> factors = new ArrayList<>();\n        for (long i = 2; i < n; i++)\
    \ {\n            if (n % i == 0) {\n                factors.add(i);\n        \
    \        if (n / i > i > 1) {\n                    factors.add(n / i);\n     \
    \           }\n            }\n        }\n        factors.add(Long.valueOf(Math.sqrt(n)));\n\
    \        long largestPrimeFactor = factors.stream()\n                .max((a,\
    \ b) -> Long.compare(a, b)).orElse(factors.get(0));\n        return largestPrimeFactor;",
  "        return largestPrimeFactorImpl(new LongToLongFunction<Long>() {\n      \
    \      public Long apply(long number) {\n                return number;\n    \
    \        }\n        });", "        // Write your code here.\n        long largestPrime\
    \ = 1;\n        long i = 2;\n        while (i < n) {\n            while (n % i\
    \ == 0) {\n                largestPrime = i;\n                break;\n       \
    \     }\n            i++;\n        }\n        return largestPrime;", "       \
    \ long largest = 2;\n        long factor = 2;\n        while (n / factor > 2)\
    \ {\n            if (n % factor == 0) {\n                largest = factor;\n \
    \               factor = 2;\n            } else {\n                factor++;\n\
    \            }\n        }\n        if (n != 2 && n % 2 == 0) {\n            largest\
    \ = factor;\n            factor = 2;\n        }\n        return largest;", " \
    \       long largestPrimeFactor = 0;\n        long i = 11;\n        while (i !=\
    \ n) {\n            if (n % i == 0) {\n                largestPrimeFactor = i;\n\
    \            }\n            i += 6;\n        }\n        return largestPrimeFactor;",
  '        return largestPrimeFactor(factors(n));', "        Set<Long> factors = new\
    \ HashSet<>();\n        for (long d = 2; d <= n / 2; ++d) {\n            if (n\
    \ % d == 0) {\n                while (n % d == 0) {\n                    factors.add(d);\n\
    \                    n /= d;\n                }\n            }\n        }\n  \
    \      if (n != 1) {\n            factors.add(n);\n        }\n        return factors.stream().findFirst().orElse(1);",
  "        // The prime factors of n are those that are smaller than n / i.\n    \
    \    // The largestPrimeFactor of n is the largest of these prime factors.\n \
    \       // A prime factor of n must be larger than all smaller prime factors.\n\
    \        // If n is divisible by any prime factor of n, then n is prime.\n   \
    \     // If n is divisible by 2m, n is prime, where m is smallest prime factor.\n\
    \        // If n is divisible by any prime factor of n, then n is prime.\n   \
    \     // If n is divisible by 2m, n is prime, where m is smallest prime factor.\n\
    \        // In any case, the largest prime factor of n is the largest\n      \
    \  // prime factor of n that is smaller than n.\n        // If n is not divisible\
    \ by any prime factor of n, then n is not prime.\n        // If n is not divisible\
    \ by any prime factor of n, then n is not prime.\n        // If n is not divisible\
    \ by any prime factor of n, then n is not prime.\n        // The largest prime\
    \ factor of n is then n.\n        final Map<Long, Integer> primeFactors = IntStream.range(0,\
    \ (int) Math.sqrt(n))\n                .filter(x -> (n % x) == 0)\n          \
    \      .filter(x -> (n % x == 0))\n                .boxed()\n                .collect(Collectors.toMap(x,\
    \ y -> x * y, (x, y) -> x + y));\n\n        long largestPrimeFactor = n;\n\n \
    \       for (Map.Entry<Long, Integer> entry : primeFactors.entrySet()) {\n   \
    \         if (entry.getKey() > largestPrimeFactor) {\n                largestPrimeFactor\
    \ = entry.getKey();\n            }\n        }\n        return largestPrimeFactor;",
  "        long factor = 0;\n        for (long a = 2; a < n; a++) {\n            if\
    \ (n % a == 0) {\n                while (n % a == 0) {\n                    factor\
    \ = a;\n                    n /= a;\n                }\n            }\n      \
    \  }\n        return factor;", "        long i = 2;\n        while (i <= n / i)\
    \ {\n            if (n % i == 0) {\n                i++;\n                n =\
    \ n / i;\n            } else {\n                i = 2;\n            }\n      \
    \  }\n        return n;", "        if (n < 2)\n            return 2;\n       \
    \ long largestPrime = 2;\n        for (long i = 2; i < n; i++) {\n           \
    \ long factorOfN = (long) Math.sqrt(i);\n            if (i % factorOfN != 0) {\n\
    \                continue;\n            }\n            while (n % i == 0) {\n\
    \                largestPrime = i;\n                n /= i;\n            }\n \
    \       }\n        return largestPrime;", "        if (n < 2) return 1l;\n   \
    \     long factor = 1;\n        for (long i = 2l; i <= n; i++) if (n % i == 0)\
    \ factor = i;\n        return factor;", "        long largestPrimeFactor = 1;\n\
    \        if (n > 1) {\n            long test = 3;\n            while (test <=\
    \ Math.sqrt(n)) {\n                if (n % test == 0) {\n                    largestPrimeFactor\
    \ = test;\n                }\n                ++test;\n            }\n       \
    \ }\n        return largestPrimeFactor;", "        PrimeFactor[] primeFactors\
    \ = new PrimeFactor[(int) Math.sqrt(n) + 1];\n        boolean isPrime[] = new\
    \ boolean[(int) Math.sqrt(n) + 1];\n        Arrays.setAll(isPrime, i -> true);\n\
    \        for (long i = 2; i <= n; i++) {\n            if (isPrime[i]) {\n    \
    \            for (long j = i * i; j < n; j += i) {\n                    isPrime[j]\
    \ = false;\n                }\n            }\n        }\n        for (long i =\
    \ 2; i <= n; i++) {\n            if (isPrime[i]) {\n                long maxFactor\
    \ = i;\n                for (long j = 2 * i; j < n; j += i) {\n              \
    \      if (isPrime[j]) {\n                        maxFactor = j;\n           \
    \             break;\n                    }\n                }\n             \
    \   primeFactors[i - 2] = new PrimeFactor(i, maxFactor);\n            }\n    \
    \    }\n        long maxFactor = 0;\n        for (long i = 2; i <= n; i++) {\n\
    \            if (primeFactors[i - 2] == null) {\n                maxFactor = i;\n\
    \                break;\n            }\n            if (maxFactor < primeFactors[i\
    \ - 2].maxFactor) {\n                maxFactor = primeFactors[i - 2].maxFactor;\n\
    \            }\n        }\n        return maxFactor;", "        if(n <= 1l) {\n\
    \            return n;\n        }\n        \n        Set<Long> set = new HashSet<>();\n\
    \        \n        long prev = (1l<<32l);\n        \n        for(int i=32l; i<=n;\
    \ i++) {\n            if(set.contains(i)) {\n                prev = (1l<<i)-1;\n\
    \                break;\n            }\n            \n            set.add(i, true);\n\
    \            \n            int bit = ((1l<<i)-1);\n            \n            for(int\
    \ j=bit-1; j>=0; --j) {\n                if( (1l<<j) < prev && ((1l<<j)-1) ==\
    \ prev) {\n                    prev = prev-(1l<<j);\n                    break;\n\
    \                }\n            }\n        }\n        \n        return prev;",
  "        if (n == 1) return n;\n\n        long highestPrimeFactor = n; // highestPrimeFactor\
    \ will remain constant throughout this function\n        long highestPrimeFactorIndex\
    \ = n; // highestPrimeFactorIndex will change with each iteration\n\n        for\
    \ (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                long\
    \ primeFactor = i;\n                long lastFoundPrimeFactor = n;\n         \
    \       while (lastFoundPrimeFactor % primeFactor == 0 && lastFoundPrimeFactor\
    \ != 2) {\n                    lastFoundPrimeFactor--;\n                }\n\n\
    \                if (lastFoundPrimeFactor > highestPrimeFactor) {\n          \
    \          highestPrimeFactor = lastFoundPrimeFactor;\n                    highestPrimeFactorIndex\
    \ = i;\n                }\n            }\n        }\n\n        if (highestPrimeFactorIndex\
    \ == n / 2) {\n            highestPrimeFactor = highestPrimeFactorIndex * 2;\n\
    \        }\n\n        return highestPrimeFactor;", "        long result = n;\n\
    \        boolean isPrime = true;\n\n        // Loop over all odd numbers less\
    \ than n.\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n\
    \ % i == 0) {\n                isPrime = false;\n            }\n        }\n\n\
    \        // If n is not a prime number, then it can have no prime factors.\n \
    \       if (!isPrime) {\n            return 0;\n        }\n\n        // If n has\
    \ a single factor that is a prime, then it must be prime also.\n        if (n\
    \ == 1) {\n            return 1;\n        }\n\n        // Loop over all odd numbers\
    \ less than n.\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n          \
    \  if (n % i == 0) {\n                long factor = n / i;\n                if\
    \ (factor > result) {\n                    result = factor;\n                }\n\
    \            }\n        }\n\n        return result;", "        // Base case for\
    \ special cases\n        if (n <= 1) return 1;\n        // If n is prime, return\
    \ it\n        if (n <= 3) return n;\n        // Find next prime\n        long\
    \ nextPrime = primeIterator.nextLong();\n        // Iterate through all multiples\
    \ of nextPrime up to the square root\n        long largestPrime = 1;\n       \
    \ for (long i = 3; i <= Math.sqrt(n); i += nextPrime) {\n            long factor\
    \ = isPrime(i);\n            if (factor > largestPrime) {\n                largestPrime\
    \ = factor;\n            }\n        }\n        // Return nextPrime if largest\
    \ prime is greater than n\n        return largestPrime > n ? nextPrime : n;",
  "        Set<Long> factors = new HashSet<>();\n        for (long i = 2; i <= Math.sqrt(n);\
    \ i++) {\n            if (n % i == 0) {\n                long l = (long) Math.sqrt(n)\
    \ / i;\n                if (factors.contains(l)) {\n                    continue;\n\
    \                } else {\n                    factors.add(l);\n             \
    \       return l;\n                }\n            }\n        }\n        return\
    \ n;", "        long largest_factor = 1l; \n        for(long i = 1; i <= n; i++)\
    \ {\n            if(n%i == 0) {\n                largest_factor = i;\n       \
    \         break;\n            }\n        }\n        return largest_factor;", '        //
    Implement this function', "        long maxFact = 1;\n        for(long x = 2;\
    \ x <= n; x++) {\n            if(n%x == 0) {\n                if(x*x > n) break;\n\
    \                maxFact = x;\n            }\n        }\n        return maxFact;",
  "        if (n < 2)\n            return 0;\n        return largestPrimeFactor(sqrt(n));",
  "        PrimeFactorsFinder pf = new PrimeFactorsFinder();\n        return pf.findLargestPrimeFactor(n);",
  "        long p = 2;\n        while(n > p) {\n            long c = n/p;\n      \
    \      if (isPrime(p))\n                return p;\n            p = c + 1;\n  \
    \      }\n        return n;", '        return largestPrimeFactor(n, 2);', "  \
    \      if (n == 1) {\n            return n;\n        }\n        return largestPrimeFactor(n/2);",
  "        long result = 1;\n        for (long d = 2l; d <= Math.sqrt(n); d *= 2l)\
    \ {\n            if (n % d == 0l) break;\n            if (d > result) {\n    \
    \            result = d;\n            }\n        }\n        return result;", " \
    \       long n = n; // not required, just to show that the local variable can\
    \ be re-used\n        long p = 2; // not required, just to show that the local\
    \ variable can be re-used\n        long q = n - 1; // not required, just to show\
    \ that the local variable can be re-used\n        while (true) {\n           \
    \ if (n % (p * p) == 0) {\n                return p * p;\n            }\n    \
    \        else if (n % (q * q) == 0) {\n                return q * q;\n       \
    \     }\n            p = q + 1;\n            q = p + ((p + q) / 2);\n        }",
  "        if(isPrime(n)) return n;\n        \n        long i = 2;\n        while(isPrime(i)\
    \ && n < i) {\n            n /= i;\n        }\n        return n;", "        long\
    \ p = 2; long q = n; long r = 2;\n        while (q > 0) {\n            if (q %\
    \ p == 0) {\n                q -= p;\n            } else {\n                r++;\n\
    \            }\n            p++;\n        }\n        return r;", "        List<Long>\
    \ factors = new ArrayList<>() ;\n        for (int i = 3; i <= Math.sqrt(n); i\
    \ += 2) {\n            if (n % i == 0) {\n                factors.add(i) ;\n \
    \           }\n        }\n        if (factors.isEmpty()) {\n            return\
    \ 1 ;\n        }\n        long largest = 1l ;\n        for (long factor : factors)\
    \ {\n            if (largest < factor) {\n                largest = factor ;\n\
    \            }\n        }\n        return largest ;", "        long largestPrimeFactor\
    \ = Long.MIN_VALUE;\n        if (n == 1l) {\n            largestPrimeFactor =\
    \ 1l;\n        } else {\n            for (long i = 2l; i <= Math.sqrt(n); i++)\
    \ {\n                if (n % i == 0) {\n                    largestPrimeFactor\
    \ = i;\n                    break;\n                }\n            }\n       \
    \ }\n        return largestPrimeFactor;", '        return largestPrimeFactor(n);',
  "        long largest = 1;\n        for(long i = 2; i < n; ++i) {\n            if(n\
    \ % i == 0) {\n                largest = i;\n            }\n        }\n      \
    \  return largest;", "        long largestPrimeFactor = 1l;\n        long currentFactor\
    \ = 2l;\n\n        while ((n % currentFactor) != 0) {\n            currentFactor++;\n\
    \        }\n\n        while (currentFactor != n) {\n            if (n % currentFactor\
    \ == 0) {\n                largestPrimeFactor = currentFactor;\n            }\n\
    \            currentFactor++;\n        }\n        return largestPrimeFactor;",
  "        if (n<2) return n;\n        long largestPrimeFactor = Long.MAX_VALUE;\n\
    \        for (long i=2; i<=n; i++) {\n            while (n%i==0) {\n         \
    \       n /= i;\n                if (n>largestPrimeFactor) {\n               \
    \     largestPrimeFactor = n;\n                }\n            }\n        }\n \
    \       return largestPrimeFactor;", "        long maxFactor = Long.MAX_VALUE;\n\
    \        long result = 1;\n        while (n % 2 == 0) {\n            maxFactor\
    \ = n;\n            n /= 2;\n        }\n        while (n % 3 == 0) {\n       \
    \     if (result != 2) {\n                maxFactor = n;\n            }\n    \
    \        n /= 3;\n        }\n        while (n % 5 == 0) {\n            if (result\
    \ != 3) {\n                maxFactor = n;\n            }\n            n /= 5;\n\
    \        }\n        if (n != 1) {\n            while (n > 1) {\n             \
    \   long primeFactor = n;\n                while (n % primeFactor == 0) {\n  \
    \                  maxFactor = primeFactor;\n                    n /= primeFactor;\n\
    \                }\n            }\n        }\n        return maxFactor;", "  \
    \      if (n <= 1) return 1;\n        long a = n;\n        long p1 = 2l;\n   \
    \     long p2 = 3l;\n        long factor = 2;\n        while (a > 1) {\n     \
    \       while (p < n && (p * p) >= a) p++;\n            if (p < n && ((p1 += p),\
    \ p * p) < a) p++;\n            if (p < n && ((p2 += p), p * p) < a) p++;\n  \
    \          if (p > n) return factor;\n            while (p > 1) { p--; factor\
    \ *= p; }\n            p1++;\n            p2++;\n        }\n        return factor;",
  '        return largestPrimeFactor(n,2);', "        if (n<1) return n;\n       \
    \ long[] sieve = new long[11999];\n        for (int i=0;i<divisors;++i) sieve[i]=1;\n\
    \        for (int i=0;i<n;++i) {\n            sieve[i]=1;\n            for (int\
    \ j=i;j*j<=n;j+=i) sieve[j]=0;\n        }\n        long max=0;\n        for (int\
    \ i=2; i<sieve.length; ++i) {\n            if (sieve[i]==1) continue;\n      \
    \      long d=i;\n            while ((d*d)<=n) d=d*d+i;\n            if (d>max)\
    \ max=d;\n        }\n        return max;", "        // Create a stream of n prime\
    \ factors starting with 2.\n        // If n is prime then there will be no factors\
    \ less than 3.\n        Stream<Long> factors = Stream.generate(factor(n, 2));\
    \ \n        // Find the largest factor in the stream.\n        Optional<Long>\
    \ largestFactor = factors.max();\n        // Return the largest factor or -1 if\
    \ there isn't one.\n        return largestFactor.isPresent() ? largestFactor.get()\
    \ : -1;", "        if (n <= 1) {\n            return 1l;\n        }\n        if\
    \ (n <= 3) {\n            return n;\n        }\n        long p = 2;\n        for\
    \ (long i = 4; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n    \
    \            p = i;\n            }\n        }\n        if (p * p > n) {\n    \
    \        return p * p;\n        }\n        return n;", "        long f = 2;\n\
    \        long m = n;\n        while (f * f <= m) {\n            f += 2;\n    \
    \    }\n        while (m > 1) {\n            while (m % f == 0) {\n          \
    \      m /= f;\n            }\n            f += 2;\n        }\n        return\
    \ f;", "        long maxFactor = 1;\n        Set<Long> factors = new HashSet<>();\n\
    \        while (n % maxFactor != 0) {\n            while (n % maxFactor == 0)\
    \ {\n                factors.add(maxFactor);\n                n = n / maxFactor;\n\
    \            }\n            maxFactor++;\n        }\n        factors.remove(maxFactor);\n\
    \        return (long) factors.stream().reduce(0, (accu, v) -> accu * v);", " \
    \       if (n <= 2) return 1l;\n        long max = 1l;\n        long next = 1l;\n\
    \        long divisor = 2l;\n        boolean even = true;\n        for (long i\
    \ = 3; i * i <= n; i += 2) {\n            if (n % i == 0) {\n                next\
    \ = i;\n                break;\n            }\n        }\n        long p = 2;\n\
    \        long x = 2;\n        boolean found = false;\n        while (!found &&\
    \ x <= n) {\n            if (n % x == 0) {\n                found = true;\n  \
    \          } else {\n                p = x;\n            }\n            x += 2;\n\
    \        }\n        if (found) {\n            while (n % p == 0) {\n         \
    \       max += p;\n                n /= p;\n            }\n        }\n       \
    \ if (n != 1l) {\n            max = Math.max(max, largestPrimeFactor(n));\n  \
    \      }\n        return max;", "        if (n == 1) return 1l;\n        if (n\
    \ % 2 == 0) return 2;\n        if (n % 3 == 0) return 3;\n        final long max\
    \ = (long) Math.sqrt(n) - 1;\n        long i = 5;\n        while (i <= max) {\n\
    \            long j = (long) Math.sqrt(i) + 1;\n            if (n % i == 0) {\n\
    \                while (j < n / i) {\n                    ++j;\n             \
    \   }\n                return i;\n            }\n            ++i;\n        }\n\
    \        return n;", "        long max = Long.MAX_VALUE;\n        long cur = n;\n\
    \        long factor = 1;\n        while (cur > 1) {\n            if (isPrime(cur))\
    \ {\n                factor *= cur;\n                while (cur % cur == 0)\n\
    \                    cur /= cur;\n            } else {\n                if (cur\
    \ > max) {\n                    max = cur;\n                    factor = Long.MAX_VALUE;\n\
    \                } else if (cur < 2) {\n                    max = cur;\n     \
    \               factor = 1;\n                } else {\n                    cur\
    \ /= cur;\n                }\n            }\n        }\n        return factor;",
  "        // Assume n is prime\n        if (n <= 1) return n;\n        // Sieve of\
    \ Erastothenes\n        long[] primes = Arrays.stream(new long[n + 1]).filter(i\
    \ -> i != 1).mapToLong(i -> i).sorted().toArray();\n        // Initialize answer\
    \ as prime number\n        long largestPrime = primes[0];\n        // Iteratively\
    \ find largest prime factor\n        for (long i = 2; i <= n; i++) {\n       \
    \     if (primes[i] <= largestPrime) {\n                // Check if next number\
    \ is too large\n                if (i % primes[i] > 0)\n                    largestPrime\
    \ = primes[i];\n                // Check if not prime\n                else break;\n\
    \            }\n        }\n        return largestPrime;", "        Set<Long> factors\
    \ = findFactors(n, 2l);\n        Long largest = factors.stream().max(Comparator.naturalOrder()).orElseThrow(RuntimeException::new);\n\
    \        for (long factor : factors) {\n            if (largest % factor == 0)\
    \ {\n                largest = factor;\n                break;\n            }\n\
    \        }\n        return largest;", "        if (n < 2) return -1;\n       \
    \ long max = 1l;\n        long p = 2;\n        while (p < n) {\n            if\
    \ (n % p == 0) return p;\n            if (p < n / p) max = p;\n            p++;\n\
    \        }\n        return max;", "        long largestPrimeFactor = n;\n    \
    \    if (n == 1) { return largestPrimeFactor; }\n        if (n % 2 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 3 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 5 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 7 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 11 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 13 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 17 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 19 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 23 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 29 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 31 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 37 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 41 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 43 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 47 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 53 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 59 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 61 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 67 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 71 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 73 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 79 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 83 == 0) { largestPrimeFactor\
    \ = largestPrimeFactor * 3 + 1; }\n        if (n % 89 == 0) { largest", "    \
    \    if (n == 1) return 1;\n        long r = 2;\n        long m = n;\n       \
    \ while (m != 1) {\n            if (n % r == 0) {\n                m--;\n    \
    \            r++;\n            } else break;\n        }\n        if (m == 1) return\
    \ n;\n        long l = 1;\n        while (l < n) {\n            if (n % l == 0)\
    \ {\n                m--;\n                l++;\n            } else {\n      \
    \          n /= l;\n                break;\n            }\n        }\n       \
    \ return m;", "        long res = n;\n        long cur = n;\n        boolean prime\
    \ = true;\n        while (cur > 1) {\n            prime = prime && isPrime(cur);\n\
    \            if (prime) {\n                res = Math.max(res, cur);\n       \
    \     }\n            cur = cur / 2;\n        }\n        return res;", "      \
    \  long largestPrimeFactor = 1;\n        for(long i = 2; i <= Math.sqrt(n); i++)\
    \ {\n            if(n%i == 0) {\n                largestPrimeFactor = i;\n   \
    \             break;\n            }\n        }\n        return largestPrimeFactor;",
  "        long prime = 1;\n        while (n % prime == 0) {\n            while (n\
    \ % prime == 0) {\n                prime++;\n            }\n            n = (long)\
    \ (Math.sqrt(n));\n        }\n        return prime;", "        long result = n;\n\
    \        while (result != 1) {\n            while (result % 2 == 0) {\n      \
    \          result /= 2;\n            }\n            if (result % 2 == 1) {\n \
    \               result /= 2;\n                result += 1;\n            }\n  \
    \      }\n        return result;", "        // Find the largest prime factor of\
    \ n.\n        // A prime factor is a factor that does not divide n.\n        //\
    \ If n is not prime, return -1.\n        // If n is 1, return 1.\n        if (n\
    \ == 1) {\n            return 1;\n        }\n        final PrimeCache<Long> primeCache\
    \ = new PrimeCache<>();\n        long maxFactor = n;\n        PrimeCache<Long>\
    \ primeFactors = primeCache.getPrimeFactors(n);\n        for (long prime : primeFactors)\
    \ {\n            long factorOfPrime = n / prime;\n            if (factorOfPrime\
    \ > maxFactor) {\n                maxFactor = factorOfPrime;\n            }\n\
    \        }\n        return maxFactor;", "        Set<Long> factors = new HashSet<Long>();\n\
    \        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n \
    \               while (n % i == 0) {\n                    n /= i;\n          \
    \          factors.add(i);\n                }\n            }\n        }\n    \
    \    if (n > 2)\n            factors.add(n);\n        long maxFactor = factors.isEmpty()\
    \ ? 1L : factors.stream().max().getAsLong();\n        return maxFactor;", "  \
    \      long f = 2;\n        while (n % f == 0) {\n            ++f;\n        }\n\
    \        if (f*f > n) return f;\n        if (n % f != 0) return -1;\n        return\
    \ n;", "        long a = 2;\n        long b = 3;\n        long c = 4;\n      \
    \  long max = 2;\n        while (true) {\n            if (n % a == 0) {\n    \
    \            n = n / a;\n                if (n > max)\n                    max\
    \ = n;\n                a = b;\n                b += c;\n            } else if\
    \ (n % b == 0) {\n                n = n / b;\n                if (n > max)\n \
    \                   max = n;\n                b = c;\n                c += a;\n\
    \            } else if (n % c == 0) {\n                n = n / c;\n          \
    \      if (n > max)\n                    max = n;\n                c = a;\n  \
    \              a += b;\n            } else {\n                break;\n       \
    \     }\n        }\n        return max;", "        long largestPrimeFactor = 1;\n\
    \        while (n > 1) {\n            if (n % 2 == 0)\n                largestPrimeFactor\
    \ *= 2;\n            if (n % 3 == 0)\n                largestPrimeFactor *= 3;\n\
    \            n /= 2;\n        }\n        return largestPrimeFactor;", "      \
    \  long result = 0;\n        while (n != 1) {\n            n /= 2;\n         \
    \   result = Math.max(result, n);\n        }\n        return result;", "     \
    \   // Set up a helper function that determines if n is a prime or composite.\n\
    \        // If n is prime, return 2. Otherwise, set up for a recursive call.\n\
    \        Function<Long, Boolean> isPrime = i -> {\n            if (n % i == 0)\
    \ {\n                return false;\n            } else {\n                for\
    \ (long j = i * 2; j < n; j += i) {\n                    if (n % j == 0) {\n \
    \                       return false;\n                    }\n               \
    \ }\n                return true;\n            }\n        };\n\n        // Recursively\
    \ determine largest prime factor of n.\n        long largestPrimeFactor = (n <\
    \ 2) ? n : largestPrimeFactor(n / 2);\n        while (largestPrimeFactor != 1\
    \ && isPrime.apply(largestPrimeFactor)) {\n            largestPrimeFactor = largestPrimeFactor\
    \ * 2;\n        }\n        return largestPrimeFactor;", "        long maxFactor\
    \ = 1l;\n        for (long d = 2; d <= n; d++) {\n            if (n % d == 0)\
    \ {\n                long root = Math.sqrt(n);\n                while (n % d ==\
    \ 0) {\n                    maxFactor = d;\n                    n /= d;\n    \
    \            }\n                maxFactor = root;\n            }\n        }\n\
    \        return maxFactor;", "        Set<Long> factors = new HashSet<>();\n \
    \       long p = 2;\n        while (p * p <= n) {\n            if (n % p == 0)\
    \ {\n                factors.add(p);\n                n /= p;\n            } else\
    \ {\n                p++;\n            }\n        }\n        if (n > 1) {\n  \
    \          factors.add(n);\n        }\n        return factors.isEmpty() ? 1l :\
    \ factors.stream().max(Long::compareTo).get();", "        long[] p = new long[(int)\
    \ Math.sqrt(n)];\n        Arrays.fill(p, 2);\n        int count = 1;\n       \
    \ while (p != null && !Arrays.equals(p, Arrays.copyOf(p, p.length))) {\n     \
    \       if (n % p[0] < 1)\n                break;\n            while (n % p[0]\
    \ >= 1) {\n                p[0] = p[0] * 2;\n                count++;\n      \
    \      }\n            if (count == p.length - 1)\n                break;\n   \
    \         p[count] = n % p[0];\n            n = n / p[0];\n        }\n       \
    \ return n == 1 ? 1 : (long) p;", "        PrimeFactor[] primeFactors = PrimeFactor.findAllFactors(n);\n\
    \        long result = Long.MIN_VALUE;\n        for (PrimeFactor pf : primeFactors)\
    \ {\n            long pfVal = pf.value();\n            if (pfVal > result) {\n\
    \                result = pfVal;\n            }\n        }\n        return result;",
  "        Set<Long> primeFactors = new HashSet<>();\n        long p = 1;\n      \
    \  while (n % p == 0) {\n            primeFactors.add(p);\n            n /= p;\n\
    \        }\n        long maxFactor = Long.MIN_VALUE;\n        for (long factor\
    \ : primeFactors) {\n            if (n / factor > maxFactor) {\n             \
    \   maxFactor = n / factor;\n            }\n        }\n        return maxFactor;",
  "        // Use Java8's Stream.iterate(long, BiFunction<Long, Long, Long>)\n   \
    \     long maxFactor = 0;\n        for (long x = 2; x * x <= n; x++) {\n     \
    \       boolean isPrime = true;\n            for (long dividend = x; dividend\
    \ % x == 0; dividend /= x) {\n                isPrime = false;\n            }\n\
    \            if (isPrime) {\n                maxFactor = x;\n                break;\n\
    \            }\n        }\n        return maxFactor;", "        long result =\
    \ n;\n        PrimeChecker pc = new PrimeChecker();\n        for (long i = 2;\
    \ i < result; i++)\n            if (pc.isPrime(i))\n                while (result\
    \ % i == 0)\n                    result /= i;\n        return result;", "    \
    \    long p = 2;\n        while (p < n / p) {\n            if (n % p == 0)\n \
    \               p += 2;\n            else\n                p = p * 3 + 1;\n  \
    \      }\n        return n;", "        long factor = 2;\n        while (!isPrime(n))\
    \ {\n            factor++;\n            n = n / factor;\n        }\n        return\
    \ factor;", "        long maxPrime = 2;\n        while (n > 1) {\n           \
    \ if (n % maxPrime == 0) {\n                n /= maxPrime;\n            } else\
    \ {\n                maxPrime += 1;\n            }\n        }\n        return\
    \ maxPrime;", "        long[] factors = { 2, 3, 5, 7, 11, 13, 17, 19 };\n    \
    \    long large = n;\n        long largest = Long.MAX_VALUE;\n        for (long\
    \ factor : factors) {\n            while (large % factor == 0) {\n           \
    \     large /= factor;\n                if (largest < factor) {\n            \
    \        largest = factor;\n                }\n            }\n        }\n    \
    \    return largest;", "        long maxFactor = n;\n        long maxFactorNumber\
    \ = n;\n        while (true) {\n            while (n % 2 == 0) {\n           \
    \     maxFactor = n / 2;\n                if (maxFactorNumber > maxFactor) maxFactorNumber\
    \ = maxFactor;\n                n = maxFactor;\n            }\n            while\
    \ (n % 3 == 0) {\n                maxFactor = n / 3;\n                if (maxFactorNumber\
    \ > maxFactor) maxFactorNumber = maxFactor;\n                n = maxFactor;\n\
    \            }\n            while (n % 5 == 0) {\n                maxFactor =\
    \ n / 5;\n                if (maxFactorNumber > maxFactor) maxFactorNumber = maxFactor;\n\
    \                n = maxFactor;\n            }\n            if (n % n == 0) break;\n\
    \            n = n / n;\n        }\n        return maxFactor;", "        // The\
    \ prime factors of n are all the odd numbers that are less than n.\n        //\
    \ So any even number greater than 1 is a prime factor of n.\n        List<Long>\
    \ factors = new ArrayList<>();\n\n        for (int i = 2; i <= n / i; i += 2)\n\
    \            if (n % i == 0)\n                factors.add(i);\n\n        if (factors.size()\
    \ == 0)\n            throw new IllegalArgumentException(\"n must be a prime integer\"\
    );\n\n        Collections.sort(factors);\n\n        return factors.get(factors.size()\
    \ - 1);", "        // write your code here\n        long largestPrimeFactor =\
    \ n;\n        for(long i = 2; i <= Math.sqrt(n); i++){\n            if(n%i ==\
    \ 0){\n                largestPrimeFactor = i;\n                break;\n     \
    \       }\n        }\n        return largestPrimeFactor;", "        long a = 1,\
    \ b = 2;\n        long c;\n        while (a < n) {\n            if (n % a == 0)\
    \ {\n                long r = n / a;\n                if (r * r == a) {\n    \
    \                if (r < b) a = r + 1;\n                    c = b;\n         \
    \       }\n                else {\n                    if (c < r) a = r + 1;\n\
    \                    c = b;\n                }\n            }\n            else\
    \ {\n                if (c < b) a = a + 1;\n                c = b;\n         \
    \   }\n        }\n        if (c < n) {\n            long r = n / c;\n        \
    \    if (r * r == c) return c;\n            else return r;\n        }\n      \
    \  return n;", "        long largestFactor = 0;\n        long factor = 2;\n\n\
    \        while (n > 1) {\n            while (n % factor == 0) {\n            \
    \    largestFactor = factor;\n                n /= factor;\n            }\n\n\
    \            factor++;\n        }\n\n        return largestFactor;", "       \
    \ // Start with 2 and double until we find a prime number.\n        long next\
    \ = 2;\n        while (isPrime(n)) {\n            next *= 2;\n        }\n    \
    \    // Now start at 2 again, and double until we find the largest.\n        next\
    \ = 2 * next;\n        while (next < n) {\n            if (isPrime(next)) {\n\
    \                next = next * 2;\n            } else {\n                return\
    \ next;\n            }\n        }\n        // If we get this far then we didn't\
    \ find the largest prime factor.\n        throw new RuntimeException(\"No largest\
    \ prime factor\");", "        long factor = 1;\n        while (n > 1) {\n    \
    \        while (n % factor == 0) {\n                n /= factor;\n           \
    \     factor++;\n            }\n        }\n        return factor;", "        long\
    \ biggestPrimeFactor = 1;\n        long currentPrime = 2;\n        while ((n %\
    \ currentPrime) == 0) {\n            biggestPrimeFactor = currentPrime;\n    \
    \        currentPrime *= 2;\n        }\n        return biggestPrimeFactor;", " \
    \       long p = 2;\n        while (n % p != 0) {\n            ++p;\n        }\n\
    \        while (p * p <= n) {\n            if (n % p == 0) {\n               \
    \ return p;\n            }\n            ++p;\n        }\n        return n;", " \
    \       final int max = 1000;\n        if (n == 1) return 1;\n        \n     \
    \   List<Long> factors = new ArrayList<>();\n        \n        do {\n        \
    \    for (int i = 2; i <= Math.sqrt(n); i++) {\n                if (n % i == 0)\
    \ {\n                    factors.add(i);\n                    if (i * i > n) break;\n\
    \                }\n            }\n            \n            if (factors.size()\
    \ > max) {\n                factors.remove(0);\n            }\n            \n\
    \        } while (factors.size() > max);\n        \n        return factors.get(factors.size()\
    \ - 1);", "        long max = n;\n        while (n % 2 == 0) {\n            max\
    \ = n / 2;\n            if (n % 3 == 0 || n % 5 == 0) return (max * 3L);\n   \
    \         while (n % 6 != 0) {\n                max = max / 6;\n             \
    \   n = n / 6;\n            }\n        }\n        if (n > 2L) return max;\n  \
    \      long nextmax = max;\n        do {\n            if (n % 2 == 0) return nextmax;\n\
    \            n = n / 2;\n            nextmax = nextmax * 2;\n        } while (n\
    \ < 2L);\n        return nextmax;", "        \n        long[] primes = new long[]{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97};\n        long[] factors = new long[n - 1];\n        \n    \
    \    for (int i = 0; i < factors.length; ++i) {\n            if (n % primes[i]\
    \ == 0) {\n                factors[i] = primes[i];\n            }\n        }\n\
    \        \n        return Math.max(factors[factors.length - 1], n);", "      \
    \  long largestPrimeFactor = 1;\n        for (long factor = 2; factor * factor\
    \ <= n; factor++)\n            if (n % factor == 0) {\n                largestPrimeFactor\
    \ = factor;\n                break;\n            }\n        return largestPrimeFactor;",
  "        long largestPrimeFactor = 1;\n        for (long i = 2; i <= n / 2; i++)\
    \ {\n            if (n % i == 0) {\n                largestPrimeFactor = i;\n\
    \                break;\n            }\n        }\n        return largestPrimeFactor;",
  "        List<Long> factors = factorize(n);\n        return factors.stream().mapToLong(Long::longValue).max().getAsLong();",
  "        long a = 1;\n        while (a * a <= n) {\n            if (n % a == 0)\
    \ {\n                break;\n            }\n            a = a + 1;\n        }\n\
    \        long b = 2;\n        while (2 * b <= n) {\n            if (n % b == 0)\
    \ {\n                break;\n            }\n            b = b + 2;\n        }\n\
    \        if (b > n) {\n            return n;\n        }\n        if (a * b > n)\
    \ {\n            return b;\n        }\n        return a;", "        if (n == 1)\
    \ {\n            return 1;\n        }\n\n        Set<Long> factors = new HashSet<>();\n\
    \        for (long i = 2; i <= n / 2; i++) {\n            if (n % i == 0) {\n\
    \                factors.add(i);\n            }\n        }\n\n        if (factors.isEmpty())\
    \ {\n            return n;\n        }\n\n        long largest = factors.stream().max().getAsLong();\n\
    \        if (largest % 2 == 0) {\n            return largest + 1;\n        }\n\
    \n        long lastPrimeFactor = factors.stream().skip(factors.size() - 1).findFirst().getAsLong();\n\
    \n        return largestPrimeFactor(lastPrimeFactor);", "        ArrayList<Long>\
    \ factors = new ArrayList<Long>();\n        long factor = 2;\n\n        while\
    \ (n != 1) {\n            while (n % factor == 0) {\n                factors.add(factor);\n\
    \                n /= factor;\n            }\n            factor++;\n        }\n\
    \        return factors.get(factors.size() - 1);", '        return largestPrimeFactor0(n);',
  "        long p = 2;\n        while (p <= n/p) {\n            if (n % p == 0) {\n\
    \                break;\n            }\n            p++;\n        }\n        return\
    \ n;", "        // 1. Set a boolean value to indicate whether or not n is prime\
    \ or not.\n        boolean isPrime = true;\n\n        // 2. Set an int variable\
    \ to indicate the smallest prime factor of n.\n        int smallestFactor = 2;\n\
    \n        // 3. Set a long variable to indicate the largest prime factor of n.\n\
    \        long largestFactor = n;\n\n        // 4. Set a long variable to hold\
    \ the largest prime factor.\n        long largestPrimeFactor = largestFactor;\n\
    \n        // 5. Set a long variable to hold the largest prime factor of n.\n \
    \       while (largestPrimeFactor < largestFactor) {\n\n            // 6. Set\
    \ a boolean value to indicate whether or not n is divisible by the\n         \
    \   // smallest prime factor.\n            boolean isDivisibleBySmallestFactor\
    \ = true;\n\n            // 7. Set a boolean value to indicate whether or not\
    \ n is divisible by the\n            // largest prime factor.\n            boolean\
    \ isDivisibleByLargestFactor = true;\n\n            // 8. Set a boolean value\
    \ to indicate whether or not n is divisible by the\n            // smallest prime\
    \ factor of the largest prime factor.\n            boolean isDivisibleByLargestPrimeFactor\
    \ = true;\n\n            // 9. Set the smallest prime factor to 2.\n         \
    \   smallestFactor = 2;\n\n            // 10. Set the largest prime factor to\
    \ n.\n            largestFactor = n;\n\n            // 11. Set a long variable\
    \ to hold the largest prime factor.\n            largestPrimeFactor = largestFactor;\n\
    \n            // 12. While the smallest prime factor is not divisible by n\n \
    \           // and n is not a prime, set smallest prime factor to smallest prime\
    \ factor\n            // plus 1.\n            while (isDivisibleBySmallestFactor\
    \ != true && isPrime == false) {\n                smallestFactor++;\n        \
    \        isDivisibleBySmallestFactor = isDivisibleBySmallestFactor(\n        \
    \            n, smallestFactor);\n            }\n\n            // 13. While the\
    \ largest prime factor is not divisible by n\n            // and n is not a prime,\
    \ set largest prime factor to largest prime factor minus 1.\n            while\
    \ (isDivisibleByLargestFactor != true && isPrime == false) {\n               \
    \ largestFactor--;\n                isDivisibleByLargestFactor = isDivisibleByLargestFactor(\n\
    \                    n, largestFactor);\n            }\n\n            // 14. While\
    \ the largest prime factor is not divisible by n\n            // and n is not\
    \ a prime, set largest prime factor to largest prime factor plus 1.\n        \
    \    while (isDivisibleByLargestPrimeFactor != true ", "        long maxPf = 0;\n\
    \        int maxN = 1;\n        long currPf = n;\n        while(!isPrime(currPf))\
    \ {\n            maxPf = max(maxPf, currPf);\n            currPf = currPf * maxN;\n\
    \            maxN++;\n        }\n        return maxPf;", "        long maxFactor\
    \ = n;\n        long factor = 2;\n        while (factor * factor <= maxFactor)\
    \ {\n            long tmpFactor = factor * factor;\n            while (tmpFactor\
    \ <= maxFactor) {\n                if (n % tmpFactor == 0) {\n               \
    \     break;\n                }\n                tmpFactor *= factor;\n      \
    \      }\n            factor = tmpFactor;\n        }\n        return factor;",
  '        return largestPrimeFactor(n, 1);', "        LongStream s = n.stream().filter(i\
    \ -> isPrime(i));\n        s.takeWhile(i -> i != 2l).findFirst().orElse(2l);",
  "        long maxFactor = 1;\n        long curFactor = n;\n        boolean flag\
    \ = false;\n\n        while (true) {\n            for (long i = 2; i <= (n / curFactor);\
    \ i++) {\n                if (n % i == 0) {\n                    flag = true;\n\
    \                    break;\n                }\n            }\n\n            if\
    \ (flag) {\n                curFactor *= maxFactor;\n                maxFactor++;\n\
    \            } else {\n                break;\n            }\n        }\n\n  \
    \      return maxFactor;", "        PrimeFactory pf = new PrimeFactory();\n  \
    \      List<Long> factors = pf.factorize(n);\n        long largestFactor = factors.stream().max(Comparator.naturalOrder()).orElse(Long.MAX_VALUE);\n\
    \        return factors.stream().filter(f -> f == largestFactor).count();", " \
    \       if (n <= 1) {\n            throw new IllegalArgumentException(\"n must\
    \ be > 1.\");\n        }\n        BigInteger bi = new BigInteger(Long.toString(n),\
    \ 2);\n        List<BigInteger> factors = bi.factors();\n        if (factors.isEmpty())\
    \ {\n            return n;\n        }\n        if (factors.size() == 1) {\n  \
    \          return factors.get(0);\n        }\n        List<BigInteger> factors2\
    \ = factors.stream()\n                .filter(f -> f.equals(bi.subtract(BigInteger.ONE)))\n\
    \                .collect(Collectors.toList());\n        if (factors2.isEmpty())\
    \ {\n            return factors.get(0);\n        }\n        if (factors2.size()\
    \ == 1) {\n            return factors2.get(0);\n        }\n        BigInteger\
    \ largestFactor = factors.get(0);\n        BigInteger largestFactor2 = factors2.get(0);\n\
    \        if (largestFactor.equals(largestFactor2)) {\n            return largestFactor;\n\
    \        }\n        List<BigInteger> factors3 = factors.stream()\n           \
    \     .filter(f -> !f.equals(largestFactor))\n                .collect(Collectors.toList());\n\
    \        BigInteger largestFactor3 = factors3.get(0);\n        if (largestFactor3.equals(largestFactor2))\
    \ {\n            return largestFactor3;\n        }\n        List<BigInteger> factors4\
    \ = factors2.stream()\n                .filter(f -> !f.equals(largestFactor2))\n\
    \                .collect(Collectors.toList());\n        BigInteger largestFactor4\
    \ = factors4.get(0);\n        if (largestFactor4.equals(largestFactor2)) {\n \
    \           return largestFactor4;\n        }\n        throw new RuntimeException(\"\
    Too many candidates found: \" + factors4.size());", "        // TODO: Implement\
    \ me!\n        long result = Long.MAX_VALUE;\n        long[] primes = new long[(int)\
    \ (n+1)/2]; // +1 because prime starts at 2 and not 1.\n        for (int i = 2;\
    \ i < n; i++) {\n            if (primes[i/2] == 0) // if it is not divisible by\
    \ any prime greater than 1\n            {\n                long j;\n         \
    \       for (j = 3; j <= (int) Math.sqrt(n); j += 2) {\n                    if\
    \ (n%j == 0) break;\n                }\n                if (j > i) {\n       \
    \             primes[i/2] = j;\n                }\n            }\n        }\n\
    \        Arrays.sort(primes);\n        result = primes[primes.length-1];\n   \
    \     if (n >= result) {\n            System.out.println(\"result \" + result);\n\
    \        }\n        return result;", '        return largestPrimeFactor(n, Long::max).get();',
  "        long max = 0;\n        for (long i = 2; i * i <= n; i++)\n        {\n \
    \           if (n % i == 0)\n            {\n                if (i > max)\n   \
    \                 max = i;\n            }\n        }\n        return max;", " \
    \       if (n <= 2) {\n            return 1;\n        }\n        long max = n\
    \ / 2;\n        while (n % 2 == 0) {\n            max = max / 2;\n           \
    \ n = n / 2;\n        }\n        while (n % 3 == 0) {\n            max = max /\
    \ 3;\n            n = n / 3;\n        }\n        while (n % 5 == 0) {\n      \
    \      max = max / 5;\n            n = n / 5;\n        }\n        while (n % 7\
    \ == 0) {\n            max = max / 7;\n            n = n / 7;\n        }\n   \
    \     while (n % 11 == 0) {\n            max = max / 11;\n            n = n /\
    \ 11;\n        }\n        while (n % 13 == 0) {\n            max = max / 13;\n\
    \            n = n / 13;\n        }\n        while (n % 17 == 0) {\n         \
    \   max = max / 17;\n            n = n / 17;\n        }\n        return max;",
  "        if(n <= 1) return 1;\n        long primes[] = new long[(int) Math.sqrt(n)\
    \ + 1];\n        Arrays.fill(primes, 1);\n        long max = Long.MIN_VALUE;\n\
    \        long m = 2;\n        for(long i = 2; i <= n; i++) {\n            if(primes[i]\
    \ <= n) {\n                m = i;\n                if(primes[i] == n) return m;\n\
    \            }\n            while(primes[i] < n) {\n                primes[i*m]\
    \ = primes[i];\n                primes[i] += m;\n                ++i;\n      \
    \      }\n            if(primes[i] == n) max = Math.min(max, primes[i]);\n   \
    \     }\n        return max;", "        List<Long> factors = new ArrayList<>();\
    \ \n        long largestPrimeFactor = 2l;\n\n        while (true) {\n        \
    \    if (n % factors.contains(largestPrimeFactor))\n                factors.remove(largestPrimeFactor);\n\
    \            else\n                factors.add(largestPrimeFactor);\n        \
    \    if (factors.isEmpty())\n                break;\n\n            if (factors.size()\
    \ > largestPrimeFactor)\n                largestPrimeFactor = factors.get(0);\n\
    \        }\n\n        return largestPrimeFactor;", '        return LongStream.range(1,
    n).filter(i -> ((n % (i + 1l) == 0l) && (i != 0l))).max().getAsLong();', "   \
    \     if (n <= 1) return n;\n        Set<Long> factors = factorsOfN(n);\n    \
    \    return factors.isEmpty() ? n : factors.last();", "        long maxFactor\
    \ = 1;\n        for(long factor = 2; factor <= n / 2; ++factor) {\n          \
    \  if(n % factor == 0) {\n                if(maxFactor < factor) {\n         \
    \           maxFactor = factor;\n                }\n                --factor;\n\
    \            }\n        }\n        return maxFactor;", "        if (n <= 1)\n\
    \            return 1;\n        for (long f = 1; f <= n / 2; f++) {\n        \
    \    if (n % f == 0)\n                return f;\n        }\n        return n;",
  "        List<Long> factors = new ArrayList<>();\n        while (n > 1) {\n    \
    \        factors.add(2l);\n            n = n / 2;\n        }\n        while (n\
    \ % 2 == 0) {\n            factors.add(2l);\n            n = n / 2;\n        }\n\
    \        long max = 2l;\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n\
    \            while (n % i == 0) {\n                factors.add(i);\n         \
    \       n = n / i;\n            }\n        }\n        return factors.stream().max(Comparator.comparingLong(Long::longValue)).orElse(-1l);",
  "        if (n < 2) {\n            return n;\n        }\n\n        ArrayList<Long>\
    \ primes = Arrays.stream(new long[] {2,3,5,7})\n                .map(l-> l.longValue())\
    \ // primes: 2, 3, 5, 7\n                .filter(p-> !isPrime(p)) // primes except\
    \ 5 and 7\n                .mapToLong(p -> p) // primes: 2, 3, 5, 7\n        \
    \        .boxed() // long: Long: [2, 3, 5, 7]\n                .collect(Collectors.toList());\
    \ // List<Long>: [2, 3, 5, 7]\n        Collections.sort(primes, (p1, p2) -> {\n\
    \            if(p1==p2) return 0;\n            return p1-p2; // Long: [2^2, 2^3,\
    \ 2^4, 2^5]\n        });\n\n        // find the largest\n        Long largest\
    \ = primes.get(primes.size()-1);\n\n        for (long i = 3; i < largest; i +=\
    \ 2) {\n            if(isPrime(i)) {\n                largest = i;\n         \
    \       break;\n            }\n        }\n\n        return largest;", "      \
    \  long largestPrimeFactor = 1;\n        for (long i = 2; i <= n / 2; i++) {\n\
    \            if (n % i == 0) {\n                long tmp = largestPrimeFactor;\n\
    \                largestPrimeFactor = i;\n                if (tmp > n) break;\n\
    \            }\n        }\n        return largestPrimeFactor;", "        if (n\
    \ == 1l)\n            return (1l);\n        long p = n;\n        while (p % 2l\
    \ != 0l)\n            p = p / 2l;\n        long r = 1l;\n        while (p != 1l)\
    \ {\n            if (p % 2l == 0l)\n                return (p);\n            if\
    \ (p * p > n) break;\n            p = p / 2l;\n        }\n        return (r);",
  "        long factor = 1;\n        while (n != 1) {\n            long newN = n /\
    \ factor;\n            factor++;\n            n = newN;\n        }\n        return\
    \ factor;", "        long d = 1;\n        while (n % d == 0) {\n            n\
    \ /= d;\n            d++;\n        }\n        return n;", "        long largest_factor\
    \ = 1;\n        long max_factor = 1;\n\n        for (int i = 2; i <= n / 2; i++)\
    \ {\n            if (n % i == 0) {\n                largest_factor = i;\n    \
    \        }\n\n            if (largest_factor > max_factor) {\n               \
    \ max_factor = largest_factor;\n            }\n        }\n\n        return max_factor;",
  "        long p = 1;\n        for (int i = 1; i <= n; i++) {\n            if (n\
    \ % i == 0) {\n                p = i * p;\n                n = n / i;\n      \
    \      }\n        }\n        return p;", "        long maxFactor = 1;\n      \
    \  while (true) {\n            if (n % maxFactor == 0)\n                return\
    \ maxFactor;\n            if (maxFactor > n)\n                break;\n       \
    \     maxFactor = maxFactor * maxFactor;\n        }\n        return n;", "   \
    \     // Implement this function.\n        long max = (long) Math.sqrt(n);\n \
    \       for (long i = 2; i <= max; i++) {\n            if (n % i == 0) {\n   \
    \             return n;\n            }\n        }\n        return n;", "     \
    \   if (n < 1) return Long.MIN_VALUE;\n        long maxpf = Long.MIN_VALUE;\n\
    \        for (long i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i ==\
    \ 0) {\n                for (long x = Math.sqrt(n); x < i; x++) {\n          \
    \          if (n % x == 0) {\n                        maxpf = Math.max(maxpf,\
    \ x);\n                    }\n                }\n            }\n        }\n  \
    \      return maxpf;", "        long largest = 1;\n        for (long i = 2; i\
    \ < Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                long\
    \ temp;\n                for (temp = largest; temp < i; temp++) {\n          \
    \          if (temp * temp == i) {\n                        break;\n         \
    \           }\n                }\n                if (temp * temp < i) {\n   \
    \                 largest = i;\n                }\n            }\n        }\n\
    \        return largest;", "        if (n < 2) throw new IllegalArgumentException(\"\
    Invalid Input: n must be > 1\");\n        long largestPrimeFactor = 1;\n     \
    \   // Iterative to find largest prime\n        // Prime factorization takes much\
    \ longer than the prime-checking solution\n        // See http://mathworld.wolfram.com/LiesInPrimeNumber.html\n\
    \        while (n % 2 == 0) {\n            largestPrimeFactor *= 2;\n        \
    \    n /= 2;\n        }\n        for (int i = 3; i * i <= n; i += 2) {\n     \
    \       if (n % i == 0) {\n                largestPrimeFactor = i;\n         \
    \       n /= i;\n            }\n        }\n        if (n > 1) {\n            largestPrimeFactor\
    \ = n;\n        }\n        return largestPrimeFactor;", "        // Factor the\
    \ number n! using Sieve of Eratosthenes.\n        ArrayList<Long> primes = sieveOfEratosthenes(n);\n\
    \        // The largest prime factor of the number n! is n\n        return primes.get(primes.size()\
    \ - 1);", "        long max = (long) Math.sqrt(n);\n        boolean prime = true;\n\
    \        long p = 1;\n        long factor = 2;\n        for (long i = 3; i <=\
    \ max; i += 2) {\n            if (n % i == 0) {\n                prime = false;\n\
    \                break;\n            }\n        }\n        if (prime) {\n    \
    \        return n;\n        }\n        do {\n            ++p;\n        } while\
    \ (p <= n && n % p == 0);\n        factor = p;\n        do {\n            ++factor;\n\
    \        } while (factor <= n && n % factor == 0);\n        return factor;", " \
    \       long p = 1;\n        while (n/p > 1) {\n            if (n % p == 0) return\
    \ p;\n            ++p;\n        }\n        return n;", "        long factor =\
    \ 1;\n        long p = 1;\n\n        while(p <= n / p) {\n            if(n%p ==\
    \ 0) factor++;\n            p++;\n        }\n\n        return factor;", "    \
    \    long max = Long.MIN_VALUE;\n        Set<Long> factors = new HashSet<>();\n\
    \        while (n != 1) {\n            factors.add(n);\n            long r = Math.round(n\
    \ * Math.sqrt(n));\n            while (n / r != 1) {\n                n /= r;\n\
    \                factors.add(r);\n            }\n            max = Math.max(max,\
    \ factors.stream().mapToLong(x -> Math.round(x)).max().getAsLong());\n       \
    \ }\n        return max;", "        long result = 1;\n        for (long i = 2;\
    \ i <= n; i++) {\n            while (n % i == 0) {\n                n /= i;\n\
    \                ++result;\n            }\n            if (n > 1) {\n        \
    \        break;\n            }\n        }\n        return result;", '        return
    largestPrimeFactorFactorial(n, 2l);', "        if (n == 1l) return n;\n      \
    \  Set<Long> factors = new HashSet<Long>();\n        long d = 2l;\n        while\
    \ (d * d <= n) if (n % d == 0l) factors.add((d++));\n        if (factors.isEmpty())\
    \ return n;\n        Set<Long> result = new HashSet<Long>();\n        for (long\
    \ f : factors) if (n % f == 0l) result.add(f);\n        if (result.isEmpty())\
    \ return n;\n        result.forEach(l -> {\n            if (n%l == 0l) result.add(f);\n\
    \        });\n        long g = 2l;\n        Set<Long> res = new HashSet<Long>();\n\
    \        for (long f : result) if (f*f <= n && n%f == 0l) res.add(g++);\n    \
    \    if (res.isEmpty()) return n;\n        int n = result.size();\n        while\
    \ (res.contains(n)) n--;\n        if (n < 2) return n;\n        if (n >= 3) return\
    \ Math.max(result.size(), n);\n        Set<Long> r = new HashSet<Long>(), w =\
    \ new HashSet<Long>();\n        int m = 2, ms = 3, i, j, t;\n        Long g =\
    \ 2l, gs = 3, gm = 2l;\n        for (i = 1; i < n; i++) {\n            while (g*g\
    \ <= n && n%g == 0l) r.add(g++);\n            if (r.size() == ms) break;\n   \
    \         if (r.size() == m) r.add(g);\n            while (g*g < n && n%g == 0l)\
    \ w.add(g++);\n            if (w.size() == ms) break;\n            if (w.size()\
    \ == m) w.add(g);\n            if (gs == 3) {\n                gs = 2;\n     \
    \           g = gm;\n            }\n            else {\n                gm = g;\n\
    \                gs = 3;\n            }\n        }\n        if (gs == 2) return\
    \ gm;\n        g = gs;\n        long t = Math.max(r.size(), w.size());\n     \
    \   for (i = 0; i < t; i++) {\n            for (j = 0; j < m; j++) if (r.get(i)\
    \ == w.get(j)) break;\n            if (j == m) {\n                for (j = 0;\
    \ j < m; j++) if (r.get(i) != w.get(j)) break;\n            }\n            if\
    \ (j == m) return g;\n        }\n        return n;", "        long largestPrimeFactor\
    \ = 1;\n        long i = 2;\n        while (i < n) {\n            long factorOfN\
    \ = n % i;\n            if (factorOfN > 0 && i != factorOfN) {\n             \
    \   largestPrimeFactor = i;\n                break;\n            }\n         \
    \   i += 2;\n        }\n        return largestPrimeFactor;", "        long largestPrimeFactor\
    \ = n;\n        long largestPrimeFactorTwo = n;\n        long largestPrimeFactorThree\
    \ = n;\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n\
    \                largestPrimeFactorTwo = i;\n            }\n            if (n\
    \ % i == 0) {\n                largestPrimeFactorThree = i;\n            }\n \
    \       }\n        largestPrimeFactor = largestPrimeFactorTwo * largestPrimeFactorThree;\n\
    \        return largestPrimeFactor;", "        // Write your solution in Java\n\
    \        return largestPrimeFactor1(n);", "        long pFactor = 1;\n       \
    \ long m = n;\n        long a = 1;\n        long m2 = 1;\n        long p = 2;\n\
    \        while (m >= p) {\n            m2 = m;\n            while (m % p == 0)\
    \ {\n                m2 /= p;\n            }\n            if (a == pFactor) {\n\
    \                pFactor = p;\n            } else if (m2 < pFactor) {\n      \
    \          pFactor = m2;\n            }\n            m = m2;\n            p++;\n\
    \        }\n        return pFactor;", "        boolean isPrime;\n        long\
    \ largest = Long.MIN_VALUE;\n        long largestPrimeFactor = Long.MIN_VALUE;\n\
    \        long i = 2;\n        while (i <= n/i) {\n            isPrime = true;\n\
    \            long j = 2;\n            while (j * j <= n/i && i*i <= n/j) {\n \
    \               if (n/j % i == 0) {\n                    isPrime = false;\n  \
    \                  break;\n                }\n                j++;\n         \
    \   }\n            if (isPrime) {\n                if (largest < n/i) {\n    \
    \                largest = n/i;\n                    largestPrimeFactor = i;\n\
    \                }\n                if (largest < n/i) {\n                   \
    \ largest = n/i;\n                    largestPrimeFactor = i;\n              \
    \  }\n            }\n            i++;\n        }\n        return largestPrimeFactor;",
  "        long factor = 2;\n        while (factor * factor <= n) {\n            if\
    \ (n % factor == 0) {\n                n /= factor;\n                break;\n\
    \            }\n            else {\n                factor++;\n            }\n\
    \        }\n        return factor;", "        long[] factors = new long[n+1];\n\
    \        factors[0] = n;\n        Arrays.fill(factors, 1);\n        long largestPrime\
    \ = 1;\n        for(long i = 2; i < factors.length; i++){\n            if(factors[i]\
    \ == 1)\n                continue;\n            long candidate = factors[i];\n\
    \            for(long j = i; j < factors.length; j++){\n                if(factors[j]\
    \ == 1)\n                    continue;\n                if(candidate % factors[j]\
    \ == 0){\n                    candidate = (candidate/factors[j]);\n          \
    \          break;\n                }\n            }\n            if(candidate\
    \ > largestPrime){\n                largestPrime = candidate;\n            }\n\
    \        }\n        return largestPrime;", "        long factor = 2;\n       \
    \ while (factor * factor < n) {\n            if (n % factor == 0) {\n        \
    \        n /= factor;\n                factor++;\n            } else {\n     \
    \           factor++;\n            }\n        }\n        return n;", "       \
    \ long f = 1;\n        while (n%2 == 0) {\n            n = n/2;\n            f\
    \ = f*2;\n        }\n        while (n > 1) {\n            while (n % 2 == 0) {\n\
    \                n = n/2;\n            }\n            if (n%2 == 0) {\n      \
    \          f = f*2;\n                n = n/2;\n            }\n            else\
    \ {\n                n = n*3;\n            }\n        }\n        return f;"]
stop_tokens:
- "\n    }\n"
