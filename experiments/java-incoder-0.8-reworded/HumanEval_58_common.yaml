name: HumanEval_58_common
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return sorted unique common elements for two array lists.\n\
  \    // >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l,\
  \ (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l,\
  \ (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))\n    // (new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))\n    // >>> common((new\
  \ ArrayList<Long>(Arrays.asList((long)5l, (long)3l, (long)2l, (long)8l))), (new\
  \ ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))\n    // (new ArrayList<Long>(Arrays.asList((long)2l,\
  \ (long)3l)))\n    public static ArrayList<Long> common(ArrayList<Long> l1, ArrayList<Long>\
  \ l2) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(common((new\
  \ ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l,\
  \ (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l,\
  \ (long)1l, (long)5l, (long)9l, (long)653l, (long)121l)))).equals((new ArrayList<Long>(Arrays.asList((long)1l,\
  \ (long)5l, (long)653l)))));\n    assert(common((new ArrayList<Long>(Arrays.asList((long)5l,\
  \ (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l,\
  \ (long)2l)))).equals((new ArrayList<Long>(Arrays.asList((long)2l, (long)3l)))));\n\
  \    assert(common((new ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l,\
  \ (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l, (long)4l)))).equals((new\
  \ ArrayList<Long>(Arrays.asList((long)2l, (long)3l, (long)4l)))));\n    assert(common((new\
  \ ArrayList<Long>(Arrays.asList((long)4l, (long)3l, (long)2l, (long)8l))), (new\
  \ ArrayList<Long>(Arrays.asList()))).equals((new ArrayList<Long>(Arrays.asList()))));\n\
  \    }\n\n}\n"
completions: ["        if (l1 == null || l2 == null) return l1;\n        ArrayList<Long>\
    \ result = new ArrayList<>();\n        // We can't use hashset because we want\
    \ to preserve duplicates\n        for (long elem : l1)\n            if (l2.contains(elem))\n\
    \                result.add(elem);\n        return result;", "        HashMap<Long,\
    \ Long> common = new HashMap<Long, Long>();\n        for (Long i : l1) {\n   \
    \         Long c = l2.stream().filter(e -> e.equals(i)).findFirst().orElse(null);\n\
    \            if (c != null)\n                common.put(i, c);\n        }\n  \
    \      ArrayList<Long> ret = new ArrayList<Long>(common.keySet());\n        Collections.sort(ret);\n\
    \        return ret;", "        // Create three empty lists to hold sorted unique\
    \ elements.\n        ArrayList<Long> u1 = new ArrayList<>();\n        ArrayList<Long>\
    \ u2 = new ArrayList<>();\n        ArrayList<Long> u3 = new ArrayList<>();\n\n\
    \        // Create three lists to hold sorted unique elements.\n        List<Long>\
    \ u1_ = new ArrayList<>();\n        List<Long> u2_ = new ArrayList<>();\n    \
    \    List<Long> u3_ = new ArrayList<>();\n\n        // Add all elements from both\
    \ lists.\n        u1_.addAll(l1);\n        u2_.addAll(l2);\n        u3_.addAll(l1);\n\
    \n        // Sort lists.\n        u1_.sort(Long::compare);\n        u2_.sort(Long::compare);\n\
    \        u3_.sort(Long::compare);\n\n        // Add unique elements from both\
    \ lists.\n        u1.addAll(u1_);\n        u2.addAll(u2_);\n        u3.addAll(u3_);\n\
    \n        // Remove duplicate elements.\n        u1.retainAll(u2);\n        u1.retainAll(u3);\n\
    \n        // Create empty list to hold sorted unique elements.\n        List<Long>\
    \ u1_ret = new ArrayList<>();\n\n        // Add unique elements from first list.\n\
    \        u1_ret.addAll(u1);\n\n        // Add unique elements from second list.\n\
    \        u1_ret.addAll(u2);\n\n        // Return sorted unique elements.\n   \
    \     u1_ret.sort(Long::compare);\n        return u1_ret;", "        ArrayList<Long>\
    \ result = new ArrayList<>();\n\n        if (l1 == null || l2 == null || l1.size()\
    \ == 0 || l2.size() == 0) {\n            return result;\n        }\n\n       \
    \ // Find unique values.\n        HashSet<Long> set1 = new HashSet<>(l1);\n  \
    \      HashSet<Long> set2 = new HashSet<>(l2);\n\n        // Create combined sets.\n\
    \        set1.retainAll(set2);\n        set2.retainAll(set1);\n\n        // If\
    \ there are no common elements, just return l1.\n        if (!set1.isEmpty())\
    \ {\n            result.addAll(l1);\n            return result;\n        }\n\n\
    \        // If there are no common elements, just return l2.\n        if (!set2.isEmpty())\
    \ {\n            result.addAll(l2);\n            return result;\n        }\n\n\
    \        // If we have common elements, find smallest from both lists.\n     \
    \   Set<Long> common = new HashSet<>();\n        for (Long val : set1) {\n   \
    \         if (set2.contains(val)) {\n                common.add(val);\n      \
    \      }\n        }\n        for (Long val : set2) {\n            if (set1.contains(val))\
    \ {\n                common.add(val);\n            }\n        }\n\n        //\
    \ Add smallest common elements from both lists.\n        for (Long val : common)\
    \ {\n            result.add(val);\n        }\n        return result;", "     \
    \   Set<Long> commonSet = new HashSet<Long>(l1);\n        l1.retainAll(l2);\n\
    \        l2.retainAll(l1);\n        l1.removeAll(l2);\n        l2.removeAll(l1);\n\
    \        l1.addAll(l2);\n        l2.addAll(l1);\n        l1.retainAll(commonSet);\n\
    \        l2.retainAll(commonSet);\n        l1.removeAll(commonSet);\n        l2.removeAll(commonSet);\n\
    \        l1.addAll(l2);\n        l2.addAll(l1);\n        return l1;", "      \
    \  if (l1 == null)\n            return l2;\n        if (l2 == null)\n        \
    \    return l1;\n        Set<Long> set1 = new HashSet<Long>(l1);\n        Set<Long>\
    \ set2 = new HashSet<Long>(l2);\n        set1.removeAll(l2);\n        set2.removeAll(l1);\n\
    \        if (set1.isEmpty() || set2.isEmpty())\n            return null;\n   \
    \     return new ArrayList<Long>(set1);", "        ArrayList<Long> l3 = new ArrayList<Long>();\n\
    \        HashSet<Long> set1 = new HashSet<Long>(l1);\n        HashSet<Long> set2\
    \ = new HashSet<Long>(l2);\n        Set<Long> common = new HashSet<Long>(set1);\n\
    \        set1.retainAll(set2);\n        set2.removeAll(common);\n        set1.removeAll(set2);\n\
    \        set2.removeAll(common);\n        set1.removeAll(set2);\n        Iterator<Long>\
    \ i = set1.iterator();\n        Iterator<Long> j = set2.iterator();\n        while\
    \ (i.hasNext()) {\n            if (!j.hasNext()) {\n                l3.add(i.next());\n\
    \            }\n            else if (j.next().equals(i.next())) {\n          \
    \      l3.add(i.next());\n            }\n            else {\n                l3.add(j.next());\n\
    \            }\n        }\n        return l3;", "        if (l1 == null || l2\
    \ == null) return null;\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (Long l : l1) result.add(l);\n        for (Long l : l2) if (!result.contains(l))\
    \ result.add(l);\n        return result;", "        Set<Long> set1 = new HashSet<>();\n\
    \        Set<Long> set2 = new HashSet<>();\n        set1.addAll(l1);\n       \
    \ set2.addAll(l2);\n        set1.removeAll(set2);\n        return set1;", "  \
    \      Set<Long> s1 = new HashSet<>();\n        Set<Long> s2 = new HashSet<>();\n\
    \        s1.addAll(l1);\n        s2.addAll(l2);\n        \n        ArrayList<Long>\
    \ res = new ArrayList<>(s1);\n        res.addAll(s2);\n        \n        return\
    \ res;", "        if (l1 == null || l2 == null)\n            return null;\n  \
    \      Set<Long> set = new HashSet<>();\n        set.addAll(l1);\n        set.addAll(l2);\n\
    \        ArrayList<Long> res = new ArrayList<>();\n        Iterator<Long> iterator\
    \ = set.iterator();\n        Long value;\n        Long min = null;\n        while\
    \ (iterator.hasNext()) {\n            value = iterator.next();\n            if\
    \ (min == null || value < min)\n                min = value;\n        }\n    \
    \    if (min == null)\n            return null;\n        Iterator<Long> iterator\
    \ = l1.iterator();\n        while (iterator.hasNext()) {\n            value =\
    \ iterator.next();\n            if (value == min)\n                res.add(min);\n\
    \        }\n        return res;", "        ArrayList<Long> ret = new ArrayList<>();\n\
    \        HashSet<Long> h1 = new HashSet<>(l1);\n        HashSet<Long> h2 = new\
    \ HashSet<>(l2);\n        for(Long value : h1) ret.add(value);\n        for(Long\
    \ value : h2) ret.add(value);\n        return ret;", "        Set<Long> set =\
    \ new HashSet<>(l1);\n        set.removeAll(l2);\n        return set.stream().sorted().collect(toList());",
  "        List<Long> l3 = new ArrayList<>(new HashSet<>(l1).stream().filter(v ->\
    \ !l2.contains(v)).collect(Collectors.toList()));\n        List<Long> l4 = new\
    \ ArrayList<>(new HashSet<>(l2).stream().filter(v -> !l1.contains(v)).collect(Collectors.toList()));\n\
    \        l3.retainAll(l4);\n        return l3;", '        return Collections.unmodifiableList(new
    TreeSet<Long>().addAll(l1).addAll(l2).stream().distinct().collect(Collectors.toList()));',
  "        HashSet<Long> common = new HashSet<Long>(l1);\n        l1.removeAll(common);\n\
    \        l2.removeAll(common);\n        for (Long element : l2) {\n          \
    \  if (common.add(element)) return new ArrayList<Long>(common);\n        }\n \
    \       return new ArrayList<Long>();", "        return Stream.of(l1, l2)\n  \
    \              .filter(Objects::nonNull)\n                .distinct()\n      \
    \          .filter(e -> !Objects.equals(e, Collections.emptyList()))\n       \
    \         .collect(Collectors.toCollection(ArrayList::new));", "        ArrayList<Long>\
    \ common = new ArrayList<Long>();\n        if (l1.size() <= l2.size()) {\n   \
    \         common.addAll(l1);\n            l1.removeAll(l2);\n            l2.removeAll(l1);\n\
    \        }\n        if (l1.size() > l2.size()) {\n            common.addAll(l2);\n\
    \            l2.removeAll(l1);\n            l1.removeAll(l2);\n        }\n   \
    \     Collections.sort(common);\n        return common;", "        ArrayList<Long>\
    \ common = new ArrayList<Long>();\n        for(Long v : l1) {\n            boolean\
    \ found = false;\n            for(Long xl : l2) {\n                if(xl.longValue()\
    \ == v.longValue()) {\n                    found = true;\n                   \
    \ break;\n                }\n            }\n            if(!found)\n         \
    \       common.add(v);\n        }\n        for(Long v : l2) {\n            boolean\
    \ found = false;\n            for(Long xl : l1) {\n                if(xl.longValue()\
    \ == v.longValue()) {\n                    found = true;\n                   \
    \ break;\n                }\n            }\n            if(!found)\n         \
    \       common.add(v);\n        }\n        Collections.sort(common);\n       \
    \ return common;", "        ArrayList<Long> result = new ArrayList<>();\n    \
    \    long size1 = l1.size();\n        long size2 = l2.size();\n        long minSize\
    \ = Math.min(size1, size2);\n\n        if (minSize == 0) {\n            return\
    \ result;\n        }\n\n        // Iterate over all elements in both lists and\
    \ remove any that were\n        // not unique.\n        for (long i = 0, j = 0;\
    \ i < minSize; i++, j++) {\n            long n1 = l1.get(i);\n            long\
    \ n2 = l2.get(j);\n            if (n1 != n2) {\n                result.add(n1);\n\
    \                j++;\n            }\n        }\n\n        if (size1 < size2)\
    \ {\n            result.addAll(Arrays.asList(l2).subList(minSize, l2.size()));\n\
    \        } else if (size2 < size1) {\n            result.addAll(Arrays.asList(l1).subList(minSize,\
    \ l1.size()));\n        }\n        return result;", "        final ArrayList result\
    \ = new ArrayList();\n        // Remove duplicates from both lists.\n        final\
    \ Set<Long> s = new HashSet<Long>();\n        for (final Long l : l1) {\n    \
    \        if (s.add(l)) {\n                result.add(l);\n            }\n    \
    \    }\n        for (final Long l : l2) {\n            if (s.add(l)) {\n     \
    \           result.add(l);\n            }\n        }\n        return result;",
  "        ArrayList<Long> list = new ArrayList<>();\n        l1.stream().filter(i\
    \ -> l2.contains(i)).forEach(list::add);\n        l1.stream().filter(i -> !l2.contains(i)).forEach(list::add);\n\
    \        return list.stream().distinct().sorted().collect(Collectors.toList());",
  "        long temp;\n        ArrayList<Long> list = new ArrayList<>(l1);\n     \
    \   for (long i : l2)\n            list.remove(i);\n        while (!list.isEmpty())\n\
    \            temp = list.remove(0);\n        return list;", '        return l1.stream().filter(x
    -> l2.contains(x)).sorted().collect(Collectors.toList());', "        l1.retainAll(l2);\n\
    \        return l1;", "        Set<Long> set1 = new HashSet<>();\n        Set<Long>\
    \ set2 = new HashSet<>();\n        set1.addAll(l1);\n        set2.addAll(l2);\n\
    \        ArrayList<Long> result = new ArrayList<>();\n        // Find intersection\
    \ of both sets.\n        for (Long val : set1) {\n            if (set2.contains(val))\
    \ {\n                result.add(val);\n            }\n        }\n        return\
    \ result;", "        Set<Long> s1 = new HashSet<Long>(l1);\n        Set<Long>\
    \ s2 = new HashSet<Long>(l2);\n\n        s1.retainAll(s2);\n\n        return (new\
    \ ArrayList<Long>(s1));", "        // Create a set for O(1) contains and contains.\n\
    \        Set<Long> set1 = new HashSet<>(l1);\n        Set<Long> set2 = new HashSet<>(l2);\n\
    \n        // Remove the common elements from the two sets.\n        set1.removeAll(l2);\n\
    \        set2.removeAll(l1);\n\n        // Return the set with common elements.\n\
    \        return set1.stream().filter(e -> set2.contains(e)).collect(Collectors.toCollection(ArrayList::new));",
  "        Set<Long> set = new HashSet<>();\n        for(long elem : l1) {\n     \
    \       if(set.contains(elem)) {\n                set.add(l2.get(l2.indexOf(elem)));\n\
    \            } else {\n                set.add(elem);\n            }\n       \
    \ }\n        return new ArrayList<>(set);", "        ArrayList<Long> common =\
    \ new ArrayList<>();\n        Set<Long> s1=new HashSet<>(l1);\n        Set<Long>\
    \ s2=new HashSet<>(l2);\n        s1.removeAll(s2); \n        common.addAll(s1);\n\
    \        return common;", "        long largest = Long.MIN_VALUE;\n        long\
    \ smallest = Long.MAX_VALUE;\n        long maxIndex = 0;\n        long minIndex\
    \ = 0;\n\n        // Find the greatest and smallest in both lists.\n        for\
    \ (Long item : l1) {\n            if (largest < item) {\n                largest\
    \ = item;\n                maxIndex = l1.indexOf(item);\n            }\n     \
    \   }\n        for (Long item : l2) {\n            if (smallest > item) {\n  \
    \              smallest = item;\n                minIndex = l2.indexOf(item);\n\
    \            }\n        }\n\n        // Find where the two largest and smallest\
    \ are in common between both lists.\n        for (Long item : l1) {\n        \
    \    if (l2.indexOf(item) == maxIndex) {\n                maxIndex = l1.indexOf(item);\n\
    \            }\n        }\n        for (Long item : l2) {\n            if (l1.indexOf(item)\
    \ == minIndex) {\n                minIndex = l2.indexOf(item);\n            }\n\
    \        }\n\n        // Return the unique set of common elements.\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (Long item : l1) {\n          \
    \  if (l2.indexOf(item) == maxIndex) {\n                result.add(item);\n  \
    \          }\n        }\n        for (Long item : l2) {\n            if (l1.indexOf(item)\
    \ == minIndex) {\n                result.add(item);\n            }\n        }\n\
    \        return result;", "        List<Long> ll1 = new ArrayList<>(l1);\n   \
    \     List<Long> ll2 = new ArrayList<>(l2);\n        List<Long> ll = new ArrayList<>();\n\
    \        for (Long val : ll1) {\n            if (ll2.contains(val)) {\n      \
    \          ll.add(val);\n                ll.remove(ll2.indexOf(val));\n      \
    \      }\n        }\n        return ll.stream().distinct().collect(Collectors.toCollection(ArrayList::new));",
  "        // Create a set to hold intersections. Use streams.\n        HashSet<Long>\
    \ intersections = new HashSet<>();\n        // Add items from l1 that are in l2\
    \ to the intersections set.\n        l2.stream().filter(l -> l1.contains(l)).forEach(intersections::add);\n\
    \        // Return sorted list.\n        return Collections.sort(intersections);",
  "        // Sort the lists.\n        ArrayList<Long> sortedL1 = new ArrayList<>((Collections.sort((l1.toArray(new\
    \ Long[l1.size()])))));\n        ArrayList<Long> sortedL2 = new ArrayList<>((Collections.sort((l2.toArray(new\
    \ Long[l2.size()])))));\n        // Create a Set to remove duplicate elements.\n\
    \        Set<Long> set = new HashSet<>(sortedL1);\n        set.addAll(sortedL2);\n\
    \        // Return sorted unique elements.\n        ArrayList<Long> result = new\
    \ ArrayList<>(set);\n        return result;", "        final int minLen = Math.min(l1.size(),\
    \ l2.size());\n        final ArrayList<Long> common = new ArrayList<Long>(minLen);\n\
    \        if (l1.size() < l2.size()) {\n            int i = l1.size();\n      \
    \      int j = l2.size();\n            while (i != 0 && j != 0) {\n          \
    \      if (l1.get(i) == l2.get(j)) {\n                    common.add((long)l1.get(i));\n\
    \                    i--;\n                    j--;\n                } else if\
    \ (l1.get(i) < l2.get(j)) {\n                    i++;\n                } else\
    \ {\n                    j--;\n                }\n            }\n        } else\
    \ {\n            int i = l2.size();\n            int j = l1.size();\n        \
    \    while (i != 0 && j != 0) {\n                if (l2.get(j) == l1.get(i)) {\n\
    \                    common.add((long)l2.get(j));\n                    i--;\n\
    \                    j--;\n                } else if (l2.get(j) < l1.get(i)) {\n\
    \                    j--;\n                } else {\n                    i++;\n\
    \                }\n            }\n        }\n        return common;", "     \
    \   if (l1.size() < 1 || l2.size() < 1) {\n            throw new IllegalArgumentException(\"\
    The lists must be not empty.\");\n        }\n        Set<Long> unique1 = new HashSet<>(l1);\n\
    \        Set<Long> unique2 = new HashSet<>(l2);\n        Set<Long> common = new\
    \ HashSet<>();\n        common.addAll(unique1);\n        common.addAll(unique2);\n\
    \        Set<Long> result = new HashSet<>();\n        for (Long element : common)\
    \ {\n            if (l1.contains(element) || l2.contains(element)) {\n       \
    \         result.add(element);\n            }\n        }\n        return new ArrayList<>(result);",
  "        ArrayList<Long> common = new ArrayList<>(l1.size());\n        for (int\
    \ i = 0; i < l1.size(); i++) {\n            for (int j = 0; j < l2.size(); j++)\
    \ {\n                if (l1.get(i).compareTo(l2.get(j)) < 0) {\n             \
    \       break;\n                }\n                if (i == l1.size() - 1 && j\
    \ == l2.size() - 1) {\n                    common.add(l1.get(i));\n          \
    \          break;\n                }\n                if (l1.get(i).compareTo(l2.get(j))\
    \ >= 0) {\n                    break;\n                }\n            }\n    \
    \    }\n        return common;", "        long sum = 0;\n        long max = l1.stream().mapToLong(x\
    \ -> (long) x).max().orElse(-1);\n        max = l2.stream().mapToLong(x -> (long)\
    \ x).max().orElse(-1);\n        for(long i = max; i >= 0; i--) sum += l1.get(i)\
    \ * l2.get(i);\n        ArrayList<Long> res = new ArrayList<>();\n        long\
    \ mult = 1;\n        for(int i = max - 1; i >= 0; i--) {\n            if(l1.get(i)\
    \ * l2.get(i) == sum) {\n                res.add((long) i);\n                mult\
    \ = l1.get(i) * l2.get(i);\n                break;\n            }\n        }\n\
    \        return res;", "        return l1.stream()\n                .filter(elem\
    \ -> l2.contains(elem))\n                .collect(Collectors.toList());", "  \
    \      ArrayList<Long> result = new ArrayList<>();\n        boolean same = true;\n\
    \        while (l1.size() > 0 && l2.size() > 0) {\n            if (l1.get(0) ==\
    \ l2.get(0)) {\n                l1.remove(0);\n                l2.remove(0);\n\
    \            }\n            else {\n                same = false;\n          \
    \      break;\n            }\n        }\n        if (l1.size() == 0 && l2.size()\
    \ == 0) {\n            return result;\n        }\n        if (l1.size() > 0) {\n\
    \            Collections.sort(l1);\n            for (long element : l1) {\n  \
    \              if (!result.contains(element)) {\n                    result.add(element);\n\
    \                }\n            }\n        }\n        if (l2.size() > 0) {\n \
    \           Collections.sort(l2);\n            for (long element : l2) {\n   \
    \             if (!result.contains(element)) {\n                    result.add(element);\n\
    \                }\n            }\n        }\n        return result;", "     \
    \   // Set up result array and two iterators. \n        ArrayList<Long> commonElements\
    \ = new ArrayList<>();\n\n        // Iterate over both lists.\n        Iterator<Long>\
    \ l1Iter = l1.iterator();\n        Iterator<Long> l2Iter = l2.iterator();\n  \
    \      while (l1Iter.hasNext() && l2Iter.hasNext()) {\n            // Get the\
    \ two numbers.\n            Long num1 = l1Iter.next();\n            Long num2\
    \ = l2Iter.next();\n\n            // Compare the numbers and add them to the result\
    \ list.\n            if (num1 > num2) commonElements.add(num1);\n            else\
    \ if (num1 < num2) commonElements.add(num2);\n            else commonElements.add(num1);\n\
    \        }\n\n        return commonElements;", "        // Use Set and SortedSet\
    \ to get unique elements.\n        Set<Long> s = new HashSet<Long>();\n      \
    \  SortedSet<Long> result = new TreeSet<Long>(s);\n        // Add all elements\
    \ to set.\n        l1.stream().map(Long::longValue).forEach(s::add);\n       \
    \ l2.stream().map(Long::longValue).forEach(s::add);\n        // Return sorted\
    \ unique elements.\n        return result.stream().collect(Collectors.toCollection(ArrayList::new));",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        if (l1.size()\
    \ > l2.size()) {\n            ArrayList<Long> result = new ArrayList<Long>(l2);\n\
    \            Collections.sort(result);\n            ArrayList<Long> l3 = new ArrayList<Long>(l1);\n\
    \            l3.removeAll(l2);\n            result.addAll(l3);\n        } else\
    \ {\n            ArrayList<Long> result = new ArrayList<Long>(l1);\n         \
    \   Collections.sort(result);\n            ArrayList<Long> l3 = new ArrayList<Long>(l2);\n\
    \            l3.removeAll(l1);\n            result.addAll(l3);\n        }\n  \
    \      Collections.sort(result);\n        return result;", "        return l1.stream()\n\
    \                .filter(i -> l2.contains(i))\n                .distinct()\n \
    \               .sorted()\n                .collect(Collectors.toList());", " \
    \       // Return sorted unique common elements for two array lists.\n       \
    \ ArrayList<Long> l3 = (ArrayList<Long>)new ArrayList(l1.size() + l2.size());\n\
    \        l3.addAll(l1);\n        l3.addAll(l2);\n        l3.setOrderComparator(Long::compareTo);\n\
    \        l3.sort(Long::compareTo);\n        return l3;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>(l1.size());\n        for (int i = 0; i < l1.size();\
    \ i++) {\n            boolean found = false;\n            for (int j = 0; j <\
    \ l2.size(); j++) {\n                if (l1.get(i) == l2.get(j)) {\n         \
    \           found = true;\n                    break;\n                }\n   \
    \         }\n            if (!found) {\n                result.add(l1.get(i));\n\
    \            }\n        }\n        return result;", "        ArrayList<Long> res\
    \ = new ArrayList<>();\n        for(int i = 0; i < l1.size(); i++) {\n       \
    \     if(l2.contains(l1.get(i))) {\n                res.add(l1.get(i));\n    \
    \        }\n        }\n        return res;", "        Set<Long> common = new HashSet<Long>();\n\
    \        common.addAll(l1);\n        common.removeAll(l2);\n        return new\
    \ ArrayList<Long>(common);", "        ArrayList<Long> common = new ArrayList<Long>(l1);\n\
    \        Set<Long> set1 = new HashSet<Long>(l1);\n        Set<Long> set2 = new\
    \ HashSet<Long>(l2);\n        set1.retainAll(set2);\n        System.out.println(set1);\n\
    \        System.out.println(set2);\n        common.retainAll(set1);\n        return\
    \ common;", "        final Set<Long> set1 = new HashSet<>(l1);\n        final\
    \ Set<Long> set2 = new HashSet<>(l2);\n        final List<Long> common = new ArrayList<>();\n\
    \        for (long e : l1) {\n            if (set1.remove(e)) {\n            \
    \    common.add(e);\n            }\n        }\n        for (long e : l2) {\n \
    \           if (set2.remove(e)) {\n                common.add(e);\n          \
    \  }\n        }\n        return common;", "        ArrayList<Long> res = new ArrayList<>();\n\
    \        if (l1.size() <= 1 || l2.size() <= 1) {\n            return res;\n  \
    \      }\n        // get min and max\n        long minL1 = l1.stream().min(Long::compareTo).get();\n\
    \        long maxL1 = l1.stream().max(Long::compareTo).get();\n        long minL2\
    \ = l2.stream().min(Long::compareTo).get();\n        long maxL2 = l2.stream().max(Long::compareTo).get();\n\
    \        // loop through min to max\n        for (long k = minL1; k <= maxL1;\
    \ k++) {\n            if (l2.contains(k)) {\n                res.add(k);\n   \
    \         }\n        }\n        return res;", "        ArrayList<Long> common\
    \ = new ArrayList<Long>();\n        Arrays.sort(l1);\n        Arrays.sort(l2);\n\
    \        Iterator it = l1.iterator();\n        Iterator it2 = l2.iterator();\n\
    \        while (it.hasNext()) {\n            long i = (Long) it.next();\n    \
    \        long j = (Long) it2.next();\n            if (i == j)\n              \
    \  common.add(j);\n        }\n        return common;", "        l1.sort(new Comparator<Long>()\
    \ {\n            public int compare(Long o1, Long o2) {\n                return\
    \ o1.compareTo(o2);\n            }\n        });\n        l2.sort(new Comparator<Long>()\
    \ {\n            public int compare(Long o1, Long o2) {\n                return\
    \ o1.compareTo(o2);\n            }\n        });\n        HashSet<Long> set = new\
    \ HashSet<>();\n        set.add(l1.get(0), l1.get(0));\n        set.add(l2.get(0),\
    \ l2.get(0));\n        ArrayList<Long> res = new ArrayList<>();\n        for (int\
    \ i = 1; i < l1.size(); i++) {\n            for (int j = 1; j < l2.size(); j++)\
    \ {\n                if (set.contains(l1.get(i), l2.get(j))) {\n             \
    \       res.add(l1.get(i));\n                    res.add(l2.get(j));\n       \
    \             set.remove(l1.get(i), l2.get(j));\n                    break;\n\
    \                }\n            }\n        }\n        return res;", "        ArrayList<Long>\
    \ result = new ArrayList<>();\n        if (l1.size() != l2.size()) {\n       \
    \     return result;\n        }\n        Set<Long> intersection = new HashSet<>(l1);\n\
    \        for (long x : l2) {\n            if (intersection.contains(x)) {\n  \
    \              result.add(x);\n            }\n            intersection.remove(x);\n\
    \        }\n        return result;", "        Collections.sort(l1);\n        Collections.sort(l2);\n\
    \        ArrayList<Long> result = new ArrayList<Long>();\n        while (l1.size()\
    \ > 0) {\n            long x = l1.remove(0);\n            l2.remove(x);\n    \
    \        if (l1.isEmpty() && l2.isEmpty())\n                return result;\n \
    \           for (long y : l1)\n                if (y == x)\n                 \
    \   result.add(x);\n            for (long y : l2)\n                if (y == x)\n\
    \                    result.add(x);\n        }\n        return result;", "   \
    \     List<Long> common = Stream.concat(l1.stream(), l2.stream()).distinct().collect(Collectors.toList());\n\
    \        Collections.sort(common);\n        return new ArrayList<Long>(common);",
  "        ArrayList<Long> common = new ArrayList<Long>();\n        Set<Long> set\
    \ = new HashSet<>();\n        set.addAll(l1);\n        set.addAll(l2);\n     \
    \   for (Long value : set) {\n            if (!common.contains(value)) {\n   \
    \             common.add(value);\n            }\n        }\n        Collections.sort(common);\n\
    \        return common;", "        // Create a Set of elements from l1 which are\
    \ not in l2\n        Set<Long> s1L = l1.stream().filter(item -> !l2.contains(item)).collect(Collectors.toSet());\n\
    \        // Create a Set of elements from l2 which are not in l1\n        Set<Long>\
    \ s2L = l2.stream().filter(item -> !l1.contains(item)).collect(Collectors.toSet());\n\
    \n        // Return sorted unique elements from l1 and l2.\n        // >>> common((new\
    \ ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l, (long)34l, (long)653l,\
    \ (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l, (long)7l,\
    \ (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))\n        // (new ArrayList<Long>(Arrays.asList((long)2l,\
    \ (long)3l)))\n        // >>> common((new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)3l, (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l,\
    \ (long)2l))))\n        // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l,\
    \ (long)653l)))\n        ArrayList<Long> s1 = new ArrayList<Long>(s1L);\n    \
    \    ArrayList<Long> s2 = new ArrayList<Long>(s2L);\n        Collections.sort(s1);\n\
    \        Collections.sort(s2);\n        return new ArrayList<Long>(s1.containsAll(s2)\
    \ ? s1 : s2);", "        List<Long> common = new ArrayList<Long>();\n        int\
    \ i = 0, j = 0;\n        while(i < l1.size() && j < l2.size()) {\n           \
    \ long a = l1.get(i++);\n            long b = l2.get(j++);\n            if(a==b)\
    \ {\n                common.add(b);\n            } else if(a<b) {\n          \
    \      i++;\n            } else {\n                j++;\n            }\n     \
    \   }\n        return common;", "        ArrayList<Long> commonElements = new\
    \ ArrayList<Long>();\n\n        HashSet<Long> set = new HashSet<Long>(l1);\n \
    \       set.removeAll(l2);\n        for (Long l : set) {\n            commonElements.add(l);\n\
    \        }\n        System.out.println(\"Common elements: \" + commonElements);\n\
    \        return commonElements;", "        List<Long> result = new ArrayList<>(l1);\n\
    \        l1.removeAll(l2);\n        result.addAll(l1);\n        return result;",
  "        long max1 = (long)0;\n        long min1 = (long)0;\n        long max2 =\
    \ (long)0;\n        long min2 = (long)0;\n        if(l1.isEmpty() || l2.isEmpty()){\n\
    \            return new ArrayList<Long>();\n        }\n        for(int i =0; i\
    \ < l1.size(); i++){\n            max1 = (max1>l1.get(i)?max1:l1.get(i));\n  \
    \          min1 = (min1<l1.get(i)?min1:l1.get(i));\n            max2 = (max2>l2.get(i)?max2:l2.get(i));\n\
    \            min2 = (min2<l2.get(i)?min2:l2.get(i));\n        }\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        long cur1 = (long)0;\n        long\
    \ cur2 = (long)0;\n        for(int i = 0; i< l1.size(); i++){\n            boolean\
    \ flag = true;\n            for(int j = 0; j < l2.size(); j++){\n            \
    \    long tmp = l1.get(i) == l2.get(j)?l1.get(i):l2.get(j);\n                if(tmp\
    \ == max1 || tmp == max2){\n                    flag = false;\n              \
    \      break;\n                }\n            }\n            if(flag){\n     \
    \           result.add(l1.get(i));\n            }\n            cur1++;\n     \
    \   }\n        for(int i = 0; i< l2.size(); i++){\n            boolean flag =\
    \ true;\n            for(int j = 0; j < l1.size(); j++){\n                long\
    \ tmp = l2.get(i) == l1.get(j)?l2.get(i):l1.get(j);\n                if(tmp ==\
    \ max1 || tmp == max2){\n                    flag = false;\n                 \
    \   break;\n                }\n            }\n            if(flag){\n        \
    \        result.add(l2.get(i));\n            }\n            cur2++;\n        }\n\
    \        return result;", "        ArrayList<Long> ret = new ArrayList<Long>();\n\
    \        for (long x : l1) {\n            if (!l2.contains(x))\n             \
    \   ret.add(x);\n        }\n        return ret;", "        HashMap<Long,Integer>\
    \ map = new HashMap<>();\n        long max = Long.MIN_VALUE;\n        int maxIndex\
    \ = 0;\n        for (int i=0; i<l1.size(); i++) {\n            if (map.containsKey(l1.get(i)))\
    \ {\n                map.put(l1.get(i),map.get(l1.get(i))+1);\n            } else\
    \ {\n                map.put(l1.get(i), 1);\n            }\n            if (map.containsKey(l2.get(i)))\
    \ {\n                map.put(l2.get(i),map.get(l2.get(i))+1);\n            } else\
    \ {\n                map.put(l2.get(i), 1);\n            }\n            if (map.get(l1.get(i))>map.get(l2.get(i)))\
    \ {\n                max = l1.get(i);\n                maxIndex = i;\n       \
    \     } else if (map.get(l1.get(i))==map.get(l2.get(i)) && l1.get(i)>max) {\n\
    \                max = l1.get(i);\n                maxIndex = i;\n           \
    \ }\n        }\n        ArrayList<Long> result = new ArrayList<>();\n        for\
    \ (Long element : map.keySet()) {\n            if (map.get(element)>1) {\n   \
    \             result.add(element);\n            }\n        }\n        return result;",
  "        List<Long> result = new ArrayList<>();\n        if (l1.size() < l2.size())\
    \ {\n            return result;\n        }\n        if (l1.size() == l2.size())\
    \ {\n            Collections.sort(l1);\n            Collections.sort(l2);\n  \
    \          for (long x : l1) {\n                for (long y : l2) {\n        \
    \            if (x == y) {\n                        result.add(x);\n         \
    \           }\n                }\n            }\n        }\n        return result;",
  "        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n      \
    \  ArrayList<Long> result = new ArrayList<>();\n        Set<Long> set1 = new HashSet<>(l1);\n\
    \        Set<Long> set2 = new HashSet<>(l2);\n        set1.retainAll(set2);\n\
    \        result.addAll(set1);\n        return result;", "        Set<Long> set\
    \ = new HashSet<>();\n        set.addAll(l1);\n        set.addAll(l2);\n     \
    \   Set<Long> result = new HashSet<>();\n        result.addAll(set);\n       \
    \ return result.stream().sorted().distinct().collect(Collectors.toCollection(ArrayList::new));",
  "        if (l1 == null || l2 == null)\n            return null;\n        Set<Long>\
    \ set1 = new HashSet<>(l1);\n        Set<Long> set2 = new HashSet<>(l2);\n   \
    \     Set<Long> set3 = new HashSet<>();\n        set1.retainAll(set2);\n     \
    \   set1.removeAll(l1);\n        set2.removeAll(l2);\n        set3.addAll(set1);\n\
    \        return set3;", "        ArrayList<Long> ret = new ArrayList<>();\n  \
    \      IntStream l1i = l1.stream();\n        IntStream l2i = l2.stream();\n  \
    \      Long commonElement = l1i.min(l2i).orElse(-1l);\n        while (true) {\n\
    \            if (commonElement == -1l) break;\n            ret.add(commonElement);\n\
    \            l1i = l1i.filter(i -> i !=commonElement);\n            l2i = l2i.filter(i\
    \ -> i !=commonElement);\n        }\n        return ret;", "        ArrayList<Long>\
    \ common = new ArrayList<>();\n        l1.stream().filter(x -> l2.contains(x)).forEach(common::add);\n\
    \        l2.stream().filter(x -> l1.contains(x)).forEach(common::add);\n     \
    \   Collections.sort(common);\n        return common;", "        Set<Long> set1\
    \ = new HashSet<Long>(l1);\n        Set<Long> set2 = new HashSet<Long>(l2);\n\
    \        Set<Long> set = new HashSet<Long>();\n        set.addAll(set1);\n   \
    \     set.addAll(set2);\n        set.removeAll(l1);\n        set.removeAll(l2);\n\
    \        return list.stream().filter(x -> set.contains(x)).collect(Collectors.toList());",
  "        Set<Long> set = new HashSet<Long>(l1);\n        set.removeAll(l2);\n  \
    \      ArrayList<Long> result = new ArrayList<Long>(set.size());\n        result.addAll(l1);\n\
    \        result.addAll(l2);\n        result.sort(Comparator.naturalOrder());\n\
    \        return result;", "        // Sorting each array list and removing duplicates\
    \ from both.\n        // The resulting sorted arrays could then be used to find\
    \ common elements.\n        ArrayList<Long> l3 = new ArrayList<>(l1);\n      \
    \  Set<Long> unique1 = new HashSet<>(l1);\n        unique1.removeAll(l2);\n  \
    \      l3.removeAll(l1);\n        Set<Long> unique2 = new HashSet<>(l2);\n   \
    \     unique2.removeAll(l1);\n        l3.removeAll(l2);\n        // Sorting final\
    \ list if necessary.\n        if (!l3.isEmpty()) {\n            l3.sort(Long::compare);\n\
    \        }\n        // Removing duplicates and adding elements not found in first\
    \ set.\n        ArrayList<Long> l4 = new ArrayList<>(l3);\n        l4.removeAll(l1);\n\
    \        l4.removeAll(l2);\n        l4.addAll(l2);\n        // Sorting final list\
    \ if necessary.\n        if (!l4.isEmpty()) {\n            l4.sort(Long::compare);\n\
    \        }\n        return l4;", "        Set<Long> common = new HashSet<>();\n\
    \        for (Long value : l1) {\n            if (l2.contains(value)) {\n    \
    \            common.add(value);\n            }\n        }\n        return new\
    \ ArrayList<Long>(common);", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        Set<Long> s1 = new HashSet<Long>(l1);\n        Set<Long> s2 = new HashSet<Long>(l2);\n\
    \        \n        for(long i : s1) {\n            boolean found = false;\n  \
    \          for(long j : s2) {\n                if(i == j) {\n                \
    \    found = true;\n                    break;\n                }\n          \
    \  }\n            if(!found) {\n                result.add(i);\n            }\n\
    \        }\n        return result;", "        ArrayList<Long> c = new ArrayList<>();\n\
    \        Collections.sort(l1);\n        Collections.sort(l2);\n        int i =\
    \ 0;\n        while (i < Math.min(l1.size(), l2.size())) {\n            long l1\
    \ = l1.get(i);\n            long l2 = l2.get(i);\n            if (l1 == l2) {\n\
    \                c.add(l1);\n                i++;\n            } else if (l1 <\
    \ l2) {\n                c.add(l1);\n            } else {\n                c.add(l2);\n\
    \            }\n        }\n        return c;", "        ArrayList<Long> l3 = new\
    \ ArrayList<>();\n        if (l1 == null || l2 == null || l2.size() <= l1.size())\
    \ {\n            return l3;\n        }\n        Set<Long> uniqueSet1 = new HashSet<>();\n\
    \        Set<Long> uniqueSet2 = new HashSet<>();\n        for (Long val : l1)\
    \ {\n            if (!uniqueSet1.contains(val)) {\n                l3.add(val);\n\
    \                uniqueSet1.add(val);\n            }\n        }\n        for (Long\
    \ val : l2) {\n            if (!uniqueSet2.contains(val)) {\n                l3.add(val);\n\
    \                uniqueSet2.add(val);\n            }\n        }\n        return\
    \ l3;", "        Set<Long> set1 = new HashSet<Long>(l1);\n        Set<Long> set2\
    \ = new HashSet<Long>(l2);\n        set1.removeAll(set2);\n        return new\
    \ ArrayList<>(set1);", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        // Sorting both lists to get an order\n        List<Long> sorted1 = sort(l1);\n\
    \        List<Long> sorted2 = sort(l2);\n\n        boolean isSorted1 = sorted1.equals(sort(common));\n\
    \        boolean isSorted2 = sorted2.equals(sort(common));\n        boolean isCommon\
    \ = sorted1.containsAll(sorted2) && sorted2.containsAll(sorted1);\n\n        if\
    \ (!isSorted1 && !isSorted2) {\n            return common;\n        } else if\
    \ (isSorted1 && !isSorted2) {\n            return common;\n        } else if (isSorted1\
    \ && isSorted2) {\n            // Merge both lists into a single list sorted and\
    \ compare with common one\n            merge(l1, l2, common);\n            //\
    \ If common list has the same size as smaller one - it's common element\n    \
    \        if (sorted1.size() < sorted2.size()) {\n                return common;\n\
    \            }\n            // If common list has the same size as smaller one\
    \ - it's common element\n            if (sorted1.size() > sorted2.size()) {\n\
    \                return common;\n            }\n            // If common list\
    \ has the same size as smaller one - it's common element\n            if (sorted1.equals(sort(common)))\
    \ {\n                return common;\n            }\n            // If common list\
    \ has the same size as smaller one - it's common element\n            if (sorted2.equals(sort(common)))\
    \ {\n                return common;\n            }\n        }\n        return\
    \ common;", "        // Solution 1: Sort and compare\n        ArrayList<Long>\
    \ list = new ArrayList<Long>(l1);\n        list.sort(Comparator.naturalOrder());\n\
    \        list.retainAll(l2);\n        // Solution 2: Use Set\n        Set<Long>\
    \ list2 = new HashSet<Long>(l1);\n        list2.retainAll(l2);\n        List<Long>\
    \ result = new ArrayList<>(list);\n        result.addAll(list2);\n        return\
    \ result;", "        ArrayList<Long> result = new ArrayList<>();\n\n        final\
    \ int len = Math.min(l1.size(), l2.size());\n        int i = 0;\n        while\
    \ (i < len) {\n            int j = 0;\n            while (j < len) {\n       \
    \         if (l1.get(i) == l2.get(j)) {\n                    result.add(l1.get(i));\n\
    \                    l1.remove(i);\n                    l2.remove(j);\n      \
    \              break;\n                }\n                j++;\n            }\n\
    \            i++;\n        }\n\n        return result;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        if (l1 == null || l2 == null) return\
    \ result;\n        for (Long l : l1) {\n            if (l2.contains(l)) result.add(l);\n\
    \        }\n        return result;", "        ArrayList<Long> ans = new ArrayList<>();\n\
    \        for (Long n : l1) {\n            for (Long m : l2) {\n              \
    \  if (n == m)\n                    ans.add(n);\n            }\n        }\n  \
    \      return ans;", "        if (l1.size() == 0) return l2;\n        if (l2.size()\
    \ == 0) return l1;\n\n        ArrayList<Long> l3 = new ArrayList<Long>();\n  \
    \      long tmp;\n        long min = Math.min(Math.min(l1.get(0), l2.get(0)),\
    \ Math.max(l1.get(l1.size()-1), l2.get(l2.size()-1)));\n\n        for (int i =\
    \ 0; i < l1.size(); i++) {\n            tmp = min;\n            while (l1.get(i)\
    \ > tmp && i < l1.size()) {\n                tmp = l1.get(i);\n              \
    \  i++;\n            }\n            l3.add(tmp);\n            tmp = min;\n   \
    \         while (l2.get(i) > tmp && i < l2.size()) {\n                tmp = l2.get(i);\n\
    \                i++;\n            }\n            l3.add(tmp);\n        }\n\n\
    \        return l3;", "        ArrayList<Long> result = new ArrayList<Long>(l1);\n\
    \        Collections.sort(l1);\n        Collections.sort(l2);\n        boolean\
    \ found = false;\n        for (long i : l1) {\n            boolean foundIn = false;\n\
    \            for (long j : l2) {\n                if (i == j) {\n            \
    \        foundIn = true;\n                    break;\n                }\n    \
    \        }\n            if (!foundIn) {\n                result.add(i);\n    \
    \        }\n        }\n        return result;", "        ArrayList<Long> result\
    \ = new ArrayList<>();\n        Long min = Math.min(l1.get(0), l2.get(0));\n \
    \       int minIndex = 0;\n        for (int i = 1; i < Math.min(l1.size(), l2.size());\
    \ i++) {\n            if (l1.get(i) == min) {\n                minIndex = i;\n\
    \            } else if (l2.get(i) == min) {\n                result.add(min);\n\
    \                result.add(l1.get(minIndex));\n                minIndex = i;\n\
    \            }\n        }\n        if (minIndex < l1.size()) {\n            result.add(min);\n\
    \            result.add(l1.get(minIndex));\n        }\n        if (minIndex <\
    \ l2.size()) {\n            result.add(min);\n            result.add(l2.get(minIndex));\n\
    \        }\n        return result;", "        ArrayList<Long> common = new ArrayList<Long>(l1);\n\
    \        HashSet<Long> hs = new HashSet<Long>(l2);\n        common.removeAll(l2);\n\
    \        common.removeAll(hs);\n        return common;", "        Set<Long> common\
    \ = new HashSet<Long>(l1);\n        common.retainAll(l2);\n        ArrayList<Long>\
    \ ret = new ArrayList<Long>();\n        for (Long elem : common) {\n         \
    \   ret.add(elem);\n        }\n        return ret;", "        Set<Long> set1 =\
    \ new HashSet<>(l1);\n        Set<Long> set2 = new HashSet<>(l2);\n        Set<Long>\
    \ commonSet = new HashSet<>();\n        for (Long s : set1) {\n            if\
    \ (set2.contains(s)) {\n                commonSet.add(s);\n            }\n   \
    \     }\n        ArrayList<Long> l3 = new ArrayList<>(commonSet);\n        Collections.sort(l3);\n\
    \        return l3;", "        return Stream.of(\n                l1.stream().distinct(),\n\
    \                l2.stream().distinct(),\n                Collectors.toList())\n\
    \                .flatMap(List::stream)\n                .filter(i -> l1.containsAll(l2))\n\
    \                .filter(i -> l2.containsAll(l1))\n                .collect(Collectors.toList());",
  "        // Iterate through both lists and add the common elements to a new list.\n\
    \        ArrayList<Long> resultList = new ArrayList<>();\n        for(long element\
    \ : l1) {\n            if(l2.contains(element)) {\n                resultList.add(element);\n\
    \            }\n        }\n        return resultList;", "        // Make two array\
    \ lists: first common elements, second non-common elements.\n        List<Long>\
    \ common = new ArrayList<>();\n        List<Long> nonCommon = new ArrayList<>();\n\
    \        for (int i = 0; i < l1.size(); i++) {\n            int j = 0;\n     \
    \       while (j < l2.size() && l2.get(j) == l1.get(i)) {\n                j++;\n\
    \            }\n            if (j == l2.size()) {\n                nonCommon.add(l1.get(i));\n\
    \            } else {\n                common.add(l1.get(i));\n            }\n\
    \        }\n        Collections.sort(common);\n        Collections.sort(nonCommon);\n\
    \        // Return sorted unique common elements.\n        return new ArrayList<Long>(new\
    \ ArrayList<Long>(common));", "        // Sort the lists.\n        if (l1 == null\
    \ || l2 == null) {\n            return null;\n        }\n        if (l1.size()\
    \ > l2.size()) {\n            l1.sort(Comparator.naturalOrder());\n          \
    \  l2.sort(Comparator.naturalOrder());\n        } else if (l1.size() < l2.size())\
    \ {\n            l2.sort(Comparator.naturalOrder());\n            l1.sort(Comparator.naturalOrder());\n\
    \        }\n        ArrayList<Long> commonList = new ArrayList<>();\n        long\
    \ last = null;\n        for (int i = 0; i < (l1.size() + l2.size()); i++) {\n\
    \            if (last != null && l1.get(i) == last) {\n                commonList.add(l1.get(i));\n\
    \            } else if (last != null && l2.get(i) == last) {\n               \
    \ commonList.add(l2.get(i));\n            } else if (last == null && (l1.get(i)\
    \ == l2.get(i))) {\n                commonList.add(l1.get(i));\n            }\n\
    \            last = l1.get(i);\n        }\n        return commonList;", "    \
    \    ArrayList<Long> l3 = new ArrayList<>();\n        Collections.sort(l1);\n\
    \        Collections.sort(l2);\n        if (l1.size() != l2.size()) {\n      \
    \      return l3;\n        }\n        int minLength = Math.min(l1.size(), l2.size());\n\
    \        for (int i = 0; i < minLength; i++) {\n            l3.add(l1.get(i));\n\
    \            if (l2.contains(l1.get(i))) {\n                l3.add(l2.get(i));\n\
    \                Collections.sort(l3);\n                return l3;\n         \
    \   }\n        }\n        return l3;", "        // sort both lists first\n   \
    \     Collections.sort(l1);\n        Collections.sort(l2);\n        int n1 = l1.size(),\
    \ n2 = l2.size();\n        // create result list with size as smaller of the two\n\
    \        ArrayList<Long> result = new ArrayList<Long>(n1 < n2 ? n1 : n2);\n  \
    \      // add common elements, if any\n        for (int i = 0; i < Math.min(result.size(),\
    \ n1 - n2); i++) {\n            result.add(l1.get(i));\n        }\n        for\
    \ (int i = 0; i < Math.min(result.size(), n2 - n1); i++) {\n            result.add(l2.get(i));\n\
    \        }\n        // return sorted result\n        Collections.sort(result);\n\
    \        return result;", "        // Write your implementation\n        ArrayList<Long>\
    \ res = new ArrayList<>();\n        HashMap<Long, Long> map = new HashMap<>();\n\
    \        for (Long val : l1)\n            map.put(val, map.getOrDefault(val, 0)\
    \ + 1);\n        for (Long val : l2)\n            if (map.containsKey(val))\n\
    \                res.add(map.get(val));\n        return res;", "        // Find\
    \ out what the longest list is\n        int longest = Collections.max(Collections.comparingInt(i\
    \ -> i.size()));\n        int longest2 = Collections.max(Collections.comparingInt(i\
    \ -> i.size()));\n        if (l1.size() > longest) {\n            return common(l1,\
    \ l2, longest);\n        } else if (l2.size() > longest2) {\n            return\
    \ common(l2, l1, longest2);\n        }\n\n        int n = Math.min(l1.size(),\
    \ l2.size());\n        if (l1.size() < l2.size()) {\n            // Copy l1 to\
    \ l2\n            ArrayList<Long> l3 = new ArrayList<>();\n            for (int\
    \ i = 0; i < n; i++) {\n                l3.add(l1.get(i));\n                l3.add(l2.get(i));\n\
    \            }\n            return common(l3, l3, n);\n        } else {\n    \
    \        // Copy l2 to l1\n            ArrayList<Long> l4 = new ArrayList<>();\n\
    \            for (int i = 0; i < n; i++) {\n                l4.add(l2.get(i));\n\
    \                l4.add(l1.get(i));\n            }\n            return common(l4,\
    \ l4, n);\n        }", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        long l1 = l1.size();\n        long l2 = l2.size();\n        long maxL1\
    \ = Long.MIN_VALUE;\n        long maxL2 = Long.MIN_VALUE;\n        // get max\
    \ value from l1 and l2 \n        if(l1.size() > l2.size())\n            maxL1\
    \ = l1.get(l1.size() - 1);\n        else\n            maxL1 = l2.get(l2.size()\
    \ - 1);\n\n        for(int i = 0; i < maxL1; i++) {\n            long val1 = l1.get(i);\n\
    \            for(int j = i + 1; j < l1.size(); j++) {\n                long val2\
    \ = l2.get(j);\n                if(val1 < val2) {\n                    // swap\
    \ values\n                    result.add(val2);\n                    result.add(val1);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     // get max value from l1 and l2 \n        if(l2.size() > l1.size())\n  \
    \          maxL2 = l2.get(l2.size() - 1);\n        else\n            maxL2 = l1.get(l1.size()\
    \ - 1);\n\n        for(int i = 0; i < maxL2; i++) {\n            long val1 = l2.get(i);\n\
    \            for(int j = i + 1; j < l2.size(); j++) {\n                long val2\
    \ = l1.get(j);\n                if(val1 < val2) {\n                    // swap\
    \ values\n                    result.add(val2);\n                    result.add(val1);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return result;", "        long [] a1 = l1.stream().mapToLong(Long::longValue).toArray();\n\
    \        long [] a2 = l2.stream().mapToLong(Long::longValue).toArray();\n    \
    \    Arrays.sort(a1);\n        Arrays.sort(a2);\n        ArrayList<Long> common\
    \ = new ArrayList<>();\n        for(int i = 0; i < a1.length; i++) {\n       \
    \     if(a1[i] == a2[i])\n                common.add(a1[i]);\n        }\n    \
    \    return common;", "        HashSet<Long> hs1 = new HashSet<>();\n        HashSet<Long>\
    \ hs2 = new HashSet<>();\n        for (Long i : l1) {\n            hs1.add(i);\n\
    \        }\n        for (Long i : l2) {\n            hs2.add(i);\n        }\n\
    \        return new ArrayList<>(hs1);", "        if (l1 == null || l2 == null\
    \ || l1.size() == 0 || l2.size() == 0) {\n            return null;\n        }\n\
    \n        Set<Long> set = new HashSet<>(l1);\n        set.removeAll(l2);\n   \
    \     return set.stream().distinct().collect(Collectors.toCollection(ArrayList::new));",
  "        l2.forEach(l2::remove);\n        l1.removeAll(l2);\n        if (l1.isEmpty()\
    \ || l2.isEmpty()) return new ArrayList<Long>();\n        l1.sort();\n       \
    \ l2.sort();\n        long m = (l1.get(0) > l2.get(0)) ? l1.get(0) : l2.get(0);\n\
    \        l1.remove(0);\n        l2.remove(0);\n        ArrayList<Long> result\
    \ = new ArrayList<Long>();\n        for (long m : l1) {\n            if (m ==\
    \ m) result.add(m);\n        }\n        return result;", "        Set<Long> set1\
    \ = new HashSet<>(l1);\n        Set<Long> set2 = new HashSet<>(l2);\n        ArrayList<Long>\
    \ result = new ArrayList<>();\n        result.addAll(set1);\n        result.addAll(set2);\n\
    \        result.retainAll(set1);\n        return result;", "        if (l1 ==\
    \ null || l2 == null) return null;\n        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        for (long i : l1) if (!l2.contains(i)) result.add(i);\n        return\
    \ result;", "        Set<Long> set1 = new HashSet<>(l1);\n        Set<Long> set2\
    \ = new HashSet<>(l2);\n        set1.retainAll(set2);\n        return new ArrayList<Long>(set1);",
  "        // We use a TreeMap to sort the lists.\n        // This is how we sort\
    \ the list by values.\n        TreeMap<Long, Long> treeMap = new TreeMap<>();\n\
    \        treeMap.addAll(l1);\n        treeMap.addAll(l2);\n        List<Long>\
    \ values = treeMap.values();\n        Arrays.sort(values);\n\n        // This\
    \ will be our resulting list.\n        ArrayList<Long> result = new ArrayList<>(values.size());\n\
    \n        // Now go through the remaining list, and copy the ones that are present.\n\
    \        for (Long value : values) {\n            if (l1.contains(value)) {\n\
    \                result.add(value);\n            }\n            if (l2.contains(value))\
    \ {\n                result.add(value);\n            }\n        }\n        return\
    \ result;", "        ArrayList<Long> common = new ArrayList<>();\n        Set<Long>\
    \ set1 = new HashSet<>(l1);\n        Set<Long> set2 = new HashSet<>(l2);\n   \
    \     Set<Long> commonSet = set1.stream()\n                .filter(set2::contains)\n\
    \                .collect(Collectors.toSet());\n        for (Long l : commonSet)\
    \ {\n            common.add(l);\n        }\n        return common;", "       \
    \ List<Long> l1List = Arrays.stream(l1).boxed().collect(Collectors.toList());\n\
    \        List<Long> l2List = Arrays.stream(l2).boxed().collect(Collectors.toList());\n\
    \        return Arrays.asList(l1List, l2List).stream().filter((l) -> l.size()\
    \ > 1).flatMap(Collection::stream).distinct().collect(Collectors.toList());",
  "        Map<Long, Integer> hashMap = new HashMap<>();\n        l1.stream().forEach((e)\
    \ -> hashMap.put(e, hashMap.getOrDefault(e, 0) + 1));\n        l2.stream().forEach((e)\
    \ -> hashMap.put(e, hashMap.getOrDefault(e, 0) + 1));\n        return l1.stream().filter(e\
    \ -> hashMap.get(e) == hashMap.get(l1.get(e))).collect(Collectors.toList());",
  '        return Collections.unmodifiableList(new ArrayList<>(Commons.intersection(l1,
    l2)));', "        final ArrayList<Long> list = new ArrayList<>(l1);\n        if\
    \ (list.size() != l2.size()) {\n            throw new IllegalArgumentException(\"\
    Cannot compare lists with different sizes\");\n        }\n\n        List<Long>\
    \ result = new ArrayList<>();\n\n        list.forEach(l -> {\n            boolean\
    \ found = false;\n            for (Long l2 : l2) {\n                if (l.equals(l2))\
    \ {\n                    found = true;\n                    break;\n         \
    \       }\n            }\n            if (!found) {\n                result.add(l);\n\
    \            }\n        });\n\n        Collections.sort(result);\n        return\
    \ result;", "        HashSet<Long> common = new HashSet<Long>();\n        // Iterate\
    \ over the first list and remove all elements that are not present in second list.\n\
    \        for(long l: l1) {\n            if(!l2.contains(l)) {\n              \
    \  l1.remove(l);\n            }\n        }\n        // Add the remaining elements\
    \ from the first list to the common set.\n        common.addAll(l1);\n       \
    \ return new ArrayList<Long>(common);", "        HashSet<Long> h1 = new HashSet<>();\n\
    \        HashSet<Long> h2 = new HashSet<>();\n        h1.addAll(l1);\n       \
    \ h2.addAll(l2);\n        return new ArrayList<Long>(h1).retainAll(h2).stream().sorted().collect(Collectors.toCollection(ArrayList::new));",
  "        Set<Long> s1 = new HashSet<Long>(l1);\n        Set<Long> s2 = new HashSet<Long>(l2);\n\
    \        return s2.stream().filter(x -> s1.contains(x))\n            .collect(Collectors.toCollection(ArrayList::new));",
  "        if (l1 == null && l2 == null) return null;\n        HashMap<Long, Long>\
    \ hashMap = new HashMap<>();\n        for (Long element : l1) {\n            hashMap.put(element,\
    \ 1l);\n        }\n        for (Long element : l2) {\n            if (hashMap.get(element)\
    \ == null) {\n                hashMap.put(element, 0l);\n            }\n     \
    \   }\n        List<Long> result = new ArrayList<>(hashMap.keySet());\n      \
    \  Collections.sort(result);\n        return result;", "        return StreamSupport.stream(l1.spliterator(),\
    \ false)\n                .filter(e -> l2.contains(e))\n                .distinct()\n\
    \                .collect(Collectors.toList());", '        return Collections.frequency(new
    LinkedHashSet<>(l1), l2); // return frequent element in l1.', "        if (l1.isEmpty())\
    \ return l2;\n        if (l2.isEmpty()) return l1;\n        \n        ArrayList<Long>\
    \ common = new ArrayList<Long>();\n        \n        if (l1.get(0) == l2.get(0))\
    \ {\n            common.add(l1.get(0));\n            return common;\n        }\n\
    \        \n        int i = 0, j = 0;\n        \n        while (i < l1.size() &&\
    \ j < l2.size()) {\n            if (l1.get(i) > l2.get(j)) {\n               \
    \ i++;\n            } else if (l1.get(i) < l2.get(j)) {\n                j++;\n\
    \            } else {\n                common.add(l1.get(i));\n              \
    \  i++;\n                j++;\n            }\n        }\n        \n        if\
    \ (i < l1.size()) {\n            for (; i < l1.size(); i++) {\n              \
    \  common.add(l1.get(i));\n            }\n        } else if (j < l2.size()) {\n\
    \            for (; j < l2.size(); j++) {\n                common.add(l2.get(j));\n\
    \            }\n        }\n        \n        return common;", "        if (l1\
    \ == null) return l2;\n        if (l2 == null) return l1;\n        if (l1.size()\
    \ == 0 || l2.size() == 0) return null;\n        Set<Long> s1Set = new HashSet<>(l1);\n\
    \        Set<Long> s2Set = new HashSet<>(l2);\n        ArrayList<Long> uniqueCommon\
    \ = new ArrayList<Long>();\n        for (Long i : s1Set) {\n            if (s2Set.contains(i))\
    \ {\n                uniqueCommon.add(i);\n            }\n        }\n        return\
    \ uniqueCommon;", "        ArrayList<Long> result = new ArrayList<>(l1);\n   \
    \     long last = 0;\n        long next = 0;\n        while (l1.size() > 0 &&\
    \ l2.size() > 0) {\n            if (l1.get(l1.size()-1) < l2.get(l2.size()-1))\
    \ {\n                result.add(l1.get(l1.size()-1));\n                l1.remove(l1.size()-1);\n\
    \            } else {\n                result.add(l2.get(l2.size()-1));\n    \
    \            l2.remove(l2.size()-1);\n            }\n        }\n        l1.addAll(l2);\n\
    \        while (l1.size() > 0) {\n            result.add(l1.get(l1.size()-1));\n\
    \            l1.remove(l1.size()-1);\n        }\n        while (l2.size() > 0)\
    \ {\n            result.add(l2.get(l2.size()-1));\n            l2.remove(l2.size()-1);\n\
    \        }\n        return result;", "        ArrayList<Long> result = new ArrayList<>(l1);\n\
    \        boolean included = false;\n        for (long e : l2) {\n            if\
    \ (included) {\n                if (result.contains(e)) {\n                  \
    \  continue;\n                } else {\n                    result.add(e);\n \
    \               }\n            } else {\n                if (result.contains(e))\
    \ {\n                    included = true;\n                }\n            }\n\
    \        }\n        return result;", "        ArrayList<Long> result = new ArrayList<Long>();\n\
    \        if (l1.size() != l2.size()) {\n            return result;\n        }\n\
    \        long max1 = Long.MIN_VALUE;\n        long min1 = Long.MAX_VALUE;\n  \
    \      long max2 = Long.MIN_VALUE;\n        long min2 = Long.MAX_VALUE;\n    \
    \    for(int i = 0; i < l1.size(); i++) {\n            if (l1.get(i) > max1) {\n\
    \                max1 = l1.get(i);\n            }\n            if (l1.get(i) <\
    \ min1) {\n                min1 = l1.get(i);\n            }\n            if (l2.get(i)\
    \ > max2) {\n                max2 = l2.get(i);\n            }\n            if\
    \ (l2.get(i) < min2) {\n                min2 = l2.get(i);\n            }\n   \
    \     }\n        if (max1 > max2) {\n            long max = max1;\n          \
    \  max1 = max2;\n            max2 = max;\n        }\n        if (min1 < min2)\
    \ {\n            long min = min1;\n            min1 = min2;\n            min2\
    \ = min;\n        }\n        if (max1 > max1) {\n            long max = max1;\n\
    \            max1 = max1;\n            max2 = max;\n        }\n        if (min1\
    \ < min1) {\n            long min = min1;\n            min1 = min1;\n        \
    \    min2 = min;\n        }\n        int i = 0;\n        while(i < l1.size() &&\
    \ i < l2.size()) {\n            if (l1.get(i) == l2.get(i)) {\n              \
    \  result.add(l1.get(i));\n                i++;\n            }\n            else\
    \ {\n                if((l1.get(i) > max1 && l2.get(i) > max2) || (l1.get(i) <\
    \ min1 && l2.get(i) < min2)) {\n                    max1 = Math.max(max1, l1.get(i));\n\
    \                    max2 = Math.max(max2, l2.get(i));\n                    max1\
    \ = Math.max(max1, l1.get(i));\n                    max2 = Math.max(max2, l2.get(i));\n\
    \                }\n                else if((l1.get(i) > max1 && l2.get(i) < max2)\
    \ || (l1.get(i) < min1 && l2.get(i) > min2)) {\n                    max1 = Math.min(max1,\
    \ l1.get(i));\n                    max2 = Math.min(max2, l2.get(i));\n       \
    \             max1 = Math.min(max1, l1.get(i));\n                    max2 = Math.min(max2,\
    \ l2.get(i));\n                }\n                else {\n                   \
    \ max1 = Math.max(max1, l1.get(i));\n                    max2 = Math.max(max2,\
    \ l2.get(i));\n                }\n            }\n        }\n        while(i <\
    \ l1.size()) {\n            result.", "        if (l1.size() < 2 || l2.size()\
    \ < 2) return new ArrayList<Long>();\n        Collections.sort(l1);\n        Collections.sort(l2);\n\
    \        Map<Long, Long> m = new HashMap<Long, Long>();\n        for (long i :\
    \ l1) m.put(i, -1l);\n        for (long i : l2) m.put(i, 1l);\n        ArrayList<Long>\
    \ result = new ArrayList<Long>();\n        for (long i : m) if (m.get(i) != -1l)\
    \ result.add(m.get(i));\n        return result;", "        ArrayList<Long> common\
    \ = new ArrayList<Long>();\n        for (Long l: l1) {\n            if (l2.contains(l))\
    \ common.add(l);\n        }\n        return common;", "        ArrayList<Long>\
    \ l = new ArrayList<Long>(l1.size());\n        List<Long> list = new ArrayList<Long>(l1.size());\n\
    \        boolean found = false;\n        Set<Long> set = new HashSet<Long>();\n\
    \        for (Long i : l1) {\n            if (set.contains(i)) {\n           \
    \     continue;\n            }\n            set.add(i);\n            list.add(i);\n\
    \        }\n        for (Long i : l2) {\n            if (set.contains(i)) {\n\
    \                continue;\n            }\n            set.add(i);\n         \
    \   list.add(i);\n        }\n        l1.retainAll(list);\n        l2.retainAll(list);\n\
    \        return l;", "        HashSet<Long> hs1 = new HashSet<>(l1);\n       \
    \ HashSet<Long> hs2 = new HashSet<>(l2);\n        ArrayList<Long> l3 = new ArrayList<>(new\
    \ HashSet<Long>(l1).stream().filter(x -> !hs2.contains(x)).collect(Collectors.toSet()));\n\
    \        ArrayList<Long> l4 = new ArrayList<>(new HashSet<Long>(l2).stream().filter(x\
    \ -> !hs1.contains(x)).collect(Collectors.toSet()));\n        return l3.equals(l4)\
    \ ? l3 : common(l3, l4);", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        int i;\n        // Sort the array so that we know if l1 or l2 is longer\
    \ than the other\n        Collections.sort(l1);\n        Collections.sort(l2);\n\
    \n        // Iterate through both array lists\n        for (i = 0; l1.size() >\
    \ 0 && i < l2.size(); i++) {\n            if (l1.get(i).equals(l2.get(i))) {\n\
    \                common.add(l1.get(i));\n                l1.remove(i);\n     \
    \           l2.remove(i);\n            }\n        }\n\n        // If one of them\
    \ has fewer than the other left, we need to\n        // add the remaining items\
    \ from l2 onto common\n        if (l1.size() > 0) {\n            for (i = 0; i\
    \ < l1.size(); i++) {\n                common.add(l1.get(i));\n            }\n\
    \        }\n\n        return common;", "        List<Long> common = new ArrayList<>(l1);\n\
    \        common.retainAll(l2);\n        return common;", "        ArrayList<Long>\
    \ unique = new ArrayList<>();\n        long max = Long.MIN_VALUE;\n        for\
    \ (Long elem : l1) {\n            if (elem > max) {\n                max = elem;\n\
    \            }\n        }\n        for (Long elem : l2) {\n            if (elem\
    \ > max) {\n                max = elem;\n            }\n        }\n        for\
    \ (Long elem : l1) {\n            for (Long elem2 : l2) {\n                if\
    \ (elem.equals(elem2)) {\n                    unique.add(elem);\n            \
    \        unique.add(elem2);\n                }\n            }\n        }\n   \
    \     unique.add(0, max);\n        unique.addAll(l2);\n        unique.remove(l1.size());\n\
    \        Collections.sort(unique);\n        return unique;", "        final long\
    \ count = Math.min(l1.size(), l2.size());\n        ArrayList<Long> common = new\
    \ ArrayList<Long>();\n        long curr = 0;\n        for(; curr < count; curr++)\
    \ {\n            if(!l1.contains(l2.get(curr)) && !l2.contains(l1.get(curr)))\
    \ {\n                common.add(l1.get(curr));\n            }\n        }\n   \
    \     if(!l1.isEmpty()) {\n            for(long i = 0; i < l1.size(); i++) {\n\
    \                if(!l2.contains(common.get(i))) {\n                    common.remove(common.size()\
    \ - 1);\n                }\n            }\n        }\n        return common;",
  "        Set<Long> common = new HashSet<>();\n        Set<Long> set = new HashSet<>(l1);\n\
    \        set.retainAll(l2);\n        common.addAll(set);\n        return common;",
  "        if (l1.isEmpty() || l2.isEmpty()) return new ArrayList<Long>();\n     \
    \   if (l1.size() > l2.size()) {\n            ArrayList<Long> temp = new ArrayList<Long>(l1);\n\
    \            temp.removeAll(l2);\n            return common(temp, l2);\n     \
    \   } else if (l2.size() > l1.size()) {\n            ArrayList<Long> temp = new\
    \ ArrayList<Long>(l2);\n            temp.removeAll(l1);\n            return common(l1,\
    \ temp);\n        }\n\n        ArrayList<Long> common = new ArrayList<Long>();\n\
    \        for (Long i : l1) if (!common.remove(i)) common.add(i);\n        return\
    \ common;", "        ArrayList list = new ArrayList();\n        ArrayList list2\
    \ = new ArrayList();\n        list.addAll(l1);\n        list2.addAll(l2);\n  \
    \      for (int i = 0; i < list.size(); i++) {\n            if (list.get(i) ==\
    \ null && list2.get(i) != null)\n                list.remove(i);\n           \
    \ else if (list2.get(i) == null && list.get(i) != null)\n                list2.remove(i);\n\
    \            else if (list.get(i) != null && list2.get(i) == null)\n         \
    \       list.remove(i);\n            else if (list.get(i) == null && list2.get(i)\
    \ == null)\n                continue;\n            else if (list.get(i) != null\
    \ && list2.get(i) != null) {\n                for (int j = 0; j < list2.size();\
    \ j++) {\n                    if (list2.get(j) == list.get(i))\n             \
    \           list2.remove(j);\n                }\n            }\n        }\n  \
    \      return list;", "        return Collections.unmodifiableList(l1.stream()\n\
    \                .filter(e -> l2.stream().anyMatch(e2 -> e == e2)))\n        \
    \        .sorted().collect(Collectors.toCollection(ArrayList::new));", "     \
    \   Map<Long, Long> map1 = new HashMap<Long, Long>(l1);\n        Map<Long, Long>\
    \ map2 = new HashMap<Long, Long>(l2);\n        Set<Long> common = new HashSet<Long>(l1);\n\
    \        common.retainAll(l2);\n        for (Long value : common) {\n        \
    \    map1.remove(value);\n            map2.remove(value);\n        }\n       \
    \ List<Long> result = new ArrayList<Long>(map1);\n        result.retainAll(l2);\n\
    \        return result;", "        ArrayList<Long> result = new ArrayList<>(l1);\n\
    \        for(int i = 1; i < l1.size(); i++)\n        {\n            boolean isFound\
    \ = false;\n            for(int j = 1; j < l2.size(); j++)\n            {\n  \
    \              if(l2.get(j) == l1.get(i))\n                {\n               \
    \     isFound = true;\n                    break;\n                }\n       \
    \     }\n            if(!isFound)\n            {\n                result.add(l1.get(i));\n\
    \            }\n        }\n        return result;", "        ArrayList<Long> res\
    \ = new ArrayList<>(l1);\n        for(long i : l2) {\n            if(!res.contains(i))\
    \ {\n                res.add(i);\n            }\n        }\n        return res;",
  "        ArrayList<Long> result = new ArrayList<>();\n        long commonElements\
    \ = 0;\n        for(Long l : l1) {\n            if(l2.contains(l)) {\n       \
    \         commonElements++;\n            }\n        }\n        for(Long l : l2)\
    \ {\n            if(!l1.contains(l)) {\n                commonElements--;\n  \
    \          }\n        }\n        for(Long l : l1) {\n            if(l2.contains(l))\
    \ {\n                commonElements--;\n            }\n            if(!result.contains(l))\
    \ {\n                result.add(l);\n            }\n        }\n        for(Long\
    \ l : l2) {\n            if(!l1.contains(l)) {\n                commonElements++;\n\
    \            }\n            if(result.contains(l)) {\n                result.remove(result.indexOf(l));\
    \ //remove element from result if l2 contains element from result\n          \
    \  }\n        }\n        return result;", "        \n        ArrayList<Long> res\
    \ = new ArrayList<>();\n        \n        Set<Long> set1 = new HashSet<>();\n\
    \        Set<Long> set2 = new HashSet<>();\n        \n        for (long i : l1)\
    \ {\n            set1.add(i);\n        }\n        \n        for (long i : l2)\
    \ {\n            set2.add(i);\n        }\n        \n        for (Long i : set1)\
    \ {\n            if (!set2.contains(i)) {\n                res.add(i);\n     \
    \       }\n        }\n        \n        return res;", "        List<Long> common\
    \ = new ArrayList<>(l1);\n        common.removeAll(l2);\n        return common;",
  '        return l1.stream().filter(l -> l2.contains(l)).collect(Collectors.toCollection(ArrayList::new));',
  "        ArrayList<Long> common = new ArrayList<>();\n        for(long l: l1){\n\
    \            if(l2.contains(l)){\n                common.add(l);\n           \
    \ }\n        }\n        return common;", "        if (l1 == null || l2 == null)\
    \ {\n            return new ArrayList<Long>();\n        }\n        ArrayList<Long>\
    \ ret = new ArrayList<Long>(l1.size());\n        ArrayList<Long> common = new\
    \ ArrayList<Long>(l1.size());\n        for (Long e : l1) {\n            for (Long\
    \ f : l2) {\n                if (e == f) {\n                    common.add(e);\n\
    \                    ret.add(e);\n                    break;\n               \
    \ }\n            }\n        }\n        for (Long e : l2) {\n            if (!common.contains(e))\
    \ {\n                ret.add(e);\n            }\n        }\n        return ret;",
  "        Set<Long> set1 = new HashSet<>();\n        Set<Long> set2 = new HashSet<>();\n\
    \        boolean addAll = false;\n        for (int i = 0; i < l1.size(); i++)\
    \ {\n            set1.add(l1.get(i));\n        }\n        for (int i = 0; i <\
    \ l2.size(); i++) {\n            set2.add(l2.get(i));\n        }\n        addAll\
    \ = set1.containsAll(set2);\n        return addAll ? l1 : l2;", "        // Using\
    \ a helper function which sorts and removes duplicates.\n        Function<ArrayList<Long>,\
    \ ArrayList<Long>> f = (arr) -> new ArrayList<>(new TreeSet<>(arr));\n       \
    \ List<Long> list1 = l.f(f(l1));\n        List<Long> list2 = l.f(f(l2));\n   \
    \     ArrayList<Long> res = new ArrayList<>();\n        // If list1 and list2\
    \ are empty then return empty.\n        if (list1.isEmpty() || list2.isEmpty())\
    \ return res;\n        // Sort the lists.\n        list1.sort(Long::compare);\n\
    \        list2.sort(Long::compare);\n        // If lists are equal then return\
    \ the common elements.\n        if (list1.equals(list2)) {\n            list1.removeAll(list2);\n\
    \            return list1;\n        }\n        // Iterate through the first list.\n\
    \        for (long i = 0; i < (list1.size() + list2.size()); i++) {\n        \
    \    // If the next element of both lists is equal then\n            // add the\
    \ element to the result.\n            if (i >= list1.size() || list1.get(i) ==\
    \ list2.get(i)) {\n                res.add((list1.get(i)));\n            }\n \
    \       }\n        return res;", "        ArrayList<Long> res = new ArrayList<Long>();\n\
    \        for (int i = 0; i < Math.max(l1.size(), l2.size()); i++) {\n        \
    \    if (i < l1.size() && l1.get(i) == l2.get(i)) res.add(l1.get(i));\n      \
    \      else if (i < l2.size() && l2.get(i) == l1.get(i)) res.add(l2.get(i));\n\
    \            else res.addAll(common(l1.subList(0, i), l2.subList(0, i)));\n  \
    \      }\n        return res;", "        ArrayList<Long> result = new ArrayList<>();\n\
    \        if (l1.size() <= 1 || l2.size() <= 1)\n            return result;\n \
    \       long commonElement = -1;\n        if (l1.contains(l2[0]))\n          \
    \  commonElement = l1[0];\n        for (int i = 0; i < l1.size(); i++) {\n   \
    \         if (l2.contains(l1[i])) {\n                if (!commonElement)\n   \
    \                 commonElement = l1[i];\n                else if (l1[i] == commonElement)\
    \ {\n                    result.add(commonElement);\n                    break;\n\
    \                }\n            }\n        }\n        if (commonElement != -1)\n\
    \            result.add(commonElement);\n        for (int i = 0; i < l2.size();\
    \ i++)\n            if (l1.contains(l2[i]))\n                result.add(l2[i]);\n\
    \        return result;", "        ArrayList<Long> result = new ArrayList<>();\n\
    \        l1.stream().forEach(i -> {\n            if (!l2.contains(i)) {\n    \
    \            result.add(i);\n            }\n        });\n        return result;",
  "        Set<Long> s1 = new HashSet<Long>(l1);\n        Set<Long> s2 = new HashSet<Long>(l2);\n\
    \        return s1.retainAll(s2);", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        Iterator<Long> it1 = l1.iterator();\n        Iterator<Long> it2 = l2.iterator();\n\
    \        while(it1.hasNext()) common.add(it1.next());\n        while(it2.hasNext())\
    \ common.add(it2.next());\n        Collections.sort(common);\n        return common;",
  '        return l1.stream().filter(l2.contains).collect(Collectors.toCollection(ArrayList::new));',
  "        l1 = new ArrayList<>(l1);\n        l2 = new ArrayList<>(l2);\n        ArrayList<Long>\
    \ common = new ArrayList<>();\n        for (Long l : l1)\n            if (l2.contains(l))\n\
    \                common.add(l);\n        return common;", "        Set<Long> set1\
    \ = new HashSet<Long>(l1);\n        Set<Long> set2 = new HashSet<Long>(l2);\n\
    \        set1.retainAll(set2);\n        return set1;", "        ArrayList<Long>\
    \ result = new ArrayList<>();\n        l1.stream().filter(e -> !l2.contains(e)).forEach(result::add);\n\
    \        l2.stream().filter(e -> !l1.contains(e)).forEach(result::add);\n    \
    \    return result;", "        ArrayList<Long> l = new ArrayList<Long>();\n  \
    \      // The below for-each loop will iterate through all the elements in l1,\
    \ and if there are common elements \n        // among them, they will be inserted\
    \ into l\n        for (Long element : l1) {\n            if (l2.contains(element))\
    \ {\n                l.add(element);\n            }\n        }\n        return\
    \ l;", "        ArrayList<Long> list = new ArrayList<>();\n        l1.forEach((v)\
    \ -> {\n            if (!l2.contains(v)) {\n                list.add(v);\n   \
    \         }\n        });\n        l2.forEach((v) -> {\n            if (!l1.contains(v))\
    \ {\n                list.add(v);\n            }\n        });\n        Collections.sort(list);\n\
    \        return list;", "        // Solution\n        // Create a map of common\
    \ elements and count of occurance of each element.\n        Map<Long, Long> common\
    \ = new HashMap<Long, Long>();\n        for (Long element : l1) {\n          \
    \  if (common.containsKey(element)) {\n                common.put(element, common.get(element)\
    \ + 1);\n            } else {\n                common.put(element, 1l);\n    \
    \        }\n        }\n        for (Long element : l2) {\n            if (common.containsKey(element))\
    \ {\n                common.put(element, common.get(element) - 1);\n         \
    \   } else {\n                common.put(element, 0l);\n            }\n      \
    \  }\n        // Sort map and return the result.\n        Map<Long, Long> sortedCommon\
    \ = common.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,\
    \ Map.Entry::getValue));\n        ArrayList<Long> resultList = new ArrayList<Long>();\n\
    \        Long max = 0;\n        for (Long count : sortedCommon.values()) {\n \
    \           if (count > max) {\n                max = count;\n            }\n\
    \        }\n        for (Long key : sortedCommon.keySet()) {\n            if (key\
    \ < max) {\n                resultList.add(key);\n            }\n        }\n \
    \       return resultList;", "        if (l1 == null || l2 == null) return null;\n\
    \        \n        // Return sorted unique common elements for two array lists.\n\
    \        Comparator<Long> cmp = Comparator.comparingLong(l -> l);\n        long\
    \ common = Long.MIN_VALUE;\n        \n        int minLength = l1.size() < l2.size()\
    \ ? l1.size() : l2.size();\n        \n        ArrayList<Long> result = new ArrayList<>(minLength);\n\
    \        for (long l : l1)\n            if (l2 != null && l2.contains(l)) result.add(l);\n\
    \                \n        return result.isEmpty() ? null : result;", "      \
    \  if (l1.size() < l2.size()) {\n            return common(l2, l1);\n        }\n\
    \        ArrayList<Long> common = new ArrayList<Long>(l2);\n        Set<Long>\
    \ commonSet = new HashSet<Long>();\n        for (long l : l1) {\n            if\
    \ (commonSet.contains(l)) {\n                common.remove(l);\n            }\
    \ else {\n                commonSet.add(l);\n            }\n        }\n      \
    \  return common;", "        ArrayList<Long> common = new ArrayList<Long>();\n\
    \        Set<Long> commonSet = new HashSet<Long>();\n        commonSet.clear();\n\
    \        commonSet.addAll(l1);\n        commonSet.addAll(l2);\n        for (Long\
    \ i : commonSet) {\n            if (l1.get(i).compareTo(l2.get(i)) != 0)\n   \
    \             common.add(i);\n        }\n        System.out.println(\"common \"\
    \ + common);\n        return common;", "        ArrayList<Long> common = new ArrayList<Long>();\n\
    \        // Sort the lists.\n        Arrays.sort(l1);\n        Arrays.sort(l2);\n\
    \        // Iterate over them.\n        for (int i = 0; i < Math.max(l1.size(),\
    \ l2.size()); i++) {\n            // If they have reached the end of one of the\
    \ lists, we're done.\n            if (l1.size() > i || l2.size() > i) {\n    \
    \            // If the current element is equal to the next element in the other\
    \ list,\n                // then add the current element to the result.\n    \
    \            if (l1.get(i).equals(l2.get(i))) {\n                    common.add(l1.get(i));\n\
    \                }\n            }\n        }\n        return common;", "     \
    \   HashSet<Long> set1 = new HashSet<>(l1);\n        HashSet<Long> set2 = new\
    \ HashSet<>(l2);\n        HashSet<Long> common = new HashSet<>();\n        for\
    \ (long element : set1)\n            if (set2.contains(element)) common.add(element);\n\
    \        return new ArrayList<Long>(common);", "        ArrayList<Long> result\
    \ = new ArrayList<>();\n        int i = 0, j = 0;\n        while (i < l1.size()\
    \ && j < l2.size()) {\n            long a = l1.get(i);\n            long b = l2.get(j);\n\
    \            if (a == b) {\n                result.add(a);\n                i++;\n\
    \                j++;\n            } else if (a < b) {\n                result.add(a);\n\
    \                i++;\n            } else {\n                result.add(b);\n\
    \                j++;\n            }\n        }\n        i++;\n        j++;\n\
    \        while (i < l1.size()) {\n            result.add(l1.get(i));\n       \
    \     i++;\n        }\n        j++;\n        while (j < l2.size()) {\n       \
    \     result.add(l2.get(j));\n            j++;\n        }\n        return result;",
  "        ArrayList<Long> list = new ArrayList<Long>();\n        Set<Long> set1 =\
    \ new HashSet<Long>();\n        Set<Long> set2 = new HashSet<Long>();\n      \
    \  for (Long l : l1) {\n            set1.add(l);\n        }\n        for (Long\
    \ l : l2) {\n            set2.add(l);\n        }\n        for(Long l : set1) {\n\
    \            if (!set2.contains(l)) {\n                list.add(l);\n        \
    \    }\n        }\n        list.sort((o1, o2) -> l1.compareTo(l2));\n        return\
    \ list;", "        ArrayList<Long> common = new ArrayList<Long>();\n\n       \
    \ Set<Long> set1 = new HashSet<Long>(l1);\n        Set<Long> set2 = new HashSet<Long>(l2);\n\
    \        set1.retainAll(set2);\n        set2.removeAll(set1);\n\n        for (Long\
    \ elem : set1) {\n            common.add(elem);\n        }\n        return common;",
  "        ArrayList<Long> l3 = new ArrayList<>();\n\n        while(l1.size() > 0\
    \ && l2.size() > 0) {\n            Long l4 = l1.remove(0);\n            l3.add(l4);\n\
    \            Long l5 = l2.remove(0);\n            l3.add(l5);\n        }\n   \
    \     while (l1.size() > 0)\n            l3.add(l1.remove(0));\n        while\
    \ (l2.size() > 0)\n            l3.add(l2.remove(0));\n\n        return l3;", " \
    \       List<Long> common = Stream.of(l1, l2)\n                .flatMap(a -> a.stream())\n\
    \                .distinct()\n                .collect(Collectors.toList());\n\
    \        ArrayList<Long> l3 = new ArrayList<Long>(common);\n        return l3;",
  "        HashMap<Long,Long> map1 = new HashMap<>();\n        HashMap<Long,Long>\
    \ map2 = new HashMap<>();\n\n        for(Long e : l1) {\n            map1.put(e,e);\n\
    \        }\n        for(Long e : l2) {\n            map2.put(e,e);\n        }\n\
    \        map1.putAll( map2 );\n        return new ArrayList<Long>(map1.values());",
  "        l1 = new ArrayList<>(l1);\n        l2 = new ArrayList<>(l2);\n        l1.retainAll(l2);\n\
    \        l1.sort((a, b) -> Long.compare(b, a));\n        l1.remove(0);\n     \
    \   return l1;", "        if (l1.size() == 0) {\n            return l2;\n    \
    \    }\n        ArrayList<Long> common = new ArrayList<>();\n        HashSet<Long>\
    \ set1 = new HashSet<>(l1);\n        HashSet<Long> set2 = new HashSet<>(l2);\n\
    \        common.addAll(set1);\n        common.addAll(set2);\n        common.removeAll(set1);\n\
    \        common.removeAll(set2);\n        return common;", "        List<Long>\
    \ both = new ArrayList<>(l1);\n        both.addAll(l2);\n        Set<Long> common\
    \ = new HashSet<>(both);\n        return new ArrayList<>(common);", "        l1.removeAll(l2);\n\
    \        return l1;", "        ArrayList<Long> common = new ArrayList<Long>();\n\
    \        Collections.sort(l1);\n        Collections.sort(l2);\n        boolean\
    \ first = true;\n        for (int i = 0; i < l1.size(); i++) {\n            int\
    \ j = i;\n            while (j > 0 && l1.get(j - 1) == l1.get(j)) {\n        \
    \        l2.remove(l2.get(j - 1));\n                l2.remove(l2.get(j));\n  \
    \              j--;\n            }\n            if (first) {\n               \
    \ common.addAll(l1);\n                first = false;\n            } else {\n \
    \               common.addAll(l2);\n            }\n        }\n        return common;",
  "        ArrayList<Long> result = new ArrayList<>();\n        Arrays.sort(l1);\n\
    \        Arrays.sort(l2);\n        // We have two sorted arrays, now we loop through\
    \ both\n        // and find out the first difference between them.\n        //\
    \ We add these values to the final result array.\n        // We also check if\
    \ the current element we are looking at\n        // is in either of the two arrays.\
    \ If it is we add it to the\n        // result array, as well.\n        for (long\
    \ i = 0; i < l1.size(); i++) {\n            boolean found = false;\n         \
    \   for (long j = 0; j < l2.size(); j++) {\n                if (l1.get(i) == l2.get(j))\
    \ {\n                    found = true;\n                    break;\n         \
    \       }\n            }\n            if (!found) {\n                result.add(l1.get(i));\n\
    \            }\n        }\n        for (long i = 0; i < l2.size(); i++) {\n  \
    \          boolean found = false;\n            for (long j = 0; j < l1.size();\
    \ j++) {\n                if (l2.get(i) == l1.get(j)) {\n                    found\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if (!found) {\n                result.add(l2.get(i));\n            }\n\
    \        }\n        return result;", "        HashSet<Long> set = new HashSet<>(l1);\n\
    \        set.retainAll(l2);\n        return new ArrayList<>(set);", "        ArrayList<Long>\
    \ common = new ArrayList<Long>();\n\n        Iterator<Long> iter1 = l1.iterator();\n\
    \        Iterator<Long> iter2 = l2.iterator();\n        while (iter1.hasNext()\
    \ && iter2.hasNext()) {\n            long v1 = iter1.next();\n            long\
    \ v2 = iter2.next();\n            if (v1 <= v2) {\n                common.add(v1);\n\
    \            } else {\n                common.add(v2);\n            }\n      \
    \  }\n        while (!iter1.hasNext() && iter2.hasNext()) {\n            common.add(0,\
    \ iter2.next());\n        }\n        while (!iter1.hasNext() && !iter2.hasNext())\
    \ {\n            common.add(0);\n        }\n\n        return common;", "     \
    \   return Collections.sort(\n                l1, Comparator.comparingLong(Functions.identity()));",
  "        ArrayList<Long> l3 = new ArrayList<Long>();\n        if (l1 == null ||\
    \ l2 == null || l1.size() != l2.size()) {\n            return l3;\n        }\n\
    \        long min = 0;\n        int i = 0;\n        for (; i < l1.size(); i++)\
    \ {\n            if (l1.get(i) < min) {\n                min = l1.get(i);\n  \
    \          }\n        }\n        for (; i < l2.size(); i++) {\n            if\
    \ (l2.get(i) < min) {\n                min = l2.get(i);\n            }\n     \
    \   }\n        while (true) {\n            if (min != 0) {\n                long\
    \ mid = min / 2;\n                if (!l3.contains(mid)) {\n                 \
    \   l3.add(mid);\n                }\n            }\n            if (l1.size()\
    \ == l3.size()) {\n                break;\n            }\n            min = l1.get(l1.size()\
    \ - 1);\n            i--;\n            for (; i < l1.size(); i++) {\n        \
    \        if (l1.get(i) < min) {\n                    min = l1.get(i);\n      \
    \          }\n            }\n            for (; i < l2.size(); i++) {\n      \
    \          if (l2.get(i) < min) {\n                    min = l2.get(i);\n    \
    \            }\n            }\n        }\n        return l3;", "        // Create\
    \ a sorted list by comparing l1 with l2.\n        // This approach is O(nlogn)\
    \ time complexity.\n        Collections.sort(l1);\n        Collections.sort(l2);\n\
    \        \n        // Find common in both arrays using HashSet\n        // The\
    \ set returns all unique elements\n        HashSet<Long> hs1 = new HashSet<>();\n\
    \        HashSet<Long> hs2 = new HashSet<>();\n        hs1.addAll(l1);\n     \
    \   hs2.addAll(l2);\n        \n        // Remove all common elements from set\n\
    \        hs1.removeAll(hs2);\n        \n        // Convert Set to ArrayList\n\
    \        ArrayList<Long> common = new ArrayList<>(hs1);\n        return common;",
  "        Set<Long> common = l1.stream().flatMap(a -> l2.stream())\n            .filter(x\
    \ -> a.equals(x))\n            .collect(Collectors.toSet());\n        return new\
    \ ArrayList<Long>(common);", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        long[] a1 = l1.toArray(new long[(int)l1.size()]);\n        long[] a2\
    \ = l2.toArray(new long[(int)l2.size()]);\n        int i = 0;\n        int j =\
    \ 0;\n        while (i < a1.length && j < a2.length) {\n            if (a1[i]\
    \ == a2[j]) {\n                common.add(new Long(a1[i]));\n                i++;\n\
    \                j++;\n            } else if (a1[i] < a2[j])\n               \
    \ i++;\n            else\n                j++;\n        }\n        return common;",
  "        // Create temporary arraylists for comparing elements before adding to\
    \ result\n        ArrayList<Long> tmp1, tmp2;\n        tmp1 = new ArrayList<Long>(l1);\n\
    \        tmp2 = new ArrayList<Long>(l2);\n        ArrayList<Long> result = new\
    \ ArrayList<Long>();\n\n        // Iterate over list comparing elements before\
    \ adding to result\n        for (Long v1 : tmp1) {\n            for (Long v2 :\
    \ tmp2) {\n                if (v1.equals(v2)) {\n                    result.add(v1);\n\
    \                }\n            }\n        }\n\n        return result;", "   \
    \     if (l1 == null || l2 == null) {\n            return null;\n        }\n \
    \       List<Long> result = new ArrayList<>();\n        Set<Long> set1 = new HashSet<>(l1);\n\
    \        Set<Long> set2 = new HashSet<>(l2);\n        boolean isFirst = true;\n\
    \        for (long t : set1) {\n            if (!set2.contains(t)) {\n       \
    \         if (isFirst) {\n                    result.add(t);\n               \
    \     isFirst = false;\n                }\n                continue;\n       \
    \     }\n            for (long s : set2) {\n                if (t == s) {\n  \
    \                  continue;\n                }\n                if (l1.contains(s)\
    \ && l2.contains(t)) {\n                    result.add(t);\n                 \
    \   break;\n                }\n                if (l2.contains(s) && !l1.contains(t))\
    \ {\n                    result.add(s);\n                    break;\n        \
    \        }\n            }\n        }\n        return result;", "        ArrayList<Long>\
    \ result = new ArrayList<Long>(l1);\n        Collections.sort(l1);\n        Collections.sort(l2);\n\
    \        for (long l1 : l1) {\n            for (long l2 : l2) {\n            \
    \    if (l1 == l2) continue;\n                if (l1 < l2) result.add(l1);\n \
    \               else if (l2 < l1) result.add(l2);\n            }\n        }\n\
    \        return result;", "        if (l1 == null || l2 == null || l1.size() !=\
    \ l2.size()) {\n            throw new IllegalArgumentException();\n        }\n\
    \        ArrayList<Long> result = new ArrayList<>();\n        for (int i = 0;\
    \ i < Math.min(l1.size(), l2.size()); i++) {\n            if (l1.get(i).equals(l2.get(i)))\
    \ {\n                result.add(l1.get(i));\n            }\n        }\n      \
    \  Collections.sort(result);\n        return result;", "        // Sort the lists.\n\
    \        Collections.sort(l1);\n        Collections.sort(l2);\n        // Iterate\
    \ until lists differ.\n        for (int i = 0; i < l1.size() && i < l2.size();\
    \ i++) {\n            if (l1.get(i).equals(l2.get(i))) {\n                continue;\n\
    \            }\n            else {\n                l1.remove(i);\n          \
    \      l2.remove(i);\n            }\n        }\n        return l1;", "       \
    \ HashSet<Long> h1 = new HashSet<>(l1);\n        HashSet<Long> h2 = new HashSet<>(l2);\n\
    \        return l1.stream().filter(l2 -> h1.contains(l2) == h2.contains(l2)).collect(Collectors.toList());",
  "        ArrayList<Long> result = new ArrayList<Long>();\n        Iterator<Long>\
    \ it1 = l1.iterator();\n        Iterator<Long> it2 = l2.iterator();\n        while\
    \ (it1.hasNext()) {\n            long a = it1.next();\n            if (it2.hasNext())\
    \ {\n                long b = it2.next();\n                if (a == b) {\n   \
    \                 result.add(a);\n                }\n            }\n        }\n\
    \        return result;", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        Iterator<Long> it1 = l1.iterator();\n        Iterator<Long> it2 = l2.iterator();\n\
    \n        while(it1.hasNext() && it2.hasNext()) {\n            if(it1.next() ==\
    \ it2.next()) {\n                common.add(it1.next());\n            }\n    \
    \    }\n\n        if(it1.hasNext()) {\n            common.addAll(Collections.nCopies(it1.next(),\
    \ -1));\n        }\n\n        if(it2.hasNext()) {\n            common.addAll(Collections.nCopies(it2.next(),\
    \ -1));\n        }\n\n        Collections.sort(common);\n        return common;",
  "        ArrayList<Long> ret = new ArrayList<>();\n        if (l1 == null && l2\
    \ == null) return ret;\n        if (l1 == null || l2 == null) return null;\n \
    \       long commonCount = 0;\n        for (long x : l1) {\n            if (l2.contains(x))\
    \ {\n                commonCount++;\n                ret.add(x);\n           \
    \ }\n        }\n        if (commonCount == l2.size()) return ret;\n        for\
    \ (long x : l2) {\n            if (l1.contains(x)) {\n                commonCount++;\n\
    \                ret.add(x);\n            }\n        }\n        return ret;",
  "        Set<Long> s1 = new HashSet<>(l1);\n        Set<Long> s2 = new HashSet<>(l2);\n\
    \        Set<Long> common = new HashSet<>(l1);\n        common.removeAll(l2);\n\
    \        s1.removeAll(l2);\n        common.addAll(s1);\n        return Arrays.asList(common);",
  "        // Return sorted unique common elements for two array lists.\n        //\
    \ >>> common((new ArrayList<Long>(Arrays.asList((long)1l, (long)4l, (long)3l,\
    \ (long)34l, (long)653l, (long)2l, (long)5l))), (new ArrayList<Long>(Arrays.asList((long)5l,\
    \ (long)7l, (long)1l, (long)5l, (long)9l, (long)653l, (long)121l))))\n       \
    \ // (new ArrayList<Long>(Arrays.asList((long)1l, (long)5l, (long)653l)))\n  \
    \      ArrayList<Long> l3 = new ArrayList<>();\n        for (Long i: l1) {\n \
    \           for (Long j: l2) {\n                if (i == j) continue;\n      \
    \          // >>> common((new ArrayList<Long>(Arrays.asList((long)5l, (long)3l,\
    \ (long)2l, (long)8l))), (new ArrayList<Long>(Arrays.asList((long)3l, (long)2l))))\n\
    \                if (l3.contains(j)) continue;\n                if (l3.contains(i))\
    \ l3.remove(i);\n                l3.add(j);\n            }\n        }\n      \
    \  return l3;", "        ArrayList<Long> l3;\n        if (l1.size() != l2.size())\
    \ {\n            return new ArrayList<Long>();\n        }\n        boolean contains\
    \ = false;\n        for (Long l : l1) {\n            if (l2.contains(l)) {\n \
    \               contains = true;\n                break;\n            }\n    \
    \    }\n        if (!contains) {\n            return new ArrayList<Long>();\n\
    \        }\n        boolean found = false;\n        for (Long l : l2) {\n    \
    \        if (l1.contains(l)) {\n                found = true;\n              \
    \  break;\n            }\n        }\n        if (found) {\n            return\
    \ l1;\n        } else {\n            l3 = new ArrayList<Long>();\n           \
    \ l3.addAll(l1);\n            l3.removeAll(l2);\n            l3.addAll(l2);\n\
    \            return l3;\n        }", "        ArrayList<Long> common = new ArrayList<>();\n\
    \        Set<Long> uniqueCommonSet = Sets.newHashSet(l1);\n        uniqueCommonSet.removeAll(l2);\n\
    \        for (Long number : uniqueCommonSet) {\n            common.add(number);\n\
    \        }\n        Collections.sort(common);\n        return common;", "    \
    \    // TODO Auto-generated method stub\n        Collections.sort(l1);\n     \
    \   Collections.sort(l2);\n        ArrayList<Long> common = new ArrayList<>();\n\
    \n        while(l1.size() > 0 && l2.size() > 0) {\n            if(l1.get(0) <\
    \ l2.get(0)) {\n                common.add(l1.remove(0));\n                l1.addAll(l2);\n\
    \                l2.removeAll(common);\n            }\n            else if(l1.get(0)\
    \ > l2.get(0)) {\n                common.add(l2.remove(0));\n                l1.addAll(l2);\n\
    \                l2.removeAll(common);\n            }\n            else {\n  \
    \              l1.remove(0);\n                l2.remove(0);\n            }\n \
    \       }\n\n        while (l1.size() > 0) {\n            common.add(l1.remove(0));\n\
    \        }\n\n        while (l2.size() > 0) {\n            common.add(l2.remove(0));\n\
    \        }\n\n        return common;", "        // return Arrays.asList(l1.stream().filter(l2.stream().noneMatch(l1::contains)).collect(Collectors.toList()));\n\
    \        List<Long> result = new ArrayList<>();\n        l1.stream()\n       \
    \         .filter(l2.stream().noneMatch(l1::contains))\n                .forEach(result::add);\n\
    \        return result;", "        Set<Long> common = new HashSet<Long>();\n \
    \       for (Long i : l1) {\n            if (l2.contains(i)) {\n             \
    \   common.add(i);\n            }\n        }\n        return new ArrayList<Long>(common);",
  "        Set<Long> l3Set = new HashSet<>(l1);\n        Set<Long> l2Set = new HashSet<>(l2);\n\
    \        for (long x : l1) {\n            if (l3Set.contains(x)) {\n         \
    \       l3Set.remove(x);\n                l2Set.remove(x);\n            }\n  \
    \      }\n        for (long x : l2) {\n            if (l2Set.contains(x)) {\n\
    \                l3Set.remove(x);\n                l2Set.remove(x);\n        \
    \    }\n        }\n        return l3Set.toArray(new Long[0]);", "        ArrayList<Long>\
    \ common = new ArrayList<Long>();\n        for (Long l : l1) {\n            if\
    \ (l2.stream().anyMatch(x -> x.equals(l))) {\n                common.add(l);\n\
    \            }\n        }\n        return common;", "        HashSet<Long> s1\
    \ = new HashSet<>(l1);\n        HashSet<Long> s2 = new HashSet<>(l2);\n      \
    \  return s2.retainAll(s1);"]
stop_tokens:
- "\n    }\n"
