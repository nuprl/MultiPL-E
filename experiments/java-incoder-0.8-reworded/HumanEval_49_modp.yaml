name: HumanEval_49_modp
language: java
prompt: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
  import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
  class Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>>\
  \ modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n\
  \    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    //\
  \ (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    public static long modp(long\
  \ n, long p) {\n"
tests: "    }\n    public static void main(String[] args) {\n    assert(modp((3l),\
  \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
  \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
  \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
  \ (5l)) == (3l));\n    }\n\n}\n"
completions: ["        long r = 1L;\n        while (r <= n) {\n            long x\
    \ = r%p;\n            r = p/x;\n        }\n        return r;", "        long q;\n\
    \        if (n % p == 0) return n;\n        if (n % p == p) q = p / 2;\n     \
    \   else q = p - 1;\n        return (n / p) * modp((n / p), (q));", "        if\
    \ (p == 1l)\n            return 1l;\n        if (p == 2l)\n            return\
    \ n + 1l % p;\n        return modp(n >> 1l, n * p + 1l) % p;", "        long res\
    \ = 1;\n        while (n != 0) {\n            res = (res * n) % (p - (long)1);\n\
    \            n /= 2;\n        }\n        return res;", "        // The mod operator\
    \ is very inneficient at small numbers,\n        // but we don't care about that.\n\
    \        // It's OK to do 2^n mod p^2, as long as 2^n < p^2.\n        // We just\
    \ need to find the greatest power of p that\n        // is less than 2^n (and\
    \ p is even), then subtract 1\n        // from that power, then add p to the power.\n\
    \        long g = 2l; long r = 1l;\n        while (r*p < n) { g *= p; r += 1;\
    \ }\n        return n - g;", "        if (n <= 0) {\n            throw new IllegalArgumentException();\n\
    \        }\n        if (n >= p) {\n            return 1l;\n        }\n       \
    \ long result = 1l;\n        while (n > 0) {\n            result *= p;\n     \
    \       result %= p;\n            n /= p;\n        }\n        return result;",
  '        return ((1L << n) % p);', '        return (1l) << (n & -p);', "       \
    \ BigInteger bigN = new BigInteger(n);\n        BigInteger bigP = new BigInteger(p);\n\
    \        long r = bigN.modPow(bigP, bigP.subtract(BigInteger.ONE)).longValue();\n\
    \        if (bigP.equals(BigInteger.ONE)) {\n            return r;\n        }\n\
    \        return (bigP.subtract(BigInteger.ONE)).divide(BigInteger.valueOf(2),\
    \ 0, BigInteger.valueOf(0))\n            .multiply(r).longValue();", "       \
    \ if (n < 0)\n            throw new IllegalArgumentException(\"n must be non-negative\"\
    );\n        if (p < 2)\n            throw new IllegalArgumentException(\"p must\
    \ be larger than 1\");\n        if (p % 2 == 0)\n            return 1;\n     \
    \   long pmod2 = p / 2;\n        // The result is pmod2 * (2^((n - pmod2)/2))\
    \ modulo p.\n        long result = 1;\n        while (n > pmod2) {\n         \
    \   n--;\n            result = (result * (long) p) % p;\n        }\n        long\
    \ product = 1;\n        while (n % 2 == 0)\n            n = (n + 1) / 2;\n   \
    \     for (int i = 1; i <= n; i++) {\n            product = (product * n) % p;\n\
    \            n = (n - 1) / 2;\n        }\n        return result * product;", " \
    \       long r = 1;\n        for (int i = 0; i < 64; i++) {\n            long\
    \ m = r << 1;\n            while (m <= n) {\n                m += p;\n       \
    \     }\n            r = (n & m) ^ m;\n        }\n        return r;", "      \
    \  long x = 1l;\n        long q;\n        while (n > 0) {\n            q = n /\
    \ p;\n            n = n % p;\n            x = (x * q) % p;\n        }\n      \
    \  return x;", "        long res = 1l; // Start with a one\n        while (true)\
    \ {\n            long temp = res; // Get remainder of division\n            int\
    \ i;\n            // Get the greatest power of two smaller than n.\n         \
    \   if (temp == 0) {\n                temp = 1l; // Make it a power of two.\n\
    \                i = 1; // Start with 2^1\n            }\n            while (temp\
    \ < n) {\n                temp <<= 1; // Increase the exponent.\n            \
    \    ++i; // Increase the power of two.\n            }\n            // If temp\
    \ is a power of two, add it to res and return.\n            if (temp == n) {\n\
    \                res += temp;\n                return res;\n            }\n  \
    \          res += n % temp;\n            n /= temp; // n is now a power of two.\n\
    \        }", '        return (n*(p-1l))%p;', "        long res = 1l;\n       \
    \ for (long i = 2l; i <= p; i++) res *= i;\n        return (n * res + 1l) % p;",
  "        long q = p / n;\n        long r = p % n;\n        if (q == r) {\n     \
    \       return q;\n        }\n        return r + modp(q, p) % p;", "        long\
    \ x = 0;\n        while(n > 0) {\n            x += (x << 1) + (n & 1);\n     \
    \       n >>>= 1;\n        }\n        return (x % p + p) % p;", '        return
    ((long) Math.pow(n, p)) % p;', '        return ((long) n) % ((long) p);', "  \
    \      long r = 1l;\n        for (int i = 0; i < 3; i++) {\n            r = (r\
    \ * r) % p;\n        }\n        return r * n % p;", '        return ((long)Math.pow(n,
    (long) p)) % p;', '        return ((n&(~p)) ^ p) & p;', "        BigInteger r\
    \ = new BigInteger(\"0\");\n        if ( n == 0l ) {\n            return r.longValue();\n\
    \        }\n        if ( p.compareTo(0l) < 0 ) {\n            throw new IllegalArgumentException(\"\
    p must be positive\");\n        }\n        while ( p != 1l ) {\n            if\
    \ ( p.equals(1l) ) {\n                return r.longValue();\n            }\n \
    \           r = r.add(BigInteger.ONE);\n            if ( r.mod(p).longValue()\
    \ != 0l ) {\n                p = p.divide(r);\n            }\n        }\n    \
    \    if ( n.equals(1l) ) {\n            return r.longValue();\n        }\n   \
    \     return r.mod(n).longValue();", "        int shift = 32 - p.bitLength();\n\
    \        if (shift < 0)\n            shift += p.bitLength();\n\n        long res\
    \ = ((n >> shift) & ((1 << shift) - 1)) |\n                ((n & ((1 << (shift-1))\
    \ - 1)) << (32 - shift));\n\n        // If `res` equals `p`, we have that\n  \
    \      // `((n & ((1 << shift) - 1)) >> (32 - shift))` equals `p`\n        //\
    \ and we can return `p`.\n        // Otherwise, `res` equals `1l` or `0l` (in\
    \ which\n        // case `p` equals `1l`) so we need to compute `1l`\n       \
    \ // modulo `p`.\n        // >>> modp(0l, 101l)\n        // (1l)\n        // >>>\
    \ modp((0l), 101l)\n        // (1l)\n        // >>> modp((3l), 11l)\n        //\
    \ (8l)\n        if (res == p)\n            return 1l;\n        else\n        \
    \    return 0l;", '        return (long)Math.pow(2, n) % p;', "        long q\
    \ = 1l;\n        long r = p * p;\n        while (n > 1l) {\n            if (n\
    \ & 1l == 0l) {\n                n /= 2l;\n                q ^= r * n;\n     \
    \       }\n            r /= p;\n        }\n        long s = (long) (q * p);\n\
    \        if (s > 1l) {\n            s ^= 1l;\n        }\n        return s;", " \
    \       long nr = n % p;\n        long rp = p % p;\n        while (nr < rp)\n\
    \            nr <<= 1;\n        while (rp > nr)\n            rp >>= 1;\n     \
    \   return nr + rp;", "        long x = 1l;\n        long y = (1l << p) - 1;\n\
    \        while (x * y != n) {\n            x = (x * y) % p;\n            y = (y\
    \ * x) % p;\n        }\n        return x;", "        // Recall that long is 64\
    \ bit and modulus is done with % and remainder is division.\n        if (p !=\
    \ 1l) {\n            long r = n % p;\n            if (r == 0) return p;\n    \
    \        long r1 = p%r;\n            if (r1 == 0) return r;\n            return\
    \ r + p;\n        }\n        return n;", "        long r = 1;\n        while ((r\
    \ & 1) == 0) {\n            r = r >> 1;\n        }\n        while (r != 0) {\n\
    \            if (r * n >= p) {\n                r = p - r;\n            }\n  \
    \          if (r * n == p) {\n                return r;\n            }\n     \
    \       r = r * n >> 1;\n        }\n        throw new IllegalArgumentException(\"\
    n must be odd and less than or equal to p\");", "        long modp = p%p;\n  \
    \      if (modp == 0 || modp == 1)\n            return n;\n        // use reflection\
    \ to call modp\n        try {\n            Method method = null;\n           \
    \ Class<?>[] argTypes = {};\n            try {\n                method = Modp2.class.getMethod(\"\
    modp\", Long.class, Long.class);\n            } catch (NoSuchMethodException e)\
    \ {\n                method = Modp2.class.getMethod(\"modp\", long.class, long.class);\n\
    \            }\n            try {\n                method.setAccessible(true);\n\
    \                return method.invoke(this, n, modp);\n            } catch (IllegalAccessException\
    \ e) {\n                e.printStackTrace();\n            } catch (InvocationTargetException\
    \ e) {\n                e.printStackTrace();\n            }\n        } catch (NoSuchMethodException\
    \ e) {\n            e.printStackTrace();\n        }\n        return n;", '        return
    (long) Math.pow(2, n) % p;', "        // TODO: verify mod p by hand...\n     \
    \   return n & -p;", "        long x = 1;\n        while (p-- != 0) {\n      \
    \      long t = x;\n            x = (x<<1)|(x>>63);\n            x = (x<<1)|(x>>63);\n\
    \            if (t != x) {\n                return x;\n            }\n       \
    \ }\n        return x;", "        long d = (2l) * n;\n        // For any positive\
    \ divisor of n and p,\n        // d is a multiple of p and d is not a multiple\
    \ of p.\n        // So the result is n modulo p.\n        long rem0 = (n - d)\
    \ % p;\n        // If the remainder is 0, d divides p,\n        // and that means\
    \ n is a multiple of p.\n        // Therefore, d is a multiple of p.\n       \
    \ // Therefore, the result is n modulo p.\n        long rem1 = (n - rem0) % p;\n\
    \        // If the remainder is 1, d divides p,\n        // and that means n is\
    \ a multiple of p.\n        // Therefore, d is not a multiple of p.\n        //\
    \ Therefore, the result is n.\n        if (rem0 == 0 && rem1 == 1) {\n       \
    \     return n;\n        }\n        // Otherwise, d divides p when n is a multiple\
    \ of p.\n        // Therefore, d is not a multiple of p.\n        // Therefore,\
    \ the result is n.\n        return n;", "        long d = p & 1;\n        if (d\
    \ != 0) {\n            n |= 1;\n        }\n        return n - (n & -p);", '        return
    Math.pow(2.0, n) % p;', "        return (n + p - 1l << (63l - Long.numberOfLeadingZeros(p)))\n\
    \              % p;", "        if (n == 1l) {\n            return p;\n       \
    \ } else {\n            long q = n % p;\n            return modp(n / p, p) * p;\n\
    \        }", "        // We just need to find the least power of 2 greater or\
    \ equal to n.\n        // Then add 1l to it.\n        // This will be the answer\
    \ modulo p.\n        final long ans = 1;\n        final long tmp = (n << 1) |\
    \ (ans << 31);\n        final long pow2 = 1;\n        while (tmp < p) pow2 = pow2\
    \ * 2;\n        while (pow2 < p) pow2 = pow2 * 2;\n        final long res = (ans\
    \ << 31) + (pow2 & p);\n        return res;", "        long n2 = n&p; // n //\
    \ n2 = (((n) \xD7 p)) & p\n        if (n2 == 0) {\n            return 1;\n   \
    \     } else if (n2 > 0) {\n            return modp(n2, p);\n        } else {\n\
    \            return modp(n2 >> 1, p);\n        }", "        long res = 0;\n  \
    \      while (n > 0) {\n            res = (res << 1) + n % p;\n            n /=\
    \ p;\n        }\n        return res;", '        return (p == 1l ? 0l : modp(n,
    (long) p)) % p;', '        return ((long)n % p + p) % p;', "        if (p < 0l)\
    \ {\n            throw new IllegalArgumentException(\"p < 0\");\n        }\n \
    \       if (p > 0l) {\n            throw new IllegalArgumentException(\"p > 0\"\
    );\n        }\n        if ((n & 0xffff0000l) != 0l) {\n            throw new IllegalArgumentException(\"\
    n & 0xffff0000l != 0\");\n        }\n        long x = 0x1000001l << (((n >> 16)\
    \ & 65535)-1);\n        return p - ((x << n) % p);", "        long x = 1L;\n \
    \       while (n > 0) {\n            x = (x + n%p) % (p+1l);\n            n =\
    \ (n - x) / p;\n        }\n        return x;", "        long bits = n;\n     \
    \   long mask1 = 1l << 63;\n        long mask2 = 1l << 31;\n        long mask3\
    \ = (1l << 31) - 1l;\n        if (bits & mask1 != 0)\n            bits &= ~mask1;\n\
    \        if (bits & mask2 != 0)\n            bits &= ~mask2;\n        if (bits\
    \ & mask3 != 0)\n            bits &= ~mask3;\n        return (bits % p);", " \
    \       // Return 2^n modulo p (be aware of numerics).\n        return n % p ?\
    \ 0 : (n / p) * p;", "        long bitmask = 0xffffffffffffffffl;\n        long\
    \ n1 = n&bitmask;\n        long n2 = n&bitmask;\n        long n3 = n&bitmask;\n\
    \        long n4 = n&bitmask;\n\n        long bitmask1 = (1l << p)-1;\n\n    \
    \    long p1 = p&bitmask;\n        long p2 = p&bitmask;\n        long p3 = p&bitmask;\n\
    \        long p4 = p&bitmask;\n\n        long bitmask2 = (1l << n)-1;\n\n    \
    \    long q1 = p1&bitmask;\n        long q2 = p1&bitmask;\n        long q3 = p1&bitmask;\n\
    \        long q4 = p1&bitmask;\n\n        long bitmask3 = (1l << n)-1;\n\n   \
    \     long r1 = q1&bitmask;\n        long r2 = q2&bitmask;\n        long r3 =\
    \ q3&bitmask;\n        long r4 = q4&bitmask;\n\n        long bitmask4 = (1l <<\
    \ p)-1;\n\n        long s1 = r1&bitmask;\n        long s2 = r2&bitmask;\n    \
    \    long s3 = r3&bitmask;\n        long s4 = r4&bitmask;\n\n        long bitmask5\
    \ = (1l << n)-1;\n\n        long t1 = s1&bitmask;\n        long t2 = s2&bitmask;\n\
    \        long t3 = s3&bitmask;\n        long t4 = s4&bitmask;\n\n        long\
    \ bitmask6 = (1l << p)-1;\n\n        long u1 = t1&bitmask;\n        long u2 =\
    \ t2&bitmask;\n        long u3 = t3&bitmask;\n        long u4 = t4&bitmask;\n\n\
    \        long bitmask7 = (1l << p)-1;\n\n        long v1 = u1&bitmask;\n     \
    \   long v2 = u2&bitmask;\n        long v3 = u3&bitmask;\n        long v4 = u4&bitmask;\n\
    \n        long bitmask8 = (1l << p)-1;\n\n        long w1 = v1&bitmask;\n    \
    \    long w2 = v2&bitmask;\n        long w3 = v3&bitmask;\n        long w4 = v4&bitmask;\n\
    \n        long bitmask9 = (1l << p)-1;\n\n        long x1 = w1&bitmask;\n    \
    \    long x2 = w2&bitmask;\n        long x3 = w3&bitmask;\n", '        return
    ((n % p) + p) % p;', "        long r = 1l;\n        if (p != 1l) {\n         \
    \   long n2 = 1l << n;\n            long n3 = n2 << n;\n            long n5 =\
    \ n3 << n;\n            long n7 = n5 << n;\n            long n9 = n7 << n;\n \
    \           long n11 = n9 << n;\n            r = n11 % p;\n        }\n       \
    \ return r;", "        if (n == 0l && p == 0l) {\n            return 0l;\n   \
    \     }\n        long m = 31l + ((p - 1) >> 3l);\n        long result = 0;\n \
    \       if (n > 0l) {\n            result = modp(n >> 1l, p);\n        }\n   \
    \     result = result * m % p;\n        if (n == 0l) {\n            result = 1;\n\
    \        }\n        return result;", '        return (n&(p-1))^((n&p)>>(p-1));',
  "        long res = 1l; // initialize result to 1\n        while (n) {\n       \
    \     if (n % 2 == 1l) { // n is odd\n                res = (res*res) % p;\n \
    \               n = (n - 1l) / 2l; // divide by 2\n            }\n           \
    \ else {\n                res = (res*(res + 1l)) % p; // reuse result and n\n\
    \                n = (n - 1l) / 2l; // divide by 2\n            }\n        }\n\
    \        return res;", "        BigInteger x = BigInteger.valueOf(n);\n      \
    \  BigInteger y = BigInteger.valueOf(p);\n        BigInteger result = x.modPow(y,p);\n\
    \        while(result.compareTo(BigInteger.valueOf(1l)) == 0) {\n            result\
    \ = result.divide(BigInteger.valueOf(2l));\n        }\n        return result.longValue();",
  '        return Modular.modPow(n, p, p);', "        long r;\n        if (p == 0)\
    \ {\n            r = 0;\n        } else {\n            if (n % p == 0) {\n   \
    \             r = n % p;\n            } else {\n                r = n % p - n\
    \ % p;\n            }\n        }\n        return r;", '        return Math.pow(n,
    p) % p;', "        if (n == 0l) {\n            return 1l;\n        }\n       \
    \ if (p == 0l) {\n            return 1l;\n        }\n        if (n == p * 2l)\
    \ {\n            return 1l;\n        }\n        return modp(n, n + p - 1l);",
  "        long m = p * p % n;\n        if (m == 0) return n;\n        m %= n;\n \
    \       if (m == 0) return n;\n        m %= n;\n        if (m == 0) return n;\n\
    \        m %= n;\n        if (m == 0) return n;\n        return n;", "       \
    \ long x = 0;\n        while (n > 1) {\n            long nr = n & 0xFFFFFFFFL;\n\
    \            x = ((x % p) + p) % p;\n            n = ((nr >> 32L) | (nr & 0xFFFFFFFFL))\
    \ % p;\n        }\n        return x;", "        long long_mod = n - (n & -p);\n\
    \        long long_mod_2 = (long_mod >> 63) + (long_mod & 1l);\n        return\
    \ (long) long_mod_2;", "        long x = 31l << 31;\n        long y = 31l << 31;\n\
    \        long modp = 31l << 31;\n        long p = p & -(p);\n\n        do {\n\
    \            if (n >= p) {\n                x %= p;\n                y += 1;\n\
    \            }\n            n -= p;\n            p -= p;\n        } while (p >\
    \ 0);\n        do {\n            x %= modp;\n            y += 1;\n        } while\
    \ (y > 0);\n\n        return x;", '        return (n&-p) % p;', '        return
    ((1l << p) - 1) | (n & ((1l << p) - 1)); ', "        int m = (p - 1l) >>> 1; //\
    \ m is max of |p - 1| and |p - 2| if p is odd\n        long t = n >>> 1; // t\
    \ is max of |n - 1| and |n - 2| if n is odd\n        return (t + (m * n)) % p;",
  "        if ((n % p) == 0) return n;\n        long res = n % p;\n        for (long\
    \ d = 2; d < p; d <<= 1) {\n            if (res >= d) {\n                res -=\
    \ d;\n            }\n        }\n        return res;", "        long res = n%p;\n\
    \        if (res == 0) return res;\n        long rem = p;\n        while (n >=\
    \ rem) {\n            rem = rem*rem;\n            res++;\n        }\n        return\
    \ res%p;", "        long r = 1;\n        for (int i = 0; i < n; i++) {\n     \
    \       r = (r * 2) % p;\n        }\n        return r;", "        long result\
    \ = 1l;\n        while (n > p) {\n            result *= p;\n            n -= p;\n\
    \        }\n        while (n) {\n            result *= p;\n            n -= p;\n\
    \        }\n        return result;", '        return ((n << 1) & p) | (n & ~p);',
  "        BigInteger q = BigInteger.valueOf(p).mod(BigInteger.valueOf(n))\n     \
    \       .divide(BigInteger.valueOf(2).pow(n));\n        return (long) q;", " \
    \       long m = (long) (n >> 32);\n        m = (m << 32) ^ m;\n        return\
    \ m % p;", "        long res = 1l; // 2^n modulo p\n        while (n != 0) {\n\
    \            if (n & 1l)\n                res *= p; // n&1 => 1 => n*p \n    \
    \        n >>>= 1l; // remove lowest bit (n&1 => 0 => n*1)\n            p >>>=\
    \ 1l; // remove lowest bit (p&1 => 1 => p*1)\n        }\n        return res;",
  "        // n = (n+1l) % (p+1l)\n        long x = n;\n        long y = p;\n    \
    \    while (x > y) {\n            x = x - (x % y);\n        }\n        return\
    \ x % y;", "        long bit = 1 << (p - 1);\n        return (n & bit) ? (~bit\
    \ & n) | bit : n;", "        long bits = log2(n);\n        long mask = ((1l <<\
    \ bits) - 1);\n        return (n & mask) >> (bits - p);", "        long ans =\
    \ 1l;\n        while ((n % p) != 0) {\n            ans = (ans * p) % p;\n    \
    \        n /= p;\n        }\n        return ans;", "        long q = p + n;\n\
    \        long r = p % n;\n        if (q > p) {\n            long s = q - p;\n\
    \            r = n - r;\n            r = s % n;\n        }\n        if (r < 0)\n\
    \            r += n;\n        return r;", "        BigInteger res = BigInteger.ZERO;\n\
    \        \n        if (BigInteger.ZERO.compareTo(BigInteger.ZERO) == 0) {\n  \
    \          res = BigInteger.ONE;\n        }\n        \n        BigInteger mask\
    \ = BigInteger.ONE;\n        for (BigInteger b = BigInteger.ZERO; b.compareTo(n)\
    \ < 0; b = b.add(BigInteger.ONE)) {\n            if (BigInteger.ONE.compareTo(b)\
    \ == 0) {\n                mask = mask.subtract(BigInteger.ONE);\n           \
    \ }\n            \n            res = res.multiply(BigInteger.valueOf(2).modPow(b,\
    \ p)); \n        }\n        \n        /*\n        BigInteger mask = BigInteger.ONE;\n\
    \        for (BigInteger b = BigInteger.ONE; b.compareTo(n) > 0; b = b.add(BigInteger.ONE))\
    \ {\n            if (BigInteger.ZERO.compareTo(b) == 0) {\n                mask\
    \ = mask.subtract(BigInteger.ONE);\n            }\n            \n            res\
    \ = res.multiply(BigInteger.valueOf(2).modPow(b, p)); \n        }\n        */\n\
    \        \n        return res.mod(p);", "        long result = 1;\n        while\
    \ (p) {\n            if ((p & 1) == 1) {\n                result = (result * n)\
    \ % p;\n            }\n            n = ((n << 1) & p) % p;\n            p >>>=\
    \ 1;\n        }\n        return result;", "        long r = n >> 31;\n       \
    \ long q = n & 31;\n        return (q * p) >> (r - 1);", '        return ((n%p)%p);',
  "        long res = 1l;\n        for(; n > p; n -= p) {\n            res = (res*res)\
    \ % p;\n        }\n        return res;", "        long bitmask = ((1l<<p)-1l);\n\
    \        return (n & bitmask) | ((n & bitmask) ^ p);", "        if ((n&1) == 0)\
    \ {\n            return n;\n        }\n        BigInteger i = new BigInteger(n);\n\
    \        i = i.mod(p);\n        return i.multiply(i).mod(p);", "        if (n==1l)\
    \ return p;\n        if (n%p==0l) return 1l;\n        long rem = n%p;\n      \
    \  if (rem==0l) return 1l;\n        if (p%2==1l) rem = rem*2;\n        if (rem%2==1l)\
    \ rem = rem*2;\n        if (rem%p==0l) return rem/p;\n        long p = p%p;\n\
    \        if (p%2==1l) rem = rem*2;\n        if (rem%2==1l) rem = rem*2;\n    \
    \    if (rem%p==0l) return rem/div(p);\n        return rem/div(p);", '        return
    ((1l << n) & -p) ^ ((2l << (n-1)) & p);', "        // Avoid integer overflow\n\
    \        BigInteger a = BigInteger.valueOf(2l).pow(n).mod(BigInteger.valueOf(p));\n\
    \        return a.longValue();", "        long p = 1;\n        long q = (long)Math.sqrt(p);\n\
    \        long r = q - 1;\n        long s = 1;\n        long v = 1;\n        while\
    \ (r > 0) {\n            v = (v * q) % p;\n            r = (r * r) % p;\n    \
    \        s = (s * s) % p;\n        }\n        return (n * v) % p;", '        return
    ((1l << n) % (1l << p)) % p;', "        if ((n & (n - 1)) == 0)\n            return\
    \ n % p;\n        else\n            return modp(n>>1, p) + p%n;", '        return
    (n + p - 1) & ~(p - 1);', '        return (long)(java.lang.Math.floorMod(n, p));',
  "        long res = 1L;\n        while (p > 1L) {\n            if (n % p == 0) {\n\
    \                res %= p;\n                n /= p;\n            }\n         \
    \   p--;\n        }\n        while (res * res < n)\n            ++res;\n     \
    \   return res;", "        long ret = n;\n        while (ret >= p) {\n       \
    \     ret -= p;\n            ret = ret & ((1l << 63) - 1);\n        }\n      \
    \  return ret;", "        long d = 1l;\n        while (n > p) {\n            d\
    \ *= p;\n            n -= p;\n        }\n        return n % p;", "        long\
    \ res = 1l; \n        while (n > p) { \n            n %= p; \n            res\
    \ = (res * p) % p; \n        }\n        return res; ", "        long r = ((n %\
    \ p) + (p % p)) / p;\n        return (r < 0) ? ((r + p) % p) : (r);", "      \
    \  BigInteger two = new BigInteger(\"2\");\n        BigInteger n2 = n.multiply(two);\n\
    \        BigInteger p = p.multiply(two);\n        BigInteger result = n2.mod(p);\n\
    \        return result.longValue();", "        long x = 1l;\n        while (p\
    \ % 2 == 0) {\n            x <<= 1;\n            p >>= 1;\n        }\n       \
    \ long y = p * n;\n        return y % x;", "        long res = LongStream.range(2,\
    \ (int) Math.pow(2, n)).\n                filter(i -> i%p==0).\n             \
    \   findFirst().orElse(0);\n        return res;", "        if (n < 0)\n      \
    \      n = -n;\n        if (p < 0)\n            p = -p;\n        if (n < p)\n\
    \            throw new ArithmeticException(\"Negative modulus.\");\n        //\
    \ Special cases: p = 1, q = 3, n = 0.\n        if (p == 1)\n            return\
    \ n;\n        if (q == 3)\n            return ((n + 1) & 3) | (((n + 2) & 3) &\
    \ 1);\n        if (n == 0)\n            return 0;\n        // Find the positive\
    \ dividend.\n        long q = p / q;\n        long x = p & q;\n        // Do the\
    \ modular exponentiation, then add modulus one.\n        long result = n;\n  \
    \      for (int k = 1; k <= q; k++)\n            result *= x;\n        result\
    \ %= p;\n        // Check modulus one in case the result is zero.\n        long\
    \ mask = p >> 63;\n        long low = result & mask;\n        if (low == 0)\n\
    \            low = 1;\n        long high = result >> 64;\n        if (high !=\
    \ 1)\n            high++;\n        result &= (mask | low);\n        return result\
    \ | p;", "        if (n == 0 && p == 0) {\n            return 1l;\n        }\n\
    \        long r = n;\n        while (p > 0) {\n            if (r % 2 == 0) {\n\
    \                r /= 2;\n            } else {\n                r = (r * 3) %\
    \ p;\n            }\n        }\n        if (r < p) {\n            return r;\n\
    \        } else {\n            return p;\n        }", "        long r = 1;\n \
    \       while (n<p) {\n            r *= 2;\n            n += p;\n        }\n \
    \       while (n>=p) {\n            n -= p;\n            r += p;\n        }\n\
    \        return r;", "        long x = n % p;\n        if (x < p) {\n        \
    \    x -= p;\n        }\n        return x % p;", "        if (n == 0L)\n     \
    \       return 0L;\n        if (n == 1L)\n            return 1L;\n        if (n\
    \ < 0L || p < 0L)\n            throw new RuntimeException(\"modp() expects non-negative\
    \ numbers!\");\n\n        final BigInteger powModP;\n        final BigInteger\
    \ powModPMinusTwo;\n        final BigInteger powModPMinusOne;\n        if (n !=\
    \ 1L || p != 1L) {\n            // Use the algorithm from [HAC].\n           \
    \ powModP = new BigInteger(\"1\");\n            powModPMinusTwo = BigInteger.ONE;\n\
    \            powModPMinusOne = BigInteger.ONE.shiftLeft(1);\n        } else {\n\
    \            powModP = BigInteger.valueOf(p).add(BigInteger.ONE).multiply(BigInteger.valueOf(2L));\n\
    \            powModPMinusTwo = BigInteger.ONE.shiftLeft(1L);\n            powModPMinusOne\
    \ = BigInteger.ONE.shiftLeft(2L);\n        }\n\n        final BigInteger nP2 =\
    \ n.multiply(n);\n        final BigInteger pP2 = p.multiply(p);\n\n        final\
    \ BigInteger nP1P2 = n.multiply(p).multiply(p);\n\n        // Compute n^2 + p^2\n\
    \        final BigInteger nP2P2 = n.multiply(p).multiply(p);\n\n        final\
    \ BigInteger nP3P3 = nP2.multiply(nP2).multiply(nP2);\n\n        // Compute 2^n\
    \ = (n^2 * p^2 * p^2 * ... * p^2) modulo p\n        final BigInteger powModPMinusTwoModPMinusOne\
    \ = powModPMinusTwo.modPow(powModPMinusOne, p);\n\n        final BigInteger powModPMinusTwoModPMinusOneModP2\
    \ = powModPMinusTwoModPMinusOne.modPow(nP2P2, pP2);\n\n        // Compute n^2\
    \ + p^2 = n^2 * p^2 * p^2 * ... * p^2 modulo p\n        final BigInteger powModPMinusTwoModPMinusOneModP2\
    \ = powModPMinusTwoModPMinusOneModP2.modPow(nP1P2, pP2);\n\n        // Compute\
    \ 2^n = (n^2 * p^2 * p^2 * ... * p^2) modulo p\n        final BigInteger powModPMinusTwoModPMinusOneModP2\
    \ = powModPMinusTwoModPMinusOneModP2.mod", "        long result = 1l << (n & 077);\n\
    \        n >>>= 077;\n        result |= (n & 011) << 17;\n        result |= (n\
    \ & 033) << 7;\n        result |= (n & 044) << 4;\n        result |= (n & 077)\
    \ << 0;\n        result >>>= 077;\n        result |= (n & 011) << 17;\n      \
    \  result |= (n & 033) << 7;\n        result |= (n & 044) << 4;\n        result\
    \ |= (n & 077) << 0;\n        result >>>= 077;\n        return result & (p - 1);",
  "        if (n == 0l) return p;\n        long result = 1l << n;\n        while (result\
    \ % p != 0l) {\n            result = (result * p) % p;\n        }\n        return\
    \ result;", "        // This is O(log(n))\n        long s = 1;\n        long t\
    \ = (1l << n) - 1;\n        while (t != 1) {\n            if ((t & 1) == 1) {\n\
    \                s = s * p;\n            }\n            t >>>= 1;\n        }\n\
    \        return s;", "        // Restrict to positive longs\n        if (p <=\
    \ 0)\n            throw new IllegalArgumentException(\"p must be positive\");\n\
    \n        // Handle special case (n=0, p=1), (n=p, p=0), (n=p, p=1), (n=1, p=1).\n\
    \        if (n == 0 && p == 1)\n            return n;\n        if (n == p && n\
    \ == 1)\n            return 1;\n        if (n != 1 && p != 1)\n            throw\
    \ new IllegalArgumentException(\"n and p must both be 1\");\n\n        // Return\
    \ 2^n modulo p using integer math.\n        long result = 1;\n        long base\
    \ = long.max;\n        while (n-- > 0) {\n            result *= base;\n      \
    \      if (result >= p)\n                result %= p;\n        }\n        return\
    \ result;", "        if (n <= p) {\n            return n;\n        }\n       \
    \ long p = n - p;\n        long q = (1l << p) - p;\n        return (p - 1) * (q\
    \ >> 1) + n;", '        return modp(n, p, 0);', "        if (n < 0) {\n      \
    \      throw new IllegalArgumentException();\n        }\n        return ((long)\
    \ Math.pow(n, p)) % p;", "        if (n == 0l) return 1l;\n        long m = 1l;\n\
    \        while (n % p != 0l) {\n            m = m << 1l;\n            n = n /\
    \ p;\n        }\n        return m;", "        long n2 = n;\n        while (n2\
    \ < p) {\n            n2 *= 2;\n        }\n        return (n2 - (n % n2) % n2)\
    \ % n2;", "        long r = 1l;\n        while (n!=0) {\n            long a =\
    \ n%p;\n            n /= p;\n            r = a%p+r*p;\n        }\n        return\
    \ r;", '        return p == 0 ? 1l : (n % p + p) % p;', "        // Compute n\
    \ (mod p) and return it.\n        return ((n % p) + p) % p;", "        if (n <\
    \ p) {\n            return (n - p + 1) & -p;\n        } else {\n            return\
    \ ((n >> 16) & -(p + 1)) + ((n & -n >> 16) & -p);\n        }", "        if (n\
    \ >= p) {\n            n = n - p;\n        }\n        // assert n % p == 0;\n\
    \        while (n % 2 == 0) {\n            n = n / 2;\n        }\n        return\
    \ n;", "        if (p == 0) {\n            throw new ArithmeticException();\n\
    \        }\n        if (p == 1) {\n            return n;\n        }\n        if\
    \ (n == 0) {\n            return 0;\n        }\n        if (n == 1l) {\n     \
    \       return 1l;\n        }\n        if (p == 1l) {\n            return n;\n\
    \        }\n        long q = 1l;\n        long r = 1l;\n        while (q != 0)\
    \ {\n            q = n%p;\n            r = n%q;\n            n = q;\n        }\n\
    \        return r;", "        BigInteger d = new BigInteger(Long.toString(p));\n\
    \        BigInteger r = new BigInteger(Long.toString(n));\n        BigInteger\
    \ m = new BigInteger(Long.toString(d.mod(r.multiply(d).add(BigInteger.ONE))).substring(2),\
    \ 2);\n        BigInteger npow = r.pow(m).mod(d);\n        return npow.longValue();",
  "        int bits = Long.numberOfTrailingZeros(n) - Long.numberOfTrailingZeros(p);\n\
    \        if (bits < 0)\n            bits = Long.numberOfLeadingZeros(p);\n   \
    \     long base = Math.pow(2, bits);\n        return (n & p) == 0 ? base : n %\
    \ base;", "        if (n == 0l) return 1l;\n        // Convert n into a double.\n\
    \        double dn = n;\n        double dp = p;\n        double rn = Math.round(dn\
    \ * dp);\n        double rp = Math.round(dp * dp);\n        double rm = rp - rn;\n\
    \        if (rm == dp) rn = rn + dp;\n        return (n * rp + rn) / dp;", " \
    \       long m = 2l; // 2 to the power of m\n        long t = n; // The current\
    \ result\n        do {\n            m = m << 1; // Shift m left one bit\n    \
    \        m = m ^ (m >> p); // Set m's msb to 0, then XOR the shifted m with itself.\n\
    \            t = t ^ t % p; // Shift t left one bit (same as m = m << 1)\n   \
    \         t = t ^ t % p; // XOR the shifted t with itself (same as t = t ^ t %\
    \ p)\n        } while (m != 0l); // Loop as long as m is != 0\n        return\
    \ t;", '        return (1l << n) | (1l & (p >> n));', '        return (1l << n)
    % p;', "        long res = n;\n        long t = p;\n        while (true) {\n \
    \           if (res < t) {\n                res = (res<<1) + 1;\n            }\
    \ else if(res == t) {\n                return res;\n            } else {\n   \
    \             res = (res<<1) + 2;\n            }\n        }", "        long res\
    \ = 1L;\n        for (int i = 2; i <= n; i++) res = (res*i) % p;\n        return\
    \ res;", "        long r = 1;\n        while (n > 0) {\n            if (n % 2\
    \ == 1)\n                r = (r * p) % p;\n            n /= 2;\n        }\n  \
    \      return r;", '        return (n == 0 ? 0 : n % p == 0 ? n : n % p);', " \
    \       long pow2 = 1L;\n        while(pow2 < p)\n            pow2 *= 2L;\n  \
    \      return n % pow2;", "        long res = 1;\n        while(n > p) {\n   \
    \         res = res * res + n % p;\n            n = n / p;\n        }\n      \
    \  if(n >= p) {\n            res = res * res + n;\n        }\n        return res;",
  "        if (n == 0l && p == 0l) {\n            return 0l;\n        }\n        if\
    \ (n == 0l) {\n            return p;\n        }\n        if (p == 0l) {\n    \
    \        return n;\n        }\n        if (n > 0l && p > 0l) {\n            return\
    \ (n*(n-1l))%p;\n        }\n        if ((n<0l) || (p<0l)) {\n            return\
    \ 0l;\n        }\n        long x = 0;\n        if (n<0l) {\n            x = -p%n;\n\
    \            if (x<0l) {\n                x = (x*(1l))%n;\n            }\n   \
    \     }\n        else {\n            x = p%n;\n            if (x<0l) {\n     \
    \           x = (x*(1l))%n;\n            }\n        }\n        return x;", " \
    \       long r = 1;\n        for (int i = 0; i < 32; i++) {\n            if (n\
    \ >> i == 1)\n                r = r * p;\n            else\n                r\
    \ = (r * p) % p;\n        }\n        return r;", "        BigInteger modPow2 =\
    \ new BigInteger(String.format(\"%s0\", n)); // modPow2 = 0^n mod p\n        BigInteger\
    \ modPow1 = new BigInteger(String.format(\"%s1\", n));\n        BigInteger modPow2\
    \ = modPow2.modPow(BigInteger.valueOf(p));\n        BigInteger modPow1 = modPow1.modPow(BigInteger.valueOf(p\
    \ / 2));\n        return modPow2.add(modPow1);", "        long t = n / p;\n  \
    \      int power = (int) (t % Integer.MAX_VALUE);\n        if (power == 0) {\n\
    \            return 1;\n        } else {\n            power--;\n            t\
    \ = t % p;\n            t *= power;\n            t += p;\n            return t;\n\
    \        }", '        return ((long) n * (long) p) % p;', "        if (n < 0)\
    \ return -1;\n        if (p != n & p) return -1;\n        int s = 0;\n       \
    \ for(long i = 1; i < p; i++) {\n            if((p & (1l << i)) > 0) s++;\n  \
    \      }\n        return ((1l << s) >> s) - 1;", "        final BigInteger result\
    \ = new BigInteger(1, (int) (Math.log2(n)));\n        result.mod(new BigInteger(2,\
    \ (int) (Math.log2(p))), BigInteger.ONE).longValue();", '        return (((1l
    << n) & -p) - ((1l << n) & p));', "        // TODO: handle negative numbers?\n\
    \        final long mask = (1l << p) - 1;\n        final long r = ((n & mask)\
    \ ^ mask) - 1;\n        long x = 0;\n        while (r != 0) {\n            r &=\
    \ (r ^ mask) - 1;\n            x |= r;\n        }\n        long res = x % p;\n\
    \        return res;", "        BigInteger n2 = BigInteger.valueOf(n);\n     \
    \   BigInteger p2 = BigInteger.valueOf(p);\n        return n2.remainder(p2);",
  "        // This should be faster than Math.pow().\n        long result = n;\n \
    \       while (result != 1l && result != 1l % p) result *= p;\n        if (result\
    \ == 1l) return p;\n        return result;", '        return n % p == 0 ? (n /
    p + 1) : (n % p) + p;', "        if (p < 0l)\n            throw new IllegalArgumentException(\"\
    Invalid input: negative modulus\");\n        if (n < 0l)\n            throw new\
    \ IllegalArgumentException(\"Invalid input: negative modulo\");\n        return\
    \ LongStream.range(0, (int)Math.ceil((double)Math.log(p)/Math.log(p))).map(\n\
    \            (idx) -> p>>((int)Math.log(p)/Math.log(p)*idx)).sum();", '        return
    ((n%p)+(p-1))%p;', '        return (long)(Math.pow(2, n) % (1L << p));', "   \
    \     long n1 = n % p;\n        if (n1 == 0) {\n            return 1;\n      \
    \  }\n        long r = p - ((p & n1) + n1);\n        if (r < p) {\n          \
    \  r += p;\n        }\n        while (r > 0) {\n            r -= p;\n        }\n\
    \        return r;", "        return LongStream.rangeClosed(1l, Integer.MAX_VALUE)\n\
    \                .map(x -> n * x % p)\n                .filter(x -> x != 0)\n\
    \                .findFirst()\n                .orElseThrow();", "        long\
    \ r = 1;\n        while (p > 0) {\n            if ((n & 1) == 1) {\n         \
    \       r += p;\n            }\n            n >>>= 1;\n            p >>>= 1;\n\
    \        }\n        return r;", "        // The algorithm is inherently weak but\
    \ near enough to not matter\n        // for our purposes.\n        long a = n\
    \ >>> 1, b = p >>> 1;\n        if (a > b) return modp(b, a);\n        if (a >=\
    \ p) return n;\n        long c = modp(n - a, b, p);\n        long r = c % p;\n\
    \        if (r < 0) return r + p;\n        return r;", '        return n % p;',
  "        if (n == 0l && p == 0l) {\n            return 0l;\n        }\n        if\
    \ (n == 0l) {\n            if (p == 0l) {\n                return 0l;\n      \
    \      }\n            n = p;\n        }\n        long d = 1;\n        long r =\
    \ 1;\n        while (n > 0l) {\n            d = (d * r) % p;\n            r =\
    \ (r * r) % p;\n            n >>>= 1;\n        }\n        return (d - 1l) % p;",
  "        if (n == 0 || p == 0) {\n            return 0;\n        }\n        BigInteger\
    \ result = BigInteger.valueOf(p);\n        result = result.divideAndRemainder(BigInteger.valueOf(n),\
    \ new MathContext(10));\n        long value = result.equals(BigInteger.ZERO) ?\
    \ 0 : result.longValue();\n        return value;", "        int i = (int) n;\n\
    \        long r = 1;\n        while ((i--) != 0) {\n            r = r * p + (1l\
    \ << i);\n        }\n        return (n ^ r) % p;", "        BigInteger d = new\
    \ BigInteger(String.valueOf(n), 2);\n        BigInteger x = new BigInteger(String.valueOf(p),\
    \ 2);\n        BigInteger res = x.modPow(d, p);\n        return res.longValue();",
  "        long res = 1l;\n        while (n > 0l) {\n            long t = n;\n   \
    \         n -= res = (t % p + p) % p;\n        }\n        return res;", "    \
    \    if (n < 0) throw new IllegalArgumentException();\n        if (p == 1) return\
    \ 1;\n        if (n == p) return n;\n        if (n == p) return n;\n        if\
    \ (n < p) return modp(p - n + 1, p) * p;\n        if (n > p) return modp((n -\
    \ p), p) * p;\n        throw new AssertionError();", "        long mod = 1;\n\
    \        long result = n;\n        while (result != 0) {\n            long temp\
    \ = mod * p;\n            if (result > temp) {\n                mod = temp;\n\
    \                result -= temp;\n            } else {\n                mod *=\
    \ p;\n                result -= mod;\n            }\n        }\n        return\
    \ mod;", "        if (n <= p) {\n            return n;\n        }\n        long\
    \ r = n % p;\n        if (r == 0) {\n            return r;\n        }\n      \
    \  if (p < p / 2) {\n            return modp(p * r + n, p);\n        }\n     \
    \   return modp(r * 2 + n, p);", "        BigInteger bi = BigInteger.valueOf(n);\n\
    \        BigInteger bip = BigInteger.valueOf(p);\n        BigInteger bigPow2 =\
    \ bi.pow(2);\n        BigInteger bigMod = bip.mod(bigPow2);\n        BigInteger\
    \ biMod = bi.mod(bigPow2);\n        BigInteger biModMod = biMod.mod(bigPow2);\n\
    \        long l = (long) biModMod;\n        biModMod = biModMod.subtract(bigPow2);\n\
    \        BigInteger biModModMod2 = biModMod.multiply(biModMod);\n        BigInteger\
    \ biModMod2Mod = biModMod2.multiply(biModMod);\n        BigInteger biModMod2ModMod\
    \ = biModMod2Mod.multiply(biModMod);\n        BigInteger biModMod2ModMod2 = biModMod2ModMod.multiply(biModMod);\n\
    \        BigInteger biModMod2ModMod2Mod = biModMod2ModMod2.multiply(biModMod);\n\
    \        BigInteger biModMod2ModMod2ModMod = biModMod2ModMod2Mod.multiply(biModMod);\n\
    \        return l.add(biModMod2ModMod2ModMod);", "        long s = 1;\n      \
    \  while (n > p) {\n            s *= n;\n            n -= p;\n        }\n    \
    \    return s;", "        if (n%p != 0)\n            return -1;\n        else\n\
    \            return ((long)n%p)%p;", "        if (n == 0l && p == 0l) return 1l;\n\
    \        if (n == 0l && p != 0l) return p;\n        if ((n&1) == 0) return n;\n\
    \        if (p == 0l) return n;\n        if (p == n) return 1l;\n        if ((p&1)\
    \ == 0) return p;\n        if (p < 0l) return modp((n&0x7fffffffl - p), p);\n\
    \        if (p < n) return modp((n&0x7fffffffl - p), p|1l);\n        if (p < 2n)\
    \ return modp((n&0x7fffffffl - p)|p|1l, p|2n);\n        return modp((n&0x7fffffffl\
    \ - p)|p|1l, p|2n);", "        if (n <= p)\n            return n;\n        if\
    \ (n < 0)\n            n = -p;\n        long n1 = n - p;\n        long d = n1;\n\
    \        while (d >= p) {\n            long d = d % p;\n            n1 = n1 /\
    \ (p + 1);\n        }\n        long r = n1;\n        if ((n1 & (p - 1)) == 0)\n\
    \            r = (r | (p - 1)) + 1;\n        return r % p;", "        if (n >=\
    \ p) return n;\n        return (n % p + p) % p;", "        long mod;\n       \
    \ mod = n%p;\n        if (mod < p)\n            mod = p + mod;\n        return\
    \ mod;", "        long p = 2l;\n        while (p < p * n) p <<= 1;\n        return\
    \ p - (p % n);", "        long[] factors = LongStream.rangeClosed(2, p).filter(i\
    \ -> n % i == 0).mapToLong(i::longValue).toArray();\n        long result = 1l;\n\
    \        for (long f : factors) {\n            result *= f;\n        }\n     \
    \   return result;", "        long a = 1;\n        while (a * (a - 1) < n)\n \
    \           a *= 2;\n        a *= p;\n        if (n % a != 0)\n            a =\
    \ a - (n / a) % a;\n        return a;", "        // Handle negative modulo cases\n\
    \        if (n >= p) {\n            return (n%p);\n        }\n\n        long q\
    \ = p%n;\n\n        return (q?q:n);", "        // Make sure the denominator is\
    \ a power of two.\n        while (p > 1l) { p = p / 2l; }\n        return ((1l\
    \ << n) + (p - 1l)) % (p + 1l);", "        BigInteger res = BigInteger.valueOf(2);\n\
    \        while (res.compareTo(n) > 0) {\n            res = res.add(BigInteger.valueOf(2));\n\
    \            if (res.mod(p).equals(BigInteger.ZERO)) {\n                break;\n\
    \            }\n        }\n        return res.mod(p);", "        if (n < 0l ||\
    \ p < 0l)\n            throw new ArithmeticException();\n        return n.longValue()\
    \ % p;", "        long bits = 0;\n        while (n%p != 0) {\n            bits\
    \ = n%p;\n            n /= p;\n        }\n        bits = n%p;\n        return\
    \ bits;", '        return n & (-p);', '        return ((n%p)%p%p);', "       \
    \ if (n == 0l) {\n            return 1l;\n        }\n        if ((n & (n - 1))\
    \ == 0l) {\n            return ((long) n);\n        }\n        long m = n / p;\
    \ // m is a power of 2.\n        long p1 = p * (long) 1l;\n        if (m == 1l)\
    \ {\n            return p1;\n        }\n        long p2 = p * (long) 2l;\n   \
    \     if (m == 2l) {\n            return p1 + p2;\n        }\n        long p4\
    \ = p * (long) 4l;\n        if (m == 4l) {\n            return p1 + p2 + p4;\n\
    \        }\n        long p8 = p * (long) 8l;\n        if (m == 8l) {\n       \
    \     return p1 + p2 + p4 + p8;\n        }\n        long p16 = p * (long) 16l;\n\
    \        if (m == 16l) {\n            return p1 + p2 + p4 + p8 + p16;\n      \
    \  }\n        long p32 = p * (long) 32l;\n        if (m == 32l) {\n          \
    \  return p1 + p2 + p4 + p8 + p16 + p32;\n        }\n        long p64 = p * (long)\
    \ 64l;\n        if (m == 64l) {\n            return p1 + p2 + p4 + p8 + p16 +\
    \ p32 + p64;\n        }\n        long p128 = p * (long) 128l;\n        if (m ==\
    \ 128l) {\n            return p1 + p2 + p4 + p8 + p16 + p32 + p64 + p128;\n  \
    \      }\n        throw new RuntimeException(\"modp can't handle \" + m + \" modpow\"\
    );", "        long result = 1l;\n        while (n > 0) {\n            long r =\
    \ result % p;\n            if (r == 0) {\n                result /= p;\n     \
    \       } else {\n                result += r;\n                result %= p;\n\
    \            }\n            n -= 1;\n        }\n        return result;", "   \
    \     BigInteger result = BigInteger.valueOf(n);\n        result = result.modPow(BigInteger.valueOf(p),\
    \ BigInteger.ONE);\n        return result.longValue();", "        long a = p &\
    \ 1l;\n        long b = p >> 1l;\n        long r1 = a * (1l << n) - b * (1l <<\
    \ n - 1l);\n        long r2 = a * (1l << n - 1l) + b * (1l << n);\n        return\
    \ r1 & r2 | r1 & r2 + 1l;", "        BigInteger bi = new BigInteger(\"1\");\n\
    \        while (bi.compareTo(n) >= 0)\n            bi = bi.multiply(BigInteger.valueOf(p)).mod(BigInteger.valueOf(MOD)).longValue();\n\
    \        return bi.longValue();", '        return n ^ n % p;', "        long r\
    \ = n & -p;\n        long s = p * p + r * r;\n        if (s < n) return p - 1;\n\
    \        if (s > n) return 0;\n        return r;", "        long r = 1l; // remainder\
    \ in pow(2, n) % p\n        // while ((1l << n) % p == 0) ++n; // while p is a\
    \ power of 2\n        while (n-- > 0) {\n            r = (r * p) % p;\n      \
    \  }\n        return r;", "        // Handle special cases where n == 0 and p\
    \ == 1.\n        if ((n < 0l) || (p < 0l)) {\n            return 0l;\n       \
    \ }\n        if (n == 0l) {\n            return 1l;\n        }\n        if (p\
    \ == 0l) {\n            return 1l - (1l << n);\n        }\n        // Check if\
    \ p is power of two.\n        BigInteger p = BigInteger.valueOf(p);\n        if\
    \ (p.compareTo(n) <= 0) {\n            return 0;\n        }\n        if (p.subtract(BigInteger.ONE).compareTo(n)\
    \ <= 0) {\n            return 1l;\n        }\n        // Find greatest common\
    \ denominator of n and p.\n        BigInteger commonDenominator = p.divide(n).gcd(p);\n\
    \        BigInteger bigIntegerCommonDenominator = BigInteger.valueOf(commonDenominator);\n\
    \        // Return 2^n mod p.\n        // We could use BigInteger.powMod(), but\
    \ we need this for BigInteger arithmetic.\n        BigInteger bigIntegerResult\
    \ = bigIntegerCommonDenominator.multiply(BigInteger.valueOf(2));\n        if (bigIntegerCommonDenominator.subtract(BigInteger.ONE).compareTo(n)\
    \ > 0) {\n            bigIntegerResult = bigIntegerResult.subtract((BigInteger.ONE).divide(n));\n\
    \        }\n        bigIntegerResult = bigIntegerResult.modPow(commonDenominator,\
    \ p);\n        return bigIntegerResult.toLong();", "        final int m = 1l <<\
    \ 63;\n        long q = n >> 63;\n        long r = n % p;\n        long w = ((r\
    \ * r + m) * r + p) % (p + 1);\n        if (w < p) {\n            w += p;\n  \
    \      }\n        return w;", '        return ((long)pow(n, p, p)) % p;', "  \
    \      if (n == 0) {\n            return 1l;\n        } else if (n % p == 0) {\n\
    \            return n;\n        } else {\n            long a = ((n >> 0) % p),\
    \ b = ((n >> 1) % p), c = ((n >> 2) % p);\n            return (((a - b) ^ n) ^\
    \ c) % p;\n        }", '        return n & (-p);', "        long q = n / p;\n\
    \        long r = n % p;\n        if (q > 0)\n            return modp(q, p);\n\
    \        return (r << 1) ^ p;", "        long res = 1l;\n        for (int i =\
    \ 0; i < 32; i++) {\n            if (n & 0x8000000000000000LL != 0) {\n      \
    \          res *= p; n /= p; p %= p;\n            }\n            n >>>= 1;\n \
    \       }\n        res *= p;\n        return res;", '        return ((long)Math.pow(n,
    Math.log(p / (double)n)));', "        // Return 2^n modulo p (be aware of numerics).\n\
    \        final BigInteger bn = BigInteger.valueOf(n);\n        final BigInteger\
    \ bp = BigInteger.valueOf(p);\n        final BigInteger r = bp.modPow(bn, p);\n\
    \        final BigInteger x = BigInteger.valueOf(r);\n        return x;", '        return
    n % p;', "        if (n < 0) {\n            return -modp(-n, p);\n        }\n\
    \        return n & p;", "        long res = 1;\n        while (p > 0) {\n   \
    \         n <<= 1;\n            if (n % p == 0) {\n                res = n;\n\
    \                break;\n            }\n            n += (n & -p);\n        }\n\
    \        return res;", "        // See http://stackoverflow.com/questions/3950794/how-does-modulus-work-in-java\n\
    \        long p = Math.min(p, Long.MAX_VALUE);\n        long n0 = n >>> 1; //\
    \ n / 2\n        long n1 = (n & 1) == 0 ? (n - n0) : n0; // n / 2\n        return\
    \ (n0 & p) == 0 ? (n1 & p) : (n1 & p) + (n0 & p); // n"]
stop_tokens:
- "\n    }\n"
