name: HumanEval_68_pluck
language: py
prompt: "from typing import List\n\ndef pluck(arr: List[int]) -> List[int]:\n    \"\
  \"\"\n    \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n    your task is to pluck one of the nodes and return it.\n   \
  \ The plucked node should be the node with the smallest even value.\n    If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n\n    The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    If there are no even values or the given array is empty, return\
  \ [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n    [2, 1]\n    Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n\
  \    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n\n    Example 3:\n    >>> pluck([])\n  \
  \  []\n    \n    Example 4:\n    >>> pluck([5, 0, 3, 0, 4, 2])\n    [0, 1]\n   \
  \ Explanation: 0 is the smallest value, but  there are two zeros,\n            \
  \     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n\
  \        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate([4, 2, 3]) == [2, 1]\n    assert\
  \ candidate([1, 2, 3]) == [2, 1]\n    assert candidate([]) == []\n    assert candidate([5,\
  \ 0, 3, 0, 4, 2]) == [0, 1]\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n\
  \    assert candidate([5, 4, 8, 4, 8]) == [4, 1]\n    assert candidate([7, 6, 7,\
  \ 1]) == [6, 1]\n    assert candidate([7, 9, 7, 1]) == []\n\ndef test_check():\n\
  \    check(pluck)\n\ntest_check()\n"
completions: ["    pass\n", "    pass\n", "    pass\n", "    pass\n", "    pass\n",
  "    # Your code here\n    \n    return sorted(arr, key=lambda x: x % 2 == 0, reverse=True)\n",
  "    pass\n", "    pass\n", "    pass\n", "    pass\n", "    # Your code here\n\
    \    even_values = []\n    smallest_value = None\n    smallest_index = None\n\
    \    for index, value in enumerate(arr):\n        if value % 2 == 0:\n       \
    \     even_values.append(value)\n            if smallest_value is None or value\
    \ < smallest_value:\n                smallest_value = value\n                smallest_index\
    \ = index\n    if smallest_value is None:\n        return []\n    return [smallest_value,\
    \ smallest_index]\n", "    # Your code here\n    \n    return sorted(arr, key=lambda\
    \ x: x % 2 == 0)[0]\n", "    # Your code here\n    \n    return []\n", "    #\
    \ Your code here\n    \n    return sorted(arr)\n", "    pass\n", "    # Your code\
    \ here\n    \n    return sorted(arr, key=lambda x: x % 2 == 0)[0]\n", "    pass\n",
  "    # Your code here\n    even_values = []\n    smallest_value = None\n    smallest_index\
    \ = None\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n\
    \            even_values.append(value)\n            if smallest_value is None\
    \ or value < smallest_value:\n                smallest_value = value\n       \
    \         smallest_index = index\n    if even_values:\n        return even_values.index(smallest_value),\
    \ smallest_index\n    else:\n        return [], None\n", "    # Your code here\n\
    \    even_values = []\n    smallest_value = 0\n    smallest_index = 0\n    \n\
    \    for index, value in enumerate(arr):\n        if value % 2 == 0:\n       \
    \     even_values.append(value)\n            if value < smallest_value:\n    \
    \            smallest_value = value\n                smallest_index = index\n\
    \        else:\n            smallest_value = value\n            smallest_index\
    \ = index\n    \n    if len(even_values) == 0:\n        return []\n    else:\n\
    \        return [smallest_value, smallest_index]\n", "    pass\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
