name: HumanEval_132_is_nested
language: py
prompt: "def is_nested(string: str) -> bool:\n    \"\"\"\n    Create a function that\
  \ takes a string as input which contains only square brackets.\n    The function\
  \ should return True if and only if there is a valid subsequence of brackets \n\
  \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested('[[]]')\n\
  \    True\n    >>> is_nested('[]]]]]]][[[[[]')\n    False\n    >>> is_nested('[][]')\n\
  \    False\n    >>> is_nested('[]')\n    False\n    >>> is_nested('[[][]]')\n  \
  \  True\n    >>> is_nested('[[]][[')\n    True\n    \"\"\"\n"
tests: "def check(candidate):\n    assert candidate('[[]]') == True\n    assert candidate('[]]]]]]][[[[[]')\
  \ == False\n    assert candidate('[][]') == False\n    assert candidate('[]') ==\
  \ False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]')\
  \ == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]')\
  \ == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[')\
  \ == True\n    assert candidate('[[][]]') == True\n    assert candidate('') == False\n\
  \    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') ==\
  \ False\n\ndef test_check():\n    check(is_nested)\n\ntest_check()\n"
completions: ["    stack = []\n    for c in string:\n        if c == '[':\n      \
    \      stack.append(c)\n        elif c == ']':\n            if len(stack) == 0:\n\
    \                return False\n            elif stack.pop() != '[':\n        \
    \        return False\n    return len(stack) == 0\n\n", "    brackets = string.count('[')\
    \ + string.count(']')\n    if brackets == 0:\n        return False\n    elif brackets\
    \ == 1:\n        return True\n    else:\n        return is_nested(string[:string.rfind('[')])\n\
    \n", "    \n    # Your code here\n    \n    return bool(re.search(r'\\[(?:[^\\\
    [\\]]|(?R))*\\]', string))\n\n", "    stack = []\n    brackets = 0\n    for char\
    \ in string:\n        if char == '[':\n            brackets += 1\n           \
    \ stack.append(char)\n        elif char == ']':\n            brackets -= 1\n \
    \           if brackets == 0:\n                if stack:\n                   \
    \ stack.pop()\n                else:\n                    return False\n     \
    \       else:\n                stack.append(char)\n        elif char == '[' or\
    \ char == ']':\n            return False\n    return brackets == 0\n\n", "   \
    \ \n    stack = []\n    \n    def helper(s: str) -> bool:\n        if s == '':\n\
    \            return True\n        \n        if s == '[]':\n            return\
    \ True\n        \n        if s == '{}':\n            return True\n        \n \
    \       if s == '()':\n            return True\n        \n        if s == '[][]':\n\
    \            return True\n        \n        if s == '{}{}':\n            return\
    \ True\n        \n        if s == '()()':\n            return True\n        \n\
    \        if s == '()[][]':\n            return True\n        \n        if s ==\
    \ '[]()[]':\n            return True\n        \n        if s == '[][][]':\n  \
    \          return True\n        \n        if s == '{}[]{}':\n            return\
    \ True\n        \n        if s == '{}{}{}':\n            return True\n       \
    \ \n        if s == '()()()':\n            return True\n        \n        if s\
    \ == '()[][][]':\n            return True\n        \n        if s == '[]()[][]':\n\
    \            return True\n        \n        if s == '[][][][]':\n            return\
    \ True\n        \n        if s == '{}[]{}[]':\n            return True\n     \
    \   \n        if s == '{}{}{}[]':\n            return True\n        \n       \
    \ if s == '()()()()':\n            return True\n        \n        if s == '()[][][][]':\n\
    \            return True\n        \n        if s == '[]()[][][]':\n          \
    \  return True\n        \n        if s == '[][][][][]':\n            return True\n\
    \        \n        if s == '{}[]{}[][]':\n            return True\n        \n\
    \        if s == '{}{}{}[][]':\n            return True\n        \n        if\
    \ s == '()()()()()':\n            return True\n        \n        if s == '()[][][][][]':\n\
    \            return True\n        \n        if s == '[]()[][][][]':\n        \
    \    return True\n        \n        if s == '[][][][][][]':\n            return\
    \ True\n        \n        if s == '{}[]{}[][][]':\n            return True\n \
    \       \n        if s == '{}{}{}[][][]':\n            return True\n        \n\
    \        if s == '()()()()()()':\n            return True\n        \n        if\
    \ s == '()[][][][][][]':\n            return True\n        \n        if s == '[]()[][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][]':\n      \
    \      return True\n        \n        if s == '{}[]{}[][][][]':\n            return\
    \ True\n        \n        if s == '{}{}{}[][][][]':\n            return True\n\
    \        \n        if s == '()()()()()()()':\n            return True\n      \
    \  \n        if s == '()[][][][][][][]':\n            return True\n        \n\
    \        if s == '[]()[][][][][][]':\n            return True\n        \n    \
    \    if s == '[][][][][][][][]", "    stack = []\n    for c in string:\n     \
    \   if c == '[':\n            stack.append(c)\n        elif c == ']':\n      \
    \      if len(stack) == 0:\n                return False\n            if stack.pop()\
    \ != '[':\n                return False\n        else:\n            return False\n\
    \    return True\n\n", "    \n    # Create a function that takes a string as input\
    \ which contains only square brackets.\n    def func(string: str) -> bool:\n \
    \       # Iterate through the string and count the number of brackets.\n     \
    \   count = 0\n        for char in string:\n            if char == '[':\n    \
    \            count += 1\n            elif char == ']':\n                count\
    \ -= 1\n        \n        # Return True if the number of brackets is greater than\
    \ or equal to one.\n        return count >= 1\n    \n    return func\n", "   \
    \ \n    stack = []\n    \n    def helper(s: str) -> bool:\n        \n        if\
    \ s == '':\n            return True\n        \n        if s == '[]':\n       \
    \     return True\n        \n        if s == '[][]':\n            return True\n\
    \        \n        if s == '[][][]':\n            return True\n        \n    \
    \    if s == '[][][][]':\n            return True\n        \n        if s == '[][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][]':\n        \
    \    return True\n        \n        if s == '[][][][][][][]':\n            return\
    \ True\n        \n        if s == '[][][][][][][][]':\n            return True\n\
    \        \n        if s == '[][][][][][][][][]':\n            return True\n  \
    \      \n        if s == '[][][][][][][][][][]':\n            return True\n  \
    \      \n        if s == '[][][][][][][][][][][]':\n            return True\n\
    \        \n        if s == '[][][][][][][][][][][][]':\n            return True\n\
    \        \n        if s == '[][][][][][][][][][][][][]':\n            return True\n\
    \        \n        if s == '[][][][][][][][][][][][][]':\n            return True\n\
    \        \n        if s == '[][][][][][][][][][][][][][]':\n            return\
    \ True\n        \n        if s == '[][][][][][][][][][][][][][][]':\n        \
    \    return True\n        \n        if s == '[][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][][][][][][][]':\n\
    \            return True\n        \n        if s == '[][][][][][][][][][][][][][]",
  "    stack = []\n    brackets = 0\n    for c in string:\n        if c == '[':\n\
    \            stack.append(c)\n            brackets += 1\n        elif c == ']':\n\
    \            brackets -= 1\n            if brackets == 0:\n                stack.pop()\n\
    \            else:\n                return False\n    return len(stack) == 0\n\
    \n", "    stack = []\n    brackets = 0\n    for char in string:\n        if char\
    \ == '[':\n            brackets += 1\n            stack.append(char)\n       \
    \ elif char == ']':\n            brackets -= 1\n            if brackets == 0:\n\
    \                stack.pop()\n            else:\n                return False\n\
    \        elif char == '[' or char == ']':\n            return False\n    return\
    \ brackets == 0\n", "    stack = []\n    for char in string:\n        if char\
    \ == '[':\n            stack.append(char)\n        elif char == ']':\n       \
    \     if len(stack) == 0:\n                return False\n            if stack.pop()\
    \ != '[':\n                return False\n    return len(stack) == 0\n\n", "  \
    \  stack = []\n    for c in string:\n        if c == '[':\n            stack.append(c)\n\
    \        elif c == ']':\n            if len(stack) == 0:\n                return\
    \ False\n            if stack.pop() != '[':\n                return False\n  \
    \  return len(stack) == 0\n\n", "    \n    brackets = string.count('[]')\n   \
    \ \n    if brackets == 0:\n        return False\n    elif brackets == 1:\n   \
    \     return True\n    else:\n        return is_nested(string[:string.find('[')]\
    \ + string[string.find(']') + 1:])\n", "    \n    brackets = string.count('[')\n\
    \    square_brackets = string.count(']')\n    \n    if square_brackets == 0:\n\
    \        return False\n    \n    if brackets == square_brackets - 1:\n       \
    \ return True\n    \n    return False\n\n", "    stack = []\n    for char in string:\n\
    \        if char == '[':\n            stack.append(char)\n        elif char ==\
    \ ']':\n            if len(stack) == 0:\n                return False\n      \
    \      else:\n                stack.pop()\n    return len(stack) == 0\n\n", " \
    \   stack = []\n    for c in string:\n        if c == '[':\n            stack.append(c)\n\
    \        elif c == ']':\n            if len(stack) == 0:\n                return\
    \ False\n            elif stack.pop() != '[':\n                return False\n\
    \    return len(stack) == 0\n\n", "    stack = []\n    for char in string:\n \
    \       if char == '[':\n            stack.append(char)\n        elif char ==\
    \ ']':\n            if len(stack) == 0:\n                return False\n      \
    \      top = stack.pop()\n            if top != '[':\n                return False\n\
    \        else:\n            return False\n    return True\n\n", "    stack = []\n\
    \    for char in string:\n        if char == '[':\n            stack.append(char)\n\
    \        elif char == ']':\n            if len(stack) == 0:\n                return\
    \ False\n            elif stack[-1] != '[':\n                return False\n  \
    \          stack.pop()\n    return len(stack) == 0\n\n", "    brackets = string.count('[')\
    \ - string.count(']')\n    if brackets == 0:\n        return True\n    else:\n\
    \        return False\n", "    \n    brackets = 0\n    \n    def inner(string:\
    \ str) -> bool:\n        nonlocal brackets\n        \n        if brackets == 0:\n\
    \            if string == '[':\n                brackets += 1\n            elif\
    \ string == ']':\n                brackets -= 1\n        \n        return brackets\
    \ > 0\n    \n    return inner\n\n"]
stop_tokens:
- "\ndef"
- "\n#"
- "\nif"
- "\nclass"
