{
  "name": "HumanEval_58_common",
  "language": "swift",
  "prompt": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t\tj1 = 0\n\t\tj2 = 0\n\t)\n\tfor i1 < len(l1) && j1 < len(l2) {\n\t\tif l1[i1] == l2[j1] {\n\t\t\ti1++\n\t\t\tj1++\n\t\t} else if l1[i1] < l2[j1] {\n\t\t\ti1++\n\t\t} else {\n\t\t\tj1++\n\t\t}\n\t}\n\tfor i2 < len(l1) {\n\t\ti2++\n\t}\n\tfor j2 < len(l2) {\n\t\tj2++\n\t}\n\treturn l1[i1:i2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp801ah3i7.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmp801ah3i7.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmp801ah3i7.swift:14:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && j1 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:14:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && j1 < len(l2) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:24:9: error: expected 'in' after for-each pattern\n        for i2 < len(l1) {\n               ^\n/tmp/tmp801ah3i7.swift:24:9: error: unary operator cannot be separated from its operand\n        for i2 < len(l1) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:27:9: error: expected 'in' after for-each pattern\n        for j2 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:27:9: error: unary operator cannot be separated from its operand\n        for j2 < len(l2) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmp801ah3i7.swift:14:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && j1 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:14:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                 ^~~\n/tmp/tmp801ah3i7.swift:14:22: error: cannot find 'j1' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                            ^~\n/tmp/tmp801ah3i7.swift:14:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                                 ^~~\n/tmp/tmp801ah3i7.swift:14:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && j1 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp801ah3i7.swift:24:9: error: '<' is not a prefix unary operator\n        for i2 < len(l1) {\n               ^\n/tmp/tmp801ah3i7.swift:24:11: error: cannot find 'len' in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi3pqm3rq.swift:12:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpi3pqm3rq.swift:13:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpi3pqm3rq.swift:13:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpi3pqm3rq.swift:16:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpi3pqm3rq.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpi3pqm3rq.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var cnt = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            cnt += 1\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp28_2odl7.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp28_2odl7.swift:12:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp28_2odl7.swift:12:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp28_2odl7.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp28_2odl7.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp28_2odl7.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpgwro6nis.swift:71:17: error: expected initial value after '='\n    var s: Int =\n                ^\n/tmp/tmpgwro6nis.swift:35:9: error: invalid redeclaration of 'i'\n    var i: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:9:9: note: 'i' previously declared here\n    var i: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:36:9: error: invalid redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:10:9: note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:37:9: error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:11:9: note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:38:9: error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:12:9: note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:39:9: error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:13:9: note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:40:9: error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:14:9: note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:41:9: error: invalid redeclaration of 'o'\n    var o: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:15:9: note: 'o' previously declared here\n    var o: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:42:9: error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:16:9: note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:43:9: error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:17:9: note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:44:9: error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:18:9: note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpgwro6nis.swift:45:9: error: invalid redeclaration of 's'\n    var s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpigqze330.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpigqze330.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpigqze330.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpigqze330.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpigqze330.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpigqze330.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var result = []\n    var l1_i = 0\n    var l2_i = 0\n    var l1_j = 0\n    var l2_j = 0\n    var l1_k = 0\n    var l2_k = 0\n    var l1_l = 0\n    var l2_l = 0\n    var l1_m = 0\n    var l2_m = 0\n    var l1_n = 0\n    var l2_n = 0\n    var l1_result = 0\n    var l2_result = 0\n    var l1_l1_len = 0\n    var l2_l2_len = 0\n    var l1_l1_i = 0\n    var l2_l2_i = 0\n    var l1_l1_j = 0\n    var l2_l2_j = 0\n    var l1_l1_k = 0\n    var l2_l2_k = 0\n    var l1_l1_l = 0\n    var l2_l2_l = 0\n    var l1_l1_m = 0\n    var l2_l2_m = 0\n    var l1_l1_n = 0\n    var l2_l2_n = 0\n    var l1_l1_result = 0\n    var l2_l2_result = 0\n    while i < l1_len && j < l2_len {\n        if l1[i] < l2[j] {\n            i += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp7a1akxnx.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp7a1akxnx.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp7a1akxnx.swift:16:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp7a1akxnx.swift:53:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp7a1akxnx.swift:58:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp7a1akxnx.swift:58:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var i3 = 0\n    var i4 = 0\n    var i5 = 0\n    var i6 = 0\n    var i7 = 0\n    var i8 = 0\n    var i9 = 0\n    var i10 = 0\n    var i11 = 0\n    var i12 = 0\n    var i13 = 0\n    var i14 = 0\n    var i15 = 0\n    var i16 = 0\n    var i17 = 0\n    var i18 = 0\n    var i19 = 0\n    var i20 = 0\n    var i21 = 0\n    var i22 = 0\n    var i23 = 0\n    var i24 = 0\n    var i25 = 0\n    var i26 = 0\n    var i27 = 0\n    var i28 = 0\n    var i29 = 0\n    var i30 = 0\n    var i31 = 0\n    var i32 = 0\n    var i33 = 0\n    var i34 = 0\n    var i35 = 0\n    var i36 = 0\n    var i37 = 0\n    var i38 = 0\n    var i39 = 0\n    var i40 = 0\n    var i41 = 0\n    var i42 = 0\n    var i43 = 0\n    var i44 = 0\n    var i45 = 0\n    var i46 = 0\n    var i47 = 0\n    var i48 = 0\n    var i49 = 0\n    var i50 = 0\n    var i51 = 0\n    var i52 = 0\n    var i53 = 0\n    var i54 = 0\n    var i55 = 0\n    var i56 = 0\n    var i57 = 0\n    var i58 = 0\n    var i59 = 0\n    var i60 = 0\n    var i61 = 0\n    var i62 = 0\n    var i63 = 0\n    var i64 = 0\n    var i65 = 0\n    var i66 = 0\n    var i67 = 0\n    var i68 = 0\n    var i69 = 0\n    var i70 = 0\n    var i71 = 0\n    var i72 = 0\n    var i73 = 0\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprdwm6okq.swift:8:9: warning: initialization of variable 'i1' was never used; consider replacing with assignment to '_' or removing it\n    var i1 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:9:9: warning: initialization of variable 'i2' was never used; consider replacing with assignment to '_' or removing it\n    var i2 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:10:9: warning: initialization of variable 'i3' was never used; consider replacing with assignment to '_' or removing it\n    var i3 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:11:9: warning: initialization of variable 'i4' was never used; consider replacing with assignment to '_' or removing it\n    var i4 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:12:9: warning: initialization of variable 'i5' was never used; consider replacing with assignment to '_' or removing it\n    var i5 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:13:9: warning: initialization of variable 'i6' was never used; consider replacing with assignment to '_' or removing it\n    var i6 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:14:9: warning: initialization of variable 'i7' was never used; consider replacing with assignment to '_' or removing it\n    var i7 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:15:9: warning: initialization of variable 'i8' was never used; consider replacing with assignment to '_' or removing it\n    var i8 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:16:9: warning: initialization of variable 'i9' was never used; consider replacing with assignment to '_' or removing it\n    var i9 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:17:9: warning: initialization of variable 'i10' was never used; consider replacing with assignment to '_' or removing it\n    var i10 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:18:9: warning: initialization of variable 'i11' was never used; consider replacing with assignment to '_' or removing it\n    var i11 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:19:9: warning: initialization of variable 'i12' was never used; consider replacing with assignme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) and i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpke3u7nb_.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpke3u7nb_.swift:11:24: error: expected '{' after 'while' condition\n    while i1 < len(l1) and i2 < len(l2) {\n                       ^\n/tmp/tmpke3u7nb_.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpke3u7nb_.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpke3u7nb_.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpke3u7nb_.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpke3u7nb_.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpke3u7nb_.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) and i2 < len(l2) {\n               ^~~\n/tmp/tmpke3u7nb_.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpke3u7nb_.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpke3u7nb_.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    let i = 0\n    let j = 0\n    let common = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpm1oa_je8.swift:10:18: error: empty collection literal requires an explicit type\n    let common = []\n                 ^~\n/tmp/tmpm1oa_je8.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpm1oa_je8.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpm1oa_je8.swift:13:20: error: cannot use mutating member on immutable value: 'common' is a 'let' constant\n            common.append(l1[i])\n            ~~~~~~ ^\n/tmp/tmpm1oa_je8.swift:10:5: note: change 'let' to 'var' to make it mutable\n    let common = []\n    ^~~\n    var\n/tmp/tmpm1oa_je8.swift:14:15: error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n            i += 1\n            ~ ^\n/tmp/tmpm1oa_je8.swift:8:5: note: change 'let' to 'var' to make it mutable\n    let i = 0\n    ^~~\n    var\n/tmp/tmpm1oa_je8.swift:15:15: error: left side of mutating operator isn't mutable: 'j' is a 'let' constant\n            j += 1\n            ~ ^\n/tmp/tmpm1oa_je8.swift:9:5: note: change 'let' to 'var' to make it mutable\n    let j = 0\n    ^~~\n    var\n/tmp/tmpm1oa_je8.swift:17:15: error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n            i += 1\n            ~ ^\n/tmp/tmpm1oa_je8.swift:8:5: note: change 'let' to 'var' to make it mutable\n    let i = 0\n    ^~~\n    var\n/tmp/tmpm1oa_je8.swift:19:15: error: left side of mutating operator isn't mutable: 'j' is a 'let' constant\n            j += 1\n            ~ ^\n/tmp/tmpm1oa_je8.swift:9:5: note: change 'let' to 'var' to make it mutable\n    let j = 0\n    ^~~\n    var\n/tmp/tmpm1oa_je8.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpm1oa_je8.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp10y8x_uj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp10y8x_uj.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp10y8x_uj.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp10y8x_uj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp10y8x_uj.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp10y8x_uj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp10y8x_uj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp10y8x_uj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp10y8x_uj.swift:13:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmp10y8x_uj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp10y8x_uj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    while i1 < len(l1) && j1 < len(l2) {\n        if l1[i1] == l2[j1] {\n            result = append(result, l1[i1])\n            i1 += 1\n            j1 += 1\n        } else if l1[i1] < l2[j1] {\n            i1 += 1\n        } else {\n            j1 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpemtfgt61.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpemtfgt61.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpemtfgt61.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpemtfgt61.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpemtfgt61.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpemtfgt61.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpemtfgt61.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpemtfgt61.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpemtfgt61.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n/tmp/tmpemtfgt61.swift:13:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && j1 < len(l2) {\n               ^~~\n/tmp/tmpemtfgt61.swift:13:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && j1 < len(l2) {\n                               ^~~\n/tmp/tmpemtfgt61.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpcmpsf7pj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpcmpsf7pj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcmpsf7pj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcmpsf7pj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpcmpsf7pj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpcmpsf7pj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var common = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            common = append(common, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpq141f9z_.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpq141f9z_.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpq141f9z_.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpq141f9z_.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpq141f9z_.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpq141f9z_.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpq141f9z_.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpq141f9z_.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpq141f9z_.swift:13:22: error: cannot find 'append' in scope\n            common = append(common, l1[i1])\n                     ^~~~~~\n/tmp/tmpq141f9z_.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpq141f9z_.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int{}\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp47a4wwac.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{}\n                   ^\n                   ;\n/tmp/tmp47a4wwac.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp47a4wwac.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp47a4wwac.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int{}\n                 ^~\n/tmp/tmp47a4wwac.swift:10:20: error: no exact matches in call to initializer \n    var result = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int{}\n    var l1_index = 0\n    var l2_index = 0\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpbqlnxn4d.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int{}\n                   ^\n                   ;\n/tmp/tmpbqlnxn4d.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpbqlnxn4d.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpbqlnxn4d.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int{}\n                 ^~\n/tmp/tmpbqlnxn4d.swift:13:20: error: no exact matches in call to initializer \n    var common = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryIn",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpm_8apw2i.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpm_8apw2i.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpm_8apw2i.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpm_8apw2i.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpm_8apw2i.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpm_8apw2i.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var m = 0\n    var n = 0\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var result = []\n    var l1_index = 0\n    var l2_index = 0\n    var l1_value = l1[0]\n    var l2_value = l2[0]\n    while l1_index < l1_len && l2_index < l2_len {\n        if l1_value == l2_value {\n            result = append(result, l1_value)\n            l1_index += 1\n            l2_index += 1\n            l1_value = l1[l1_index]\n            l2_value = l2[l2_index]\n        } else if l1_value < l2_value {\n            l1_index += 1\n            l1_value = l1[l1_index]\n        } else {\n            l2_index += 1\n            l2_value = l2[l2_index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmplbu2er0m.swift:13:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmplbu2er0m.swift:14:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmplbu2er0m.swift:15:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmplbu2er0m.swift:22:22: error: cannot find 'append' in scope\n            result = append(result, l1_value)\n                     ^~~~~~\n/tmp/tmplbu2er0m.swift:35:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmplbu2er0m.swift:35:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i1, i2 int\n\tvar result []Int\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\tresult = append(result, l1[i1])\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprx12l_15.swift:10:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i1, i2 int\n                   ^\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together\n        var i1, i2 int\n                ~~~^~~\n                i2int\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together with camel-case\n        var i1, i2 int\n                ~~~^~~\n                i2Int\n/tmp/tmprx12l_15.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmprx12l_15.swift:11:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmprx12l_15.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmprx12l_15.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmprx12l_15.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:10:6: error: type annotation missing in pattern\n        var i1, i2 int\n            ^\n/tmp/tmprx12l_15.swift:10:10: error: type annotation missing in pattern\n        var i1, i2 int\n                ^\n/tmp/tmprx12l_15.swift:11:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmprx12l_15.swift:11:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:15: error: expected member name or constructor call after type name\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) and i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpke3u7nb_.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpke3u7nb_.swift:11:24: error: expected '{' after 'while' condition\n    while i1 < len(l1) and i2 < len(l2) {\n                       ^\n/tmp/tmpke3u7nb_.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpke3u7nb_.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpke3u7nb_.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpke3u7nb_.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpke3u7nb_.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpke3u7nb_.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) and i2 < len(l2) {\n               ^~~\n/tmp/tmpke3u7nb_.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpke3u7nb_.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpke3u7nb_.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[i] {\n            result = append(result, l1[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpvf261pvk.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpvf261pvk.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpvf261pvk.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmpvf261pvk.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpvf261pvk.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpvf261pvk.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpvf261pvk.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpvf261pvk.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpcmpsf7pj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpcmpsf7pj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcmpsf7pj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcmpsf7pj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpcmpsf7pj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpcmpsf7pj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var cnt = 0\n    var res = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            cnt += 1\n            res = append(res, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp3qt0hm1n.swift:11:15: error: empty collection literal requires an explicit type\n    var res = []\n              ^~\n/tmp/tmp3qt0hm1n.swift:12:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp3qt0hm1n.swift:12:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp3qt0hm1n.swift:15:19: error: cannot find 'append' in scope\n            res = append(res, l1[i1])\n                  ^~~~~~\n/tmp/tmp3qt0hm1n.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return res\n           ^\n/tmp/tmp3qt0hm1n.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return res\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var l1_idx = 0\n    var l2_idx = 0\n    var common = []Int{}\n    for l1_idx < l1_len && l2_idx < l2_len {\n        if l1[l1_idx] == l2[l2_idx] {\n            common = append(common, l1[l1_idx])\n            l1_idx += 1\n            l2_idx += 1\n        } else if l1[l1_idx] > l2[l2_idx] {\n            l2_idx += 1\n        } else {\n            l1_idx += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpuusjhn87.swift:12:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int{}\n                   ^\n                   ;\n/tmp/tmpuusjhn87.swift:13:16: error: expected 'in' after for-each pattern\n    for l1_idx < l1_len && l2_idx < l2_len {\n               ^\n/tmp/tmpuusjhn87.swift:13:16: error: unary operator cannot be separated from its operand\n    for l1_idx < l1_len && l2_idx < l2_len {\n               ^~\n                \n/tmp/tmpuusjhn87.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpuusjhn87.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpuusjhn87.swift:12:18: error: empty collection literal requires an explicit type\n    var common = []Int{}\n                 ^~\n/tmp/tmpuusjhn87.swift:12:20: error: no exact matches in call to initializer \n    var common = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlina",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result = []Int\n    var i = 0\n    var j = 0\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    var l1Idx = 0\n    var l2Idx = 0\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i++\n            j++\n        } else if l1[i] > l2[j] {\n            j++\n        } else {\n            i++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp25gj3e0k.swift:8:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp25gj3e0k.swift:8:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp25gj3e0k.swift:8:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp25gj3e0k.swift:8:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp25gj3e0k.swift:8:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp25gj3e0k.swift:8:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp25gj3e0k.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp25gj3e0k.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp25gj3e0k.swift:17:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp25gj3e0k.swift:18:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmp25gj3e0k.swift:19:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmp25gj3e0k.swift:21:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmp25gj3e0k.swift:23:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmp25gj3e0k.swift:26:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp25gj3e0k.swift:26:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var c = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            c = append(c, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpo3pzbb7y.swift:10:15: error: consecutive statements on a line must be separated by ';'\n    var c = []Int\n              ^\n              ;\n/tmp/tmpo3pzbb7y.swift:10:13: error: empty collection literal requires an explicit type\n    var c = []Int\n            ^~\n/tmp/tmpo3pzbb7y.swift:10:15: error: expected member name or constructor call after type name\n    var c = []Int\n              ^\n/tmp/tmpo3pzbb7y.swift:10:15: note: add arguments after the type to construct a value of the type\n    var c = []Int\n              ^\n                 ()\n/tmp/tmpo3pzbb7y.swift:10:15: note: use '.self' to reference the type object\n    var c = []Int\n              ^\n                 .self\n/tmp/tmpo3pzbb7y.swift:10:15: warning: expression of type 'Int.Type' is unused\n    var c = []Int\n              ^~~\n/tmp/tmpo3pzbb7y.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpo3pzbb7y.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpo3pzbb7y.swift:13:17: error: cannot find 'append' in scope\n            c = append(c, l1[i1])\n                ^~~~~~\n/tmp/tmpo3pzbb7y.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return c\n           ^\n/tmp/tmpo3pzbb7y.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return c\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpyglo9ph4.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpyglo9ph4.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpyglo9ph4.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpyglo9ph4.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpyglo9ph4.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpyglo9ph4.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t\tj1 = 0\n\t\tj2 = 0\n\t)\n\tfor i1 < len(l1) && j1 < len(l2) {\n\t\tif l1[i1] == l2[j1] {\n\t\t\ti1++\n\t\t\tj1++\n\t\t} else if l1[i1] < l2[j1] {\n\t\t\ti1++\n\t\t} else {\n\t\t\tj1++\n\t\t}\n\t}\n\tfor i2 < len(l1) {\n\t\ti2++\n\t}\n\tfor j2 < len(l2) {\n\t\tj2++\n\t}\n\treturn l1[i1:i2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp801ah3i7.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmp801ah3i7.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmp801ah3i7.swift:14:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && j1 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:14:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && j1 < len(l2) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:24:9: error: expected 'in' after for-each pattern\n        for i2 < len(l1) {\n               ^\n/tmp/tmp801ah3i7.swift:24:9: error: unary operator cannot be separated from its operand\n        for i2 < len(l1) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:27:9: error: expected 'in' after for-each pattern\n        for j2 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:27:9: error: unary operator cannot be separated from its operand\n        for j2 < len(l2) {\n               ^~\n                \n/tmp/tmp801ah3i7.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmp801ah3i7.swift:14:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && j1 < len(l2) {\n               ^\n/tmp/tmp801ah3i7.swift:14:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                 ^~~\n/tmp/tmp801ah3i7.swift:14:22: error: cannot find 'j1' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                            ^~\n/tmp/tmp801ah3i7.swift:14:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && j1 < len(l2) {\n                                 ^~~\n/tmp/tmp801ah3i7.swift:14:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && j1 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmp801ah3i7.swift:24:9: error: '<' is not a prefix unary operator\n        for i2 < len(l1) {\n               ^\n/tmp/tmp801ah3i7.swift:24:11: error: cannot find 'len' in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpkn9qp4tf.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpkn9qp4tf.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpkn9qp4tf.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpkn9qp4tf.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpkn9qp4tf.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpkn9qp4tf.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpkn9qp4tf.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpkn9qp4tf.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpkn9qp4tf.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpkn9qp4tf.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpkn9qp4tf.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpkn9qp4tf.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpkn9qp4tf.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpkn9qp4tf.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var m = 0\n    var n = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i = i + 1\n            j = j + 1\n        } else if l1[i] > l2[j] {\n            j = j + 1\n        } else {\n            i = i + 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpn1v6epp6.swift:13:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpn1v6epp6.swift:14:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpn1v6epp6.swift:14:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpn1v6epp6.swift:16:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpn1v6epp6.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpn1v6epp6.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpxb_7wmws.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpxb_7wmws.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpxb_7wmws.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpxb_7wmws.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpxb_7wmws.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpxb_7wmws.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpxb_7wmws.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpxb_7wmws.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpxb_7wmws.swift:14:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpxb_7wmws.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpxb_7wmws.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var l1_index = 0\n    var l2_index = 0\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2f4y9vjo.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp2f4y9vjo.swift:11:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp2f4y9vjo.swift:12:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp2f4y9vjo.swift:17:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp2f4y9vjo.swift:26:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2f4y9vjo.swift:26:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var cnt = 0\n    var res = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            cnt += 1\n            res = append(res, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp3qt0hm1n.swift:11:15: error: empty collection literal requires an explicit type\n    var res = []\n              ^~\n/tmp/tmp3qt0hm1n.swift:12:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp3qt0hm1n.swift:12:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp3qt0hm1n.swift:15:19: error: cannot find 'append' in scope\n            res = append(res, l1[i1])\n                  ^~~~~~\n/tmp/tmp3qt0hm1n.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return res\n           ^\n/tmp/tmp3qt0hm1n.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return res\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp0111atqc.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp0111atqc.swift:13:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp0111atqc.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmp0111atqc.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp0111atqc.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp0111atqc.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp0111atqc.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp0111atqc.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp0111atqc.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp0111atqc.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp0111atqc.swift:13:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp0111atqc.swift:13:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp0111atqc.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp0111atqc.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpigqze330.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpigqze330.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpigqze330.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpigqze330.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpigqze330.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpigqze330.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp5osxhvfo.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp5osxhvfo.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp5osxhvfo.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp5osxhvfo.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp5osxhvfo.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp5osxhvfo.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp5osxhvfo.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp5osxhvfo.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp5osxhvfo.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp5osxhvfo.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp5osxhvfo.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[i] {\n            result = append(result, l1[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpvf261pvk.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpvf261pvk.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpvf261pvk.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmpvf261pvk.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpvf261pvk.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpvf261pvk.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpvf261pvk.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpvf261pvk.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[0] {\n            result = append(result, l1[i])\n            l2 = l2[1:]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp7g53jw6b.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmp7g53jw6b.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmp7g53jw6b.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmp7g53jw6b.swift:12:22: error: expected ',' separator\n            l2 = l2[1:]\n                     ^\n                     ,\n/tmp/tmp7g53jw6b.swift:12:22: error: expected expression in list of expressions\n            l2 = l2[1:]\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var len1 = len(l1)\n    var len2 = len(l2)\n    while i < len1 && j < len2 {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpf6vqqxwf.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpf6vqqxwf.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpf6vqqxwf.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpf6vqqxwf.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpf6vqqxwf.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpf6vqqxwf.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpf6vqqxwf.swift:11:16: error: cannot find 'len' in scope\n    var len1 = len(l1)\n               ^~~\n/tmp/tmpf6vqqxwf.swift:12:16: error: cannot find 'len' in scope\n    var len2 = len(l2)\n               ^~~\n/tmp/tmpf6vqqxwf.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpf6vqqxwf.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpf6vqqxwf.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i1, i2 int\n\tvar result []Int\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\tresult = append(result, l1[i1])\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprx12l_15.swift:10:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i1, i2 int\n                   ^\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together\n        var i1, i2 int\n                ~~~^~~\n                i2int\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together with camel-case\n        var i1, i2 int\n                ~~~^~~\n                i2Int\n/tmp/tmprx12l_15.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmprx12l_15.swift:11:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmprx12l_15.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmprx12l_15.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmprx12l_15.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:10:6: error: type annotation missing in pattern\n        var i1, i2 int\n            ^\n/tmp/tmprx12l_15.swift:10:10: error: type annotation missing in pattern\n        var i1, i2 int\n                ^\n/tmp/tmprx12l_15.swift:11:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmprx12l_15.swift:11:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:15: error: expected member name or constructor call after type name\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    for i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpysh1sh_6.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpysh1sh_6.swift:14:11: error: expected 'in' after for-each pattern\n    for i < l1_len && j < l2_len {\n          ^\n/tmp/tmpysh1sh_6.swift:14:11: error: unary operator cannot be separated from its operand\n    for i < l1_len && j < l2_len {\n          ^~\n           \n/tmp/tmpysh1sh_6.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpysh1sh_6.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpysh1sh_6.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpysh1sh_6.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpysh1sh_6.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpysh1sh_6.swift:12:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpysh1sh_6.swift:13:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpysh1sh_6.swift:14:11: error: '<' is not a prefix unary operator\n    for i < l1_len && j < l2_len {\n          ^\n/tmp/tmpysh1sh_6.swift:14:20: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1_len && j < l2_len {\n          ~~~~~~~~~^~~~~~~~~~~~~\n/tmp/tmpysh1sh_6.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpysh1sh_6.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var i3 = 0\n    var i4 = 0\n    var i5 = 0\n    var i6 = 0\n    var i7 = 0\n    var i8 = 0\n    var i9 = 0\n    var i10 = 0\n    var i11 = 0\n    var i12 = 0\n    var i13 = 0\n    var i14 = 0\n    var i15 = 0\n    var i16 = 0\n    var i17 = 0\n    var i18 = 0\n    var i19 = 0\n    var i20 = 0\n    var i21 = 0\n    var i22 = 0\n    var i23 = 0\n    var i24 = 0\n    var i25 = 0\n    var i26 = 0\n    var i27 = 0\n    var i28 = 0\n    var i29 = 0\n    var i30 = 0\n    var i31 = 0\n    var i32 = 0\n    var i33 = 0\n    var i34 = 0\n    var i35 = 0\n    var i36 = 0\n    var i37 = 0\n    var i38 = 0\n    var i39 = 0\n    var i40 = 0\n    var i41 = 0\n    var i42 = 0\n    var i43 = 0\n    var i44 = 0\n    var i45 = 0\n    var i46 = 0\n    var i47 = 0\n    var i48 = 0\n    var i49 = 0\n    var i50 = 0\n    var i51 = 0\n    var i52 = 0\n    var i53 = 0\n    var i54 = 0\n    var i55 = 0\n    var i56 = 0\n    var i57 = 0\n    var i58 = 0\n    var i59 = 0\n    var i60 = 0\n    var i61 = 0\n    var i62 = 0\n    var i63 = 0\n    var i64 = 0\n    var i65 = 0\n    var i66 = 0\n    var i67 = 0\n    var i68 = 0\n    var i69 = 0\n    var i70 = 0\n    var i71 = 0\n    var i72 = 0\n    var i73 = 0\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprdwm6okq.swift:8:9: warning: initialization of variable 'i1' was never used; consider replacing with assignment to '_' or removing it\n    var i1 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:9:9: warning: initialization of variable 'i2' was never used; consider replacing with assignment to '_' or removing it\n    var i2 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:10:9: warning: initialization of variable 'i3' was never used; consider replacing with assignment to '_' or removing it\n    var i3 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:11:9: warning: initialization of variable 'i4' was never used; consider replacing with assignment to '_' or removing it\n    var i4 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:12:9: warning: initialization of variable 'i5' was never used; consider replacing with assignment to '_' or removing it\n    var i5 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:13:9: warning: initialization of variable 'i6' was never used; consider replacing with assignment to '_' or removing it\n    var i6 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:14:9: warning: initialization of variable 'i7' was never used; consider replacing with assignment to '_' or removing it\n    var i7 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:15:9: warning: initialization of variable 'i8' was never used; consider replacing with assignment to '_' or removing it\n    var i8 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:16:9: warning: initialization of variable 'i9' was never used; consider replacing with assignment to '_' or removing it\n    var i9 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:17:9: warning: initialization of variable 'i10' was never used; consider replacing with assignment to '_' or removing it\n    var i10 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:18:9: warning: initialization of variable 'i11' was never used; consider replacing with assignment to '_' or removing it\n    var i11 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:19:9: warning: initialization of variable 'i12' was never used; consider replacing with assignme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = make([]Int, 0)\n    var l1_i = 0\n    var l2_i = 0\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp10mlm2ia.swift:13:25: error: expected ',' separator\n    var common = make([]Int, 0)\n                        ^\n                        ,\n/tmp/tmp10mlm2ia.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp10mlm2ia.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp10mlm2ia.swift:13:18: error: cannot find 'make' in scope\n    var common = make([]Int, 0)\n                 ^~~~\n/tmp/tmp10mlm2ia.swift:18:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpw7hof8u6.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpw7hof8u6.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpw7hof8u6.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpw7hof8u6.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpw7hof8u6.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpw7hof8u6.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpw7hof8u6.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmpw7hof8u6.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmpw7hof8u6.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpw7hof8u6.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpw7hof8u6.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpnwr72w8m.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpnwr72w8m.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpnwr72w8m.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpnwr72w8m.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpnwr72w8m.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpnwr72w8m.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpnwr72w8m.swift:16:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpnwr72w8m.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpnwr72w8m.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar common = make([]Int, 0)\n\tfor i := 0; i < len(l1); i++ {\n\t\tfor j := 0; j < len(l2); j++ {\n\t\t\tif l1[i] == l2[j] {\n\t\t\t\tcommon = append(common, l1[i])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpaevy6r9t.swift:8:22: error: expected ',' separator\n        var common = make([]Int, 0)\n                            ^\n                            ,\n/tmp/tmpaevy6r9t.swift:9:9: error: expected type\n        for i := 0; i < len(l1); i++ {\n               ^\n                <#type#>\n/tmp/tmpaevy6r9t.swift:9:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(l1); i++ {\n               ^\n/tmp/tmpaevy6r9t.swift:9:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(l1); i++ {\n               ^\n/tmp/tmpaevy6r9t.swift:10:10: error: expected type\n                for j := 0; j < len(l2); j++ {\n                       ^\n                        <#type#>\n/tmp/tmpaevy6r9t.swift:10:10: error: expected 'in' after for-each pattern\n                for j := 0; j < len(l2); j++ {\n                       ^\n/tmp/tmpaevy6r9t.swift:10:10: error: expected Sequence expression for for-each loop\n                for j := 0; j < len(l2); j++ {\n                       ^\n/tmp/tmpaevy6r9t.swift:8:15: error: cannot find 'make' in scope\n        var common = make([]Int, 0)\n                     ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var i3 = 0\n    var i4 = 0\n    var i5 = 0\n    var i6 = 0\n    var i7 = 0\n    var i8 = 0\n    var i9 = 0\n    var i10 = 0\n    var i11 = 0\n    var i12 = 0\n    var i13 = 0\n    var i14 = 0\n    var i15 = 0\n    var i16 = 0\n    var i17 = 0\n    var i18 = 0\n    var i19 = 0\n    var i20 = 0\n    var i21 = 0\n    var i22 = 0\n    var i23 = 0\n    var i24 = 0\n    var i25 = 0\n    var i26 = 0\n    var i27 = 0\n    var i28 = 0\n    var i29 = 0\n    var i30 = 0\n    var i31 = 0\n    var i32 = 0\n    var i33 = 0\n    var i34 = 0\n    var i35 = 0\n    var i36 = 0\n    var i37 = 0\n    var i38 = 0\n    var i39 = 0\n    var i40 = 0\n    var i41 = 0\n    var i42 = 0\n    var i43 = 0\n    var i44 = 0\n    var i45 = 0\n    var i46 = 0\n    var i47 = 0\n    var i48 = 0\n    var i49 = 0\n    var i50 = 0\n    var i51 = 0\n    var i52 = 0\n    var i53 = 0\n    var i54 = 0\n    var i55 = 0\n    var i56 = 0\n    var i57 = 0\n    var i58 = 0\n    var i59 = 0\n    var i60 = 0\n    var i61 = 0\n    var i62 = 0\n    var i63 = 0\n    var i64 = 0\n    var i65 = 0\n    var i66 = 0\n    var i67 = 0\n    var i68 = 0\n    var i69 = 0\n    var i70 = 0\n    var i71 = 0\n    var i72 = 0\n    var i73 = 0\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprdwm6okq.swift:8:9: warning: initialization of variable 'i1' was never used; consider replacing with assignment to '_' or removing it\n    var i1 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:9:9: warning: initialization of variable 'i2' was never used; consider replacing with assignment to '_' or removing it\n    var i2 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:10:9: warning: initialization of variable 'i3' was never used; consider replacing with assignment to '_' or removing it\n    var i3 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:11:9: warning: initialization of variable 'i4' was never used; consider replacing with assignment to '_' or removing it\n    var i4 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:12:9: warning: initialization of variable 'i5' was never used; consider replacing with assignment to '_' or removing it\n    var i5 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:13:9: warning: initialization of variable 'i6' was never used; consider replacing with assignment to '_' or removing it\n    var i6 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:14:9: warning: initialization of variable 'i7' was never used; consider replacing with assignment to '_' or removing it\n    var i7 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:15:9: warning: initialization of variable 'i8' was never used; consider replacing with assignment to '_' or removing it\n    var i8 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:16:9: warning: initialization of variable 'i9' was never used; consider replacing with assignment to '_' or removing it\n    var i9 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:17:9: warning: initialization of variable 'i10' was never used; consider replacing with assignment to '_' or removing it\n    var i10 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:18:9: warning: initialization of variable 'i11' was never used; consider replacing with assignment to '_' or removing it\n    var i11 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:19:9: warning: initialization of variable 'i12' was never used; consider replacing with assignme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result = []Int\n    var i = 0\n    var j = 0\n    var k = 0\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var l1_index = 0\n    var l2_index = 0\n    var l1_value = l1[0]\n    var l2_value = l2[0]\n    while i < l1_len && j < l2_len {\n        if l1_value == l2_value {\n            result = append(result, l1[l1_index])\n            l1_index += 1\n            l2_index += 1\n            if l1_index == l1_len {\n                break\n            }\n            if l2_index == l2_len {\n                break\n            }\n            l1_value = l1[l1_index]\n            l2_value = l2[l2_index]\n        } else if l1_value < l2_value {\n            l1_index += 1\n            if l1_index == l1_len {\n                break\n            }\n            l1_value = l1[l1_index]\n        } else {\n            l2_index += 1\n            if l2_index == l2_len {\n                break\n            }\n            l2_value = l2[l2_index]\n        }\n        k += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72az3phs.swift:8:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72az3phs.swift:8:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72az3phs.swift:8:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72az3phs.swift:8:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72az3phs.swift:8:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72az3phs.swift:8:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72az3phs.swift:12:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp72az3phs.swift:13:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp72az3phs.swift:20:22: error: cannot find 'append' in scope\n            result = append(result, l1[l1_index])\n                     ^~~~~~\n/tmp/tmp72az3phs.swift:46:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72az3phs.swift:46:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpq8u1mnfu.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpq8u1mnfu.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpq8u1mnfu.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpq8u1mnfu.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpq8u1mnfu.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpq8u1mnfu.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpq8u1mnfu.swift:11:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpq8u1mnfu.swift:12:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpq8u1mnfu.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpq8u1mnfu.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpq8u1mnfu.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpcket6ssr.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpcket6ssr.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcket6ssr.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcket6ssr.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpcket6ssr.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpcket6ssr.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar i = 0\n\tvar j = 0\n\tvar result = []Int{}\n\tfor i < len(l1) && j < len(l2) {\n\t\tif l1[i] == l2[j] {\n\t\t\tresult = append(result, l1[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else if l1[i] > l2[j] {\n\t\t\tj++\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpzauqxdn6.swift:10:17: error: consecutive statements on a line must be separated by ';'\n        var result = []Int{}\n                       ^\n                       ;\n/tmp/tmpzauqxdn6.swift:11:8: error: expected 'in' after for-each pattern\n        for i < len(l1) && j < len(l2) {\n              ^\n/tmp/tmpzauqxdn6.swift:11:8: error: unary operator cannot be separated from its operand\n        for i < len(l1) && j < len(l2) {\n              ^~\n               \n/tmp/tmpzauqxdn6.swift:10:15: error: empty collection literal requires an explicit type\n        var result = []Int{}\n                     ^~\n/tmp/tmpzauqxdn6.swift:10:17: error: no exact matches in call to initializer \n        var result = []Int{}\n                       ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp15k92fgu.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp15k92fgu.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp15k92fgu.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp15k92fgu.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp15k92fgu.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int{}\n    for i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpth57d6nv.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int{}\n                   ^\n                   ;\n/tmp/tmpth57d6nv.swift:14:11: error: expected 'in' after for-each pattern\n    for i < l1_len && j < l2_len {\n          ^\n/tmp/tmpth57d6nv.swift:14:11: error: unary operator cannot be separated from its operand\n    for i < l1_len && j < l2_len {\n          ^~\n           \n/tmp/tmpth57d6nv.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpth57d6nv.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpth57d6nv.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int{}\n                 ^~\n/tmp/tmpth57d6nv.swift:13:20: error: no exact matches in call to initializer \n    var common = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) whe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var common = []Int\n    var i = 0\n    var j = 0\n    var k = 0\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpcpfct88d.swift:8:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpcpfct88d.swift:8:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpcpfct88d.swift:8:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpcpfct88d.swift:8:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpcpfct88d.swift:8:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpcpfct88d.swift:8:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpcpfct88d.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcpfct88d.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcpfct88d.swift:14:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpcpfct88d.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpcpfct88d.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp2d5x9xet.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp2d5x9xet.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp2d5x9xet.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp2d5x9xet.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp2d5x9xet.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp2d5x9xet.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp2d5x9xet.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp2d5x9xet.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp2d5x9xet.swift:15:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmp2d5x9xet.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp2d5x9xet.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n        if l2.contains(i) {\n            result.append(i)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "tmpafy3mqqi/tmpafy3mqqi.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f41558c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f4124fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f4124f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f4124e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpafy3mqqi                        0x000055a7bab5c67c <unavailable> + 5756\n5    libc.so.6                          0x00002b3f41744460 __libc_start_main + 245\n6    tmpafy3mqqi                        0x000055a7bab5c1f9 <unavailable> + 4601\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    var result = []\n    while i1 < len(l1) and j1 < len(l2) {\n        if l1[i1] == l2[j1] {\n            result = append(result, l1[i1])\n            i1 += 1\n            j1 += 1\n        } else if l1[i1] < l2[j1] {\n            i1 += 1\n        } else {\n            j1 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpmenntso3.swift:13:24: error: expected '{' after 'while' condition\n    while i1 < len(l1) and j1 < len(l2) {\n                       ^\n/tmp/tmpmenntso3.swift:12:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpmenntso3.swift:13:16: error: cannot find 'len' in scope\n    while i1 < len(l1) and j1 < len(l2) {\n               ^~~\n/tmp/tmpmenntso3.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpmenntso3.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpmenntso3.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    let l1_len = len(l1)\n    let l2_len = len(l2)\n    let l1_set = new Set(l1)\n    let l2_set = new Set(l2)\n    let common = []\n    for i in l1_set {\n        if l2_set.has(i) {\n            common.append(i)\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp0epcgp0w.swift:10:21: error: consecutive statements on a line must be separated by ';'\n    let l1_set = new Set(l1)\n                    ^\n                    ;\n/tmp/tmp0epcgp0w.swift:11:21: error: consecutive statements on a line must be separated by ';'\n    let l2_set = new Set(l2)\n                    ^\n                    ;\n/tmp/tmp0epcgp0w.swift:8:18: error: cannot find 'len' in scope\n    let l1_len = len(l1)\n                 ^~~\n/tmp/tmp0epcgp0w.swift:9:18: error: cannot find 'len' in scope\n    let l2_len = len(l2)\n                 ^~~\n/tmp/tmp0epcgp0w.swift:10:18: error: cannot find 'new' in scope\n    let l1_set = new Set(l1)\n                 ^~~\n/tmp/tmp0epcgp0w.swift:10:22: warning: result of 'Set<Element>' initializer is unused\n    let l1_set = new Set(l1)\n                     ^  ~~~~\n/tmp/tmp0epcgp0w.swift:11:18: error: cannot find 'new' in scope\n    let l2_set = new Set(l2)\n                 ^~~\n/tmp/tmp0epcgp0w.swift:11:22: warning: result of 'Set<Element>' initializer is unused\n    let l2_set = new Set(l2)\n                     ^  ~~~~\n/tmp/tmp0epcgp0w.swift:12:18: error: empty collection literal requires an explicit type\n    let common = []\n                 ^~\n/tmp/tmp0epcgp0w.swift:18:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp0epcgp0w.swift:18:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpcnjv2gti.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpcnjv2gti.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcnjv2gti.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcnjv2gti.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpcnjv2gti.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpcnjv2gti.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    var i = 0\n    var j = 0\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpptv8g5u3.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpptv8g5u3.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpptv8g5u3.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpptv8g5u3.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpptv8g5u3.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpptv8g5u3.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpptv8g5u3.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpptv8g5u3.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpptv8g5u3.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpptv8g5u3.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpptv8g5u3.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n/tmp/tmpptv8g5u3.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpptv8g5u3.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpptv8g5u3.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpptv8g5u3.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i, j int\n\tvar result []Int\n\tfor i < len(l1) && j < len(l2) {\n\t\tif l1[i] == l2[j] {\n\t\t\tresult = append(result, l1[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else if l1[i] < l2[j] {\n\t\t\ti++\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp97kbgfv1.swift:10:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i, j int\n                 ^\n/tmp/tmp97kbgfv1.swift:10:11: note: join the identifiers together\n        var i, j int\n               ~~^~~\n               jint\n/tmp/tmp97kbgfv1.swift:10:11: note: join the identifiers together with camel-case\n        var i, j int\n               ~~^~~\n               jInt\n/tmp/tmp97kbgfv1.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmp97kbgfv1.swift:11:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmp97kbgfv1.swift:12:8: error: expected 'in' after for-each pattern\n        for i < len(l1) && j < len(l2) {\n              ^\n/tmp/tmp97kbgfv1.swift:12:8: error: unary operator cannot be separated from its operand\n        for i < len(l1) && j < len(l2) {\n              ^~\n               \n/tmp/tmp97kbgfv1.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmp97kbgfv1.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmp97kbgfv1.swift:10:6: error: type annotation missing in pattern\n        var i, j int\n            ^\n/tmp/tmp97kbgfv1.swift:10:9: error: type annotation missing in pattern\n        var i, j int\n               ^\n/tmp/tmp97kbgfv1.swift:11:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmp97kbgfv1.swift:11:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmp97kbgfv1.swift:11:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmp97kbgfv1.swift:11:15: error: expected member name or constructor call after type name\n        var result []Int\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t)\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn l1[:i1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpvykslgh1.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmpvykslgh1.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmpvykslgh1.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpvykslgh1.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpvykslgh1.swift:22:12: error: expected expression in list of expressions\n        return l1[:i1]\n                  ^\n/tmp/tmpvykslgh1.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmpvykslgh1.swift:12:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpvykslgh1.swift:12:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                 ^~~\n/tmp/tmpvykslgh1.swift:12:22: error: cannot find 'i2' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                            ^~\n/tmp/tmpvykslgh1.swift:12:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                                 ^~~\n/tmp/tmpvykslgh1.swift:12:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && i2 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpvykslgh1.swift:22:15: error: missing argument for parameter #1 in call\n        return l1[:i1]\n                     ^\n                     <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\n/tmp/tmpvykslgh1.swift:22:11: error: no 'subscript' candidates produce the expected contextual result type '[Int]'\n        return l1[:i1]\n                 ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not the expected contextual result type '[Int]'\n    @inlinable public",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp0111atqc.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp0111atqc.swift:13:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp0111atqc.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmp0111atqc.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp0111atqc.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp0111atqc.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp0111atqc.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp0111atqc.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp0111atqc.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp0111atqc.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp0111atqc.swift:13:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp0111atqc.swift:13:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp0111atqc.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp0111atqc.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[i] {\n            result = append(result, l1[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpvf261pvk.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpvf261pvk.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpvf261pvk.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmpvf261pvk.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpvf261pvk.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpvf261pvk.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpvf261pvk.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpvf261pvk.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    var k1 = 0\n    var k2 = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    while j1 < len(l1) {\n        if l1[j1] == l2[j2] {\n            result = append(result, l1[j1])\n            j1 += 1\n            j2 += 1\n        } else if l1[j1] < l2[j2] {\n            j1 += 1\n        } else {\n            j2 += 1\n        }\n    }\n    while k1 < len(l1) {\n        if l1[k1] == l2[k2] {\n            result = append(result, l1[k1])\n            k1 += 1\n            k2 += 1\n        } else if l1[k1] < l2[k2] {\n            k1 += 1\n        } else {\n            k2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmplx5dog2i.swift:14:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmplx5dog2i.swift:15:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmplx5dog2i.swift:15:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmplx5dog2i.swift:17:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmplx5dog2i.swift:26:16: error: cannot find 'len' in scope\n    while j1 < len(l1) {\n               ^~~\n/tmp/tmplx5dog2i.swift:28:22: error: cannot find 'append' in scope\n            result = append(result, l1[j1])\n                     ^~~~~~\n/tmp/tmplx5dog2i.swift:37:16: error: cannot find 'len' in scope\n    while k1 < len(l1) {\n               ^~~\n/tmp/tmplx5dog2i.swift:39:22: error: cannot find 'append' in scope\n            result = append(result, l1[k1])\n                     ^~~~~~\n/tmp/tmplx5dog2i.swift:48:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmplx5dog2i.swift:48:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpyglo9ph4.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpyglo9ph4.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpyglo9ph4.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpyglo9ph4.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpyglo9ph4.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpyglo9ph4.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar i, j int\n\tvar result []Int\n\tfor i < len(l1) && j < len(l2) {\n\t\tif l1[i] == l2[j] {\n\t\t\tresult = append(result, l1[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else if l1[i] < l2[j] {\n\t\t\ti++\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp2y05l9qt.swift:8:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i, j int\n                 ^\n/tmp/tmp2y05l9qt.swift:8:11: note: join the identifiers together\n        var i, j int\n               ~~^~~\n               jint\n/tmp/tmp2y05l9qt.swift:8:11: note: join the identifiers together with camel-case\n        var i, j int\n               ~~^~~\n               jInt\n/tmp/tmp2y05l9qt.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmp2y05l9qt.swift:9:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmp2y05l9qt.swift:10:8: error: expected 'in' after for-each pattern\n        for i < len(l1) && j < len(l2) {\n              ^\n/tmp/tmp2y05l9qt.swift:10:8: error: unary operator cannot be separated from its operand\n        for i < len(l1) && j < len(l2) {\n              ^~\n               \n/tmp/tmp2y05l9qt.swift:8:6: error: type annotation missing in pattern\n        var i, j int\n            ^\n/tmp/tmp2y05l9qt.swift:8:9: error: type annotation missing in pattern\n        var i, j int\n               ^\n/tmp/tmp2y05l9qt.swift:9:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmp2y05l9qt.swift:9:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmp2y05l9qt.swift:9:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmp2y05l9qt.swift:9:15: error: expected member name or constructor call after type name\n        var result []Int\n                     ^\n/tmp/tmp2y05l9qt.swift:9:15: note: add arguments after the type to construct a value of the type\n        var result []Int\n                     ^\n                        ()\n/tmp/tmp2y05l9qt.swift:9:15: note: use '.self' to reference the type object\n        var result []Int\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpm_8apw2i.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpm_8apw2i.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpm_8apw2i.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpm_8apw2i.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpm_8apw2i.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpm_8apw2i.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpnwr72w8m.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpnwr72w8m.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpnwr72w8m.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpnwr72w8m.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpnwr72w8m.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpnwr72w8m.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpnwr72w8m.swift:16:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpnwr72w8m.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpnwr72w8m.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int{}\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp47a4wwac.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{}\n                   ^\n                   ;\n/tmp/tmp47a4wwac.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp47a4wwac.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp47a4wwac.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int{}\n                 ^~\n/tmp/tmp47a4wwac.swift:10:20: error: no exact matches in call to initializer \n    var result = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpjior1upg.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpjior1upg.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpjior1upg.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpjior1upg.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpjior1upg.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpjior1upg.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpjior1upg.swift:11:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpjior1upg.swift:12:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpjior1upg.swift:15:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpjior1upg.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpjior1upg.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i++\n            j++\n        } else if l1[i] < l2[j] {\n            i++\n        } else {\n            j++\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpuub2q_jn.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpuub2q_jn.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpuub2q_jn.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpuub2q_jn.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpuub2q_jn.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpuub2q_jn.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpuub2q_jn.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpuub2q_jn.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpuub2q_jn.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpuub2q_jn.swift:15:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpuub2q_jn.swift:16:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmpuub2q_jn.swift:18:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            i++\n             ^~\n/tmp/tmpuub2q_jn.swift:20:14: error: cannot find operator '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmpuub2q_jn.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpuub2q_jn.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp3tgt1t0v.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp3tgt1t0v.swift:12:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp3tgt1t0v.swift:12:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp3tgt1t0v.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp3tgt1t0v.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp3tgt1t0v.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp3tgt1t0v.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp3tgt1t0v.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp3tgt1t0v.swift:12:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp3tgt1t0v.swift:12:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmp3tgt1t0v.swift:12:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmp3tgt1t0v.swift:12:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmp3tgt1t0v.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp3tgt1t0v.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n        if l2.contains(i) {\n            result.append(i)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "tmpafy3mqqi/tmpafy3mqqi.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3f41558c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3f4124fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3f4124f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3f4124e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpafy3mqqi                        0x000055a7bab5c67c <unavailable> + 5756\n5    libc.so.6                          0x00002b3f41744460 __libc_start_main + 245\n6    tmpafy3mqqi                        0x000055a7bab5c1f9 <unavailable> + 4601\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var common = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            common.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp36uka7hz.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp36uka7hz.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp36uka7hz.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp36uka7hz.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp36uka7hz.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp36uka7hz.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp36uka7hz.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp36uka7hz.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp36uka7hz.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp36uka7hz.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var c = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            c = append(c, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp9peq1zmk.swift:10:15: error: consecutive statements on a line must be separated by ';'\n    var c = []Int\n              ^\n              ;\n/tmp/tmp9peq1zmk.swift:10:13: error: empty collection literal requires an explicit type\n    var c = []Int\n            ^~\n/tmp/tmp9peq1zmk.swift:10:15: error: expected member name or constructor call after type name\n    var c = []Int\n              ^\n/tmp/tmp9peq1zmk.swift:10:15: note: add arguments after the type to construct a value of the type\n    var c = []Int\n              ^\n                 ()\n/tmp/tmp9peq1zmk.swift:10:15: note: use '.self' to reference the type object\n    var c = []Int\n              ^\n                 .self\n/tmp/tmp9peq1zmk.swift:10:15: warning: expression of type 'Int.Type' is unused\n    var c = []Int\n              ^~~\n/tmp/tmp9peq1zmk.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp9peq1zmk.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp9peq1zmk.swift:13:17: error: cannot find 'append' in scope\n            c = append(c, l1[i])\n                ^~~~~~\n/tmp/tmp9peq1zmk.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return c\n           ^\n/tmp/tmp9peq1zmk.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return c\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp39mi_au6.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp39mi_au6.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp39mi_au6.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp39mi_au6.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp39mi_au6.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp39mi_au6.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp39mi_au6.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp39mi_au6.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmp39mi_au6.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmp39mi_au6.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmp39mi_au6.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp39mi_au6.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp39mi_au6.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp39mi_au6.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp39mi_au6.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp39mi_au6.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp39mi_au6.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp39mi_au6.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp39mi_au6.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp39mi_au6.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmp39mi_au6.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmp39mi_au6.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmp39mi_au6.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp39mi_au6.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i, j int\n\tvar result []Int\n\tfor i < len(l1) && j < len(l2) {\n\t\tif l1[i] == l2[j] {\n\t\t\tresult = append(result, l1[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else if l1[i] < l2[j] {\n\t\t\ti++\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp97kbgfv1.swift:10:11: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i, j int\n                 ^\n/tmp/tmp97kbgfv1.swift:10:11: note: join the identifiers together\n        var i, j int\n               ~~^~~\n               jint\n/tmp/tmp97kbgfv1.swift:10:11: note: join the identifiers together with camel-case\n        var i, j int\n               ~~^~~\n               jInt\n/tmp/tmp97kbgfv1.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmp97kbgfv1.swift:11:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmp97kbgfv1.swift:12:8: error: expected 'in' after for-each pattern\n        for i < len(l1) && j < len(l2) {\n              ^\n/tmp/tmp97kbgfv1.swift:12:8: error: unary operator cannot be separated from its operand\n        for i < len(l1) && j < len(l2) {\n              ^~\n               \n/tmp/tmp97kbgfv1.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmp97kbgfv1.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmp97kbgfv1.swift:10:6: error: type annotation missing in pattern\n        var i, j int\n            ^\n/tmp/tmp97kbgfv1.swift:10:9: error: type annotation missing in pattern\n        var i, j int\n               ^\n/tmp/tmp97kbgfv1.swift:11:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmp97kbgfv1.swift:11:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmp97kbgfv1.swift:11:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmp97kbgfv1.swift:11:15: error: expected member name or constructor call after type name\n        var result []Int\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    let l1_len = len(l1)\n    let l2_len = len(l2)\n    let l1_idx = 0\n    let l2_idx = 0\n    let common = []\n    while l1_idx < l1_len && l2_idx < l2_len {\n        if l1[l1_idx] == l2[l2_idx] {\n            common.append(l1[l1_idx])\n            l1_idx += 1\n            l2_idx += 1\n        } else if l1[l1_idx] < l2[l2_idx] {\n            l1_idx += 1\n        } else {\n            l2_idx += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpsik00rnc.swift:8:18: error: cannot find 'len' in scope\n    let l1_len = len(l1)\n                 ^~~\n/tmp/tmpsik00rnc.swift:9:18: error: cannot find 'len' in scope\n    let l2_len = len(l2)\n                 ^~~\n/tmp/tmpsik00rnc.swift:12:18: error: empty collection literal requires an explicit type\n    let common = []\n                 ^~\n/tmp/tmpsik00rnc.swift:15:20: error: cannot use mutating member on immutable value: 'common' is a 'let' constant\n            common.append(l1[l1_idx])\n            ~~~~~~ ^\n/tmp/tmpsik00rnc.swift:12:5: note: change 'let' to 'var' to make it mutable\n    let common = []\n    ^~~\n    var\n/tmp/tmpsik00rnc.swift:16:20: error: left side of mutating operator isn't mutable: 'l1_idx' is a 'let' constant\n            l1_idx += 1\n            ~~~~~~ ^\n/tmp/tmpsik00rnc.swift:10:5: note: change 'let' to 'var' to make it mutable\n    let l1_idx = 0\n    ^~~\n    var\n/tmp/tmpsik00rnc.swift:17:20: error: left side of mutating operator isn't mutable: 'l2_idx' is a 'let' constant\n            l2_idx += 1\n            ~~~~~~ ^\n/tmp/tmpsik00rnc.swift:11:5: note: change 'let' to 'var' to make it mutable\n    let l2_idx = 0\n    ^~~\n    var\n/tmp/tmpsik00rnc.swift:19:20: error: left side of mutating operator isn't mutable: 'l1_idx' is a 'let' constant\n            l1_idx += 1\n            ~~~~~~ ^\n/tmp/tmpsik00rnc.swift:10:5: note: change 'let' to 'var' to make it mutable\n    let l1_idx = 0\n    ^~~\n    var\n/tmp/tmpsik00rnc.swift:21:20: error: left side of mutating operator isn't mutable: 'l2_idx' is a 'let' constant\n            l2_idx += 1\n            ~~~~~~ ^\n/tmp/tmpsik00rnc.swift:11:5: note: change 'let' to 'var' to make it mutable\n    let l2_idx = 0\n    ^~~\n    var\n/tmp/tmpsik00rnc.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpsik00rnc.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = make([]Int, 0)\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmplx6nvong.swift:13:25: error: expected ',' separator\n    var common = make([]Int, 0)\n                        ^\n                        ,\n/tmp/tmplx6nvong.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmplx6nvong.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmplx6nvong.swift:13:18: error: cannot find 'make' in scope\n    var common = make([]Int, 0)\n                 ^~~~\n/tmp/tmplx6nvong.swift:16:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp7m79fump.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp7m79fump.swift:14:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp7m79fump.swift:14:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmp7m79fump.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp7m79fump.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp7m79fump.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp7m79fump.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp7m79fump.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp7m79fump.swift:12:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp7m79fump.swift:13:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp7m79fump.swift:14:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp7m79fump.swift:14:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp7m79fump.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp7m79fump.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpkn9qp4tf.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpkn9qp4tf.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpkn9qp4tf.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpkn9qp4tf.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpkn9qp4tf.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpkn9qp4tf.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpkn9qp4tf.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpkn9qp4tf.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpkn9qp4tf.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpkn9qp4tf.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpkn9qp4tf.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpkn9qp4tf.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpkn9qp4tf.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpkn9qp4tf.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpjn74nyfj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpjn74nyfj.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpjn74nyfj.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpjn74nyfj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpjn74nyfj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpjn74nyfj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpjn74nyfj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpjn74nyfj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpjn74nyfj.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpjn74nyfj.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpjn74nyfj.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpjn74nyfj.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpjn74nyfj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpjn74nyfj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var result = []\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpbhfg1_s6.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpbhfg1_s6.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpbhfg1_s6.swift:16:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpbhfg1_s6.swift:19:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpbhfg1_s6.swift:28:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpbhfg1_s6.swift:28:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var l1_i = 0\n    var l2_i = 0\n    var l1_j = 0\n    var l2_j = 0\n    var result = []\n    while l1_i < l1_len && l2_i < l2_len {\n        if l1[l1_i] < l2[l2_i] {\n            l1_i += 1\n        } else if l1[l1_i] > l2[l2_i] {\n            l2_i += 1\n        } else {\n            result = append(result, l1[l1_i])\n            l1_i += 1\n            l2_i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp52i50ae4.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp52i50ae4.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp52i50ae4.swift:14:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp52i50ae4.swift:21:22: error: cannot find 'append' in scope\n            result = append(result, l1[l1_i])\n                     ^~~~~~\n/tmp/tmp52i50ae4.swift:26:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp52i50ae4.swift:26:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i1 < l1Len && i2 < l2Len {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp7g814npy.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmp7g814npy.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmp7g814npy.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmp7g814npy.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmp7g814npy.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmp7g814npy.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmp7g814npy.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmp7g814npy.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmp7g814npy.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n/tmp/tmp7g814npy.swift:13:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp7g814npy.swift:14:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp7g814npy.swift:17:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t)\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn l1[:i1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpvykslgh1.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmpvykslgh1.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmpvykslgh1.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpvykslgh1.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpvykslgh1.swift:22:12: error: expected expression in list of expressions\n        return l1[:i1]\n                  ^\n/tmp/tmpvykslgh1.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmpvykslgh1.swift:12:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpvykslgh1.swift:12:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                 ^~~\n/tmp/tmpvykslgh1.swift:12:22: error: cannot find 'i2' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                            ^~\n/tmp/tmpvykslgh1.swift:12:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                                 ^~~\n/tmp/tmpvykslgh1.swift:12:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && i2 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpvykslgh1.swift:22:15: error: missing argument for parameter #1 in call\n        return l1[:i1]\n                     ^\n                     <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\n/tmp/tmpvykslgh1.swift:22:11: error: no 'subscript' candidates produce the expected contextual result type '[Int]'\n        return l1[:i1]\n                 ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not the expected contextual result type '[Int]'\n    @inlinable public",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    var l1_index = 0\n    var l2_index = 0\n    var l1_value = l1[0]\n    var l2_value = l2[0]\n    while i < l1_len && j < l2_len {\n        if l1_value == l2_value {\n            common = append(common, l1_value)\n            i += 1\n            j += 1\n            l1_index += 1\n            l2_index += 1\n            if l1_index == l1_len {\n                break\n            }\n            if l2_index == l2_len {\n                break\n            }\n            l1_value = l1[l1_index]\n            l2_value = l2[l2_index]\n        } else if l1_value < l2_value {\n            i += 1\n            l1_index += 1\n            if l1_index == l1_len {\n                break\n            }\n            l1_value = l1[l1_index]\n        } else {\n            j += 1\n            l2_index += 1\n            if l2_index == l2_len {\n                break\n            }\n            l2_value = l2[l2_index]\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpoxux7awj.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpoxux7awj.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpoxux7awj.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpoxux7awj.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpoxux7awj.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpoxux7awj.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpoxux7awj.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpoxux7awj.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpoxux7awj.swift:20:22: error: cannot find 'append' in scope\n            common = append(common, l1_value)\n                     ^~~~~~\n/tmp/tmpoxux7awj.swift:49:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpoxux7awj.swift:49:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpnwr72w8m.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpnwr72w8m.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpnwr72w8m.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpnwr72w8m.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpnwr72w8m.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpnwr72w8m.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpnwr72w8m.swift:16:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpnwr72w8m.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpnwr72w8m.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) and i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpke3u7nb_.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpke3u7nb_.swift:11:24: error: expected '{' after 'while' condition\n    while i1 < len(l1) and i2 < len(l2) {\n                       ^\n/tmp/tmpke3u7nb_.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpke3u7nb_.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpke3u7nb_.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpke3u7nb_.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpke3u7nb_.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpke3u7nb_.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) and i2 < len(l2) {\n               ^~~\n/tmp/tmpke3u7nb_.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpke3u7nb_.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpke3u7nb_.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common_list = []\n    var l1_index = 0\n    var l2_index = 0\n    var l1_value = l1[0]\n    var l2_value = l2[0]\n    while i < l1_len && j < l2_len {\n        if l1_value == l2_value {\n            common_list = append(common_list, l1_value)\n            i += 1\n            j += 1\n            k += 1\n        } else if l1_value < l2_value {\n            i += 1\n        } else {\n            j += 1\n        }\n        l1_index += 1\n        l2_index += 1\n        l1_value = l1[l1_index]\n        l2_value = l2[l2_index]\n    }\n    return common_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpduk7ywh7.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpduk7ywh7.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpduk7ywh7.swift:13:23: error: empty collection literal requires an explicit type\n    var common_list = []\n                      ^~\n/tmp/tmpduk7ywh7.swift:20:27: error: cannot find 'append' in scope\n            common_list = append(common_list, l1_value)\n                          ^~~~~~\n/tmp/tmpduk7ywh7.swift:34:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common_list\n           ^\n/tmp/tmpduk7ywh7.swift:34:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common_list\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    for i := 0; i < len(l1); i++ {\n        if l1[i] == l2[i] {\n            result = append(result, l1[i])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpvf261pvk.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpvf261pvk.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpvf261pvk.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmpvf261pvk.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpvf261pvk.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpvf261pvk.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpvf261pvk.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpvf261pvk.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpvf261pvk.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpvf261pvk.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t)\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn l1[0:i1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpmhp305zj.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmpmhp305zj.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmpmhp305zj.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpmhp305zj.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpmhp305zj.swift:22:13: error: expected ',' separator\n        return l1[0:i1]\n                   ^\n                   ,\n/tmp/tmpmhp305zj.swift:22:13: error: expected expression in list of expressions\n        return l1[0:i1]\n                   ^\n/tmp/tmpmhp305zj.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmpmhp305zj.swift:12:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpmhp305zj.swift:12:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                 ^~~\n/tmp/tmpmhp305zj.swift:12:22: error: cannot find 'i2' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                            ^~\n/tmp/tmpmhp305zj.swift:12:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                                 ^~~\n/tmp/tmpmhp305zj.swift:12:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && i2 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpmhp305zj.swift:22:11: error: cannot convert return expression of type 'Int' to return type '[Int]'\n        return l1[0:i1]\n               ~~^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    var l1_i = 0\n    var l2_i = 0\n    var l1_j = 0\n    var l2_j = 0\n    var l1_k = 0\n    var l2_k = 0\n    var l1_common = 0\n    var l2_common = 0\n    var l1_l = 0\n    var l2_l = 0\n    var l1_m = 0\n    var l2_m = 0\n    var l1_n = 0\n    var l2_n = 0\n    var l1_o = 0\n    var l2_o = 0\n    var l1_p = 0\n    var l2_p = 0\n    var l1_q = 0\n    var l2_q = 0\n    var l1_r = 0\n    var l2_r = 0\n    var l1_s = 0\n    var l2_s = 0\n    var l1_t = 0\n    var l2_t = 0\n    var l1_u = 0\n    var l2_u = 0\n    var l1_v = 0\n    var l2_v = 0\n    var l1_w = 0\n    var l2_w = 0\n    var l1_x = 0\n    var l2_x = 0\n    var l1_y = 0\n    var l2_y = 0\n    var l1_z = 0\n    var l2_z = 0\n    var l1_common_i = 0\n    var l2_common_i = 0\n    var l1_common_j = 0\n    var l2_common_j = 0\n    var l1_common_k = 0\n    var l2_common_k = 0\n    var l1_common_l = 0\n    var l2_common_l = 0\n    var l1_common_m = 0\n    var l2_common_m = 0\n    var l1_common_n =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpk5b2i5w7.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpk5b2i5w7.swift:62:22: error: expected initial value after '='\n    var l1_common_n =\n                     ^\n/tmp/tmpk5b2i5w7.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpk5b2i5w7.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpk5b2i5w7.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpk5b2i5w7.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpk5b2i5w7.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpk5b2i5w7.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpk5b2i5w7.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpnwr72w8m.swift:13:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpnwr72w8m.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpnwr72w8m.swift:13:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpnwr72w8m.swift:13:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpnwr72w8m.swift:13:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpnwr72w8m.swift:13:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpnwr72w8m.swift:13:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpnwr72w8m.swift:16:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpnwr72w8m.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpnwr72w8m.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    var k1 = 0\n    var k2 = 0\n    while i1 < len(l1) && j1 < len(l2) {\n        if l1[i1] < l2[j1] {\n            i1 += 1\n        } else if l1[i1] > l2[j1] {\n            j1 += 1\n        } else {\n            result = append(result, l1[i1])\n            i1 += 1\n            j1 += 1\n        }\n    }\n    while i1 < len(l1) {\n        result = append(result, l1[i1])\n        i1 += 1\n    }\n    while j1 < len(l2) {\n        result = append(result, l2[j1])\n        j1 += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpdq4l3gsp.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpdq4l3gsp.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpdq4l3gsp.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpdq4l3gsp.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpdq4l3gsp.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpdq4l3gsp.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpdq4l3gsp.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpdq4l3gsp.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpdq4l3gsp.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n/tmp/tmpdq4l3gsp.swift:15:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && j1 < len(l2) {\n               ^~~\n/tmp/tmpdq4l3gsp.swift:15:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && j1 < len(l2) {\n                               ^~~\n/tmp/tmpdq4l3gsp.swift:21:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpdq4l3gsp.swift:26:16: error: cannot find 'len' in scope\n    while i1 < len(l1) {\n               ^~~\n/tmp/tmpdq4l3gsp.swift:27:18: error: cannot find 'append' in scope\n        result = append(result, l1[i1])\n                 ^~~~~~\n/tmp/tmpdq4l3gsp.swift:30:16: error: cannot find 'len' in scope\n    while j1 < len(l2) {\n               ^~~\n/tmp/tmpdq4l3gsp.swift:31:18: error: cannot find 'append' in scope\n        result = append(result, l2[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    var i: Int = 0\n    var j: Int = 0\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpcojyvzdz.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpcojyvzdz.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpcojyvzdz.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpcojyvzdz.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpcojyvzdz.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpcojyvzdz.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var i3 = 0\n    var i4 = 0\n    var i5 = 0\n    var i6 = 0\n    var i7 = 0\n    var i8 = 0\n    var i9 = 0\n    var i10 = 0\n    var i11 = 0\n    var i12 = 0\n    var i13 = 0\n    var i14 = 0\n    var i15 = 0\n    var i16 = 0\n    var i17 = 0\n    var i18 = 0\n    var i19 = 0\n    var i20 = 0\n    var i21 = 0\n    var i22 = 0\n    var i23 = 0\n    var i24 = 0\n    var i25 = 0\n    var i26 = 0\n    var i27 = 0\n    var i28 = 0\n    var i29 = 0\n    var i30 = 0\n    var i31 = 0\n    var i32 = 0\n    var i33 = 0\n    var i34 = 0\n    var i35 = 0\n    var i36 = 0\n    var i37 = 0\n    var i38 = 0\n    var i39 = 0\n    var i40 = 0\n    var i41 = 0\n    var i42 = 0\n    var i43 = 0\n    var i44 = 0\n    var i45 = 0\n    var i46 = 0\n    var i47 = 0\n    var i48 = 0\n    var i49 = 0\n    var i50 = 0\n    var i51 = 0\n    var i52 = 0\n    var i53 = 0\n    var i54 = 0\n    var i55 = 0\n    var i56 = 0\n    var i57 = 0\n    var i58 = 0\n    var i59 = 0\n    var i60 = 0\n    var i61 = 0\n    var i62 = 0\n    var i63 = 0\n    var i64 = 0\n    var i65 = 0\n    var i66 = 0\n    var i67 = 0\n    var i68 = 0\n    var i69 = 0\n    var i70 = 0\n    var i71 = 0\n    var i72 = 0\n    var i73 = 0\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprdwm6okq.swift:8:9: warning: initialization of variable 'i1' was never used; consider replacing with assignment to '_' or removing it\n    var i1 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:9:9: warning: initialization of variable 'i2' was never used; consider replacing with assignment to '_' or removing it\n    var i2 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:10:9: warning: initialization of variable 'i3' was never used; consider replacing with assignment to '_' or removing it\n    var i3 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:11:9: warning: initialization of variable 'i4' was never used; consider replacing with assignment to '_' or removing it\n    var i4 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:12:9: warning: initialization of variable 'i5' was never used; consider replacing with assignment to '_' or removing it\n    var i5 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:13:9: warning: initialization of variable 'i6' was never used; consider replacing with assignment to '_' or removing it\n    var i6 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:14:9: warning: initialization of variable 'i7' was never used; consider replacing with assignment to '_' or removing it\n    var i7 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:15:9: warning: initialization of variable 'i8' was never used; consider replacing with assignment to '_' or removing it\n    var i8 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:16:9: warning: initialization of variable 'i9' was never used; consider replacing with assignment to '_' or removing it\n    var i9 = 0\n    ~~~~^~\n    _\n/tmp/tmprdwm6okq.swift:17:9: warning: initialization of variable 'i10' was never used; consider replacing with assignment to '_' or removing it\n    var i10 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:18:9: warning: initialization of variable 'i11' was never used; consider replacing with assignment to '_' or removing it\n    var i11 = 0\n    ~~~~^~~\n    _\n/tmp/tmprdwm6okq.swift:19:9: warning: initialization of variable 'i12' was never used; consider replacing with assignme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpm_8apw2i.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpm_8apw2i.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpm_8apw2i.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpm_8apw2i.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpm_8apw2i.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpm_8apw2i.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t)\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\ti1 += 1\n\t\t\ti2 += 1\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1 += 1\n\t\t} else {\n\t\t\ti2 += 1\n\t\t}\n\t}\n\treturn l1[:i1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpelp6ouab.swift:9:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmpelp6ouab.swift:9:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmpelp6ouab.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpelp6ouab.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpelp6ouab.swift:22:12: error: expected expression in list of expressions\n        return l1[:i1]\n                  ^\n/tmp/tmpelp6ouab.swift:9:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmpelp6ouab.swift:12:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpelp6ouab.swift:12:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                 ^~~\n/tmp/tmpelp6ouab.swift:12:22: error: cannot find 'i2' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                            ^~\n/tmp/tmpelp6ouab.swift:12:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                                 ^~~\n/tmp/tmpelp6ouab.swift:12:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && i2 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpelp6ouab.swift:22:15: error: missing argument for parameter #1 in call\n        return l1[:i1]\n                     ^\n                     <#Int#>\nSwift.Array:16:23: note: 'subscript(_:)' declared here\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\n/tmp/tmpelp6ouab.swift:22:11: error: no 'subscript' candidates produce the expected contextual result type '[Int]'\n        return l1[:i1]\n                 ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not the expected contextual result type '[Int]'\n    @inlinable public",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp72dvssmn.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp72dvssmn.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp72dvssmn.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp72dvssmn.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp72dvssmn.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp72dvssmn.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp72dvssmn.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmp72dvssmn.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmp72dvssmn.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp72dvssmn.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp72dvssmn.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var z: Int = 0\n    var a: Int = 0\n    var b: Int = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int = 0\n    var s: Int =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpob2j0qfx.swift:71:17: error: expected initial value after '='\n    var s: Int =\n                ^\n/tmp/tmpob2j0qfx.swift:35:9: error: invalid redeclaration of 'i'\n    var i: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:9:9: note: 'i' previously declared here\n    var i: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:36:9: error: invalid redeclaration of 'j'\n    var j: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:10:9: note: 'j' previously declared here\n    var j: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:37:9: error: invalid redeclaration of 'k'\n    var k: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:11:9: note: 'k' previously declared here\n    var k: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:38:9: error: invalid redeclaration of 'l'\n    var l: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:12:9: note: 'l' previously declared here\n    var l: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:39:9: error: invalid redeclaration of 'm'\n    var m: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:13:9: note: 'm' previously declared here\n    var m: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:40:9: error: invalid redeclaration of 'n'\n    var n: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:14:9: note: 'n' previously declared here\n    var n: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:41:9: error: invalid redeclaration of 'o'\n    var o: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:15:9: note: 'o' previously declared here\n    var o: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:42:9: error: invalid redeclaration of 'p'\n    var p: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:16:9: note: 'p' previously declared here\n    var p: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:43:9: error: invalid redeclaration of 'q'\n    var q: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:17:9: note: 'q' previously declared here\n    var q: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:44:9: error: invalid redeclaration of 'r'\n    var r: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:18:9: note: 'r' previously declared here\n    var r: Int = 0\n        ^\n/tmp/tmpob2j0qfx.swift:45:9: error: invalid redeclaration of 's'\n    var s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    var i1 = 0\n    var i2 = 0\n    var j1 = 0\n    var j2 = 0\n    var k1 = 0\n    var k2 = 0\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    while i1 < l1_len && i2 < l2_len {\n        if l1[i1] < l2[i2] {\n            i1 += 1\n        } else if l1[i1] > l2[i2] {\n            i2 += 1\n        } else {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        }\n    }\n    while j1 < l1_len {\n        if l1[j1] == l2[j2] {\n            result = append(result, l1[j1])\n            j1 += 1\n            j2 += 1\n        } else if l1[j1] < l2[j2] {\n            j1 += 1\n        } else {\n            j2 += 1\n        }\n    }\n    while k1 < l1_len {\n        if l1[k1] == l2[k2] {\n            result = append(result, l1[k1])\n            k1 += 1\n            k2 += 1\n        } else if l1[k1] < l2[k2] {\n            k1 += 1\n        } else {\n            k2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpdhzautkv.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpdhzautkv.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpdhzautkv.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpdhzautkv.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpdhzautkv.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpdhzautkv.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpdhzautkv.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpdhzautkv.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpdhzautkv.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n/tmp/tmpdhzautkv.swift:15:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpdhzautkv.swift:16:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpdhzautkv.swift:23:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpdhzautkv.swift:30:22: error: cannot find 'append' in scope\n            result = append(result, l1[j1])\n                     ^~~~~~\n/tmp/tmpdhzautkv.swift:41:22: error: cannot find 'append' in scope\n            result = append(result, l1[k1])\n                     ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpb7as22ig.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpb7as22ig.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpb7as22ig.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpb7as22ig.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpb7as22ig.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpb7as22ig.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpb7as22ig.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpb7as22ig.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpb7as22ig.swift:13:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpb7as22ig.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpb7as22ig.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int{}\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp9o_7_w5p.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{}\n                   ^\n                   ;\n/tmp/tmp9o_7_w5p.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp9o_7_w5p.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp9o_7_w5p.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int{}\n                 ^~\n/tmp/tmp9o_7_w5p.swift:10:20: error: no exact matches in call to initializer \n    var result = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp2pgu1up0.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp2pgu1up0.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp2pgu1up0.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp2pgu1up0.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp2pgu1up0.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp2pgu1up0.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp2pgu1up0.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp2pgu1up0.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp2pgu1up0.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmp2pgu1up0.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp2pgu1up0.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpyglo9ph4.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpyglo9ph4.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpyglo9ph4.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpyglo9ph4.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpyglo9ph4.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpyglo9ph4.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var cnt = 0\n    var res = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            cnt += 1\n            res = append(res, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp3qt0hm1n.swift:11:15: error: empty collection literal requires an explicit type\n    var res = []\n              ^~\n/tmp/tmp3qt0hm1n.swift:12:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmp3qt0hm1n.swift:12:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmp3qt0hm1n.swift:15:19: error: cannot find 'append' in scope\n            res = append(res, l1[i1])\n                  ^~~~~~\n/tmp/tmp3qt0hm1n.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return res\n           ^\n/tmp/tmp3qt0hm1n.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return res\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var common = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp7m79fump.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp7m79fump.swift:14:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp7m79fump.swift:14:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmp7m79fump.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp7m79fump.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp7m79fump.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp7m79fump.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp7m79fump.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp7m79fump.swift:12:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp7m79fump.swift:13:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp7m79fump.swift:14:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmp7m79fump.swift:14:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp7m79fump.swift:25:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmp7m79fump.swift:25:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int{}\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpzljjtkx1.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{}\n                   ^\n                   ;\n/tmp/tmpzljjtkx1.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int{}\n                 ^~\n/tmp/tmpzljjtkx1.swift:10:20: error: no exact matches in call to initializer \n    var result = []Int{}\n                   ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable public init<Other>(cla",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    for i in l1 {\n        if l2.contains(i) {\n            common.append(i)\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "tmpwq7bp138/tmpwq7bp138.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b89b090bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b89b0602b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b89b0602988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b89b06017b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpwq7bp138                        0x0000561338cbf67c <unavailable> + 5756\n5    libc.so.6                          0x00002b89b0af7460 __libc_start_main + 245\n6    tmpwq7bp138                        0x0000561338cbf1f9 <unavailable> + 4601\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tvar l1_len = len(l1)\n\tvar l2_len = len(l2)\n\tvar i = 0\n\tvar j = 0\n\tvar k = 0\n\tvar common = make([]Int, 0)\n\tfor i < l1_len && j < l2_len {\n\t\tif l1[i] == l2[j] {\n\t\t\tcommon = append(common, l1[i])\n\t\t\ti += 1\n\t\t\tj += 1\n\t\t} else if l1[i] < l2[j] {\n\t\t\ti += 1\n\t\t} else {\n\t\t\tj += 1\n\t\t}\n\t}\n\treturn common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp2v8il4b2.swift:13:22: error: expected ',' separator\n        var common = make([]Int, 0)\n                            ^\n                            ,\n/tmp/tmp2v8il4b2.swift:14:8: error: expected 'in' after for-each pattern\n        for i < l1_len && j < l2_len {\n              ^\n/tmp/tmp2v8il4b2.swift:14:8: error: unary operator cannot be separated from its operand\n        for i < l1_len && j < l2_len {\n              ^~\n               \n/tmp/tmp2v8il4b2.swift:8:15: error: cannot find 'len' in scope\n        var l1_len = len(l1)\n                     ^~~\n/tmp/tmp2v8il4b2.swift:9:15: error: cannot find 'len' in scope\n        var l2_len = len(l2)\n                     ^~~\n/tmp/tmp2v8il4b2.swift:13:15: error: cannot find 'make' in scope\n        var common = make([]Int, 0)\n                     ^~~~\n/tmp/tmp2v8il4b2.swift:14:8: error: '<' is not a prefix unary operator\n        for i < l1_len && j < l2_len {\n              ^\n/tmp/tmp2v8il4b2.swift:14:17: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i < l1_len && j < l2_len {\n              ~~~~~~~~~^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp5osxhvfo.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp5osxhvfo.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp5osxhvfo.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp5osxhvfo.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp5osxhvfo.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp5osxhvfo.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp5osxhvfo.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp5osxhvfo.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp5osxhvfo.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp5osxhvfo.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp5osxhvfo.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var c = []Int\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            c = append(c, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpo3pzbb7y.swift:10:15: error: consecutive statements on a line must be separated by ';'\n    var c = []Int\n              ^\n              ;\n/tmp/tmpo3pzbb7y.swift:10:13: error: empty collection literal requires an explicit type\n    var c = []Int\n            ^~\n/tmp/tmpo3pzbb7y.swift:10:15: error: expected member name or constructor call after type name\n    var c = []Int\n              ^\n/tmp/tmpo3pzbb7y.swift:10:15: note: add arguments after the type to construct a value of the type\n    var c = []Int\n              ^\n                 ()\n/tmp/tmpo3pzbb7y.swift:10:15: note: use '.self' to reference the type object\n    var c = []Int\n              ^\n                 .self\n/tmp/tmpo3pzbb7y.swift:10:15: warning: expression of type 'Int.Type' is unused\n    var c = []Int\n              ^~~\n/tmp/tmpo3pzbb7y.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpo3pzbb7y.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpo3pzbb7y.swift:13:17: error: cannot find 'append' in scope\n            c = append(c, l1[i1])\n                ^~~~~~\n/tmp/tmpo3pzbb7y.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return c\n           ^\n/tmp/tmpo3pzbb7y.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return c\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var result = [Int]\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpumqlj8sn.swift:11:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpumqlj8sn.swift:12:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpumqlj8sn.swift:13:18: error: expected member name or constructor call after type name\n    var result = [Int]\n                 ^\n/tmp/tmpumqlj8sn.swift:13:22: note: add arguments after the type to construct a value of the type\n    var result = [Int]\n                     ^\n                      ()\n/tmp/tmpumqlj8sn.swift:13:22: note: use '.self' to reference the type object\n    var result = [Int]\n                     ^\n                      .self\n/tmp/tmpumqlj8sn.swift:16:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpumqlj8sn.swift:25:12: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n    return result\n           ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1 = append(l1, -1)\n\tl2 = append(l2, -1)\n\tvar (\n\t\ti1 = 0\n\t\ti2 = 0\n\t)\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn l1[:i1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpihudrtrt.swift:11:6: error: expected ',' separator\n                i1 = 0\n                   ^\n                  ,\n/tmp/tmpihudrtrt.swift:11:6: error: expected pattern\n                i1 = 0\n                   ^\n/tmp/tmpihudrtrt.swift:14:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpihudrtrt.swift:14:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpihudrtrt.swift:24:12: error: expected expression in list of expressions\n        return l1[:i1]\n                  ^\n/tmp/tmpihudrtrt.swift:8:7: error: cannot find 'append' in scope\n        l1 = append(l1, -1)\n             ^~~~~~\n/tmp/tmpihudrtrt.swift:8:2: error: cannot assign to value: 'l1' is a 'let' constant\n        l1 = append(l1, -1)\n        ^~\n/tmp/tmpihudrtrt.swift:9:7: error: cannot find 'append' in scope\n        l2 = append(l2, -1)\n             ^~~~~~\n/tmp/tmpihudrtrt.swift:9:2: error: cannot assign to value: 'l2' is a 'let' constant\n        l2 = append(l2, -1)\n        ^~\n/tmp/tmpihudrtrt.swift:11:3: error: type annotation missing in pattern\n                i1 = 0\n                ^\n/tmp/tmpihudrtrt.swift:14:9: error: '<' is not a prefix unary operator\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpihudrtrt.swift:14:11: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                 ^~~\n/tmp/tmpihudrtrt.swift:14:22: error: cannot find 'i2' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                            ^~\n/tmp/tmpihudrtrt.swift:14:27: error: cannot find 'len' in scope\n        for i1 < len(l1) && i2 < len(l2) {\n                                 ^~~\n/tmp/tmpihudrtrt.swift:14:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n        for i1 < len(l1) && i2 < len(l2) {\n               ~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpihudrtrt.swift:24:15: error: missing argument for parameter #1 in call\n        return l1[:i1]\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    while i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmp5osxhvfo.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp5osxhvfo.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp5osxhvfo.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp5osxhvfo.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp5osxhvfo.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp5osxhvfo.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp5osxhvfo.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmp5osxhvfo.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmp5osxhvfo.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmp5osxhvfo.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp5osxhvfo.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar result []Int\n\ti, j := 0, 0\n\tfor i < len(l1) && j < len(l2) {\n\t\tif l1[i] == l2[j] {\n\t\t\tresult = append(result, l1[i])\n\t\t\ti++\n\t\t\tj++\n\t\t} else if l1[i] < l2[j] {\n\t\t\ti++\n\t\t} else {\n\t\t\tj++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp9tpb5dk7.swift:10:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmp9tpb5dk7.swift:10:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmp9tpb5dk7.swift:11:3: error: consecutive statements on a line must be separated by ';'\n        i, j := 0, 0\n         ^\n         ;\n/tmp/tmp9tpb5dk7.swift:11:3: error: expected expression\n        i, j := 0, 0\n         ^\n/tmp/tmp9tpb5dk7.swift:12:8: error: expected 'in' after for-each pattern\n        for i < len(l1) && j < len(l2) {\n              ^\n/tmp/tmp9tpb5dk7.swift:12:8: error: unary operator cannot be separated from its operand\n        for i < len(l1) && j < len(l2) {\n              ^~\n               \n/tmp/tmp9tpb5dk7.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmp9tpb5dk7.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmp9tpb5dk7.swift:10:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmp9tpb5dk7.swift:10:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmp9tpb5dk7.swift:10:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmp9tpb5dk7.swift:10:15: error: expected member name or constructor call after type name\n        var result []Int\n                     ^\n/tmp/tmp9tpb5dk7.swift:10:15: note: add arguments after the type to construct a value of the type\n        var result []Int\n                     ^\n                        ()\n/tmp/tmp9tpb5dk7.swift:10:15: note: use '.self' to reference the type object\n        var result []Int\n                     ^\n                        .self\n/tmp/tmp9tpb5dk7.swift:10:15: warning: expression of type 'Int.Type' is unused\n        var ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            result = append(result, l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpm_8apw2i.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpm_8apw2i.swift:11:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpm_8apw2i.swift:11:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpm_8apw2i.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i1])\n                     ^~~~~~\n/tmp/tmpm_8apw2i.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpm_8apw2i.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            result.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpicf4pf8o.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpicf4pf8o.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpicf4pf8o.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpicf4pf8o.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpicf4pf8o.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp39mi_au6.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmp39mi_au6.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmp39mi_au6.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmp39mi_au6.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmp39mi_au6.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmp39mi_au6.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmp39mi_au6.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmp39mi_au6.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmp39mi_au6.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmp39mi_au6.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmp39mi_au6.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmp39mi_au6.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp39mi_au6.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var count = 0\n    var common = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            count += 1\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpk1fa0xts.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpk1fa0xts.swift:11:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpk1fa0xts.swift:11:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpk1fa0xts.swift:11:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpk1fa0xts.swift:11:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpk1fa0xts.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpk1fa0xts.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpk1fa0xts.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpk1fa0xts.swift:15:22: error: cannot find 'append' in scope\n            common = append(common, l1[i])\n                     ^~~~~~\n/tmp/tmpk1fa0xts.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpk1fa0xts.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var result []Int\n    for i := 0; i < len(l1); i++ {\n        for j := 0; j < len(l2); j++ {\n            if l1[i] == l2[j] {\n                result = append(result, l1[i])\n                break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpcogvq3p2.swift:8:15: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n              ^\n              ;\n/tmp/tmpcogvq3p2.swift:8:18: error: consecutive statements on a line must be separated by ';'\n    var result []Int\n                 ^\n                 ;\n/tmp/tmpcogvq3p2.swift:9:12: error: expected type\n    for i := 0; i < len(l1); i++ {\n           ^\n            <#type#>\n/tmp/tmpcogvq3p2.swift:9:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpcogvq3p2.swift:9:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(l1); i++ {\n           ^\n/tmp/tmpcogvq3p2.swift:10:16: error: expected type\n        for j := 0; j < len(l2); j++ {\n               ^\n                <#type#>\n/tmp/tmpcogvq3p2.swift:10:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(l2); j++ {\n               ^\n/tmp/tmpcogvq3p2.swift:10:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(l2); j++ {\n               ^\n/tmp/tmpcogvq3p2.swift:8:9: error: type annotation missing in pattern\n    var result []Int\n        ^\n/tmp/tmpcogvq3p2.swift:8:16: error: empty collection literal requires an explicit type\n    var result []Int\n               ^~\n/tmp/tmpcogvq3p2.swift:8:16: warning: expression of type '[Any]' is unused\n    var result []Int\n               ^~\n/tmp/tmpcogvq3p2.swift:8:18: error: expected member name or constructor call after type name\n    var result []Int\n                 ^\n/tmp/tmpcogvq3p2.swift:8:18: note: add arguments after the type to construct a value of the type\n    var result []Int\n                 ^\n                    ()\n/tmp/tmpcogvq3p2.swift:8:18: note: use '.self' to reference the type object\n    var result []Int\n                 ^\n                    .self\n/tmp/tmpcogvq3p2.swift:8:18: warning: expression of type 'Int.Type' is unused\n    var result []Int\n                 ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    var len1 = len(l1)\n    var len2 = len(l2)\n    while i < len1 && j < len2 {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpf6vqqxwf.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpf6vqqxwf.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpf6vqqxwf.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpf6vqqxwf.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpf6vqqxwf.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpf6vqqxwf.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpf6vqqxwf.swift:11:16: error: cannot find 'len' in scope\n    var len1 = len(l1)\n               ^~~\n/tmp/tmpf6vqqxwf.swift:12:16: error: cannot find 'len' in scope\n    var len2 = len(l2)\n               ^~~\n/tmp/tmpf6vqqxwf.swift:15:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpf6vqqxwf.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpf6vqqxwf.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpcmpsf7pj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpcmpsf7pj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpcmpsf7pj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpcmpsf7pj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpcmpsf7pj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpcmpsf7pj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmppgdczxpm.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmppgdczxpm.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmppgdczxpm.swift:11:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmppgdczxpm.swift:11:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmppgdczxpm.swift:11:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmppgdczxpm.swift:11:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmppgdczxpm.swift:12:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmppgdczxpm.swift:12:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmppgdczxpm.swift:14:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmppgdczxpm.swift:23:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmppgdczxpm.swift:23:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpi7zep0vi.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpi7zep0vi.swift:13:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmpi7zep0vi.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmpi7zep0vi.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpi7zep0vi.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpi7zep0vi.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpi7zep0vi.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpi7zep0vi.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpi7zep0vi.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmpi7zep0vi.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmpi7zep0vi.swift:13:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmpi7zep0vi.swift:13:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpi7zep0vi.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpi7zep0vi.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i1, i2 int\n\tvar common [Int]\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\tcommon = append(common, l1[i1])\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpjk_i096i.swift:10:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i1, i2 int\n                   ^\n/tmp/tmpjk_i096i.swift:10:13: note: join the identifiers together\n        var i1, i2 int\n                ~~~^~~\n                i2int\n/tmp/tmpjk_i096i.swift:10:13: note: join the identifiers together with camel-case\n        var i1, i2 int\n                ~~~^~~\n                i2Int\n/tmp/tmpjk_i096i.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var common [Int]\n                  ^\n                  ;\n/tmp/tmpjk_i096i.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmpjk_i096i.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmpjk_i096i.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmpjk_i096i.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmpjk_i096i.swift:10:6: error: type annotation missing in pattern\n        var i1, i2 int\n            ^\n/tmp/tmpjk_i096i.swift:10:10: error: type annotation missing in pattern\n        var i1, i2 int\n                ^\n/tmp/tmpjk_i096i.swift:11:6: error: type annotation missing in pattern\n        var common [Int]\n            ^\n/tmp/tmpjk_i096i.swift:11:13: error: expected member name or constructor call after type name\n        var common [Int]\n                   ^\n/tmp/tmpjk_i096i.swift:11:17: note: add arguments after the type to construct a value of the type\n        var common [Int]\n                       ^\n                        ()\n/tmp/tmpjk_i096i.swift:11:17: note: use '.self' to reference the type object\n        var common [Int]\n                       ^\n                        .self\n/tmp/tmpjk_i096i.swift:11:13: warning: expression of",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []\n    var len1 = len(l1)\n    var len2 = len(l2)\n    for i < len1 && j < len2 {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp1952t6uu.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len1 && j < len2 {\n          ^\n/tmp/tmp1952t6uu.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len1 && j < len2 {\n          ^~\n           \n/tmp/tmp1952t6uu.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmp1952t6uu.swift:11:16: error: cannot find 'len' in scope\n    var len1 = len(l1)\n               ^~~\n/tmp/tmp1952t6uu.swift:12:16: error: cannot find 'len' in scope\n    var len2 = len(l2)\n               ^~~\n/tmp/tmp1952t6uu.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len1 && j < len2 {\n          ^\n/tmp/tmp1952t6uu.swift:13:18: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len1 && j < len2 {\n          ~~~~~~~^~~~~~~~~~~\n/tmp/tmp1952t6uu.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmp1952t6uu.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpd28ltgcl.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpd28ltgcl.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpd28ltgcl.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpd28ltgcl.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpd28ltgcl.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpd28ltgcl.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpd28ltgcl.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpd28ltgcl.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpd28ltgcl.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpd28ltgcl.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpd28ltgcl.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpd28ltgcl.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpd28ltgcl.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpd28ltgcl.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\tl1.sort()\n\tl2.sort()\n\tvar i1, i2 int\n\tvar result []Int\n\tfor i1 < len(l1) && i2 < len(l2) {\n\t\tif l1[i1] == l2[i2] {\n\t\t\tresult = append(result, l1[i1])\n\t\t\ti1++\n\t\t\ti2++\n\t\t} else if l1[i1] < l2[i2] {\n\t\t\ti1++\n\t\t} else {\n\t\t\ti2++\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmprx12l_15.swift:10:13: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n        var i1, i2 int\n                   ^\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together\n        var i1, i2 int\n                ~~~^~~\n                i2int\n/tmp/tmprx12l_15.swift:10:13: note: join the identifiers together with camel-case\n        var i1, i2 int\n                ~~~^~~\n                i2Int\n/tmp/tmprx12l_15.swift:11:12: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                  ^\n                  ;\n/tmp/tmprx12l_15.swift:11:15: error: consecutive statements on a line must be separated by ';'\n        var result []Int\n                     ^\n                     ;\n/tmp/tmprx12l_15.swift:12:9: error: expected 'in' after for-each pattern\n        for i1 < len(l1) && i2 < len(l2) {\n               ^\n/tmp/tmprx12l_15.swift:12:9: error: unary operator cannot be separated from its operand\n        for i1 < len(l1) && i2 < len(l2) {\n               ^~\n                \n/tmp/tmprx12l_15.swift:8:5: error: cannot use mutating member on immutable value: 'l1' is a 'let' constant\n        l1.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:9:5: error: cannot use mutating member on immutable value: 'l2' is a 'let' constant\n        l2.sort()\n        ~~ ^\n/tmp/tmprx12l_15.swift:10:6: error: type annotation missing in pattern\n        var i1, i2 int\n            ^\n/tmp/tmprx12l_15.swift:10:10: error: type annotation missing in pattern\n        var i1, i2 int\n                ^\n/tmp/tmprx12l_15.swift:11:6: error: type annotation missing in pattern\n        var result []Int\n            ^\n/tmp/tmprx12l_15.swift:11:13: error: empty collection literal requires an explicit type\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:13: warning: expression of type '[Any]' is unused\n        var result []Int\n                   ^~\n/tmp/tmprx12l_15.swift:11:15: error: expected member name or constructor call after type name\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var l1_idx = 0\n    var l2_idx = 0\n    var common = []Int\n    var l1_idx_prev = -1\n    var l2_idx_prev = -1\n    var common_idx = -1\n    var l1_idx_next = -1\n    var l2_idx_next = -1\n    var common_idx_next = -1\n    var common_idx_prev = -1\n    var l1_idx_next_prev = -1\n    var l2_idx_next_prev = -1\n    var common_idx_next_prev = -1\n    var common_idx_prev_next = -1\n    var l1_idx_prev_next = -1\n    var l2_idx_prev_next = -1\n    var common_idx_prev_next = -1\n    var common_idx_next_next = -1\n    var l1_idx_prev_next_prev = -1\n    var l2_idx_prev_next_prev = -1\n    var common_idx_prev_next_prev = -1\n    var common_idx_next_next_prev = -1\n    var l1_idx_prev_next_next = -1\n    var l2_idx_prev_next_next = -1\n    var common_idx_prev_next_next = -1\n    var common_idx_next_next_next = -1\n    var l1_idx_prev_next_next_next = -1\n    var l2_idx_prev_next_next_next = -1\n    var common_idx_prev_next_next_next = -1\n    var common_idx_next_next_next_next = -1\n    var l1_idx_prev_next_next_next_next = -1\n    var l2_idx_prev_next_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmp0_m4h3yo.swift:15:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmp0_m4h3yo.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmp0_m4h3yo.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmp0_m4h3yo.swift:15:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmp0_m4h3yo.swift:15:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmp0_m4h3yo.swift:15:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmp0_m4h3yo.swift:15:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmp0_m4h3yo.swift:15:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmp0_m4h3yo.swift:29:9: error: invalid redeclaration of 'common_idx_prev_next'\n    var common_idx_prev_next = -1\n        ^\n/tmp/tmp0_m4h3yo.swift:26:9: note: 'common_idx_prev_next' previously declared here\n    var common_idx_prev_next = -1\n        ^\n/tmp/tmp0_m4h3yo.swift:44:9: error: type annotation missing in pattern\n    var l2_idx_prev_next_\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpjn74nyfj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpjn74nyfj.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpjn74nyfj.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpjn74nyfj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpjn74nyfj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpjn74nyfj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpjn74nyfj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpjn74nyfj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpjn74nyfj.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpjn74nyfj.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpjn74nyfj.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpjn74nyfj.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n/tmp/tmpjn74nyfj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpjn74nyfj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var result = []Int\n    while i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpetwyv1sj.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int\n                   ^\n                   ;\n/tmp/tmpetwyv1sj.swift:10:18: error: empty collection literal requires an explicit type\n    var result = []Int\n                 ^~\n/tmp/tmpetwyv1sj.swift:10:20: error: expected member name or constructor call after type name\n    var result = []Int\n                   ^\n/tmp/tmpetwyv1sj.swift:10:20: note: add arguments after the type to construct a value of the type\n    var result = []Int\n                   ^\n                      ()\n/tmp/tmpetwyv1sj.swift:10:20: note: use '.self' to reference the type object\n    var result = []Int\n                   ^\n                      .self\n/tmp/tmpetwyv1sj.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var result = []Int\n                   ^~~\n/tmp/tmpetwyv1sj.swift:11:15: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n              ^~~\n/tmp/tmpetwyv1sj.swift:11:30: error: cannot find 'len' in scope\n    while i < len(l1) && j < len(l2) {\n                             ^~~\n/tmp/tmpetwyv1sj.swift:13:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpetwyv1sj.swift:22:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpetwyv1sj.swift:22:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var l1_len = len(l1)\n    var l2_len = len(l2)\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var result = []\n    while i < l1_len && j < l2_len {\n        if l1[i] == l2[j] {\n            result = append(result, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpbhfg1_s6.swift:8:18: error: cannot find 'len' in scope\n    var l1_len = len(l1)\n                 ^~~\n/tmp/tmpbhfg1_s6.swift:9:18: error: cannot find 'len' in scope\n    var l2_len = len(l2)\n                 ^~~\n/tmp/tmpbhfg1_s6.swift:16:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpbhfg1_s6.swift:19:22: error: cannot find 'append' in scope\n            result = append(result, l1[i])\n                     ^~~~~~\n/tmp/tmpbhfg1_s6.swift:28:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpbhfg1_s6.swift:28:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n\t// TODO: implement\n\treturn []Int{}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpalavbrpy.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpalavbrpy.swift:9:11: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable public init<Other>(clamping source: Other) where Other : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:2:23: note: candidate requires that '() -> ()' c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    var i: Int = 0\n    var j: Int = 0\n    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n            common.append(l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n            j += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpg3wl3lor.swift:11:11: error: expected 'in' after for-each pattern\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpg3wl3lor.swift:11:11: error: unary operator cannot be separated from its operand\n    for i < len(l1) && j < len(l2) {\n          ^~\n           \n/tmp/tmpg3wl3lor.swift:11:11: error: '<' is not a prefix unary operator\n    for i < len(l1) && j < len(l2) {\n          ^\n/tmp/tmpg3wl3lor.swift:11:13: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n            ^~~\n/tmp/tmpg3wl3lor.swift:11:28: error: cannot find 'len' in scope\n    for i < len(l1) && j < len(l2) {\n                           ^~~\n/tmp/tmpg3wl3lor.swift:11:21: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(l1) && j < len(l2) {\n          ~~~~~~~~~~^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i1 = 0\n    var i2 = 0\n    var count = 0\n    var result = []\n    while i1 < len(l1) && i2 < len(l2) {\n        if l1[i1] == l2[i2] {\n            count += 1\n            result.append(l1[i1])\n            i1 += 1\n            i2 += 1\n        } else if l1[i1] < l2[i2] {\n            i1 += 1\n        } else {\n            i2 += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpmoyyhx6h.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []\n                 ^~\n/tmp/tmpmoyyhx6h.swift:12:16: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n               ^~~\n/tmp/tmpmoyyhx6h.swift:12:32: error: cannot find 'len' in scope\n    while i1 < len(l1) && i2 < len(l2) {\n                               ^~~\n/tmp/tmpmoyyhx6h.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return result\n           ^\n/tmp/tmpmoyyhx6h.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293499,
      "stdout": "",
      "stderr": "/tmp/tmpi4uhldn7.swift:93:8: error: expected pattern\n    var\n       ^\n/tmp/tmpi4uhldn7.swift:34:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:8:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpi4uhldn7.swift:35:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:9:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpi4uhldn7.swift:36:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:10:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpi4uhldn7.swift:37:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:11:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpi4uhldn7.swift:38:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:12:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpi4uhldn7.swift:39:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:13:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpi4uhldn7.swift:40:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:14:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpi4uhldn7.swift:41:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:15:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpi4uhldn7.swift:42:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:16:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpi4uhldn7.swift:43:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:17:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpi4uhldn7.swift:44:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:18:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpi4uhldn7.swift:45:9: erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int], l2: [Int]) -> [Int] {\n    var i = 0\n    var j = 0\n    var common = []Int\n    var l1Len = len(l1)\n    var l2Len = len(l2)\n    for i < l1Len && j < l2Len {\n        if l1[i] == l2[j] {\n            common = append(common, l1[i])\n            i += 1\n            j += 1\n        } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])",
      "timestamp": 1664293500,
      "stdout": "",
      "stderr": "/tmp/tmpfyzm__zo.swift:10:20: error: consecutive statements on a line must be separated by ';'\n    var common = []Int\n                   ^\n                   ;\n/tmp/tmpfyzm__zo.swift:13:11: error: expected 'in' after for-each pattern\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmpfyzm__zo.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < l1Len && j < l2Len {\n          ^~\n           \n/tmp/tmpfyzm__zo.swift:10:18: error: empty collection literal requires an explicit type\n    var common = []Int\n                 ^~\n/tmp/tmpfyzm__zo.swift:10:20: error: expected member name or constructor call after type name\n    var common = []Int\n                   ^\n/tmp/tmpfyzm__zo.swift:10:20: note: add arguments after the type to construct a value of the type\n    var common = []Int\n                   ^\n                      ()\n/tmp/tmpfyzm__zo.swift:10:20: note: use '.self' to reference the type object\n    var common = []Int\n                   ^\n                      .self\n/tmp/tmpfyzm__zo.swift:10:20: warning: expression of type 'Int.Type' is unused\n    var common = []Int\n                   ^~~\n/tmp/tmpfyzm__zo.swift:11:17: error: cannot find 'len' in scope\n    var l1Len = len(l1)\n                ^~~\n/tmp/tmpfyzm__zo.swift:12:17: error: cannot find 'len' in scope\n    var l2Len = len(l2)\n                ^~~\n/tmp/tmpfyzm__zo.swift:13:11: error: '<' is not a prefix unary operator\n    for i < l1Len && j < l2Len {\n          ^\n/tmp/tmpfyzm__zo.swift:13:19: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < l1Len && j < l2Len {\n          ~~~~~~~~^~~~~~~~~~~~\n/tmp/tmpfyzm__zo.swift:24:12: error: cannot convert return expression of type '[Any]' to return type '[Int]'\n    return common\n           ^\n/tmp/tmpfyzm__zo.swift:24:12: note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n    return common\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}