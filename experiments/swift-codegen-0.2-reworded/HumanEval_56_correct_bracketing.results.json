{
  "name": "HumanEval_56_correct_bracketing",
  "language": "swift",
  "prompt": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_set bool\n    var closing_bracket_index_set bool\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    var opening_bracket_stack_set bool\n    var closing_bracket_stack_set bool\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_set bool\n    var closing_bracket_stack_index_set bool\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp0_b1rl6e.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp0_b1rl6e.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp0_b1rl6e.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp0_b1rl6e.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp0_b1rl6e.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp0_b1rl6e.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp0_b1rl6e.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp0_b1rl6e.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp0_b1rl6e.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp0_b1rl6e.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp0_b1rl6e.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp0_b1rl6e.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppth0zmh7.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmppth0zmh7.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmppth0zmh7.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmppth0zmh7.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmppth0zmh7.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var open_brackets = 0\n    var close_brackets = 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            close_brackets += 1\n        }\n    }\n    return open_brackets == close_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpf_1hk_2k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpf_1hk_2k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpf_1hk_2k.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpf_1hk_2k.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    opening_brackets := 0\n    closing_brackets := 0\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_brackets += 1\n        } else if brackets[i] == '>' {\n            closing_brackets += 1\n        }\n    }\n    \n    if opening_brackets == closing_brackets {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp0fe5emzw.swift:17:21: error: consecutive statements on a line must be separated by ';'\n    opening_brackets := 0\n                    ^\n                    ;\n/tmp/tmp0fe5emzw.swift:17:22: error: expected expression\n    opening_brackets := 0\n                     ^\n/tmp/tmp0fe5emzw.swift:20:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp0fe5emzw.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp0fe5emzw.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp0fe5emzw.swift:21:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp0fe5emzw.swift:23:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmp0fe5emzw.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp0fe5emzw.swift:17:5: error: cannot find 'opening_brackets' in scope\n    opening_brackets := 0\n    ^~~~~~~~~~~~~~~~\n/tmp/tmp0fe5emzw.swift:28:8: error: cannot find 'opening_brackets' in scope\n    if opening_brackets == closing_brackets {\n       ^~~~~~~~~~~~~~~~\n/tmp/tmp0fe5emzw.swift:28:28: error: cannot find 'closing_brackets' in scope\n    if opening_brackets == closing_brackets {\n                           ^~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmldfud_3.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpmldfud_3.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpmldfud_3.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpmldfud_3.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpmldfud_3.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpmldfud_3.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpmldfud_3.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpmldfud_3.swift:26:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpmldfud_3.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp6xil28fl.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp6xil28fl.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp6xil28fl.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp6xil28fl.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6xil28fl.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp6xil28fl.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp6xil28fl.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmp6xil28fl.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp6xil28fl.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp6xil28fl.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp6xil28fl.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp6xil28fl.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmp6xil28fl.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n/tmp/tmp6xil28fl.swift:35:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpfgcgcma5.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpfgcgcma5.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpfgcgcma5.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpfgcgcma5.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpfgcgcma5.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpfgcgcma5.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpfgcgcma5.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpfgcgcma5.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpfgcgcma5.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpfgcgcma5.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpfgcgcma5.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpfgcgcma5.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpfgcgcma5.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpfgcgcma5.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n/tmp/tmpfgcgcma5.swift:35:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    var opening_brackets = []\n    var closing_brackets = []\n    for _, char := range brackets {\n        if char == \"<\" {\n            opening_bracket_count += 1\n            opening_brackets = append(opening_brackets, char)\n        } else if char == \">\" {\n            closing_bracket_count += 1\n            closing_brackets = append(closing_brackets, char)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_brackets); i += 1 {\n        if opening_brackets[i] != closing_brackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpu415lf6b.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpu415lf6b.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpu415lf6b.swift:29:12: error: expected type\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n            <#type#>\n/tmp/tmpu415lf6b.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n/tmp/tmpu415lf6b.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n/tmp/tmpu415lf6b.swift:15:28: error: empty collection literal requires an explicit type\n    var opening_brackets = []\n                           ^~\n/tmp/tmpu415lf6b.swift:16:28: error: empty collection literal requires an explicit type\n    var closing_brackets = []\n                           ^~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjqkvwwx9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjqkvwwx9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpjqkvwwx9.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpjqkvwwx9.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpjqkvwwx9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjqkvwwx9.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpd8gnp5a4.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpd8gnp5a4.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpd8gnp5a4.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpd8gnp5a4.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpd8gnp5a4.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpd8gnp5a4.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpd8gnp5a4.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpd8gnp5a4.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpwg8g4dqa.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpwg8g4dqa.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpwg8g4dqa.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpwg8g4dqa.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpwg8g4dqa.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpwg8g4dqa.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpwg8g4dqa.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpwg8g4dqa.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpylg56gyy.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpylg56gyy.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpylg56gyy.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpylg56gyy.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpylg56gyy.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpylg56gyy.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpylg56gyy.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpylg56gyy.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpylg56gyy.swift:27:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpylg56gyy.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpylg56gyy.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpylg56gyy.swift:30:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpylg56gyy.swift:30:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack:=[]int{0}\n    for i := 1; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if brackets[stack[len(stack) - 1]] != '>' {\n                return false\n            }\n            stack = stack[0 : len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpexw7kzzh.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{0}\n         ^\n         ;\n/tmp/tmpexw7kzzh.swift:16:10: error: expected expression\n    stack:=[]int{0}\n         ^\n/tmp/tmpexw7kzzh.swift:16:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{0}\n          ^\n            \n/tmp/tmpexw7kzzh.swift:17:12: error: expected type\n    for i := 1; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpexw7kzzh.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(brackets); i++ {\n           ^\n/tmp/tmpexw7kzzh.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(brackets); i++ {\n           ^\n/tmp/tmpexw7kzzh.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpexw7kzzh.swift:24:51: error: single-quoted string literal found, use '\"'\n            if brackets[stack[len(stack) - 1]] != '>' {\n                                                  ^~~\n                                                  \">\"\n/tmp/tmpexw7kzzh.swift:27:29: error: expected ',' separator\n            stack = stack[0 : len(stack) - 1]\n                            ^\n                           ,\n/tmp/tmpexw7kzzh.swift:27:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack) - 1]\n                            ^\n/tmp/tmpexw7kzzh.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpexw7kzzh.swift:16:5: error: cannot find 'stack' in scope\n    stack:=[]int{0}\n    ^~~~~\n/tmp/tmpexw7kzzh.swift:30:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpexw7kzzh.swift:30:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    \n    for _, char := range brackets {\n        if char == \"<\" {\n            opening_bracket_count += 1\n        } else if char == \">\" {\n            closing_bracket_count += 1\n        }\n    }\n    \n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    \n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == \"<\" && brackets[i + 1] != \">\" {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp8l2cq10y.swift:20:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp8l2cq10y.swift:20:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp8l2cq10y.swift:32:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp8l2cq10y.swift:32:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmp8l2cq10y.swift:32:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char String\n    var closing_bracket_char String\n    var opening_bracket_index_in_brackets int\n    var closing_bracket_index_in_brackets int\n    var opening_bracket_index_in_brackets_2 int\n    var closing_bracket_index_in_brackets_2 int\n    var opening_bracket_index_in_brackets_3 int\n    var closing_bracket_index_in_brackets_3 int\n    var opening_bracket_index_in_brackets_4 int\n    var closing_bracket_index_in_brackets_4 int\n    var opening_bracket_index_in_brackets_5 int\n    var closing_bracket_index_in_brackets_5 int\n    var opening_bracket_index_in_brackets_6 int\n    var closing_bracket_index_in_brackets_6 int\n    var opening_bracket_index_in_brackets_7 int\n    var closing_bracket_index_in_brackets_7 int\n    var opening_bracket_index_in_brackets_8 int\n    var closing_bracket_index_in_brackets_8 int\n    var opening_bracket_index_in_brackets_9 int\n    var closing_bracket_index_in_brackets_9 int\n    var opening_bracket_index_in_brackets_10 int\n    var closing_bracket_index_in_brackets_10 int\n    var opening_bracket_index_in_brackets_11 int\n    var closing_bracket_index_in_brackets_11 int\n    var opening_bracket_index_in_brackets_12 int\n    var closing_bracket_index_in_brackets_12 int\n    var opening_bracket_index_in_brackets_13 int\n    var closing_bracket_index_in_brackets_13 int\n    var opening_bracket_index_in_brackets_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpywraucjh.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpywraucjh.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpywraucjh.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpywraucjh.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpywraucjh.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpywraucjh.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpywraucjh.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpywraucjh.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpywraucjh.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpywraucjh.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpywraucjh.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpywraucjh.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets == 0 {\n            return true\n        }\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpwda1_kre.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpwda1_kre.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpwda1_kre.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpwda1_kre.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpwda1_kre.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpwda1_kre.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpwda1_kre.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpwda1_kre.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpwda1_kre.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpwda1_kre.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpwda1_kre.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpwda1_kre.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpwda1_kre.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpwda1_kre.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count == closing_bracket_count {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpx1e6n6lt.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpx1e6n6lt.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpx1e6n6lt.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpx1e6n6lt.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpx1e6n6lt.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpx1e6n6lt.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpx1e6n6lt.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpx1e6n6lt.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpx1e6n6lt.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpx1e6n6lt.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpx1e6n6lt.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpx1e6n6lt.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_in_string int\n    var closing_bracket_index_in_string int\n    var opening_bracket_index_in_string_inclusive bool\n    var closing_bracket_index_in_string_inclusive bool\n    var opening_bracket_index_in_string_exclusive int\n    var closing_bracket_index_in_string_exclusive int\n    var opening_bracket_index_in_string_exclusive_inclusive bool\n    var closing_bracket_index_in_string_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive int\n    var closing_bracket_index_in_string_exclusive_exclusive int\n    var opening_bracket_index_in_string_exclusive_exclusive_inclusive bool\n    var closing_bracket_index_in_string_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive int\n    var closing_bracket_index_in_string_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive int\n    var closing_bracket_index_in_string_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive int\n    var closing_bracket_index_in_string_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive bool\n    var opening_bracket_index_in_string_exclusive_exclusive_exclusive_inclusive int\n    var closing_bracket_index_in_string_exclusive_exclusive_inclusive bool\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyy2zeh8n.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpyy2zeh8n.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpyy2zeh8n.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpyy2zeh8n.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpyy2zeh8n.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpyy2zeh8n.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpyy2zeh8n.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpyy2zeh8n.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpyy2zeh8n.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpyy2zeh8n.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpyy2zeh8n.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpyy2zeh8n.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp9ym9d21w.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp9ym9d21w.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp9ym9d21w.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp9ym9d21w.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp9ym9d21w.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    \n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp48vdnl7y.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp48vdnl7y.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp48vdnl7y.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp48vdnl7y.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp48vdnl7y.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp48vdnl7y.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp48vdnl7y.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp48vdnl7y.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp48vdnl7y.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp48vdnl7y.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp48vdnl7y.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp48vdnl7y.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack := make([]rune, 0)\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp7ng7tzx8.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := make([]rune, 0)\n         ^\n         ;\n/tmp/tmp7ng7tzx8.swift:16:11: error: expected expression\n    stack := make([]rune, 0)\n          ^\n/tmp/tmp7ng7tzx8.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp7ng7tzx8.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp7ng7tzx8.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp7ng7tzx8.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmp7ng7tzx8.swift:27:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp7ng7tzx8.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp7ng7tzx8.swift:16:5: error: cannot find 'stack' in scope\n    stack := make([]rune, 0)\n    ^~~~~\n/tmp/tmp7ng7tzx8.swift:30:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp7ng7tzx8.swift:30:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_char_stack []string\n    var closing_bracket_char_stack []string\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_char = brackets[i]\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_char_stack = append(opening_bracket_char_stack, opening_bracket_char)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_char = brackets[i]\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_char_stack = append(closing_bracket_char_stack, closing_bracket_char)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpn5w3dqr2.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpn5w3dqr2.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpn5w3dqr2.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpn5w3dqr2.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpn5w3dqr2.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpn5w3dqr2.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpn5w3dqr2.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpn5w3dqr2.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpn5w3dqr2.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpn5w3dqr2.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpn5w3dqr2.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpn5w3dqr2.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var bracket_count int\n    var opening_bracket string\n    var closing_bracket string\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_count int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    var result bool\n    \n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket)\n            opening_bracket = \"\"\n            opening_bracket_index = i\n            opening_bracket_count = 1\n        } else if char == '>' {\n            closing_bracket = opening_bracket\n            closing_bracket_index = i\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket)\n            opening_bracket_count = 0\n            opening_bracket = \"\"\n        } else {\n            opening_bracket += char\n        }\n    }\n    \n    if opening_bracket_count != 0 {\n        return false\n    }\n    \n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_count = 1\n        } else if char == '>' {\n            opening_bracket_count = 0\n        }\n        \n        if opening_bracket_count == 0 {\n            if char == '<' {\n                opening_bracket = \"\"\n                opening_bracket_index = i\n                opening_bracket_count = 1\n            } else if char == '>' {\n                opening_bracket = \"\"\n                opening_bracket_index = i\n                opening_bracket_count = 1\n            } else {\n                opening_bracket += char\n            }\n        }\n    }\n    \n    if opening_bracket_count != 0 {\n        return false\n    }\n    \n    opening_bracket_count = 0\n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            opening_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpm02ff2yg.swift:13:23: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var bracket_count int\n                      ^\n/tmp/tmpm02ff2yg.swift:13:23: note: join the identifiers together\n    var bracket_count int\n        ~~~~~~~~~~~~~~^~~\n        bracket_countint\n/tmp/tmpm02ff2yg.swift:13:23: note: join the identifiers together with camel-case\n    var bracket_count int\n        ~~~~~~~~~~~~~~^~~\n        bracket_countInt\n/tmp/tmpm02ff2yg.swift:14:25: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket string\n                        ^\n/tmp/tmpm02ff2yg.swift:14:25: note: join the identifiers together\n    var opening_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        opening_bracketstring\n/tmp/tmpm02ff2yg.swift:14:25: note: join the identifiers together with camel-case\n    var opening_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        opening_bracketString\n/tmp/tmpm02ff2yg.swift:15:25: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket string\n                        ^\n/tmp/tmpm02ff2yg.swift:15:25: note: join the identifiers together\n    var closing_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        closing_bracketstring\n/tmp/tmpm02ff2yg.swift:15:25: note: join the identifiers together with camel-case\n    var closing_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        closing_bracketString\n/tmp/tmpm02ff2yg.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpm02ff2yg.swift:16:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpm02ff2yg.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpdvhfamth.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpdvhfamth.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpdvhfamth.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpdvhfamth.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpdvhfamth.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpdvhfamth.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpdvhfamth.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpdvhfamth.swift:25:29: error: expected ',' separator\n            stack = stack[0 : len(stack)-1]\n                            ^\n                           ,\n/tmp/tmpdvhfamth.swift:25:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack)-1]\n                            ^\n/tmp/tmpdvhfamth.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpdvhfamth.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpdvhfamth.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp7v2bpqtt.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp7v2bpqtt.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp7v2bpqtt.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp7v2bpqtt.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp7v2bpqtt.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp7v2bpqtt.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp7v2bpqtt.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp7v2bpqtt.swift:25:29: error: expected ',' separator\n            stack = stack[0 : len(stack) - 1]\n                            ^\n                           ,\n/tmp/tmp7v2bpqtt.swift:25:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack) - 1]\n                            ^\n/tmp/tmp7v2bpqtt.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp7v2bpqtt.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp7v2bpqtt.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, opening_bracket_count)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, closing_bracket_count)\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmphpy31egk.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmphpy31egk.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmphpy31egk.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmphpy31egk.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmphpy31egk.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmphpy31egk.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmphpy31egk.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmphpy31egk.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmphpy31egk.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmphpy31egk.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmphpy31egk.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmphpy31egk.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, '<')\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpu2rezsl1.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpu2rezsl1.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpu2rezsl1.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpu2rezsl1.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpu2rezsl1.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpu2rezsl1.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpu2rezsl1.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpu2rezsl1.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpu2rezsl1.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpu2rezsl1.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpu2rezsl1.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpu2rezsl1.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpu2rezsl1.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpcrjottbz.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpcrjottbz.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpcrjottbz.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpcrjottbz.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpcrjottbz.swift:17:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpcrjottbz.swift:17:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpcrjottbz.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpcrjottbz.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpcrjottbz.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpcrjottbz.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpcrjottbz.swift:28:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpcrjottbz.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmpcrjottbz.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp9ym9d21w.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp9ym9d21w.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp9ym9d21w.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp9ym9d21w.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp9ym9d21w.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppth0zmh7.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmppth0zmh7.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmppth0zmh7.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmppth0zmh7.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmppth0zmh7.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_set []int\n    var closing_bracket_set []int\n    var opening_bracket_index_set_length int\n    var closing_bracket_index_set_length int\n    var opening_bracket_set_length int\n    var closing_bracket_set_length int\n    var opening_bracket_index_set_index int\n    var closing_bracket_index_set_index int\n    var opening_bracket_set_index int\n    var closing_bracket_set_index int\n    var opening_bracket_index_set_index_set []int\n    var closing_bracket_index_set_index_set []int\n    var opening_bracket_set_index_set []int\n    var closing_bracket_set_index_set []int\n    var opening_bracket_index_set_index_set_length int\n    var closing_bracket_index_set_index_set_length int\n    var opening_bracket_set_index_set_length int\n    var closing_bracket_set_index_set_length int\n    var opening_bracket_index_set_index_set_index int\n    var closing_bracket_index_set_index_set_index int\n    var opening_bracket_set_index_set_index int\n    var closing_bracket_set_index_set_index int\n    var opening_bracket_index_set_index_set_index_set []int\n    var closing_bracket_index_set_index_set_index_set []int\n    var opening_bracket_set_index_set_index_set []int\n    var closing_bracket_set_index_set_index_set []int\n    var opening_bracket_index_set_index_set_index_set_length int\n    var closing_bracket_index_set_index_set_index_set\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpj9nnnx9b.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpj9nnnx9b.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpj9nnnx9b.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpj9nnnx9b.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpj9nnnx9b.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpj9nnnx9b.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpj9nnnx9b.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpj9nnnx9b.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpj9nnnx9b.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpj9nnnx9b.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpj9nnnx9b.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpj9nnnx9b.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, char)\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpevtinja9.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpevtinja9.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpevtinja9.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpevtinja9.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpevtinja9.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpevtinja9.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpevtinja9.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpevtinja9.swift:26:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpevtinja9.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpevtinja9.swift:33:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpevtinja9.swift:33:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpc6as4lne.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpc6as4lne.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpc6as4lne.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpc6as4lne.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpc6as4lne.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpc6as4lne.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpc6as4lne.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpc6as4lne.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpc6as4lne.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpc6as4lne.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpc6as4lne.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpu7890oxp.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpu7890oxp.swift:16:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpu7890oxp.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpu7890oxp.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpu7890oxp.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpu7890oxp.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpu7890oxp.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpu7890oxp.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpu7890oxp.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpu7890oxp.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpu7890oxp.swift:16:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpu7890oxp.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpu7890oxp.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := make([]rune, 0)\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp9t8tytgk.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := make([]rune, 0)\n         ^\n         ;\n/tmp/tmp9t8tytgk.swift:17:11: error: expected expression\n    stack := make([]rune, 0)\n          ^\n/tmp/tmp9t8tytgk.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp9t8tytgk.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp9t8tytgk.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp9t8tytgk.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp9t8tytgk.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp9t8tytgk.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmp9t8tytgk.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp9t8tytgk.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp9t8tytgk.swift:17:5: error: cannot find 'stack' in scope\n    stack := make([]rune, 0)\n    ^~~~~\n/tmp/tmp9t8tytgk.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp9t8tytgk.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmptk1f4qq1.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmptk1f4qq1.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmptk1f4qq1.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmptk1f4qq1.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmptk1f4qq1.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmptk1f4qq1.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmptk1f4qq1.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmptk1f4qq1.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmptk1f4qq1.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    var opening_bracket_index = 0\n    var closing_bracket_index = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < opening_bracket_count; i++ {\n        if brackets[opening_bracket_index + 1] != '>' {\n            return false\n        }\n        opening_bracket_index += 1\n        closing_bracket_index += 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmphokcpvi6.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmphokcpvi6.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmphokcpvi6.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmphokcpvi6.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmphokcpvi6.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmphokcpvi6.swift:29:12: error: expected type\n    for i := 0; i < opening_bracket_count; i++ {\n           ^\n            <#type#>\n/tmp/tmphokcpvi6.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < opening_bracket_count; i++ {\n           ^\n/tmp/tmphokcpvi6.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < opening_bracket_count; i++ {\n           ^\n/tmp/tmphokcpvi6.swift:30:51: error: single-quoted string literal found, use '\"'\n        if brackets[opening_bracket_index + 1] != '>' {\n                                                  ^~~\n                                                  \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, c)\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbdb3c_j1.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpbdb3c_j1.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpbdb3c_j1.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbdb3c_j1.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbdb3c_j1.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpbdb3c_j1.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpbdb3c_j1.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpbdb3c_j1.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpbdb3c_j1.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpbdb3c_j1.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var stack = []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbw6il66v.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []rune{}\n                  ^\n                  ;\n/tmp/tmpbw6il66v.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbw6il66v.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbw6il66v.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpbw6il66v.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpbw6il66v.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpbw6il66v.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpbw6il66v.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpbw6il66v.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []rune{}\n                ^~\n/tmp/tmpbw6il66v.swift:16:19: error: cannot find 'rune' in scope\n    var stack = []rune{}\n                  ^~~~\n/tmp/tmpbw6il66v.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_char_stack []string\n    var closing_bracket_char_stack []string\n    var opening_bracket_index_stack_length int\n    var closing_bracket_index_stack_length int\n    var opening_bracket_index_stack_index int\n    var closing_bracket_index_stack_index int\n    var opening_bracket_char_stack_length int\n    var closing_bracket_char_stack_length int\n    var opening_bracket_char_stack_index int\n    var closing_bracket_char_stack_index int\n    var opening_bracket_index_stack_index_max int\n    var closing_bracket_index_stack_index_max int\n    var opening_bracket_index_stack_index_min int\n    var closing_bracket_index_stack_index_min int\n    var opening_bracket_char_stack_index_max int\n    var closing_bracket_char_stack_index_max int\n    var opening_bracket_char_stack_index_min int\n    var closing_bracket_char_stack_index_min int\n    var opening_bracket_index_stack_index_max int\n    var closing_bracket_index_stack_index_min int\n    var opening_bracket_index_stack_index_min int\n    var closing_bracket_index_stack_index_min int\n    var opening_bracket_index_stack_index_min int\n    var closing_bracket_index_stack_index_min int\n    var opening_bracket_index_stack_index_min int\n    var closing_bracket_index_stack_index_min int\n    var opening_bracket_index_stack_index_min int\n    var closing_bracket_index_stack_index_min int\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp1e1kmhtm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp1e1kmhtm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp1e1kmhtm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp1e1kmhtm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp1e1kmhtm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp1e1kmhtm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp1e1kmhtm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp1e1kmhtm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp1e1kmhtm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp1e1kmhtm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp1e1kmhtm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp1e1kmhtm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjbs7c60p.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjbs7c60p.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjbs7c60p.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpjbs7c60p.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjbs7c60p.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjbs7c60p.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpjbs7c60p.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpjbs7c60p.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjbs7c60p.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpxrep_3f1.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpxrep_3f1.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpxrep_3f1.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpxrep_3f1.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpxrep_3f1.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpxrep_3f1.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpxrep_3f1.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpxrep_3f1.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpxrep_3f1.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpxrep_3f1.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpxrep_3f1.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpxrep_3f1.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, char)\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp668wf6io.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp668wf6io.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp668wf6io.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp668wf6io.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp668wf6io.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmp668wf6io.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp668wf6io.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmp668wf6io.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp668wf6io.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp668wf6io.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp668wf6io.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            if open_brackets == 0 {\n                return false\n            } else {\n                open_brackets -= 1\n            }\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppay9a32n.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmppay9a32n.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmppay9a32n.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmppay9a32n.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppay9a32n.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppay9a32n.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmppay9a32n.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmppay9a32n.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmppay9a32n.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            opening_brackets += 1\n        } else if c == '>' {\n            closing_brackets += 1\n        }\n    }\n    if opening_brackets == 0 || closing_brackets == 0 {\n        return false\n    }\n    if opening_brackets != closing_brackets {\n        return false\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            if i == 0 || brackets[i-1] != '<' {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp_qgb0k3g.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp_qgb0k3g.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp_qgb0k3g.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp_qgb0k3g.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp_qgb0k3g.swift:31:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp_qgb0k3g.swift:31:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_qgb0k3g.swift:31:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_qgb0k3g.swift:32:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp_qgb0k3g.swift:33:43: error: single-quoted string literal found, use '\"'\n            if i == 0 || brackets[i-1] != '<' {\n                                          ^~~\n                                          \"<\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, char)\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpn9psrkbo.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpn9psrkbo.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpn9psrkbo.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpn9psrkbo.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpn9psrkbo.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpn9psrkbo.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpn9psrkbo.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpn9psrkbo.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpn9psrkbo.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpn9psrkbo.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpn9psrkbo.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpcrjottbz.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpcrjottbz.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpcrjottbz.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpcrjottbz.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpcrjottbz.swift:17:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpcrjottbz.swift:17:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpcrjottbz.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpcrjottbz.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpcrjottbz.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpcrjottbz.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpcrjottbz.swift:28:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpcrjottbz.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmpcrjottbz.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var stack: List[String] = []\n    for _, c := range brackets {\n        if c == '<' {\n            stack.Push(c)\n        } else {\n            if stack.IsEmpty() {\n                return false\n            }\n            if stack.Peek() != '<' {\n                return false\n            }\n            stack.Pop()\n        }\n    }\n    if stack.IsEmpty() {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp0h3piasi.swift:16:20: error: array types are now written with the brackets around the element type\n    var stack: List[String] = []\n                   ^\n               [   \n/tmp/tmp0h3piasi.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp0h3piasi.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp0h3piasi.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp0h3piasi.swift:24:32: error: single-quoted string literal found, use '\"'\n            if stack.Peek() != '<' {\n                               ^~~\n                               \"<\"\n/tmp/tmp0h3piasi.swift:16:16: error: cannot find type 'List' in scope\n    var stack: List[String] = []\n               ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_brackets += 1\n        } else if brackets[i] == '>' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppx1lm2u4.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmppx1lm2u4.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppx1lm2u4.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppx1lm2u4.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmppx1lm2u4.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_brackets += 1\n        } else if brackets[i] == '>' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppx1lm2u4.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmppx1lm2u4.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppx1lm2u4.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmppx1lm2u4.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmppx1lm2u4.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbeu6jh7z.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbeu6jh7z.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbeu6jh7z.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpbeu6jh7z.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpbeu6jh7z.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpbeu6jh7z.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpbeu6jh7z.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpbeu6jh7z.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpbeu6jh7z.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpbeu6jh7z.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpbeu6jh7z.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbeu6jh7z.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpbeu6jh7z.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, '<')\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpv8hlxxhz.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpv8hlxxhz.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpv8hlxxhz.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpv8hlxxhz.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpv8hlxxhz.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpv8hlxxhz.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpv8hlxxhz.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpv8hlxxhz.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpv8hlxxhz.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpv8hlxxhz.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpv8hlxxhz.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpduyir4ba.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpduyir4ba.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpduyir4ba.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpduyir4ba.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpduyir4ba.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpduyir4ba.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpduyir4ba.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpduyir4ba.swift:26:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := range brackets {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    for {\n        if len(opening_bracket_index_stack) == 0 {\n            return true\n        }\n        opening_bracket_index = opening_bracket_index_stack[len(opening_bracket_index_stack) - 1]\n        opening_bracket_index_stack = opening_bracket_index_stack[:len(opening_bracket_index_stack) - 1]\n        if opening_bracket_count == closing_bracket_count {\n            continue\n        }\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp00eigvbm.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp00eigvbm.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp00eigvbm.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp00eigvbm.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp00eigvbm.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp00eigvbm.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp00eigvbm.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp00eigvbm.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp00eigvbm.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp00eigvbm.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp00eigvbm.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp00eigvbm.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack:=[]\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            stack[last] = i\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpzsnhr0sk.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]\n         ^\n         ;\n/tmp/tmpzsnhr0sk.swift:17:10: error: expected expression\n    stack:=[]\n         ^\n/tmp/tmpzsnhr0sk.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]\n          ^\n            \n/tmp/tmpzsnhr0sk.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpzsnhr0sk.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpzsnhr0sk.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpzsnhr0sk.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpzsnhr0sk.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpzsnhr0sk.swift:25:17: error: consecutive statements on a line must be separated by ';'\n            last := len(stack) - 1\n                ^\n                ;\n/tmp/tmpzsnhr0sk.swift:25:18: error: expected expression\n            last := len(stack) - 1\n                 ^\n/tmp/tmpzsnhr0sk.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpzsnhr0sk.swift:17:5: error: cannot find 'stack' in scope\n    stack:=[]\n    ^~~~~\n/tmp/tmpzsnhr0sk.swift:30:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpzsnhr0sk.swift:30:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack:=[]int{}\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            stack[last] = i\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmnthfs01.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{}\n         ^\n         ;\n/tmp/tmpmnthfs01.swift:17:10: error: expected expression\n    stack:=[]int{}\n         ^\n/tmp/tmpmnthfs01.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{}\n          ^\n            \n/tmp/tmpmnthfs01.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmnthfs01.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmnthfs01.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmnthfs01.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmnthfs01.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpmnthfs01.swift:25:17: error: consecutive statements on a line must be separated by ';'\n            last := len(stack) - 1\n                ^\n                ;\n/tmp/tmpmnthfs01.swift:25:18: error: expected expression\n            last := len(stack) - 1\n                 ^\n/tmp/tmpmnthfs01.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpmnthfs01.swift:17:5: error: cannot find 'stack' in scope\n    stack:=[]int{}\n    ^~~~~\n/tmp/tmpmnthfs01.swift:30:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpmnthfs01.swift:30:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            opening_brackets += 1\n        } else if c == '>' {\n            closing_brackets += 1\n        }\n    }\n    return opening_brackets == closing_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmph2f55i54.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmph2f55i54.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmph2f55i54.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmph2f55i54.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmph2f55i54.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if char == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_index_stack) - 1; i >= 0; i -= 1 {\n        opening_bracket_index = opening_bracket_index_stack[i]\n        closing_bracket_index = closing_bracket_index_stack[i]\n        if opening_bracket_index > closing_bracket_index {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp47k1_6aa.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp47k1_6aa.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp47k1_6aa.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp47k1_6aa.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp47k1_6aa.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp47k1_6aa.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp47k1_6aa.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp47k1_6aa.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp47k1_6aa.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp47k1_6aa.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp47k1_6aa.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp47k1_6aa.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_found bool\n    var closing_bracket_index_found bool\n    var opening_bracket_index_found_bool bool\n    var opening_bracket_index_found_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index_found_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool_bool bool\n    var opening_bracket_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmprag3b36c.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmprag3b36c.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmprag3b36c.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmprag3b36c.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmprag3b36c.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmprag3b36c.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmprag3b36c.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmprag3b36c.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmprag3b36c.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmprag3b36c.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmprag3b36c.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmprag3b36c.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set = make([]int, 0)\n    var closing_bracket_index_set = make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_set = append(opening_bracket_index_set, opening_bracket_index)\n        } else if brackets[i] == '>' {\n            closing_bracket_count++\n            closing_bracket_index = i\n            closing_bracket_index_set = append(closing_bracket_index_set, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_set); i++ {\n        if opening_bracket_index_set[i] != closing_bracket_index_set[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpnk2jcfx0.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpnk2jcfx0.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpnk2jcfx0.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpnk2jcfx0.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpnk2jcfx0.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpnk2jcfx0.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpnk2jcfx0.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpnk2jcfx0.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpnk2jcfx0.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpnk2jcfx0.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpnk2jcfx0.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpnk2jcfx0.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, c := range brackets {\n        if c == '<' {\n            opening_bracket_count += 1\n        } else if c == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpzl5qoqf1.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpzl5qoqf1.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpzl5qoqf1.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpzl5qoqf1.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_len int\n    var opening_bracket_index_set_len_max int\n    var opening_bracket_index_set_len_min int\n    var opening_bracket_index_set_len_sum int\n    var opening_bracket_index_set_len_sum_square int\n    var opening_bracket_index_set_len_square_root int\n    var opening_bracket_index_set_len_cubed int\n    var opening_bracket_index_set_len_cubed_root int\n    var opening_bracket_index_set_len_reciprocal int\n    var opening_bracket_index_set_len_reciprocal_square int\n    var opening_bracket_index_set_len_reciprocal_cubed int\n    var opening_bracket_index_set_len_reciprocal_square_root int\n    var opening_bracket_index_set_len_reciprocal_cubed_root int\n    var opening_bracket_index_set_len_log int\n    var opening_bracket_index_set_len_log_square int\n    var opening_bracket_index_set_len_log_cubed int\n    var opening_bracket_index_set_len_log_square_root int\n    var opening_bracket_index_set_len_log_cubed_root int\n    var opening_bracket_index_set_len_exp int\n    var opening_bracket_index_set_len_exp_square int\n    var opening_bracket_index_set_len_exp_cubed int\n    var opening_bracket_index_set_len_exp_square_root int\n    var opening_bracket_index_set_len_exp_cubed_root int\n    var opening_bracket_index_set_len\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpu0lw5kzf.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpu0lw5kzf.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpu0lw5kzf.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpu0lw5kzf.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpu0lw5kzf.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpu0lw5kzf.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpu0lw5kzf.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpu0lw5kzf.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpu0lw5kzf.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpu0lw5kzf.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpu0lw5kzf.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpu0lw5kzf.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var open_bracket_count int\n    var close_bracket_count int\n    var opening_bracket string\n    var closing_bracket string\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_found bool\n    var closing_bracket_index_found bool\n    var opening_bracket_index_found_in_closing_bracket bool\n    var opening_bracket_index_found_in_opening_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing_bracket_in_opening_bracket bool\n    var opening_bracket_index_found_in_opening_bracket_in_closing_bracket bool\n    var opening_bracket_index_found_in_closing\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpayeurh25.swift:13:28: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var open_bracket_count int\n                           ^\n/tmp/tmpayeurh25.swift:13:28: note: join the identifiers together\n    var open_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~^~~\n        open_bracket_countint\n/tmp/tmpayeurh25.swift:13:28: note: join the identifiers together with camel-case\n    var open_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~^~~\n        open_bracket_countInt\n/tmp/tmpayeurh25.swift:14:29: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var close_bracket_count int\n                            ^\n/tmp/tmpayeurh25.swift:14:29: note: join the identifiers together\n    var close_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~^~~\n        close_bracket_countint\n/tmp/tmpayeurh25.swift:14:29: note: join the identifiers together with camel-case\n    var close_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~^~~\n        close_bracket_countInt\n/tmp/tmpayeurh25.swift:15:25: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket string\n                        ^\n/tmp/tmpayeurh25.swift:15:25: note: join the identifiers together\n    var opening_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        opening_bracketstring\n/tmp/tmpayeurh25.swift:15:25: note: join the identifiers together with camel-case\n    var opening_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        opening_bracketString\n/tmp/tmpayeurh25.swift:16:25: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket string\n                        ^\n/tmp/tmpayeurh25.swift:16:25: note: join the identifiers together\n    var closing_bracket string\n        ~~~~~~~~~~~~~~~~^~~~~~\n        closing_bracketstring\n/tmp/tmpayeurh25.swift:16:25: note: join the identifiers together with camel-case\n    var closing_bracket string\n        ~~~~~~~~~~~",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    close_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '>' {\n            close_brackets += 1\n        }\n    }\n    \n    if close_brackets == open_brackets {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmp9nqxnq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpmp9nqxnq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmp9nqxnq.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    close_brackets := 0\n                  ^\n                  ;\n/tmp/tmpmp9nqxnq.swift:28:20: error: expected expression\n    close_brackets := 0\n                   ^\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpmp9nqxnq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:28:5: error: cannot find 'close_brackets' in scope\n    close_brackets := 0\n    ^~~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:35:8: error: cannot find ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpit69kraw.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpit69kraw.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpit69kraw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpit69kraw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpit69kraw.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpit69kraw.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpit69kraw.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpit69kraw.swift:25:29: error: expected ',' separator\n            stack = stack[0 : len(stack) - 1]\n                            ^\n                           ,\n/tmp/tmpit69kraw.swift:25:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack) - 1]\n                            ^\n/tmp/tmpit69kraw.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpit69kraw.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpit69kraw.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_stack = append(opening_bracket_stack, brackets[opening_bracket_index])\n        } else if char == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            closing_bracket_stack = append(closing_bracket_stack, brackets[closing_bracket_index])\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i -= 1 {\n        if opening_bracket_stack[i] != closing_bracket_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpawpsyglf.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpawpsyglf.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpawpsyglf.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpawpsyglf.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpawpsyglf.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpawpsyglf.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpawpsyglf.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpawpsyglf.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpawpsyglf.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpawpsyglf.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpawpsyglf.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpawpsyglf.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var open_bracket_count = 0\n    var close_bracket_count = 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_bracket_count += 1\n        } else if c == '>' {\n            close_bracket_count += 1\n        }\n    }\n    return open_bracket_count == close_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp8p6u1sui.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp8p6u1sui.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp8p6u1sui.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp8p6u1sui.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count == closing_bracket_count {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpx1e6n6lt.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpx1e6n6lt.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpx1e6n6lt.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpx1e6n6lt.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpx1e6n6lt.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpx1e6n6lt.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpx1e6n6lt.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpx1e6n6lt.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpx1e6n6lt.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpx1e6n6lt.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpx1e6n6lt.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpx1e6n6lt.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp9ym9d21w.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp9ym9d21w.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp9ym9d21w.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp9ym9d21w.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp9ym9d21w.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    close_brackets := 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            close_brackets += 1\n        }\n    }\n    \n    if close_brackets == open_brackets {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpex1x3ify.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpex1x3ify.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpex1x3ify.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpex1x3ify.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpex1x3ify.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpex1x3ify.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpex1x3ify.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    close_brackets := 0\n                  ^\n                  ;\n/tmp/tmpex1x3ify.swift:28:20: error: expected expression\n    close_brackets := 0\n                   ^\n/tmp/tmpex1x3ify.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpex1x3ify.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpex1x3ify.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpex1x3ify.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpex1x3ify.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpex1x3ify.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpex1x3ify.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpex1x3ify.swift:28:5: error: cannot find ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, c := range brackets {\n        if c == '<' {\n            opening_bracket_count += 1\n        } else if c == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbc066dhp.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpbc066dhp.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpbc066dhp.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpbc066dhp.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpbc066dhp.swift:17:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpbc066dhp.swift:17:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpbc066dhp.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbc066dhp.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbc066dhp.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpbc066dhp.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpbc066dhp.swift:28:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpbc066dhp.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmpbc066dhp.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets_count := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets_count += 1\n        }\n        \n        if brackets[i] == '>' {\n            open_brackets_count -= 1\n        }\n        \n        if open_brackets_count < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets_count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp_h2xdkb7.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp_h2xdkb7.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp_h2xdkb7.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp_h2xdkb7.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_h2xdkb7.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_h2xdkb7.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp_h2xdkb7.swift:28:24: error: consecutive statements on a line must be separated by ';'\n    open_brackets_count := 0\n                       ^\n                       ;\n/tmp/tmp_h2xdkb7.swift:28:25: error: expected expression\n    open_brackets_count := 0\n                        ^\n/tmp/tmp_h2xdkb7.swift:29:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp_h2xdkb7.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_h2xdkb7.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_h2xdkb7.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp_h2xdkb7.swift:34:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp_h2xdkb7.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp_h2xdkb7.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpgx1kmelo.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpgx1kmelo.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpgx1kmelo.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpgx1kmelo.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpgx1kmelo.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, '<')\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp72e9fjkw.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp72e9fjkw.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp72e9fjkw.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp72e9fjkw.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp72e9fjkw.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmp72e9fjkw.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp72e9fjkw.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp72e9fjkw.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmp72e9fjkw.swift:26:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmp72e9fjkw.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp72e9fjkw.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp72e9fjkw.swift:33:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp72e9fjkw.swift:33:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var open_brackets = 0\n    var close_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            close_brackets += 1\n        }\n    }\n    if open_brackets != close_brackets {\n        return false\n    }\n    for i := 0; i < len(brackets) - 1; i++ {\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpecmpsnsi.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpecmpsnsi.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpecmpsnsi.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpecmpsnsi.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpecmpsnsi.swift:28:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpecmpsnsi.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmpecmpsnsi.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets) - 1; i++ {\n           ^\n/tmp/tmpecmpsnsi.swift:29:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n                          ^~~\n                          \"<\"\n/tmp/tmpecmpsnsi.swift:29:53: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n                                                    ^~~\n                                                    \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, '<')\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpoyc2elrt.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpoyc2elrt.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpoyc2elrt.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpoyc2elrt.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpoyc2elrt.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpoyc2elrt.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpoyc2elrt.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpoyc2elrt.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpoyc2elrt.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpoyc2elrt.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpoyc2elrt.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_set []int\n    var closing_bracket_set []int\n    var opening_bracket_index_set_len int\n    var closing_bracket_index_set_len int\n    var opening_bracket_set_len int\n    var closing_bracket_set_len int\n    var opening_bracket_index_set_len_max int\n    var opening_bracket_index_set_len_min int\n    var opening_bracket_set_len_max int\n    var opening_bracket_set_len_min int\n    var closing_bracket_index_set_len_max int\n    var closing_bracket_index_set_len_min int\n    var closing_bracket_set_len_max int\n    var closing_bracket_set_len_min int\n    var opening_bracket_index_set_len_sum int\n    var opening_bracket_set_len_sum int\n    var closing_bracket_index_set_len_sum int\n    var closing_bracket_set_len_sum int\n    var opening_bracket_index_set_len_avg float64\n    var opening_bracket_set_len_avg float64\n    var closing_bracket_index_set_len_avg float64\n    var closing_bracket_set_len_avg float64\n    var opening_bracket_index_set_len_stddev float64\n    var opening_bracket_set_len_stddev float64\n    var closing_bracket_index_set_len_stddev float64\n    var closing_bracket_set_len_stddev float64\n    var opening_bracket_index_set_len_sum_square float64\n    var opening_bracket_set_len_sum_square float64\n    var closing_bracket_index_set_len_sum_square\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp03p8tkml.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp03p8tkml.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp03p8tkml.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp03p8tkml.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp03p8tkml.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp03p8tkml.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp03p8tkml.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp03p8tkml.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp03p8tkml.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp03p8tkml.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp03p8tkml.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp03p8tkml.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpgx1kmelo.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpgx1kmelo.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpgx1kmelo.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpgx1kmelo.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpgx1kmelo.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpljfdpdue.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpljfdpdue.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpljfdpdue.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpljfdpdue.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpljfdpdue.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpljfdpdue.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpljfdpdue.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpljfdpdue.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpljfdpdue.swift:26:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpljfdpdue.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpljfdpdue.swift:33:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpljfdpdue.swift:33:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpm8bo515a.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpm8bo515a.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpm8bo515a.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpm8bo515a.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpm8bo515a.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpm8bo515a.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpm8bo515a.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpm8bo515a.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpm8bo515a.swift:27:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var opening_bracket_count_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_count_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_count_stack = append(opening_bracket_count_stack, opening_bracket_count)\n        } else if brackets[i] == '>' {\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n            opening_bracket_count--\n            if opening_bracket_count == 0 {\n                if opening_bracket_index_stack[len(opening_bracket_index_stack) - 1] == opening_bracket_index {\n                    opening_bracket_count_stack[len(opening_bracket_count_stack) - 1]--\n                    if opening_bracket_count_stack[len(opening_bracket_count_stack) - 1] == 0 {\n                        return true\n                    }\n                } else {\n                    return false\n                }\n            }\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpvie1pf0u.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpvie1pf0u.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpvie1pf0u.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpvie1pf0u.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpvie1pf0u.swift:17:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpvie1pf0u.swift:17:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpvie1pf0u.swift:18:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpvie1pf0u.swift:18:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpvie1pf0u.swift:18:31: note: join the identifiers together with camel-case\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexInt\n/tmp/tmpvie1pf0u.swift:19:36: error: consecutive statements on a line must be separated by ';'\n    var opening_bracket_index_stack []int\n                                   ^\n                                   ;\n/tmp/tmpvie1pf0u.swift:19:39: error: consecutive statements on a line must be separated by ';'\n    var opening_bracket_index_stack []int\n                                      ^\n                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpd8gnp5a4.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpd8gnp5a4.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpd8gnp5a4.swift:17:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpd8gnp5a4.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpd8gnp5a4.swift:18:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpd8gnp5a4.swift:20:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpd8gnp5a4.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpd8gnp5a4.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, '<')\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbib_8_uv.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpbib_8_uv.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpbib_8_uv.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpbib_8_uv.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpbib_8_uv.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpbib_8_uv.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpbib_8_uv.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if r == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpbib_8_uv.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpbib_8_uv.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpbib_8_uv.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpbib_8_uv.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpbib_8_uv.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpbib_8_uv.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp68zv02nt.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp68zv02nt.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp68zv02nt.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp68zv02nt.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp68zv02nt.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp68zv02nt.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp68zv02nt.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp68zv02nt.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp68zv02nt.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp68zv02nt.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp68zv02nt.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp68zv02nt.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp5b8pezek.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5b8pezek.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5b8pezek.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp5b8pezek.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp5b8pezek.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5b8pezek.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpdw9mjui4.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpdw9mjui4.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpdw9mjui4.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpdw9mjui4.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpdw9mjui4.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpdw9mjui4.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpdw9mjui4.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpdw9mjui4.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpdw9mjui4.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpdw9mjui4.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpdw9mjui4.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpdw9mjui4.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpgx1kmelo.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpgx1kmelo.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpgx1kmelo.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpgx1kmelo.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpgx1kmelo.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    \n    for i, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if char == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    \n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    \n    for i := len(opening_bracket_index_stack) - 1; i >= 0; i -= 1 {\n        opening_bracket_index = opening_bracket_index_stack[i]\n        closing_bracket_index = closing_bracket_index_stack[i]\n        if opening_bracket_index > closing_bracket_index {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp7rfs1bqz.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp7rfs1bqz.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp7rfs1bqz.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp7rfs1bqz.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp7rfs1bqz.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp7rfs1bqz.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp7rfs1bqz.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp7rfs1bqz.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp7rfs1bqz.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp7rfs1bqz.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp7rfs1bqz.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp7rfs1bqz.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_in_string int\n    var closing_bracket_index_in_string int\n    var opening_bracket_index_in_string_2 int\n    var closing_bracket_index_in_string_2 int\n    var opening_bracket_index_in_string_3 int\n    var closing_bracket_index_in_string_3 int\n    var opening_bracket_index_in_string_4 int\n    var closing_bracket_index_in_string_4 int\n    var opening_bracket_index_in_string_5 int\n    var closing_bracket_index_in_string_5 int\n    var opening_bracket_index_in_string_6 int\n    var closing_bracket_index_in_string_6 int\n    var opening_bracket_index_in_string_7 int\n    var closing_bracket_index_in_string_7 int\n    var opening_bracket_index_in_string_8 int\n    var closing_bracket_index_in_string_8 int\n    var opening_bracket_index_in_string_9 int\n    var closing_bracket_index_in_string_9 int\n    var opening_bracket_index_in_string_10 int\n    var closing_bracket_index_in_string_10 int\n    var opening_bracket_index_in_string_11 int\n    var closing_bracket_index_in_string_11 int\n    var opening_bracket_index_in_string_12 int\n    var closing_bracket_index_in_string_12 int\n    var opening_bracket_index_in_string_13 int\n    var closing_bracket_index_in_string_13 int\n    var opening_bracket_index_in_string_14 int\n    var closing_bracket_index_in_string_14 int\n    var opening_bracket_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp4ebph8w_.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp4ebph8w_.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp4ebph8w_.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp4ebph8w_.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp4ebph8w_.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp4ebph8w_.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp4ebph8w_.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp4ebph8w_.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp4ebph8w_.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp4ebph8w_.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp4ebph8w_.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp4ebph8w_.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmwuonit9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpmwuonit9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpmwuonit9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmwuonit9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmwuonit9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmwuonit9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmwuonit9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpmwuonit9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpmwuonit9.swift:29:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpl9hp46zr.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpl9hp46zr.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpl9hp46zr.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpl9hp46zr.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpl9hp46zr.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpl9hp46zr.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpl9hp46zr.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpl9hp46zr.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpl9hp46zr.swift:27:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp5b8pezek.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5b8pezek.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5b8pezek.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp5b8pezek.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp5b8pezek.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5b8pezek.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    var opening_brackets = []\n    var closing_brackets = []\n    for _, c := range brackets {\n        if c == '<' {\n            opening_bracket_count += 1\n            opening_brackets = append(opening_brackets, c)\n        } else if c == '>' {\n            closing_bracket_count += 1\n            closing_brackets = append(closing_brackets, c)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_brackets); i += 1 {\n        if opening_brackets[i] != closing_brackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp208nx4zd.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp208nx4zd.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp208nx4zd.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp208nx4zd.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp208nx4zd.swift:29:12: error: expected type\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n            <#type#>\n/tmp/tmp208nx4zd.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n/tmp/tmp208nx4zd.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(opening_brackets); i += 1 {\n           ^\n/tmp/tmp208nx4zd.swift:15:28: error: empty collection literal requires an explicit type\n    var opening_brackets = []\n                           ^~\n/tmp/tmp208nx4zd.swift:16:28: error: empty collection literal requires an explicit type\n    var closing_brackets = []\n                           ^~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp5b8pezek.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5b8pezek.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5b8pezek.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp5b8pezek.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp5b8pezek.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5b8pezek.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpc9uartj1.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpc9uartj1.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpc9uartj1.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpc9uartj1.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpc9uartj1.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpc9uartj1.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpc9uartj1.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpc9uartj1.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpc9uartj1.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpc9uartj1.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpc9uartj1.swift:13:9: error: type annotation missing in pattern\n    var opening_bracket_count int\n        ^\n/tmp/tmpc9uartj1.swift:14:9: error: type annotation missing in pattern\n    var closing_bracket_count int\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    \n    if opening_bracket_count == closing_bracket_count {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpqpsfnnan.swift:20:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpqpsfnnan.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqpsfnnan.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpqpsfnnan.swift:21:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpqpsfnnan.swift:23:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var open_brackets = 0\n    var close_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            close_brackets += 1\n        }\n    }\n    return open_brackets == close_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp1en79yr6.swift:15:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp1en79yr6.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp1en79yr6.swift:16:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp1en79yr6.swift:18:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var closing_bracket_count int\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(brackets) - 1; i += 1 {\n        if brackets[i] == '<' && brackets[i + 1] != '>' {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpo8l6048l.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpo8l6048l.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpo8l6048l.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpo8l6048l.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpo8l6048l.swift:17:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpo8l6048l.swift:17:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpo8l6048l.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpo8l6048l.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpo8l6048l.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpo8l6048l.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpo8l6048l.swift:28:12: error: expected type\n    for i := 0; i < len(brackets) - 1; i += 1 {\n           ^\n            <#type#>\n/tmp/tmpo8l6048l.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets) - 1; i += 1 {\n           ^\n/tmp/tmpo8l6048l.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(bra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_brackets += 1\n        } else if brackets[i] == '>' {\n            closing_brackets += 1\n        }\n    }\n    if opening_brackets == closing_brackets {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp3utzl5vu.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp3utzl5vu.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3utzl5vu.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp3utzl5vu.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp3utzl5vu.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    var open_brackets = 0\n    var close_brackets = 0\n    \n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            close_brackets += 1\n        }\n    }\n    \n    if open_brackets == close_brackets {\n        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpys5l3_4g.swift:20:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpys5l3_4g.swift:20:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpys5l3_4g.swift:20:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpys5l3_4g.swift:21:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpys5l3_4g.swift:23:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp_n41ob1r.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp_n41ob1r.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp_n41ob1r.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp_n41ob1r.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_n41ob1r.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp_n41ob1r.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp_n41ob1r.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp_n41ob1r.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp_n41ob1r.swift:30:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_set bool\n    var closing_bracket_index_set bool\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_set bool\n    var closing_bracket_stack_set bool\n    var opening_bracket_stack_index_set bool\n    var closing_bracket_stack_index_set bool\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpw2fhk4h5.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpw2fhk4h5.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpw2fhk4h5.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpw2fhk4h5.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpw2fhk4h5.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpw2fhk4h5.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpw2fhk4h5.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpw2fhk4h5.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpw2fhk4h5.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpw2fhk4h5.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpw2fhk4h5.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpw2fhk4h5.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            if open_brackets == 0 {\n                return false\n            }\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmwuonit9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpmwuonit9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpmwuonit9.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmwuonit9.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmwuonit9.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmwuonit9.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmwuonit9.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpmwuonit9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpmwuonit9.swift:29:8: error: cannot find 'open_brackets' in scope\n    if open_brackets != 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack:=[]int{}\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            \n            last := len(stack) - 1\n            stack[last] = i\n            stack = stack[:last]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpygtbevib.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{}\n         ^\n         ;\n/tmp/tmpygtbevib.swift:17:10: error: expected expression\n    stack:=[]int{}\n         ^\n/tmp/tmpygtbevib.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{}\n          ^\n            \n/tmp/tmpygtbevib.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpygtbevib.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpygtbevib.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpygtbevib.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpygtbevib.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpygtbevib.swift:26:17: error: consecutive statements on a line must be separated by ';'\n            last := len(stack) - 1\n                ^\n                ;\n/tmp/tmpygtbevib.swift:26:18: error: expected expression\n            last := len(stack) - 1\n                 ^\n/tmp/tmpygtbevib.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpygtbevib.swift:17:5: error: cannot find 'stack' in scope\n    stack:=[]int{}\n    ^~~~~\n/tmp/tmpygtbevib.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpygtbevib.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpduyir4ba.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpduyir4ba.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpduyir4ba.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpduyir4ba.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpduyir4ba.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpduyir4ba.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpduyir4ba.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpduyir4ba.swift:26:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets < 0 {\n            return false\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjbs7c60p.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjbs7c60p.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjbs7c60p.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpjbs7c60p.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjbs7c60p.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjbs7c60p.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpjbs7c60p.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpjbs7c60p.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjbs7c60p.swift:30:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_brackets = 0\n    var closing_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            opening_brackets += 1\n        } else if c == '>' {\n            closing_brackets += 1\n        }\n    }\n    if opening_brackets != closing_brackets {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmppuyl23wr.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmppuyl23wr.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmppuyl23wr.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmppuyl23wr.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack:=[]int{0}\n    for i:=0; i<len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, 0)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpqqnodb5o.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{0}\n         ^\n         ;\n/tmp/tmpqqnodb5o.swift:16:10: error: expected expression\n    stack:=[]int{0}\n         ^\n/tmp/tmpqqnodb5o.swift:16:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{0}\n          ^\n            \n/tmp/tmpqqnodb5o.swift:17:11: error: '=' must have consistent whitespace on both sides\n    for i:=0; i<len(brackets); i++ {\n          ^\n            \n/tmp/tmpqqnodb5o.swift:17:11: error: expected type\n    for i:=0; i<len(brackets); i++ {\n          ^\n           <#type#>\n/tmp/tmpqqnodb5o.swift:17:11: error: expected 'in' after for-each pattern\n    for i:=0; i<len(brackets); i++ {\n          ^\n/tmp/tmpqqnodb5o.swift:17:11: error: expected Sequence expression for for-each loop\n    for i:=0; i<len(brackets); i++ {\n          ^\n/tmp/tmpqqnodb5o.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpqqnodb5o.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpqqnodb5o.swift:24:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpqqnodb5o.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpqqnodb5o.swift:16:5: error: cannot find 'stack' in scope\n    stack:=[]int{0}\n    ^~~~~\n/tmp/tmpqqnodb5o.swift:27:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpqqnodb5o.swift:27:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpb7i_1oi2.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpb7i_1oi2.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpb7i_1oi2.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpb7i_1oi2.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpb7i_1oi2.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpb7i_1oi2.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpnvmec7sl.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpnvmec7sl.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpnvmec7sl.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpnvmec7sl.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpnvmec7sl.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpnvmec7sl.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpnvmec7sl.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpnvmec7sl.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpnvmec7sl.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpwg8g4dqa.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpwg8g4dqa.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpwg8g4dqa.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpwg8g4dqa.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpwg8g4dqa.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpwg8g4dqa.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpwg8g4dqa.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpwg8g4dqa.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpz674uqsq.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpz674uqsq.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpz674uqsq.swift:18:10: error: expected 'in' after for-each pattern\n    for _, r := range brackets {\n         ^\n/tmp/tmpz674uqsq.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, r := range brackets {\n         ^\n/tmp/tmpz674uqsq.swift:19:17: error: single-quoted string literal found, use '\"'\n        if r == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpz674uqsq.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpz674uqsq.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpz674uqsq.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpz674uqsq.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpz674uqsq.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpz674uqsq.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp9ym9d21w.swift:16:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp9ym9d21w.swift:16:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp9ym9d21w.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp9ym9d21w.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp9ym9d21w.swift:16:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp9ym9d21w.swift:24:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack:=[]int{0}\n    for i := 1; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpamepmfi6.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{0}\n         ^\n         ;\n/tmp/tmpamepmfi6.swift:17:10: error: expected expression\n    stack:=[]int{0}\n         ^\n/tmp/tmpamepmfi6.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{0}\n          ^\n            \n/tmp/tmpamepmfi6.swift:18:12: error: expected type\n    for i := 1; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpamepmfi6.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(brackets); i++ {\n           ^\n/tmp/tmpamepmfi6.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(brackets); i++ {\n           ^\n/tmp/tmpamepmfi6.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpamepmfi6.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpamepmfi6.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmpamepmfi6.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpamepmfi6.swift:17:5: error: cannot find 'stack' in scope\n    stack:=[]int{0}\n    ^~~~~\n/tmp/tmpamepmfi6.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpamepmfi6.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpwg8g4dqa.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmpwg8g4dqa.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpwg8g4dqa.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpwg8g4dqa.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpwg8g4dqa.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpwg8g4dqa.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpwg8g4dqa.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmpwg8g4dqa.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmpwg8g4dqa.swift:32:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmpwg8g4dqa.swift:32:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var opening_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var opening_bracket_count_stack []int\n    var opening_bracket_stack []string\n    var closing_bracket_stack []string\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count++\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n            opening_bracket_count_stack = append(opening_bracket_count_stack, opening_bracket_count)\n            opening_bracket_stack = append(opening_bracket_stack, brackets[i])\n        } else if brackets[i] == '>' {\n            closing_bracket_index = i\n            closing_bracket_stack = append(closing_bracket_stack, brackets[i])\n        }\n    }\n    for i := len(opening_bracket_stack) - 1; i >= 0; i-- {\n        if opening_bracket_count_stack[i] != opening_bracket_count {\n            return false\n        }\n        if opening_bracket_stack[i] != '<' {\n            return false\n        }\n        if closing_bracket_index != -1 {\n            if closing_bracket_stack[closing_bracket_index] != '>' {\n                return false\n            }\n            opening_bracket_count--\n            opening_bracket_index = opening_bracket_index_stack[i]\n            closing_bracket_index = -1\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpll673r6f.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpll673r6f.swift:16:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpll673r6f.swift:16:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpll673r6f.swift:17:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpll673r6f.swift:17:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpll673r6f.swift:17:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpll673r6f.swift:18:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpll673r6f.swift:18:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpll673r6f.swift:18:31: note: join the identifiers together with camel-case\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexInt\n/tmp/tmpll673r6f.swift:19:36: error: consecutive statements on a line must be separated by ';'\n    var opening_bracket_index_stack []int\n                                   ^\n                                   ;\n/tmp/tmpll673r6f.swift:19:39: error: consecutive statements on a line must be separated by ';'\n    var opening_bracket_index_stack []int\n                                      ^\n                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjqkvwwx9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjqkvwwx9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpjqkvwwx9.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpjqkvwwx9.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpjqkvwwx9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjqkvwwx9.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i, c := range brackets {\n        if c == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if c == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := len(opening_bracket_index_stack) - 1; i >= 0; i-- {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmphmvuf9ek.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmphmvuf9ek.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmphmvuf9ek.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmphmvuf9ek.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmphmvuf9ek.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmphmvuf9ek.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmphmvuf9ek.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmphmvuf9ek.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmphmvuf9ek.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmphmvuf9ek.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmphmvuf9ek.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmphmvuf9ek.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_set []int\n    var closing_bracket_stack_set []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_set []int\n    var closing_bracket_stack_index_set []int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_set []int\n    var closing_bracket_stack_index_stack_set []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_set []int\n    var closing_bracket_stack_index_stack_index_set []int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_set []int\n    var closing_bracket_stack_index_stack_index_stack_set []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_set []int\n    var closing_bracket_stack_index_stack_index_stack_index_set []int\n    var opening_bracket_stack_index_stack_index_stack_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpn_umhwkk.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpn_umhwkk.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpn_umhwkk.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpn_umhwkk.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpn_umhwkk.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpn_umhwkk.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpn_umhwkk.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpn_umhwkk.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpn_umhwkk.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpn_umhwkk.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpn_umhwkk.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpn_umhwkk.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_length int\n    var closing_bracket_stack_length int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_length int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_length int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpdzlekzbd.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpdzlekzbd.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpdzlekzbd.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpdzlekzbd.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpdzlekzbd.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpdzlekzbd.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpdzlekzbd.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpdzlekzbd.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpdzlekzbd.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpdzlekzbd.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpdzlekzbd.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpdzlekzbd.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp6oh50j46.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp6oh50j46.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp6oh50j46.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp6oh50j46.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp6oh50j46.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp6oh50j46.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp6oh50j46.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp6oh50j46.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp6oh50j46.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp6oh50j46.swift:29:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp6oh50j46.swift:29:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpvrz8k6p3.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpvrz8k6p3.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpvrz8k6p3.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpvrz8k6p3.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpvrz8k6p3.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpvrz8k6p3.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpvrz8k6p3.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpvrz8k6p3.swift:26:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        \n        if open_brackets == 0 {\n            return false\n        }\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp5hf609pj.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5hf609pj.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5hf609pj.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp5hf609pj.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5hf609pj.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp5hf609pj.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp5hf609pj.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmp5hf609pj.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp5hf609pj.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp5hf609pj.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp5hf609pj.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5hf609pj.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmp5hf609pj.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjqkvwwx9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjqkvwwx9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpjqkvwwx9.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpjqkvwwx9.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpjqkvwwx9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjqkvwwx9.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_char string\n    var closing_bracket_char string\n    var opening_bracket_index_set bool\n    var closing_bracket_index_set bool\n    var opening_bracket_char_set bool\n    var closing_bracket_char_set bool\n    var opening_bracket_index_list []int\n    var closing_bracket_index_list []int\n    var opening_bracket_index_set_list []bool\n    var closing_bracket_index_set_list []bool\n    var opening_bracket_char_list []string\n    var closing_bracket_char_list []string\n    var opening_bracket_index_list_list [][]int\n    var closing_bracket_index_list_list [][]int\n    var opening_bracket_index_set_list_list [][]bool\n    var closing_bracket_index_set_list_list [][]bool\n    var opening_bracket_char_list_list [][]string\n    var closing_bracket_char_list_list [][]string\n    var opening_bracket_index_list_list_list [][][]int\n    var closing_bracket_index_list_list_list [][][]int\n    var opening_bracket_index_set_list_list_list [][][]bool\n    var closing_bracket_index_set_list_list_list [][][]bool\n    var opening_bracket_char_list_list_list [][][]string\n    var closing_bracket_char_list_list_list [][][]string\n    for opening_bracket_count = 0; opening_bracket_count < len(brackets); opening_bracket_count = opening_bracket_count + 1 {\n        opening_bracket_index = opening_bracket_count\n        opening_bracket_char = brackets[opening_bracket_index]\n        opening_bracket_index_set = false\n        opening_bracket_char_set = false\n        opening_bracket_index\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpuwptl3jn.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpuwptl3jn.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpuwptl3jn.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpuwptl3jn.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpuwptl3jn.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpuwptl3jn.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpuwptl3jn.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpuwptl3jn.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpuwptl3jn.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpuwptl3jn.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpuwptl3jn.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpuwptl3jn.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack:= []\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[0:len(stack) - 1]\n            if i - last != 1 {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpzxcfw4ka.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:= []\n         ^\n         ;\n/tmp/tmpzxcfw4ka.swift:17:10: error: expected expression\n    stack:= []\n         ^\n/tmp/tmpzxcfw4ka.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpzxcfw4ka.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpzxcfw4ka.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpzxcfw4ka.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpzxcfw4ka.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpzxcfw4ka.swift:25:17: error: consecutive statements on a line must be separated by ';'\n            last := stack[len(stack) - 1]\n                ^\n                ;\n/tmp/tmpzxcfw4ka.swift:25:18: error: expected expression\n            last := stack[len(stack) - 1]\n                 ^\n/tmp/tmpzxcfw4ka.swift:17:5: error: cannot find 'stack' in scope\n    stack:= []\n    ^~~~~\n/tmp/tmpzxcfw4ka.swift:32:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmpzxcfw4ka.swift:32:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpyo9kjw4k.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpyo9kjw4k.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpyo9kjw4k.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpyo9kjw4k.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpyo9kjw4k.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpyo9kjw4k.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set bool\n    var closing_bracket_index_set bool\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_set bool\n    var closing_bracket_stack_set bool\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_set bool\n    var closing_bracket_stack_index_set bool\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_set bool\n    var closing_bracket_stack_index_stack_index_stack_set bool\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_set bool\n    var closing_bracket_stack_index_stack_index_stack_index_set bool\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp0rg6htu0.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmp0rg6htu0.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmp0rg6htu0.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmp0rg6htu0.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmp0rg6htu0.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmp0rg6htu0.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmp0rg6htu0.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmp0rg6htu0.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmp0rg6htu0.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmp0rg6htu0.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmp0rg6htu0.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmp0rg6htu0.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    open_brackets = 0\n    for i := len(brackets) - 1; i >= 0; i-- {\n        if brackets[i] == '>' {\n            open_brackets += 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpnvq_gt3h.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpnvq_gt3h.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpnvq_gt3h.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpnvq_gt3h.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpnvq_gt3h.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpnvq_gt3h.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpnvq_gt3h.swift:29:12: error: expected type\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpnvq_gt3h.swift:29:12: error: expected 'in' after for-each pattern\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpnvq_gt3h.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := len(brackets) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpnvq_gt3h.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpnvq_gt3h.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpnvq_gt3h.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpnvq_gt3h.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpnvq_gt3h.swift:28:5: error: cannot find 'open_brackets' in scope\n    open_brackets = 0\n    ^~~~~~~~~~~~~\n/tmp/tmpnvq_gt3h.swift:35:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var open_brackets = 0\n    var close_brackets = 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            close_brackets += 1\n        }\n    }\n    if open_brackets != close_brackets {\n        return false\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            if i == 0 || brackets[i-1] != '<' {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpmgig8jpp.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpmgig8jpp.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpmgig8jpp.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpmgig8jpp.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpmgig8jpp.swift:28:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmgig8jpp.swift:28:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmgig8jpp.swift:28:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmgig8jpp.swift:29:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmgig8jpp.swift:30:43: error: single-quoted string literal found, use '\"'\n            if i == 0 || brackets[i-1] != '<' {\n                                          ^~~\n                                          \"<\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpbw8m43un.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpbw8m43un.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpbw8m43un.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpbw8m43un.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpbw8m43un.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpbw8m43un.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpbw8m43un.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpbw8m43un.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpbw8m43un.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    var stack = []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpbw6il66v.swift:16:19: error: consecutive statements on a line must be separated by ';'\n    var stack = []rune{}\n                  ^\n                  ;\n/tmp/tmpbw6il66v.swift:17:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmpbw6il66v.swift:17:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmpbw6il66v.swift:18:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmpbw6il66v.swift:19:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmpbw6il66v.swift:20:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmpbw6il66v.swift:24:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] == '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmpbw6il66v.swift:25:31: error: expected expression in list of expressions\n                stack = stack[:len(stack) - 1]\n                              ^\n/tmp/tmpbw6il66v.swift:16:17: error: empty collection literal requires an explicit type\n    var stack = []rune{}\n                ^~\n/tmp/tmpbw6il66v.swift:16:19: error: cannot find 'rune' in scope\n    var stack = []rune{}\n                  ^~~~\n/tmp/tmpbw6il66v.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    var opening_bracket_stack []int\n    var closing_bracket_stack []int\n    var opening_bracket_stack_index int\n    var closing_bracket_stack_index int\n    var opening_bracket_stack_index_stack []int\n    var closing_bracket_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack []int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_index int\n    var opening_bracket_stack_index_stack_index_stack_index_stack_index_stack_index_stack []int\n    var closing_bracket_stack_index_stack_index_stack_index_stack_index_stack_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpgx1kmelo.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmpgx1kmelo.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmpgx1kmelo.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmpgx1kmelo.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmpgx1kmelo.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmpgx1kmelo.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmpgx1kmelo.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmpgx1kmelo.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmpgx1kmelo.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n        if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp49c16nbq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp49c16nbq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp49c16nbq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp49c16nbq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp49c16nbq.swift:22:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp49c16nbq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp49c16nbq.swift:29:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_stack []int\n    var closing_bracket_index_stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            opening_bracket_count += 1\n            opening_bracket_index = i\n            opening_bracket_index_stack = append(opening_bracket_index_stack, opening_bracket_index)\n        } else if brackets[i] == '>' {\n            closing_bracket_count += 1\n            closing_bracket_index = i\n            closing_bracket_index_stack = append(closing_bracket_index_stack, closing_bracket_index)\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    for i := 0; i < len(opening_bracket_index_stack); i++ {\n        if opening_bracket_index_stack[i] != closing_bracket_index_stack[i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmppth0zmh7.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmppth0zmh7.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmppth0zmh7.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmppth0zmh7.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmppth0zmh7.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmppth0zmh7.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmppth0zmh7.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmppth0zmh7.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmppth0zmh7.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    return opening_bracket_count == closing_bracket_count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpuvk9meos.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpuvk9meos.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpuvk9meos.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpuvk9meos.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp5b8pezek.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5b8pezek.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5b8pezek.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp5b8pezek.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp5b8pezek.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5b8pezek.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, char := range brackets {\n        if char == '<' {\n            open_brackets += 1\n        } else if char == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpjqkvwwx9.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpjqkvwwx9.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmpjqkvwwx9.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmpjqkvwwx9.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpjqkvwwx9.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpjqkvwwx9.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpjqkvwwx9.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    stack:=[]int{}\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            stack[last] = i\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp1hq7johp.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    stack:=[]int{}\n         ^\n         ;\n/tmp/tmp1hq7johp.swift:16:10: error: expected expression\n    stack:=[]int{}\n         ^\n/tmp/tmp1hq7johp.swift:16:11: error: '=' must have consistent whitespace on both sides\n    stack:=[]int{}\n          ^\n            \n/tmp/tmp1hq7johp.swift:17:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp1hq7johp.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp1hq7johp.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp1hq7johp.swift:18:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp1hq7johp.swift:20:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmp1hq7johp.swift:24:17: error: consecutive statements on a line must be separated by ';'\n            last := len(stack) - 1\n                ^\n                ;\n/tmp/tmp1hq7johp.swift:24:18: error: expected expression\n            last := len(stack) - 1\n                 ^\n/tmp/tmp1hq7johp.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp1hq7johp.swift:16:5: error: cannot find 'stack' in scope\n    stack:=[]int{}\n    ^~~~~\n/tmp/tmp1hq7johp.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp1hq7johp.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, c)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp5uwcbc3s.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp5uwcbc3s.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp5uwcbc3s.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5uwcbc3s.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5uwcbc3s.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5uwcbc3s.swift:25:41: error: single-quoted string literal found, use '\"'\n            if stack[len(stack) - 1] != '<' {\n                                        ^~~\n                                        \"<\"\n/tmp/tmp5uwcbc3s.swift:28:27: error: expected expression in list of expressions\n            stack = stack[:len(stack) - 1]\n                          ^\n/tmp/tmp5uwcbc3s.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp5uwcbc3s.swift:31:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp5uwcbc3s.swift:31:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack:=make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            \n            if brackets[i] != '>' {\n                return false\n            }\n            \n            index := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if i != index {\n                return false\n            }\n        }\n    }\n    \n    if len(stack) != 0 {\n        return false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp87d9pcun.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack:=make([]int, 0)\n         ^\n         ;\n/tmp/tmp87d9pcun.swift:17:10: error: expected expression\n    stack:=make([]int, 0)\n         ^\n/tmp/tmp87d9pcun.swift:17:11: error: '=' must have consistent whitespace on both sides\n    stack:=make([]int, 0)\n          ^\n            \n/tmp/tmp87d9pcun.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmp87d9pcun.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp87d9pcun.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmp87d9pcun.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmp87d9pcun.swift:26:31: error: single-quoted string literal found, use '\"'\n            if brackets[i] != '>' {\n                              ^~~\n                              \">\"\n/tmp/tmp87d9pcun.swift:30:18: error: consecutive statements on a line must be separated by ';'\n            index := stack[len(stack) - 1]\n                 ^\n                 ;\n/tmp/tmp87d9pcun.swift:30:19: error: expected expression\n            index := stack[len(stack) - 1]\n                  ^\n/tmp/tmp87d9pcun.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp87d9pcun.swift:17:5: error: cannot find 'stack' in scope\n    stack:=make([]int, 0)\n    ^~~~~\n/tmp/tmp87d9pcun.swift:38:8: error: cannot find 'len' in scope\n    if len(stack) != 0 {\n       ^~~\n/tmp/tmp87d9pcun.swift:38:12: error: cannot find 'stack' in scope\n    if len(stack) != 0 {\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        }\n    }\n    \n    if open_brackets == 0 {\n        return true\n    }\n    \n    close_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '>' {\n            close_brackets += 1\n        }\n    }\n    \n    if close_brackets == open_brackets {\n        return true\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpmp9nqxnq.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpmp9nqxnq.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpmp9nqxnq.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    close_brackets := 0\n                  ^\n                  ;\n/tmp/tmpmp9nqxnq.swift:28:20: error: expected expression\n    close_brackets := 0\n                   ^\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:29:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpmp9nqxnq.swift:30:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmpmp9nqxnq.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:24:8: error: cannot find 'open_brackets' in scope\n    if open_brackets == 0 {\n       ^~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:28:5: error: cannot find 'close_brackets' in scope\n    close_brackets := 0\n    ^~~~~~~~~~~~~~\n/tmp/tmpmp9nqxnq.swift:35:8: error: cannot find ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for _, c := range brackets {\n        if c == '<' {\n            open_brackets += 1\n        } else if c == '>' {\n            open_brackets -= 1\n        }\n    }\n    \n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmp5b8pezek.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmp5b8pezek.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp5b8pezek.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp5b8pezek.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp5b8pezek.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp5b8pezek.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmp5b8pezek.swift:26:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count int\n    var closing_bracket_count int\n    var opening_bracket_index int\n    var closing_bracket_index int\n    var opening_bracket_index_set []int\n    var closing_bracket_index_set []int\n    var opening_bracket_index_set_copy []int\n    var opening_bracket_index_set_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var opening_bracket_index_set_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmprt2sd400.swift:13:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_count int\n                              ^\n/tmp/tmprt2sd400.swift:13:31: note: join the identifiers together\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countint\n/tmp/tmprt2sd400.swift:13:31: note: join the identifiers together with camel-case\n    var opening_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_countInt\n/tmp/tmprt2sd400.swift:14:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_count int\n                              ^\n/tmp/tmprt2sd400.swift:14:31: note: join the identifiers together\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countint\n/tmp/tmprt2sd400.swift:14:31: note: join the identifiers together with camel-case\n    var closing_bracket_count int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_countInt\n/tmp/tmprt2sd400.swift:15:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var opening_bracket_index int\n                              ^\n/tmp/tmprt2sd400.swift:15:31: note: join the identifiers together\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexint\n/tmp/tmprt2sd400.swift:15:31: note: join the identifiers together with camel-case\n    var opening_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        opening_bracket_indexInt\n/tmp/tmprt2sd400.swift:16:31: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var closing_bracket_index int\n                              ^\n/tmp/tmprt2sd400.swift:16:31: note: join the identifiers together\n    var closing_bracket_index int\n        ~~~~~~~~~~~~~~~~~~~~~~^~~\n        closing_bracket_indexint\n/tmp/tmprt2sd400.swift:16:31: note: join the id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var opening_bracket_count = 0\n    var closing_bracket_count = 0\n    for _, char := range brackets {\n        if char == '<' {\n            opening_bracket_count += 1\n        } else if char == '>' {\n            closing_bracket_count += 1\n        }\n    }\n    if opening_bracket_count != closing_bracket_count {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmplkf79y6o.swift:15:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmplkf79y6o.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmplkf79y6o.swift:16:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmplkf79y6o.swift:18:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    var open_brackets = 0\n    var close_brackets = 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            close_brackets += 1\n        }\n    }\n    return open_brackets == close_brackets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpjypzdica.swift:15:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpjypzdica.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjypzdica.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpjypzdica.swift:16:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpjypzdica.swift:18:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, char := range brackets {\n        if char == '<' {\n            stack = append(stack, '<')\n        } else if char == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp_1d0r_s5.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp_1d0r_s5.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp_1d0r_s5.swift:18:10: error: expected 'in' after for-each pattern\n    for _, char := range brackets {\n         ^\n/tmp/tmp_1d0r_s5.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, char := range brackets {\n         ^\n/tmp/tmp_1d0r_s5.swift:19:20: error: single-quoted string literal found, use '\"'\n        if char == '<' {\n                   ^~~\n                   \"<\"\n/tmp/tmp_1d0r_s5.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp_1d0r_s5.swift:21:27: error: single-quoted string literal found, use '\"'\n        } else if char == '>' {\n                          ^~~\n                          \">\"\n/tmp/tmp_1d0r_s5.swift:25:27: error: expected expression in list of expressions\n            stack = stack[:len(stack)-1]\n                          ^\n/tmp/tmp_1d0r_s5.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmp_1d0r_s5.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp_1d0r_s5.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp_1d0r_s5.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if len(brackets) == 0 {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmpe_bkh3i0.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpe_bkh3i0.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpe_bkh3i0.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpe_bkh3i0.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpe_bkh3i0.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpe_bkh3i0.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpe_bkh3i0.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpe_bkh3i0.swift:13:8: error: cannot find 'len' in scope\n    if len(brackets) == 0 {\n       ^~~\n/tmp/tmpe_bkh3i0.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpe_bkh3i0.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack) - 1]\n        }\n    }\n    \n    return len(stack) == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293463,
      "stdout": "",
      "stderr": "/tmp/tmp1dpzw6we.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    stack := []rune{}\n         ^\n         ;\n/tmp/tmp1dpzw6we.swift:17:11: error: expected expression\n    stack := []rune{}\n          ^\n/tmp/tmp1dpzw6we.swift:18:10: error: expected 'in' after for-each pattern\n    for _, c := range brackets {\n         ^\n/tmp/tmp1dpzw6we.swift:18:10: error: expected Sequence expression for for-each loop\n    for _, c := range brackets {\n         ^\n/tmp/tmp1dpzw6we.swift:19:17: error: single-quoted string literal found, use '\"'\n        if c == '<' {\n                ^~~\n                \"<\"\n/tmp/tmp1dpzw6we.swift:20:35: error: single-quoted string literal found, use '\"'\n            stack = append(stack, '<')\n                                  ^~~\n                                  \"<\"\n/tmp/tmp1dpzw6we.swift:21:24: error: single-quoted string literal found, use '\"'\n        } else if c == '>' {\n                       ^~~\n                       \">\"\n/tmp/tmp1dpzw6we.swift:25:29: error: expected ',' separator\n            stack = stack[0 : len(stack) - 1]\n                            ^\n                           ,\n/tmp/tmp1dpzw6we.swift:25:29: error: expected expression in list of expressions\n            stack = stack[0 : len(stack) - 1]\n                            ^\n/tmp/tmp1dpzw6we.swift:17:5: error: cannot find 'stack' in scope\n    stack := []rune{}\n    ^~~~~\n/tmp/tmp1dpzw6we.swift:29:12: error: cannot find 'len' in scope\n    return len(stack) == 0\n           ^~~\n/tmp/tmp1dpzw6we.swift:29:16: error: cannot find 'stack' in scope\n    return len(stack) == 0\n               ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// brackets is a string of \"<\" and \">\".\n/// return true if every opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(brackets: \"<\")\n/// false\n/// >>> correct_bracketing(brackets: \"<>\")\n/// true\n/// >>> correct_bracketing(brackets: \"<<><>>\")\n/// true\n/// >>> correct_bracketing(brackets: \"><<>\")\n/// false\nfunc correct_bracketing(brackets: String) -> Bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    open_brackets := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            open_brackets += 1\n        } else if brackets[i] == '>' {\n            open_brackets -= 1\n        }\n        if open_brackets < 0 {\n            return false\n        }\n    }\n    return open_brackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(correct_bracketing(brackets: \"<>\") == true)\nassert(correct_bracketing(brackets: \"<<><>>\") == true)\nassert(correct_bracketing(brackets: \"<><><<><>><>\") == true)\nassert(correct_bracketing(brackets: \"<><><<<><><>><>><<><><<>>>\") == true)\nassert(correct_bracketing(brackets: \"<<<><>>>>\") == false)\nassert(correct_bracketing(brackets: \"><<>\") == false)\nassert(correct_bracketing(brackets: \"<\") == false)\nassert(correct_bracketing(brackets: \"<<<<\") == false)\nassert(correct_bracketing(brackets: \">\") == false)\nassert(correct_bracketing(brackets: \"<<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>><<>\") == false)\nassert(correct_bracketing(brackets: \"<><><<><>><>>><>\") == false)",
      "timestamp": 1664293462,
      "stdout": "",
      "stderr": "/tmp/tmpias9sqrf.swift:17:18: error: consecutive statements on a line must be separated by ';'\n    open_brackets := 0\n                 ^\n                 ;\n/tmp/tmpias9sqrf.swift:17:19: error: expected expression\n    open_brackets := 0\n                  ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected type\n    for i := 0; i < len(brackets); i++ {\n           ^\n            <#type#>\n/tmp/tmpias9sqrf.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(brackets); i++ {\n           ^\n/tmp/tmpias9sqrf.swift:19:27: error: single-quoted string literal found, use '\"'\n        if brackets[i] == '<' {\n                          ^~~\n                          \"<\"\n/tmp/tmpias9sqrf.swift:21:34: error: single-quoted string literal found, use '\"'\n        } else if brackets[i] == '>' {\n                                 ^~~\n                                 \">\"\n/tmp/tmpias9sqrf.swift:17:5: error: cannot find 'open_brackets' in scope\n    open_brackets := 0\n    ^~~~~~~~~~~~~\n/tmp/tmpias9sqrf.swift:28:12: error: cannot find 'open_brackets' in scope\n    return open_brackets == 0\n           ^~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}