{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "swift",
  "prompt": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmps14lmyvb/tmps14lmyvb.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0b8068ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0b80381b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0b80381988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0b803807b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmps14lmyvb                        0x0000563b6b390307 <unavailable> + 4871\n5    libc.so.6                          0x00002b0b80876460 __libc_start_main + 245\n6    tmps14lmyvb                        0x0000563b6b38ff49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpz7879qcy/tmpz7879qcy.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba8d8b22c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba8d8819b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba8d8819988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba8d88187b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpz7879qcy                        0x000055c419d56307 <unavailable> + 4871\n5    libc.so.6                          0x00002ba8d8d0e460 __libc_start_main + 245\n6    tmpz7879qcy                        0x000055c419d55f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp4ka0l0sa/tmp4ka0l0sa.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac80c8abc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac80c5a2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac80c5a2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac80c5a17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4ka0l0sa                        0x0000558272103307 <unavailable> + 4871\n5    libc.so.6                          0x00002ac80ca97460 __libc_start_main + 245\n6    tmp4ka0l0sa                        0x0000558272102f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var vowels_count = 0\n    var consonants_count = 0\n    var closest_vowel = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] in vowels {\n            vowels_count += 1\n            if vowels_count > 1 {\n                closest_vowel = word[i]\n                break\n            }\n        } else if word[i] in consonants {\n            consonants_count += 1\n            if consonants_count > 1 {\n                closest_vowel = word[i]\n                break\n            }\n        }\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpgnhdo_3h.swift:23:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpgnhdo_3h.swift:23:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpgnhdo_3h.swift:23:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpgnhdo_3h.swift:24:20: error: expected '{' after 'if' condition\n        if word[i] in vowels {\n                   ^\n/tmp/tmpgnhdo_3h.swift:30:27: error: expected '{' after 'if' condition\n        } else if word[i] in consonants {\n                          ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            if result == \"\" {\n                result = word[i]\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpxhy3oc4u.swift:21:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpxhy3oc4u.swift:21:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpxhy3oc4u.swift:21:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpv6h8azx9.swift:22:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpv6h8azx9.swift:22:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpv6h8azx9.swift:22:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpv6h8azx9.swift:23:23: error: single-quoted string literal found, use '\"'\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n                      ^~~\n                      \"a\"\n/tmp/tmpv6h8azx9.swift:23:41: error: single-quoted string literal found, use '\"'\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n                                        ^~~\n                                        \"e\"\n/tmp/tmpv6h8azx9.swift:23:59: error: single-quoted string literal found, use '\"'\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n                                                          ^~~\n                                                          \"i\"\n/tmp/tmpv6h8azx9.swift:23:77: error: single-quoted string literal found, use '\"'\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n                                                                            ^~~\n                                                                            \"o\"\n/tmp/tmpv6h8azx9.swift:23:95: error: single-quoted string literal found, use '\"'\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n                                                                                              ^~~\n                                                                                              \"u\"\n/tmp/tmpv6h8azx9.swift:18:8: error: cannot find 'len' in scope\n    if len(word) < 2 {\n       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmpuewc4jw0.swift:21:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpuewc4jw0.swift:21:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmpuewc4jw0.swift:21:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmps14lmyvb/tmps14lmyvb.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0b8068ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0b80381b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0b80381988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0b803807b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmps14lmyvb                        0x0000563b6b390307 <unavailable> + 4871\n5    libc.so.6                          0x00002b0b80876460 __libc_start_main + 245\n6    tmps14lmyvb                        0x0000563b6b38ff49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp_cbp1yxy.swift:21:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmp_cbp1yxy.swift:21:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp_cbp1yxy.swift:21:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code goes here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmpsh5520dr/tmpsh5520dr.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b8a075d2c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b8a072c9b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b8a072c9988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b8a072c87b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpsh5520dr                        0x00005584692b4307 <unavailable> + 4871\n5    libc.so.6                          0x00002b8a077be460 __libc_start_main + 245\n6    tmpsh5520dr                        0x00005584692b3f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmps14lmyvb/tmps14lmyvb.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0b8068ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0b80381b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0b80381988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0b803807b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmps14lmyvb                        0x0000563b6b390307 <unavailable> + 4871\n5    libc.so.6                          0x00002b0b80876460 __libc_start_main + 245\n6    tmps14lmyvb                        0x0000563b6b38ff49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmps14lmyvb/tmps14lmyvb.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b0b8068ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b0b80381b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b0b80381988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b0b803807b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmps14lmyvb                        0x0000563b6b390307 <unavailable> + 4871\n5    libc.so.6                          0x00002b0b80876460 __libc_start_main + 245\n6    tmps14lmyvb                        0x0000563b6b38ff49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292972,
      "stdout": "",
      "stderr": "tmp4ka0l0sa/tmp4ka0l0sa.swift:34: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac80c8abc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac80c5a2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac80c5a2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac80c5a17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4ka0l0sa                        0x0000558272103307 <unavailable> + 4871\n5    libc.so.6                          0x00002ac80ca97460 __libc_start_main + 245\n6    tmp4ka0l0sa                        0x0000558272102f49 <unavailable> + 3913\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    // your code here\n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := \"aeiouAEIOU\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp7k3at01x.swift:22:11: error: consecutive statements on a line must be separated by ';'\n    vowels := \"aeiouAEIOU\"\n          ^\n          ;\n/tmp/tmp7k3at01x.swift:22:12: error: expected expression\n    vowels := \"aeiouAEIOU\"\n           ^\n/tmp/tmp7k3at01x.swift:24:12: error: expected type\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmp7k3at01x.swift:24:12: error: expected 'in' after for-each pattern\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp7k3at01x.swift:24:12: error: expected Sequence expression for for-each loop\n    for i := len(word) - 1; i >= 0; i-- {\n           ^\n/tmp/tmp7k3at01x.swift:18:8: error: cannot find 'len' in scope\n    if len(word) == 0 {\n       ^~~\n/tmp/tmp7k3at01x.swift:22:5: error: cannot find 'vowels' in scope\n    vowels := \"aeiouAEIOU\"\n    ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word: \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word: \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "/tmp/tmp4aryz8hj.swift:18:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}