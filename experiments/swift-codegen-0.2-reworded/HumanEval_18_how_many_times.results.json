{
  "name": "HumanEval_18_how_many_times",
  "language": "swift",
  "prompt": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpuciewe4f.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpuciewe4f.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpuciewe4f.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpuciewe4f.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuciewe4f.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuciewe4f.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpuciewe4f.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuciewe4f.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuciewe4f.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpuciewe4f.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsd8ikuvh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsd8ikuvh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsd8ikuvh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpsd8ikuvh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsd8ikuvh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsd8ikuvh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpsd8ikuvh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsd8ikuvh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsd8ikuvh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpsd8ikuvh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpsd8ikuvh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsd8ikuvh.swift:29:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp6l5sp6it.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp6l5sp6it.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp6l5sp6it.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp6l5sp6it.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp6l5sp6it.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp6l5sp6it.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp6l5sp6it.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpz1da0vwn.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpz1da0vwn.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpz1da0vwn.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpz1da0vwn.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpz1da0vwn.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpz1da0vwn.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpz1da0vwn.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpz1da0vwn.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpz1da0vwn.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpz1da0vwn.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpz1da0vwn.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpz1da0vwn.swift:29:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpuf_tx72a.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpuf_tx72a.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpuf_tx72a.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpuf_tx72a.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuf_tx72a.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuf_tx72a.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpuf_tx72a.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuf_tx72a.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuf_tx72a.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpuf_tx72a.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpuf_tx72a.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpwn0j8w7l.swift:14:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpwn0j8w7l.swift:14:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpwn0j8w7l.swift:15:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpwn0j8w7l.swift:15:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpwn0j8w7l.swift:14:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpwn0j8w7l.swift:14:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpwn0j8w7l.swift:15:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpwn0j8w7l.swift:15:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvfc233yr.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvfc233yr.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvfc233yr.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvfc233yr.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvfc233yr.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvfc233yr.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpvfc233yr.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvfc233yr.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvfc233yr.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpvfc233yr.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvfc233yr.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_length = len(substring)\n    var string_length = len(string)\n    for i < string_length {\n        for j < substring_length {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp124hhcld.swift:15:11: error: expected 'in' after for-each pattern\n    for i < string_length {\n          ^\n/tmp/tmp124hhcld.swift:15:11: error: unary operator cannot be separated from its operand\n    for i < string_length {\n          ^~\n           \n/tmp/tmp124hhcld.swift:16:15: error: expected 'in' after for-each pattern\n        for j < substring_length {\n              ^\n/tmp/tmp124hhcld.swift:16:15: error: unary operator cannot be separated from its operand\n        for j < substring_length {\n              ^~\n               \n/tmp/tmp124hhcld.swift:13:28: error: cannot find 'len' in scope\n    var substring_length = len(substring)\n                           ^~~\n/tmp/tmp124hhcld.swift:14:25: error: cannot find 'len' in scope\n    var string_length = len(string)\n                        ^~~\n/tmp/tmp124hhcld.swift:15:11: error: '<' is not a prefix unary operator\n    for i < string_length {\n          ^\n/tmp/tmp124hhcld.swift:16:15: error: '<' is not a prefix unary operator\n        for j < substring_length {\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppmubaqyh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppmubaqyh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppmubaqyh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppmubaqyh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmppmubaqyh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmppmubaqyh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppmubaqyh.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy004hf37.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy004hf37.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy004hf37.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpy004hf37.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpy004hf37.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpy004hf37.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy004hf37.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvzielti4.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvzielti4.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvzielti4.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvzielti4.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvzielti4.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvzielti4.swift:24:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpvzielti4.swift:24:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvzielti4.swift:24:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvzielti4.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvzielti4.swift:34:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpda0a6ogb.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpda0a6ogb.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpda0a6ogb.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpda0a6ogb.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpda0a6ogb.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpda0a6ogb.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpda0a6ogb.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    // Your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "tmparxrx4_z/tmparxrx4_z.swift:28: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b759469cc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b7594393b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b7594393988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b75943927b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmparxrx4_z                        0x000055fe9a4b6372 <unavailable> + 4978\n5    libc.so.6                          0x00002b7594888460 __libc_start_main + 245\n6    tmparxrx4_z                        0x000055fe9a4b5ee9 <unavailable> + 3817\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpaw2wjnhz.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpaw2wjnhz.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpaw2wjnhz.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpaw2wjnhz.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdpdvd7c0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdpdvd7c0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdpdvd7c0.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    if string[0] == substring[0] {\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n    }\n    return how_many_times(string[1:], substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpm85031d2.swift:17:39: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n                                      ,\n/tmp/tmpm85031d2.swift:17:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n/tmp/tmpm85031d2.swift:17:79: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n                                                                              ,\n/tmp/tmpm85031d2.swift:17:79: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n/tmp/tmpm85031d2.swift:17:94: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n                                                                                             ,\n/tmp/tmpm85031d2.swift:17:94: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n/tmp/tmpm85031d2.swift:19:35: error: expected ',' separator\n    return how_many_times(string[1:], substring)\n                                  ^\n                                  ,\n/tmp/tmpm85031d2.swift:19:35: error: expected expression in list of expressions\n    return how_many_times(string[1:], substring)\n                                  ^\n/tmp/tmpm85031d2.swift:10:8: error: cannot find 'len' i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpuiphs4jj.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpuiphs4jj.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpuiphs4jj.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpuiphs4jj.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpuiphs4jj.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpuiphs4jj.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpuiphs4jj.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpto99ofvn.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpto99ofvn.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpto99ofvn.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpb9h9lcr1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpb9h9lcr1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpb9h9lcr1.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpb9h9lcr1.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpb9h9lcr1.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpb9h9lcr1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpb9h9lcr1.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_len = len(substring)\n    var string_len = len(string)\n    while i < string_len {\n        j = 0\n        while j < substring_len {\n            if string[i+j] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmphh_hvzdo.swift:13:25: error: cannot find 'len' in scope\n    var substring_len = len(substring)\n                        ^~~\n/tmp/tmphh_hvzdo.swift:14:22: error: cannot find 'len' in scope\n    var string_len = len(string)\n                     ^~~\n/tmp/tmphh_hvzdo.swift:18:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i+j] == substring[j] {\n               ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphh_hvzdo.swift:18:31: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i+j] == substring[j] {\n                              ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdm9p0sjv.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdm9p0sjv.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdm9p0sjv.swift:17:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdm9p0sjv.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdm9p0sjv.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdm9p0sjv.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 {\n       ^~~\n/tmp/tmpdm9p0sjv.swift:13:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpdm9p0sjv.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdm9p0sjv.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_len = len(substring)\n    var string_len = len(string)\n    \n    while i < string_len {\n        j = 0\n        while j < substring_len {\n            if string[i + j] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmphqk1x6to.swift:13:25: error: cannot find 'len' in scope\n    var substring_len = len(substring)\n                        ^~~\n/tmp/tmphqk1x6to.swift:14:22: error: cannot find 'len' in scope\n    var string_len = len(string)\n                     ^~~\n/tmp/tmphqk1x6to.swift:19:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i + j] == substring[j] {\n               ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphqk1x6to.swift:19:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i + j] == substring[j] {\n                                ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmps4vua4_n.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmps4vua4_n.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmps4vua4_n.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmps4vua4_n.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmps4vua4_n.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmps4vua4_n.swift:22:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmps4vua4_n.swift:22:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmps4vua4_n.swift:22:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmps4vua4_n.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmps4vua4_n.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmps4vua4_n.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmps4vua4_n.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppri3k_74.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppri3k_74.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppri3k_74.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppri3k_74.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpaw2wjnhz.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpaw2wjnhz.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpaw2wjnhz.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpaw2wjnhz.swift:23:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpaw2wjnhz.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpaw2wjnhz.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpa_f66adh.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpa_f66adh.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpa_f66adh.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpa_f66adh.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpa_f66adh.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpao4engn0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpao4engn0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpao4engn0.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpao4engn0.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpao4engn0.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpao4engn0.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpao4engn0.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpao4engn0.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpao4engn0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpao4engn0.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy74ms2xd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy74ms2xd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpy74ms2xd.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpy74ms2xd.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy74ms2xd.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppri3k_74.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppri3k_74.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppri3k_74.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppri3k_74.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpjlmuube2.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpjlmuube2.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpjlmuube2.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpjlmuube2.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpjlmuube2.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpjlmuube2.swift:22:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpjlmuube2.swift:22:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpjlmuube2.swift:22:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpjlmuube2.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpjlmuube2.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpjlmuube2.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpr2et7c9o.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpr2et7c9o.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpr2et7c9o.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpr2et7c9o.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpr2et7c9o.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpr2et7c9o.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpr2et7c9o.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpr2et7c9o.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpr2et7c9o.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpr2et7c9o.swift:29:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy74ms2xd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy74ms2xd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpy74ms2xd.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpy74ms2xd.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy74ms2xd.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpmw0toe1e.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpmw0toe1e.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpmw0toe1e.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpmw0toe1e.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpmw0toe1e.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpmw0toe1e.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpmw0toe1e.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpmw0toe1e.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpmw0toe1e.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpmw0toe1e.swift:28:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppmubaqyh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppmubaqyh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppmubaqyh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppmubaqyh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmppmubaqyh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmppmubaqyh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppmubaqyh.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsuh893p9.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsuh893p9.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsuh893p9.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpsuh893p9.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsuh893p9.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsuh893p9.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpsuh893p9.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpsuh893p9.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsuh893p9.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    while i < len(string) && j < len(substring) {\n        if string[i] == substring[j] {\n            count += 1\n            i += 1\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpzaf7jyw0.swift:13:15: error: cannot find 'len' in scope\n    while i < len(string) && j < len(substring) {\n              ^~~\n/tmp/tmpzaf7jyw0.swift:13:34: error: cannot find 'len' in scope\n    while i < len(string) && j < len(substring) {\n                                 ^~~\n/tmp/tmpzaf7jyw0.swift:14:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzaf7jyw0.swift:14:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpjm3sz7wg.swift:95:8: error: expected pattern\n    var\n       ^\n/tmp/tmpjm3sz7wg.swift:37:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:11:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:38:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:12:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:39:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:13:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:40:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:14:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:41:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:15:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:42:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:16:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:43:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:17:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:44:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:18:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:45:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:19:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:46:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:20:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:47:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:21:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:48:9: er",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpto99ofvn.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpto99ofvn.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpto99ofvn.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_length = len(substring)\n    var string_length = len(string)\n    \n    for i < string_length {\n        for j < substring_length {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvprk943r.swift:16:11: error: expected 'in' after for-each pattern\n    for i < string_length {\n          ^\n/tmp/tmpvprk943r.swift:16:11: error: unary operator cannot be separated from its operand\n    for i < string_length {\n          ^~\n           \n/tmp/tmpvprk943r.swift:17:15: error: expected 'in' after for-each pattern\n        for j < substring_length {\n              ^\n/tmp/tmpvprk943r.swift:17:15: error: unary operator cannot be separated from its operand\n        for j < substring_length {\n              ^~\n               \n/tmp/tmpvprk943r.swift:13:28: error: cannot find 'len' in scope\n    var substring_length = len(substring)\n                           ^~~\n/tmp/tmpvprk943r.swift:14:25: error: cannot find 'len' in scope\n    var string_length = len(string)\n                        ^~~\n/tmp/tmpvprk943r.swift:16:11: error: '<' is not a prefix unary operator\n    for i < string_length {\n          ^\n/tmp/tmpvprk943r.swift:17:15: error: '<' is not a prefix unary operator\n        for j < substring_length {\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp7q3oa_3k.swift:11:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp7q3oa_3k.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp7q3oa_3k.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmplicg3rig.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmplicg3rig.swift:17:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmplicg3rig.swift:18:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmplicg3rig.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmplicg3rig.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmplicg3rig.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 {\n       ^~~\n/tmp/tmplicg3rig.swift:13:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmplicg3rig.swift:17:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmplicg3rig.swift:23:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpmw0toe1e.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpmw0toe1e.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpmw0toe1e.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpmw0toe1e.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpmw0toe1e.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpmw0toe1e.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpmw0toe1e.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpmw0toe1e.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpmw0toe1e.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpmw0toe1e.swift:28:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvsw6wphp.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvsw6wphp.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvsw6wphp.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvsw6wphp.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvsw6wphp.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvsw6wphp.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpvsw6wphp.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvsw6wphp.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvsw6wphp.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvsw6wphp.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp0yslczxb.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp0yslczxb.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp0yslczxb.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp0yslczxb.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp0yslczxb.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy74ms2xd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy74ms2xd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpy74ms2xd.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpy74ms2xd.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy74ms2xd.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    for i < len(string) {\n        if string[i] == substring[0] {\n            count += 1\n            i += 1\n            for i < len(substring) {\n                if string[i] != substring[i] {\n                    break\n                }\n                i += 1\n            }\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp5r3baoev.swift:12:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp5r3baoev.swift:12:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp5r3baoev.swift:16:19: error: expected 'in' after for-each pattern\n            for i < len(substring) {\n                  ^\n/tmp/tmp5r3baoev.swift:16:19: error: unary operator cannot be separated from its operand\n            for i < len(substring) {\n                  ^~\n                   \n/tmp/tmp5r3baoev.swift:12:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp5r3baoev.swift:12:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp5r3baoev.swift:16:19: error: '<' is not a prefix unary operator\n            for i < len(substring) {\n                  ^\n/tmp/tmp5r3baoev.swift:16:21: error: cannot find 'len' in scope\n            for i < len(substring) {\n                    ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpao4engn0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpao4engn0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpao4engn0.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpao4engn0.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpao4engn0.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpao4engn0.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpao4engn0.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpao4engn0.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpao4engn0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpao4engn0.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpz1da0vwn.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpz1da0vwn.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpz1da0vwn.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpz1da0vwn.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpz1da0vwn.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpz1da0vwn.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpz1da0vwn.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpz1da0vwn.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpz1da0vwn.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpz1da0vwn.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpz1da0vwn.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpz1da0vwn.swift:29:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    if string[0] == substring[0] {\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n    } else {\n        return how_many_times(string[1:], substring)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpg7mvf1vs.swift:17:39: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n                                      ,\n/tmp/tmpg7mvf1vs.swift:17:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n/tmp/tmpg7mvf1vs.swift:17:79: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n                                                                              ,\n/tmp/tmpg7mvf1vs.swift:17:79: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n/tmp/tmpg7mvf1vs.swift:17:94: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n                                                                                             ,\n/tmp/tmpg7mvf1vs.swift:17:94: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n/tmp/tmpg7mvf1vs.swift:19:39: error: expected ',' separator\n        return how_many_times(string[1:], substring)\n                                      ^\n                                      ,\n/tmp/tmpg7mvf1vs.swift:19:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring)\n                                      ^\n/tmp/tmpg7mvf1vs.swift:10:8: error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp2fwa_a05.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp2fwa_a05.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp2fwa_a05.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp2fwa_a05.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp2fwa_a05.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp2fwa_a05.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp2fwa_a05.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp2fwa_a05.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp2fwa_a05.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdpdvd7c0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdpdvd7c0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdpdvd7c0.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpaxq2gm_j.swift:11:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpaxq2gm_j.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpaxq2gm_j.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpjm3sz7wg.swift:95:8: error: expected pattern\n    var\n       ^\n/tmp/tmpjm3sz7wg.swift:37:9: error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:11:9: note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:38:9: error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:12:9: note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:39:9: error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:13:9: note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:40:9: error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:14:9: note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:41:9: error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:15:9: note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:42:9: error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:16:9: note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:43:9: error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:17:9: note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:44:9: error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:18:9: note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:45:9: error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:19:9: note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:46:9: error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:20:9: note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:47:9: error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:21:9: note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpjm3sz7wg.swift:48:9: er",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpnvwfagij.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpnvwfagij.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpnvwfagij.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpnvwfagij.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp5leklm4a.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp5leklm4a.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp5leklm4a.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp5leklm4a.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp5leklm4a.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp5leklm4a.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp5leklm4a.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdpdvd7c0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdpdvd7c0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdpdvd7c0.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvfc233yr.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvfc233yr.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvfc233yr.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvfc233yr.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvfc233yr.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvfc233yr.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpvfc233yr.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvfc233yr.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvfc233yr.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpvfc233yr.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvfc233yr.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_length = len(substring)\n    var string_length = len(string)\n    \n    for i < string_length {\n        for j < substring_length {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsfcay2d5.swift:16:11: error: expected 'in' after for-each pattern\n    for i < string_length {\n          ^\n/tmp/tmpsfcay2d5.swift:16:11: error: unary operator cannot be separated from its operand\n    for i < string_length {\n          ^~\n           \n/tmp/tmpsfcay2d5.swift:17:15: error: expected 'in' after for-each pattern\n        for j < substring_length {\n              ^\n/tmp/tmpsfcay2d5.swift:17:15: error: unary operator cannot be separated from its operand\n        for j < substring_length {\n              ^~\n               \n/tmp/tmpsfcay2d5.swift:13:28: error: cannot find 'len' in scope\n    var substring_length = len(substring)\n                           ^~~\n/tmp/tmpsfcay2d5.swift:14:25: error: cannot find 'len' in scope\n    var string_length = len(string)\n                        ^~~\n/tmp/tmpsfcay2d5.swift:16:11: error: '<' is not a prefix unary operator\n    for i < string_length {\n          ^\n/tmp/tmpsfcay2d5.swift:17:15: error: '<' is not a prefix unary operator\n        for j < substring_length {\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsuh893p9.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsuh893p9.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsuh893p9.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpsuh893p9.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsuh893p9.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsuh893p9.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpsuh893p9.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpsuh893p9.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsuh893p9.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppmubaqyh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppmubaqyh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppmubaqyh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppmubaqyh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmppmubaqyh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmppmubaqyh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppmubaqyh.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    if len(string) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpcflxv38s.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpcflxv38s.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpcflxv38s.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpcflxv38s.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpcflxv38s.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpcflxv38s.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpcflxv38s.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpcflxv38s.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpcflxv38s.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpcflxv38s.swift:13:8: error: cannot find 'len' in scope\n    if len(string) == 0 {\n       ^~~\n/tmp/tmpcflxv38s.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpcflxv38s.swift:28:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdpdvd7c0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdpdvd7c0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdpdvd7c0.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    for i < len(string) - len(substring) + 1 {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpmpi0rmxe.swift:12:11: error: expected 'in' after for-each pattern\n    for i < len(string) - len(substring) + 1 {\n          ^\n/tmp/tmpmpi0rmxe.swift:12:11: error: unary operator cannot be separated from its operand\n    for i < len(string) - len(substring) + 1 {\n          ^~\n           \n/tmp/tmpmpi0rmxe.swift:12:11: error: '<' is not a prefix unary operator\n    for i < len(string) - len(substring) + 1 {\n          ^\n/tmp/tmpmpi0rmxe.swift:12:13: error: cannot find 'len' in scope\n    for i < len(string) - len(substring) + 1 {\n            ^~~\n/tmp/tmpmpi0rmxe.swift:12:27: error: cannot find 'len' in scope\n    for i < len(string) - len(substring) + 1 {\n                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpa_f66adh.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpa_f66adh.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpa_f66adh.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpa_f66adh.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpa_f66adh.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += how_many_times(string[i+1:], substring[1:])\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp13jnv9gm.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp13jnv9gm.swift:17:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp13jnv9gm.swift:19:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp13jnv9gm.swift:19:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp13jnv9gm.swift:19:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp13jnv9gm.swift:21:47: error: expected ',' separator\n            count += how_many_times(string[i+1:], substring[1:])\n                                              ^\n                                              ,\n/tmp/tmp13jnv9gm.swift:21:47: error: expected expression in list of expressions\n            count += how_many_times(string[i+1:], substring[1:])\n                                              ^\n/tmp/tmp13jnv9gm.swift:21:62: error: expected ',' separator\n            count += how_many_times(string[i+1:], substring[1:])\n                                                             ^\n                                                             ,\n/tmp/tmp13jnv9gm.swift:21:62: error: expected expression in list of expressions\n            count += how_many_times(string[i+1:], substring[1:])\n                                                             ^\n/tmp/tmp13jnv9gm.swift:17:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp13jnv9gm.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    for i < len(string) {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n            i += len(substring)\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpyov39u6m.swift:12:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpyov39u6m.swift:12:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpyov39u6m.swift:12:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpyov39u6m.swift:12:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpuf_tx72a.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpuf_tx72a.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpuf_tx72a.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpuf_tx72a.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuf_tx72a.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpuf_tx72a.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpuf_tx72a.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuf_tx72a.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpuf_tx72a.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpuf_tx72a.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpuf_tx72a.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_len = len(substring)\n    var string_len = len(string)\n    while i < string_len {\n        if string[i] == substring[j] {\n            count += 1\n            j += 1\n            if j == substring_len {\n                j = 0\n                i += 1\n            }\n        } else {\n            j = 0\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpuh45x0ol.swift:13:25: error: cannot find 'len' in scope\n    var substring_len = len(substring)\n                        ^~~\n/tmp/tmpuh45x0ol.swift:14:22: error: cannot find 'len' in scope\n    var string_len = len(string)\n                     ^~~\n/tmp/tmpuh45x0ol.swift:16:12: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpuh45x0ol.swift:16:25: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpnvwfagij.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpnvwfagij.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpnvwfagij.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpnvwfagij.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmplaqv8uka.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmplaqv8uka.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmplaqv8uka.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmplaqv8uka.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmplaqv8uka.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmplaqv8uka.swift:22:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmplaqv8uka.swift:22:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmplaqv8uka.swift:22:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmplaqv8uka.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmplaqv8uka.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpgx4f3fzh.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpgx4f3fzh.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpgx4f3fzh.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp0h71d5mq.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp0h71d5mq.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp0h71d5mq.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp0h71d5mq.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp0h71d5mq.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp0h71d5mq.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp0h71d5mq.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp0h71d5mq.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp0h71d5mq.swift:20:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppri3k_74.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppri3k_74.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppri3k_74.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppri3k_74.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppri3k_74.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpainu35jx.swift:11:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpainu35jx.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpainu35jx.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) && j < len(substring) {\n        if string[i] == substring[j] {\n            count += 1\n            i += 1\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp2lywb8t5.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) && j < len(substring) {\n          ^\n/tmp/tmp2lywb8t5.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) && j < len(substring) {\n          ^~\n           \n/tmp/tmp2lywb8t5.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) && j < len(substring) {\n          ^\n/tmp/tmp2lywb8t5.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) && j < len(substring) {\n            ^~~\n/tmp/tmp2lywb8t5.swift:13:32: error: cannot find 'len' in scope\n    for i < len(string) && j < len(substring) {\n                               ^~~\n/tmp/tmp2lywb8t5.swift:13:25: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(string) && j < len(substring) {\n          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpt8j_lwn0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpt8j_lwn0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpt8j_lwn0.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpt8j_lwn0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpt8j_lwn0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpt8j_lwn0.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpt8j_lwn0.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpt8j_lwn0.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpt8j_lwn0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpt8j_lwn0.swift:29:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp7q3oa_3k.swift:11:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp7q3oa_3k.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp7q3oa_3k.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n        return 1\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsl_2rbgg.swift:17:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsl_2rbgg.swift:17:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsl_2rbgg.swift:18:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpsl_2rbgg.swift:18:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsl_2rbgg.swift:18:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpsl_2rbgg.swift:17:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsl_2rbgg.swift:23:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsyebkt0i.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsyebkt0i.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsyebkt0i.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpsyebkt0i.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsyebkt0i.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsyebkt0i.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpsyebkt0i.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsyebkt0i.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsyebkt0i.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsyebkt0i.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); {\n        if string[i] == substring[0] {\n            count += 1\n            i += 1\n            \n            for j := 1; j < len(substring); {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n                j += 1\n            }\n        } else {\n            i += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppf0041pd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppf0041pd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppf0041pd.swift:16:12: error: expected type\n    for i := 0; i < len(string); {\n           ^\n            <#type#>\n/tmp/tmppf0041pd.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); {\n           ^\n/tmp/tmppf0041pd.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); {\n           ^\n/tmp/tmppf0041pd.swift:21:20: error: expected type\n            for j := 1; j < len(substring); {\n                   ^\n                    <#type#>\n/tmp/tmppf0041pd.swift:21:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); {\n                   ^\n/tmp/tmppf0041pd.swift:21:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); {\n                   ^\n/tmp/tmppf0041pd.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmppf0041pd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppf0041pd.swift:34:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_len = len(substring)\n    var string_len = len(string)\n    while i < string_len {\n        j = 0\n        while j < substring_len {\n            if string[i + j] != substring[j] {\n                break\n            }\n            j += 1\n        }\n        if j == substring_len {\n            count += 1\n            i += substring_len\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpwnzp8im7.swift:13:25: error: cannot find 'len' in scope\n    var substring_len = len(substring)\n                        ^~~\n/tmp/tmpwnzp8im7.swift:14:22: error: cannot find 'len' in scope\n    var string_len = len(string)\n                     ^~~\n/tmp/tmpwnzp8im7.swift:18:16: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i + j] != substring[j] {\n               ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwnzp8im7.swift:18:33: error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index instead.\n            if string[i + j] != substring[j] {\n                                ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i: Int) -> Character { get }\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp0yslczxb.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp0yslczxb.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp0yslczxb.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp0yslczxb.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp0yslczxb.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpnvwfagij.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpnvwfagij.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpnvwfagij.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpnvwfagij.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmptpb4z39r.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmptpb4z39r.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmptpb4z39r.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmptpb4z39r.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmptpb4z39r.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmptpb4z39r.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmptpb4z39r.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmptpb4z39r.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmptpb4z39r.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            if len(substring) == 1 {\n                return count\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp_4_iyp2h.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp_4_iyp2h.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp_4_iyp2h.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp_4_iyp2h.swift:33:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppmubaqyh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppmubaqyh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppmubaqyh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppmubaqyh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmppmubaqyh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmppmubaqyh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppmubaqyh.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxuuaamkz.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpxuuaamkz.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpxuuaamkz.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpxuuaamkz.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpxuuaamkz.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpxuuaamkz.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpxuuaamkz.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpxuuaamkz.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpxuuaamkz.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 {\n       ^~~\n/tmp/tmpxuuaamkz.swift:13:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpxuuaamkz.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpxuuaamkz.swift:28:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp5kp_afhm.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp5kp_afhm.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp5kp_afhm.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp5kp_afhm.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp5kp_afhm.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp5kp_afhm.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp5kp_afhm.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) && j < len(substring) {\n        if string[i] == substring[j] {\n            count += 1\n            i += 1\n            j += 1\n        } else {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp2lywb8t5.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) && j < len(substring) {\n          ^\n/tmp/tmp2lywb8t5.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) && j < len(substring) {\n          ^~\n           \n/tmp/tmp2lywb8t5.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) && j < len(substring) {\n          ^\n/tmp/tmp2lywb8t5.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) && j < len(substring) {\n            ^~~\n/tmp/tmp2lywb8t5.swift:13:32: error: cannot find 'len' in scope\n    for i < len(string) && j < len(substring) {\n                               ^~~\n/tmp/tmp2lywb8t5.swift:13:25: error: for-in loop requires 'Bool' to conform to 'Sequence'\n    for i < len(string) && j < len(substring) {\n          ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmppmubaqyh.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmppmubaqyh.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmppmubaqyh.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmppmubaqyh.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmppmubaqyh.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmppmubaqyh.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmppmubaqyh.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmppmubaqyh.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        j = 0\n        for j < len(substring) {\n            if string[i+j] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpphs3yx49.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpphs3yx49.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpphs3yx49.swift:15:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpphs3yx49.swift:15:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpphs3yx49.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpphs3yx49.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpphs3yx49.swift:15:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpphs3yx49.swift:15:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpainu35jx.swift:11:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpainu35jx.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpainu35jx.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy1d4gctd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy1d4gctd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy1d4gctd.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpy1d4gctd.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy1d4gctd.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy1d4gctd.swift:24:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpy1d4gctd.swift:24:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy1d4gctd.swift:24:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy1d4gctd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy1d4gctd.swift:34:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp0yslczxb.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp0yslczxb.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp0yslczxb.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp0yslczxb.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp0yslczxb.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp0yslczxb.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += how_many_times(string[i+1:], substring[1:])\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp258uc9p9.swift:16:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp258uc9p9.swift:16:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp258uc9p9.swift:17:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp258uc9p9.swift:17:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp258uc9p9.swift:17:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp258uc9p9.swift:19:47: error: expected ',' separator\n            count += how_many_times(string[i+1:], substring[1:])\n                                              ^\n                                              ,\n/tmp/tmp258uc9p9.swift:19:47: error: expected expression in list of expressions\n            count += how_many_times(string[i+1:], substring[1:])\n                                              ^\n/tmp/tmp258uc9p9.swift:19:62: error: expected ',' separator\n            count += how_many_times(string[i+1:], substring[1:])\n                                                             ^\n                                                             ,\n/tmp/tmp258uc9p9.swift:19:62: error: expected expression in list of expressions\n            count += how_many_times(string[i+1:], substring[1:])\n                                                             ^\n/tmp/tmp258uc9p9.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 {\n       ^~~\n/tmp/tmp258uc9p9.swift:13:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmp258uc9p9.swift:16:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp258uc9p9.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            if len(substring) == 1 {\n                return count\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    count -= 1\n                    break\n                }\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp_4_iyp2h.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp_4_iyp2h.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp_4_iyp2h.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp_4_iyp2h.swift:24:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp_4_iyp2h.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp_4_iyp2h.swift:33:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpv9nn8g1_.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpv9nn8g1_.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpv9nn8g1_.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpv9nn8g1_.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpv9nn8g1_.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpv9nn8g1_.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpv9nn8g1_.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    if string[0] == substring[0] {\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n    } else {\n        return how_many_times(string[1:], substring)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpg7mvf1vs.swift:17:39: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n                                      ,\n/tmp/tmpg7mvf1vs.swift:17:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n/tmp/tmpg7mvf1vs.swift:17:79: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n                                                                              ,\n/tmp/tmpg7mvf1vs.swift:17:79: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n/tmp/tmpg7mvf1vs.swift:17:94: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n                                                                                             ,\n/tmp/tmpg7mvf1vs.swift:17:94: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n/tmp/tmpg7mvf1vs.swift:19:39: error: expected ',' separator\n        return how_many_times(string[1:], substring)\n                                      ^\n                                      ,\n/tmp/tmpg7mvf1vs.swift:19:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring)\n                                      ^\n/tmp/tmpg7mvf1vs.swift:10:8: error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8swx_jst.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp8swx_jst.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp8swx_jst.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp8swx_jst.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp8swx_jst.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp8swx_jst.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp8swx_jst.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp8swx_jst.swift:27:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvsw6wphp.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvsw6wphp.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvsw6wphp.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvsw6wphp.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvsw6wphp.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvsw6wphp.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpvsw6wphp.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvsw6wphp.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpvsw6wphp.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvsw6wphp.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) < len(substring) {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpvk1n4wdf.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpvk1n4wdf.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpvk1n4wdf.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpvk1n4wdf.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvk1n4wdf.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpvk1n4wdf.swift:10:8: error: cannot find 'len' in scope\n    if len(string) < len(substring) {\n       ^~~\n/tmp/tmpvk1n4wdf.swift:10:22: error: cannot find 'len' in scope\n    if len(string) < len(substring) {\n                     ^~~\n/tmp/tmpvk1n4wdf.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpvk1n4wdf.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpi28wtwu1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpi28wtwu1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpi28wtwu1.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpi28wtwu1.swift:20:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:20:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpi28wtwu1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpi28wtwu1.swift:30:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp827edjwd.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmp827edjwd.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmp827edjwd.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmp827edjwd.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmp827edjwd.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmp827edjwd.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    for i < len(string) {\n        for j < len(substring) {\n            if string[i] == substring[j] {\n                count += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpxsg439m2.swift:13:11: error: expected 'in' after for-each pattern\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:11: error: unary operator cannot be separated from its operand\n    for i < len(string) {\n          ^~\n           \n/tmp/tmpxsg439m2.swift:14:15: error: expected 'in' after for-each pattern\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:15: error: unary operator cannot be separated from its operand\n        for j < len(substring) {\n              ^~\n               \n/tmp/tmpxsg439m2.swift:13:11: error: '<' is not a prefix unary operator\n    for i < len(string) {\n          ^\n/tmp/tmpxsg439m2.swift:13:13: error: cannot find 'len' in scope\n    for i < len(string) {\n            ^~~\n/tmp/tmpxsg439m2.swift:14:15: error: '<' is not a prefix unary operator\n        for j < len(substring) {\n              ^\n/tmp/tmpxsg439m2.swift:14:17: error: cannot find 'len' in scope\n        for j < len(substring) {\n                ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    var i = 0\n    var j = 0\n    var substring_len = len(substring)\n    var string_len = len(string)\n    for i < string_len {\n        for j < substring_len {\n            if string[i] == substring[j] {\n                count += 1\n                i += 1\n                j += 1\n            } else {\n                j = 0\n            }\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp8_4loh6m.swift:15:11: error: expected 'in' after for-each pattern\n    for i < string_len {\n          ^\n/tmp/tmp8_4loh6m.swift:15:11: error: unary operator cannot be separated from its operand\n    for i < string_len {\n          ^~\n           \n/tmp/tmp8_4loh6m.swift:16:15: error: expected 'in' after for-each pattern\n        for j < substring_len {\n              ^\n/tmp/tmp8_4loh6m.swift:16:15: error: unary operator cannot be separated from its operand\n        for j < substring_len {\n              ^~\n               \n/tmp/tmp8_4loh6m.swift:13:25: error: cannot find 'len' in scope\n    var substring_len = len(substring)\n                        ^~~\n/tmp/tmp8_4loh6m.swift:14:22: error: cannot find 'len' in scope\n    var string_len = len(string)\n                     ^~~\n/tmp/tmp8_4loh6m.swift:15:11: error: '<' is not a prefix unary operator\n    for i < string_len {\n          ^\n/tmp/tmp8_4loh6m.swift:16:15: error: '<' is not a prefix unary operator\n        for j < substring_len {\n              ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpgx4f3fzh.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpgx4f3fzh.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpgx4f3fzh.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 {\n        return 0\n    }\n    if len(substring) == 0 {\n        return 1\n    }\n    if string[0] == substring[0] {\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n    }\n    return how_many_times(string[1:], substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpm85031d2.swift:17:39: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n                                      ,\n/tmp/tmpm85031d2.swift:17:39: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                      ^\n/tmp/tmpm85031d2.swift:17:79: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n                                                                              ,\n/tmp/tmpm85031d2.swift:17:79: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                              ^\n/tmp/tmpm85031d2.swift:17:94: error: expected ',' separator\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n                                                                                             ,\n/tmp/tmpm85031d2.swift:17:94: error: expected expression in list of expressions\n        return how_many_times(string[1:], substring) + how_many_times(string[1:], substring[1:])\n                                                                                             ^\n/tmp/tmpm85031d2.swift:19:35: error: expected ',' separator\n    return how_many_times(string[1:], substring)\n                                  ^\n                                  ,\n/tmp/tmpm85031d2.swift:19:35: error: expected expression in list of expressions\n    return how_many_times(string[1:], substring)\n                                  ^\n/tmp/tmpm85031d2.swift:10:8: error: cannot find 'len' i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp2fwa_a05.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp2fwa_a05.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp2fwa_a05.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp2fwa_a05.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp2fwa_a05.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp2fwa_a05.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp2fwa_a05.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp2fwa_a05.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp2fwa_a05.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var count = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp3zxxovhb.swift:11:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp3zxxovhb.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp3zxxovhb.swift:14:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp3zxxovhb.swift:14:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            \n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                \n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpri1y9xrd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpri1y9xrd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpri1y9xrd.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpri1y9xrd.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpri1y9xrd.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpri1y9xrd.swift:24:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpri1y9xrd.swift:24:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpri1y9xrd.swift:24:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpri1y9xrd.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpri1y9xrd.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpri1y9xrd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpri1y9xrd.swift:34:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpdpdvd7c0.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpdpdvd7c0.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpdpdvd7c0.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpdpdvd7c0.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            if len(substring) == 1 {\n                break\n            }\n            \n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpjlmuube2.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpjlmuube2.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpjlmuube2.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpjlmuube2.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpjlmuube2.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpjlmuube2.swift:22:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpjlmuube2.swift:22:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpjlmuube2.swift:22:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpjlmuube2.swift:10:8: error: cannot find 'len' in scope\n    if len(substring) == 0 {\n       ^~~\n/tmp/tmpjlmuube2.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpjlmuube2.swift:31:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count++\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpnvwfagij.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpnvwfagij.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpnvwfagij.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpnvwfagij.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpnvwfagij.swift:19:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpy74ms2xd.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpy74ms2xd.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpy74ms2xd.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpy74ms2xd.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpy74ms2xd.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpy74ms2xd.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp611v7u42.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp611v7u42.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp611v7u42.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp611v7u42.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmp611v7u42.swift:18:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmp611v7u42.swift:18:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:18:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmp611v7u42.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmp611v7u42.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmp611v7u42.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp611v7u42.swift:26:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmposrvmfmj.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmposrvmfmj.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmposrvmfmj.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmposrvmfmj.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmposrvmfmj.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmposrvmfmj.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmposrvmfmj.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmposrvmfmj.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpa_f66adh.swift:13:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpa_f66adh.swift:13:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpa_f66adh.swift:14:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:14:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpa_f66adh.swift:17:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:17:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpa_f66adh.swift:13:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpa_f66adh.swift:25:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) < len(substring) {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i + len(substring)] == substring {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmp_ih752ut.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmp_ih752ut.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmp_ih752ut.swift:15:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmp_ih752ut.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp_ih752ut.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmp_ih752ut.swift:10:8: error: cannot find 'len' in scope\n    if len(string) < len(substring) {\n       ^~~\n/tmp/tmp_ih752ut.swift:10:22: error: cannot find 'len' in scope\n    if len(string) < len(substring) {\n                     ^~~\n/tmp/tmp_ih752ut.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmp_ih752ut.swift:21:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if string == \"\" {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n                if string[i+j] != substring[j] {\n                    break\n                }\n                count += 1\n            }\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpsyy3nfqu.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpsyy3nfqu.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpsyy3nfqu.swift:16:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpsyy3nfqu.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsyy3nfqu.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmpsyy3nfqu.swift:19:20: error: expected type\n            for j := 1; j < len(substring); j++ {\n                   ^\n                    <#type#>\n/tmp/tmpsyy3nfqu.swift:19:20: error: expected 'in' after for-each pattern\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsyy3nfqu.swift:19:20: error: expected Sequence expression for for-each loop\n            for j := 1; j < len(substring); j++ {\n                   ^\n/tmp/tmpsyy3nfqu.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpsyy3nfqu.swift:28:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    \n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n        if string[i:i+len(substring)] == substring {\n            count++\n        }\n    }\n    \n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmpn_b8hwtm.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmpn_b8hwtm.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmpn_b8hwtm.swift:16:12: error: expected type\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n            <#type#>\n/tmp/tmpn_b8hwtm.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpn_b8hwtm.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string) - len(substring) + 1; i++ {\n           ^\n/tmp/tmpn_b8hwtm.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmpn_b8hwtm.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmpn_b8hwtm.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmpn_b8hwtm.swift:22:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring: \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n/// 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if len(string) == 0 || len(substring) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n            count += how_many_times(string[i+1:], substring)\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "/tmp/tmptp4433a1.swift:14:10: error: consecutive statements on a line must be separated by ';'\n    count := 0\n         ^\n         ;\n/tmp/tmptp4433a1.swift:14:11: error: expected expression\n    count := 0\n          ^\n/tmp/tmptp4433a1.swift:15:12: error: expected type\n    for i := 0; i < len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmptp4433a1.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmptp4433a1.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(string); i++ {\n           ^\n/tmp/tmptp4433a1.swift:17:47: error: expected ',' separator\n            count += how_many_times(string[i+1:], substring)\n                                              ^\n                                              ,\n/tmp/tmptp4433a1.swift:17:47: error: expected expression in list of expressions\n            count += how_many_times(string[i+1:], substring)\n                                              ^\n/tmp/tmptp4433a1.swift:10:8: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n       ^~~\n/tmp/tmptp4433a1.swift:10:28: error: cannot find 'len' in scope\n    if len(string) == 0 || len(substring) == 0 {\n                           ^~~\n/tmp/tmptp4433a1.swift:14:5: error: cannot find 'count' in scope\n    count := 0\n    ^~~~~\n/tmp/tmptp4433a1.swift:20:12: error: cannot find 'count' in scope\n    return count\n           ^~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}