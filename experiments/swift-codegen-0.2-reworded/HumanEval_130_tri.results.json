{
  "name": "HumanEval_130_tri",
  "language": "swift",
  "prompt": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n <= 0 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n == 2 {\n        return [1, 3]\n    }\n    return [1, 3, 2, 8]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "tmp3okommfc/tmp3okommfc.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af66a72ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af66a421b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af66a421988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af66a4207b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3okommfc                        0x000056173b14c47f <unavailable> + 5247\n5    libc.so.6                          0x00002af66a916460 __libc_start_main + 245\n6    tmp3okommfc                        0x000056173b14bfc9 <unavailable> + 4041\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmprlwyce9f.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmprlwyce9f.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmprlwyce9f.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmprlwyce9f.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmprlwyce9f.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmprlwyce9f.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmprlwyce9f.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmprlwyce9f.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmprlwyce9f.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n             ^\n             ;\n/tmp/tmprlwyce9f.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n                  ^\n                  ;\n/tmp/tmprlwyce9f.swift:31:19: error: expected expression\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n                  ^\n/tmp/tmprlwyce9f.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpbb5vse8h.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpbb5vse8h.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpbb5vse8h.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpbb5vse8h.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpbb5vse8h.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 2, 3, 5]\n    }\n    return [1, 3, 2, 8]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "tmp3hdie3fb/tmp3hdie3fb.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ab24675bc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ab246452b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ab246452988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ab2464517b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp3hdie3fb                        0x0000555f710d551f <unavailable> + 5407\n5    libc.so.6                          0x00002ab246947460 __libc_start_main + 245\n6    tmp3hdie3fb                        0x0000555f710d5069 <unavailable> + 4201\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2}\n    }\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpt4i7vo5l.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2}\n                      ^\n                      ;\n/tmp/tmpt4i7vo5l.swift:26:23: error: expected expression\n        return [Int]{1, n / 2}\n                      ^\n/tmp/tmpt4i7vo5l.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                ^\n                ;\n/tmp/tmpt4i7vo5l.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                  ^\n                  ;\n/tmp/tmpt4i7vo5l.swift:28:19: error: expected expression\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                  ^\n/tmp/tmpt4i7vo5l.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpt4i7vo5l.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpt4i7vo5l.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpt4i7vo5l.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpt4i7vo5l.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpt4i7vo5l.swift:23:21: note: did you mean to use a 'do' stat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp9xx7j8mr.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp9xx7j8mr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp9xx7j8mr.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable pu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 1 + n / 2}\n    }\n    return []Int{1, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpz77l22w1.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpz77l22w1.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpz77l22w1.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpz77l22w1.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpz77l22w1.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpz77l22w1.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2}\n                 ^\n                 ;\n/tmp/tmpz77l22w1.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpz77l22w1.swift:29:23: error: expected expression\n        return []Int{1, 1 + n / 2}\n                      ^\n/tmp/tmpz77l22w1.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2 + 1}\n             ^\n             ;\n/tmp/tmpz77l22w1.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpz77l22w1.swift:31:19: error: expected expression\n    return []Int{1, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpz77l22w1.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requir",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp0_tg4tep.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp0_tg4tep.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp0_tg4tep.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    a := []Int{1, 3}\n    b := []Int{1, 2}\n    c := []Int{1, 1}\n    \n    for i := 2; i <= n; i++ {\n        a = append(a, b[0] + b[1] + c[0] + c[1])\n        b = append(b, a[0] + a[1] + c[0] + c[1])\n        c = append(c, a[0] + a[1] + b[0] + b[1])\n    }\n    \n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfcibg1we.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpfcibg1we.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpfcibg1we.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpfcibg1we.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpfcibg1we.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpfcibg1we.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpfcibg1we.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpfcibg1we.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpfcibg1we.swift:32:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 3}\n     ^\n     ;\n/tmp/tmpfcibg1we.swift:32:7: error: expected expression\n    a := []Int{1, 3}\n      ^\n/tmp/tmpfcibg1we.swift:36:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpfcibg1we.swift:36:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpfcibg1we.swift:36:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpfcibg1we.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(cod",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 2, 3, 5}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpejd_c35a.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpejd_c35a.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpejd_c35a.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpejd_c35a.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpejd_c35a.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpejd_c35a.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 2, 3, 5}\n                ^\n                ;\n/tmp/tmpejd_c35a.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 2, 3, 5}\n                  ^\n                  ;\n/tmp/tmpejd_c35a.swift:28:19: error: expected expression\n    return [Int]{1, 2, 3, 5}\n                  ^\n/tmp/tmpejd_c35a.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpejd_c35a.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpejd_c35a.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpejd_c35a.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpejd_c35a.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpejd_c35a.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpejd_c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return []Int{1}\n    }\n    if n == 1 {\n        return []Int{3}\n    }\n    if n == 2 {\n        return []Int{2}\n    }\n    \n    var a, b, c, result []Int\n    a = []Int{1, 3}\n    b = []Int{1, 1}\n    c = []Int{1, 2}\n    \n    for i := 0; i < n - 2; i++ {\n        result = append(result, a[0] + b[0] + c[0])\n        a = append(a, b[0] + c[0])\n        b = append(b, c[0])\n        c = append(c, a[0] + b[0])\n    }\n    \n    result = append(result, a[0] + b[0] + c[0])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpw5po3d6i.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpw5po3d6i.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{3}\n                 ^\n                 ;\n/tmp/tmpw5po3d6i.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{2}\n                 ^\n                 ;\n/tmp/tmpw5po3d6i.swift:32:24: error: consecutive statements on a line must be separated by ';'\n    var a, b, c, result []Int\n                       ^\n                       ;\n/tmp/tmpw5po3d6i.swift:32:27: error: consecutive statements on a line must be separated by ';'\n    var a, b, c, result []Int\n                          ^\n                          ;\n/tmp/tmpw5po3d6i.swift:33:11: error: consecutive statements on a line must be separated by ';'\n    a = []Int{1, 3}\n          ^\n          ;\n/tmp/tmpw5po3d6i.swift:33:16: error: consecutive statements on a line must be separated by ';'\n    a = []Int{1, 3}\n               ^\n               ;\n/tmp/tmpw5po3d6i.swift:33:16: error: expected expression\n    a = []Int{1, 3}\n               ^\n/tmp/tmpw5po3d6i.swift:34:11: error: consecutive statements on a line must be separated by ';'\n    b = []Int{1, 1}\n          ^\n          ;\n/tmp/tmpw5po3d6i.swift:34:16: error: consecutive statements on a line must be separated by ';'\n    b = []Int{1, 1}\n               ^\n               ;\n/tmp/tmpw5po3d6i.swift:34:16: error: expected expression\n    b = []Int{1, 1}\n               ^\n/tmp/tmpw5po3d6i.swift:35:11: error: consecutive statements on a line must be separated by ';'\n    c = []Int{1, 2}\n          ^\n          ;\n/tmp/tmpw5po3d6i.swift:35:16: error: consecutive statements on a line must be separated by ';'\n    c = []Int{1, 2}\n               ^\n               ;\n/tmp/tmpw5po3d6i.swift:35:16: error: expected expression\n    c = []Int{1, 2}\n               ^\n/tmp/tmpw5po3d6i.swift:37:12: error: expected type\n    for i := 0; i < n - ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1, 2, 3}\n    }\n    return [Int]{1, 2, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpztfbasp4.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpztfbasp4.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpztfbasp4.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpztfbasp4.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpztfbasp4.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpztfbasp4.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpztfbasp4.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpztfbasp4.swift:29:23: error: expected expression\n        return [Int]{1, 1, 2, 3}\n                      ^\n/tmp/tmpztfbasp4.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 2, 3, 5, 8}\n                ^\n                ;\n/tmp/tmpztfbasp4.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 2, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmpztfbasp4.swift:31:19: error: expected expression\n    return [Int]{1, 2, 3, 5, 8}\n                  ^\n/tmp/tmpztfbasp4.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpztfbasp4.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpztfbasp4.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 3, 2, 8]\n    }\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpmsrx0j5c.swift:28:31: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                              ^\n                              n: \n/tmp/tmpmsrx0j5c.swift:28:44: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                                           ^\n                                           n: \n/tmp/tmpmsrx0j5c.swift:28:57: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                                                        ^\n                                                        n: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n <= 0 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n == 2 {\n        return [1, 2]\n    }\n    if n == 3 {\n        return [1, 3, 2, 8]\n    }\n    if n % 2 == 0 {\n        return [1, 1 + n / 2, 1 + n / 2, 1 + n / 2]\n    }\n    return [1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "tmpcs0k15nu/tmpcs0k15nu.swift:51: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ac2b20d0c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ac2b1dc7b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ac2b1dc7988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ac2b1dc67b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpcs0k15nu                        0x0000562c5f82051f <unavailable> + 5407\n5    libc.so.6                          0x00002ac2b22bc460 __libc_start_main + 245\n6    tmpcs0k15nu                        0x0000562c5f820069 <unavailable> + 4201\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n == 2 {\n        return [Int]{2, 3}\n    }\n    \n    var a, b, c [Int]\n    a = [Int]{1}\n    b = [Int]{3}\n    c = [Int]{2, 3}\n    \n    for i := 3; i <= n; i++ {\n        a = append(a, b...)\n        b = append(b, c...)\n        c = append(c, a...)\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpoxbnhzhb.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpoxbnhzhb.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmpoxbnhzhb.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmpoxbnhzhb.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmpoxbnhzhb.swift:29:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmpoxbnhzhb.swift:32:16: error: consecutive statements on a line must be separated by ';'\n    var a, b, c [Int]\n               ^\n               ;\n/tmp/tmpoxbnhzhb.swift:33:14: error: consecutive statements on a line must be separated by ';'\n    a = [Int]{1}\n             ^\n             ;\n/tmp/tmpoxbnhzhb.swift:34:14: error: consecutive statements on a line must be separated by ';'\n    b = [Int]{3}\n             ^\n             ;\n/tmp/tmpoxbnhzhb.swift:35:14: error: consecutive statements on a line must be separated by ';'\n    c = [Int]{2, 3}\n             ^\n             ;\n/tmp/tmpoxbnhzhb.swift:35:16: error: consecutive statements on a line must be separated by ';'\n    c = [Int]{2, 3}\n               ^\n               ;\n/tmp/tmpoxbnhzhb.swift:35:16: error: expected expression\n    c = [Int]{2, 3}\n               ^\n/tmp/tmpoxbnhzhb.swift:37:12: error: expected type\n    for i := 3; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpoxbnhzhb.swift:37:12: error: expected 'in' after for-each pattern\n    for i := 3; i <= n; i++ {\n           ^\n/tmp/tmpoxbnhzhb.swift:37:12: error: expected Sequence expression for for-each loop\n    for i := 3; i <= n; i++ {\n           ^\n/tmp/tmpoxbnhzhb.swift:20:9: error: cannot find 'panic' in scope\n        panic(\"n should be non-",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    \n    var a = [Int]{}\n    a[0] = 1\n    a[1] = 3\n    \n    for i := 2; i <= n; i++ {\n        a[i] = 1 + (i / 2)\n        if i % 2 == 0 {\n            a[i] += a[i - 1] + a[i - 2]\n        } else {\n            a[i] += a[i - 1] + a[i - 2] + a[i + 1]\n        }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpprggs4zq.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpprggs4zq.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpprggs4zq.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpprggs4zq.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpprggs4zq.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpprggs4zq.swift:29:18: error: unexpected '{' in declaration\n    var a = [Int]{}\n                 ^\n/tmp/tmpprggs4zq.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpprggs4zq.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpprggs4zq.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpprggs4zq.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpprggs4zq.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpprggs4zq.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpprggs4zq.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpprggs4zq.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpprggs4zq.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n - 1), 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp4s3i4_ge.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp4s3i4_ge.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp4s3i4_ge.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable public i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    a := []Int{1, 3}\n    b := []Int{1, 1}\n    c := []Int{1, 2}\n    \n    for i := 2; i <= n; i++ {\n        a = append(a, b[0] + b[1] + c[0] + c[1])\n        b = append(b, c[0] + c[1])\n        c = append(c, a[0] + a[1])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmph_ju3ck5.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmph_ju3ck5.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmph_ju3ck5.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmph_ju3ck5.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmph_ju3ck5.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmph_ju3ck5.swift:29:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 3}\n     ^\n     ;\n/tmp/tmph_ju3ck5.swift:29:7: error: expected expression\n    a := []Int{1, 3}\n      ^\n/tmp/tmph_ju3ck5.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmph_ju3ck5.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmph_ju3ck5.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmph_ju3ck5.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmprch4fi10.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmprch4fi10.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmprch4fi10.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmprch4fi10.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmprch4fi10.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmprch4fi10.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmprch4fi10.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmprch4fi10.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 5}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5kd02xgx.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp5kd02xgx.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp5kd02xgx.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                ^\n                ;\n/tmp/tmp5kd02xgx.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                  ^\n                  ;\n/tmp/tmp5kd02xgx.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 5}\n                  ^\n/tmp/tmp5kd02xgx.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp5kd02xgx.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp5kd02xgx.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp5kd02xgx.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp5kd02",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 0 {\n\t\tpanic(\"n should be non-negative\")\n\t}\n\tif n == 0 {\n\t\treturn []Int{1}\n\t}\n\tif n == 1 {\n\t\treturn []Int{3}\n\t}\n\tif n == 2 {\n\t\treturn []Int{2}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmptctwkwcl.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{3}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{2}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:31:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmptctwkwcl.swift:31:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmptctwkwcl.swift:31:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmptctwkwcl.swift:20:3: error: cannot find 'panic' in scope\n                panic(\"n should be non-negative\")\n                ^~~~~\n/tmp/tmptctwkwcl.swift:23:12: error: no exact matches in call to initializer \n                return []Int{1}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> Int' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> Int' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> Int' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> Int' conf",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    \n    a := [Int]{}\n    a.append(1)\n    a.append(3)\n    a.append(2)\n    \n    for i := 3; i <= n; i++ {\n        a.append(a[i - 1] + a[i - 2] + a[i - 3])\n    }\n    \n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp6_zmcoe9.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp6_zmcoe9.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp6_zmcoe9.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmp6_zmcoe9.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmp6_zmcoe9.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmp6_zmcoe9.swift:29:6: error: consecutive statements on a line must be separated by ';'\n    a := [Int]{}\n     ^\n     ;\n/tmp/tmp6_zmcoe9.swift:29:7: error: expected expression\n    a := [Int]{}\n      ^\n/tmp/tmp6_zmcoe9.swift:34:12: error: expected type\n    for i := 3; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp6_zmcoe9.swift:34:12: error: expected 'in' after for-each pattern\n    for i := 3; i <= n; i++ {\n           ^\n/tmp/tmp6_zmcoe9.swift:34:12: error: expected Sequence expression for for-each loop\n    for i := 3; i <= n; i++ {\n           ^\n/tmp/tmp6_zmcoe9.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp6_zmcoe9.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp6_zmcoe9.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp6_zmcoe9.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp6_zmcoe9.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp6_zmcoe9.swift:23:21: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn []int{}\n\t}\n\tif n == 1 {\n\t\treturn []int{1}\n\t}\n\tif n == 2 {\n\t\treturn []int{1, 3}\n\t}\n\tif n == 3 {\n\t\treturn []int{1, 3, 2, 8}\n\t}\n\tif n % 2 == 0 {\n\t\treturn append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n\t}\n\treturn append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpyloe5lmi.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []int{}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3}\n                              ^\n                              ;\n/tmp/tmpyloe5lmi.swift:26:17: error: expected expression\n                return []int{1, 3}\n                              ^\n/tmp/tmpyloe5lmi.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:29:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmpyloe5lmi.swift:29:17: error: expected expression\n                return []int{1, 3, 2, 8}\n                              ^\n/tmp/tmpyloe5lmi.swift:20:12: error: cannot find 'int' in scope\n                return []int{}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:23:12: error: cannot find 'int' in scope\n                return []int{1}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:26:12: error: cannot find 'int' in scope\n                return []int{1, 3}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:29:12: error: cannot find 'int' in scope\n                return []int{1, 3, 2, 8}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:32:10: error: cannot find 'append' in scope\n                return append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpnuf8vl5n.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpnuf8vl5n.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpnuf8vl5n.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpnuf8vl5n.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpnuf8vl5n.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpnuf8vl5n.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2}\n                    ^\n                    ;\n/tmp/tmpnuf8vl5n.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpnuf8vl5n.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2}\n                      ^\n/tmp/tmpnuf8vl5n.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + 1}\n                ^\n                ;\n/tmp/tmpnuf8vl5n.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpnuf8vl5n.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpnuf8vl5n.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpnuf8vl5n.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpnuf8vl5n.swift:20:21: note: did you mean to use a 'do",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    \n    var a = [Int]{1, 3}\n    for i := 2; i <= n; i++ {\n        a = append(a, a[i-1] + a[i-2] + a[i+1])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpagk7c37_.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpagk7c37_.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpagk7c37_.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpagk7c37_.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpagk7c37_.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpagk7c37_.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var a = [Int]{1, 3}\n                   ^\n                   ;\n/tmp/tmpagk7c37_.swift:29:20: error: expected expression\n    var a = [Int]{1, 3}\n                   ^\n/tmp/tmpagk7c37_.swift:29:9: error: computed property must have an explicit type\n    var a = [Int]{1, 3}\n        ^\n         : <# Type #>\n/tmp/tmpagk7c37_.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpagk7c37_.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpagk7c37_.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpagk7c37_.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpagk7c37_.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpagk7c37_.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpagk7c37_.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2)...)\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n - 1) + tri(n - 2) + tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmprl2fsk74.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmprl2fsk74.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmprl2fsk74.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmprl2fsk74.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmprl2fsk74.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmprl2fsk74.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmprl2fsk74.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmprl2fsk74.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmprl2fsk74.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmprch4fi10.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmprch4fi10.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmprch4fi10.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmprch4fi10.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmprch4fi10.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmprch4fi10.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmprch4fi10.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmprch4fi10.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpnp8czd7z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpnp8czd7z.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n/tmp/tmpnp8czd7z.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                ^\n                ;\n/tmp/tmpnp8czd7z.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpnp8czd7z.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpnp8czd7z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpnp8czd7z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    a := []Int{1, 1}\n    b := []Int{1, 1}\n    c := []Int{1, 1}\n    \n    for i := 2; i <= n; i++ {\n        a = append(a, 1 + (i / 2))\n        b = append(b, 1 + (i - 1))\n        c = append(c, 1 + (i - 2))\n    }\n    \n    return append(append(append(a, b...), c...), 1 + (n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpqdrcwvks.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpqdrcwvks.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpqdrcwvks.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpqdrcwvks.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpqdrcwvks.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpqdrcwvks.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpqdrcwvks.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpqdrcwvks.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpqdrcwvks.swift:32:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 1}\n     ^\n     ;\n/tmp/tmpqdrcwvks.swift:32:7: error: expected expression\n    a := []Int{1, 1}\n      ^\n/tmp/tmpqdrcwvks.swift:36:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpqdrcwvks.swift:36:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpqdrcwvks.swift:36:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpqdrcwvks.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(cod",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 2, 3]\n    }\n    return [1, 3, 2, 8]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "tmpaqqu5zm8/tmpaqqu5zm8.swift:45: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b3c1d730c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3c1d427b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3c1d427988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3c1d4267b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpaqqu5zm8                        0x00005586e55ac51f <unavailable> + 5407\n5    libc.so.6                          0x00002b3c1d91c460 __libc_start_main + 245\n6    tmpaqqu5zm8                        0x00005586e55ac069 <unavailable> + 4201\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    a := []Int{1, 3}\n    b := []Int{1, 1}\n    c := []Int{1, 1}\n    \n    for i := 2; i <= n; i++ {\n        a = append(a, b[0] + b[1])\n        b = append(b, a[0] + a[1])\n        c = append(c, b[0] + b[1])\n    }\n    \n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp6gbm1_of.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp6gbm1_of.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp6gbm1_of.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp6gbm1_of.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp6gbm1_of.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp6gbm1_of.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp6gbm1_of.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp6gbm1_of.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp6gbm1_of.swift:32:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 3}\n     ^\n     ;\n/tmp/tmp6gbm1_of.swift:32:7: error: expected expression\n    a := []Int{1, 3}\n      ^\n/tmp/tmp6gbm1_of.swift:36:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp6gbm1_of.swift:36:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gbm1_of.swift:36:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp6gbm1_of.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(cod",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 0 {\n\t\tpanic(\"n should be non-negative\")\n\t}\n\tif n == 0 {\n\t\treturn []Int{1}\n\t}\n\tif n == 1 {\n\t\treturn []Int{3}\n\t}\n\tif n == 2 {\n\t\treturn []Int{2}\n\t}\n\tif n == 3 {\n\t\treturn []Int{8}\n\t}\n\t\n\tvar a, b, c, d, e, f, g, h, i, j, k, l, m, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30, n31, n32, n33, n34, n35, n36, n37, n38, n39, n40, n41, n42, n43, n44, n45, n46, n47, n48, n49, n50, n51, n52, n53, n54, n55, n56, n57, n58, n59, n60, n61, n62, n63, n64, n65, n66, n67, n68, n69, n70, n71, n72, n73, n74, n75, n76, n77, n78, n79, n80, n81, n82, n83, n84, n85, n86, n87, n88, n89, n90, n91, n92, n93, n94, n95, n96, n97, n98, n99, n100, n101, n102, n103, n104, n105, n106, n107, n108, n109, n110, n111, n112, n113, n114, n115, n116, n117, n118, n119, n120, n121, n122, n123, n124, n125, n126, n127, n128, n129, n130\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5yde7el4.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmp5yde7el4.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{3}\n                         ^\n                         ;\n/tmp/tmp5yde7el4.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{2}\n                         ^\n                         ;\n/tmp/tmp5yde7el4.swift:32:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{8}\n                         ^\n                         ;\n/tmp/tmp5yde7el4.swift:20:3: error: cannot find 'panic' in scope\n                panic(\"n should be non-negative\")\n                ^~~~~\n/tmp/tmp5yde7el4.swift:23:12: error: no exact matches in call to initializer \n                return []Int{1}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> Int' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> Int' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> Int' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> Int' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> Int' conform to 'BinaryInteger'",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    var a = []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        a = append(a, a[i-1] + a[i-2] + a[i-3])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpg_g88f7i.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpg_g88f7i.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpg_g88f7i.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpg_g88f7i.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpg_g88f7i.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpg_g88f7i.swift:29:15: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 3}\n              ^\n              ;\n/tmp/tmpg_g88f7i.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 3}\n                   ^\n                   ;\n/tmp/tmpg_g88f7i.swift:29:20: error: expected expression\n    var a = []Int{1, 3}\n                   ^\n/tmp/tmpg_g88f7i.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpg_g88f7i.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpg_g88f7i.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpg_g88f7i.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInt",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpvohkpeir.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpvohkpeir.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpvohkpeir.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpvohkpeir.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpvohkpeir.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpvohkpeir.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpvohkpeir.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpvohkpeir.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpvohkpeir.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else if n == 3 {\n        return []Int{1, 3, 2, 8}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5jp4fuho.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp5jp4fuho.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:28:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' confor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 2}\n    } else if n == 3 {\n        return []Int{1, 3, 2, 8}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpz44ojepr.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:24:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpz44ojepr.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpz44ojepr.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:28:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpz44ojepr.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' confor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 3, 2, 8]\n    }\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpmsrx0j5c.swift:28:31: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                              ^\n                              n: \n/tmp/tmpmsrx0j5c.swift:28:44: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                                           ^\n                                           n: \n/tmp/tmpmsrx0j5c.swift:28:57: error: missing argument label 'n:' in call\n    return [1, 3, 2, 8] + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                                                        ^\n                                                        n: \n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    if n == 2 {\n        return []int{1, 3}\n    }\n    if n == 3 {\n        return []int{1, 3, 2, 8}\n    }\n    \n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpskqr0haw.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []int{}\n                 ^\n                 ;\n/tmp/tmpskqr0haw.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1}\n                 ^\n                 ;\n/tmp/tmpskqr0haw.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                 ^\n                 ;\n/tmp/tmpskqr0haw.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                      ^\n                      ;\n/tmp/tmpskqr0haw.swift:26:23: error: expected expression\n        return []int{1, 3}\n                      ^\n/tmp/tmpskqr0haw.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpskqr0haw.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpskqr0haw.swift:29:23: error: expected expression\n        return []int{1, 3, 2, 8}\n                      ^\n/tmp/tmpskqr0haw.swift:20:18: error: cannot find 'int' in scope\n        return []int{}\n                 ^~~\n/tmp/tmpskqr0haw.swift:23:18: error: cannot find 'int' in scope\n        return []int{1}\n                 ^~~\n/tmp/tmpskqr0haw.swift:26:18: error: cannot find 'int' in scope\n        return []int{1, 3}\n                 ^~~\n/tmp/tmpskqr0haw.swift:29:18: error: cannot find 'int' in scope\n        return []int{1, 3, 2, 8}\n                 ^~~\n/tmp/tmpskqr0haw.swift:32:12: error: cannot find 'append' in scope\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n           ^~~~~~\n/tmp/tmpskqr0haw.swift:32:23: error: missing argument label 'n:' in call\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n                      ^\n                      n: \n/tmp/tmpskqr0haw.swift:32:35: error: missing argum",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpqpgjrdt2.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpqpgjrdt2.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpqpgjrdt2.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpqpgjrdt2.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpqpgjrdt2.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpqpgjrdt2.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpqpgjrdt2.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpqpgjrdt2.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpqpgjrdt2.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpqpgjrdt2.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpqpgjrdt2.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpqpgjrdt2.swift",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n <= 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmplgj8q3ar.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmplgj8q3ar.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmplgj8q3ar.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmplgj8q3ar.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmplgj8q3ar.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmplgj8q3ar.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    return []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp_2fsss7u.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp_2fsss7u.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp_2fsss7u.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp_2fsss7u.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp_2fsss7u.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp_2fsss7u.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp_2fsss7u.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp_2fsss7u.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp_2fsss7u.swift:32:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n             ^\n             ;\n/tmp/tmp_2fsss7u.swift:32:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmp_2fsss7u.swift:32:19: error: expected expression\n    return []Int{1, 3, 2, 8}\n                  ^\n/tmp/tmp_2fsss7u.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requiremen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + (n / 2))\n    }\n    return append(tri(n - 1), tri(n - 2), 1 + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp1qam8706.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp1qam8706.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp1qam8706.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable pu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n    } else {\n        return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpjfr5u_bp.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpjfr5u_bp.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpjfr5u_bp.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpjfr5u_bp.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpjfr5u_bp.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpjfr5u_bp.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 3, 2, 8}\n\t}\n\treturn []Int{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpmoxa74kp.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmpmoxa74kp.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpmoxa74kp.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmpmoxa74kp.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmpmoxa74kp.swift:26:17: error: expected expression\n                return []Int{1, 3, 2, 8}\n                              ^\n/tmp/tmpmoxa74kp.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                 ^\n                 ;\n/tmp/tmpmoxa74kp.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                      ^\n                      ;\n/tmp/tmpmoxa74kp.swift:28:16: error: expected expression\n        return []Int{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                      ^\n/tmp/tmpmoxa74kp.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'Binar",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + (n / 2), 2}\n    }\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkh96_b2z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpkh96_b2z.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpkh96_b2z.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpkh96_b2z.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpkh96_b2z.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpkh96_b2z.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + (n / 2), 2}\n                    ^\n                    ;\n/tmp/tmpkh96_b2z.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + (n / 2), 2}\n                      ^\n                      ;\n/tmp/tmpkh96_b2z.swift:29:23: error: expected expression\n        return [Int]{1, 1 + (n / 2), 2}\n                      ^\n/tmp/tmpkh96_b2z.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                ^\n                ;\n/tmp/tmpkh96_b2z.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                  ^\n                  ;\n/tmp/tmpkh96_b2z.swift:31:19: error: expected expression\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                  ^\n/tmp/tmpkh96_b2z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpkh96_b2z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpnp8czd7z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpnp8czd7z.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n/tmp/tmpnp8czd7z.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                ^\n                ;\n/tmp/tmpnp8czd7z.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpnp8czd7z.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpnp8czd7z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpnp8czd7z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn [Int]{1}\n\t}\n\tif n == 1 {\n\t\treturn [Int]{3}\n\t}\n\tif n % 2 == 0 {\n\t\treturn [Int]{1, 2, 3}\n\t}\n\treturn [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpl3m9lt91.swift:20:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:23:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{3}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:26:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1, 2, 3}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpl3m9lt91.swift:26:17: error: expected expression\n                return [Int]{1, 2, 3}\n                              ^\n/tmp/tmpl3m9lt91.swift:28:14: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpl3m9lt91.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpl3m9lt91.swift:28:16: error: expected expression\n        return [Int]{3, 1, 2, 3}\n                      ^\n/tmp/tmpl3m9lt91.swift:20:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmpl3m9lt91.swift:20:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmpl3m9lt91.swift:20:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmpl3m9lt91.swift:23:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{3}\n                       ^~~~~\n/tmp/tmpl3m9lt91.swift:23:15: error: closure expr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    result := []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i - 1] + result[i - 2] + result[i - 3])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp1uqervvv.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp1uqervvv.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp1uqervvv.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmp1uqervvv.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmp1uqervvv.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmp1uqervvv.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp1uqervvv.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp1uqervvv.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp1uqervvv.swift:32:11: error: consecutive statements on a line must be separated by ';'\n    result := []Int{1, 3}\n          ^\n          ;\n/tmp/tmp1uqervvv.swift:32:12: error: expected expression\n    result := []Int{1, 3}\n           ^\n/tmp/tmp1uqervvv.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp1uqervvv.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp1uqervvv.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp1uqervvv.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    \n    a := [Int]{}\n    a[0] = 1\n    a[1] = 3\n    \n    for i := 2; i <= n; i++ {\n        a[i] = a[i - 1] + a[i - 2] + a[i - 1]\n    }\n    \n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmphr3cy4rw.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmphr3cy4rw.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmphr3cy4rw.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmphr3cy4rw.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmphr3cy4rw.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmphr3cy4rw.swift:29:6: error: consecutive statements on a line must be separated by ';'\n    a := [Int]{}\n     ^\n     ;\n/tmp/tmphr3cy4rw.swift:29:7: error: expected expression\n    a := [Int]{}\n      ^\n/tmp/tmphr3cy4rw.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmphr3cy4rw.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmphr3cy4rw.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmphr3cy4rw.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmphr3cy4rw.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmphr3cy4rw.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmphr3cy4rw.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmphr3cy4rw.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmphr3cy4rw.swift:23:21: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 5, 13, 10}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp_gd2jor6.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp_gd2jor6.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp_gd2jor6.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp_gd2jor6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp_gd2jor6.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp_gd2jor6.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 13, 10}\n                ^\n                ;\n/tmp/tmp_gd2jor6.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 13, 10}\n                  ^\n                  ;\n/tmp/tmp_gd2jor6.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 13, 10}\n                  ^\n/tmp/tmp_gd2jor6.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp_gd2jor6.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp_gd2jor6.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp_gd2jor6.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp_gd2jor6.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp_gd2jor6.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp2f6a6khi.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp2f6a6khi.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp2f6a6khi.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp2f6a6khi.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp2f6a6khi.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp2f6a6khi.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp2f6a6khi.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp2f6a6khi.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp2f6a6khi.swift:26:16: error: cannot find 'append' in scope\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n               ^~~~~~\n/tmp/tmp2f6a6khi.swift:26:27: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n                          ^\n                          n: \n/tmp/tmp2f6a6khi.swift:26:35: error: cannot convert value of type 'Int' to expected argument type 'Array<Int>'\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n                                  ^\n/tmp/tmp2f6a6khi.swift:26:43: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n                                          ^\n                                          n: \n/tmp/tmp2f6a6khi.swift:26:56: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 1 + n / 2, 2}\n    }\n    return []Int{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpyp_cnlcl.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpyp_cnlcl.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpyp_cnlcl.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpyp_cnlcl.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpyp_cnlcl.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpyp_cnlcl.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 2}\n                 ^\n                 ;\n/tmp/tmpyp_cnlcl.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 2}\n                      ^\n                      ;\n/tmp/tmpyp_cnlcl.swift:29:23: error: expected expression\n        return []Int{1, 1 + n / 2, 2}\n                      ^\n/tmp/tmpyp_cnlcl.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n             ^\n             ;\n/tmp/tmpyp_cnlcl.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n                  ^\n                  ;\n/tmp/tmpyp_cnlcl.swift:31:19: error: expected expression\n    return []Int{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n                  ^\n/tmp/tmpyp_cnlcl.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedIntege",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 5}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5kd02xgx.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp5kd02xgx.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp5kd02xgx.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                ^\n                ;\n/tmp/tmp5kd02xgx.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                  ^\n                  ;\n/tmp/tmp5kd02xgx.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 5}\n                  ^\n/tmp/tmp5kd02xgx.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp5kd02xgx.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp5kd02xgx.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp5kd02xgx.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp5kd02",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    a := []Int{1, 3}\n    b := []Int{1, 1}\n    c := []Int{3, 2}\n    \n    for i := 2; i <= n; i++ {\n        a = append(a, b[0] + b[1])\n        b = append(b, c[0] + c[1])\n        c = append(c, a[0] + a[1])\n    }\n    \n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpcxxzxis9.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpcxxzxis9.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpcxxzxis9.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpcxxzxis9.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpcxxzxis9.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpcxxzxis9.swift:29:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 3}\n     ^\n     ;\n/tmp/tmpcxxzxis9.swift:29:7: error: expected expression\n    a := []Int{1, 3}\n      ^\n/tmp/tmpcxxzxis9.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpcxxzxis9.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpcxxzxis9.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpcxxzxis9.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1, 2, 3}\n    }\n    return [Int]{1, 1, 1, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4sdyt0u9.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp4sdyt0u9.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp4sdyt0u9.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp4sdyt0u9.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp4sdyt0u9.swift:26:23: error: expected expression\n        return [Int]{1, 1, 2, 3}\n                      ^\n/tmp/tmp4sdyt0u9.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp4sdyt0u9.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp4sdyt0u9.swift:28:19: error: expected expression\n    return [Int]{1, 1, 1, 1, 2, 3}\n                  ^\n/tmp/tmp4sdyt0u9.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp4sdyt0u9.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp4sdyt0u9.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp4sdyt0u9.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp4sdyt0u9.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp4sdyt0u9.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn [Int]{1}\n\t}\n\tif n == 1 {\n\t\treturn [Int]{3}\n\t}\n\tif n % 2 == 0 {\n\t\treturn [Int]{1, 2, 3}\n\t}\n\treturn [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpl3m9lt91.swift:20:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:23:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{3}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:26:15: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1, 2, 3}\n                            ^\n                            ;\n/tmp/tmpl3m9lt91.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return [Int]{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpl3m9lt91.swift:26:17: error: expected expression\n                return [Int]{1, 2, 3}\n                              ^\n/tmp/tmpl3m9lt91.swift:28:14: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpl3m9lt91.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpl3m9lt91.swift:28:16: error: expected expression\n        return [Int]{3, 1, 2, 3}\n                      ^\n/tmp/tmpl3m9lt91.swift:20:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{1}\n                       ^~~~~\n/tmp/tmpl3m9lt91.swift:20:15: error: closure expression is unused\n                return [Int]{1}\n                            ^\n/tmp/tmpl3m9lt91.swift:20:15: note: did you mean to use a 'do' statement?\n                return [Int]{1}\n                            ^\n                            do \n/tmp/tmpl3m9lt91.swift:23:10: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n                return [Int]{3}\n                       ^~~~~\n/tmp/tmpl3m9lt91.swift:23:15: error: closure expr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 2, 3}\n    }\n    return []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpw_ea8ytx.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpw_ea8ytx.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpw_ea8ytx.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpw_ea8ytx.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpw_ea8ytx.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpw_ea8ytx.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                 ^\n                 ;\n/tmp/tmpw_ea8ytx.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpw_ea8ytx.swift:29:23: error: expected expression\n        return []Int{1, 2, 3}\n                      ^\n/tmp/tmpw_ea8ytx.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n             ^\n             ;\n/tmp/tmpw_ea8ytx.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpw_ea8ytx.swift:31:19: error: expected expression\n    return []Int{1, 3, 2, 8}\n                  ^\n/tmp/tmpw_ea8ytx.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specifi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    } else {\n        return [Int]{1, 3, 5, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp66k1z08_.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp66k1z08_.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp66k1z08_.swift:24:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp66k1z08_.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp66k1z08_.swift:24:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp66k1z08_.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 5, 8}\n                    ^\n                    ;\n/tmp/tmp66k1z08_.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 5, 8}\n                      ^\n                      ;\n/tmp/tmp66k1z08_.swift:26:23: error: expected expression\n        return [Int]{1, 3, 5, 8}\n                      ^\n/tmp/tmp66k1z08_.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp66k1z08_.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp66k1z08_.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp66k1z08_.swift:22:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp66k1z08_.swift:22:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp66k1z08_.swift:22:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n == 2 {\n        return [Int]{2, 3}\n    }\n    if n == 3 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp2fn9dwfe.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp2fn9dwfe.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp2fn9dwfe.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmp2fn9dwfe.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmp2fn9dwfe.swift:29:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmp2fn9dwfe.swift:32:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp2fn9dwfe.swift:32:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp2fn9dwfe.swift:32:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp2fn9dwfe.swift:34:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmp2fn9dwfe.swift:34:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmp2fn9dwfe.swift:34:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmp2fn9dwfe.swift:20:9: error: cannot find 'panic' in scope\n        panic(\"n should be non-negative\")\n        ^~~~~\n/tmp/tmp2fn9dwfe.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp2fn9dwfe.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    return []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp1ip__6s1.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp1ip__6s1.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp1ip__6s1.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp1ip__6s1.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp1ip__6s1.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp1ip__6s1.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp1ip__6s1.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp1ip__6s1.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp1ip__6s1.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n             ^\n             ;\n/tmp/tmp1ip__6s1.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmp1ip__6s1.swift:31:19: error: expected expression\n    return []Int{1, 3, 2, 8}\n                  ^\n/tmp/tmp1ip__6s1.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requiremen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 2}\n    } else if n == 3 {\n        return []Int{1, 3, 2, 8}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpz44ojepr.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:24:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpz44ojepr.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpz44ojepr.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpz44ojepr.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpz44ojepr.swift:28:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpz44ojepr.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' confor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpbb5vse8h.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpbb5vse8h.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpbb5vse8h.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpbb5vse8h.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpbb5vse8h.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpbb5vse8h.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    \n    var result = []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i-1] + result[i-2] + result[i-1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpzm0fygry.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpzm0fygry.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpzm0fygry.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpzm0fygry.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpzm0fygry.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpzm0fygry.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                   ^\n                   ;\n/tmp/tmpzm0fygry.swift:29:25: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                        ^\n                        ;\n/tmp/tmpzm0fygry.swift:29:25: error: expected expression\n    var result = []Int{1, 3}\n                        ^\n/tmp/tmpzm0fygry.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpzm0fygry.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpzm0fygry.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpzm0fygry.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    if n == 2 {\n        return []int{1, 3}\n    }\n    \n    var a = []int{1, 3}\n    for i := 2; i <= n; i++ {\n        a = append(a, a[i-1] + a[i-2] + a[i-3])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpfguu8iuu.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []int{}\n                 ^\n                 ;\n/tmp/tmpfguu8iuu.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1}\n                 ^\n                 ;\n/tmp/tmpfguu8iuu.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                 ^\n                 ;\n/tmp/tmpfguu8iuu.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                      ^\n                      ;\n/tmp/tmpfguu8iuu.swift:26:23: error: expected expression\n        return []int{1, 3}\n                      ^\n/tmp/tmpfguu8iuu.swift:29:15: error: consecutive statements on a line must be separated by ';'\n    var a = []int{1, 3}\n              ^\n              ;\n/tmp/tmpfguu8iuu.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var a = []int{1, 3}\n                   ^\n                   ;\n/tmp/tmpfguu8iuu.swift:29:20: error: expected expression\n    var a = []int{1, 3}\n                   ^\n/tmp/tmpfguu8iuu.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpfguu8iuu.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpfguu8iuu.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpfguu8iuu.swift:20:18: error: cannot find 'int' in scope\n        return []int{}\n                 ^~~\n/tmp/tmpfguu8iuu.swift:23:18: error: cannot find 'int' in scope\n        return []int{1}\n                 ^~~\n/tmp/tmpfguu8iuu.swift:26:18: error: cannot find 'int' in scope\n        return []int{1, 3}\n                 ^~~\n/tmp/tmpfguu8iuu.swift:29:13: error: empty collection literal requires an explicit type\n    var a = []int{1, 3}\n            ^~\n/tmp/tmpfguu8iuu.swift:29:15: error: cannot find 'int' in scope\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 2, 3}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpd4kytjjg.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpd4kytjjg.swift:26:17: error: expected expression\n                return []Int{1, 2, 3}\n                              ^\n/tmp/tmpd4kytjjg.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpd4kytjjg.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpd4kytjjg.swift:28:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpd4kytjjg.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloating",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 2, 3}\n    }\n    return []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpegegqil3.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpegegqil3.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpegegqil3.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpegegqil3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpegegqil3.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpegegqil3.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                 ^\n                 ;\n/tmp/tmpegegqil3.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpegegqil3.swift:29:23: error: expected expression\n        return []Int{1, 2, 3}\n                      ^\n/tmp/tmpegegqil3.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n             ^\n             ;\n/tmp/tmpegegqil3.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpegegqil3.swift:31:19: error: expected expression\n    return []Int{1, 3, 2, 8}\n                  ^\n/tmp/tmpegegqil3.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specifi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    \n    result := []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i - 1] + result[i - 2] + result[i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp40iwk_iw.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp40iwk_iw.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp40iwk_iw.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmp40iwk_iw.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmp40iwk_iw.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmp40iwk_iw.swift:29:11: error: consecutive statements on a line must be separated by ';'\n    result := []Int{1, 3}\n          ^\n          ;\n/tmp/tmp40iwk_iw.swift:29:12: error: expected expression\n    result := []Int{1, 3}\n           ^\n/tmp/tmp40iwk_iw.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp40iwk_iw.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp40iwk_iw.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp40iwk_iw.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryF",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n % 2 == 0 {\n        return []Int{1, n / 2, tri(n - 2) + tri(n - 1) + tri(n + 1)}\n    } else {\n        return []Int{tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "/tmp/tmpii18tfb0.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpii18tfb0.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpii18tfb0.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, n / 2, tri(n - 2) + tri(n - 1) + tri(n + 1)}\n                 ^\n                 ;\n/tmp/tmpii18tfb0.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, n / 2, tri(n - 2) + tri(n - 1) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpii18tfb0.swift:26:23: error: expected expression\n        return []Int{1, n / 2, tri(n - 2) + tri(n - 1) + tri(n + 1)}\n                      ^\n/tmp/tmpii18tfb0.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                 ^\n                 ;\n/tmp/tmpii18tfb0.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp042_qyqr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp042_qyqr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp042_qyqr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                ^\n                ;\n/tmp/tmp042_qyqr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmp042_qyqr.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 8}\n                  ^\n/tmp/tmp042_qyqr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp042_qyqr.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp042_qyqr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp042_qyqr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp042_qyqr.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp042_qyqr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp042_q",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else if n == 3 {\n        return []Int{1, 3, 2, 8}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5jp4fuho.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp5jp4fuho.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:28:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' confor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    var result = []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i - 1] + result[i - 2] + result[i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp25xvhgm_.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp25xvhgm_.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp25xvhgm_.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                   ^\n                   ;\n/tmp/tmp25xvhgm_.swift:29:25: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                        ^\n                        ;\n/tmp/tmp25xvhgm_.swift:29:25: error: expected expression\n    var result = []Int{1, 3}\n                        ^\n/tmp/tmp25xvhgm_.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp25xvhgm_.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp25xvhgm_.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp25xvhgm_.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, 1}\n    }\n    return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpvj0r77tn.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpvj0r77tn.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpvj0r77tn.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, 1}\n                    ^\n                    ;\n/tmp/tmpvj0r77tn.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, 1}\n                      ^\n                      ;\n/tmp/tmpvj0r77tn.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, 1}\n                      ^\n/tmp/tmpvj0r77tn.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                ^\n                ;\n/tmp/tmpvj0r77tn.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn []int{}\n\t}\n\tif n == 1 {\n\t\treturn []int{1}\n\t}\n\tif n == 2 {\n\t\treturn []int{1, 2}\n\t}\n\tif n == 3 {\n\t\treturn []int{1, 3, 2, 8}\n\t}\n\tif n % 2 == 0 {\n\t\treturn append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n\t}\n\treturn append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpuup48ss_.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []int{}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 2}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 2}\n                              ^\n                              ;\n/tmp/tmpuup48ss_.swift:26:17: error: expected expression\n                return []int{1, 2}\n                              ^\n/tmp/tmpuup48ss_.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:29:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmpuup48ss_.swift:29:17: error: expected expression\n                return []int{1, 3, 2, 8}\n                              ^\n/tmp/tmpuup48ss_.swift:20:12: error: cannot find 'int' in scope\n                return []int{}\n                         ^~~\n/tmp/tmpuup48ss_.swift:23:12: error: cannot find 'int' in scope\n                return []int{1}\n                         ^~~\n/tmp/tmpuup48ss_.swift:26:12: error: cannot find 'int' in scope\n                return []int{1, 2}\n                         ^~~\n/tmp/tmpuup48ss_.swift:29:12: error: cannot find 'int' in scope\n                return []int{1, 3, 2, 8}\n                         ^~~\n/tmp/tmpuup48ss_.swift:32:10: error: cannot find 'append' in scope\n                return append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp0_tg4tep.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp0_tg4tep.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp0_tg4tep.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n == 3 {\n        return [Int]{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "/tmp/tmp2rifskrt.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp2rifskrt.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp2rifskrt.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmp2rifskrt.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmp2rifskrt.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmp2rifskrt.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp2rifskrt.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp2rifskrt.swift:29:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp2rifskrt.swift:32:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp2rifskrt.swift:32:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp2rifskrt.swift:32:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp2rifskrt.swift:34:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                ^\n                ;\n/tmp/tmp2rifskrt.swift:34:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2))\n    } else {\n        return append(tri(n - 1), tri(n - 2), 1 + tri(n - 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4p33ph4z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp4p33ph4z.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp4p33ph4z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp4p33ph4z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp4p33ph4z.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp4p33ph4z.swift:22:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp4p33ph4z.swift:22:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp4p33ph4z.swift:22:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp4p33ph4z.swift:24:16: error: cannot find 'append' in scope\n        return append(tri(n - 1), 1 + tri(n - 2))\n               ^~~~~~\n/tmp/tmp4p33ph4z.swift:24:37: error: binary operator '+' cannot be applied to operands of type 'Int' and '[Int]'\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                  ~ ^ ~~~~~~~~~~\n/tmp/tmp4p33ph4z.swift:24:37: note: overloads for '+' exist with these partially matching parameter lists: (Int, Int)\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                    ^\n/tmp/tmp4p33ph4z.swift:24:27: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2))\n                          ^\n                          n: \n/tmp/tmp4p33ph4z.swift:24:43: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    \n    var a = [Int]{}\n    a[0] = 1\n    a[1] = 3\n    if n % 2 == 0 {\n        for i := 2; i < n; i += 2 {\n            a[i] = a[i - 1] + a[i - 2] + a[i + 1]\n        }\n    } else {\n        for i := 2; i < n; i += 2 {\n            a[i] = a[i - 1] + a[i - 2] + a[i + 1]\n        }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmppm5z_nev.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmppm5z_nev.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmppm5z_nev.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmppm5z_nev.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmppm5z_nev.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmppm5z_nev.swift:29:18: error: unexpected '{' in declaration\n    var a = [Int]{}\n                 ^\n/tmp/tmppm5z_nev.swift:33:16: error: expected type\n        for i := 2; i < n; i += 2 {\n               ^\n                <#type#>\n/tmp/tmppm5z_nev.swift:33:16: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i += 2 {\n               ^\n/tmp/tmppm5z_nev.swift:33:16: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i += 2 {\n               ^\n/tmp/tmppm5z_nev.swift:37:16: error: expected type\n        for i := 2; i < n; i += 2 {\n               ^\n                <#type#>\n/tmp/tmppm5z_nev.swift:37:16: error: expected 'in' after for-each pattern\n        for i := 2; i < n; i += 2 {\n               ^\n/tmp/tmppm5z_nev.swift:37:16: error: expected Sequence expression for for-each loop\n        for i := 2; i < n; i += 2 {\n               ^\n/tmp/tmppm5z_nev.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmppm5z_nev.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmppm5z_nev.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 5}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp5kd02xgx.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp5kd02xgx.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp5kd02xgx.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp5kd02xgx.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                ^\n                ;\n/tmp/tmp5kd02xgx.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 5}\n                  ^\n                  ;\n/tmp/tmp5kd02xgx.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 5}\n                  ^\n/tmp/tmp5kd02xgx.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp5kd02xgx.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp5kd02xgx.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp5kd02xgx.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp5kd02xgx.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp5kd02",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    } else {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpqpwibe7j.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpqpwibe7j.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpqpwibe7j.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpqpwibe7j.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpqpwibe7j.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpqpwibe7j.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpqpwibe7j.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpqpwibe7j.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpqpwibe7j.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp2qj1n9_f.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp2qj1n9_f.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp2qj1n9_f.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp2qj1n9_f.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp2qj1n9_f.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp2qj1n9_f.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                ^\n                ;\n/tmp/tmp2qj1n9_f.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmp2qj1n9_f.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 8}\n                  ^\n/tmp/tmp2qj1n9_f.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmph862zqhd.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmph862zqhd.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmph862zqhd.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmph862zqhd.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmph862zqhd.swift:29:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmph862zqhd.swift:20:9: error: cannot find 'panic' in scope\n        panic(\"n should be non-negative\")\n        ^~~~~\n/tmp/tmph862zqhd.swift:23:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requireme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    } else {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpi701cs2a.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpi701cs2a.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpi701cs2a.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpi701cs2a.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpi701cs2a.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpi701cs2a.swift:22:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpi701cs2a.swift:22:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpi701cs2a.swift:22:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpi701cs2a.swift:24:16: error: cannot find 'append' in scope\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n               ^~~~~~\n/tmp/tmpi701cs2a.swift:24:27: error: missing argument label 'n:' in call\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n                          ^\n                          n: \n/tmp/tmpi701cs2a.swift:24:39: error: missing argument label 'n:' in call\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n                                      ^\n                                      n: \n/tmp/tmpi701cs2a.swift:24:51: error: missing argument label 'n:' in call\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n                                                  ^\n                                                  n: \n/tmp/tmpi701cs2a.swift:26:16: error: cannot find 'append' in scope\n        return append(tri(n - 1), tri(n - 2",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    if n == 2 {\n        return []int{1, 2}\n    }\n    if n == 3 {\n        return []int{1, 3, 2, 8}\n    }\n    \n    var a = []int{1, 3, 2, 8}\n    for i := 4; i <= n; i++ {\n        a = append(a, a[i-1] + a[i-2] + a[i-3])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpux4t9fod.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []int{}\n                 ^\n                 ;\n/tmp/tmpux4t9fod.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1}\n                 ^\n                 ;\n/tmp/tmpux4t9fod.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 2}\n                 ^\n                 ;\n/tmp/tmpux4t9fod.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 2}\n                      ^\n                      ;\n/tmp/tmpux4t9fod.swift:26:23: error: expected expression\n        return []int{1, 2}\n                      ^\n/tmp/tmpux4t9fod.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpux4t9fod.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpux4t9fod.swift:29:23: error: expected expression\n        return []int{1, 3, 2, 8}\n                      ^\n/tmp/tmpux4t9fod.swift:32:15: error: consecutive statements on a line must be separated by ';'\n    var a = []int{1, 3, 2, 8}\n              ^\n              ;\n/tmp/tmpux4t9fod.swift:32:20: error: consecutive statements on a line must be separated by ';'\n    var a = []int{1, 3, 2, 8}\n                   ^\n                   ;\n/tmp/tmpux4t9fod.swift:32:20: error: expected expression\n    var a = []int{1, 3, 2, 8}\n                   ^\n/tmp/tmpux4t9fod.swift:33:12: error: expected type\n    for i := 4; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpux4t9fod.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 4; i <= n; i++ {\n           ^\n/tmp/tmpux4t9fod.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 4; i <= n; i++ {\n           ^\n/tmp/tmpux4t9fod.swift:20:18: error: cannot find '",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 3, 2, 8}\n    }\n    return []Int{1, 2, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpgy_w_hi7.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpgy_w_hi7.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpgy_w_hi7.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpgy_w_hi7.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpgy_w_hi7.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpgy_w_hi7.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpgy_w_hi7.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpgy_w_hi7.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpgy_w_hi7.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 2, 3, 5, 8}\n             ^\n             ;\n/tmp/tmpgy_w_hi7.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 2, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmpgy_w_hi7.swift:31:19: error: expected expression\n    return []Int{1, 2, 3, 5, 8}\n                  ^\n/tmp/tmpgy_w_hi7.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2) + tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp6h6zygrn.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp6h6zygrn.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp6h6zygrn.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmp6h6zygrn.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmp6h6zygrn.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmp6h6zygrn.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 2, 3}\n    }\n    return []Int{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpmbkmqtpd.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpmbkmqtpd.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpmbkmqtpd.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpmbkmqtpd.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpmbkmqtpd.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpmbkmqtpd.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                 ^\n                 ;\n/tmp/tmpmbkmqtpd.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpmbkmqtpd.swift:29:23: error: expected expression\n        return []Int{1, 2, 3}\n                      ^\n/tmp/tmpmbkmqtpd.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 5, 8}\n             ^\n             ;\n/tmp/tmpmbkmqtpd.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmpmbkmqtpd.swift:31:19: error: expected expression\n    return []Int{1, 3, 5, 8}\n                  ^\n/tmp/tmpmbkmqtpd.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specifi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    if n % 2 == 0 {\n        return []Int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmph9k1e6gl.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmph9k1e6gl.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmph9k1e6gl.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmph9k1e6gl.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmph9k1e6gl.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmph9k1e6gl.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmph9k1e6gl.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmph9k1e6gl.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmph9k1e6gl.swift:33:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n                 ^\n                 ;\n/tmp/tmph9k1e6gl.swift:33:23: error: consecutive statements o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2)}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmphw466se2.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmphw466se2.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmphw466se2.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmphw466se2.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmphw466se2.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmphw466se2.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2)}\n                ^\n                ;\n/tmp/tmphw466se2.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2)}\n                  ^\n                  ;\n/tmp/tmphw466se2.swift:28:19: error: expected expression\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2)}\n                  ^\n/tmp/tmphw466se2.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmphw466se2.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmphw466se2.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmphw466se2.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmphw466se2.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmphw466se2.swift:23:21: note: did you mean to use a 'do' statement?\n        ret",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n <= 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpy96m2uem.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpy96m2uem.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpy96m2uem.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpy96m2uem.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpy96m2uem.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpy96m2uem.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n == 2 {\n        return [Int]{1, 3}\n    } else if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    } else {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmptvyuc4ox.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmptvyuc4ox.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmptvyuc4ox.swift:24:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmptvyuc4ox.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmptvyuc4ox.swift:24:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmptvyuc4ox.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmptvyuc4ox.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmptvyuc4ox.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmptvyuc4ox.swift:22:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmptvyuc4ox.swift:22:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmptvyuc4ox.swift:22:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmptvyuc4ox.swift:24:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1, 3}\n               ^~~~~\n/tmp/tmptvyuc4ox.swift:24:21: error: closure expression is unused\n        return [Int]{1, 3}\n                    ^\n/tmp/tmptvyuc4ox.swift:24:21: note: did you mean to use a 'do' statement?\n        return [Int]{1, 3}\n                    ^\n                    do \n/tmp/tmptvyuc4ox.swift:26:16",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 0 {\n\t\tpanic(\"n should be non-negative\")\n\t}\n\tif n == 0 {\n\t\treturn []Int{1}\n\t}\n\tif n == 1 {\n\t\treturn []Int{3}\n\t}\n\tif n == 2 {\n\t\treturn []Int{2}\n\t}\n\tif n == 3 {\n\t\treturn []Int{3}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 2, 3}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpxwoqdct_.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpxwoqdct_.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{3}\n                         ^\n                         ;\n/tmp/tmpxwoqdct_.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{2}\n                         ^\n                         ;\n/tmp/tmpxwoqdct_.swift:32:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{3}\n                         ^\n                         ;\n/tmp/tmpxwoqdct_.swift:35:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                         ^\n                         ;\n/tmp/tmpxwoqdct_.swift:35:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpxwoqdct_.swift:35:17: error: expected expression\n                return []Int{1, 2, 3}\n                              ^\n/tmp/tmpxwoqdct_.swift:37:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpxwoqdct_.swift:37:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpxwoqdct_.swift:37:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpxwoqdct_.swift:20:3: error: cannot find 'panic' in scope\n                panic(\"n should be non-negative\")\n                ^~~~~\n/tmp/tmpxwoqdct_.swift:23:12: error: no exact matches in call to initializer \n                return []Int{1}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> Int' conform to 'CodingKey' (r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp3nxi655f.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp3nxi655f.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp3nxi655f.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                ^\n                ;\n/tmp/tmp3nxi655f.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmp3nxi655f.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 8}\n                  ^\n/tmp/tmp3nxi655f.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp3nxi655f.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp3nxi655f.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp3nxi655f.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3nxi655f.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3nxi655f.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, 1}\n    }\n    return [Int]{1, 1, 1, 1, n, n + 1, n + 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpha0ahbyb.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpha0ahbyb.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpha0ahbyb.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, 1}\n                    ^\n                    ;\n/tmp/tmpha0ahbyb.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, 1}\n                      ^\n                      ;\n/tmp/tmpha0ahbyb.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, 1}\n                      ^\n/tmp/tmpha0ahbyb.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, n, n + 1, n + 2}\n                ^\n                ;\n/tmp/tmpha0ahbyb.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1, 1, 1, n, n + 1, n + 2}\n                  ^\n                  ;\n/tmp/tmpha0ahbyb.swift:28:19: error: expected expression\n    return [Int]{1, 1, 1, 1, n, n + 1, n + 2}\n                  ^\n/tmp/tmpha0ahbyb.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpha0ahbyb.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpha0ahbyb.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpha0ahbyb.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpha0ahbyb.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpha0ahbyb.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 0 {\n\t\tpanic(\"n should be non-negative\")\n\t}\n\tif n == 0 {\n\t\treturn []Int{1}\n\t}\n\tif n == 1 {\n\t\treturn []Int{3}\n\t}\n\tif n == 2 {\n\t\treturn []Int{2}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmptctwkwcl.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{3}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{2}\n                         ^\n                         ;\n/tmp/tmptctwkwcl.swift:31:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmptctwkwcl.swift:31:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmptctwkwcl.swift:31:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmptctwkwcl.swift:20:3: error: cannot find 'panic' in scope\n                panic(\"n should be non-negative\")\n                ^~~~~\n/tmp/tmptctwkwcl.swift:23:12: error: no exact matches in call to initializer \n                return []Int{1}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> Int' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> Int' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> Int' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> Int' conf",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    a := []Int{1, 1}\n    b := []Int{1, 1}\n    for i := 2; i <= n; i++ {\n        a = append(a, 1 + (i / 2))\n        b = append(b, 1 + (i / 2))\n        b = append(b, 1 + (i / 2))\n        a = append(a, b[i - 2] + b[i - 1] + b[i])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpppifwslp.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpppifwslp.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpppifwslp.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpppifwslp.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpppifwslp.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpppifwslp.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpppifwslp.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpppifwslp.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpppifwslp.swift:32:6: error: consecutive statements on a line must be separated by ';'\n    a := []Int{1, 1}\n     ^\n     ;\n/tmp/tmpppifwslp.swift:32:7: error: expected expression\n    a := []Int{1, 1}\n      ^\n/tmp/tmpppifwslp.swift:34:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpppifwslp.swift:34:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpppifwslp.swift:34:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpppifwslp.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(cod",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 3, 2, 8}\n\t}\n\treturn []Int{1, 3, 2, 8, 1, 5, 3, 2, 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmppkofox1y.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmppkofox1y.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmppkofox1y.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmppkofox1y.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmppkofox1y.swift:26:17: error: expected expression\n                return []Int{1, 3, 2, 8}\n                              ^\n/tmp/tmppkofox1y.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8, 1, 5, 3, 2, 1}\n                 ^\n                 ;\n/tmp/tmppkofox1y.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8, 1, 5, 3, 2, 1}\n                      ^\n                      ;\n/tmp/tmppkofox1y.swift:28:16: error: expected expression\n        return []Int{1, 3, 2, 8, 1, 5, 3, 2, 1}\n                      ^\n/tmp/tmppkofox1y.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloating",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpeqx_7ybg.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpeqx_7ybg.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpeqx_7ybg.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpeqx_7ybg.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpeqx_7ybg.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpeqx_7ybg.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpeqx_7ybg.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpeqx_7ybg.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpeqx_7ybg.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpeqx_7ybg.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpdbm66tsg.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpdbm66tsg.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpdbm66tsg.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpdbm66tsg.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpdbm66tsg.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpdbm66tsg.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpdbm66tsg.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpdbm66tsg.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpdbm66tsg.swift:32:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n             ^\n             ;\n/tmp/tmpdbm66tsg.swift:32:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n                  ^\n                  ;\n/tmp/tmpdbm66tsg.swift:32:19: error: expected expression\n    return []Int{1, 1 + n / 2, 1 + (n - 1) / 2, 1 + (n - 2) / 2 + 1 + (n - 1) / 2}\n                  ^\n/tmp/tmpdbm66tsg.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 1, 2, 3}\n\t}\n\treturn []Int{1, 1, 2, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpj815mcm7.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmpj815mcm7.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpj815mcm7.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 1, 2, 3}\n                         ^\n                         ;\n/tmp/tmpj815mcm7.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpj815mcm7.swift:26:17: error: expected expression\n                return []Int{1, 1, 2, 3}\n                              ^\n/tmp/tmpj815mcm7.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1, 2, 3, 5, 8}\n                 ^\n                 ;\n/tmp/tmpj815mcm7.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1, 2, 3, 5, 8}\n                      ^\n                      ;\n/tmp/tmpj815mcm7.swift:28:16: error: expected expression\n        return []Int{1, 1, 2, 3, 5, 8}\n                      ^\n/tmp/tmpj815mcm7.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specifi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    var result = []Int{}\n    result = append(result, 1)\n    result = append(result, 3)\n    result = append(result, 2)\n    \n    if n % 2 == 0 {\n        result = append(result, tri(n - 1) + tri(n - 2) + tri(n + 1))\n    } else {\n        result = append(result, tri(n - 1) + tri(n - 2) + tri(n + 1))\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpkf0al0e6.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpkf0al0e6.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpkf0al0e6.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpkf0al0e6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpkf0al0e6.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpkf0al0e6.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{}\n                   ^\n                   ;\n/tmp/tmpkf0al0e6.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n == 2 {\n        return [Int]{2, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpfprjg66l.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfprjg66l.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmpfprjg66l.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmpfprjg66l.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmpfprjg66l.swift:26:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmpfprjg66l.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpfprjg66l.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpfprjg66l.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpfprjg66l.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpfprjg66l.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpfprjg66l.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpfprjg66l.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpfprjg66l.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpfprjg66l.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1, tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpoyip9wwn.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpoyip9wwn.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpoyip9wwn.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp0_tg4tep.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp0_tg4tep.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp0_tg4tep.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp0_tg4tep.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp0_tg4tep.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpeqx_7ybg.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpeqx_7ybg.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpeqx_7ybg.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpeqx_7ybg.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpeqx_7ybg.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpeqx_7ybg.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpeqx_7ybg.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpeqx_7ybg.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpeqx_7ybg.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpeqx_7ybg.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpeqx_7ybg.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n == 2 {\n        return [Int]{2, 3}\n    }\n    if n == 3 {\n        return [Int]{1, 3, 2, 8}\n    }\n    if n == 4 {\n        return [Int]{3, 1, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp3usr0n84.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3usr0n84.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3usr0n84.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmp3usr0n84.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmp3usr0n84.swift:29:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmp3usr0n84.swift:32:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp3usr0n84.swift:32:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp3usr0n84.swift:32:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp3usr0n84.swift:35:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 8}\n                    ^\n                    ;\n/tmp/tmp3usr0n84.swift:35:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3, 1, 2, 8}\n                      ^\n                      ;\n/tmp/tmp3usr0n84.swift:35:23: error: expected expression\n        return [Int]{3, 1, 2, 8}\n                      ^\n/tmp/tmp3usr0n84.swift:37:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmp3usr0n84.swift:37:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmp3usr0n84.swift:37:19: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    \n    var result = [Int]{}\n    result[0] = 1\n    result[1] = 3\n    \n    for i := 2; i <= n; i++ {\n        if i % 2 == 0 {\n            result[i] = result[i - 1] + result[i - 2]\n        } else {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1]\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpkra67oou.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpkra67oou.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpkra67oou.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpkra67oou.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpkra67oou.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpkra67oou.swift:29:23: error: unexpected '{' in declaration\n    var result = [Int]{}\n                      ^\n/tmp/tmpkra67oou.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpkra67oou.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpkra67oou.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpkra67oou.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpkra67oou.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpkra67oou.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpkra67oou.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpkra67oou.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpkra67oou.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpapgzqrf0.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpapgzqrf0.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpapgzqrf0.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpapgzqrf0.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpapgzqrf0.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpapgzqrf0.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpapgzqrf0.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpapgzqrf0.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpapgzqrf0.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 2, 3}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpd4kytjjg.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpd4kytjjg.swift:26:17: error: expected expression\n                return []Int{1, 2, 3}\n                              ^\n/tmp/tmpd4kytjjg.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpd4kytjjg.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpd4kytjjg.swift:28:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpd4kytjjg.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloating",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + (n / 2), 2}\n    }\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp7mcdteju.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp7mcdteju.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp7mcdteju.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmp7mcdteju.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmp7mcdteju.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmp7mcdteju.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + (n / 2), 2}\n                    ^\n                    ;\n/tmp/tmp7mcdteju.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + (n / 2), 2}\n                      ^\n                      ;\n/tmp/tmp7mcdteju.swift:29:23: error: expected expression\n        return [Int]{1, 1 + (n / 2), 2}\n                      ^\n/tmp/tmp7mcdteju.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                ^\n                ;\n/tmp/tmp7mcdteju.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                  ^\n                  ;\n/tmp/tmp7mcdteju.swift:31:19: error: expected expression\n    return [Int]{1, 1 + (n / 2), 1 + (n / 2) + (n / 2), 2}\n                  ^\n/tmp/tmp7mcdteju.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp7mcdteju.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1, tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpoyip9wwn.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpoyip9wwn.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpoyip9wwn.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpoyip9wwn.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2}\n    }\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpt4i7vo5l.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2}\n                    ^\n                    ;\n/tmp/tmpt4i7vo5l.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2}\n                      ^\n                      ;\n/tmp/tmpt4i7vo5l.swift:26:23: error: expected expression\n        return [Int]{1, n / 2}\n                      ^\n/tmp/tmpt4i7vo5l.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                ^\n                ;\n/tmp/tmpt4i7vo5l.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                  ^\n                  ;\n/tmp/tmpt4i7vo5l.swift:28:19: error: expected expression\n    return [Int]{1, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                  ^\n/tmp/tmpt4i7vo5l.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpt4i7vo5l.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpt4i7vo5l.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpt4i7vo5l.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpt4i7vo5l.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpt4i7vo5l.swift:23:21: note: did you mean to use a 'do' stat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn []int{}\n\t}\n\tif n == 1 {\n\t\treturn []int{1}\n\t}\n\tif n == 2 {\n\t\treturn []int{1, 3}\n\t}\n\tif n == 3 {\n\t\treturn []int{1, 3, 2, 8}\n\t}\n\tif n % 2 == 0 {\n\t\treturn append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n\t}\n\treturn append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpyloe5lmi.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []int{}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3}\n                              ^\n                              ;\n/tmp/tmpyloe5lmi.swift:26:17: error: expected expression\n                return []int{1, 3}\n                              ^\n/tmp/tmpyloe5lmi.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmpyloe5lmi.swift:29:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmpyloe5lmi.swift:29:17: error: expected expression\n                return []int{1, 3, 2, 8}\n                              ^\n/tmp/tmpyloe5lmi.swift:20:12: error: cannot find 'int' in scope\n                return []int{}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:23:12: error: cannot find 'int' in scope\n                return []int{1}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:26:12: error: cannot find 'int' in scope\n                return []int{1, 3}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:29:12: error: cannot find 'int' in scope\n                return []int{1, 3, 2, 8}\n                         ^~~\n/tmp/tmpyloe5lmi.swift:32:10: error: cannot find 'append' in scope\n                return append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmprch4fi10.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmprch4fi10.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmprch4fi10.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmprch4fi10.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmprch4fi10.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmprch4fi10.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmprch4fi10.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmprch4fi10.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n == 2 {\n        return [Int]{1, 3}\n    } else if n == 3 {\n        return [Int]{1, 3, 2, 8}\n    } else {\n        return [Int]{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp0x9278ig.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp0x9278ig.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp0x9278ig.swift:24:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmp0x9278ig.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmp0x9278ig.swift:24:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmp0x9278ig.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp0x9278ig.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp0x9278ig.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp0x9278ig.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp0x9278ig.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp0x9278ig.swift:28:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp0x9278ig.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp0x9278ig.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp0x9278ig.swift:20:21: note: did you mean to use a 'do' statement?\n        retu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n    } else {\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpfvk1r_c3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n                      ;\n/tmp/tmpfvk1r_c3.swift:26:23: error: expected expression\n        return [Int]{1, n / 2, tri(n - 1) + tri(n - 2) + tri(n + 1)}\n                      ^\n/tmp/tmpfvk1r_c3.swift:28:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                    ^\n                    ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: consecutive statements on a line must be separated by ';'\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n                                                         ;\n/tmp/tmpfvk1r_c3.swift:28:58: error: expected expression\n        return [Int]{tri(n - 1) + tri(n - 2) + tri(n + 1), 1, n / 2}\n                                                         ^\n/tmp/tmpfvk1r_c3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpfvk1r_c3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpfvk1r_c3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpfvk1r_c3.swift:23:16: error: cannot convert return express",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 1 + n / 2, 1 + n / 2}\n    }\n    return []Int{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpwsr1v_pc.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpwsr1v_pc.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpwsr1v_pc.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpwsr1v_pc.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpwsr1v_pc.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpwsr1v_pc.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 1 + n / 2}\n                 ^\n                 ;\n/tmp/tmpwsr1v_pc.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpwsr1v_pc.swift:29:23: error: expected expression\n        return []Int{1, 1 + n / 2, 1 + n / 2}\n                      ^\n/tmp/tmpwsr1v_pc.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n             ^\n             ;\n/tmp/tmpwsr1v_pc.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpwsr1v_pc.swift:31:19: error: expected expression\n    return []Int{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpwsr1v_pc.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : Codin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "/tmp/tmpx_fl5ng3.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpx_fl5ng3.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpx_fl5ng3.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmpx_fl5ng3.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpx_fl5ng3.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmpx_fl5ng3.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                ^\n                ;\n/tmp/tmpx_fl5ng3.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                  ^\n                  ;\n/tmp/tmpx_fl5ng3.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8} + tri(n - 1) + tri(n - 2) + tri(n + 1)\n                  ^\n/tmp/tmpx_fl5ng3.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpx_fl5ng3.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpx_fl5ng3.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpx_fl5ng3.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpx_fl5ng3.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpx_fl5ng3.swift:23:21: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{1}\n    }\n    if n == 2 {\n        return []int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []int{1, 2, 3}\n    }\n    return []int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp8s8zm1uc.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []int{}\n                 ^\n                 ;\n/tmp/tmp8s8zm1uc.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1}\n                 ^\n                 ;\n/tmp/tmp8s8zm1uc.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                 ^\n                 ;\n/tmp/tmp8s8zm1uc.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 3}\n                      ^\n                      ;\n/tmp/tmp8s8zm1uc.swift:26:23: error: expected expression\n        return []int{1, 3}\n                      ^\n/tmp/tmp8s8zm1uc.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 2, 3}\n                 ^\n                 ;\n/tmp/tmp8s8zm1uc.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []int{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp8s8zm1uc.swift:29:23: error: expected expression\n        return []int{1, 2, 3}\n                      ^\n/tmp/tmp8s8zm1uc.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []int{1, 3, 2, 8}\n             ^\n             ;\n/tmp/tmp8s8zm1uc.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []int{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmp8s8zm1uc.swift:31:19: error: expected expression\n    return []int{1, 3, 2, 8}\n                  ^\n/tmp/tmp8s8zm1uc.swift:20:18: error: cannot find 'int' in scope\n        return []int{}\n                 ^~~\n/tmp/tmp8s8zm1uc.swift:23:18: error: cannot find 'int' in scope\n        return []int{1}\n                 ^~~\n/tmp/tmp8s8zm1uc.swift:26:18: error: cannot find 'int' in scope\n        return []int{1, 3}\n                 ^~~\n/tmp/tmp8s8zm1uc.swift:29:18: error: cannot find 'int' in scope\n        return []int{1, 2, 3}\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    var a = []Int{1, 1}\n    for i := 2; i <= n; i++ {\n        a = append(a, 1 + a[i - 1] + a[i - 2])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpgtwasffa.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpgtwasffa.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpgtwasffa.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpgtwasffa.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpgtwasffa.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpgtwasffa.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpgtwasffa.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpgtwasffa.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpgtwasffa.swift:32:15: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 1}\n              ^\n              ;\n/tmp/tmpgtwasffa.swift:32:20: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 1}\n                   ^\n                   ;\n/tmp/tmpgtwasffa.swift:32:20: error: expected expression\n    var a = []Int{1, 1}\n                   ^\n/tmp/tmpgtwasffa.swift:33:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpgtwasffa.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpgtwasffa.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpgtwasffa.swift:20:18: error: no exact matches in call to ini",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2, 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpe0jbmci6.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpe0jbmci6.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpe0jbmci6.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpe0jbmci6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpe0jbmci6.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpe0jbmci6.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 2}\n                    ^\n                    ;\n/tmp/tmpe0jbmci6.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 2}\n                      ^\n                      ;\n/tmp/tmpe0jbmci6.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2, 2}\n                      ^\n/tmp/tmpe0jbmci6.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n                ^\n                ;\n/tmp/tmpe0jbmci6.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n                  ^\n                  ;\n/tmp/tmpe0jbmci6.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 3}\n                  ^\n/tmp/tmpe0jbmci6.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpe0jbmci6.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpe0jbmci6.swift:20:21: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 6}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp1lafs_12.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp1lafs_12.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp1lafs_12.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp1lafs_12.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp1lafs_12.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp1lafs_12.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 6}\n                ^\n                ;\n/tmp/tmp1lafs_12.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 6}\n                  ^\n                  ;\n/tmp/tmp1lafs_12.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 6}\n                  ^\n/tmp/tmp1lafs_12.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp1lafs_12.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp1lafs_12.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp1lafs_12.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp1lafs_12.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp1lafs_12.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return []Int{1}\n    }\n    if n == 1 {\n        return []Int{3}\n    }\n    if n == 2 {\n        return []Int{2}\n    }\n    if n == 3 {\n        return []Int{8}\n    }\n    \n    result := []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i-1] + result[i-2] + result[i-3])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpce41v87n.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpce41v87n.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{3}\n                 ^\n                 ;\n/tmp/tmpce41v87n.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{2}\n                 ^\n                 ;\n/tmp/tmpce41v87n.swift:32:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{8}\n                 ^\n                 ;\n/tmp/tmpce41v87n.swift:35:11: error: consecutive statements on a line must be separated by ';'\n    result := []Int{1, 3}\n          ^\n          ;\n/tmp/tmpce41v87n.swift:35:12: error: expected expression\n    result := []Int{1, 3}\n           ^\n/tmp/tmpce41v87n.swift:36:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmpce41v87n.swift:36:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpce41v87n.swift:36:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmpce41v87n.swift:20:9: error: cannot find 'panic' in scope\n        panic(\"n should be non-negative\")\n        ^~~~~\n/tmp/tmpce41v87n.swift:23:18: error: no exact matches in call to initializer \n        return []Int{1}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> Int' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> Int' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> Int' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'Binar",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp8hk_467d.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp8hk_467d.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp8hk_467d.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                    ^\n                    ;\n/tmp/tmp8hk_467d.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                      ^\n                      ;\n/tmp/tmp8hk_467d.sw",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2))\n    }\n    return append(tri(n - 1), tri(n - 2), 1 + tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp7i_imhr9.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp7i_imhr9.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp7i_imhr9.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:6:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(truncatingIfNeeded source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:5:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'Other' : 'BinaryInteger')\n    @inlinable pu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpmly6_kk6.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpmly6_kk6.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpmly6_kk6.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpmly6_kk6.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpmly6_kk6.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    \n    var result = []Int{1, 3}\n    for i := 2; i <= n; i++ {\n        result = append(result, result[i - 1] + result[i - 2] + result[i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp25xvhgm_.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp25xvhgm_.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp25xvhgm_.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp25xvhgm_.swift:29:20: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                   ^\n                   ;\n/tmp/tmp25xvhgm_.swift:29:25: error: consecutive statements on a line must be separated by ';'\n    var result = []Int{1, 3}\n                        ^\n                        ;\n/tmp/tmp25xvhgm_.swift:29:25: error: expected expression\n    var result = []Int{1, 3}\n                        ^\n/tmp/tmp25xvhgm_.swift:30:12: error: expected type\n    for i := 2; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmp25xvhgm_.swift:30:12: error: expected 'in' after for-each pattern\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp25xvhgm_.swift:30:12: error: expected Sequence expression for for-each loop\n    for i := 2; i <= n; i++ {\n           ^\n/tmp/tmp25xvhgm_.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n < 1 {\n\t\treturn []Int{}\n\t}\n\tif n == 1 {\n\t\treturn []Int{1}\n\t}\n\tif n % 2 == 0 {\n\t\treturn []Int{1, 2, 3}\n\t}\n\treturn []Int{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpd4kytjjg.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                         ^\n                         ;\n/tmp/tmpd4kytjjg.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []Int{1, 2, 3}\n                              ^\n                              ;\n/tmp/tmpd4kytjjg.swift:26:17: error: expected expression\n                return []Int{1, 2, 3}\n                              ^\n/tmp/tmpd4kytjjg.swift:28:11: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpd4kytjjg.swift:28:16: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpd4kytjjg.swift:28:16: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpd4kytjjg.swift:20:12: error: no exact matches in call to initializer \n                return []Int{}\n                         ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloating",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp042_qyqr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp042_qyqr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp042_qyqr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp042_qyqr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                ^\n                ;\n/tmp/tmp042_qyqr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmp042_qyqr.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 8}\n                  ^\n/tmp/tmp042_qyqr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp042_qyqr.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp042_qyqr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp042_qyqr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp042_qyqr.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp042_qyqr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp042_q",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), 1, tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpkka6pn6y.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpkka6pn6y.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpkka6pn6y.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpkka6pn6y.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpkka6pn6y.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpkka6pn6y.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpkka6pn6y.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpkka6pn6y.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpkka6pn6y.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    } else if n == 1 {\n        return [Int]{1}\n    } else if n % 2 == 0 {\n        return append(tri(n - 1), 1 + tri(n - 2))\n    } else {\n        return append(tri(n - 1), tri(n - 2), 1 + tri(n - 1))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp4p33ph4z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp4p33ph4z.swift:22:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp4p33ph4z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp4p33ph4z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp4p33ph4z.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp4p33ph4z.swift:22:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp4p33ph4z.swift:22:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp4p33ph4z.swift:22:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp4p33ph4z.swift:24:16: error: cannot find 'append' in scope\n        return append(tri(n - 1), 1 + tri(n - 2))\n               ^~~~~~\n/tmp/tmp4p33ph4z.swift:24:37: error: binary operator '+' cannot be applied to operands of type 'Int' and '[Int]'\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                  ~ ^ ~~~~~~~~~~\n/tmp/tmp4p33ph4z.swift:24:37: note: overloads for '+' exist with these partially matching parameter lists: (Int, Int)\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                    ^\n/tmp/tmp4p33ph4z.swift:24:27: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2))\n                          ^\n                          n: \n/tmp/tmp4p33ph4z.swift:24:43: error: missing argument label 'n:' in call\n        return append(tri(n - 1), 1 + tri(n - 2))\n                                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmprch4fi10.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmprch4fi10.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmprch4fi10.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmprch4fi10.swift:29:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmprch4fi10.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmprch4fi10.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmprch4fi10.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmprch4fi10.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmprch4fi10.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmprch4fi10.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    return append(tri(n - 1), tri(n - 2) + tri(n - 1) + tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmp_udshx1u.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp_udshx1u.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp_udshx1u.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp_udshx1u.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp_udshx1u.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp_udshx1u.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init<T>(_ source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.SignedInteger:2:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init<T>(_ source: T) where T : BinaryInteger\n               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 3}\n    }\n    if n % 2 == 0 {\n        return []Int{1, 1 + n / 2, 2}\n    }\n    return []Int{1, 1 + (n - 1) / 2, 1 + (n - 2) / 2, 1 + (n + 1) / 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpfyfkaktz.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpfyfkaktz.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpfyfkaktz.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmpfyfkaktz.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmpfyfkaktz.swift:26:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmpfyfkaktz.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 2}\n                 ^\n                 ;\n/tmp/tmpfyfkaktz.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 1 + n / 2, 2}\n                      ^\n                      ;\n/tmp/tmpfyfkaktz.swift:29:23: error: expected expression\n        return []Int{1, 1 + n / 2, 2}\n                      ^\n/tmp/tmpfyfkaktz.swift:31:14: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + (n - 1) / 2, 1 + (n - 2) / 2, 1 + (n + 1) / 2}\n             ^\n             ;\n/tmp/tmpfyfkaktz.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return []Int{1, 1 + (n - 1) / 2, 1 + (n - 2) / 2, 1 + (n + 1) / 2}\n                  ^\n                  ;\n/tmp/tmpfyfkaktz.swift:31:19: error: expected expression\n    return []Int{1, 1 + (n - 1) / 2, 1 + (n - 2) / 2, 1 + (n + 1) / 2}\n                  ^\n/tmp/tmpfyfkaktz.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 2, 3, 5, 8]\n    }\n    return [1, 3, 2, 8, 7, 6]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "tmpl1nuwhtp/tmpl1nuwhtp.swift:44: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b2f6df98c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b2f6dc8fb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b2f6dc8f988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b2f6dc8e7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpl1nuwhtp                        0x0000562bcc9f042a <unavailable> + 5162\n5    libc.so.6                          0x00002b2f6e184460 __libc_start_main + 245\n6    tmpl1nuwhtp                        0x0000562bcc9f0069 <unavailable> + 4201\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpodp62jom.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpodp62jom.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpodp62jom.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmpodp62jom.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpodp62jom.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmpodp62jom.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                ^\n                ;\n/tmp/tmpodp62jom.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                  ^\n                  ;\n/tmp/tmpodp62jom.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8, 1, 5, 3, 4, 2, 1}\n                  ^\n/tmp/tmpodp62jom.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpodp62jom.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpodp62jom.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpodp62jom.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpodp62jom.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpodp62jom.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpnp8czd7z.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpnp8czd7z.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                    ^\n                    ;\n/tmp/tmpnp8czd7z.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n                      ;\n/tmp/tmpnp8czd7z.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2, 1 + n / 2}\n                      ^\n/tmp/tmpnp8czd7z.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                ^\n                ;\n/tmp/tmpnp8czd7z.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n                  ;\n/tmp/tmpnp8czd7z.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2, 1 + n / 2 + 1}\n                  ^\n/tmp/tmpnp8czd7z.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpnp8czd7z.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    } else if n == 1 {\n        return []Int{1}\n    } else if n == 2 {\n        return []Int{1, 3}\n    } else if n == 3 {\n        return []Int{1, 3, 2, 8}\n    } else {\n        return []Int{1, 3, 2, 8}\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp5jp4fuho.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:22:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:24:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:24:23: error: expected expression\n        return []Int{1, 3}\n                      ^\n/tmp/tmp5jp4fuho.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:26:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:28:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmp5jp4fuho.swift:28:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp5jp4fuho.swift:28:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmp5jp4fuho.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' confor",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n == 3 {\n        return [Int]{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3, 5, 8} + tri(n - 2)\n    }\n    return [Int]{1, 3, 5, 8} + tri(n - 1) + tri(n - 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpqzj5mbs6.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpqzj5mbs6.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpqzj5mbs6.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpqzj5mbs6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpqzj5mbs6.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpqzj5mbs6.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmpqzj5mbs6.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpqzj5mbs6.swift:29:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmpqzj5mbs6.swift:32:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3, 5, 8} + tri(n - 2)\n                    ^\n                    ;\n/tmp/tmpqzj5mbs6.swift:32:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3, 5, 8} + tri(n - 2)\n                      ^\n                      ;\n/tmp/tmpqzj5mbs6.swift:32:23: error: expected expression\n        return [Int]{1, 2, 3, 5, 8} + tri(n - 2)\n                      ^\n/tmp/tmpqzj5mbs6.swift:34:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8} + tri(n - 1) + tri(n - 2)\n                ^\n                ;\n/tmp/tmpqzj5mbs6.swift:34:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 0 {\n        panic(\"n should be non-negative\")\n    }\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n == 2 {\n        return [Int]{2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmps5gxo3l4.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmps5gxo3l4.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmps5gxo3l4.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                    ^\n                    ;\n/tmp/tmps5gxo3l4.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{2, 3}\n                      ^\n                      ;\n/tmp/tmps5gxo3l4.swift:29:23: error: expected expression\n        return [Int]{2, 3}\n                      ^\n/tmp/tmps5gxo3l4.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmps5gxo3l4.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmps5gxo3l4.swift:31:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmps5gxo3l4.swift:20:9: error: cannot find 'panic' in scope\n        panic(\"n should be non-negative\")\n        ^~~~~\n/tmp/tmps5gxo3l4.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmps5gxo3l4.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmps5gxo3l4.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmps5gxo3l4.swift:26:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmps5gxo3l4.swift:26:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmps5gxo3l4.swift:26:21: note: did y",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []\n    }\n    if n == 1 {\n        return [1]\n    }\n    if n % 2 == 0 {\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpkvlsymuu.swift:27:1: error: expected expression in container literal\n}\n^\n/tmp/tmpkvlsymuu.swift:51:28: error: expected '}' at end of brace statement\nassert(tri(n: 1) == [1, 3])\n                           ^\n/tmp/tmpkvlsymuu.swift:18:27: note: to match this opening '{'\nfunc tri(n: Int) -> [Int] {\n                          ^\n/tmp/tmpkvlsymuu.swift:30:6: error: operator functions can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n < 1 {\n        return []Int{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpapgzqrf0.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpapgzqrf0.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpapgzqrf0.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpapgzqrf0.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpapgzqrf0.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpapgzqrf0.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpapgzqrf0.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpapgzqrf0.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpapgzqrf0.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3:23: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    if n % 2 == 0 {\n        return append(tri(n - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n - 2), tri(n + 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpmly6_kk6.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmpmly6_kk6.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmpmly6_kk6.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmpmly6_kk6.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmpmly6_kk6.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmpmly6_kk6.swift:20:18: error: no exact matches in call to initializer \n        return []Int{}\n                 ^\nSwift.Int:6:12: note: candidate requires that '() -> ()' conform to 'CodingKey' (requirement specified as 'T' : 'CodingKey')\n    public init?<T>(codingKey: T) where T : CodingKey\n           ^\nSwift.SignedInteger:3:23: note: candidate requires that '() -> ()' conform to 'BinaryInteger' (requirement specified as 'T' : 'BinaryInteger')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryInteger\n                      ^\nSwift.FixedWidthInteger:4:23: note: candidate requires that '() -> ()' conform to 'BinaryFloatingPoint' (requirement specified as 'T' : 'BinaryFloatingPoint')\n    @inlinable public init?<T>(exactly source: T) where T : BinaryFloatingPoint\n                      ^\nSwift.FixedWidthInteger:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n <= 0 {\n        return []Int{}\n    }\n    if n == 1 {\n        return []Int{1}\n    }\n    if n == 2 {\n        return []Int{1, 2}\n    }\n    if n == 3 {\n        return []Int{1, 3, 2, 8}\n    }\n    \n    var a = []Int{1, 3, 2, 8}\n    for i := 4; i <= n; i++ {\n        a = append(a, a[i - 1] + a[i - 2] + a[i - 3])\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmplsdw11f5.swift:20:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{}\n                 ^\n                 ;\n/tmp/tmplsdw11f5.swift:23:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1}\n                 ^\n                 ;\n/tmp/tmplsdw11f5.swift:26:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                 ^\n                 ;\n/tmp/tmplsdw11f5.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 2}\n                      ^\n                      ;\n/tmp/tmplsdw11f5.swift:26:23: error: expected expression\n        return []Int{1, 2}\n                      ^\n/tmp/tmplsdw11f5.swift:29:18: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                 ^\n                 ;\n/tmp/tmplsdw11f5.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return []Int{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmplsdw11f5.swift:29:23: error: expected expression\n        return []Int{1, 3, 2, 8}\n                      ^\n/tmp/tmplsdw11f5.swift:32:15: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 3, 2, 8}\n              ^\n              ;\n/tmp/tmplsdw11f5.swift:32:20: error: consecutive statements on a line must be separated by ';'\n    var a = []Int{1, 3, 2, 8}\n                   ^\n                   ;\n/tmp/tmplsdw11f5.swift:32:20: error: expected expression\n    var a = []Int{1, 3, 2, 8}\n                   ^\n/tmp/tmplsdw11f5.swift:33:12: error: expected type\n    for i := 4; i <= n; i++ {\n           ^\n            <#type#>\n/tmp/tmplsdw11f5.swift:33:12: error: expected 'in' after for-each pattern\n    for i := 4; i <= n; i++ {\n           ^\n/tmp/tmplsdw11f5.swift:33:12: error: expected Sequence expression for for-each loop\n    for i := 4; i <= n; i++ {\n           ^\n/tmp/tmplsdw11f5.swift:20:18: error: no exact matc",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 3, 2, 8}\n    }\n    return [Int]{1, 3, 5, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmp3nxi655f.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                    ^\n                    ;\n/tmp/tmp3nxi655f.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3, 2, 8}\n                      ^\n                      ;\n/tmp/tmp3nxi655f.swift:26:23: error: expected expression\n        return [Int]{1, 3, 2, 8}\n                      ^\n/tmp/tmp3nxi655f.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                ^\n                ;\n/tmp/tmp3nxi655f.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 5, 8}\n                  ^\n                  ;\n/tmp/tmp3nxi655f.swift:28:19: error: expected expression\n    return [Int]{1, 3, 5, 8}\n                  ^\n/tmp/tmp3nxi655f.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmp3nxi655f.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmp3nxi655f.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmp3nxi655f.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3nxi655f.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3nxi655f.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n\tif n == 0 {\n\t\treturn []int{}\n\t}\n\tif n == 1 {\n\t\treturn []int{1}\n\t}\n\tif n == 2 {\n\t\treturn []int{1, 2}\n\t}\n\tif n == 3 {\n\t\treturn []int{1, 3, 2, 8}\n\t}\n\tif n % 2 == 0 {\n\t\treturn append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n\t}\n\treturn append(tri(n - 1), tri(n - 2), tri(n - 1), tri(n - 1))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpuup48ss_.swift:20:12: error: consecutive statements on a line must be separated by ';'\n                return []int{}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:23:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:26:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 2}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:26:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 2}\n                              ^\n                              ;\n/tmp/tmpuup48ss_.swift:26:17: error: expected expression\n                return []int{1, 2}\n                              ^\n/tmp/tmpuup48ss_.swift:29:12: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                         ^\n                         ;\n/tmp/tmpuup48ss_.swift:29:17: error: consecutive statements on a line must be separated by ';'\n                return []int{1, 3, 2, 8}\n                              ^\n                              ;\n/tmp/tmpuup48ss_.swift:29:17: error: expected expression\n                return []int{1, 3, 2, 8}\n                              ^\n/tmp/tmpuup48ss_.swift:20:12: error: cannot find 'int' in scope\n                return []int{}\n                         ^~~\n/tmp/tmpuup48ss_.swift:23:12: error: cannot find 'int' in scope\n                return []int{1}\n                         ^~~\n/tmp/tmpuup48ss_.swift:26:12: error: cannot find 'int' in scope\n                return []int{1, 2}\n                         ^~~\n/tmp/tmpuup48ss_.swift:29:12: error: cannot find 'int' in scope\n                return []int{1, 3, 2, 8}\n                         ^~~\n/tmp/tmpuup48ss_.swift:32:10: error: cannot find 'append' in scope\n                return append(tri(n - 1), 1, tri(n - 2), tri(n - 1))\n                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "/tmp/tmpqpgjrdt2.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                    ^\n                    ;\n/tmp/tmpqpgjrdt2.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 3}\n                      ^\n                      ;\n/tmp/tmpqpgjrdt2.swift:26:23: error: expected expression\n        return [Int]{1, 3}\n                      ^\n/tmp/tmpqpgjrdt2.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpqpgjrdt2.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpqpgjrdt2.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpqpgjrdt2.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpqpgjrdt2.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpqpgjrdt2.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpqpgjrdt2.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpqpgjrdt2.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpqpgjrdt2.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpqpgjrdt2.swift",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{1}\n    }\n    if n == 1 {\n        return [Int]{3}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{3, 1, 2, 3}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmp3a97tldr.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmp3a97tldr.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmp3a97tldr.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmp3a97tldr.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                ^\n                ;\n/tmp/tmp3a97tldr.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{3, 1, 2, 3}\n                  ^\n                  ;\n/tmp/tmp3a97tldr.swift:28:19: error: expected expression\n    return [Int]{3, 1, 2, 3}\n                  ^\n/tmp/tmp3a97tldr.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:20:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmp3a97tldr.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmp3a97tldr.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{3}\n               ^~~~~\n/tmp/tmp3a97tldr.swift:23:21: error: closure expression is unused\n        return [Int]{3}\n                    ^\n/tmp/tmp3a97tldr.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{3}\n                    ^\n                    do \n/tmp/tmp3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n == 2 {\n        return [Int]{1, 2}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 1 + n / 2, 2}\n    }\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 2}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "/tmp/tmpjiw6g4yi.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpjiw6g4yi.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpjiw6g4yi.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                    ^\n                    ;\n/tmp/tmpjiw6g4yi.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2}\n                      ^\n                      ;\n/tmp/tmpjiw6g4yi.swift:26:23: error: expected expression\n        return [Int]{1, 2}\n                      ^\n/tmp/tmpjiw6g4yi.swift:29:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 2}\n                    ^\n                    ;\n/tmp/tmpjiw6g4yi.swift:29:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 1 + n / 2, 2}\n                      ^\n                      ;\n/tmp/tmpjiw6g4yi.swift:29:23: error: expected expression\n        return [Int]{1, 1 + n / 2, 2}\n                      ^\n/tmp/tmpjiw6g4yi.swift:31:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 2}\n                ^\n                ;\n/tmp/tmpjiw6g4yi.swift:31:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 2}\n                  ^\n                  ;\n/tmp/tmpjiw6g4yi.swift:31:19: error: expected expression\n    return [Int]{1, 1 + n / 2, 1 + n / 2 + n / 2, 2}\n                  ^\n/tmp/tmpjiw6g4yi.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpjiw6g4yi.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpjiw6g4yi.swift:20:21: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n/// the last couple centuries. However, what people don't know is Tribonacci sequence.\n/// Tribonacci sequence is defined by the recurrence:\n/// tri(1) = 3\n/// tri(n) = 1 + n / 2, if n is even.\n/// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n/// For example:\n/// tri(2) = 1 + (2 / 2) = 2\n/// tri(4) = 3\n/// tri(3) = tri(2) + tri(1) + tri(4)\n/// = 2 + 3 + 3 = 8 \n/// You are given a non-negative integer number n, you have to a return an array of the \n/// first n + 1 numbers of the Tribonacci sequence.\n/// Examples:\n/// >>> tri(n: 3)\n/// [1, 3, 2, 8]\nfunc tri(n: Int) -> [Int] {\n    if n == 0 {\n        return [Int]{}\n    }\n    if n == 1 {\n        return [Int]{1}\n    }\n    if n % 2 == 0 {\n        return [Int]{1, 2, 3}\n    }\n    return [Int]{1, 3, 2, 8}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tri(n: 3) == [1, 3, 2, 8])\nassert(tri(n: 4) == [1, 3, 2, 8, 3])\nassert(tri(n: 5) == [1, 3, 2, 8, 3, 15])\nassert(tri(n: 6) == [1, 3, 2, 8, 3, 15, 4])\nassert(tri(n: 7) == [1, 3, 2, 8, 3, 15, 4, 24])\nassert(tri(n: 8) == [1, 3, 2, 8, 3, 15, 4, 24, 5])\nassert(tri(n: 9) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35])\nassert(tri(n: 20) == [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11])\nassert(tri(n: 0) == [1])\nassert(tri(n: 1) == [1, 3])",
      "timestamp": 1664293219,
      "stdout": "",
      "stderr": "/tmp/tmpv7fmh60b.swift:20:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:23:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:21: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                    ^\n                    ;\n/tmp/tmpv7fmh60b.swift:26:23: error: consecutive statements on a line must be separated by ';'\n        return [Int]{1, 2, 3}\n                      ^\n                      ;\n/tmp/tmpv7fmh60b.swift:26:23: error: expected expression\n        return [Int]{1, 2, 3}\n                      ^\n/tmp/tmpv7fmh60b.swift:28:17: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                ^\n                ;\n/tmp/tmpv7fmh60b.swift:28:19: error: consecutive statements on a line must be separated by ';'\n    return [Int]{1, 3, 2, 8}\n                  ^\n                  ;\n/tmp/tmpv7fmh60b.swift:28:19: error: expected expression\n    return [Int]{1, 3, 2, 8}\n                  ^\n/tmp/tmpv7fmh60b.swift:20:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:20:21: error: closure expression is unused\n        return [Int]{}\n                    ^\n/tmp/tmpv7fmh60b.swift:20:21: note: did you mean to use a 'do' statement?\n        return [Int]{}\n                    ^\n                    do \n/tmp/tmpv7fmh60b.swift:23:16: error: cannot convert return expression of type '[Int].Type' to return type '[Int]'\n        return [Int]{1}\n               ^~~~~\n/tmp/tmpv7fmh60b.swift:23:21: error: closure expression is unused\n        return [Int]{1}\n                    ^\n/tmp/tmpv7fmh60b.swift:23:21: note: did you mean to use a 'do' statement?\n        return [Int]{1}\n                    ^\n                    do \n/tmp/tmpv7fmh",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}