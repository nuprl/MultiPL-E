{
  "name": "HumanEval_158_find_max",
  "language": "swift",
  "prompt": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := used[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpm4p3bgbz.swift:14:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpm4p3bgbz.swift:14:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpm4p3bgbz.swift:14:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpm4p3bgbz.swift:15:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpm4p3bgbz.swift:15:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpm4p3bgbz.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpm4p3bgbz.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpm4p3bgbz.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpm4p3bgbz.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpm4p3bgbz.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpm4p3bgbz.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpm4p3bgbz.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := used[c]; !ok {\n                     ^\n/tmp/tmpm4p3bgbz.swift:14:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpm4p3bgbz.swift:15:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpv6xa2iiy.swift:15:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpv6xa2iiy.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpv6xa2iiy.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpgzkdhmkn.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpgzkdhmkn.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpgzkdhmkn.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpgzkdhmkn.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpgzkdhmkn.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpgzkdhmkn.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb9d5zkwg.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpb9d5zkwg.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpb9d5zkwg.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpb9d5zkwg.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpb9d5zkwg.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpb9d5zkwg.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := len(word)\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvfy840d8.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvfy840d8.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvfy840d8.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvfy840d8.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := len(word)\n             ^\n             ;\n/tmp/tmpvfy840d8.swift:16:15: error: expected expression\n        count := len(word)\n              ^\n/tmp/tmpvfy840d8.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvfy840d8.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := unique[c]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp0kiqaxac.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp0kiqaxac.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp0kiqaxac.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp0kiqaxac.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp0kiqaxac.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp0kiqaxac.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp0kiqaxac.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[c]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7i1eoswk.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7i1eoswk.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp7i1eoswk.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpswf_e4oz.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpswf_e4oz.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpswf_e4oz.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := unique[ch]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpub2ikqsu.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpub2ikqsu.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := visited[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_cncehpq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_cncehpq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := visited[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := len(word)\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvfy840d8.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvfy840d8.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvfy840d8.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvfy840d8.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := len(word)\n             ^\n             ;\n/tmp/tmpvfy840d8.swift:16:15: error: expected expression\n        count := len(word)\n              ^\n/tmp/tmpvfy840d8.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvfy840d8.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpkwnq2rj9.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmpkwnq2rj9.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmpkwnq2rj9.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmpkwnq2rj9.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmpkwnq2rj9.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmpkwnq2rj9.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return max_string(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpg7dtm9px.swift:14:12: error: cannot find 'max_string' in scope\n    return max_string(words)\n           ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 1\n            } else {\n                word_count[c] += 1\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12faa04w.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp12faa04w.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp12faa04w.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp12faa04w.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp12faa04w.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp12faa04w.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp12faa04w.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpao6ep4aq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpao6ep4aq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpao6ep4aq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpao6ep4aq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpao6ep4aq.swift:18:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpao6ep4aq.swift:18:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpao6ep4aq.swift:18:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := seen[c]; !ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp2_qx2aq4.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp2_qx2aq4.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp2_qx2aq4.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp2_qx2aq4.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp2_qx2aq4.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp2_qx2aq4.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp2_qx2aq4.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := seen[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := word_count[ch]; ok {\n                count += 1\n            } else {\n                word_count[ch] = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpxte6cmfw.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpxte6cmfw.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpxte6cmfw.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpxte6cmfw.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpxte6cmfw.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpxte6cmfw.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpxte6cmfw.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := len(word)\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvfy840d8.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvfy840d8.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvfy840d8.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvfy840d8.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := len(word)\n             ^\n             ;\n/tmp/tmpvfy840d8.swift:16:15: error: expected expression\n        count := len(word)\n              ^\n/tmp/tmpvfy840d8.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvfy840d8.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpxt4pu30j.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpxt4pu30j.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpxt4pu30j.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpxt4pu30j.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpxt4pu30j.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpxt4pu30j.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpxt4pu30j.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpi2yj21u4/tmpi2yj21u4.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af9137b1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af9134a8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af9134a8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af9134a77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2yj21u4                        0x000055bf0206651e <unavailable> + 5406\n5    libc.so.6                          0x00002af91399d460 __libc_start_main + 245\n6    tmpi2yj21u4                        0x000055bf020660d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max_string(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpoxphx2ur.swift:14:12: error: cannot find 'max_string' in scope\n    return max_string(words)\n           ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpswf_e4oz.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpswf_e4oz.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpswf_e4oz.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb7_k1mwv.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpul8dvhyb.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpul8dvhyb.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpul8dvhyb.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpul8dvhyb.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpul8dvhyb.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpul8dvhyb.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpul8dvhyb.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmpul8dvhyb.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmpul8dvhyb.swift:28:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpswf_e4oz.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpswf_e4oz.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpswf_e4oz.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpelviyza3.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpelviyza3.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpelviyza3.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpelviyza3.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmph_a9ruil.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmph_a9ruil.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmph_a9ruil.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmph_a9ruil.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmph_a9ruil.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmph_a9ruil.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmph_a9ruil.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmph_a9ruil.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmph_a9ruil.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmph_a9ruil.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmph_a9ruil.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmph_a9ruil.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmph_a9ruil.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmph_a9ruil.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] != word[i + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpr983umr5.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpr983umr5.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpr983umr5.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpr983umr5.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpr983umr5.swift:18:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpr983umr5.swift:18:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpr983umr5.swift:18:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 0\n            }\n            word_count[c] += 1\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpwb09bl86.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpwb09bl86.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpwb09bl86.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpwb09bl86.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpwb09bl86.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpwb09bl86.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpwb09bl86.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpxt4pu30j.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpxt4pu30j.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpxt4pu30j.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpxt4pu30j.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpxt4pu30j.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpxt4pu30j.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpxt4pu30j.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 0\n            }\n            word_count[c] += 1\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpwb09bl86.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpwb09bl86.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpwb09bl86.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpwb09bl86.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpwb09bl86.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpwb09bl86.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpwb09bl86.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmperda59cz.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmperda59cz.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmperda59cz.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmperda59cz.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmperda59cz.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmperda59cz.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmperda59cz.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmperda59cz.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmperda59cz.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmperda59cz.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmperda59cz.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmperda59cz.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmperda59cz.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmperda59cz.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max_string(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpoxphx2ur.swift:14:12: error: cannot find 'max_string' in scope\n    return max_string(words)\n           ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp922u445v.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp922u445v.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp922u445v.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp922u445v.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp922u445v.swift:18:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp922u445v.swift:18:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp922u445v.swift:18:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb7_k1mwv.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] != word[i + 1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvblx8j3o.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvblx8j3o.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvblx8j3o.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvblx8j3o.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvblx8j3o.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvblx8j3o.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvblx8j3o.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvblx8j3o.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpvblx8j3o.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpvblx8j3o.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpvblx8j3o.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpvblx8j3o.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpvblx8j3o.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvblx8j3o.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i in range(len(words)) {\n        if len(words[i]) > max_count {\n            max_count = len(words[i])\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp52ru8w9f.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmp52ru8w9f.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmp52ru8w9f.swift:16:14: error: cannot find 'range' in scope\n    for i in range(len(words)) {\n             ^~~~~\n/tmp/tmp52ru8w9f.swift:16:20: error: cannot find 'len' in scope\n    for i in range(len(words)) {\n                   ^~~\n/tmp/tmp52ru8w9f.swift:22:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 0\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_jgn9jrt.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp_jgn9jrt.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp_jgn9jrt.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp_jgn9jrt.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp_jgn9jrt.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp_jgn9jrt.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_jgn9jrt.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_jgn9jrt.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_jgn9jrt.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_jgn9jrt.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_jgn9jrt.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_jgn9jrt.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp_jgn9jrt.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp3h_oab3_.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp3h_oab3_.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp3h_oab3_.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp3h_oab3_.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp3h_oab3_.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp3h_oab3_.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max_char_count(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpgyl9q0gf.swift:14:12: error: cannot find 'max_char_count' in scope\n    return max_char_count(words)\n           ^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpp4ep76ok.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpp4ep76ok.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpp4ep76ok.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpp4ep76ok.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpp4ep76ok.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpp4ep76ok.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb5mj1exc.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpb5mj1exc.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpb5mj1exc.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpb5mj1exc.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpb5mj1exc.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpb5mj1exc.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpb5mj1exc.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := unique[ch]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpwvqo1m3d.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpwvqo1m3d.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpwvqo1m3d.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpwvqo1m3d.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpwvqo1m3d.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpwvqo1m3d.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpwvqo1m3d.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpwvqo1m3d.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpwvqo1m3d.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpwvqo1m3d.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpwvqo1m3d.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpwvqo1m3d.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[ch]; ok {\n                     ^\n/tmp/tmpwvqo1m3d.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpwvqo1m3d.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpi2yj21u4/tmpi2yj21u4.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af9137b1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af9134a8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af9134a8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af9134a77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2yj21u4                        0x000055bf0206651e <unavailable> + 5406\n5    libc.so.6                          0x00002af91399d460 __libc_start_main + 245\n6    tmpi2yj21u4                        0x000055bf020660d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmprpw4kqjo.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmprpw4kqjo.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmprpw4kqjo.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmprpw4kqjo.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmprpw4kqjo.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmprpw4kqjo.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmprpw4kqjo.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmprpw4kqjo.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmprpw4kqjo.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmprpw4kqjo.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmprpw4kqjo.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmprpw4kqjo.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmprpw4kqjo.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpelviyza3.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpelviyza3.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpelviyza3.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpelviyza3.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := unique[ch]; ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmppgrp_kgm.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmppgrp_kgm.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmppgrp_kgm.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmppgrp_kgm.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmppgrp_kgm.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmppgrp_kgm.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmppgrp_kgm.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 0\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp4ywt_gf0.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp4ywt_gf0.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := seen[c]; !ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp2_qx2aq4.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp2_qx2aq4.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp2_qx2aq4.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp2_qx2aq4.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp2_qx2aq4.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp2_qx2aq4.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp2_qx2aq4.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := seen[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := count_map[ch]; ok {\n                count += 1\n            } else {\n                count_map[ch] = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp67al_asd.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp67al_asd.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp67al_asd.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp67al_asd.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp67al_asd.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp67al_asd.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp67al_asd.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp67al_asd.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp67al_asd.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp67al_asd.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmp67al_asd.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmp67al_asd.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := count_map[ch]; ok {\n                     ^\n/tmp/tmp67al_asd.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp67al_asd.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmprpw4kqjo.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmprpw4kqjo.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmprpw4kqjo.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmprpw4kqjo.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmprpw4kqjo.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmprpw4kqjo.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmprpw4kqjo.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmprpw4kqjo.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmprpw4kqjo.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmprpw4kqjo.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmprpw4kqjo.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmprpw4kqjo.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmprpw4kqjo.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpv6xa2iiy.swift:15:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpv6xa2iiy.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpv6xa2iiy.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpv6xa2iiy.swift:17:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 0\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp4ywt_gf0.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp4ywt_gf0.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        if len(words[i]) > max_count {\n            max_count = len(words[i])\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpkw555noy.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpkw555noy.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpkw555noy.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpkw555noy.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmpkw555noy.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmpkw555noy.swift:22:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 1\n            } else {\n                word_count[c] += 1\n            }\n            count += word_count[c]\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmphkutr7cq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmphkutr7cq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmphkutr7cq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmphkutr7cq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmphkutr7cq.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmphkutr7cq.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmphkutr7cq.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := visited[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_cncehpq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_cncehpq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := visited[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := word_count[ch]; ok {\n                count += 1\n            } else {\n                word_count[ch] = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpt3hg897w.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpt3hg897w.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpt3hg897w.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpt3hg897w.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpt3hg897w.swift:18:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpt3hg897w.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpt3hg897w.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpswf_e4oz.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpswf_e4oz.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpswf_e4oz.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpswf_e4oz.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := unique[ch]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpub2ikqsu.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpub2ikqsu.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb7_k1mwv.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7i1eoswk.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7i1eoswk.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp7i1eoswk.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        count := 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j + 1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpin8uucp7.swift:15:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpin8uucp7.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpin8uucp7.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpin8uucp7.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpin8uucp7.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpin8uucp7.swift:17:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpin8uucp7.swift:17:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpin8uucp7.swift:17:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpl9f0lsh8.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpl9f0lsh8.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpl9f0lsh8.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpl9f0lsh8.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpl9f0lsh8.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpl9f0lsh8.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count = 0\n            } else {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp86nvjh21.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp86nvjh21.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp86nvjh21.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp86nvjh21.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp86nvjh21.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp86nvjh21.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp86nvjh21.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp86nvjh21.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp86nvjh21.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp86nvjh21.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp86nvjh21.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp86nvjh21.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmp86nvjh21.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp86nvjh21.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 0\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp3vbqwuee.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp3vbqwuee.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp3vbqwuee.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp3vbqwuee.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp3vbqwuee.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp3vbqwuee.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            count += strings.Count(word, string(ch))\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp6ljrxc6h.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp6ljrxc6h.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp6ljrxc6h.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp6ljrxc6h.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp6ljrxc6h.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp6ljrxc6h.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp6ljrxc6h.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp6ljrxc6h.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp6ljrxc6h.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp6ljrxc6h.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmp6ljrxc6h.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmp6ljrxc6h.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp6ljrxc6h.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        count := 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpldgby34s.swift:15:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpldgby34s.swift:15:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpldgby34s.swift:15:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpldgby34s.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpldgby34s.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpldgby34s.swift:17:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpldgby34s.swift:17:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpldgby34s.swift:17:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[count] {\n                count += 1\n            } else {\n                count = 0\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp4ywt_gf0.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp4ywt_gf0.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp4ywt_gf0.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp4ywt_gf0.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := unique[c]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp0kiqaxac.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp0kiqaxac.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp0kiqaxac.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp0kiqaxac.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp0kiqaxac.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp0kiqaxac.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp0kiqaxac.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[c]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := visited[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_cncehpq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_cncehpq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := visited[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp922u445v.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp922u445v.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp922u445v.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp922u445v.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp922u445v.swift:18:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp922u445v.swift:18:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp922u445v.swift:18:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpkwnq2rj9.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmpkwnq2rj9.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmpkwnq2rj9.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmpkwnq2rj9.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmpkwnq2rj9.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmpkwnq2rj9.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := count_map[c]; !ok {\n                count_map[c] = 0\n            }\n            count_map[c] += 1\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpc1fman1y.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpc1fman1y.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpc1fman1y.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpc1fman1y.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpc1fman1y.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpc1fman1y.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpc1fman1y.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpc1fman1y.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpc1fman1y.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpc1fman1y.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpc1fman1y.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpc1fman1y.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := count_map[c]; !ok {\n                     ^\n/tmp/tmpc1fman1y.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpc1fman1y.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] != word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmper1cw21k.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmper1cw21k.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmper1cw21k.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmper1cw21k.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmper1cw21k.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmper1cw21k.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmper1cw21k.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmper1cw21k.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmper1cw21k.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmper1cw21k.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmper1cw21k.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmper1cw21k.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmper1cw21k.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmper1cw21k.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpgzkdhmkn.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpgzkdhmkn.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpgzkdhmkn.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpgzkdhmkn.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpgzkdhmkn.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpgzkdhmkn.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpi2yj21u4/tmpi2yj21u4.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af9137b1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af9134a8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af9134a8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af9134a77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2yj21u4                        0x000055bf0206651e <unavailable> + 5406\n5    libc.so.6                          0x00002af91399d460 __libc_start_main + 245\n6    tmpi2yj21u4                        0x000055bf020660d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := count_map[c]; !ok {\n                count_map[c] = 1\n            } else {\n                count_map[c] += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpnxb4tnas.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpnxb4tnas.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpnxb4tnas.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpnxb4tnas.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpnxb4tnas.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpnxb4tnas.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpnxb4tnas.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpnxb4tnas.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpnxb4tnas.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpnxb4tnas.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpnxb4tnas.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpnxb4tnas.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := count_map[c]; !ok {\n                     ^\n/tmp/tmpnxb4tnas.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpnxb4tnas.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max_string(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpoxphx2ur.swift:14:12: error: cannot find 'max_string' in scope\n    return max_string(words)\n           ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := len(word)\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvfy840d8.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvfy840d8.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvfy840d8.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvfy840d8.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := len(word)\n             ^\n             ;\n/tmp/tmpvfy840d8.swift:16:15: error: expected expression\n        count := len(word)\n              ^\n/tmp/tmpvfy840d8.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvfy840d8.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := unique[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpedvrc8s4.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpedvrc8s4.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpedvrc8s4.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpedvrc8s4.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpedvrc8s4.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpedvrc8s4.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpedvrc8s4.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := unique[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpi2yj21u4/tmpi2yj21u4.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002af9137b1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002af9134a8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002af9134a8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002af9134a77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpi2yj21u4                        0x000055bf0206651e <unavailable> + 5406\n5    libc.so.6                          0x00002af91399d460 __libc_start_main + 245\n6    tmpi2yj21u4                        0x000055bf020660d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmph_a9ruil.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmph_a9ruil.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmph_a9ruil.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmph_a9ruil.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmph_a9ruil.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmph_a9ruil.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmph_a9ruil.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmph_a9ruil.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmph_a9ruil.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmph_a9ruil.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmph_a9ruil.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmph_a9ruil.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmph_a9ruil.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmph_a9ruil.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := visited[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_cncehpq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_cncehpq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_cncehpq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_cncehpq.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := visited[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpp4ep76ok.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpp4ep76ok.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpp4ep76ok.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpp4ep76ok.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpp4ep76ok.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpp4ep76ok.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i in range(len(words)) {\n        if len(words[i]) > len(max_word) {\n            max_count = 0\n            max_word = words[i]\n        }\n        if len(words[i]) == len(max_word) {\n            if max_count < len(words[i]) {\n                max_count = len(words[i])\n            }\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp21hkx2gf.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmp21hkx2gf.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmp21hkx2gf.swift:16:14: error: cannot find 'range' in scope\n    for i in range(len(words)) {\n             ^~~~~\n/tmp/tmp21hkx2gf.swift:16:20: error: cannot find 'len' in scope\n    for i in range(len(words)) {\n                   ^~~\n/tmp/tmp21hkx2gf.swift:27:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb5mj1exc.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpb5mj1exc.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpb5mj1exc.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpb5mj1exc.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpb5mj1exc.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpb5mj1exc.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpb5mj1exc.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp3qvi_d1t.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmp3qvi_d1t.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmp3qvi_d1t.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmp3qvi_d1t.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmp3qvi_d1t.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmp3qvi_d1t.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmp3qvi_d1t.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmp3qvi_d1t.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmp3qvi_d1t.swift:28:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := seen[c]; !ok {\n                seen[c] = true\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8_ax41c7.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8_ax41c7.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8_ax41c7.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8_ax41c7.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8_ax41c7.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8_ax41c7.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8_ax41c7.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8_ax41c7.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp8_ax41c7.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp8_ax41c7.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp8_ax41c7.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp8_ax41c7.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := seen[c]; !ok {\n                     ^\n/tmp/tmp8_ax41c7.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8_ax41c7.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 0\n            }\n            word_count[c]++\n            count++\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpbd4i6vbt.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpbd4i6vbt.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpbd4i6vbt.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpbd4i6vbt.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpbd4i6vbt.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpbd4i6vbt.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpbd4i6vbt.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            count += strings.Count(word, string(ch))\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp6ljrxc6h.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp6ljrxc6h.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp6ljrxc6h.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp6ljrxc6h.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp6ljrxc6h.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp6ljrxc6h.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp6ljrxc6h.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp6ljrxc6h.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp6ljrxc6h.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp6ljrxc6h.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmp6ljrxc6h.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmp6ljrxc6h.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp6ljrxc6h.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := word_count[c]; !ok {\n                word_count[c] = 0\n            }\n            word_count[c] += 1\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmphhohx8nl.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmphhohx8nl.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmphhohx8nl.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmphhohx8nl.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmphhohx8nl.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmphhohx8nl.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmphhohx8nl.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmphhohx8nl.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmphhohx8nl.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmphhohx8nl.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmphhohx8nl.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmphhohx8nl.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[c]; !ok {\n                     ^\n/tmp/tmphhohx8nl.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmphhohx8nl.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpkwnq2rj9.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmpkwnq2rj9.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmpkwnq2rj9.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmpkwnq2rj9.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmpkwnq2rj9.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmpkwnq2rj9.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] != word[i + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpsujqh8cn.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpsujqh8cn.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpsujqh8cn.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpsujqh8cn.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpsujqh8cn.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpsujqh8cn.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpsujqh8cn.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpsujqh8cn.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpsujqh8cn.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpsujqh8cn.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpsujqh8cn.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpsujqh8cn.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpsujqh8cn.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpsujqh8cn.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            count += strings.Count(word, string(ch))\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpmlatnzle.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpmlatnzle.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpmlatnzle.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpmlatnzle.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpmlatnzle.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpmlatnzle.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp3joa1iol.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp3joa1iol.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp3joa1iol.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp3joa1iol.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp3joa1iol.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp3joa1iol.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp3joa1iol.swift:19:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := count_map[c]; !ok {\n                count_map[c] = 1\n            } else {\n                count_map[c] += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpnxb4tnas.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpnxb4tnas.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpnxb4tnas.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpnxb4tnas.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpnxb4tnas.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpnxb4tnas.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpnxb4tnas.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpnxb4tnas.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpnxb4tnas.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpnxb4tnas.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpnxb4tnas.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpnxb4tnas.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := count_map[c]; !ok {\n                     ^\n/tmp/tmpnxb4tnas.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpnxb4tnas.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == word[0] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpelviyza3.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpelviyza3.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpelviyza3.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpelviyza3.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpelviyza3.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count int\n    var max_word String\n    for i := 0; i < len(words); i++ {\n        count := 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] == words[i][j+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpo7zn9ynj.swift:14:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpo7zn9ynj.swift:14:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpo7zn9ynj.swift:14:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpo7zn9ynj.swift:15:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpo7zn9ynj.swift:15:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpo7zn9ynj.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpo7zn9ynj.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpo7zn9ynj.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpo7zn9ynj.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpo7zn9ynj.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpo7zn9ynj.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpo7zn9ynj.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpo7zn9ynj.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpo7zn9ynj.swift:14:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpo7zn9ynj.swift:15:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k0nk368.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k0nk368.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k0nk368.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k0nk368.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp8k0nk368.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp8k0nk368.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k0nk368.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp3antzc7j.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp3antzc7j.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp3antzc7j.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp3antzc7j.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp3antzc7j.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp3antzc7j.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp3antzc7j.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := word_count[ch]; ok {\n                count += 1\n            } else {\n                word_count[ch] = 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpxte6cmfw.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpxte6cmfw.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpxte6cmfw.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpxte6cmfw.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpxte6cmfw.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpxte6cmfw.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpxte6cmfw.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                count = 0\n            } else {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp86nvjh21.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp86nvjh21.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp86nvjh21.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp86nvjh21.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp86nvjh21.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp86nvjh21.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp86nvjh21.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp86nvjh21.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp86nvjh21.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp86nvjh21.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp86nvjh21.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp86nvjh21.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmp86nvjh21.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp86nvjh21.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpxrfcrmgy.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpxrfcrmgy.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpxrfcrmgy.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpxrfcrmgy.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpxrfcrmgy.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpxrfcrmgy.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := unique[ch]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpub2ikqsu.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpub2ikqsu.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpub2ikqsu.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpub2ikqsu.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[ch]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, ch := range word {\n            if _, ok := word_count[ch]; !ok {\n                word_count[ch] = 0\n            }\n            word_count[ch]++\n            count++\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpn__lol_r.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpn__lol_r.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpn__lol_r.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpn__lol_r.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpn__lol_r.swift:18:14: error: expected 'in' after for-each pattern\n        for _, ch := range word {\n             ^\n/tmp/tmpn__lol_r.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, ch := range word {\n             ^\n/tmp/tmpn__lol_r.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := word_count[ch]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i in range(0, len(words)) {\n        count = 0\n        for j in range(0, len(words[i])) {\n            if words[i][j] != words[i][j+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpt1z7z8vf.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmpt1z7z8vf.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmpt1z7z8vf.swift:16:14: error: cannot find 'range' in scope\n    for i in range(0, len(words)) {\n             ^~~~~\n/tmp/tmpt1z7z8vf.swift:16:23: error: cannot find 'len' in scope\n    for i in range(0, len(words)) {\n                      ^~~\n/tmp/tmpt1z7z8vf.swift:28:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n/tmp/tmpt1z7z8vf.swift:18:18: error: cannot find 'range' in scope\n        for j in range(0, len(words[i])) {\n                 ^~~~~\n/tmp/tmpt1z7z8vf.swift:18:27: error: cannot find 'len' in scope\n        for j in range(0, len(words[i])) {\n                          ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k0nk368.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k0nk368.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k0nk368.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k0nk368.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp8k0nk368.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp8k0nk368.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k0nk368.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k0nk368.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k0nk368.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k0nk368.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k0nk368.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp8k0nk368.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp8k0nk368.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k0nk368.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := unique[c]; ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp_ej8rpnq.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp_ej8rpnq.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp_ej8rpnq.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp_ej8rpnq.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp_ej8rpnq.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp_ej8rpnq.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp_ej8rpnq.swift:18:22: error: expected '{' after 'if' condition\n            if _, ok := unique[c]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max(words, (a, b) => a.length - b.length)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp12zchdwp.swift:14:24: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                       ^\n/tmp/tmp12zchdwp.swift:14:27: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                          ^\n/tmp/tmp12zchdwp.swift:14:30: error: cannot find operator '=>' in scope\n    return max(words, (a, b) => a.length - b.length)\n                             ^~\n/tmp/tmp12zchdwp.swift:14:33: error: cannot find 'a' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                ^\n/tmp/tmp12zchdwp.swift:14:44: error: cannot find 'b' in scope\n    return max(words, (a, b) => a.length - b.length)\n                                           ^\n/tmp/tmp12zchdwp.swift:14:16: error: cannot convert value of type '[String]' to expected argument type 'String'\n    return max(words, (a, b) => a.length - b.length)\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7577dr2u.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7577dr2u.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7577dr2u.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmp7577dr2u.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return max_string(words)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpoxphx2ur.swift:14:12: error: cannot find 'max_string' in scope\n    return max_string(words)\n           ^~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    max_count = 0\n    max_word = \"\"\n    for i in range(len(words)) {\n        count = 0\n        for j in range(len(words[i])) {\n            if words[i][j] == words[i][j+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "/tmp/tmpj2lnzznd.swift:14:5: error: cannot find 'max_count' in scope\n    max_count = 0\n    ^~~~~~~~~\n/tmp/tmpj2lnzznd.swift:15:5: error: cannot find 'max_word' in scope\n    max_word = \"\"\n    ^~~~~~~~\n/tmp/tmpj2lnzznd.swift:16:14: error: cannot find 'range' in scope\n    for i in range(len(words)) {\n             ^~~~~\n/tmp/tmpj2lnzznd.swift:16:20: error: cannot find 'len' in scope\n    for i in range(len(words)) {\n                   ^~~\n/tmp/tmpj2lnzznd.swift:28:12: error: cannot find 'max_word' in scope\n    return max_word\n           ^~~~~~~~\n/tmp/tmpj2lnzznd.swift:18:18: error: cannot find 'range' in scope\n        for j in range(len(words[i])) {\n                 ^~~~~\n/tmp/tmpj2lnzznd.swift:18:24: error: cannot find 'len' in scope\n        for j in range(len(words[i])) {\n                       ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp7i1eoswk.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp7i1eoswk.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp7i1eoswk.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp7i1eoswk.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp7i1eoswk.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k0nk368.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k0nk368.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k0nk368.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k0nk368.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k0nk368.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k0nk368.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmp8k0nk368.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmp8k0nk368.swift:17:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:17:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmp8k0nk368.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k0nk368.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := unique[c]; ok {\n                count += 1\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb3me3pu5.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpb3me3pu5.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpb3me3pu5.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpb3me3pu5.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpb3me3pu5.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpb3me3pu5.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpb3me3pu5.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := unique[c]; ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if _, ok := seen[c]; !ok {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "/tmp/tmpplomzg4d.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpplomzg4d.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpplomzg4d.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpplomzg4d.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpplomzg4d.swift:18:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpplomzg4d.swift:18:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpplomzg4d.swift:19:22: error: expected '{' after 'if' condition\n            if _, ok := seen[c]; !ok {\n                     ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for _, word := range words {\n        count := 0\n        for i := 0; i < len(word); i++ {\n            if word[i] == word[i+1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpao6ep4aq.swift:16:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpao6ep4aq.swift:16:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpao6ep4aq.swift:17:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpao6ep4aq.swift:17:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpao6ep4aq.swift:18:16: error: expected type\n        for i := 0; i < len(word); i++ {\n               ^\n                <#type#>\n/tmp/tmpao6ep4aq.swift:18:16: error: expected 'in' after for-each pattern\n        for i := 0; i < len(word); i++ {\n               ^\n/tmp/tmpao6ep4aq.swift:18:16: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(word); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpybvwsnvm.swift:14:1: error: missing return in global function expected to return 'String'\n}\n^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := make(map[rune]int)\n        for _, r := range word {\n            count[r]++\n        }\n        if len(count) > max_count {\n            max_count = len(count)\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmp8k_wbjvp.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmp8k_wbjvp.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmp8k_wbjvp.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmp8k_wbjvp.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmp8k_wbjvp.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := make(map[rune]int)\n             ^\n             ;\n/tmp/tmp8k_wbjvp.swift:16:15: error: expected expression\n        count := make(map[rune]int)\n              ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected 'in' after for-each pattern\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, r := range word {\n             ^\n/tmp/tmp8k_wbjvp.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmp8k_wbjvp.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    return words[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "tmpeny34gqp/tmpeny34gqp.swift:30: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b9726dc9c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b9726ac0b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b9726ac0988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b9726abf7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpeny34gqp                        0x000055703944851e <unavailable> + 5406\n5    libc.so.6                          0x00002b9726fb5460 __libc_start_main + 245\n6    tmpeny34gqp                        0x00005570394480d9 <unavailable> + 4313\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := len(word)\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpvfy840d8.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpvfy840d8.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpvfy840d8.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpvfy840d8.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpvfy840d8.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpvfy840d8.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := len(word)\n             ^\n             ;\n/tmp/tmpvfy840d8.swift:16:15: error: expected expression\n        count := len(word)\n              ^\n/tmp/tmpvfy840d8.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpvfy840d8.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    // Write your code here\n    var max_count = 0\n    var max_word = \"\"\n    for i := 0; i < len(words); i++ {\n        var count = 0\n        for j := 0; j < len(words[i]); j++ {\n            if words[i][j] != words[i][j + 1] {\n                count++\n            }\n        }\n        if count > max_count {\n            max_count = count\n            max_word = words[i]\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpb7_k1mwv.swift:16:12: error: expected type\n    for i := 0; i < len(words); i++ {\n           ^\n            <#type#>\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected 'in' after for-each pattern\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:16:12: error: expected Sequence expression for for-each loop\n    for i := 0; i < len(words); i++ {\n           ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected type\n        for j := 0; j < len(words[i]); j++ {\n               ^\n                <#type#>\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected 'in' after for-each pattern\n        for j := 0; j < len(words[i]); j++ {\n               ^\n/tmp/tmpb7_k1mwv.swift:18:16: error: expected Sequence expression for for-each loop\n        for j := 0; j < len(words[i]); j++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Write a function that accepts an array of strings.\n/// The array contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(words: [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String {\n    var max_count int\n    var max_word String\n    for _, word := range words {\n        count := 0\n        for _, c := range word {\n            if c == ' ' {\n                continue\n            }\n            count += 1\n        }\n        if count > max_count {\n            max_count = count\n            max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "/tmp/tmpom9zdvej.swift:13:19: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_count int\n                  ^\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countint\n/tmp/tmpom9zdvej.swift:13:19: note: join the identifiers together with camel-case\n    var max_count int\n        ~~~~~~~~~~^~~\n        max_countInt\n/tmp/tmpom9zdvej.swift:14:18: error: found an unexpected second identifier in variable declaration; is there an accidental break?\n    var max_word String\n                 ^\n/tmp/tmpom9zdvej.swift:14:18: note: join the identifiers together\n    var max_word String\n        ~~~~~~~~~^~~~~~\n        max_wordString\n/tmp/tmpom9zdvej.swift:15:10: error: expected 'in' after for-each pattern\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:15:10: error: expected Sequence expression for for-each loop\n    for _, word := range words {\n         ^\n/tmp/tmpom9zdvej.swift:16:14: error: consecutive statements on a line must be separated by ';'\n        count := 0\n             ^\n             ;\n/tmp/tmpom9zdvej.swift:16:15: error: expected expression\n        count := 0\n              ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected 'in' after for-each pattern\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:17:14: error: expected Sequence expression for for-each loop\n        for _, c := range word {\n             ^\n/tmp/tmpom9zdvej.swift:18:21: error: single-quoted string literal found, use '\"'\n            if c == ' ' {\n                    ^~~\n                    \" \"\n/tmp/tmpom9zdvej.swift:13:9: error: type annotation missing in pattern\n    var max_count int\n        ^\n/tmp/tmpom9zdvej.swift:14:9: error: type annotation missing in pattern\n    var max_word String\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}