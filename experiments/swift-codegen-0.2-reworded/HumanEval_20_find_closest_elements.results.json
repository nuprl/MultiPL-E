{
  "name": "HumanEval_20_find_closest_elements",
  "language": "swift",
  "prompt": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar closest_number = min_number\n\tvar closest_index = 0\n\tfor i, number := range numbers {\n\t\tif number < closest_number {\n\t\t\tclosest_number = number\n\t\t\tclosest_index = i\n\t\t}\n\t}\n\treturn (closest_number, numbers[closest_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpvqi3v40d.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = index\n        }\n        if number > max_number {\n            max_number = number\n            max_index = index\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpfefinpgl.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t\tmin_index = i\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmped450djs.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\treturn (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp4aa2bj1w/tmp4aa2bj1w.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1198dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1195d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1195d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1195d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4aa2bj1w                        0x000055facebf048e <unavailable> + 5262\n5    libc.so.6                          0x00002ba119ac7460 __libc_start_main + 245\n6    tmp4aa2bj1w                        0x000055facebf0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var closest_value = min_value\n    var closest_index = 0\n    for i, value := range numbers {\n        if value < closest_value {\n            closest_value = value\n            closest_index = i\n        }\n    }\n    return (closest_value, numbers[closest_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp1ax8l3c1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmp1ax8l3c1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmp1ax8l3c1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, value := range numbers {\n         ^\n/tmp/tmp1ax8l3c1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpdk3afz4j.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp06f47wi1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = i\n        }\n        if number > max_number {\n            max_number = number\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpkl46nhu0.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i, v := range numbers {\n\t\tif v < min_value {\n\t\t\tmin_value = v\n\t\t\tmin_index = i\n\t\t}\n\t\tif v > max_value {\n\t\t\tmax_value = v\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpo9hpqwgm.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmpo9hpqwgm.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmpo9hpqwgm.swift:13:7: error: expected 'in' after for-each pattern\n        for i, v := range numbers {\n             ^\n/tmp/tmpo9hpqwgm.swift:13:7: error: expected Sequence expression for for-each loop\n        for i, v := range numbers {\n             ^\n/tmp/tmpo9hpqwgm.swift:23:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpo9hpqwgm.swift:23:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpo9hpqwgm.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmpo9hpqwgm.swift:23:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[max_index]\n                       ^~~~~~~~~\n/tmp/tmpo9hpqwgm.swift:23:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i in numbers {\n        if i < min_number {\n            min_number = i\n        }\n        if i > max_number {\n            max_number = i\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i in range(len(numbers)) {\n        if numbers[i] == min_number {\n            min_index = i\n        }\n        if numbers[i] == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp49wsr1mp.swift:21:14: error: cannot find 'range' in scope\n    for i in range(len(numbers)) {\n             ^~~~~\n/tmp/tmp49wsr1mp.swift:21:20: error: cannot find 'len' in scope\n    for i in range(len(numbers)) {\n                   ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i, v := range numbers {\n\t\tif v < min_value {\n\t\t\tmin_value = v\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i, v := range numbers {\n\t\tif v > max_value {\n\t\t\tmax_value = v\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi33dsdb4.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmpi33dsdb4.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmpi33dsdb4.swift:11:7: error: expected 'in' after for-each pattern\n        for i, v := range numbers {\n             ^\n/tmp/tmpi33dsdb4.swift:11:7: error: expected Sequence expression for for-each loop\n        for i, v := range numbers {\n             ^\n/tmp/tmpi33dsdb4.swift:19:7: error: expected 'in' after for-each pattern\n        for i, v := range numbers {\n             ^\n/tmp/tmpi33dsdb4.swift:19:7: error: expected Sequence expression for for-each loop\n        for i, v := range numbers {\n             ^\n/tmp/tmpi33dsdb4.swift:25:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpi33dsdb4.swift:25:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpi33dsdb4.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmpi33dsdb4.swift:25:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[max_index]\n                       ^~~~~~~~~\n/tmp/tmpi33dsdb4.swift:25:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    for _, value := range numbers {\n        if value == min_value {\n            return (value, max_value)\n        }\n        if value == max_value {\n            return (min_value, value)\n        }\n    }\n    return (min_value, max_value)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpz2aq3aru.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpz2aq3aru.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpz2aq3aru.swift:19:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpz2aq3aru.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tfor _, value := range numbers {\n\t\tif value == min_value {\n\t\t\treturn value, max_value\n\t\t}\n\t}\n\treturn min_value, max_value\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmppeqhn1kc.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmppeqhn1kc.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmppeqhn1kc.swift:19:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmppeqhn1kc.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmppeqhn1kc.swift:21:16: error: consecutive statements on a line must be separated by ';'\n                        return value, max_value\n                                    ^\n                                    ;\n/tmp/tmppeqhn1kc.swift:21:16: error: expected expression\n                        return value, max_value\n                                    ^\n/tmp/tmppeqhn1kc.swift:24:18: error: consecutive statements on a line must be separated by ';'\n        return min_value, max_value\n                        ^\n                        ;\n/tmp/tmppeqhn1kc.swift:24:18: error: expected expression\n        return min_value, max_value\n                        ^\n/tmp/tmppeqhn1kc.swift:24:9: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return min_value, max_value\n               ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\treturn (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp4aa2bj1w/tmp4aa2bj1w.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1198dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1195d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1195d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1195d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4aa2bj1w                        0x000055facebf048e <unavailable> + 5262\n5    libc.so.6                          0x00002ba119ac7460 __libc_start_main + 245\n6    tmp4aa2bj1w                        0x000055facebf0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar closest_pair = (min_number, max_number)\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\treturn closest_pair\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpa_83adu5.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpa_83adu5.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpa_83adu5.swift:20:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpa_83adu5.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number: Double = numbers[0]\n    var max_number: Double = numbers[0]\n    for i in range(1, len(numbers)) {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpkm098b_z.swift:11:14: error: cannot find 'range' in scope\n    for i in range(1, len(numbers)) {\n             ^~~~~\n/tmp/tmpkm098b_z.swift:11:23: error: cannot find 'len' in scope\n    for i in range(1, len(numbers)) {\n                      ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp6i83molh.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp6i83molh.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp6i83molh.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp6i83molh.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp6i83molh.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp6i83molh.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tfor _, number := range numbers {\n\t\tif number == min_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number == max_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\treturn (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpab5qexkj.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp30htkub1.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp30htkub1.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp30htkub1.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp30htkub1.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp30htkub1.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp30htkub1.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp30htkub1.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp30htkub1.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpo8npus5x.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmpo8npus5x.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmpo8npus5x.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpo8npus5x.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpo8npus5x.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpo8npus5x.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpo8npus5x.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpo8npus5x.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpo8npus5x.swift:25:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpo8npus5x.swift:25:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpo8npus5x.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmpo8npus5x.swift:25:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[max_index]\n                       ^~~~~~~~~\n/tmp/tmpo8npus5x.swift:25:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var closest_number = min_number\n    var closest_number_index = 0\n    for i, number in numbers {\n        if number < closest_number {\n            closest_number = number\n            closest_number_index = i\n        }\n    }\n    return (closest_number, numbers[closest_number_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7bo07m08.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmp7bo07m08.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmp7bo07m08.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmp7bo07m08.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    for _, number := range numbers {\n        if number == min_number {\n            return (number, max_number)\n        }\n        if number == max_number {\n            return (min_number, number)\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpa48kaacl.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpa48kaacl.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpa48kaacl.swift:19:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpa48kaacl.swift:19:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tfor _, number := range numbers {\n\t\tif number == min_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number == max_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\treturn (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpab5qexkj.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, value := range numbers {\n        if value == min_value {\n            min_index = i\n        }\n        if value == max_value {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpugw67azx.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected 'in' after for-each pattern\n    for i, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tfor _, number := range numbers {\n\t\tif number == min_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number == max_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\treturn (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpab5qexkj.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t\tmin_index = i\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmped450djs.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value: Double = numbers[0]\n\tvar max_value: Double = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\treturn (min_value, max_value)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp40m9nt7x.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmp40m9nt7x.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmp40m9nt7x.swift:19:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmp40m9nt7x.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tfor _, number := range numbers {\n\t\tif number == min_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number == max_number {\n\t\t\tcontinue\n\t\t}\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\treturn (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpab5qexkj.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpab5qexkj.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmprmqxrn1d.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmprmqxrn1d.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmprmqxrn1d.swift:14:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmprmqxrn1d.swift:14:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmprmqxrn1d.swift:14:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmprmqxrn1d.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmprmqxrn1d.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmprmqxrn1d.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i, value := range numbers {\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpogf5jk1h.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmpogf5jk1h.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmpogf5jk1h.swift:11:7: error: expected 'in' after for-each pattern\n        for i, value := range numbers {\n             ^\n/tmp/tmpogf5jk1h.swift:11:7: error: expected Sequence expression for for-each loop\n        for i, value := range numbers {\n             ^\n/tmp/tmpogf5jk1h.swift:19:7: error: expected 'in' after for-each pattern\n        for i, value := range numbers {\n             ^\n/tmp/tmpogf5jk1h.swift:19:7: error: expected Sequence expression for for-each loop\n        for i, value := range numbers {\n             ^\n/tmp/tmpogf5jk1h.swift:25:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpogf5jk1h.swift:25:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpogf5jk1h.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmpogf5jk1h.swift:25:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[max_index]\n                       ^~~~~~~~~\n/tmp/tmpogf5jk1h.swift:25:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> Arra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp06f47wi1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_val := numbers[0]\n\tmin_index := 0\n\tmax_val := numbers[0]\n\tmax_index := 0\n\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_val {\n\t\t\tmin_val = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_val {\n\t\t\tmax_val = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp83zzgn98.swift:9:9: error: consecutive statements on a line must be separated by ';'\n        min_val := numbers[0]\n               ^\n               ;\n/tmp/tmp83zzgn98.swift:9:10: error: expected expression\n        min_val := numbers[0]\n                ^\n/tmp/tmp83zzgn98.swift:14:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp83zzgn98.swift:14:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp83zzgn98.swift:14:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp83zzgn98.swift:9:2: error: cannot find 'min_val' in scope\n        min_val := numbers[0]\n        ^~~~~~~\n/tmp/tmp83zzgn98.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp83zzgn98.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number := range numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpmt9tzseu.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number := range numbers {\n             ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var closest_pair = (min_value, max_value)\n    for _, value := range numbers {\n        if value < closest_pair[0] {\n            closest_pair = (value, closest_pair[1])\n        } else if value > closest_pair[1] {\n            closest_pair = (closest_pair[0], value)\n        }\n    }\n    return closest_pair\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp__87k71q.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmp__87k71q.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmp__87k71q.swift:20:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmp__87k71q.swift:20:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tvar closest_pair = (min_value, max_value)\n\tfor _, value := range numbers {\n\t\tif value < closest_pair[0] {\n\t\t\tclosest_pair = (value, closest_pair[1])\n\t\t}\n\t\tif value > closest_pair[1] {\n\t\t\tclosest_pair = (closest_pair[0], value)\n\t\t}\n\t}\n\treturn closest_pair\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmplh9rjyed.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmplh9rjyed.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmplh9rjyed.swift:20:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmplh9rjyed.swift:20:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // TODO: Implement this function\n    return (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp8_j19zmc/tmp8_j19zmc.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b326ecf1c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b326e9e8b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b326e9e8988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b326e9e77b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp8_j19zmc                        0x000055b0a18ce48e <unavailable> + 5262\n5    libc.so.6                          0x00002b326eedd460 __libc_start_main + 245\n6    tmp8_j19zmc                        0x000055b0a18ce049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar closest_number = min_number\n\tvar closest_index = 0\n\tfor i, number := range numbers {\n\t\tif number < closest_number {\n\t\t\tclosest_number = number\n\t\t\tclosest_index = i\n\t\t}\n\t}\n\treturn closest_number, numbers[closest_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp3qw4ogct.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp3qw4ogct.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp3qw4ogct.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp3qw4ogct.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp3qw4ogct.swift:27:23: error: consecutive statements on a line must be separated by ';'\n        return closest_number, numbers[closest_index]\n                             ^\n                             ;\n/tmp/tmp3qw4ogct.swift:27:23: error: expected expression\n        return closest_number, numbers[closest_index]\n                             ^\n/tmp/tmp3qw4ogct.swift:27:9: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return closest_number, numbers[closest_index]\n               ^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i in numbers {\n        if i < min_number {\n            min_number = i\n        }\n        if i > max_number {\n            max_number = i\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i in range(len(numbers)) {\n        if numbers[i] == min_number {\n            min_index = i\n        }\n        if numbers[i] == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp49wsr1mp.swift:21:14: error: cannot find 'range' in scope\n    for i in range(len(numbers)) {\n             ^~~~~\n/tmp/tmp49wsr1mp.swift:21:20: error: cannot find 'len' in scope\n    for i in range(len(numbers)) {\n                   ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\treturn (min_value, max_value)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpurn8wmes.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmpurn8wmes.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmpurn8wmes.swift:19:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmpurn8wmes.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tfor _, number := range numbers {\n\t\tif number == min_number {\n\t\t\treturn (number, max_number)\n\t\t}\n\t\tif number == max_number {\n\t\t\treturn (min_number, number)\n\t\t}\n\t}\n\treturn (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp6aj3ddxl.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6aj3ddxl.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6aj3ddxl.swift:19:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6aj3ddxl.swift:19:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, value := range numbers {\n        if value == min_value {\n            min_index = index\n        }\n        if value == max_value {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpa4gezghg.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpa4gezghg.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpa4gezghg.swift:21:14: error: expected 'in' after for-each pattern\n    for index, value := range numbers {\n             ^\n/tmp/tmpa4gezghg.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, value := range numbers {\n        if value == min_value {\n            min_index = i\n        }\n        if value == max_value {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpugw67azx.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected 'in' after for-each pattern\n    for i, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7oyxf9i5.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp7oyxf9i5.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\treturn (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp4aa2bj1w/tmp4aa2bj1w.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1198dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1195d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1195d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1195d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4aa2bj1w                        0x000055facebf048e <unavailable> + 5262\n5    libc.so.6                          0x00002ba119ac7460 __libc_start_main + 245\n6    tmp4aa2bj1w                        0x000055facebf0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar closest_number = min_number\n\tvar closest_index = 0\n\tfor i, number := range numbers {\n\t\tif number < closest_number {\n\t\t\tclosest_number = number\n\t\t\tclosest_index = i\n\t\t}\n\t}\n\treturn (closest_number, numbers[closest_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpvqi3v40d.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpvqi3v40d.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpcy69xvvx.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    let min_value = numbers[0]\n    let max_value = numbers[0]\n    for _, number in numbers {\n        if number < min_value {\n            min_value = number\n        }\n        if number > max_value {\n            max_value = number\n        }\n    }\n    let min_index = 0\n    let max_index = 0\n    for i, number in numbers {\n        if number == min_value {\n            min_index = i\n        }\n        if number == max_value {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpqtd1g578.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpqtd1g578.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpqtd1g578.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpqtd1g578.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for i in range(1, len(numbers)) {\n        if numbers[i] < min_value {\n            min_value = numbers[i]\n        }\n        if numbers[i] > max_value {\n            max_value = numbers[i]\n        }\n    }\n    return (min_value, max_value)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpnutqmtln.swift:11:14: error: cannot find 'range' in scope\n    for i in range(1, len(numbers)) {\n             ^~~~~\n/tmp/tmpnutqmtln.swift:11:23: error: cannot find 'len' in scope\n    for i in range(1, len(numbers)) {\n                      ^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // TODO: Implement this function\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpi9_wkvgy.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpi9_wkvgy.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, value := range numbers {\n        if value == min_value {\n            min_index = index\n        }\n        if value == max_value {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpa4gezghg.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpa4gezghg.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpa4gezghg.swift:21:14: error: expected 'in' after for-each pattern\n    for index, value := range numbers {\n             ^\n/tmp/tmpa4gezghg.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar closest_number = min_number\n\tvar closest_number_index = 0\n\tfor i, number := range numbers {\n\t\tif number < closest_number {\n\t\t\tclosest_number = number\n\t\t\tclosest_number_index = i\n\t\t}\n\t}\n\treturn closest_number, numbers[closest_number_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7r38we9k.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp7r38we9k.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp7r38we9k.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp7r38we9k.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp7r38we9k.swift:27:23: error: consecutive statements on a line must be separated by ';'\n        return closest_number, numbers[closest_number_index]\n                             ^\n                             ;\n/tmp/tmp7r38we9k.swift:27:23: error: expected expression\n        return closest_number, numbers[closest_number_index]\n                             ^\n/tmp/tmp7r38we9k.swift:27:9: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return closest_number, numbers[closest_number_index]\n               ^~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4x8pvjpi.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4x8pvjpi.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4x8pvjpi.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4x8pvjpi.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4x8pvjpi.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4x8pvjpi.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4x8pvjpi.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4x8pvjpi.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4x8pvjpi.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4x8pvjpi.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp4x8pvjpi.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number: Double = numbers[0]\n    var max_number: Double = numbers[0]\n    for i in numbers {\n        if i < min_number {\n            min_number = i\n        }\n        if i > max_number {\n            max_number = i\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmposuisute/tmposuisute.swift:35: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002abfbee25c80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002abfbeb1cb6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002abfbeb1c988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002abfbeb1b7b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmposuisute                        0x000055bb1533564e <unavailable> + 5710\n5    libc.so.6                          0x00002abfbf011460 __libc_start_main + 245\n6    tmposuisute                        0x000055bb15335209 <unavailable> + 4617\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, value := range numbers {\n\t\tif value == min_value {\n\t\t\tmin_index = i\n\t\t}\n\t\tif value == max_value {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp8tyj2d8g.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmp8tyj2d8g.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmp8tyj2d8g.swift:21:7: error: expected 'in' after for-each pattern\n        for i, value := range numbers {\n             ^\n/tmp/tmp8tyj2d8g.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, value := range numbers {\n             ^\n/tmp/tmp8tyj2d8g.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp8tyj2d8g.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp8tyj2d8g.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, value := range numbers {\n\t\tif value < min_value {\n\t\t\tmin_value = value\n\t\t}\n\t\tif value > max_value {\n\t\t\tmax_value = value\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, value := range numbers {\n\t\tif value == min_value {\n\t\t\tmin_index = i\n\t\t}\n\t\tif value == max_value {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmprz7zto65.swift:11:7: error: expected 'in' after for-each pattern\n        for _, value := range numbers {\n             ^\n/tmp/tmprz7zto65.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, value := range numbers {\n             ^\n/tmp/tmprz7zto65.swift:21:7: error: expected 'in' after for-each pattern\n        for i, value := range numbers {\n             ^\n/tmp/tmprz7zto65.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, value := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = i\n        }\n        if number > max_number {\n            max_number = number\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpkl46nhu0.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpkl46nhu0.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t\tmin_index = i\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmped450djs.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_diff = math.MaxFloat64\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i := 0; i < len(numbers); i++ {\n\t\tdiff := math.Abs(numbers[i] - numbers[0])\n\t\tif diff < min_diff {\n\t\t\tmin_diff = diff\n\t\t\tmin_index = i\n\t\t}\n\t\tdiff = math.Abs(numbers[i] - numbers[len(numbers)-1])\n\t\tif diff < min_diff {\n\t\t\tmin_diff = diff\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp57i0br5a.swift:12:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp57i0br5a.swift:12:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp57i0br5a.swift:12:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmp57i0br5a.swift:13:7: error: consecutive statements on a line must be separated by ';'\n                diff := math.Abs(numbers[i] - numbers[0])\n                    ^\n                    ;\n/tmp/tmp57i0br5a.swift:13:8: error: expected expression\n                diff := math.Abs(numbers[i] - numbers[0])\n                     ^\n/tmp/tmp57i0br5a.swift:24:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp57i0br5a.swift:24:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp57i0br5a.swift:9:17: error: cannot find 'math' in scope\n        var min_diff = math.MaxFloat64\n                       ^~~~\n/tmp/tmp57i0br5a.swift:24:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_val := numbers[0]\n\tmin_index := 0\n\tmax_val := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_val {\n\t\t\tmin_val = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_val {\n\t\t\tmax_val = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpt5prta0q.swift:9:9: error: consecutive statements on a line must be separated by ';'\n        min_val := numbers[0]\n               ^\n               ;\n/tmp/tmpt5prta0q.swift:9:10: error: expected expression\n        min_val := numbers[0]\n                ^\n/tmp/tmpt5prta0q.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpt5prta0q.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpt5prta0q.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpt5prta0q.swift:9:2: error: cannot find 'min_val' in scope\n        min_val := numbers[0]\n        ^~~~~~~\n/tmp/tmpt5prta0q.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpt5prta0q.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i, num := range numbers {\n\t\tif num < min_number {\n\t\t\tmin_number = num\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i, num := range numbers {\n\t\tif num > max_number {\n\t\t\tmax_number = num\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpo97s6hjc.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpo97s6hjc.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpo97s6hjc.swift:11:7: error: expected 'in' after for-each pattern\n        for i, num := range numbers {\n             ^\n/tmp/tmpo97s6hjc.swift:11:7: error: expected Sequence expression for for-each loop\n        for i, num := range numbers {\n             ^\n/tmp/tmpo97s6hjc.swift:19:7: error: expected 'in' after for-each pattern\n        for i, num := range numbers {\n             ^\n/tmp/tmpo97s6hjc.swift:19:7: error: expected Sequence expression for for-each loop\n        for i, num := range numbers {\n             ^\n/tmp/tmpo97s6hjc.swift:25:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpo97s6hjc.swift:25:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpo97s6hjc.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpo97s6hjc.swift:25:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[max_index]\n                       ^~~~~~~~~\n/tmp/tmpo97s6hjc.swift:25:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> Arra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpdk3afz4j.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // Write your code here\n    return (numbers[0], numbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmpaynxq9ny/tmpaynxq9ny.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aadde19dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaddde94b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaddde94988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaddde937b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpaynxq9ny                        0x00005648382274de <unavailable> + 5342\n5    libc.so.6                          0x00002aadde389460 __libc_start_main + 245\n6    tmpaynxq9ny                        0x0000564838227099 <unavailable> + 4249\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tmax_number := numbers[0]\n\tmax_index := 0\n\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp07u_kjs3.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmp07u_kjs3.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmp07u_kjs3.swift:14:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp07u_kjs3.swift:14:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp07u_kjs3.swift:14:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp07u_kjs3.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmp07u_kjs3.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp07u_kjs3.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpkx0_nz0d.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpkx0_nz0d.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpkx0_nz0d.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpkx0_nz0d.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n/tmp/tmpkx0_nz0d.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpkx0_nz0d.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpkx0_nz0d.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_value {\n\t\t\tmin_value = number\n\t\t}\n\t\tif number > max_value {\n\t\t\tmax_value = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_value {\n\t\t\tmin_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tif number == max_value {\n\t\t\tmax_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp82tfs1sp.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp82tfs1sp.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp82tfs1sp.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp82tfs1sp.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp82tfs1sp.swift:27:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp82tfs1sp.swift:27:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7oyxf9i5.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp7oyxf9i5.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // Write your code here\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpmy1laqk4.swift:12:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpmy1laqk4.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpjnzz76sm.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpjnzz76sm.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = index\n        }\n        if number > max_number {\n            max_number = number\n            max_index = index\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpfefinpgl.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i, number := range numbers {\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpdk3afz4j.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpdk3afz4j.swift:27:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i += 1 {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpuoo54u9i.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n            <#type#>\n/tmp/tmpuoo54u9i.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n/tmp/tmpuoo54u9i.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // Write your code here\n    return (numbers[0], numbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmpaynxq9ny/tmpaynxq9ny.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aadde19dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaddde94b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaddde94988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaddde937b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpaynxq9ny                        0x00005648382274de <unavailable> + 5342\n5    libc.so.6                          0x00002aadde389460 __libc_start_main + 245\n6    tmpaynxq9ny                        0x0000564838227099 <unavailable> + 4249\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tmax_value := numbers[0]\n\tmax_index := 0\n\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpg9ugzsg4.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmpg9ugzsg4.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmpg9ugzsg4.swift:14:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpg9ugzsg4.swift:14:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpg9ugzsg4.swift:14:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpg9ugzsg4.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmpg9ugzsg4.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpg9ugzsg4.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_diff = math.MaxFloat64\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i := 0; i < len(numbers); i++ {\n\t\tfor j := 0; j < len(numbers); j++ {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdiff := numbers[i] - numbers[j]\n\t\t\tif diff < 0 {\n\t\t\t\tdiff = -diff\n\t\t\t}\n\t\t\tif diff < min_diff {\n\t\t\t\tmin_diff = diff\n\t\t\t\tmin_index = i\n\t\t\t\tmax_index = j\n\t\t\t}\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpkf60z401.swift:12:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpkf60z401.swift:12:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpkf60z401.swift:12:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpkf60z401.swift:13:10: error: expected type\n                for j := 0; j < len(numbers); j++ {\n                       ^\n                        <#type#>\n/tmp/tmpkf60z401.swift:13:10: error: expected 'in' after for-each pattern\n                for j := 0; j < len(numbers); j++ {\n                       ^\n/tmp/tmpkf60z401.swift:13:10: error: expected Sequence expression for for-each loop\n                for j := 0; j < len(numbers); j++ {\n                       ^\n/tmp/tmpkf60z401.swift:17:8: error: consecutive statements on a line must be separated by ';'\n                        diff := numbers[i] - numbers[j]\n                            ^\n                            ;\n/tmp/tmpkf60z401.swift:17:9: error: expected expression\n                        diff := numbers[i] - numbers[j]\n                             ^\n/tmp/tmpkf60z401.swift:28:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmpkf60z401.swift:28:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmpkf60z401.swift:9:17: error: cannot find 'math' in scope\n        var min_diff = math.MaxFloat64\n                       ^~~~\n/tmp/tmpkf60z401.swift:28:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i += 1 {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpuoo54u9i.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n            <#type#>\n/tmp/tmpuoo54u9i.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n/tmp/tmpuoo54u9i.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i += 1 {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i, number := range numbers {\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpov2lh7f3.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpov2lh7f3.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpov2lh7f3.swift:11:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpov2lh7f3.swift:11:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpov2lh7f3.swift:19:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpov2lh7f3.swift:19:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmpov2lh7f3.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpov2lh7f3.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpov2lh7f3.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement find_closest_elements\n\treturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpf4b9zmpk.swift:10:2: error: non-void function should return a value\n        return\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7oyxf9i5.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp7oyxf9i5.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp6i83molh.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp6i83molh.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp6i83molh.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpt8g9ial7.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpt8g9ial7.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp06f47wi1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp06f47wi1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number := range numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp06f47wi1.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number := range numbers {\n         ^\n/tmp/tmp06f47wi1.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = i\n        }\n        if number > max_number {\n            max_number = number\n            max_index = i\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpnr5j31fp.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number := range numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpmt9tzseu.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number := range numbers {\n             ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmphsm74zq_.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmphsm74zq_.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmphsm74zq_.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmphsm74zq_.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmphsm74zq_.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmphsm74zq_.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmphsm74zq_.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmphsm74zq_.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmphsm74zq_.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmphsm74zq_.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpl_qeznsf.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmpl_qeznsf.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\tnumbers.sort()\n\treturn numbers[0], numbers[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpijdl1h8z.swift:11:19: error: consecutive statements on a line must be separated by ';'\n        return numbers[0], numbers[1]\n                         ^\n                         ;\n/tmp/tmpijdl1h8z.swift:11:19: error: expected expression\n        return numbers[0], numbers[1]\n                         ^\n/tmp/tmpijdl1h8z.swift:10:10: error: cannot use mutating member on immutable value: 'numbers' is a 'let' constant\n        numbers.sort()\n        ~~~~~~~ ^\n/tmp/tmpijdl1h8z.swift:11:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[0], numbers[1]\n               ~~~~~~~^~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t\tmin_index = i\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmped450djs.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmped450djs.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for _, value := range numbers {\n        if value < min_value {\n            min_value = value\n        }\n        if value > max_value {\n            max_value = value\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, value := range numbers {\n        if value == min_value {\n            min_index = i\n        }\n        if value == max_value {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpugw67azx.swift:11:10: error: expected 'in' after for-each pattern\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected 'in' after for-each pattern\n    for i, value := range numbers {\n         ^\n/tmp/tmpugw67azx.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, value := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var closest_number = min_number\n    var closest_index = 0\n    for i, number in numbers {\n        if number < closest_number {\n            closest_number = number\n            closest_index = i\n        }\n    }\n    return (closest_number, numbers[closest_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmptj5ekis4.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmptj5ekis4.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmptj5ekis4.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmptj5ekis4.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\treturn (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp4aa2bj1w/tmp4aa2bj1w.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1198dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1195d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1195d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1195d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4aa2bj1w                        0x000055facebf048e <unavailable> + 5262\n5    libc.so.6                          0x00002ba119ac7460 __libc_start_main + 245\n6    tmp4aa2bj1w                        0x000055facebf0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_value = numbers[0]\n\tvar max_value = numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i := 0; i < len(numbers); i++ {\n\t\tif numbers[i] == min_value {\n\t\t\tmin_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i := 0; i < len(numbers); i++ {\n\t\tif numbers[i] == max_value {\n\t\t\tmax_index = i\n\t\t\tbreak\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpep7l2ujm.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpep7l2ujm.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpep7l2ujm.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpep7l2ujm.swift:21:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpep7l2ujm.swift:21:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpep7l2ujm.swift:21:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpep7l2ujm.swift:27:9: error: expected type\n        for i := 0; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpep7l2ujm.swift:27:9: error: expected 'in' after for-each pattern\n        for i := 0; i < len(numbers); i++ {\n               ^\n/tmp/tmpep7l2ujm.swift:27:9: error: expected Sequence expression for for-each loop\n        for i := 0; i < len(numbers); i++ {\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    // Write your code here\n    return (numbers[0], numbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmpaynxq9ny/tmpaynxq9ny.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002aadde19dc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002aaddde94b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002aaddde94988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002aaddde937b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpaynxq9ny                        0x00005648382274de <unavailable> + 5342\n5    libc.so.6                          0x00002aadde389460 __libc_start_main + 245\n6    tmpaynxq9ny                        0x0000564838227099 <unavailable> + 4249\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] < min_number {\n            min_number = numbers[i]\n        }\n        if numbers[i] > max_number {\n            max_number = numbers[i]\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpg12ripkp.swift:11:12: error: expected type\n    for i := 1; i < len(numbers); i++ {\n           ^\n            <#type#>\n/tmp/tmpg12ripkp.swift:11:12: error: expected 'in' after for-each pattern\n    for i := 1; i < len(numbers); i++ {\n           ^\n/tmp/tmpg12ripkp.swift:11:12: error: expected Sequence expression for for-each loop\n    for i := 1; i < len(numbers); i++ {\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor i, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = i\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp6i83molh.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected 'in' after for-each pattern\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:21:7: error: expected Sequence expression for for-each loop\n        for i, number := range numbers {\n             ^\n/tmp/tmp6i83molh.swift:29:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[max_index]\n                                 ^\n                                 ;\n/tmp/tmp6i83molh.swift:29:27: error: expected expression\n        return numbers[min_index], numbers[max_index]\n                                 ^\n/tmp/tmp6i83molh.swift:29:16: error: cannot convert return expression of type 'Double' to return type '(Double, Double)'\n        return numbers[min_index], numbers[max_index]\n               ~~~~~~~^~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement this function\n\treturn (0.0, 0.0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "tmp4aa2bj1w/tmp4aa2bj1w.swift:26: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002ba1198dbc80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002ba1195d2b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002ba1195d2988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002ba1195d17b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmp4aa2bj1w                        0x000055facebf048e <unavailable> + 5262\n5    libc.so.6                          0x00002ba119ac7460 __libc_start_main + 245\n6    tmp4aa2bj1w                        0x000055facebf0049 <unavailable> + 4169\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp7oyxf9i5.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmp7oyxf9i5.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = i\n        }\n        if number > max_number {\n            max_number = number\n            max_index = i\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpnr5j31fp.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpnr5j31fp.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_number := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_number {\n\t\t\tmin_number = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_number := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_number {\n\t\t\tmax_number = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpagquydma.swift:9:12: error: consecutive statements on a line must be separated by ';'\n        min_number := numbers[0]\n                  ^\n                  ;\n/tmp/tmpagquydma.swift:9:13: error: expected expression\n        min_number := numbers[0]\n                   ^\n/tmp/tmpagquydma.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmpagquydma.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmpagquydma.swift:9:2: error: cannot find 'min_number' in scope\n        min_number := numbers[0]\n        ^~~~~~~~~~\n/tmp/tmpagquydma.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmpagquydma.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for i, number in numbers {\n        if number == min_number {\n            min_index = i\n        }\n        if number == max_number {\n            max_index = i\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpcy69xvvx.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:21:10: error: expected 'in' after for-each pattern\n    for i, number in numbers {\n         ^\n/tmp/tmpcy69xvvx.swift:21:10: error: expected Sequence expression for for-each loop\n    for i, number in numbers {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_value := numbers[0]\n\tmin_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\tmax_value := numbers[0]\n\tmax_index := 0\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmp9qyajm7y.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_value := numbers[0]\n                 ^\n                 ;\n/tmp/tmp9qyajm7y.swift:9:12: error: expected expression\n        min_value := numbers[0]\n                  ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp9qyajm7y.swift:19:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:19:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp9qyajm7y.swift:9:2: error: cannot find 'min_value' in scope\n        min_value := numbers[0]\n        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmp9qyajm7y.swift:25:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number in numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number in numbers {\n        if number < min_number {\n            min_number = number\n            min_index = index\n        }\n        if number > max_number {\n            max_number = number\n            max_index = index\n        }\n    }\n    return (min_number, max_number)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpfefinpgl.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number in numbers {\n         ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number in numbers {\n             ^\n/tmp/tmpfefinpgl.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number in numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t}\n\treturn numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmp4_wyha4e.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmp4_wyha4e.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmp4_wyha4e.swift:11:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:11:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmp4_wyha4e.swift:17:27: error: consecutive statements on a line must be separated by ';'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n                                 ;\n/tmp/tmp4_wyha4e.swift:17:27: error: expected expression\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                                 ^\n/tmp/tmp4_wyha4e.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:17: error: cannot find 'min_index' in scope\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                       ^~~~~~~~~\n/tmp/tmp4_wyha4e.swift:17:16: error: no 'subscript' candidates produce the expected contextual result type '(Double, Double)'\n        return numbers[min_index], numbers[(min_index + 1) % len(numbers)]\n                      ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Double', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note: 'subscript(_:)' produces 'ArraySlice<Double>', not the expected contextual result type '(Double, Double)'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n                      ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tmin_index := 0\n\tmin_value := numbers[0]\n\tmax_index := 0\n\tmax_value := numbers[0]\n\tfor i := 1; i < len(numbers); i++ {\n\t\tif numbers[i] < min_value {\n\t\t\tmin_value = numbers[i]\n\t\t\tmin_index = i\n\t\t}\n\t\tif numbers[i] > max_value {\n\t\t\tmax_value = numbers[i]\n\t\t\tmax_index = i\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmps9llchug.swift:9:11: error: consecutive statements on a line must be separated by ';'\n        min_index := 0\n                 ^\n                 ;\n/tmp/tmps9llchug.swift:9:12: error: expected expression\n        min_index := 0\n                  ^\n/tmp/tmps9llchug.swift:13:9: error: expected type\n        for i := 1; i < len(numbers); i++ {\n               ^\n                <#type#>\n/tmp/tmps9llchug.swift:13:9: error: expected 'in' after for-each pattern\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:13:9: error: expected Sequence expression for for-each loop\n        for i := 1; i < len(numbers); i++ {\n               ^\n/tmp/tmps9llchug.swift:9:2: error: cannot find 'min_index' in scope\n        min_index := 0\n        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:18: error: cannot find 'min_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                        ^~~~~~~~~\n/tmp/tmps9llchug.swift:23:38: error: cannot find 'max_index' in scope\n        return (numbers[min_index], numbers[max_index])\n                                            ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n    var min_number = numbers[0]\n    var max_number = numbers[0]\n    for _, number := range numbers {\n        if number < min_number {\n            min_number = number\n        }\n        if number > max_number {\n            max_number = number\n        }\n    }\n    var min_index = 0\n    var max_index = 0\n    for index, number := range numbers {\n        if number == min_number {\n            min_index = index\n        }\n        if number == max_number {\n            max_index = index\n        }\n    }\n    return (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpmt9tzseu.swift:11:10: error: expected 'in' after for-each pattern\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:11:10: error: expected Sequence expression for for-each loop\n    for _, number := range numbers {\n         ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected 'in' after for-each pattern\n    for index, number := range numbers {\n             ^\n/tmp/tmpmt9tzseu.swift:21:14: error: expected Sequence expression for for-each loop\n    for index, number := range numbers {\n             ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\t// TODO: Implement find_closest_elements\n\treturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "/tmp/tmpf4b9zmpk.swift:10:2: error: non-void function should return a value\n        return\n        ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// From a supplied array of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double, Double) {\n\tvar min_number = numbers[0]\n\tvar max_number = numbers[0]\n\tfor _, number := range numbers {\n\t\tif number < min_number {\n\t\t\tmin_number = number\n\t\t}\n\t\tif number > max_number {\n\t\t\tmax_number = number\n\t\t}\n\t}\n\tvar min_index = 0\n\tvar max_index = 0\n\tfor index, number := range numbers {\n\t\tif number == min_number {\n\t\t\tmin_index = index\n\t\t}\n\t\tif number == max_number {\n\t\t\tmax_index = index\n\t\t}\n\t}\n\treturn (numbers[min_index], numbers[max_index])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "/tmp/tmpi5w1d_n7.swift:11:7: error: expected 'in' after for-each pattern\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:11:7: error: expected Sequence expression for for-each loop\n        for _, number := range numbers {\n             ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected 'in' after for-each pattern\n        for index, number := range numbers {\n                 ^\n/tmp/tmpi5w1d_n7.swift:21:11: error: expected Sequence expression for for-each loop\n        for index, number := range numbers {\n                 ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}