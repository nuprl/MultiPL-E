{
  "name": "HumanEval_7_filter_by_substring",
  "language": "swift",
  "prompt": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n",
  "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\tif strings == nil {\n\t\treturn nil\n\t}\n\tvar result = make([]String, 0)\n\tfor _, s := range strings {\n\t\tif strings.Contains(s, substring) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpakhr1a0k.swift:11:22: error: expected ',' separator\n        var result = make([]String, 0)\n                            ^\n                            ,\n/tmp/tmpakhr1a0k.swift:12:7: error: expected 'in' after for-each pattern\n        for _, s := range strings {\n             ^\n/tmp/tmpakhr1a0k.swift:12:7: error: expected Sequence expression for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmpakhr1a0k.swift:8:13: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n        if strings == nil {\n           ~~~~~~~ ^  ~~~\n/tmp/tmpakhr1a0k.swift:9:10: error: 'nil' is incompatible with return type '[String]'\n                return nil\n                       ^\n/tmp/tmpakhr1a0k.swift:11:15: error: cannot find 'make' in scope\n        var result = make([]String, 0)\n                     ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result []String\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0bojl7mi.swift:11:15: error: consecutive statements on a line must be separated by ';'\n    var result []String\n              ^\n              ;\n/tmp/tmp0bojl7mi.swift:11:18: error: consecutive statements on a line must be separated by ';'\n    var result []String\n                 ^\n                 ;\n/tmp/tmp0bojl7mi.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmp0bojl7mi.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmp0bojl7mi.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmp0bojl7mi.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmp0bojl7mi.swift:11:9: error: type annotation missing in pattern\n    var result []String\n        ^\n/tmp/tmp0bojl7mi.swift:11:16: error: empty collection literal requires an explicit type\n    var result []String\n               ^~\n/tmp/tmp0bojl7mi.swift:11:16: warning: expression of type '[Any]' is unused\n    var result []String\n               ^~\n/tmp/tmp0bojl7mi.swift:11:18: error: expected member name or constructor call after type name\n    var result []String\n                 ^\n/tmp/tmp0bojl7mi.swift:11:18: note: add arguments after the type to construct a value of the type\n    var result []String\n                 ^\n                       ()\n/tmp/tmp0bojl7mi.swift:11:18: note: use '.self' to reference the type object\n    var result []String\n                 ^\n                       .self\n/tmp/tmp0bojl7mi.swift:11:18: warning: expression of type 'String.Type' is unused\n    var result []String\n                 ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpoh5d1bz7.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpoh5d1bz7.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmpoh5d1bz7.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result: [String] = []\n    for _, string := range strings {\n        if strings.Contains(string, substring) {\n            result = append(result, string)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpnpl_e46u.swift:12:10: error: expected 'in' after for-each pattern\n    for _, string := range strings {\n         ^\n/tmp/tmpnpl_e46u.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, string := range strings {\n         ^\n/tmp/tmpnpl_e46u.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpnpl_e46u.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    var result: [String] = []\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp6w4wzbrz.swift:9:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmp6w4wzbrz.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) -> s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp9l_okrd2.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) -> s.contains(substring))\n                              ^\n/tmp/tmp9l_okrd2.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) -> s.contains(substring))\n                                  ^\n/tmp/tmp9l_okrd2.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) -> s.contains(substring))\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(substring.contains)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "tmpudiodhft/tmpudiodhft.swift:25: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b352726ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3526f61b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3526f61988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3526f607b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpudiodhft                        0x00005577a86a1987 <unavailable> + 6535\n5    libc.so.6                          0x00002b3527456460 __libc_start_main + 245\n6    tmpudiodhft                        0x00005577a86a1309 <unavailable> + 4873\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) -> s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpi1e8yqin.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) -> s.contains(substring))\n                          ^\n/tmp/tmpi1e8yqin.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) -> s.contains(substring))\n                              ^\n/tmp/tmpi1e8yqin.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpi1e8yqin.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpi1e8yqin.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) -> s.contains(substring))\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result: [String] = []\n    for _, string := range strings {\n        if strings.Contains(string, substring) {\n            result = append(result, string)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpnpl_e46u.swift:12:10: error: expected 'in' after for-each pattern\n    for _, string := range strings {\n         ^\n/tmp/tmpnpl_e46u.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, string := range strings {\n         ^\n/tmp/tmpnpl_e46u.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpnpl_e46u.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(substring.contains)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "tmpudiodhft/tmpudiodhft.swift:25: Assertion failed\nCurrent stack trace:\n0    libswiftCore.so                    0x00002b352726ac80 _swift_stdlib_reportFatalErrorInFile + 112\n1    libswiftCore.so                    0x00002b3526f61b6c <unavailable> + 1436524\n2    libswiftCore.so                    0x00002b3526f61988 <unavailable> + 1436040\n3    libswiftCore.so                    0x00002b3526f607b0 _assertionFailure(_:_:file:line:flags:) + 699\n4    tmpudiodhft                        0x00005577a86a1987 <unavailable> + 6535\n5    libc.so.6                          0x00002b3527456460 __libc_start_main + 245\n6    tmpudiodhft                        0x00005577a86a1309 <unavailable> + 4873\n",
      "exit_code": -4,
      "status": "Exception"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result: [String] = []\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpkmyh7qi2.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpkmyh7qi2.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpkmyh7qi2.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpkmyh7qi2.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(lambda x: substring in x)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpu_1262vp.swift:11:34: error: expected ',' separator\n    return strings.filter(lambda x: substring in x)\n                                 ^\n                                ,\n/tmp/tmpu_1262vp.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpu_1262vp.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpu_1262vp.swift:11:27: error: cannot find 'lambda' in scope\n    return strings.filter(lambda x: substring in x)\n                          ^~~~~~\n/tmp/tmpu_1262vp.swift:11:37: error: extra argument 'x' in call\n    return strings.filter(lambda x: substring in x)\n                         ~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpu_1262vp.swift:11:27: error: converting non-escaping value to '(String) throws -> Bool' may allow it to escape\n    return strings.filter(lambda x: substring in x)\n                          ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpoh5d1bz7.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpoh5d1bz7.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmpoh5d1bz7.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpoh5d1bz7.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpoh5d1bz7.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmpoh5d1bz7.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result: [String] = []\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpkmyh7qi2.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpkmyh7qi2.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpkmyh7qi2.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpkmyh7qi2.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\tif strings == nil {\n\t\treturn nil\n\t}\n\treturn strings.filter(func(s: String) bool {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp33kg7z7y.swift:11:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) bool {\n                              ^\n/tmp/tmp33kg7z7y.swift:11:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) bool {\n                                  ^\n/tmp/tmp33kg7z7y.swift:8:13: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n        if strings == nil {\n           ~~~~~~~ ^  ~~~\n/tmp/tmp33kg7z7y.swift:9:10: error: 'nil' is incompatible with return type '[String]'\n                return nil\n                       ^\n/tmp/tmp33kg7z7y.swift:11:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) bool {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\tif strings == nil {\n\t\treturn nil\n\t}\n\treturn strings.filter(func(s: String) bool {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp33kg7z7y.swift:11:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) bool {\n                              ^\n/tmp/tmp33kg7z7y.swift:11:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) bool {\n                                  ^\n/tmp/tmp33kg7z7y.swift:8:13: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n        if strings == nil {\n           ~~~~~~~ ^  ~~~\n/tmp/tmp33kg7z7y.swift:9:10: error: 'nil' is incompatible with return type '[String]'\n                return nil\n                       ^\n/tmp/tmp33kg7z7y.swift:11:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) bool {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return filter(strings, func(s: String) -> bool {\n        return strings.contains(s, substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpkfj4y1yj.swift:11:28: error: expected expression in list of expressions\n    return filter(strings, func(s: String) -> bool {\n                           ^\n/tmp/tmpkfj4y1yj.swift:11:32: error: expected identifier in function declaration\n    return filter(strings, func(s: String) -> bool {\n                               ^\n/tmp/tmpkfj4y1yj.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpkfj4y1yj.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpkfj4y1yj.swift:11:12: error: cannot find 'filter' in scope\n    return filter(strings, func(s: String) -> bool {\n           ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result: [String] = []\n    for _, v := range strings {\n        if strings.Contains(v, substring) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp23f949wq.swift:12:10: error: expected 'in' after for-each pattern\n    for _, v := range strings {\n         ^\n/tmp/tmp23f949wq.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, v := range strings {\n         ^\n/tmp/tmp23f949wq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmp23f949wq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = make([]String, 0)\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpaeud26l9.swift:11:25: error: expected ',' separator\n    var result = make([]String, 0)\n                        ^\n                        ,\n/tmp/tmpaeud26l9.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpaeud26l9.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpaeud26l9.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpaeud26l9.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpaeud26l9.swift:11:18: error: cannot find 'make' in scope\n    var result = make([]String, 0)\n                 ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    var result: [String] = []\n    for _, s: String in strings {\n        if s.contains(substring) {\n            result.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpwa__b9my.swift:9:10: error: expected 'in' after for-each pattern\n    for _, s: String in strings {\n         ^\n/tmp/tmpwa__b9my.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, s: String in strings {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return filter(strings, func(s: String) bool {\n        return strings.contains(s, substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpmjprrzn8.swift:11:28: error: expected expression in list of expressions\n    return filter(strings, func(s: String) bool {\n                           ^\n/tmp/tmpmjprrzn8.swift:11:32: error: expected identifier in function declaration\n    return filter(strings, func(s: String) bool {\n                               ^\n/tmp/tmpmjprrzn8.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpmjprrzn8.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpmjprrzn8.swift:11:12: error: cannot find 'filter' in scope\n    return filter(strings, func(s: String) bool {\n           ^~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\tif strings == nil {\n\t\treturn nil\n\t}\n\tvar result = make([]String, 0)\n\tfor _, s := range strings {\n\t\tif strings.Contains(s, substring) {\n\t\t\tresult = append(result, s)\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpakhr1a0k.swift:11:22: error: expected ',' separator\n        var result = make([]String, 0)\n                            ^\n                            ,\n/tmp/tmpakhr1a0k.swift:12:7: error: expected 'in' after for-each pattern\n        for _, s := range strings {\n             ^\n/tmp/tmpakhr1a0k.swift:12:7: error: expected Sequence expression for for-each loop\n        for _, s := range strings {\n             ^\n/tmp/tmpakhr1a0k.swift:8:13: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n        if strings == nil {\n           ~~~~~~~ ^  ~~~\n/tmp/tmpakhr1a0k.swift:9:10: error: 'nil' is incompatible with return type '[String]'\n                return nil\n                       ^\n/tmp/tmpakhr1a0k.swift:11:15: error: cannot find 'make' in scope\n        var result = make([]String, 0)\n                     ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    var filtered_strings = []\n    for _, string in strings {\n        if string.contains(substring) {\n            filtered_strings.append(string)\n        }\n    }\n    return filtered_strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmph5fmn6di.swift:9:10: error: expected 'in' after for-each pattern\n    for _, string in strings {\n         ^\n/tmp/tmph5fmn6di.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, string in strings {\n         ^\n/tmp/tmph5fmn6di.swift:8:28: error: empty collection literal requires an explicit type\n    var filtered_strings = []\n                           ^~\n/tmp/tmph5fmn6di.swift:14:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return filtered_strings\n           ^\n/tmp/tmph5fmn6di.swift:14:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return filtered_strings\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    var result: [String] = []\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp6w4wzbrz.swift:9:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmp6w4wzbrz.swift:9:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = make([]String, 0)\n    for _, v := range strings {\n        if strings.Contains(v, substring) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpupddm6s1.swift:11:25: error: expected ',' separator\n    var result = make([]String, 0)\n                        ^\n                        ,\n/tmp/tmpupddm6s1.swift:12:10: error: expected 'in' after for-each pattern\n    for _, v := range strings {\n         ^\n/tmp/tmpupddm6s1.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, v := range strings {\n         ^\n/tmp/tmpupddm6s1.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpupddm6s1.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpupddm6s1.swift:11:18: error: cannot find 'make' in scope\n    var result = make([]String, 0)\n                 ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = []String{}\n    for _, s := range strings {\n        if strings.Contains(s, substring) {\n            result = append(result, s)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl51ne_p5.swift:11:20: error: consecutive statements on a line must be separated by ';'\n    var result = []String{}\n                   ^\n                   ;\n/tmp/tmpl51ne_p5.swift:12:10: error: expected 'in' after for-each pattern\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, s := range strings {\n         ^\n/tmp/tmpl51ne_p5.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpl51ne_p5.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpl51ne_p5.swift:11:18: error: empty collection literal requires an explicit type\n    var result = []String{}\n                 ^~\n/tmp/tmpl51ne_p5.swift:11:20: error: ambiguous use of 'init'\n    var result = []String{}\n                   ^\nSwift.String:2:12: note: found this candidate\n    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12: note: found this candidate\n    public init<Subject>(reflecting subject: Subject)\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: error: cannot convert return expression of type '[Any]' to return type '[String]'\n    return result\n           ^\n/tmp/tmpl51ne_p5.swift:17:12: note: arguments to generic parameter 'Element' ('Any' and 'String') are expected to be equal\n    return result\n           ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) -> s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp9l_okrd2.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) -> s.contains(substring))\n                              ^\n/tmp/tmp9l_okrd2.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) -> s.contains(substring))\n                                  ^\n/tmp/tmp9l_okrd2.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) -> s.contains(substring))\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(x => x.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp4e9ihth3.swift:8:27: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                          ^\n/tmp/tmp4e9ihth3.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(x => x.contains(substring))\n                            ^~\n/tmp/tmp4e9ihth3.swift:8:32: error: cannot find 'x' in scope\n    return strings.filter(x => x.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn s.contains(substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmphy62xwsk.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmphy62xwsk.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmphy62xwsk.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(func(s: String) {\n        return s.contains(substring)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpd88gcnxq.swift:11:27: error: expected expression in list of expressions\n    return strings.filter(func(s: String) {\n                          ^\n/tmp/tmpd88gcnxq.swift:11:31: error: expected identifier in function declaration\n    return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpd88gcnxq.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpd88gcnxq.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpd88gcnxq.swift:11:26: error: missing argument for parameter #1 in call\n    return strings.filter(func(s: String) {\n                         ^\n                         <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    var result = make([]String, 0)\n    for _, string := range strings {\n        if strings.Contains(string, substring) {\n            result = append(result, string)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp1el_af8d.swift:11:25: error: expected ',' separator\n    var result = make([]String, 0)\n                        ^\n                        ,\n/tmp/tmp1el_af8d.swift:12:10: error: expected 'in' after for-each pattern\n    for _, string := range strings {\n         ^\n/tmp/tmp1el_af8d.swift:12:10: error: expected Sequence expression for for-each loop\n    for _, string := range strings {\n         ^\n/tmp/tmp1el_af8d.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmp1el_af8d.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmp1el_af8d.swift:11:18: error: cannot find 'make' in scope\n    var result = make([]String, 0)\n                 ^~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    if strings == nil {\n        return nil\n    }\n    return strings.filter(lambda x: substring in x)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpu_1262vp.swift:11:34: error: expected ',' separator\n    return strings.filter(lambda x: substring in x)\n                                 ^\n                                ,\n/tmp/tmpu_1262vp.swift:8:16: warning: comparing non-optional value of type '[String]' to 'nil' always returns false\n    if strings == nil {\n       ~~~~~~~ ^  ~~~\n/tmp/tmpu_1262vp.swift:9:16: error: 'nil' is incompatible with return type '[String]'\n        return nil\n               ^\n/tmp/tmpu_1262vp.swift:11:27: error: cannot find 'lambda' in scope\n    return strings.filter(lambda x: substring in x)\n                          ^~~~~~\n/tmp/tmpu_1262vp.swift:11:37: error: extra argument 'x' in call\n    return strings.filter(lambda x: substring in x)\n                         ~~~~~~~~~~~^~~~~~~~~~~~~~~\n/tmp/tmpu_1262vp.swift:11:27: error: converting non-escaping value to '(String) throws -> Bool' may allow it to escape\n    return strings.filter(lambda x: substring in x)\n                          ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.includes(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmp0j88p8yb.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                          ^\n/tmp/tmp0j88p8yb.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.includes(substring))\n                            ^~\n/tmp/tmp0j88p8yb.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.includes(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n\treturn strings.filter(func(s: String) {\n\t\treturn strings.contains(s, substring)\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpoh5d1bz7.swift:8:24: error: expected expression in list of expressions\n        return strings.filter(func(s: String) {\n                              ^\n/tmp/tmpoh5d1bz7.swift:8:28: error: expected identifier in function declaration\n        return strings.filter(func(s: String) {\n                                  ^\n/tmp/tmpoh5d1bz7.swift:8:23: error: missing argument for parameter #1 in call\n        return strings.filter(func(s: String) {\n                             ^\n                             <#(String) throws -> Bool#>\nSwift.RangeReplaceableCollection:3:40: note: 'filter' declared here\n    @inlinable public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> Self\n                                       ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "\n/// Filter an input array of strings only for ones that contain given substring\n/// >>> filter_by_substring(strings: [] as [String], substring: \"a\")\n/// [] as [String]\n/// >>> filter_by_substring(strings: [\"abc\", \"bacd\", \"cde\", \"array\"], substring: \"a\")\n/// [\"abc\", \"bacd\", \"array\"]\nfunc filter_by_substring(strings: [String], substring: String) -> [String] {\n    return strings.filter(s => s.contains(substring))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_by_substring(strings: [] as [String], substring: \"john\") == [] as [String])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], substring: \"xx\") == [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"])\nassert(filter_by_substring(strings: [\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], substring: \"run\") == [\"grunt\", \"prune\"])",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "/tmp/tmpl5qph4i0.swift:8:27: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                          ^\n/tmp/tmpl5qph4i0.swift:8:29: error: cannot find operator '=>' in scope\n    return strings.filter(s => s.contains(substring))\n                            ^~\n/tmp/tmpl5qph4i0.swift:8:32: error: cannot find 's' in scope\n    return strings.filter(s => s.contains(substring))\n                               ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}