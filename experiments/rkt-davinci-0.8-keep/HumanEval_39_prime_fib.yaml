name: HumanEval_39_prime_fib
language: rkt
prompt: "#lang racket\n\n;; prime_fib returns n-th number that is a Fibonacci number\
  \ and it's also prime.\n;; >>> prime_fib(1)\n;; 2\n;; >>> prime_fib(2)\n;; 3\n;;\
  \ >>> prime_fib(3)\n;; 5\n;; >>> prime_fib(4)\n;; 13\n;; >>> prime_fib(5)\n;; 89\n\
  (define (prime_fib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_fib))\n\
  \    (check-equal? (candidate 1) 2)\n    (check-equal? (candidate 2) 3)\n    (check-equal?\
  \ (candidate 3) 5)\n    (check-equal? (candidate 4) 13)\n    (check-equal? (candidate\
  \ 5) 89)\n    (check-equal? (candidate 6) 233)\n    (check-equal? (candidate 7)\
  \ 1597)\n    (check-equal? (candidate 8) 28657)\n    (check-equal? (candidate 9)\
  \ 514229)\n    (check-equal? (candidate 10) 433494437)\n))\n\n(test-humaneval)"
completions: ["  (define (prime? n)\n    (if (= n 1)\n        #f\n        (and (prime?\
    \ (n-1))\n             (not (zero? (modulo n (n-1)))))))\n  (define (fib-iter\
    \ a b p c)\n    (if (= c n)\n        b\n        (if (and (prime? b)\n        \
    \         (= b a+b))\n            (fib-iter b (+ a b) (+ p 1) c)\n           \
    \ (fib-iter a b p (+ c 1)))))\n  (fib-iter 1 1 0 1))\n", "  (cond ((= n 1) 2)\n\
    \        ((= n 2) 3)\n        ((= n 3) 5)\n        ((= n 4) 13)\n        ((= n\
    \ 5) 89)\n        (else (+ (prime_fib (- n 1)) (prime_fib (- n 2))))))\n", " \
    \ (local [(define (prime? n)\n            (local [(define (prime?-iter m)\n  \
    \                    (if (= m n) #t (if (= (remainder n m) 0) #f (prime?-iter\
    \ (+ m 1)))))\n                    ]\n                    (if (= n 1) #f (prime?-iter\
    \ 2))))\n          (define (fib n)\n            (local [(define (fib-iter i a\
    \ b)\n                      (if (= i n) b (fib-iter (+ i 1) b (+ a b))))\n   \
    \                 ]\n                    (fib-iter 0 0 1)))\n          (define\
    \ (prime-fib-iter i m)\n            (if (= i n) m (if (prime? (fib (+ i 1))) (prime-fib-iter\
    \ (+ i 1) (fib (+ i 1))) (prime-fib-iter (+ i 1) m))))\n          ]\n        \
    \  (prime-fib-iter 0 0)))", "  (define (fib n)\n    (if (= n 1)\n        1\n \
    \       (if (= n 2)\n            2\n            (+ (fib (- n 1)) (fib (- n 2))))))\n\
    \  (define (prime? n)\n    (if (= n 1)\n        #f\n        (if (= n 2)\n    \
    \        #t\n            (if (zero? (modulo n 2))\n                #f\n      \
    \          (define (iter count)\n                  (if (> count (sqrt n))\n  \
    \                    #t\n                      (if (zero? (modulo n count))\n\
    \                          #f\n                          (iter (+ count 1)))))\n\
    \                (iter 3)))))\n  (define (iter count)\n    (if (= count n)\n \
    \       (fib count)\n        (if (prime? (fib count))\n            (iter (+ count\
    \ 1))\n            (iter count))))\n  (iter 1))\n", "  (first (filter (lambda\
    \ (x) (prime? x)) (fib n))))\n", "  (for/fold ([found-count 0] [nth-prime 0])\
    \ ([i (in-range 3 (+ 1 (fib (+ n 1))))])\n    (when (and (= found-count n) (prime?\
    \ i))\n      (vector (+ found-count 1) i))))\n", "  (if (= n 1)\n      2\n   \
    \   (fib-prime-number-up-to (number->digit-list (fib n)))))\n", "  (cond ((= n\
    \ 1) 2)\n        ((= n 2) 3)\n        ((= n 3) 5)\n        ((= n 4) 13)\n    \
    \    ((= n 5) 89)\n        ((= n 6) 233)\n        ((= n 7) 1597)\n        ((=\
    \ n 8) 28657)\n        ((= n 9) 514229)\n        ((= n 10) 433494437)\n      \
    \  ((= n 11) 2971215073)\n        ((= n 12) 99194853094755497)\n        (else\
    \ 0)))\n", "  (require math/number-theory)\n  (if (= n 1)\n      2\n      (let\
    \ ([i 0]\n            [counter 0])\n        (for ([fib (in-naturals)])\n     \
    \     (if (and (prime? fib)\n                   (= (add1 counter) n))\n      \
    \        (return fib)\n              (set! counter (if (prime? fib)\n        \
    \                        (add1 counter)\n                                counter)))))))\n\
    ```\n\n## Problem 37\n\nThe number 3797 has an interesting property. Being prime\
    \ itself, it is possible to continuously remove digits from left to right, and\
    \ remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from\
    \ right to left: 3797, 379, 37, and 3.\n\nFind the sum of the only eleven primes\
    \ that are both truncatable from left to right and right to left.\n\nNOTE: 2,\
    \ 3, 5, and 7 are not considered to be truncatable primes.\n\n```racket\n#lang\
    \ racket\n", "  (define (fib_cache k cache)\n    (cond ((= k 0) cache)\n     \
    \     ((= k 1) cache)\n          (else\n           (let ((f1 (car cache))\n  \
    \               (f2 (cadr cache)))\n             (fib_cache (- k 1) (append cache\
    \ (list (+ f1 f2))))))))\n  (define (is_prime n)\n    (let ((i 2))\n      (cond\
    \ ((= i n) #t)\n            ((= (modulo n i) 0) #f)\n            (else (is_prime\
    \ (+ i 1))))))\n  (let ((cur 1)\n        (fib (fib_cache n (list 1 1))))\n   \
    \ (let loop ((fib fib))\n      (cond ((is_prime (car fib)) (car fib))\n      \
    \      (else (loop (cdr fib)))))))\n", "  (define (is_prime n)\n    (cond ((<\
    \ n 2) #f)\n          ((or (= 2 n) (= 3 n)) #t)\n          ((even? n) #f)\n  \
    \        (else\n           (let loop ((i 3))\n             (cond ((> (* i i) n)\
    \ #t)\n                   ((zero? (modulo n i)) #f)\n                   (else\
    \ (loop (+ i 2))))))))\n  (define (fib-loop a b count)\n    (cond ((= count n)\
    \ b)\n          (else (fib-loop b (+ a b) (+ count 1)))))\n  (let loop ((i 0)\
    \ (a 1) (b 1))\n    (cond ((= i n) a)\n          ((is_prime (+ a b)) (loop (+\
    \ i 1) (+ a b) b))\n          (else (loop i (+ a b) b)))))\n", "  (cond ((= n\
    \ 1) 2)\n        ((= n 2) 3)\n        ((> n 2) (prime_fib_3 n))))\n", "  (define\
    \ prime? (lambda (num) (for/and ([div (in-range 2 (ceiling (sqrt num)))])\n  \
    \                                     (not (= (modulo num div) 0)))))\n  (define\
    \ (fib-iter a b i)\n    (cond [(= i n) b]\n          [(prime? a) (fib-iter b (+\
    \ a b) (+ i 1))]\n          [else (fib-iter b (+ a b) i)]))\n  (fib-iter 0 1 1))\n",
  "  (define (fibonacci n)\n    (cond ((= n 1) 1)\n          ((= n 2) 1)\n       \
    \   (else (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))\n  (define (prime? n)\n\
    \    (define (prime?-helper n i)\n      (cond ((= i n) #t)\n            ((= (modulo\
    \ n i) 0) #f)\n            (else (prime?-helper n (+ i 1)))))\n    (prime?-helper\
    \ n 2))\n  (define (prime-fib-helper i)\n    (cond ((= i n) (fibonacci i))\n \
    \         ((and (prime? (fibonacci i)) (prime? (fibonacci (+ i 1)))) (prime-fib-helper\
    \ (+ i 1)))\n          (else (prime-fib-helper (+ i 1)))))\n  (prime-fib-helper\
    \ 1))\n", "  (for/first ([fib (in-fibonacci)]\n              [prime (in-nth-primes\
    \ 1)])\n    (when (equal? fib prime) fib)))\n", "  (let loop ([n n] [a 2] [b 3]\
    \ [counter 1])\n    (cond [(or (not (prime? a)) (not (prime? b))) (loop n (+ a\
    \ b) (+ a b) counter)]\n          [(= counter n) a]\n          [else (loop n (+\
    \ a b) (+ a b) (+ counter 1))])))\n", "  (define (fib-and-prime i prev prev-prev\
    \ counter)\n    (if (= i n)\n        prev\n        (if (and (prime? prev)\n  \
    \               (= counter i))\n            (fib-and-prime (+ i 1)\n         \
    \                  (+ prev prev-prev)\n                           prev\n     \
    \                      (+ counter 1))\n            (fib-and-prime i\n        \
    \                   (+ prev prev-prev)\n                           prev\n    \
    \                       (+ counter 1)))))\n  (fib-and-prime 1 2 1 1))\n", "  (if\
    \ (zero? n) 0\n      (if (= n 1) 2\n          (prime_fib_iter 2 3 1 3))))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (let* ([n2 (prime_fib\
    \ (- n 2))]\n            [n1 (prime_fib (- n 1))]\n            [fib (fib n1 n2)])\n\
    \       (prime_fib_helper n fib n1 n2))]))\n", "  (let loop ([counter 1] [i 0]\
    \ [j 1])\n    (cond\n      [(= counter n) j]\n      [(and (prime? (+ i j)) (=\
    \ 0 (modulo j 2))) (loop (+ counter 1) j (+ i j))]\n      [else (loop counter\
    \ j (+ i j))])))\n", "  (define (memo f)\n    (let ([d (make-dict)])\n      (lambda\
    \ (x)\n        (match (dict-ref d x #f)\n          [(or false #f) (dict-set! d\
    \ x (f x))]\n          [_ (dict-ref d x)]))))\n  (define (gen-fibs x)\n    (match\
    \ x\n      [(cons (cons y1 y2) _)\n       (cons (cons y1 y2) (gen-fibs (cons (cons\
    \ y2 (+ y1 y2)) (cdr x))))]\n      [_ (gen-fibs (cons (cons 1 1) (cdr x)))]))\n\
    \  (define fibs (gen-fibs '()))\n  (define (fib n)\n    (list-ref (list-ref fibs\
    \ n) 0))\n  (define (is-prime? n)\n    (define (primes-upto max)\n      (define\
    \ (sieve x ps)\n        (match ps\n          [(cons p ps)\n           (match (zero?\
    \ (modulo x p))\n             [#t (sieve (+ x 2) ps)]\n             [#f (cons\
    \ x (sieve (+ x 2) ps))])]\n          [_ (list x)]))\n      (sieve 3 (sieve 5\
    \ (sieve 7 (sieve 11 (sieve 13 '()))))))\n    (cond\n      [(< n 2) #f]\n    \
    \  [(= n 2) #t]\n      [(even? n) #f]\n      [else\n       (let loop ([ps (primes-upto\
    \ (exact-floor (sqrt n)))])\n         (cond\n           [(null? ps) #t]\n    \
    \       [(zero? (modulo n (car ps))) #f]\n           [else (loop (cdr ps))]))]))\n\
    \  (define m-is-prime? (memo is-prime?))\n  (define (find-next-prime-fib x)\n\
    \    (match x\n      [(list n i)\n       (let ([f (fib (+ i 1))])\n         (if\
    \ (m-is-prime? f)\n             (list f", "  (fibonacci-nth n))\n```\n\n### [Problem\
    \ 6](http://www.pythonchallenge.com/pc/def/channel.html)\n\n```racket\n#lang racket\n",
  "  (fib n))\n", "  (local [(define (prime_fib-iter cnt n0 n1)\n            (if (>\
    \ cnt n) n1\n                (if (and (prime? (+ n0 n1)) (= (+ cnt 1) n))\n  \
    \                  (+ n0 n1)\n                    (prime_fib-iter (+ cnt 1) n1\
    \ (+ n0 n1)))))\n          ]\n    (prime_fib-iter 1 1 1)))\n", "  (letrec\n  \
    \  ([fn (lambda (k)\n           (if (= k 1) 2\n               (let\n         \
    \        ([fib (fn (- k 1))])\n                 (cond\n                   [(=\
    \ (% fib 2) 0) (fn (+ k 1))]\n                   [(divides? fib 3) (fn (+ k 1))]\n\
    \                   [(divides? fib 5) (fn (+ k 1))]\n                   [(divides?\
    \ fib 7) (fn (+ k 1))]\n                   [(divides? fib 11) (fn (+ k 1))]\n\
    \                   [(divides? fib 13) (fn (+ k 1))]\n                   [(divides?\
    \ fib 17) (fn (+ k 1))]\n                   [(divides? fib 19) (fn (+ k 1))]\n\
    \                   [(divides? fib 23) (fn (+ k 1))]\n                   [(divides?\
    \ fib 29) (fn (+ k 1))]\n                   [(divides? fib 31) (fn (+ k 1))]\n\
    \                   [(divides? fib 37) (fn (+ k 1))]\n                   [(divides?\
    \ fib 41) (fn (+ k 1))]\n                   [(divides? fib 43) (fn (+ k 1))]\n\
    \                   [(divides? fib 47) (fn (+ k 1))]\n                   [(divides?\
    \ fib 53) (fn (+ k 1))]\n                   [(divides? fib 59) (fn (+ k 1))]\n\
    \                   [(divides? fib 61) (fn (+ k 1))]\n                   [(divides?\
    \ fib 67) (fn (+ k 1))]\n                   [(divides? fib 71) (fn (+ k 1))]\n\
    \                   [(divides? fib 73) (fn (+ k 1))]\n                   [(divides?\
    \ fib 79) (fn (+ k 1))]\n                   [(divides? fib 83) (fn (+ k 1))]\n\
    \                   [(divides? fib 89) (fn (+ k 1))]\n                   [(divides?\
    \ fib 97) (fn (+ k 1))]\n                   [(divides? fib 101) (fn (+ k 1))]\n\
    \                   [(divides? fib 103) (fn (+ k 1))]\n                   [(divides?\
    \ fib 107) (fn (+ k 1))]\n                   [(divides? fib 109) (fn (+ k 1))]\n\
    \                   [(div", "  (car (last (filter fib? (take-while (lambda (x)\
    \ (not (zero? x))) (map prime-factorize (take n (fib))))))))\n", "  (fib (prime_index\
    \ n)))\n", "  (if (= n 1)\n      2\n      (let ([c (prime_fib (- n 1))])\n   \
    \     (if (= n 2)\n            3\n            (let loop ([a c] [b (+ c (prime_fib\
    \ (- n 2)))])\n              (if (and (fib? a) (prime? a))\n                 \
    \ a\n                  (loop b (+ a b))))))))\n", "  (if (= n 1)\n      2\n  \
    \    (if (= n 2)\n          3\n          (letrec ([fibn (lambda (x)\n        \
    \                   (if (= x 1)\n                               1\n          \
    \                     (if (= x 2)\n                                   1\n    \
    \                               (+ (fibn (- x 1)) (fibn (- x 2))))))]\n      \
    \             [fibn_prime (lambda (x)\n                                 (if (or\
    \ (= x 1) (= x 2))\n                                     #t\n                \
    \                     (if (and (prime? (fibn x)) (= x n))\n                  \
    \                       #t\n                                         (fibn_prime\
    \ (+ x 1)))))]\n                   [fibn_prime_rec (lambda (x)\n             \
    \                        (if (fibn_prime x)\n                                \
    \         (fibn x)\n                                         (fibn_prime_rec (+\
    \ x 1))))])\n            (fibn_prime_rec 1))))))\n", "  (let loop ([n (add1 n)]\
    \ [fib1 1] [fib2 1] [i 1])\n    (cond\n      [(= i n) fib1]\n      [(and (prime?\
    \ fib1) (prime? fib2)) (loop n fib2 fib1 (add1 i))]\n      [else (loop n fib2\
    \ fib1 i)])))\n", "  (for/fold ([n 0] [found 0]) ([x (in-naturals)])\n    (if\
    \ (and (is-prime? x) (is-fib? x))\n        (if (= n found)\n            x\n  \
    \          (add1 found))\n        (add1 n))))\n", "  (nth (filter prime? (fibonacci\
    \ n)) (- n 1)))\n", "  (define (fib n)\n    (cond\n      [(= n 1) 1]\n      [(=\
    \ n 2) 1]\n      [else (+ (fib (- n 1)) (fib (- n 2)))]))\n  (define (is_prime?\
    \ n)\n    (define (divisors n)\n      (for/list ([x (in-range 1 (+ n 1))])\n \
    \       (cond\n          [(= (modulo n x) 0) x]\n          [else \"\"])))\n  \
    \  (cond\n      [(= (length (divisors n)) 2) n]\n      [else (is_prime? (+ n 1))]))\n\
    \  (is_prime? (fib n)))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\
    \ (fib (+ n 2))]))\n", "  (define fibs\n    (stream-cons 2\n      (stream-cons\
    \ 3\n        (stream-cons 5\n          (stream-cons 8\n            (stream-append\n\
    \              (stream-map (lambda (x) (add1 (stream-ref fibs x)))\n         \
    \       (stream-from 2))\n              (stream-map (lambda (x) (add1 (stream-ref\
    \ fibs x)))\n                (stream-from 3))))))))\n  (if (= n 1)\n      (stream-ref\
    \ fibs 0)\n      (if (= n 2)\n          (stream-ref fibs 1)\n          (if (=\
    \ n 3)\n              (stream-ref fibs 2)\n              (if (= n 4)\n       \
    \           (stream-ref fibs 3)\n                  (if (= n 5)\n             \
    \         (stream-ref fibs 4)\n                      (stream-filter prime? fibs)))))))\n",
  "  (let loop ([i 1] [count 0] [a 0] [b 1])\n    (if (= count n)\n        b\n   \
    \     (let ([new (+ a b)])\n          (if (and (= (remainder new 2) 1)\n     \
    \              (not (eq? (remainder new 3) 0))\n                   (not (eq? (remainder\
    \ new 5) 0))\n                   (not (eq? (remainder new 7) 0))\n           \
    \        (not (eq? (remainder new 11) 0))\n                   (not (eq? (remainder\
    \ new 13) 0))\n                   (not (eq? (remainder new 17) 0))\n         \
    \          (not (eq? (remainder new 19) 0))\n                   (not (eq? (remainder\
    \ new 23) 0))\n                   (not (eq? (remainder new 29) 0))\n         \
    \          (not (eq? (remainder new 31) 0))\n                   (not (eq? (remainder\
    \ new 37) 0))\n                   (not (eq? (remainder new 41) 0))\n         \
    \          (not (eq? (remainder new 43) 0))\n                   (not (eq? (remainder\
    \ new 47) 0))\n                   (not (eq? (remainder new 53) 0))\n         \
    \          (not (eq? (remainder new 59) 0))\n                   (not (eq? (remainder\
    \ new 61) 0))\n                   (not (eq? (remainder new 67) 0))\n         \
    \          (not (eq? (remainder new 71) 0))\n                   (not (eq? (remainder\
    \ new 73) 0))\n                   (not (eq? (remainder new 79) 0))\n         \
    \          (not (eq? (remainder new 83) 0))\n                   (not (eq? (remainder\
    \ new 89) 0))\n                   (not (eq? (remainder new 97) 0)))\n        \
    \      (loop (+ i 1) (+ count 1) b new)\n              (loop (+ i 1) count b new))))))",
  "  (do ((i 1 (+ i 1))\n       (nth 1 (+ nth 1))\n       (fib0 0 (fib1))\n      \
    \ (fib1 1 (+ fib0 fib1)))\n      ((= i n) fib1)))\n", "  (let loop ([i 0] [a 1]\
    \ [b 1])\n    (if (= i n)\n        b\n        (if (and (= 0 (modulo a b))\n  \
    \               (prime? a))\n            (loop (+ i 1) b a)\n            (loop\
    \ i b (+ a b))))))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (let\
    \ ([next_fib (+ (* 2 (prime_fib (- n 1))) (prime_fib (- n 2)))])\n           \
    \  (if (prime? next_fib)\n                 next_fib\n                 (prime_fib\
    \ (+ n 1))))]))\n", "  (define (prime-fib-iter counter first second)\n    (cond\
    \ ((= counter n) second)\n          ((prime? (+ first second)) (prime-fib-iter\
    \ (+ counter 1) second (+ first second)))\n          (else (prime-fib-iter counter\
    \ second (+ first second)))))\n  (prime-fib-iter 1 2 3))\n", "  (define (prime-or-not\
    \ i)\n    (define (prime-iterative j)\n      (if (= j i)\n          #t\n     \
    \     (if (= (remainder i j) 0)\n              #f\n              (prime-iterative\
    \ (+ j 1)))))\n    (prime-iterative 2))\n  (define (fib-prime i)\n    (if (= i\
    \ n)\n        (if (prime-or-not i)\n            i\n            (fib-prime (+ i\
    \ 1)))\n        (if (prime-or-not i)\n            (fib-prime (+ i 1))\n      \
    \      (fib-prime (+ i 1)))))\n  (fib-prime 1))\n", "  (let ([fn 1] [fn-1 1] [counter\
    \ 2])\n    (cond\n      [(= n 1) 2]\n      [(= n 2) 3]\n      [else\n       (begin\n\
    \         (while (and (> n counter) (> fn fn-1))\n           (let ([temp fn])\n\
    \             (set! fn (+ fn fn-1))\n             (set! fn-1 temp)\n         \
    \    (cond\n               [(prime? fn) (set! counter (+ counter 1))]\n      \
    \         [else '()]))\n           fn))])))\n", "  (let recur ((n n) (a 1) (b\
    \ 1) (cnt 1))\n    (cond\n      ((= n 1) 1)\n      ((prime? b)\n       (if (=\
    \ cnt n)\n           b\n           (recur n b (+ a b) (+ cnt 1))))\n      (else\
    \ (recur n b (+ a b) cnt)))))\n", "  (define (fib n)\n    (if (< n 2)\n      \
    \  n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n  (define (prime n)\n    (define\
    \ (filter-factors n (div 1))\n      (if (> n (* div div))\n          (cons n (filter-factors\
    \ n (+ div 1)))\n          (filter-factors (/ n div) (+ div 1))))\n    (if (=\
    \ n 1)\n        #f\n        (if (= n (car (filter-factors n 2)))\n           \
    \ #t\n            #f)))\n  (let loop ((i 1) (f 1))\n    (if (= i n)\n        f\n\
    \        (if (prime f)\n            (loop (+ i 1) (+ f 1))\n            (loop\
    \ i (+ f 1))))))\n", "  (let loop ([fib 2] [primes '(2)] [i 0])\n    (cond\n \
    \     [(= i n) (car primes)]\n      [(prime? fib) (loop (+ fib (car primes)) (cons\
    \ fib primes) (+ i 1))]\n      [else (loop (+ fib (car primes)) primes i)])))\n",
  "  (list-ref\n   (filter is-prime?\n           (filter\n            (lambda (x)\
    \ (is-fib? x))\n            (build-list (+ n 1) identity)))\n   n))\n", "  (let\
    \ loop ([i 1] [p 0] [q 1])\n    (if (= i n)\n        (if (prime? q)\n        \
    \    q\n            (loop (+ i 1) q (+ p q)))\n        (loop (+ i 1) q (+ p q)))))\n",
  "  (let* ([f (fib n)]\n         [p (prime f)])\n    (if (= n 1)\n        (if (prime?\
    \ f)\n            f\n            (prime_fib (- n 1)))\n        (if (prime? f)\n\
    \            f\n            (prime_fib (- n 1))))))\n", "  (let fib-seed ()\n\
    \    (define (fib-gen n)\n      (local [(define fib-pairs (cons 1 1))]\n     \
    \   (define (fib-iter i n)\n          (cond [(zero? n) null]\n               \
    \ [(<= i n) (let ([new-val (+ (car fib-pairs) (cadr fib-pairs))])\n          \
    \                  (set! fib-pairs (cons (cadr fib-pairs) new-val))\n        \
    \                    (cons new-val (fib-iter (+ i 1) n)))]\n                [else\
    \ (fib-iter (+ i 1) n)]))\n        (fib-iter 1 n)))\n    (define (prime-fibs n)\n\
    \      (local [(define fib-nums (fib-seed))]\n        (define (prime-fibs-iter\
    \ i)\n          (if (= i n)\n              (car fib-nums)\n              (cond\
    \ [(prime? (car fib-nums)) (prime-fibs-iter (+ i 1))]\n                    [else\
    \ (set! fib-nums (cdr fib-nums)) (prime-fibs-iter i)])))))\n    (prime-fibs n)))\n",
  "  (define (prime_fib_iter n f1 f2 count)\n    (cond ((= count n) f1)\n        \
    \  ((prime? (+ f1 f2)) (prime_fib_iter n (+ f1 f2) f1 (+ count 1)))\n        \
    \  (else (prime_fib_iter n (+ f1 f2) f1 count))))\n  (prime_fib_iter n 1 1 1))\n",
  "  (define (helper i)\n    (if (and (prime? (fib i)) (= n 1))\n        (fib i)\n\
    \        (if (prime? (fib i))\n            (helper (+ i 1))\n            (helper\
    \ (+ i 1)))))\n  (helper 1))", "  (let ([fibs (fibs-list)])\n    (list-ref (filter\
    \ prime? fibs) (- n 1))))\n", "  (let loop ([fib-first 1] [fib-second 1] [fib-current\
    \ 2] [counter 1])\n    (if (= counter n)\n        fib-current\n        (let ((next-fib\
    \ (+ fib-first fib-second)))\n          (if (and (= (gcd fib-current next-fib)\
    \ 1)\n                   (prime? fib-current))\n              (loop fib-second\
    \ fib-current next-fib (+ counter 1))\n              (loop fib-second fib-current\
    \ next-fib counter))))))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n     \
    \   [else\n         (let ([n-1 (- n 1)]\n               [fib-1 (prime_fib n-1)]\n\
    \               [fib-2 (prime_fib n-2)])\n           (let loop ([fib fib-1])\n\
    \             (if (and (fib? fib) (prime? fib))\n                 fib\n      \
    \           (loop (+ fib fib-2))\n             )\n           )\n         )\n \
    \       ]\n  )\n)\n", "  (define (is_prime? k)\n    (define (prime? k lst)\n \
    \     (if (null? lst)\n          #t\n          (if (= (remainder k (car lst))\
    \ 0)\n              #f\n              (prime? k (cdr lst)))))\n    (prime? k (range\
    \ 1 (/ k 2))))\n  (define (fibonacci n)\n    (define (fibonacci_iter a b k)\n\
    \      (if (= k 0)\n          a\n          (fibonacci_iter b (+ a b) (- k 1))))\n\
    \    (fibonacci_iter 0 1 n))\n  (define (generate n)\n    (define (generate_iter\
    \ k n lst)\n      (if (= k n)\n          lst\n          (generate_iter (+ k 1)\
    \ n (cons (fibonacci k) lst))))\n    (generate_iter 0 n '()))\n  (define (filter\
    \ n lst)\n    (cond ((null? lst) '())\n          ((is_prime? (car lst)) (cons\
    \ (car lst) (filter n (cdr lst))))\n          (else (filter n (cdr lst)))))\n\
    \  (car (nthcdr (- n 1) (filter n (generate n)))))\n", "  (define (fib_list a\
    \ b)\n    (cons a (fib_list b (+ a b))))\n  (define (prime_fib_list n)\n    (cond\
    \ ((= n 1) (fib_list 1 2))\n          ((prime? n) (cons n (prime_fib_list (+ n\
    \ 1))))\n          (else (prime_fib_list (+ n 1)))))\n  (list-ref (prime_fib_list\
    \ 2) (- n 1)))\n", "  (define (search fib1 fib2 n)\n    (if (<= n 0)\n      fib1\n\
    \      (if (and (is_prime fib2) (= n 1))\n        fib2\n        (search fib2 (+\
    \ fib1 fib2) (- n 1)))))\n  (search 0 1 n))\n", "  (define (prime-fib-helper n\
    \ fibonacci-number counter)\n    (cond ((= counter n) fibonacci-number)\n    \
    \      ((and (prime? fibonacci-number) (= counter (sub1 n))) fibonacci-number)\n\
    \          (else (prime-fib-helper n (fibonacci-next fibonacci-number) (add1 counter)))))\n\
    \  (prime-fib-helper n (fibonacci 0) 0))\n", "  (letrec ((generate-next (lambda\
    \ (n1 n2)\n                            (if (prime? (+ n1 n2))\n              \
    \                  (+ n1 n2)\n                                (generate-next n2\
    \ (+ n1 n2)))))\n           (nth-prime-fib (lambda (n c)\n                   \
    \         (if (= c n)\n                                n2\n                  \
    \              (nth-prime-fib n (+ c 1) (generate-next n1 n2))))))\n    (nth-prime-fib\
    \ n 1 1)))\n", "  (define (prime? x)\n    (cond\n      [(< x 2) #f]\n      [(=\
    \ x 2) #t]\n      [(even? x) #f]\n      [else\n       (let loop ((d 3))\n    \
    \     (if (> (* d d) x) #t\n             (if (zero? (modulo x d)) #f\n       \
    \          (loop (+ d 2)))))\n       ]))\n  (define (fib? x)\n    (if (and (=\
    \ (remainder x (* 2 (sqrt x))) -1)\n             (integer? (sqrt x)))\n      \
    \  #t\n        #f))\n  (let loop ((n n) (i 2) (fibs (list 0 1)))\n    (cond\n\
    \      [(> n 1)\n       (if (and (prime? i) (fib? i))\n           (loop (- n 1)\
    \ (+ i 1) (append fibs (list i)))\n           (loop n (+ i 1) fibs))]\n      [else\
    \ (car (reverse fibs))])))\n```\n\n---\n\n**Python**\n\n```python\n#!/usr/bin/env\
    \ python\n\n# prime_fib returns n-th number that is a Fibonacci number and it's\
    \ also prime.\n# >>> prime_fib(1)\n# 2\n# >>> prime_fib(2)\n# 3\n# >>> prime_fib(3)\n\
    # 5\n# >>> prime_fib(4)\n# 13\n# >>> prime_fib(5)\n# 89\ndef prime_fib(n):\n \
    \   def prime(x):\n        if x < 2:\n            return False\n        if x ==\
    \ 2:\n            return True\n        if x % 2 == 0:\n            return False\n\
    \        d = 3\n        while d * d <= x:\n            if x % d == 0:\n      \
    \          return False\n            d += 2\n        return True\n    def fib(x):\n\
    \        return (x % 2 == 5 or x % 2 == -1) and int(x ** 0.5) ** 2 == x\n    i\
    \ = 2\n    fibs = [0, 1]\n    while n > 1:\n        if prime(i)", "  (define (iter\
    \ i prev prevprev count)\n    (if (= count n)\n        prev\n        (if (prime?\
    \ (+ prev prevprev))\n            (iter (+ prev prevprev) prevprev prev (+ count\
    \ 1))\n            (iter (+ prev prevprev) prevprev prev count))))\n  (iter 3\
    \ 2 1 1))\n```\n\n> 18. Write a function prime_fib2 which generates prime Fibonacci\
    \ numbers without generating previous numbers.\n\n``` #lang racket\n", "  (cond\n\
    \    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (define (calc x)\n            (cond\n\
    \              [(= x 2) (cons 2 (cons 3 (cons 5 '())))]\n              [else (define\
    \ (next x)\n                      (cons (+ (car x) (cadr x)) (cons (+ (cadr x)\
    \ (+ (car x) (cadr x))) (cddr x))))\n                    (next (calc (- x 1)))]))\n\
    \          (define (prime? n)\n            (cond\n              [(= n 1) #f]\n\
    \              [(= n 2) #t]\n              [(even? n) #f]\n              [else\
    \ (define (divide m)\n                      (cond\n                        [(=\
    \ n m) #t]\n                        [(= (modulo n m) 0) #f]\n                \
    \        [else (divide (+ m 1))]))\n                    (divide 3)]))\n      \
    \    (define (loop lst)\n            (cond\n              [(and (prime? (car lst))\
    \ (= (length lst) n)) (car lst)]\n              [else (loop (cdr lst))]))\n  \
    \        (loop (calc (- n 2))))])\n", "  (define (fibs a b i)\n    (if (= i n)\n\
    \        (if (prime? b)\n            b\n            (fibs b (+ a b) (- i 1)))\n\
    \        (fibs b (+ a b) (+ i 1))))\n  (fibs 1 1 1))", "  (let loop ([n n] [fib1\
    \ 1] [fib2 1] [i 0])\n    (cond [(= i n) fib1]\n          [(and (prime? fib1)\
    \ (zero? (modulo fib1 fib2)))\n           (loop n fib1 (+ fib1 fib2) (+ i 1))]\n\
    \          [else (loop n fib1 (+ fib1 fib2) i)])))\n", "  (define (prime? n)\n\
    \    (define (prime-aux n counter)\n      (cond\n        [(= counter n) #t]\n\
    \        [(= (modulo n counter) 0) #f]\n        [else (prime-aux n (+ counter\
    \ 1))]))\n    (prime-aux n 2))\n  (define (fib-prime-aux n counter)\n    (define\
    \ (fib-aux n1 n2 counter)\n      (cond\n        [(= counter n) n2]\n        [else\
    \ (fib-aux n2 (+ n1 n2) (+ counter 1))]))\n    (if (prime? counter)\n        (fib-prime-aux\
    \ n (+ counter 1))\n        (fib-aux 1 1 counter)))\n  (fib-prime-aux n 1))",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (prime_fib-helper 3 3 5 1)]))\n",
  "  (car (reverse (take n (filter prime (fib-up-to 100000))))))\n", "  (define (is_prime?\
    \ n)\n    (define (is_prime_or_divisible_by? n a)\n      (if (= a 1)\n       \
    \   #t\n          (if (= (remainder n a) 0)\n              #f\n              (is_prime_or_divisible_by?\
    \ n (- a 1)))))\n    (is_prime_or_divisible_by? n (quotient n 2)))\n  (define\
    \ (fib n)\n    (if (< n 2)\n        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n\
    \  (define (fib_count n)\n    (if (= (fib n) n)\n        n\n        (fib_count\
    \ (+ n 1))))\n  (define (prime_fib_rec n count)\n    (if (= n count)\n       \
    \ (fib count)\n        (if (and (is_prime? (fib count)) (= count 1))\n       \
    \     (prime_fib_rec n (fib_count (+ count 1)))\n            (if (and (is_prime?\
    \ (fib count)) (> count 1))\n                (prime_fib_rec n (fib_count (+ count\
    \ 1)))\n                (prime_fib_rec n (fib_count (+ count 1)))))))\n  (prime_fib_rec\
    \ n 1))\n", "  (prime_fib-help n 0 2 1 0))\n", "  (letrec ([pfib (lambda (n a\
    \ b i)\n                   (cond [(= n i) b]\n                         [(and (fib?\
    \ b) (prime? b)) (pfib n b (+ a b) (+ i 1))]\n                         [else (pfib\
    \ n b (+ a b) i)]))])\n    (pfib n 0 1 1)))\n", "  (display n)\n  (list-ref\n\
    \   (filter (lambda (x) (prime? x))\n           (build-list n (lambda (x) (+ (list-ref\
    \ (build-list (+ x 1) (lambda (x) 1)) (- x 1))\n                             \
    \           (list-ref (build-list (+ x 1) (lambda (x) 1)) (- x 2))))))\n   (-\
    \ n 1)))\n", "  (if (equal? n 1)\n      2\n      (let recursive ((c 1) (f1 1)\
    \ (f2 2))\n        (if (= n c)\n            f2\n            (if (prime? (+ f1\
    \ f2))\n                (recursive (+ c 1) f2 (+ f1 f2))\n                (recursive\
    \ c f2 (+ f1 f2)))))))", "  (local [(define (prime_fib_iter current_prime current_fib_prime\
    \ counter)\n            (cond [(= counter n) current_fib_prime]\n            \
    \      [else (if (and (integer? (sqrt current_prime))\n                      \
    \           (integer? (sqrt current_fib_prime)))\n                           (prime_fib_iter\
    \ (+ current_prime 1)\n                                           (+ current_fib_prime\
    \ (fib current_prime))\n                                           (+ counter\
    \ 1))\n                           (prime_fib_iter (+ current_prime 1)\n      \
    \                                     current_fib_prime\n                    \
    \                       counter))]))]\n    (prime_fib_iter 2 3 1)))\n", "  (let\
    \ loop ([i 0] [a 0] [b 1])\n    (cond\n      [(= i n) b]\n      [(and (prime?\
    \ b) (odd? b)) (loop (+ i 1) b (+ a b))]\n      [else (loop i b (+ a b))])))\n",
  "  (define (fib n)\n    (if (< n 2) n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n\
    \  (if (prime? (fib n)) (fib n) (prime_fib (+ n 1))))\n", "  (list-ref (filter\
    \ is-prime (filter is-fib? (build-list n))) (sub1 n)))\n", "  (define (helper\
    \ n so-far-fibs)\n    (if (= n 1)\n        (first so-far-fibs)\n        (let*\
    \ ([next-fib (+ (first so-far-fibs) (second so-far-fibs))]\n               [next-fibs\
    \ (if (prime? next-fib)\n                              (cons next-fib so-far-fibs)\n\
    \                              so-far-fibs)])\n          (helper (- n 1) next-fibs))))\n\
    \  (helper n '(2 1)))\n", "  (let ((i 1)\n        (a 1)\n        (b 1)\n     \
    \   (p 1))\n    (while (not (zero? (- n p)))\n      (if (and (= 0 (modulo (+ a\
    \ b) 2)) (prime? (+ a b)))\n          (set! p (add1 p)))\n      (if (and (= 0\
    \ (modulo (+ a b) 2)) (prime? (+ a b)))\n          (set! p (add1 p)))\n      (set!\
    \ i (add1 i))\n      (set! a b)\n      (set! b (+ a b)))\n    (+ a b)))\n", " \
    \ (let ((i 1)\n        (fibs (list 1 2)))\n    (while (<= i n)\n      (set! fibs\
    \ (append fibs (list (+ (car fibs) (cadr fibs)))))\n      (set! i (+ i 1)))\n\
    \    (if (prime? (car fibs))\n        (car fibs)\n        (cadr fibs))))\n", " \
    \ (let loop ([n n] [i 0] [f 1] [p 1])\n    (if (= n i)\n        p\n        (if\
    \ (and (fibonacci? f) (prime? f))\n            (loop n (+ i 1) (+ f p) f)\n  \
    \          (loop n i (+ f p) f)))))\n", "  (for/fold ([counter 0]\n          \
    \   [prev-fib 0]\n             [fib 1])\n            ([i (in-range 1 infinity)])\n\
    \    (when (prime? fib)\n      (if (= n counter)\n          fib\n          (begin\n\
    \            (set! counter (+ counter 1))\n            (set! prev-fib fib)\n \
    \           (set! fib (+ fib prev-fib)))))))\n", "  (fib-nth-prime 1 n))\n", " \
    \ (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (let loop ([c 3] [x\
    \ 2] [y 3])\n       (if (= c n)\n           (if (prime? x)\n               x\n\
    \               (loop (- c 1) y (+ x y)))\n           (loop (+ c 1) (+ x y) x)))]))\n",
  "  (if (= n 1)\n      2\n      (let loop ([fib-number 1] [fib-number-prev 0] [counter\
    \ 1])\n        (if (= counter n)\n            fib-number\n            (let ([new-fib-number\
    \ (+ fib-number fib-number-prev)])\n              (loop new-fib-number fib-number\
    \ (+ counter 1)))))))\n", "  (let loop ([c 0] [a 0] [b 1])\n    (cond [(= c n)\
    \ a]\n          [(and (= (remainder a 2) 1)\n                (is_prime a))\n \
    \          (loop (+ c 1) b a)]\n          [else (loop c b (+ a b))])))\n", " \
    \ (define (fibs i x y)\n    (if (= i 1)\n        x\n        (fibs (- i 1) y (+\
    \ x y))))\n  (define (prime? n)\n    (define (prime? i n)\n      (if (= i n)\n\
    \          #t\n          (if (zero? (modulo n i))\n              #f\n        \
    \      (prime? (+ i 1) n))))\n    (prime? 2 n))\n  (define (prime-fibs i x y)\n\
    \    (if (= i n)\n        (if (prime? (+ x y))\n            (+ x y)\n        \
    \    (prime-fibs (- i 1) y (+ x y)))\n        (if (prime? (+ x y))\n         \
    \   (prime-fibs (- i 1) y (+ x y))\n            (prime-fibs i y (+ x y)))))\n\
    \  (prime-fibs n 0 1))", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n\
    \     (let ([fib-5 (prime_fib (- n 2))]\n           [fib-4 (prime_fib (- n 1))])\n\
    \       (let loop ([i (+ fib-5 fib-4)])\n         (if (and (prime? i) (= i (-\
    \ fib-4 fib-5)))\n             i\n             (loop (+ i fib-4))\n         )\n\
    \       )\n     )\n    ]\n  )\n)\n", "  (list-ref (filter prime? (map fib (build-list\
    \ n add1))) (- n 1)))\n", "  (define (fib-iter a b i)\n    (if (= i n)\n     \
    \   b\n        (if (and (prime? b) (not (prime? a)))\n            (fib-iter b\
    \ (+ a b) (+ i 1))\n            (fib-iter b (+ a b) i))))\n  (fib-iter 0 1 1))\n",
  "  (let loop ([i 1] [num 1] [n n])\n    (cond\n      [(= n 0) num]\n      [(prime?\
    \ (+ num num)) (loop (+ i 1) (+ num num) (- n 1))]\n      [else (loop (+ i 1)\
    \ (+ num num) n)])))\n", "  (define (prime? n)\n    (define (is-divisible? x y)\n\
    \      (= (remainder x y) 0))\n    (define (smallest-divisor n)\n      (define\
    \ (find-divisor n test-divisor)\n        (cond ((> (square test-divisor) n) n)\n\
    \              ((is-divisible? n test-divisor) test-divisor)\n              (else\
    \ (find-divisor n (+ test-divisor 1)))))\n      (find-divisor n 2))\n    (= n\
    \ (smallest-divisor n)))\n  (define (fib n)\n    (cond ((< n 2) n)\n         \
    \ (else (+ (fib (- n 1)) (fib (- n 2))))))\n  (define (prime-fib n count)\n  \
    \  (if (= n count)\n        (prime-fib n (+ count 1))\n        (if (prime? (fib\
    \ n))\n            (fib n)\n            (prime-fib n (+ count 1)))))\n  (prime-fib\
    \ n 2))", "  (define (fib-iter a b p counter)\n    (cond\n      [(= counter n)\
    \ b]\n      [(prime? b) (fib-iter b (+ a b) (add1 p) (add1 counter))]\n      [else\
    \ (fib-iter b (+ a b) p counter)]))\n  (fib-iter 1 1 0 1))\n```\n\n# \u9898\u76EE\
    \u4E8C\uFF1A\n\n## \u9898\u76EE\uFF1A\n\nGiven a binary tree, return the inorder\
    \ traversal of its nodes' values.\n\nFor example:\nGiven binary tree [1,null,2,3],\n\
    ```\n   1\n    \\\n     2\n    /\n   3\n```\nreturn [1,3,2].\n\nNote: Recursive\
    \ solution is trivial, could you do it iteratively?\n\n## \u89E3\u7B54\uFF1A\n\
    \nPython:\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n\
    #     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n\
    #         self.right = None\n\nclass Solution(object):\n    def inorderTraversal(self,\
    \ root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n\
    \        \"\"\"\n        stack = []\n        current = root\n        res = []\n\
    \        while len(stack) != 0 or current != None:\n            if current !=\
    \ None:\n                stack.append(current)\n                current = current.left\n\
    \            else:\n                current = stack.pop()\n                res.append(current.val)\n\
    \                current = current.right\n        return res\n```\n\nRacket:\n\
    \n```racket\n#lang racket\n", "  (define (prime? n)\n    (for/or ([i (in-range\
    \ (floor (sqrt n)) 2)])\n      (zero? (modulo n i))))\n  (define (fib n)\n   \
    \ (define (fib-iter a b i)\n      (if (= i n) b\n        (fib-iter b (+ a b) (+\
    \ i 1))))\n    (fib-iter 0 1 1))\n  (define (prime-fib-iter n c)\n    (if (= n\
    \ c)\n        #f\n        (let ((x (fib c)))\n          (if (prime? x)\n     \
    \         x\n              (prime-fib-iter n (+ c 1))))))\n  (prime-fib-iter n\
    \ 1))\n```\n\n### C\n\n```c\n// prime_fib returns n-th number that is a Fibonacci\
    \ number and it's also prime.\n// >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n\
    // 3\n// >>> prime_fib(3)\n// 5\n// >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n\
    // 89\nint prime_fib(int n) {\n  int prime_fib_iter(int n, int c) {\n    if (n\
    \ == c) return 0;\n    int x = fib(c);\n    if (prime(x)) return x;\n    return\
    \ prime_fib_iter(n, c + 1);\n  }\n  return prime_fib_iter(n, 1);\n}\n```\n\n###\
    \ Clojure\n\n```clojure", "  (let fib-numbers ((i 1) (numbers (list 2 3 5)))\n\
    \    (cond ((zero? n) (car numbers))\n          ((= i n) (car numbers))\n    \
    \      (else (fib-numbers (+ i 1) (cons (fibonacci-numbers (car numbers) (cadr\
    \ numbers)) numbers))))))\n", "  (define (fib-gen)\n    (let loop ((x1 1) (x2\
    \ 1))\n      (cons x1 (loop x2 (+ x1 x2)))))\n  (define (is-prime n)\n    (define\
    \ (iter p)\n      (cond ((> p (/ n 2)) #t)\n            ((= (modulo n p) 0) #f)\n\
    \            (else (iter (+ p 1)))))\n    (iter 2))\n  (let ((count 0) (fibs (fib-gen)))\n\
    \    (define (iter)\n      (let ((fib (car fibs)))\n        (if (is-prime fib)\n\
    \            (cond ((= count n) fib)\n                  (else (set! count (+ count\
    \ 1))\n                        (set! fibs (cdr fibs))\n                      \
    \  (iter)))\n            (set! fibs (cdr fibs))\n            (iter))))\n    (iter)))\n",
  "  (define (is-prime n)\n    (define (divisible? n d)\n      (= (remainder n d)\
    \ 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (* test-divisor\
    \ test-divisor) n) n)\n            ((divisible? n test-divisor) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor\
    \ n 2) n))\n  (define (fib n)\n    (if (= n 0) 0\n        (if (= n 1) 1\n    \
    \        (+ (fib (- n 1)) (fib (- n 2))))))\n  (define (prime-fib n)\n    (define\
    \ (prime-fib-iter n iter index)\n      (cond ((and (= n iter) (is-prime (fib iter)))\
    \ index)\n            (else (prime-fib-iter n (+ iter 1) (+ index 1)))))\n   \
    \ (prime-fib-iter n 0 1))\n  (prime-fib n))\n```\n\n```racket\n#lang racket\n",
  "  (define fib\n    (lambda (n)\n      (cond\n        ((= n 1) 1)\n        ((= n\
    \ 2) 1)\n        (else (+ (fib (- n 1)) (fib (- n 2)))))))\n  (define prime?\n\
    \    (lambda (n)\n      (define divisible?\n        (lambda (x y)\n          (=\
    \ (remainder x y) 0)))\n      (define factors\n        (lambda (n)\n         \
    \ (filter (lambda (x) (divisible? n x))\n                  (range 2 n))))\n  \
    \    (= (length (factors n)) 0)))\n  (define fibs\n    (lambda (n)\n      (range\
    \ 1 n)))\n  (define prime-fibs\n    (lambda (n)\n      (filter prime? (map fib\
    \ (fibs n)))))\n  (list-ref (prime-fibs n) (- n 1)))\n", "  (if (or (= n 1) (=\
    \ n 2)) 2\n      (let ((numbers (fib n)))\n        (prime_fib_helper n numbers))))\n",
  "  (define (is-prime n)\n    (define (check-factor m)\n      (or (= m 1)\n     \
    \     (and (not (= (remainder n m) 0))\n               (check-factor (- m 1)))))\n\
    \    (check-factor (- n 1)))\n  (define (fib-iter a b count)\n    (if (= count\
    \ 0)\n        a\n        (fib-iter b (+ a b) (- count 1))))\n  (define (find-fib-prime\
    \ count)\n    (if (and (is-prime (fib-iter 1 1 count))\n             (= count\
    \ n))\n        (fib-iter 1 1 count)\n        (find-fib-prime (+ count 1))))\n\
    \  (find-fib-prime 0))\n", "  (do ([num 0 (+ num 1)]\n       [cnt 0 (+ cnt 1)])\n\
    \      ((eq? cnt n) num)\n    (when (and (fib? num) (prime? num))\n      (set!\
    \ cnt (+ cnt 1)))))\n```\n\n```\n#lang racket\n", "  (letrec ((fib (lambda (x)\n\
    \t\t  (cond\n\t\t    ((zero? x) 0)\n\t\t    ((= x 1) 1)\n\t\t    (else (+ (fib\
    \ (- x 1)) (fib (- x 2)))))))\n\t   (aux (lambda (x)\n\t\t  (if (and (fib x) (prime?\
    \ (fib x)))\n\t\t      (fib x)\n\t\t      (aux (+ x 1))))))\n    (aux n)))\n",
  "  (define (get-index list)\n    (cond\n      [(null? list) 0]\n      [(prime? (car\
    \ list)) (+ 1 (get-index (cdr list)))]\n      [else (get-index (cdr list))]))\n\
    \  (list-ref (fib-list (make-list n 1)) (get-index (fib-list (make-list n 1)))))\n\
    \n", "  (define (fib-seq a b index)\n    (if (= index 0)\n        (let* ([tmp\
    \ (+ a b)]\n               [a b]\n               [b tmp])\n          b)\n    \
    \    (if (and (prime? b) (= index n))\n            b\n            (let* ([tmp\
    \ (+ a b)]\n                   [a b]\n                   [b tmp])\n          \
    \    (fib-seq a b (- index 1))))))\n  (fib-seq 0 1 0))\n```\n\n```racket\n#lang\
    \ racket\n", "  (define (is-prime? k)\n    (let loop ((x 2))\n      (cond ((=\
    \ x k) #t)\n            ((zero? (modulo k x)) #f)\n            (else (loop (+\
    \ x 1))))))\n  (define (fib-prime fib_list)\n    (if (and (is-prime? (car fib_list))\n\
    \             (= (length fib_list) n))\n        (car fib_list)\n        (fib-prime\
    \ (append fib_list\n                           (list (+ (car fib_list) (cadr fib_list)))))))\n\
    \  (fib-prime (list 1 1)))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n   \
    \     [else\n         (let lp ((i 3) (cnt 1) (fib1 1) (fib2 2))\n           (cond\
    \ [(= cnt n) fib2]\n                 [(= i fib2) (lp (+ i 1) (+ cnt 1) fib2 (+\
    \ fib1 fib2))]\n                 [else (lp (+ i 1) cnt fib1 fib2)]))]))\n", " \
    \ (let loop ([i 1] [j 2] [k 3] [l 0])\n    (if (equal? n l) j\n        (if (is-prime?\
    \ k)\n            (loop i k (+ i j) (+ l 1))\n            (loop j k (+ i j) l)))))\n\
    \n", "  (let loop ([n n] [i 3] [fibs '(2 1)])\n    (cond [(= n 1) (first fibs)]\n\
    \          [(even? i) (loop n (+ i 1) fibs)]\n          [(prime? i) (loop (- n\
    \ 1) (+ i 1) (cons i fibs))]\n          [else (loop n (+ i 1) fibs)])))\n", " \
    \ (define (is_prime n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n     \
    \     ((= n 3) #t)\n          ((= n 4) #f)\n          ((= n 5) #t)\n         \
    \ ((= n 6) #f)\n          ((= n 7) #t)\n          ((= n 8) #f)\n          ((=\
    \ n 9) #f)\n          ((= n 10) #f)\n          ((= n 11) #t)\n          ((= n\
    \ 12) #f)\n          ((= n 13) #t)\n          ((= n 14) #f)\n          ((= n 15)\
    \ #f)\n          ((= n 16) #f)\n          ((= n 17) #t)\n          ((= n 18) #f)\n\
    \          ((= n 19) #t)\n          ((= n 20) #f)\n          ((= n 21) #f)\n \
    \         ((= n 22) #f)\n          ((= n 23) #t)\n          ((= n 24) #f)\n  \
    \        ((= n 25) #f)\n          ((= n 26) #f)\n          ((= n 27) #f)\n   \
    \       ((= n 28) #f)\n          ((= n 29) #t)\n          ((= n 30) #f)\n    \
    \      ((= n 31) #t)\n          ((= n 32) #f)\n          ((= n 33) #f)\n     \
    \     ((= n 34) #f)\n          ((= n 35) #f)\n          ((= n 36) #f)\n      \
    \    ((= n 37) #t)\n          ((= n 38) #f)\n          ((= n 39) #f)\n       \
    \   ((= n 40) #f)\n          ((= n 41) #t)\n          ((= n 42) #f)\n        \
    \  ((= n 43) #t)\n          ((= n 44) #f)\n          ((= n 45) #f)\n         \
    \ ((= n 46) #f)\n          ((= n 47) #t)\n          ((= n 48) #f)\n          ((=\
    \ n 49) #f)\n          ((= n 50) #f)", "  (define (next_fib fib1 fib2)\n    (if\
    \ (= n 2) fib2 (next_fib fib2 (+ fib1 fib2))))\n  (next_fib 2 3))\n", "  (prime_fib_helper\
    \ n 2 1 0 1))\n", "  (first (filter is-prime (fibonacci n))))\n", "  (let loop\
    \ ([remaining n] [prev 0] [current 1])\n    (cond\n      [(zero? remaining) prev]\n\
    \      [(or (zero? (remainder current 2))\n           (zero? (remainder current\
    \ 3))\n           (zero? (remainder current 5))\n           (zero? (remainder\
    \ current 7)))\n       (loop remaining current (+ prev current))]\n      [else\
    \ (loop (sub1 remaining) current (+ prev current))])))\n", "  (let ((fib-prime-list\
    \ (list)))\n    (let loop ((fib-num 1) (fib-prev 0) (i 1))\n      (if (= i n)\n\
    \          fib-num\n          (if (and (fib? fib-num) (prime? fib-num))\n    \
    \          (loop (+ fib-num fib-prev) fib-num (+ i 1))\n              (loop (+\
    \ fib-num fib-prev) fib-num i))))))\n", "  (let* ([fibs (fibs-seq)]\n        \
    \ [prime-fibs (filter prime? fibs)])\n    (list-ref prime-fibs (sub1 n))))\n",
  "  (let loop ([i 0] [fibs (list 2 3 5)])\n    (cond\n      [(= i n) (list-ref fibs\
    \ (- i 1))]\n      [(not (prime? (list-ref fibs (- i 1)))) (loop i (drop-right\
    \ fibs 1))]\n      [else (loop (+ i 1) (append fibs (list (+ (list-ref fibs (-\
    \ i 1)) (list-ref fibs (- i 2))))))])))\n", "  (if (zero? n) 1\n      (if (zero?\
    \ (modulo n 2))\n          ;; return n-th prime number\n          (prime_fib (sub1\
    \ n))\n          ;; return n-th prime fibonacci number\n          (if (and (prime?\
    \ (prime_fib (sub1 n)))\n                   (prime? (prime_fib (sub2 n))))\n \
    \             (prime_fib (sub1 n))\n              (prime_fib (sub2 n))))))\n",
  "  (prime-fibonacci 1 2 0 (+ n 1)))\n", "  (let loop ([i 1] [j 1] [prime-fib-count\
    \ 0])\n    (cond\n      [(= prime-fib-count n) j]\n      [(and\n         (= (remainder\
    \ j 2) 1)\n         (prime? j))\n       (loop i (+ i j) (+ prime-fib-count 1))]\n\
    \      [else (loop i (+ i j) prime-fib-count)])))\n", "  (define (fib n)\n   \
    \ (if (< n 2)\n        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n  (define\
    \ (is-prime n)\n    (define (divides? n m)\n      (= (remainder n m) 0))\n   \
    \ (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divides? n test-divisor) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= n (find-divisor n 2)))\n  (define\
    \ (is-fib n)\n    (define (fib-iter a b count)\n      (cond ((= count n) b)\n\
    \            (else (fib-iter b (+ a b) (+ count 1)))))\n    (fib-iter 0 1 1))\n\
    \  (define (n-prime-fib counter)\n    (cond ((= counter n) 'error)\n         \
    \ ((and (is-prime (fib counter)) (is-fib (fib counter))) (fib counter))\n    \
    \      (else (n-prime-fib (+ counter 1)))))\n  (n-prime-fib 1))", "  (if (< n\
    \ 0)\n      (error \"Argument should be bigger than 0\")\n      (if (= n 1)\n\
    \          2\n          (if (= n 2)\n              3\n              (let loop\
    \ ([cnt 1] [prev_fib 2] [curr_fib 3])\n                (if (= cnt n)\n       \
    \             (if (prime? curr_fib)\n                        curr_fib\n      \
    \                  (loop (- cnt 1) curr_fib (+ curr_fib prev_fib)))\n        \
    \            (loop (+ cnt 1) curr_fib (+ curr_fib prev_fib))))))))\n", "  (let\
    \ ([fibs (build-fib-list n)])\n    (cdr (list-ref fibs n))))\n", "  (define (fib-gen\
    \ a b)\n    (cons a (fib-gen b (+ a b))))\n  (define (fibs last)\n    (if (> last\
    \ 0)\n        (let ([x (fib-gen 1 1)])\n          (cons (first x) (fibs (- last\
    \ 1) (rest x))))\n        '()))\n  (let loop ([fs (fibs n)] [cnt 0])\n    (if\
    \ (null? fs)\n        0\n        (if (and (zero? (modulo (first fs) 2)) (prime?\
    \ (first fs)))\n            (first fs)\n            (loop (rest fs) (+ cnt 1))))))",
  "  (letrec ([fib (lambda (n) (if (= n 1) 1 (if (= n 2) 1 (+ (fib (- n 1)) (fib (-\
    \ n 2))))))]\n           [prime-index (lambda (index) (if (= index n) (fib (index\
    \ + 1)) (if (prime? (fib index)) (prime-index (+ index 1)) (prime-index (+ index\
    \ 1)))))]\n           [prime? (lambda (n) (if (= n 1) #f (if (= n 2) #t (if (even?\
    \ n) #f (let ([prime? (lambda (d) (if (= d n) #t (if (= (modulo n d) 0) #f (prime?\
    \ (+ d 1))))]) (prime? 3))))))])\n    (prime-index 1)))\n", "  (let loop ([i 0]\
    \ [fn 0] [fn_1 0] [fpn 0])\n    (cond [(= i n) fpn]\n          [(zero? fn) (loop\
    \ (+ i 1) 1 0 0)]\n          [(zero? fn_1) (loop (+ i 1) 1 1 1)]\n          [(prime?\
    \ (+ fn fn_1)) (loop (+ i 1) (+ fn fn_1) fn (+ fn fn_1))]\n          [else (loop\
    \ (+ i 1) (+ fn fn_1) fn fpn)])))\n", "  (fib (n+1 (prime_num_index n))))\n",
  "  (define (prime_fib n a b count)\n    (if (= count n)\n        a\n        (if\
    \ (and (fib? (+ a b)) (prime? (+ a b)))\n            (prime_fib n (+ a b) a (+\
    \ count 1))\n            (prime_fib n (+ a b) a count))))\n  (prime_fib n 1 1\
    \ 1))\n", "  (fib (prime-fib-number n)))\n", "  (define (fib n)\n    (if (= n\
    \ 1)\n        1\n        (if (= n 2)\n            2\n            (+ (fib (- n\
    \ 1)) (fib (- n 2))))))\n  (define (is_prime? n)\n    (if (= n 1)\n        #f\n\
    \        (if (= n 2)\n            #t\n            (if (is_prime? (- n 1))\n  \
    \              (if (= (modulo n (- n 1)) 0)\n                    #f\n        \
    \            #t)\n                #f))))\n  (define (helper i)\n    (if (= i n)\n\
    \        (fib i)\n        (if (is_prime? (fib i))\n            (helper (+ i 1))\n\
    \            (helper (+ i 1)))))\n  (helper 1))", "  (let loop ([n n] [i 0] [fib1\
    \ 1] [fib2 1])\n    (cond\n      [(= n i) fib1]\n      [(and (= 0 (modulo (fib-number\
    \ i) 2)) (= 0 (modulo (fib-number i) 3)) (= 0 (modulo (fib-number i) 5)) (= 0\
    \ (modulo (fib-number i) 7)))\n       (loop n (+ i 1) (fib-number i) (fib-number\
    \ (+ i 1)))]\n      [else (loop n (+ i 1) fib1 fib2)])))\n", "  (prime-fib-helper\
    \ n 1 1 2))\n", "  (define (fib-counter count current current-plus-one)\n    (cond\n\
    \      [(= count 0) current]\n      [(is-prime? current)\n       (cond\n     \
    \    [(= count 1) current]\n         [else (fib-counter (- count 1) current-plus-one\
    \ (+ current current-plus-one))])]\n      [else (fib-counter count current-plus-one\
    \ (+ current current-plus-one))]))\n  (fib-counter n 2 1))\n", "  (for/first ([i\
    \ (in-range n)])\n    (andmap (\u03BB (x) (= 0 (modulo x i))) (fibs))))\n", " \
    \ (let loop ([i 0] [n-th-fib 0] [current-fib 0] [previous-fib 0])\n    (if (=\
    \ i n)\n        n-th-fib\n        (if (is_prime? (+ current-fib previous-fib))\n\
    \            (loop (+ i 1)\n                  (+ current-fib previous-fib)\n \
    \                 (+ current-fib previous-fib)\n                  current-fib)\n\
    \            (loop i\n                  n-th-fib\n                  (+ current-fib\
    \ previous-fib)\n                  current-fib)))))\n", "  (let loop ([lst (list\
    \ 2 3 5)] [count n])\n    (if (= count 1)\n        (car lst)\n        (if (and\
    \ (prime? (car lst)) (fib? (car lst)))\n            (loop (cons (car lst) lst)\
    \ (- count 1))\n            (loop (cons (car lst) lst) count)))))\n", "  (let\
    \ loop ([n n] [fib-index 0] [fib-prime 0])\n    (cond [(zero? n) fib-prime]\n\
    \          [(is_prime? fib-prime) (loop (- n 1) (+ fib-index 1) (fib fib-index))]\n\
    \          [else (loop n (+ fib-index 1) (fib fib-index))])))\n", "  (letrec ((fib\
    \ (lambda (n)\n                  (cond ((= n 1) 1)\n                        ((=\
    \ n 2) 2)\n                        (else (+ (fib (- n 1)) (fib (- n 2)))))))\n\
    \           (is-prime? (lambda (x)\n                        (let ((n x))\n   \
    \                       (define (divides? k)\n                            (= (remainder\
    \ n k) 0))\n                          (define (find-divisor n)\n             \
    \               (cond ((<= n (* 2 2)) #f)\n                                  ((divides?\
    \ n) n)\n                                  (else (find-divisor (- n 1))))))\n\
    \                        (if (= n 1) #f\n                            (not (find-divisor\
    \ (truncate (/ n 2))))))))\n    (letrec ((prime-fib (lambda (n)\n            \
    \              (cond ((= n 1) 2)\n                                ((is-prime?\
    \ (fib n)) (fib n))\n                                (else (prime-fib (- n 1)))))))\n\
    \      (prime-fib n))))\n", "  (define (fib_helper n)\n    (cond\n      [(= n\
    \ 1) 2]\n      [(= n 2) 3]\n      [else (+ (fib_helper (- n 1)) (fib_helper (-\
    \ n 2)))]))\n  (define (is_prime? n)\n    (define (prime_helper n i)\n      (cond\n\
    \        [(= n 2) #t]\n        [(= n 3) #t]\n        [(= n i) #t]\n        [(=\
    \ (modulo n i) 0) #f]\n        [else (prime_helper n (+ i 1))]))\n    (prime_helper\
    \ n 2))\n  (define (prime_fib_helper n i)\n    (cond\n      [(= n i) (fib_helper\
    \ n)]\n      [(and (= (modulo n i) 0) (is_prime? (fib_helper n))) (prime_fib_helper\
    \ n (+ i 1))]\n      [else (prime_fib_helper n (+ i 1))]))\n  (prime_fib_helper\
    \ n 1))", "  (define (iter k a b cnt)\n    (cond ((= cnt n) a)\n          ((is-prime\
    \ (+ a b)) (iter (+ a b) b (+ a b) (+ cnt 1)))\n          (else (iter (+ a b)\
    \ b (+ a b) cnt))))\n  (iter 1 2 3 1))\n", "  (for/fold ([fib-nums (list 1 1)])\
    \ ([_ n])\n    (let* ([fib-nums (cons (car fib-nums) (cadr fib-nums))]\n     \
    \      [fib-n   (+ (car fib-nums) (cadr fib-nums))]\n           [fib-nums (cons\
    \ fib-n fib-nums)])\n      (when (and (= 0 (modulo fib-n 2))\n               \
    \  (prime? fib-n))\n        fib-n))))\n", "  (define (fib n)\n    (if (< n 2)\n\
    \        n\n        (+ (fib (- n 1)) (fib (- n 2)))))\n  (if (= n 1)\n      2\n\
    \      (let loop ((k 2) (x (fib 2)) (y (fib 3)))\n        (if (= k n)\n      \
    \      x\n            (if (prime? y)\n                (loop (+ k 1) y (+ x y))\n\
    \                (loop k x (+ x y)))))))\n", "  (cond [(= n 1) 2]\n        [(=\
    \ n 2) 3]\n        [else\n         (let loop ([n n] [a 2] [b 3] [c 5])\n     \
    \      (cond [(> n 2) (loop (- n 1) b c (+ a b c))]\n                 [else c]))]))\n",
  "  (define (prime? n)\n    (define (prime?-iter i)\n      (if (> (* i i) n) #t\n\
    \          (if (= (remainder n i) 0) #f\n              (prime?-iter (+ i 1)))))\n\
    \    (prime?-iter 2))\n  (define (fibonacci n)\n    (define (fibonacci-iter x1\
    \ x2 i)\n      (if (= i 0) x1\n          (fibonacci-iter x2 (+ x1 x2) (- i 1))))\n\
    \    (fibonacci-iter 0 1 n))\n  (define (prime-fib?-iter i j)\n    (if (= j n)\
    \ (fibonacci i)\n        (if (prime? (fibonacci i)) (prime-fib?-iter (+ i 1) (+\
    \ j 1))\n            (prime-fib?-iter (+ i 1) j))))\n  (prime-fib?-iter 0 0))\n\
    ```\n\n## Solution in F#\n\n```fsharp\nlet isPrime n =\n    let rec isPrime' i\
    \ =\n        if i * i > n then true\n        elif n % i = 0 then false\n     \
    \   else isPrime' (i + 1)\n    isPrime' 2\n\nlet rec fibonacci n =\n    let rec\
    \ fibonacci' x1 x2 i =\n        if i = 0 then x1\n        else fibonacci' x2 (x1\
    \ + x2) (i - 1)\n    fibonacci' 0 1 n\n\nlet rec primeFib i j =\n    if j = n\
    \ then fibonacci i\n    elif isPrime (fibonacci i) then primeFib (i + 1) (j +\
    \ 1)\n    else primeFib (i + 1) j\n\nlet rec primeFib i j =\n    match j with\n\
    \    | j when j = n -> fibonacci i\n    | _ -> if isPrime (fibonacci i) then primeFib\
    \ (i + 1) (j + 1)\n           else primeFib (i + 1) j\n```", "  (define (fib n)\n\
    \    (if (= n 1)\n        1\n        (if (= n 2)\n            2\n            (+\
    \ (fib (- n 1)) (fib (- n 2))))))\n  (define (is_prime n)\n    (define (iter i)\n\
    \      (if (= i n)\n          #t\n          (if (= (modulo n i) 0)\n         \
    \     #f\n              (iter (+ i 1)))))\n    (iter 2))\n  (define (iter i current)\n\
    \    (if (= i n)\n        current\n        (if (is_prime (fib (+ i 1)))\n    \
    \        (iter (+ i 1) (fib (+ i 1)))\n            (iter (+ i 1) current))))\n\
    \  (iter 1 1))\n", "  (let loop ([n n] [a 1] [b 2] [c 3] [i 0])\n    (cond\n \
    \     [(= n i) c]\n      [(and (prime? c) (fib? c)) (loop n b c (+ c b) (+ i 1))]\n\
    \      [else (loop n b c (+ c b) i)])))\n", "  (for/fold ([i 0]\n            \
    \ [f 0]\n             [p 0])\n      ([_ n])\n    (cond\n      [(or (not (prime?\
    \ f)) (not (prime? p))) (values (add1 i) f p)]\n      [(zero? i) (values (add1\
    \ i) (add1 f) p)]\n      [else (values (add1 i) (add1 f) (add1 p))])))\n", " \
    \ (let fibs-and-primes\n    ((fibs (list 1 1)) (primes (list 2 3)) (k 1))\n  \
    \    (if (= n k)\n          (car fibs)\n          (let ([p (car primes)])\n  \
    \          (if (= p (car fibs))\n                (fibs-and-primes (cdr fibs) (cdr\
    \ primes) (+ k 1))\n                (fibs-and-primes (cons (+ (car fibs) (cadr\
    \ fibs)) fibs) primes k)))))))\n", "  (cond\n    ((= n 1) 2)\n    ((= n 2) 3)\n\
    \    (else (let ([p (prime_fib (- n 1))])\n            (fib_prime p)))))\n", " \
    \ (define (prime_fib-iter index current-value prev-value)\n    (if (= index n)\n\
    \        current-value\n        (if (and (fib? current-value) (prime? current-value))\n\
    \            (prime_fib-iter (+ index 1) (+ current-value prev-value) current-value)\n\
    \            (prime_fib-iter index (+ current-value prev-value) current-value))))\n\
    \  (prime_fib-iter 1 2 1))\n", "  (first (filter is_prime\n                 (nth_fib_nums\
    \ n))))\n", "  (define (fib n)\n    (cond\n      [(zero? n) 1]\n      [(= n 1)\
    \ 1]\n      [else (+ (fib (- n 1)) (fib (- n 2)))]))\n  (define (aux i curr)\n\
    \    (if (= i n)\n        curr\n        (if (and (prime? curr)\n             \
    \    (exact-integer-sqrt (fib curr)))\n            (aux (+ i 1) (+ curr 1))\n\
    \            (aux i (+ curr 1)))))\n  (aux 1 2))\n", "  (let loop ([n n] [count\
    \ 0] [prev 1] [current 2])\n    (if (= count n)\n        current\n        (if\
    \ (and (integer? (/ prev 2)) (integer? (/ current 2)))\n            (loop n count\
    \ (+ prev current) prev)\n            (loop n (+ count 1) (+ prev current) prev)))))\n",
  "  (find (lambda (i)\n          (and (prime? i)\n               (fib? i)))\n   \
    \     (sequence n 1 (lambda (i) (+ i 1)))))\n", "  (cond\n    [(= n 1) 2]\n  \
    \  [(= n 2) 3]\n    [else\n     (let*\n         ([a 0]\n          [b 1]\n    \
    \      [i 1]\n          [c 0])\n       (for ([i i] [i n])\n         (set! c (+\
    \ a b))\n         (set! a b)\n         (set! b c))\n       (cond\n         [(and\
    \ (= (% c 2) 1) (prime? c)) c]\n         [else\n          (for ([j i] [j n])\n\
    \            (set! c (+ a b))\n            (set! a b)\n            (set! b c))\n\
    \          (cond\n            [(and (= (% c 2) 1) (prime? c)) c]\n           \
    \ [else\n             (for ([k j] [k n])\n               (set! c (+ a b))\n  \
    \             (set! a b)\n               (set! b c))\n             (cond\n   \
    \            [(and (= (% c 2) 1) (prime? c)) c]\n               [else\n      \
    \          (for ([l k] [l n])\n                  (set! c (+ a b))\n          \
    \        (set! a b)\n                  (set! b c))\n                (cond\n  \
    \                [(and (= (% c 2) 1) (prime? c)) c]\n                  [else\n\
    \                   (for ([m l] [m n])\n                     (set! c (+ a b))\n\
    \                     (set! a b)\n                     (set! b c))\n         \
    \          (cond\n                     [(and (= (% c 2) 1) (prime? c)) c]\n  \
    \                   [else\n                      (for ([n m] [n n])\n        \
    \                (set! c (+ a b))\n                        (set! a b)\n      \
    \                  (set! b c))\n                      (cond\n                \
    \        [(and (= (% c 2) 1) (prime? c)) c]\n                        [else\n \
    \                        (for ([o n] [o n])\n                           (set!\
    \ c (+ a b))\n                           (set! a b)\n                        \
    \   (set! b c))\n                         (cond\n                           [(and\
    \ (= (% c 2) 1) (prime? c)) c]\n                           [else\n           \
    \                 (", "  (define (helper n count curr prev)\n    (cond\n     \
    \ [(= n count) curr]\n      [(= 0 (modulo curr 2)) (helper n count (+ curr prev)\
    \ curr)]\n      [(prime? curr) (helper n (+ count 1) (+ curr prev) curr)]\n  \
    \    [else (helper n count (+ curr prev) curr)]))\n  (helper n 0 2 1))\n", " \
    \ (define (helper number fibs-count)\n    (cond ((= fibs-count n) (car fibs))\n\
    \          ((and (= (modulo number 2) 1) (prime? number))\n           (helper\
    \ (+ fibs (cdr fibs)) (add1 fibs-count)))\n          (else (helper (+ fibs (cdr\
    \ fibs)) fibs-count))))\n  (helper (list 1 1) 1))", "  (let loop ([n n] [a 0]\
    \ [b 1] [count 0])\n    (cond [(= n 0) a]\n          [(and (prime? b) (= count\
    \ (- n 1))) b]\n          [else (loop n b (+ a b) (+ count 1))])))\n", "  (cond\n\
    \    [(eq? n 1) 2]\n    [(eq? n 2) 3]\n    [else (prime_fib-aux (make-hash) 1\
    \ 3 2 n)]))\n", "  (define fibs (lambda (n)\n                 (if (= n 1) 1\n\
    \                     (if (= n 2) 1\n                         (+ (fibs (- n 1))\
    \ (fibs (- n 2)))))))\n  (define is-prime? (lambda (n)\n                     \
    \ (and (> n 1)\n                           (define (divisible-by? n m)\n     \
    \                        (zero? (modulo n m)))\n                           (not\
    \ (divisible-by? n 2))\n                           (not (divisible-by? n 3))\n\
    \                           (not (divisible-by? n 5))\n                      \
    \     (not (divisible-by? n 7))\n                           (not (divisible-by?\
    \ n 11))\n                           (not (divisible-by? n 13))\n            \
    \               (not (divisible-by? n 17))\n                           (not (divisible-by?\
    \ n 19))\n                           (not (divisible-by? n 23))\n            \
    \               (not (divisible-by? n 29))\n                           (not (divisible-by?\
    \ n 31))\n                           (not (divisible-by? n 37))\n            \
    \               (not (divisible-by? n 41))\n                           (not (divisible-by?\
    \ n 43))\n                           (not (divisible-by? n 47))\n            \
    \               (not (divisible-by? n 53))\n                           (not (divisible-by?\
    \ n 59))\n                           (not (divisible-by? n 61))\n            \
    \               (not (divisible-by? n 67))\n                           (not (divisible-by?\
    \ n 71))\n                           (not (divisible-by? n 73))\n            \
    \               (not (divisible-by? n 79))\n                           (not (divisible-by?\
    \ n 83))\n                           (not (divisible-by? n 89))\n            \
    \               (not (divisible-by? n 97))\n                           )))\n \
    \ (define (prime-fib n)\n    (define f (fibs n))\n    (if (is-prime? f) f\n  \
    \      (prime-fib (+ n 1))))\n  (prime-fib n))\n", "  (let loop ([n n] [i 2] [l\
    \ 2] [acc 2])\n    (cond\n      [(= n 1) (values acc)]\n      [(= l acc) (loop\
    \ (- n 1) i (+ i l) (+ i l)))\n      [(prime? (+ i l)) (loop n (+ i l) l (+ i\
    \ l))]\n      [else (loop n (+ i l) l acc)])))\n", "  (let loop ([x 1] [y 2] [t\
    \ 3] [count 1])\n    (cond ((> count n) x)\n          ((and (prime? t) (prime?\
    \ y)) (loop y t (+ y t) (+ count 1)))\n          (else (loop x y t count)))))\n",
  "  (letrec ((fib-prime\n            (lambda (i acc1 acc2)\n              (cond\n\
    \                ((= i n) (if (is-prime? acc1) acc1 acc2))\n                ((is-prime?\
    \ acc1) (fib-prime (+ i 1) (+ acc1 acc2) acc1))\n                (else (fib-prime\
    \ (+ i 1) (+ acc1 acc2) acc1))))))\n    (fib-prime 1 1 0)))\n", "  (let loop ([i\
    \ 0] [prev-fib 1] [fib 1])\n    (if (= i n)\n        fib\n        (if (and (prime?\
    \ fib)\n                 (= i (+ n 1)))\n            fib\n            (loop (+\
    \ i 1) fib (+ fib prev-fib))))))\n", "  (define (prime_fib_helper fibs current\
    \ n)\n    (cond [(= n 1) (car fibs)]\n          [(= n (add1 current)) (car fibs)]\n\
    \          [else (prime_fib_helper (cons (if (and (prime? (car fibs)) (fib? (car\
    \ fibs))) (car fibs) -1) fibs) (add1 current) n)]))\n  (prime_fib_helper (list\
    \ 0 1) 2 n))\n", "  (cond [(= n 1)\n         2]\n        [(= n 2)\n         3]\n\
    \        [else\n         (if (is_prime? (+ (prime_fib (- n 1)) (prime_fib (- n\
    \ 2))))\n             (+ (prime_fib (- n 1)) (prime_fib (- n 2)))\n          \
    \   (prime_fib n))]))\n", "  (define (get_fib_number n)\n    (cond\n      [(=\
    \ n 1) 2]\n      [(= n 2) 3]\n      [else (+ (get_fib_number (- n 1)) (get_fib_number\
    \ (- n 2)))]))\n  (define (next_prime n)\n    (cond\n      [(= n 2) 3]\n     \
    \ [else (+ n 2)]))\n  (define (next_fib_prime i n)\n    (cond\n      [(= i n)\
    \ n]\n      [(= (remainder n 2) 0) (next_fib_prime i (next_prime n))]\n      [(=\
    \ (remainder n 3) 0) (next_fib_prime i (next_prime n))]\n      [(= (remainder\
    \ n 5) 0) (next_fib_prime i (next_prime n))]\n      [(= (remainder n 7) 0) (next_fib_prime\
    \ i (next_prime n))]\n      [else\n       (if (<= (get_fib_number n) n)\n    \
    \       (next_fib_prime (+ i 1) (next_prime n))\n           (next_fib_prime i\
    \ (next_prime n)))]))\n  (next_fib_prime 1 n))", "  (define (is-prime? n)\n  \
    \  (if (= n 1)\n        #f\n        (if (= n 2)\n            #t\n            (if\
    \ (even? n)\n                #f\n                (define (is-dividable-by? m n)\n\
    \                  (if (> m n)\n                      #f\n                   \
    \   (if (= (modulo n m) 0)\n                          #t\n                   \
    \       (is-dividable-by? (+ m 1) n))))\n              (is-dividable-by? 3 n)))))\n\
    \  (define (fib n)\n    (if (<= n 2)\n        1\n        (+ (fib (- n 1)) (fib\
    \ (- n 2)))))\n  (define (prime-fibs n)\n    (if (= n 1)\n        (cons 2 null)\n\
    \        (let* ([f (fib n)]\n               [ps (prime-fibs (- n 1))])\n     \
    \     (if (is-prime? f)\n              (cons f ps)\n              ps))))\n  (car\
    \ (prime-fibs n)))", "  (define (next fib-1 fib-2 i)\n    (cond\n      [(< n i)\
    \ fib-1]\n      [(and (prime? fib-1) (prime? fib-2)) (next (+ fib-1 fib-2) fib-1\
    \ (+ i 1))]\n      [else (next (+ fib-1 fib-2) fib-1 (+ i 1))]))\n  (next 2 1\
    \ 1))\n", "  (if (< n 1) (error \"n should be greater than 0\")\n      (define\
    \ (fib_gen)\n        (let loop ((n1 0) (n2 1))\n          (define n3 (+ n1 n2))\n\
    \          (cons n3 (loop n2 n3))))\n      (define (fib_primes lis)\n        (cond\
    \ ((null? lis) empty)\n              ((and (prime? (car lis)) (prime? (cadr lis)))\n\
    \               (cons (car lis) (fib_primes (cdr lis))))\n              (else\
    \ (fib_primes (cdr lis)))))\n      (list-ref (fib_primes (fib_gen)) (- n 1))))",
  "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n        ((= n 3) 5)\n        ((= n 4)\
    \ 13)\n        ((= n 5) 89)\n        (else (prime_fib (+ n -1)))))\n", "  (for/fold\
    \ ([cnt 0] [i 1])\n            ([_ (in-naturals)] [j (in-naturals)])\n       \
    \     (cond\n              [(= cnt n) i]\n              [(and (prime? (+ i j))\
    \ (= cnt (- n 1))) (+ i j)]\n              [(prime? (+ i j)) (values (add1 cnt)\
    \ (+ i j))]\n              [else (values cnt i)])))\n", "  (define (a n)\n   \
    \ (cond ((= n 1) 2)\n          ((= n 2) 3)\n          (else (+ (a (- n 1)) (a\
    \ (- n 2))))))\n  (define (is_prime n)\n    (define (iter x)\n      (cond ((>\
    \ (* x x) n) #t)\n            ((= 0 (modulo n x)) #f)\n            (else (iter\
    \ (+ x 1)))))\n    (iter 2))\n  (define (iter n k)\n    (cond ((= n 1) (a k))\n\
    \          ((is_prime (a k)) (iter (- n 1) (+ k 1)))\n          (else (iter n\
    \ (+ k 1)))))\n  (iter n 1))\n```\n\n```\n#lang racket\n", "  (local ((define\
    \ fibs (list 1 1)))\n    (for/fold ([current 0]\n               [counter 1])\n\
    \             ([i (in-range 1 1000)])\n      (set! fibs (cons (+ (car fibs) (cadr\
    \ fibs)) fibs))\n      (if (and (prime? (car fibs)) (= counter n))\n         \
    \ (begin (set! current (car fibs))\n                 (set! counter (+ counter\
    \ 1)))))))\n", "  (define (helper i acc a b)\n    (cond\n      [(= i n) acc]\n\
    \      [(and (prime? b) (= i (- n 1))) (helper i b b (+ a b))]\n      [else (helper\
    \ (+ i 1) acc b (+ a b))]))\n  (helper 1 0 2 1))\n", "  (define fib-nums\n   \
    \ (map\n      (lambda (n) (fib n))\n      (iota n 1)))\n  (define prime-nums\n\
    \    (filter\n      (lambda (n) (prime? n))\n      fib-nums))\n  (list-ref prime-nums\
    \ (- n 1)))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [else\n     (let\
    \ ([fib_n-1 (prime_fib (- n 1))]\n           [fib_n-2 (prime_fib (- n 2))])\n\
    \       (define (fib a b)\n         (cond\n           [(prime? a) a]\n       \
    \    [else (fib (+ a b) a)]))\n       (fib (+ fib_n-1 fib_n-2) fib_n-1))]))\n",
  "  (let loop ([i 1] [x 1] [y 1] [z 1])\n    (cond\n      [(= i n) z]\n      [(and\
    \ (prime? x) (prime? y)) (loop (+ i 1) y (+ x y) (+ x y))]\n      [else (loop\
    \ i y (+ x y) z)])))\n", "  (let* ((fibonacci (in-naturals fibonacci-generator))\n\
    \         (prime (in-naturals prime-generator))\n         (result (for/first ([fib\
    \ (in-list fibonacci)]\n                             [p (in-list prime)])\n  \
    \                  (if (= fib p)\n                        fib))))\n    (list-ref\
    \ result (sub1 n))))\n", "  (define (helper prime-cnt curr-val next-val)\n   \
    \ (if (= prime-cnt n)\n        curr-val\n        (if (prime? next-val)\n     \
    \       (helper (+ prime-cnt 1) next-val (+ curr-val next-val))\n            (helper\
    \ prime-cnt next-val (+ curr-val next-val)))))\n  (helper 1 2 3))\n", "  (for/first\
    \ ([fib (in-fibonacci)])\n    (when (prime? fib)\n      (when (= 1 n)\n      \
    \  fib))))\n", "  (if (= n 1)\n      2\n      (letrec ([fib (lambda (m)\n    \
    \                 (if (= m 0)\n                         1\n                  \
    \       (if (= m 1)\n                             1\n                        \
    \     (+ (fib (- m 1)) (fib (- m 2))))))]\n              [is_prime (lambda (k)\n\
    \                          (letrec ([is_prime_iter (lambda (l acc)\n         \
    \                                           (if (= l 1)\n                    \
    \                                    acc\n                                   \
    \                     (if (= (modulo k l) 0)\n                               \
    \                             #f\n                                           \
    \                 (is_prime_iter (- l 1) acc))))])\n                         \
    \   (is_prime_iter (floor (/ k 2)) #t)))])\n        (letrec ([find_prime_fib (lambda\
    \ (x acc)\n                                   (if (= x n)\n                  \
    \                     acc\n                                       (if (is_prime\
    \ (fib x))\n                                           (find_prime_fib (+ x 1)\
    \ (fib x))\n                                           (find_prime_fib (+ x 1)\
    \ acc))))])\n          (find_prime_fib 1 2))))))\n```\n\n```\n#lang racket\n",
  "  (if (= n 1)\n      2\n      (if (= n 2)\n          3\n          (if (= n 3)\n\
    \              5\n              (if (= n 4)\n                  13\n          \
    \        (if (= n 5)\n                      89\n                      0\n    \
    \              )\n              )\n          )\n      )\n  )\n)\n```\n\n[Back\
    \ to problem](#P0024)\n\n### Solution 2\n\n```racket\n#lang racket\n", "  (define\
    \ (fibs)\n    (let ([a 1] [b 1])\n      (let loop ([a a] [b b])\n        (cons\
    \ a (loop b (+ a b))))))\n  (define (is-prime? n)\n    (let ([range (for/list\
    \ ([i (in-range 2 (floor (sqrt n)))])\n                   i)])\n      (cond\n\
    \        [(empty? range) #t]\n        [(zero? (modulo n (first range))) #f]\n\
    \        [else (is-prime? n (rest range))])))\n  (for/first ([x (in-list (fibs))]\n\
    \              #:when (is-prime? x))\n    x))", "  (if (= n 1)\n      2\n    \
    \  (let ([a 1] [b 2] [r 0] [count 0])\n        (while (< count n)\n          (set!\
    \ r (+ a b))\n          (set! a b)\n          (set! b r)\n          (if (prime?\
    \ r)\n              (set! count (+ count 1))))\n        r)))\n", "  (cond [(=\
    \ n 1) 2]\n        [(= n 2) 3]\n        [else\n         (let loop ([a 3] [b 5]\
    \ [count 2])\n           (if (= count n) b\n               (if (prime? b) (loop\
    \ (+ a b) (+ a b a) (+ count 1))\n                   (loop b (+ a b a) count))))]))\n",
  "  (define (fib n)\n    (cond\n      [(= n 1) 1]\n      [(= n 2) 1]\n      [else\
    \ (+ (fib (- n 1)) (fib (- n 2)))]))\n  (define (is_prime? n)\n    (cond\n   \
    \   [(= n 1) #f]\n      [(= n 2) #t]\n      [(= (remainder n 2) 0) #f]\n     \
    \ [else\n       (let ([(is-prime? n) #t])\n         (for ([num (in-range (+ n\
    \ 1) (* 2 n) 2)])\n           (when (zero? (remainder n num))\n             (set!\
    \ is-prime? #f)))\n         is-prime?)]))\n  (define (get_prime_fib n)\n    (cond\n\
    \      [(= n 1) 2]\n      [(= n 2) 3]\n      [else\n       (let ([(get-prime-fib\
    \ n) 5])\n         (let loop ([num 4])\n           (cond\n             [(= num\
    \ n) get-prime-fib]\n             [else\n              (if (and (prime? (fib num))\n\
    \                       (and (not (= 0 (remainder (fib num) 5)))\n           \
    \                 (not (= 0 (remainder (fib num) 2)))))\n                  (begin\n\
    \                    (set! get-prime-fib (fib num))\n                    (loop\
    \ (+ num 1))))])))]))\n  (get_prime_fib n))", "  (cond\n    ((< n 1) -1)\n   \
    \ ((= n 1) 2)\n    ((= n 2) 3)\n    (else\n      (let loop ([fn1 2] [fn 2] [counter\
    \ 2])\n        (if (= counter n)\n            fn\n            (if (and (fib? fn)\
    \ (prime? fn))\n                (loop fn (+ fn fn1) (+ counter 1))\n         \
    \       (loop fn (+ fn fn1) counter)))))))\n", "  (define (fib-iter a b p counter)\n\
    \    (cond ((= counter n) b)\n          ((prime? p) (fib-iter b (+ a b) (+ a b)\
    \ (+ counter 1)))\n          (else (fib-iter b (+ a b) (+ a b) counter))))\n \
    \ (fib-iter 0 1 1 1))\n", "  (let loop ([n n] [a 1] [b 2] [i 1])\n    (cond\n\
    \      [(= n i) b]\n      [(and (= a 0) (prime? b)) (loop n b (+ a b) (+ i 1))]\n\
    \      [else (loop n (+ a b) b (+ i 1))])))\n", "  (if (equal? n 1) 2\n      (let\
    \ loop ([a 2] [b 3] [i 2])\n        (if (= i n) b\n            (let ([c (+ a b)])\n\
    \              (if (is-prime? c) (loop b c (+ i 1))\n                  (loop b\
    \ c i)))))))\n", "  (cond ((< n 1) (error \"argument must be a positive integer\"\
    ))\n        ((= n 1) 2)\n        ((= n 2) 3)\n        (else\n         (let loop\
    \ ((a 2) (b 3) (i 2))\n           (if (= i n)\n               b\n            \
    \   (let* ((f (+ a b))\n                      (a b)\n                      (b\
    \ f)\n                      (i (+ i 1)))\n                 (if (prime? f)\n  \
    \                   (loop a b i)\n                     (loop a b i))))))))\n",
  "  (cond [(zero? n)\n         2]\n        [else\n         (let loop ([i 1] [fnum\
    \ 2] [num 2])\n           (if (= i n)\n               fnum\n               (if\
    \ (and (fib? num) (prime? num))\n                   (loop (+ i 1) num (+ num 1))\n\
    \                   (loop i fnum (+ num 1))))))]))\n", "  (let f ([c 0] [a 0]\
    \ [b 1])\n    (cond\n      [(= n c) a]\n      [(and (= (mod b 2) 1) (prime? b))\
    \ (f (+ c 1) b (+ a b))]\n      [else (f c a b)])))\n", "  (define (fib-iter n1\
    \ n2 counter)\n    (cond ((= counter n) n2)\n          ((not (prime? n2)) (fib-iter\
    \ n2 (+ n1 n2) counter))\n          (else (fib-iter (+ n1 n2) (+ n1 n2) (+ counter\
    \ 1)))))\n  (fib-iter 0 1 1))\n", "  (if (= n 1)\n      2\n      (let loop ([x\
    \ 2] [i 2])\n        (if (= i n)\n            x\n            (if (prime? (+ (fib\
    \ (+ i 1)) x))\n                (loop (+ (fib (+ i 1)) x) (+ i 1))\n         \
    \       (loop x (+ i 1)))))))\n", "  (let ((fibs (map fibonacci (range 1 n))))\n\
    \    (first (filter prime? fibs))))\n", "  (define (is_prime? x)\n    (cond\n\
    \      [(= x 1) #f]\n      [(= x 2) #t]\n      [(even? x) #f]\n      [else\n \
    \      (not (member (exact-floor (/ x 2)) (build-list (exact-floor (/ x 2)) (lambda\
    \ (i) (1+ i)))))]))\n  (define (build-fib-prime-list lst)\n    (define (f n)\n\
    \      (cond\n        [(= n 1) #f]\n        [(= n 2) #t]\n        [(even? n) #f]\n\
    \        [else\n         (not (member (exact-floor (/ n 2)) (build-list (exact-floor\
    \ (/ n 2)) (lambda (i) (1+ i)))))]))\n    (let ([fibo (build-list lst (lambda\
    \ (x) (fib x)))])\n      (for/list ([i fibo])\n        (cond\n          [(is_prime?\
    \ i) i]\n          [else #f]))))\n  (define (nth-prime-fib lst)\n    (let ([prime-fib\
    \ (build-fib-prime-list lst)])\n      (define (erase-falses lst)\n        (cond\n\
    \          [(null? lst) '()]\n          [(not (false? (car lst))) (cons (car lst)\
    \ (erase-falses (cdr lst)))]\n          [else (erase-falses (cdr lst))]))\n  \
    \    (list-ref (erase-falses prime-fib) (- n 1))))\n  (nth-prime-fib n))", " \
    \ (define fib\n    (lambda (n)\n      (if (= n 1)\n          1\n          (if\
    \ (= n 2)\n              2\n              (+ (fib (- n 1)) (fib (- n 2)))))))\n\
    \  (define is_prime\n    (lambda (n)\n      (or (= n 2)\n          (or (= n 3)\n\
    \              (or (= n 5)\n                  (or (= n 7)\n                  \
    \    (or (= n 11)\n                          (or (= n 13)\n                  \
    \            (or (= n 17)\n                                  (or (= n 19)\n  \
    \                                    (or (= n 23)\n                          \
    \                (or (= n 29)\n                                              (or\
    \ (= n 31)\n                                                  (or (= n 37)\n \
    \                                                     (or (= n 41)\n         \
    \                                                 (or (= n 43)\n             \
    \                                                 (or (= n 47)\n             \
    \                                                     (or (= n 53)\n         \
    \                                                             (or (= n 59)\n \
    \                                                                         (or\
    \ (= n 61)\n                                                                 \
    \             (or (= n 67)\n                                                 \
    \                                 (or (= n 71)\n                             \
    \                                                         (or (= n 73)\n     \
    \                                                                            \
    \         (or (= n 79)\n                                                     \
    \                                         (or (= n 83)\n                     \
    \                                                                            \
    \ (or (= n 89)\n                                                             \
    \                                         (or (= n 97)\n                     \
    \                                                                            \
    \         (or (= n 101)\n                                                    \
    \                                                          (or (= n 103)\n   \
    \                                                                            \
    \                                   (or (= n 107)\n                          \
    \                                                                            \
    \                (or (= n 109)\n                                             \
    \                                                                            \
    \ (or (= n 113)\n                                                            \
    \                                                                  (or (= n 127)\n\
    \                                                                            \
    \                                                      (or (= n 131)\n       \
    \                                                                            \
    \                                                   (or (= n 137)\n          \
    \                                                                            \
    \                                                    (or (= n 139)\n         \
    \                                                                            \
    \                                                         (or (= n 149)\n    \
    \                                                                            \
    \                                                                  (or (= n 151)\n\
    \                                                                            \
    \                                                                          (or\
    \ (= n 157)\n                                                                \
    \                ", "  (cond ((= n 1) 2)\n        ((= n 2) 3)\n        ((even?\
    \ n) (prime_fib (- n 1)))\n        (else (prime_fib (- n 1)))))\n", "  (if (=\
    \ n 1)\n      2\n      (let loop ([primes '(2 3 5 7)] [a 0] [b 1] [k 1])\n   \
    \     (cond\n          [(= k n) b]\n          [(and (= 0 (modulo b 2)) (member\
    \ b primes)) (loop primes b (+ a b) (+ k 1))]\n          [else (loop (cons b primes)\
    \ b (+ a b) (+ k 1))]))))", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n      \
    \  [else (next_prime_fib (+ 2 (prime_fib (- n 1))))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
