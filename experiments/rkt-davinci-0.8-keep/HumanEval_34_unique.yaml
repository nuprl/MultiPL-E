name: HumanEval_34_unique
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique elements in a list\n;; >>> unique([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123])\n;; [0, 2, 3, 5, 9, 123]\n(define (unique l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate unique))\n\
  \    (check-equal? (candidate (list 5 3 5 2 3 3 9 0 123)) (list 0 2 3 5 9 123))\n\
  ))\n\n(test-humaneval)"
completions: ["  (if (null? l)\n      l\n      (if (member (car l) (cdr l))\n    \
    \      (unique (cdr l))\n          (cons (car l) (unique (cdr l))))))\n", "  (cond\
    \ [(empty? l) '()]\n        [(member (first l) (rest l)) (unique (rest l))]\n\
    \        [else (cons (first l) (unique (rest l)))]))\n", "  (quicksort\n   (foldl\n\
    \    (lambda (x acc)\n      (if (member x acc)\n          acc\n          (cons\
    \ x acc)))\n    '()\n    l)))\n", "  (sort (list-remove-duplicates l) &lt;))\n",
  "  (sort l #&lt;))\n", "  (sort (foldl (lambda (a b) (if (member a b) b (cons a\
    \ b))) empty l) <))\n", "  (apply set l))\n", "  (remove-duplicates (sort l <)))\n",
  "  (let loop ([l l] [r '()])\n    (cond [(empty? l) r]\n          [(member (first\
    \ l) r) (loop (rest l) r)]\n          [else (loop (rest l) (cons (first l) r))])))\n\
    </code>\n", "  (sort (remove-duplicates l) <))\n", "  (define (is-in x l)\n  \
    \  (cond [(empty? l) false]\n          [(equal? x (first l)) true]\n         \
    \ [else (is-in x (rest l))]))\n  (cond [(empty? l) empty]\n        [(is-in (first\
    \ l) (rest l)) (unique (rest l))]\n        [else (cons (first l) (unique (rest\
    \ l)))]))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest l)) l]\n   \
    \     [else (cons (first l)\n                    (unique (remover (first l) (rest\
    \ l))))]))\n", "  (define s (sort l &lt;))\n  (define (unique-inner l result)\n\
    \    (if (empty? l)\n        result\n        (if (= (first l) (first result))\n\
    \            (unique-inner (rest l) result)\n            (unique-inner (rest l)\
    \ (cons (first l) result)))))\n  (unique-inner s (list (first s))))\n", "  (cond\
    \ [(empty? l) empty]\n        [(cons? l) (unique-cons (first l) (unique (rest\
    \ l)))]))\n", "  (set-cons-as-aggregate!)\n  (list-set l))\n", "  (define (helper\
    \ l result)\n    (cond\n      [(empty? l) result]\n      [(member (first l) result)\
    \ (helper (rest l) result)]\n      [else (helper (rest l) (append result (list\
    \ (first l))))]))\n  (helper l empty))\n", "  (remove-duplicates (sort l #:key\
    \ sort-key) #:key sort-key))\n", "  (cond\n    [(empty? l) empty]\n    [else\n\
    \     (define (unique-helper lst acc)\n       (cond\n         [(empty? lst) (reverse\
    \ acc)]\n         [(member (first lst) acc) (unique-helper (rest lst) acc)]\n\
    \         [else (unique-helper (rest lst) (cons (first lst) acc))]))\n     (unique-helper\
    \ l empty)]))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest l)) (list\
    \ (first l))]\n        [else (set-remove equal? (first l) (unique (rest l)))]))\n\
    </code>\nHowever I receive the following error:\n<code>application: not a procedure;\n\
    \ expected a procedure that can be applied to arguments\n  given: '(2 3 3 5 9\
    \ 123)\n  arguments...: [none]\n</code>\nAccording to this thread this is a \"\
    circular-definition\" error, but I cannot see the problem in my code.\n\n\nA:\n\
    \nYou're using Racket's <code>cond</code> procedure, which doesn't take lists.\
    \ You probably want to use Scheme's <code>cond</code> macro, which is also available\
    \ as <code>if</code> in Racket. You can use <code>if</code> just like <code>cond</code>,\
    \ by omitting the condition.\n<code>(define (unique l)\n  (if (empty? l)\n   \
    \   empty\n      (if (empty? (rest l))\n          (list (first l))\n         \
    \ (set-remove equal? (first l) (unique (rest l))))))\n</code>\nAlternatively,\
    \ you can use the <code>cond</code> macro:\n<code>(define (unique l)\n  (cond\
    \ [(empty? l) empty]\n        [(empty? (rest l)) (list (first l))]\n        [else\
    \ (set-remove equal? (first l) (unique (rest l)))]))\n</code>\n", "  (cond [(empty?\
    \ l) '()]\n        [(empty? (cdr l)) (list (car l))]\n        [else\n        \
    \ (cons (car l)\n               (unique (filter (curry equal? (car l)) (cdr l))))]))\n",
  "  (let* ((s (set l))\n         (l (for/list ([v s])\n                v)))\n   \
    \ (sort l &lt;)))\n</code>\n", "  (sort (remove-duplicates l) <))\n", "  (cond\
    \ [(empty? l) (list)]\n        [(empty? (rest l)) (list (first l))]\n        [else\
    \ (define rest-unique (unique (rest l)))\n              (if (equal? (first l)\
    \ (first rest-unique))\n                  rest-unique\n                  (cons\
    \ (first l) rest-unique))]))\n", "  (sort l #:key (lambda (x) x)))\n", "  (cond\n\
    \    [(empty? l) (list)]\n    [(cons? l)\n     (define next (cdr l))\n     (define\
    \ val (car l))\n     (define rest (unique next))\n     (if (and (not (member val\
    \ rest))\n              (not (member val next)))\n         (cons val rest)\n \
    \        rest)]))\n", "  (hash-delete-duplicates (hash) (sort l <)))\n", "  (list-sort\
    \ <= (hash-remove-duplicates (build-hasheq l))))\n", "  (sort l <))\n", "  (sort\
    \ (remove-duplicates l) &lt;))\n", "  (let* ([s (set l)]\n         [a (sort s\
    \ <)])\n    a))\n", "  (sort (foldl (lambda (x acc) (cons x (remove x acc)))\n\
    \               empty l)\n        <))\n", "  (cond\n    [(empty? l) '()]\n   \
    \ [(member (first l) (rest l)) (unique (rest l))]\n    [else (cons (first l) (unique\
    \ (rest l)))]))\n", "  (if (empty? l)\n      l\n      (define (u l acc)\n    \
    \    (if (empty? l)\n            acc\n            (let ([a (first l)])\n     \
    \         (if (member a acc)\n                  (u (rest l) acc)\n           \
    \       (u (rest l) (cons a acc))))))\n      (sort (u l empty) <)))\n", "  (remove-duplicates\
    \ (sort l)))\n", "  (define (recur lst prev result)\n    (if (null? lst)\n   \
    \     result\n        (if (&lt;= (car lst) prev)\n            (recur (cdr lst)\
    \ prev result)\n            (recur (cdr lst) (car lst) (cons (car lst) result)))))\n\
    \  (reverse (recur l -1 '())))\n", "  (cond [(empty? l) empty]\n        [(null?\
    \ (cdr l)) l]\n        [else\n         (let ((a (car l))\n               (b (cadr\
    \ l)))\n           (if (= a b)\n               (unique (cdr l))\n            \
    \   (cons a (unique (cdr l)))))]))\n", "  (sort (remove-duplicates l)))\n", " \
    \ (cond [(empty? l) empty]\n        [(empty? (rest l)) (list (first l))]\n   \
    \     [else (unique-helper (first l) (rest l))]))\n", "  (let* ((unique-seen '())\n\
    \         (unique-seen-list (list)))\n    (for ([n l])\n      (if (not (member\
    \ n unique-seen))\n          (begin\n            (set! unique-seen (cons n unique-seen))\n\
    \            (set! unique-seen-list (cons n unique-seen-list)))))\n    (reverse\
    \ unique-seen-list)))\n```\n\n## unique-sublists\n\n```racket\n#lang racket\n",
  "  (sort l <))\n```\n\n#### Set\n\n``` #lang racket\n", "  (set-equal? l (remove-duplicates\
    \ l)))\n", "  (set-equal?\n   (sort l)\n   (remove-duplicates (sort l))))\n",
  "  (if (empty? l)\n      '()\n      (cons (first l) (unique (filter (lambda (x)\
    \ (not (equal? x (first l)))) (rest l))))))\n", "  (hash-remove-duplicates\n \
    \  (hash)\n   (sort l <)))\n", "  (sort (set l) <))\n", "  (sort l <)\n  (for/fold\
    \ ([acc '()]) ([e l])\n    (cond [(member e acc) acc]\n          [else (cons e\
    \ acc)])))\n", "  (sort l #<?))\n", "  (set! l (sort l <))\n  (set! l (for/list\
    \ ([e l] #:when (not (member e (rest l)))) e))\n  l)", "  (sort (set l) <))\n\
    ```\n\n```racket\n#lang racket\n", "  (remove-duplicates (sort l)))\n", "  (cond\n\
    \    [(empty? l)\n     empty]\n    [(empty? (rest l))\n     (list (first l))]\n\
    \    [else\n     (cons (first l)\n           (unique (remove (first l) (rest l))))]))\n",
  "  (sort (remove-duplicates l) <))\n", "  (cond [(empty? l) empty]\n        [(empty?\
    \ (rest l)) l]\n        [else\n         (unique (unique-helper (first l) (rest\
    \ l)))]))\n", "  (if (null? l)\n      '()\n      (append (list (car l)) (unique\
    \ (remq (car l) (cdr l))))))\n", "  (sort l #:cmp < #:key car))\n", "  (sort (remove-duplicates\
    \ l) <))\n", "  (set-difference (build-list (add1 (length l)) (\u03BB (i) i))\
    \ l))\n", "  (let* ((x (first l))\n         (ys (rest l))\n         (filtered\
    \ (filter (\u03BB (a) (not (= a x))) ys)))\n    (if (null? filtered)\n       \
    \ (list x)\n        (append (unique filtered) (list x)))))\n", "  (apply set l))\n",
  "  (apply set l))\n", "  (filter (lambda (e) (andmap (lambda (i) (not (= e i)))\
    \ l)) l))\n", "  (sort l #:key (lambda (x) x) #:distinct? #t))\n", "  (sort (remove-duplicates\
    \ l) &lt;))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest l)) l]\n \
    \       [else (cons (first l) (unique (remove (first l) (rest l))))]))\n", " \
    \ (apply list (quicksort l)))\n", "  (sort (remove-duplicates l) <))\n</code>\n\
    This is a solution to a question in a book that I'm working through, but I'm confused\
    \ by the result when I enter the example list given in the problem:\n<code>&gt;\
    \ (unique '(5 3 5 2 3 3 9 0 123))\n'(0 2 3 5 9 123)\n</code>\nSo I'm getting the\
    \ right result, but why are the numbers surrounded by quotes and single quotes?\
    \ \nThanks\n\n\nA:\n\nRacket will quote lists and symbols by default when printing.\
    \ The result of your function is a list of numbers:\n<code>&gt; (unique '(5 3\
    \ 5 2 3 3 9 0 123))\n'(0 2 3 5 9 123)\n&gt; (unique '(5 3 5 2 3 3 9 0 123))",
  "  (cond [(empty? l) empty]\n        [(empty? (rest l)) l]\n        [else\n    \
    \     (cons (first l)\n               (unique (filter (lambda (x) (not (= x (first\
    \ l)))) (rest l))))]))\n", "  (sort l #:key #&lt;))\n</code>\n", "  (unique-core\
    \ l '()))\n", "  (sort (delete-duplicates l) <))\n", "  (sort (remove-duplicates\
    \ l) <))\n", "  (sort (remove-duplicates l) <))\n", "  (set-remove-duplicates\
    \ (sort l <)))\n", "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first\
    \ l)\n           (unique (remove (first l) (rest l))))]))\n", "  (sort (list-set\
    \ l) &lt;))\n", "  (sort (build-list (length l) (\u03BB (i) (list-ref l i))) <))\n",
  "  (sort (remdup l) <))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest\
    \ l)) (list (first l))]\n        [else (cons (first l) (unique (remq (first l)\
    \ (rest l))))]))\n", "  (sort l #&lt;)\n  (let loop ([l l] [result '()])\n   \
    \ (cond [(empty? l) (reverse result)]\n          [(member (first l) result) (loop\
    \ (rest l) result)]\n          [else (loop (rest l) (cons (first l) result))])))\n\
    </code>\nI used the built-in <code>sort</code> function from <code>Racket</code>\
    \ to have the list sorted before creating the unique elements.\n", "  (sort l\
    \ <))\n", "  (remove-duplicates l #:equal? equal?))\n", "  (cond [(empty? l) empty]\n\
    \        [(member (first l) (rest l)) (unique (rest l))]\n        [else (cons\
    \ (first l) (unique (rest l)))]))\n", "  (apply max (list->set l)))\n", "  (sort\
    \ (remove-duplicates l) <))\n```\n\n```racket\n#lang racket\n", "  (define (loop\
    \ unique l)\n    (cond [(empty? l) (reverse unique)]\n          [(member (first\
    \ l) unique) (loop unique (rest l))]\n          [else (loop (cons (first l) unique)\
    \ (rest l))]))\n  (loop (list) l))\n", "  (cond\n    [(empty? l) '()]\n    [(memq\
    \ (first l) (rest l)) (unique (rest l))]\n    [else (cons (first l) (unique (rest\
    \ l)))]))\n", "  (define (equal? x y)\n    (equal? (list-ref x 0) (list-ref y\
    \ 0)))\n  (define (unique-tr l acc)\n    (cond\n      [(empty? l) (sort acc (lambda\
    \ (x y) (< (list-ref x 0) (list-ref y 0))))]\n      [(member (first l) acc equal?)\
    \ (unique-tr (rest l) acc)]\n      [else (unique-tr (rest l) (cons (first l) acc))]))\n\
    \  (unique-tr l (list)))\n```\n\n### [Ternary](https://github.com/svelgmon/racket-katas/blob/master/katas/ternary.rkt)\n\
    \n```racket\n#lang racket\n", "  (define (iter result input)\n    (cond [(empty?\
    \ input) result]\n          [(member (first input) result) (iter result (rest\
    \ input))]\n          [else (iter (append result (list (first input))) (rest input))]))\n\
    \  (iter (list) l))\n```\n\nThis code can be found in a slightly modified form\
    \ [here](./javascript/unique.js).\n\n## Odd and Even\n\nGiven a list of numbers,\
    \ return a list of those which are odd and those which are even, respectively.\n\
    \n### Lua\n\n```Lua\nfunction isEven(n)\n  if n % 2 == 0 then\n    return true\n\
    \  else\n    return false\n  end\nend\n\nfunction oddAndEven(input)\n  local odds\
    \ = {}\n  local evens = {}\n  for _, v in ipairs(input) do\n    if isEven(v) then\n\
    \      table.insert(evens, v)\n    else\n      table.insert(odds, v)\n    end\n\
    \  end\n  return odds, evens\nend\n```\n\n### Racket\n\n```racket", "  (remove-duplicates\
    \ (sort l <)))\n", "  (sort l <))\n```\n\nThe `racket` language is pretty cool.\
    \ It comes with a standard library and an\ninteractive repl (just like ruby).\
    \ We can even use the `require` keyword to load\nany racket module.\n\n## Running\n\
    \nSimply run `/bin/bash run.sh` to run all code in the directory. Each solution\n\
    should print the results.\n\nYou can also manually run each solution with `racket\
    \ [solution]` or `racket\n[solution] [input]` if you have inputs.\n\n## Tests\n\
    \nThere are no tests. Because each solution should print the results, simply\n\
    verify that the results are correct.\n\n## Resources\n\n- [Racket docs](https://docs.racket-lang.org/index.html)\n\
    - [Racket Style Guide](https://docs.racket-lang.org/style/index.html)\n- [Stack\
    \ Overflow](https://stackoverflow.com/questions/tagged/racket)", "  (sort (remove-duplicates\
    \ l) <))\n", "  (sort l #:key identity #:cmp < #:distinct? #t))\n", "  (define\
    \ (aux l acc)\n    (cond\n      [(empty? l) acc]\n      [(not (memq (first l)\
    \ acc)) (aux (rest l) (cons (first l) acc))]\n      [else (aux (rest l) acc)]))\n\
    \  (aux l '()))\n", "  (if (null? l) l\n      (cons (car l) (unique (remove (car\
    \ l) (cdr l))))))\n", "  (sort (remove-duplicates l) <))\n", "  (cond ((null?\
    \ l) l)\n        ((null? (cdr l)) l)\n        (else (let ((c (car l))\n      \
    \               (r (unique (cdr l))))\n                (if (memq c r) r (cons\
    \ c r))))))\n", "  (sort l <))\n", "  (cond ((null? l) '())\n        ((member\
    \ (car l) (cdr l)) (unique (cdr l)))\n        (else (cons (car l) (unique (cdr\
    \ l))))))\n", "  (set! l (sort l <))\n  (cond [(null? l) l]\n        [(null? (cdr\
    \ l)) l]\n        [else\n         (if (= (car l) (cadr l))\n             (unique\
    \ (cdr l))\n             (cons (car l) (unique (cdr l))))]))\n", "  (sort l <))\n",
  "  (sort (set l) <))\n", "  (sort (hash-remove-duplicates (map hash l)) <))\n",
  "  (define s (set l))\n  (sort s <))\n", "  (set-car! l '())\n  (sort (remove-duplicates\
    \ l) #:key car &lt;))\n</code>\nThe original version is longer and doesn't seem\
    \ as elegant. Also, I don't understand why I need to use <code>#:key car</code>.\
    \ Why does <code>&lt;</code> not do what I want?\nAny other optimizations you\
    \ can think of?\n\n\nA:\n\nThe problem you're having is that <code>sort</code>\
    \ is trying to compare two lists, which it can't do, so you get an error. If you\
    \ use <code>#:key car</code>, it will compare the first element of each list,\
    \ which is what you wanted. Your code is fine otherwise.\n", "  (apply list (sort\
    \ l <)))\n", "  (sort (remove-duplicates l) <))\n", "  (sort (list-&gt;set l)\
    \ &lt;))\n", "  (unique' (sort l) '()))\n", "  (sort (remove-duplicates l) <))\n",
  "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first l)\n           (unique\
    \ (remove (first l) (rest l))))]))\n", "  (sort l <))\n", "  (unique' l '()))\n",
  "  (filter (lambda (x)\n            (even? x))\n          l))", "  (sort (remove-duplicates\
    \ l) <))\n", "  (if (empty? l)\n      empty\n      (cons (first l)\n         \
    \   (unique (remove (first l) (remove-all (first l) (rest l)))))))\n", "  (sort\
    \ l #:key (\u03BB (e) e)))\n", "  (sort l &lt;))\n", "  (define (unique-iter l\
    \ acc seen)\n    (cond\n      [(empty? l) (reverse acc)]\n      [(member (first\
    \ l) seen) (unique-iter (rest l) acc seen)]\n      [else (unique-iter (rest l)\
    \ (cons (first l) acc) (cons (first l) seen))]))\n  (unique-iter l '() '()))\n",
  "  (cond\n    [(empty? l) '()]\n    [(empty? (rest l)) (list (first l))]\n    [else\
    \ (unique (unique-helper (first l) (rest l)))]))\n", "  (apply append (hash-keys\
    \ (hash l))))\n", "  (if (null? l)\n      '()\n      (begin\n        (define (unique-helper\
    \ l elist)\n          (if (null? l)\n              elist\n              (unique-helper\
    \ (cdr l) (cons (car l) elist))))\n        (sort (unique-helper l '()) <))))\n\
    ```\n\n### Binary Search\n\n```\n#lang racket\n", "  (sort (remove-duplicates\
    \ l) <))\n", "  (sort l #&lt;))\n", "  (define (ins x l)\n    (cond\n      [(null?\
    \ l) (list x)]\n      [(< x (car l)) (cons x l)]\n      [else (cons (car l) (ins\
    \ x (cdr l)))]))\n  (if (null? l)\n      (list)\n      (ins (car l) (unique (cdr\
    \ l)))))\n", "  (remove-duplicates l))\n", "  (remove-duplicates (sort l)))\n",
  "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first l)\n           (unique\
    \ (filter (lambda (x) (not (equal? x (first l)))) (rest l))))]))\n", "  (sort\
    \ l #&lt;))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest l)) (list\
    \ (first l))]\n        [else (define x (first l))\n         (define xs (unique\
    \ (rest l)))\n         (cond [(member x xs) xs]\n               [else (cons x\
    \ xs)])]))\n", "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first\
    \ l)\n           (unique (filter (lambda (x) (not (equal? x (first l)))) (rest\
    \ l))))]))\n", "  (define (contains? l e)\n    (cond ((null? l) #f)\n        \
    \  ((equal? (car l) e) #t)\n          (else (contains? (cdr l) e))))\n  (define\
    \ (loop l u)\n    (cond ((null? l) (reverse u))\n          ((contains? u (car\
    \ l)) (loop (cdr l) u))\n          (else (loop (cdr l) (cons (car l) u)))))\n\
    \  (loop l '()))\n", "  (remove-duplicates (sort l)))\n", "  (if (null? l)\n \
    \     '()\n      (let ((not-unique? (member (car l) (cdr l))))\n        (if not-unique?\n\
    \            (unique (cdr l))\n            (cons (car l) (unique (cdr l)))))))",
  "  (if (null? l)\n      '()\n      (sort (remove-duplicates l) <)))\n", "  (sort\
    \ (remove-duplicates l)))\n", "  (apply set l))\n", "  (filter (lambda (x) (not\
    \ (member x (cdr l)))) l))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest\
    \ l)) (list (first l))]\n        [else (let* ([res (unique (rest l))]\n      \
    \              [first-elem (first l)])\n                 (cond [(empty? res) (list\
    \ first-elem)]\n                       [(zero? (compare first-elem (first res)))\
    \ res]\n                       [else (cons first-elem res)]))]))\n", "  (sort\
    \ l <))\n", "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first l)\n\
    \           (unique (filter (lambda (x) (not (equal? x (first l)))) (rest l))))]))\n",
  "  (cond [(empty? l) empty]\n        [(equal? (first l) (second l)) (unique (rest\
    \ l))]\n        [else (cons (first l) (unique (rest l)))]))\n", "  (letrec ([merge-uniq\
    \ (lambda (l1 l2)\n                         (cond [(empty? l1) l2]\n         \
    \                      [(empty? l2) l1]\n                               [(or (=\
    \ (first l1) (first l2))\n                                    (= (first l1) (first\
    \ (rest l2))))\n                                (merge-uniq (rest l1) (rest l2))]\n\
    \                               [(< (first l1) (first l2))\n                 \
    \               (cons (first l1) (merge-uniq (rest l1) l2))]\n               \
    \                [else\n                                (cons (first l2) (merge-uniq\
    \ l1 (rest l2)))]))]\n         [insert (lambda (l)\n                   (cond [(empty?\
    \ l) l]\n                          [else (merge-uniq (list (first l))\n      \
    \                                      (insert (rest l)))]))]\n         [sort\
    \ (lambda (l)\n                 (cond [(empty? l) l]\n                       [else\
    \ (insert (sort (rest l)))]))]\n         [uniq (lambda (l)\n                 (cond\
    \ [(empty? l) l]\n                       [(empty? (rest l)) l]\n             \
    \          [(= (first l) (first (rest l)))\n                        (uniq (rest\
    \ l))]\n                       [else (cons (first l) (uniq (rest l)))]))])\n \
    \   (uniq (sort l))))\n", "  (sort (remove-duplicates l) <))\n", "  (cond\n  \
    \  [(empty? l) (list)]\n    [(member (first l) (rest l)) (unique (rest l))]\n\
    \    [else (cons (first l) (unique (rest l)))]))\n", "  (define a (sort l))\n\
    \  (set! a (remove-duplicates a))\n  (set! a (sort a)))\n", "  (remove-duplicates\
    \ (sort l <)))\n", "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first\
    \ l)\n           (unique (filter (lambda (x) (not (= x (first l)))) (rest l))))]))\n",
  "  (let loop ([l l] [res (list)])\n    (cond [(empty? l) (sort res <)]\n       \
    \   [(member (first l) res) (loop (rest l) res)]\n          [else (loop (rest\
    \ l) (cons (first l) res))])))\n", "  (sort (remove-duplicates l) &lt;))\n", " \
    \ (sort (remove-duplicates l) &lt;))\n", "  (sort (remove-duplicates l) <))\n",
  "  (set! l (remove-duplicates l))\n  (sort l <))\n", "  (set (sort l <)))\n", " \
    \ (sort l #&lt;)\n  (cond\n    [(empty? l) '()]\n    [(cons? l)\n     (cons (first\
    \ l)\n           (unique (remq (first l) (rest l))))]))\n</code>\nHere is my implementation\
    \ in Racket.\n<code>#lang racket\n", "  (set-car! l\n    (delete-duplicates l)))\n",
  "  (sort (distinct l) <))\n", "  (sort (remove-duplicates l) <))\n", "  (sort (remove-duplicates\
    \ l) <))\n", "  (set! l (sort l <))\n  (cond [(null? l) l]\n        [(null? (cdr\
    \ l)) l]\n        [else\n         (if (= (car l) (cadr l))\n             (unique\
    \ (cdr l))\n             (cons (car l) (unique (cdr l))))]))\n```\n\n### 1.5 Stable\
    \ Unique\n```#lang racket\n", "  (cond\n    [(empty? l) empty]\n    [else\n  \
    \   (define first (first l))\n     (define rest (remove first (rest l)))\n   \
    \  (append (list first) (unique rest))]))\n```\n\n```\n#lang racket\n", "  (define\
    \ (remove-first-occurrence e l)\n    (cond\n      [(null? l) '()]\n      [(equal?\
    \ e (car l)) (cdr l)]\n      [else (cons (car l) (remove-first-occurrence e (cdr\
    \ l)))]))\n  (cond\n    [(null? l) '()]\n    [else (cons (car l) (unique (remove-first-occurrence\
    \ (car l) (cdr l))))]))\n", "  (define (helper l acc)\n    (cond [(empty? l) acc]\n\
    \          [(member (first l) acc) (helper (rest l) acc)]\n          [else (helper\
    \ (rest l) (cons (first l) acc))]))\n  (sort (helper l '()) <))\n", "  (sort (remove-duplicates\
    \ l) <))\n```\n\nIn [Racket](https://racket-lang.org) we use [`sort`](https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._sort%29%29)\
    \ and [`remove-duplicates`](https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._remove-duplicates%29%29).\n\
    \n### Solution\n\n```kotlin\nfun unique(list: List<Int>): List<Int> = list.distinct().sorted()\n\
    ```\n\nIn [Kotlin](https://kotlinlang.org) we use [`distinct`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/distinct.html)\
    \ and [`sorted`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html).\n\
    \n---\n\n## Problem 3 - Reverse words\n\nWrite a program which reverse words in\
    \ a string.\n\n### Details\n\nGiven a string consisting of words separated by\
    \ spaces. It is required to\ninvert the order of the words (not letters) in the\
    \ string. Words in the\nresult should be separated by single spaces.\n\n### Example\n\
    \nFor `text = \"CodeFights Is Pretty Cool\"`, the output should be\n`reverseWords(text)\
    \ = \"Cool Pretty Is CodeFights\"`.\n\n### Input/Output\n\n- **[execution time\
    \ limit] 4 seconds (js)**\n\n- **[input] string text**\n\n  A string consisting\
    \ of words separated by a single space.\n\n  *Guaranteed constraints:*\n\n  `4\
    \ \u2264 text.length \u2264 50`.\n\n- **[output] string**\n\n  - Text with inverted\
    \ words order.\n\n### Test 1\n\n```clojure", "  (sort (remove-duplicates l) <))\n",
  "  (set l))\n", "  (let loop ([l l] [acc '()])\n    (if (empty? l)\n        (sort\
    \ acc &lt;)\n        (if (member (first l) acc)\n            (loop (rest l) acc)\n\
    \            (loop (rest l) (cons (first l) acc))))))\n", "  (define (unique-r\
    \ acc l)\n    (cond [(empty? l) acc]\n          [(member (first l) acc) (unique-r\
    \ acc (rest l))]\n          [else (unique-r (cons (first l) acc) (rest l))]))\n\
    \  (reverse (unique-r '() l)))\n", "  (cond\n    [(empty? l) (quote ())]\n   \
    \ [(equal? (first l) (second l)) (unique (rest l))]\n    [else (cons (first l)\
    \ (unique (rest l)))]))\n", "  (define _next (apply-hash ht-next))\n  (define\
    \ _add (apply-hash ht-add))\n  (let* ([ht (make-hash)]\n         [ret (null)]\n\
    \         [current ret])\n    (for ([e l])\n      (if (ht-exists? ht e)\n    \
    \      (void)\n          (set! current (_add ht current e))\n          (set! ret\
    \ (if (eq? ret (null)) current ret))))\n    (let* ([lst (list)]\n           [e\
    \ current])\n      (while (not (eq? current (null)))\n        (set! lst (cons\
    \ (ht-value current) lst))\n        (set! current (_next current)))\n      (reverse\
    \ lst))))\n", "  (define (uniq l1 l2)\n    (cond\n      [(empty? l1) l2]\n   \
    \   [(member (first l1) l2) (uniq (rest l1) l2)]\n      [else (uniq (rest l1)\
    \ (cons (first l1) l2))]))\n  (uniq l (list)))\n", "  (sort (remove-duplicates\
    \ l)))\n", "  (sort (remove-duplicates l) <))\n", "  (sort (remove-duplicates\
    \ l) <))\n```\n\n```racket\n#lang racket\n", "  (cond [(empty? l) empty]\n   \
    \     [(cons? l)\n         (unique (sub1\n                  (unique (sub2\n  \
    \                         (unique (sub3 l))))))]))\n", "  (remove-duplicates (sort\
    \ l #<)))\n", "  (cond [(empty? l) empty]\n        [(member (first l) (rest l))\
    \ (unique (rest l))]\n        [else (cons (first l) (unique (rest l)))]))\n",
  "  (let loop ([l l] [u '()])\n    (cond [(empty? l) (sort u <)]\n          [(member\
    \ (first l) u) (loop (rest l) u)]\n          [else (loop (rest l) (cons (first\
    \ l) u))])))\n```\n\n### Erlang\n\n```erlang\n-module(unique).\n-export([unique/1]).\n\
    \nunique(List) ->\n  unique(List, []).\n\nunique([], Acc) ->\n  lists:sort(Acc);\n\
    unique([Head|Tail], Acc) ->\n  case lists:member(Head, Acc) of\n    true ->\n\
    \      unique(Tail, Acc);\n    false ->\n      unique(Tail, [Head|Acc])\n  end.\n\
    ```\n\n### Haskell\n\n```haskell\n-- Return sorted unique elements in a list\n\
    -- >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n-- [0, 2, 3, 5, 9, 123]\nunique\
    \ :: (Ord a) => [a] -> [a]\nunique = S.toList . S.fromList\n```\n\n### Lua\n\n\
    ```lua\n-- Return sorted unique elements in a list\n-- >>> unique({5, 3, 5, 2,\
    \ 3, 3, 9, 0, 123})\n-- {0, 2, 3, 5, 9, 123}\nfunction unique(t)\n  local u =\
    \ {}\n  for _, e in ipairs(t) do\n    u[e] = true\n  end\n  local r = {}\n  for\
    \ e in pairs(u) do\n    table.insert(r, e)\n  end\n  table.sort(r)\n  return r\n\
    end\n```\n\n### Perl\n\n```perl\nuse v5.10;\n\n# Return sorted unique elements\
    \ in a list\n# >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\n\
    sub unique {\n  my @l = @_;\n  my %u;\n  @u{@l} = ();\n  return sort {$a <=>",
  "  (sort l <))\n", "  (define (uq-worker set l)\n    (cond [(empty? l) (set->list\
    \ set)]\n          [(member? (first l) set) (uq-worker set (rest l))]\n      \
    \    [else (uq-worker (set add (first l)) (rest l))]))\n  (uq-worker (set) l))\n",
  "  (cond\n    [(empty? l) empty]\n    [else\n     (cons (first l)\n           (unique\
    \ (remove (first l) (rest l))))]))\n", "  (define (unique1 l a)\n    (cond ((null?\
    \ l) (reverse a))\n          ((in? (car l) a) (unique1 (cdr l) a))\n         \
    \ (else (unique1 (cdr l) (cons (car l) a)))))\n  (unique1 l '()))\n", "  (sort\
    \ (remove-duplicates l) <))\n", "  (define (uniqued i-l i-u)\n    (cond\n    \
    \  [(null? i-l) (reverse i-u)]\n      [(member (car i-l) i-u) (uniqued (cdr i-l)\
    \ i-u)]\n      [else (uniqued (cdr i-l) (cons (car i-l) i-u))]))\n  (uniqued l\
    \ '()))\n", "  (sort (list-set l) <))\n", "  (sort l #:key (lambda (x) x)))\n\
    ```\n\n## License\n\nMIT", "  (set-difference (sort l <) (sort l >)))\n", "  (sort\
    \ l <))\n", "  (sort l #&lt;)\n  (let loop ([tail (cdr l)] [result (list (car\
    \ l))])\n    (if (not (null? tail))\n        (if (member (car tail) result)\n\
    \            (loop (cdr tail) result)\n            (loop (cdr tail) (cons (car\
    \ tail) result)))\n        (reverse result))))\n</code>\nI am getting warnings\
    \ with the <code>member</code> function, but I don't know how else to determine\
    \ if a element is in a list. I could possibly use an unordered list and just return\
    \ <code>#t</code> whenever it's found, but that would be pretty inefficient.\n\
    \n\nA:\n\nYou can first use <code>sort</code> and then <code>remove-duplicates</code>\
    \ from the <code>srfi</code> module:\n<code>(require srfi/1)\n", "  (sort (remove-duplicates\
    \ l) &lt;))\n", "  (sort l <)\n  (remove-duplicates l))", "  (sort (remdup l)\
    \ <))\n", "  (filter (lambda (x) (count x l)) l))\n", "  (sort l #:key first))\n\
    </code>\n<code>#lang racket\n", "  (define (unique-iter l ret)\n    (cond ((null?\
    \ l) ret)\n          ((member (car l) ret) (unique-iter (cdr l) ret))\n      \
    \    (else (unique-iter (cdr l) (cons (car l) ret)))))\n  (sort (unique-iter l\
    \ '()) <))\n", "  (cond [(empty? l) empty]\n        [(empty? (rest l)) l]\n  \
    \      [else\n         (define c (first l))\n         (cond [(member c (rest l))\
    \ (unique (remove c (rest l)))]\n               [else (cons c (unique (rest l)))])]))\n",
  "  (sort (remove-duplicates l) <))\n", "  (cond [(empty? l) empty]\n        [(cons?\
    \ l) (car l)]\n        [else (cons (car l)\n                    (filter #f (lambda\
    \ (x) (member x (car l)))\n                            (cdr l)))]))\n", "  (sort\
    \ (remove-duplicates l) #&lt;))\n", "  (let loop ([l l] [acc '()])\n    (cond\
    \ [(empty? l) (sort acc <)]\n          [(member (first l) acc) (loop (rest l)\
    \ acc)]\n          [else (loop (rest l) (cons (first l) acc))])))\n", "  (let\
    \ ([seen '()])\n    (for ([i l])\n      (if (not (memq i seen))\n        (begin\n\
    \          (set! seen (cons i seen))\n          (displayln i))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
