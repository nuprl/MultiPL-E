name: HumanEval_44_change_base
language: rkt
prompt: "#lang racket\n\n;; Change numerical base of input number x to base.\n;; return\
  \ string representation after the conversion.\n;; base numbers are less than 10.\n\
  ;; >>> change_base(8, 3)\n;; '22'\n;; >>> change_base(8, 2)\n;; '1000'\n;; >>> change_base(7,\
  \ 2)\n;; '111'\n(define (change_base x base)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n\
  \    (check-equal? (candidate 8 3) \"22\")\n    (check-equal? (candidate 9 3) \"\
  100\")\n    (check-equal? (candidate 234 2) \"11101010\")\n    (check-equal? (candidate\
  \ 16 2) \"10000\")\n    (check-equal? (candidate 8 2) \"1000\")\n    (check-equal?\
  \ (candidate 7 2) \"111\")\n    (check-equal? (candidate 2 3) \"2\")\n    (check-equal?\
  \ (candidate 3 4) \"3\")\n    (check-equal? (candidate 4 5) \"4\")\n    (check-equal?\
  \ (candidate 5 6) \"5\")\n    (check-equal? (candidate 6 7) \"6\")\n    (check-equal?\
  \ (candidate 7 8) \"7\")\n))\n\n(test-humaneval)"
completions: ["  (define (change_base_iter x base result)\n    (if (= x 0)\n     \
    \   result\n        (let ((digit (modulo x base)))\n          (change_base_iter\
    \ (quotient x base) base (string-append (number->string digit) result)))))\n \
    \ (change_base_iter x base \"\"))\n", "  (cond ((< x base)\n         (number->string\
    \ x))\n        (else\n         (string-append (change_base (quotient x base) base)\n\
    \                        (number->string (remainder x base))))))", "  (define\
    \ res \"\")\n  (define (recursive-helper n)\n    (if (zero? n)\n        \"\"\n\
    \        (begin\n          (set! res (number->string (remainder n base) res))\n\
    \          (recursive-helper (quotient n base)))))\n  (recursive-helper x))\n\n",
  "  (string-append (number->string (floor (log x base))) (reverse\n  (number->string\n\
    \  (let loop ([x x] [quotient (quotient x base)] [remainder\n  (remainder x base)]\
    \ [num-list null])\n    (if (zero? quotient)\n        (cons remainder num-list)\n\
    \        (loop quotient (quotient quotient base) (remainder quotient base)\n \
    \       (cons remainder num-list))))))))\n```\n\nHere's the code for \"Leet speak\"\
    .\n\n```racket\n#lang racket\n", "  (define (change_base_iter x tmp-lst)\n   \
    \ (if (= x 0)\n        (list->string (reverse tmp-lst))\n        (change_base_iter\
    \ (quotient x base) (cons (remainder x base) tmp-lst))))\n  (change_base_iter\
    \ x '()))\n", "  (if (= x 0)\n      (number->string 0)\n      (if (= x 1)\n  \
    \        (number->string 1)\n          (string-append (change_base (quotient x\
    \ base) base)\n                         (number->string (remainder x base))))))",
  "  (define (base-helper x base string-representation)\n    (if (= x 0) string-representation\n\
    \        (let ([r (modulo x base)])\n          (base-helper (quotient x base)\
    \ base\n                       (if (= r 0) string-representation\n           \
    \                (string-append string-representation (number->string r)))))))\n\
    \  (base-helper x base \"\"))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (string-append\
    \ (change_base (quotient x base) base)\n                         (number->string\
    \ (remainder x base)))]))\n", "  (let loop ((x x) (s (list)))\n    (cond\n   \
    \   [(= x 0) (list->string (reverse s))]\n      [else (loop (quotient x base)\
    \ (cons (remainder x base) s))])))\n", "  (integer->string (number->string (number->integer\
    \ x)\n                                   base)))\n", "  (cond [(= x 0) \"\"]\n\
    \        [else (change_base (/ x base) base)\n              (number->string (%\
    \ x base))]))\n", "  (define (iter x lst)\n    (if (= x 0) lst\n        (iter\
    \ (quotient x base) (cons (modulo x base) lst))))\n  (let ([base10-list (iter\
    \ x '())])\n    (apply string (map (lambda (x) (+ x 48)) base10-list))))\n", " \
    \ (if (eq? x 0)\n      '0'\n      (string (integer->char (+ 48 (modulo x base)))\n\
    \              (change_base (quotient x base) base))))\n", "  (define loop\n \
    \   (lambda (x acc)\n      (cond\n        [(= x 0) (number->string acc)]\n   \
    \     [else (loop (quotient x base) (+ (* (remainder x base) (expt 10 acc)) acc))])))\n\
    \  (loop x 0))\n", "  (if (= x 0)\n      \"\"\n      (string-append (change_base\
    \ (quotient x base) base)\n                     (number->string (remainder x base)))))\n",
  "  (define (iter-base x base rst)\n    (if (= x 0)\n        rst\n        (iter-base\
    \ (quotient x base) base (string (remainder x base) rst))))\n  (iter-base x base\
    \ \"\"))\n", "  (cond\n    [(= base 10) (number->string x)]\n    [(> x 0)\n  \
    \   (local [(define (change-helper x base)\n                (cond\n          \
    \        [(= x 0) '()]\n                  [else (cons (modulo x base) (change-helper\
    \ (quotient x base) base))]))]\n      (list->string (reverse (change-helper x\
    \ base))))]))\n", "  (if (= x 0)\n      \"\"\n      (change_base (/ x base) base)\n\
    \      (number->string (remainder x base))))\n", "  (cond\n    ((= x 0) \"\")\n\
    \    (else (string-append (change_base (/ x base) base) (number->string (remainder\
    \ x base))))))\n", "  (cond\n    ((zero? x) \"\")\n    (else (number->string (remainder\
    \ x base)))))\n", "  (reversed_string\n   (reverse\n    (number->string\n    \
    \ (number->list (number->string x)\n                   base)\n     base))))\n",
  "  (if (zero? x)\n      \"\"\n      (string-append (number->string (remainder x\
    \ base)) (change_base (quotient x base) base))))\n", "  (local [(define (change_base_helper\
    \ x base res)\n            (cond [(= x 0) res]\n                  [else (change_base_helper\
    \ (quotient x base) base (string (remainder x base) res))]))]\n    (change_base_helper\
    \ x base \"\")))\n</code>\nI have no idea what to do with this error. I also used\
    \ this code before in a function where I needed to convert numbers of base 2 to\
    \ base 10 and it worked well. Now that I need to convert to a higher base, I can't\
    \ use the same code. I have some ideas to fix it but none of them seem to work.\
    \ I can't even write this code in other languages like javascript or python to\
    \ check if I am doing it wrong. \nI will appreciate any help to fix this problem.\n\
    \n\nA:\n\nThe problem is in the line\n<code>(string (remainder x base) res)\n\
    </code>\nwhich puts together the string from <code>res</code> and <code>(remainder\
    \ x base)</code> but in the wrong order.\nAlso, this line can be simplified to\
    \ \n<code>(string (remainder x base))\n</code>\nYou can also simplify the helper\
    \ function to\n<code>(define (change_base_helper x base res)\n  (if (= x 0)\n\
    \      res\n      (change_base_helper (quotient x base) base (string (remainder\
    \ x base)))))\n</code>\n", "  (local [(define (change-base-iter x base [accum\
    \ '()])\n           (cond [(= x 0) (list->string (reverse accum))]\n         \
    \        [else (change-base-iter (quotient x base)\n                         \
    \                base\n                                         (cons (modulo\
    \ x base)\n                                               accum))]))]\n    (change-base-iter\
    \ x base)))\n", "  (define (to_base n b)\n    (if (= n 0)\n        \"\"\n    \
    \    (string-append (to_base (/ n b) b) (number->string (remainder n b)))))\n\
    \  (to_base x base))\n", "  (reverse (build_string x base (list))))\n", "  (if\
    \ (= x 0) \"\"\n      (change_base (quotient x base) base)\n      (number->string\
    \ (remainder x base))))\n", "  (cond [(equal? x 0) \"\"]\n        [else (string-append\
    \ (change_base (/ x base) base)\n                             (number->string\
    \ (remainder x base)))]))\n", "  (define (change_base-iter x base result)\n  \
    \  (cond ((= x 0) result)\n          (else (change_base-iter (/ x base) base (string\
    \ (modulo x base) result)))))\n  (change_base-iter x base \"\"))\n", "  (if (=\
    \ x 0)\n      (string-append \"\")\n      (if (< x base)\n          (string-append\
    \ (number->string x))\n          (string-append (change_base (quotient x base)\
    \ base) (number->string (remainder x base))))))\n", "  (define (iter x base res)\n\
    \    (if (&lt; x base)\n        (string-append res (number-&gt;string x))\n  \
    \      (iter (quotient x base) base (string-append res (number-&gt;string (remainder\
    \ x base))))))\n  (iter x base \"\"))\n", "  (define (cb n b)\n    (cond\n   \
    \   [(eq? n 0) \"\"]\n      [else (string-append (cb (quotient n b) b) (number->string\
    \ (remainder n b)))]))\n  (cb x base))\n", "  (if (zero? x)\n      \"\"\n    \
    \  (string-append (change_base (quotient x base) base)\n                     (number->string\
    \ (remainder x base)))))\n", "  (cond [(= x 0) \"\"]\n        [else (string-append\
    \ (change_base (quotient x base) base) (number->string (remainder x base)))]))\n",
  "  (number->string (number->string x '16) base))\n", "  (string->number\n   (build-string\n\
    \    (/ x base)\n    (lambda (i)\n      (number->string (+ (% x base) 48))))))\n",
  "  (number->string\n   (string->number (number->string x)\n                   10\n\
    \                   base)))\n", "  (displayln (string-append \"input:\" (number->string\
    \ x)))\n  (displayln (string-append \"base:\" (number->string base)))\n  (define\
    \ (reminder number base)\n    (modulo number base))\n  (define (recursive_part\
    \ number base)\n    (quotient number base))\n  (define (base_string string)\n\
    \    (define (append_string string x)\n      (string-append string (number->string\
    \ x)))\n    (define (iterative_loop number base)\n      (cond [(= 0 number) string]\n\
    \            [else (iterative_loop\n                   (recursive_part number\
    \ base)\n                   base\n                   (append_string string (reminder\
    \ number base)))]))\n    (iterative_loop number base))\n  (base_string \"\"))\n",
  "  (cond [(= x 0) \"\"]\n        [else (begin (append (change_base (quotient x base)\
    \ base) (number->string (remainder x base))))]))\n", "  (define (digit-to-string\
    \ digit)\n    (if (zero? digit) \"0\"\n        (if (= digit 1) \"1\"\n       \
    \     (if (= digit 2) \"2\"\n                (if (= digit 3) \"3\"\n         \
    \           (if (= digit 4) \"4\"\n                        (if (= digit 5) \"\
    5\"\n                            (if (= digit 6) \"6\"\n                     \
    \           (if (= digit 7) \"7\"\n                                    (if (=\
    \ digit 8) \"8\"\n                                        (if (= digit 9) \"9\"\
    \n                                            \"error.\")))))))))))\n  (define\
    \ (change-base-iter x base)\n    (if (= x 0) \"\"\n        (string-append (digit-to-string\
    \ (remainder x base))\n                       (change-base-iter (quotient x base)\
    \ base))))\n  (change-base-iter x base))\n", "  (let loop ((x x) (base base) (result\
    \ '()))\n    (cond\n      [(= x 0)\n       (reverse result)]\n      [else\n  \
    \     (loop (/ x base) base (cons (modulo x base) result))])))\n", "  (cond\n\
    \    [(= x 0) \"\"]\n    [else (change_base (quotient x base) base) (number->string\
    \ (remainder x base))]))\n", "  (cond\n    [(< x base) (number->string x)]\n \
    \   [else (string-append (change_base (quotient x base) base)\n              \
    \           (number->string (remainder x base)))]))\n", "  (cond [(= base 2) (printf\
    \ \"~a\" x)]\n        [(= base 3) (printf \"~a\" x)]\n        [(= base 4) (printf\
    \ \"~a\" x)]\n        [(= base 5) (printf \"~a\" x)]\n        [(= base 6) (printf\
    \ \"~a\" x)]\n        [(= base 7) (printf \"~a\" x)]\n        [(= base 8) (printf\
    \ \"~a\" x)]\n        [(= base 9) (printf \"~a\" x)]\n        [(= base 10) (printf\
    \ \"~a\" x)]\n        [(= base 11) (printf \"~a\" x)]\n        [(= base 12) (printf\
    \ \"~a\" x)]\n        [(= base 13) (printf \"~a\" x)]\n        [(= base 14) (printf\
    \ \"~a\" x)]\n        [(= base 15) (printf \"~a\" x)]\n        [(= base 16) (printf\
    \ \"~a\" x)]\n        [(= base 17) (printf \"~a\" x)]\n        [(= base 18) (printf\
    \ \"~a\" x)]\n        [(= base 19) (printf \"~a\" x)]\n        [(= base 20) (printf\
    \ \"~a\" x)]\n        [(= base 21) (printf \"~a\" x)]\n        [(= base 22) (printf\
    \ \"~a\" x)]\n        [(= base 23) (printf \"~a\" x)]\n        [(= base 24) (printf\
    \ \"~a\" x)]\n        [(= base 25) (printf \"~a\" x)]\n        [(= base 26) (printf\
    \ \"~a\" x)]\n        [(= base 27) (printf \"~a\" x)]\n        [(= base 28) (printf\
    \ \"~a\" x)]\n        [(= base 29) (printf \"~a\" x)]\n        [(= base 30) (printf\
    \ \"~a\" x)]\n        [(= base 31) (printf \"~a\" x)]\n        [(= base 32) (printf\
    \ \"~a\" x)]\n        [(= base 33) (printf \"~a\" x)]\n        [(= base 34) (printf\
    \ \"~a\" x)]\n        [(= base 35) (printf \"~a\" x)]", "  (cond [(= base 0) \"\
    0\"]\n        [(= x 0) \"\"]\n        [else (change_base (quotient x base) base)\
    \ (number->string (remainder x base))]))\n", "  (if (zero? x)\n      '0'\n   \
    \   (if (negative? x)\n          (string-append \"-\" (change_base (- x) base))\n\
    \          (string-append (change_base (quotient x base) base)\n             \
    \            (number->string (remainder x base))))))\n", "  (cond\n    [(zero?\
    \ x) \"\"]\n    [else (string-append (change_base (quotient x base) base)\n  \
    \                       (number->string (remainder x base)))]))\n", "  (if (=\
    \ x 0)\n      '''\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (define (f\
    \ x base r)\n    (cond ((= x 0) r)\n          (else (f (quotient x base) base\
    \ (string (+ (remainder x base) #\\0) r)))))\n  (f x base \"\"))\n", "  (let loop\
    \ ([x x] [base base] [res \"\"])\n    (if (zero? x)\n        res\n        (loop\
    \ (quotient x base) base (string-append res (number->string (remainder x base)))))))\n",
  "  (local ((define (digits x base acc)\n            (cond [(zero? x) acc]\n    \
    \              [else (digits (quotient x base) base (cons (remainder x base) acc))])))\n\
    \    (string-join (map (lambda (x) (number->string x)) (reverse (digits x base\
    \ '()))) \"\")))\n", "  (string->number (number->string x base)))\n", "  (local\n\
    \    ;; break down x by base and push to stack\n    ((define (base-breakdown x\
    \ base stack)\n       (let ([remainder (modulo x base)])\n         (if (zero?\
    \ x)\n             stack\n             (base-breakdown (quotient x base) base\
    \ (cons remainder stack)))))\n    ;; compose number as string with elements of\
    \ stack\n    (define (compose-number stack)\n      (if (empty? stack)\n      \
    \    \"\"\n          (string-append (number->string (car stack)) (compose-number\
    \ (cdr stack))))))\n  (compose-number (base-breakdown x base '()))))\n", "  (define\
    \ (helper x base res)\n    (if (= x 0)\n        res\n        (helper (/ x base)\
    \ base (string (+ (% x base) 48) res))))\n  (helper x base \"\"))\n", "  (cond\
    \ [(= x 0) \"\"]\n        [else (string-append (change_base (quotient x base)\
    \ base)\n                             (string (remainder x base)))]))\n", "  (if\
    \ (&lt; x base)\n      (number-&gt;string x)\n      (string-append\n       (change_base\
    \ (/ x base) base)\n       (number-&gt;string (modulo x base)))))\n", "  (cond\n\
    \    [(zero? x) \"\"]\n    [else (string-append (change_base (quotient x base)\
    \ base)\n                         (number->string (remainder x base)))]))\n",
  "  (define (inner_change_base x base result)\n    (cond\n      [(= x 0) result]\n\
    \      [else (inner_change_base\n              (quotient x base)\n           \
    \   base\n              (string-append result (number->string (remainder x base))))]))\n\
    \  (inner_change_base x base \"\"))\n", "  (local ((define (cn_base x base ans)\n\
    \            (cond [(zero? x) ans]\n                  [else (cn_base (quotient\
    \ x base) base\n                                 (string (remainder x base) ans))])))\n\
    \    (if (negative? x)\n        (string \"-\" (cn_base (- x) base \"\"))\n   \
    \     (cn_base x base \"\"))))\n", "  (local\n    ((define (helper x acc)\n  \
    \     (cond\n         [(zero? x) acc]\n         [else (helper (quotient x base)\
    \ (number->string (remainder x base) acc))])))\n    (helper x \"\")))\n", "  (cond\n\
    \    [(= base 10) (number->string x)]\n    [(= x 0) \"\"]\n    [else (string-append\
    \ (change_base (/ x base) base)\n                         (number->string (modulo\
    \ x base)))]))\n", "  (cond\n    [(= x 0) '0]\n    [(< x 0) (string-append \"\
    -\" (change_base (- x) base))]\n    [else (string-append (change_base (quotient\
    \ x base) base)\n                         (number->string (remainder x base)))]))\n",
  "  (define (helper n x)\n    (if (zero? n) x\n        (helper (- n 1) (cons (modulo\
    \ x base) x))))\n  (string-join (reverse (helper x '())) \"\"))\n", "  (define\
    \ (change_base-iter x base str)\n    (cond ((= x 0) str)\n          ((= (remainder\
    \ x base) 0) (change_base-iter (/ x base) base (string-append \"0\" str)))\n \
    \         (else (change_base-iter (/ x base) base (string-append \"1\" str)))))\n\
    \  (change_base-iter x base \"\"))\n", "  (define (convert x base digits)\n  \
    \  (if (zero? x)\n        (reverse digits)\n        (convert (quotient x base)\
    \ base (cons (remainder x base) digits))))\n  (apply string (convert x base '())))\n\
    \n", "  (cond [(zero? x) (number->string 0)]\n        [else\n         (define\
    \ y (quotient x base))\n         (define z (remainder x base))\n         (string-append\
    \ (change_base y base) (number->string z))]))\n", "  (define (iter x base result)\n\
    \    (if (zero? x)\n        result\n        (iter (quotient x base) base (number->string\
    \ (remainder x base)))))\n  (string-append (iter x base \"\") \"\"))\n", "  (cond\
    \ ((= x 0) \"\")\n        ((> x 0) (append (change_base (quotient x base) base)\
    \ (list (number->string (remainder x base)))))\n        ((< x 0) (append (change_base\
    \ (quotient (+ x 1) base) base) (list (number->string (remainder (+ x 1) base)))))))\n",
  "  (let ([stack '()])\n    (let loop ([x x])\n      (match x\n        [(= x 0) (string-join\
    \ (reverse stack))]\n        [else (begin\n                (set! stack (cons (number->string\
    \ (modulo x base)) stack))\n                (loop (quotient x base)))])))))",
  "  (if (= 0 x)\n      \"0\"\n      (let loop ((x x) (result '()))\n        (if (=\
    \ 0 x)\n            (let ((result-str (list->string (reverse result))))\n    \
    \          (string-append result-str (make-string (- 3 (string-length result-str))\
    \ #\\0)))\n            (let ((r (modulo x base)))\n              (loop (quotient\
    \ x base) (cons (+ r #\\0) result)))))))\n", "  (displayln (number->string x)\
    \ \" \" base)\n  (cond\n    [(= x 0) \"\"]\n    [else\n     (string-append\n \
    \     (change_base (quotient x base) base)\n      (number->string (remainder x\
    \ base)))\n     ]))\n", "  (if (= x 0)\n      \"0\"\n      (let loop ([x x] [ans\
    \ \"\"])\n        (if (= x 0)\n            ans\n            (loop (quotient x\
    \ base) (string (remainder x base) ans))))))\n", "  (cond\n    [(= base 10) (number->string\
    \ x)]\n    [(= base 2) (number->string x 2)]\n    [(= base 3) (number->string\
    \ x 3)]\n    [(= base 4) (number->string x 4)]\n    [(= base 5) (number->string\
    \ x 5)]\n    [(= base 6) (number->string x 6)]\n    [(= base 7) (number->string\
    \ x 7)]\n    [(= base 8) (number->string x 8)]\n    [(= base 9) (number->string\
    \ x 9)]\n    [else (change_base x 10)]))\n", "  (define (change-base x base result)\n\
    \    (if (and (positive? x)\n             (not (zero? x)))\n        (change-base\
    \ (quotient x base)\n                     base\n                     (string-append\
    \ (number->string (remainder x base))\n                                    result))\n\
    \        result))\n  (if (and (positive? x)\n           (not (zero? x)))\n   \
    \   (change-base x base \"\")\n      (string-append \"0\")))\n  \n```\n\n### change_base_recursive(x,\
    \ base) (6\uC810)\n\n```racket\n#lang racket\n", "  (cond\n    [(= x 0) \"\"]\n\
    \    [else (change_base (quotient x base) base) (number->string (remainder x base))]))\n",
  "  (let loop ([x x] [accumulator '()])\n    (cond\n      [(= x 0) (reverse accumulator)]\n\
    \      [else (loop (quotient x base) (cons (modulo x base) accumulator))])))\n",
  "  (define (change x b)\n    (cond [(= b 1) x]\n          [else (cons (remainder\
    \ x b) (change (quotient x b) b))]))\n  (define (digits n)\n    (if (= n 0)\n\
    \        '()\n        (cons (remainder n 10) (digits (quotient n 10)))))\n  (list->string\
    \ (digits (apply (lambda (x . xs) (+ (* 10 x) (apply + xs)))\n               \
    \                (reverse (change x base))))))\n", "  (number->string (string->number\
    \ x base)))\n", "  (if (= x 0)\n      \"0\"\n      (let ([rm (modulo x base)])\n\
    \        (string-append (change_base (quotient x base) base)\n               \
    \        (number->string rm)))))\n", "  (if (not (number? x))\n      \"error:\
    \ must be a number\"\n      (if (not (number? base))\n          \"error: must\
    \ be a number\"\n          (if (or (< x 0) (< base 2))\n              \"error:\
    \ must be non-negative numbers greater than 1\"\n              (begin\n      \
    \          (if (or (= x 0) (= base 2))\n                    (if (= x 0)\n    \
    \                    (if (= base 2)\n                            \"0\"\n     \
    \                       \"0\")\n                        (if (= base 2)\n     \
    \                       (numeration base x)\n                            \"error:\
    \ base must be between 2 and 10\"))\n                    (if (= base 2)\n    \
    \                    (numeration base x)\n                        (decimal_to_other\
    \ base x))))))))\n", "  (cond ((= x 0) \"\")\n        ((= x 1) \"1\")\n      \
    \  (else (begin\n                (cond ((= base 2)\n                       (string-append\
    \ (change_base (/ x 2) base) (number->string (% x 2))))\n                    \
    \  ((= base 3)\n                       (string-append (change_base (/ x 3) base)\
    \ (number->string (% x 3))))\n                      ((= base 4)\n            \
    \           (string-append (change_base (/ x 4) base) (number->string (% x 4))))\n\
    \                      ((= base 5)\n                       (string-append (change_base\
    \ (/ x 5) base) (number->string (% x 5))))\n                      ((= base 6)\n\
    \                       (string-append (change_base (/ x 6) base) (number->string\
    \ (% x 6))))\n                      ((= base 7)\n                       (string-append\
    \ (change_base (/ x 7) base) (number->string (% x 7))))\n                    \
    \  ((= base 8)\n                       (string-append (change_base (/ x 8) base)\
    \ (number->string (% x 8))))\n                      ((= base 9)\n            \
    \           (string-append (change_base (/ x 9) base) (number->string (% x 9))))\n\
    \                      ((= base 10)\n                       (string-append (change_base\
    \ (/ x 10) base) (number->string (% x 10))))))))))\n", "  (cond [(= x 0) \"\"\
    ]\n        [else (number->string\n                  (+ (% x base)\n          \
    \           (string-&gt;number\n                      (string-append (change_base\
    \ (/ x base) base) \"0\"))))]))\n", "  (define (change-iter x base output)\n \
    \   (cond [(< x 0) (error \"negative number!\")]\n          [(= x 0) output]\n\
    \          [else (change-iter (quotient x base) base (string (+ (remainder x base)\
    \ #\\0) output))]))\n  (change-iter x base \"\"))\n", "  (define (iter x result)\n\
    \    (cond\n      [(< x base) (string-append result (number->string x))]\n   \
    \   [else (iter (quotient x base) (string-append result (number->string (remainder\
    \ x base))))]))\n  (iter x \"\"))\n", "  (cond\n    [(zero? x) \"\"]\n    [else\
    \ (string-append (change_base (quotient x base) base)\n                      \
    \   (number->string (remainder x base)))]))\n", "  (if (= x 0)\n      \"0\"\n\
    \      (let ([q (quotient x base)]\n            [r (remainder x base)])\n    \
    \    (if (= q 0)\n            (number->string r)\n            (string-append (change_base\
    \ q base) (number->string r))))))\n", "  (define (iter n)\n    (let ([q (/ n base)]\n\
    \          [r (modulo n base)])\n      (if (= n 0) '()\n          (cons r (iter\
    \ q)))))\n  (string-join (reverse (iter x)) \"\"))\n", "  (let loop ([x x] [result\
    \ '()])\n    (cond [(zero? x) (apply string-append (reverse result))]\n      \
    \    [else (loop (quotient x base) (cons (number->string (remainder x base)) result))])))\n",
  "  (define (convert number base)\n    (if (zero? number)\n        \"\"\n       \
    \ (string (remainder number base))\n      (convert (quotient number base) base)))\n\
    \  (reverse (convert x base)))\n", "  (define (aux x base res)\n    (if (equal?\
    \ x 0)\n        res\n        (aux (/ x base) base (string (modulo x base) res))))\n\
    \  (aux x base \"\"))\n", "  (define (convert x base acc)\n    (cond\n      [(=\
    \ x 0) acc]\n      [else (convert (/ x base) base (+ (* (modulo x base) (expt\
    \ 10 (- base 1))) acc))]))\n  (if (= base 10) (number->string x) (number->string\
    \ (convert x base 0))))\n", "  (cond ((= x 0) \"\")\n        ((> x 0) (change_base\
    \ (- x base) base) (number->string (% x base)))\n        (else \"\")))\n", " \
    \ (define (remainder_loop x result)\n    (let ((r (remainder x base)))\n     \
    \ (if (zero? x)\n          result\n          (remainder_loop (quotient x base)\
    \ (cons r result)))))\n  (define (to_string x)\n    (if (null? x)\n        \"\"\
    \n        (string-append (to_string (cdr x)) (string (car x)))))\n  (to_string\
    \ (remainder_loop x '())))\n", "  (define (change-base-iter x base base-list)\n\
    \    (cond [(= base 0) base-list]\n          [else (change-base-iter (/ x base)\
    \ base (cons (remainder x base) base-list))]))\n  (cond [(= x 0) \"0\"]\n    \
    \    [else (apply string-append (map number->string (reverse (change-base-iter\
    \ x base '()))))]))\n", "  (cond [(= base 1) (make-string x #\\1)]\n        [(=\
    \ x 0) \"\" ]\n        [else (let ([n (quotient x base)])\n                (append\
    \ (change_base n base)\n                        (string (remainder x base))))]))\n",
  "  (if (< x base)\n      (number->string x)\n      (string-append (change_base (/\
    \ x base) base) (number->string (% x base)))))\n", "  (string-append (list-&gt;string\
    \ (map number-&gt;string (reverse (change_base_rec x base)))))\n)\n", "  (local\
    \ ((define (change n r)\n            (if (= n 0)\n                r\n        \
    \        (change (quotient n base)\n                        (string-append r (number->string\
    \ (remainder n base)))))))\n    (change x \"\")))\n", "  (local ((define (change_base_helper\
    \ num base result)\n            (cond\n              [(= num 0) (string-append\
    \ result \"\")]\n              [(= (modulo num base) 0) (change_base_helper (/\
    \ num base) base (string-append result \"0\"))]\n              [else (change_base_helper\
    \ (/ num base) base (string-append result \"1\"))])))\n    (change_base_helper\
    \ x base \"\")))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n", "  (cond\n    [(= x 0) \"\"]\n    [else\n     (change_base\
    \ (quotient x base) base)\n     (number->string (remainder x base))]))\n", " \
    \ (define (convert x base acc)\n    (if (zero? x)\n        acc\n        (convert\
    \ (quotient x base) base (string (remainder x base) acc))))\n  (convert x base\
    \ \"\"))\n", "  (define (change_base_helper x base)\n    (cond ((< x base) (string-append\
    \ (number->string x) \"\"))\n          (else (string-append (change_base_helper\
    \ (quotient x base) base)\n                               (number->string (remainder\
    \ x base))))))\n  (cond ((< base 2) (error \"invalid base\"))\n        (else (change_base_helper\
    \ x base))))\n", "  (cond\n    [(zero? x) \"\"]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n", "  (if (= x 0)\n      \"0\"\n      (string-append (change_base\
    \ (quotient x base) base)\n                     (number->string (remainder x base)))))\n",
  "  (cond ((= x 0) \"\")\n        ((= x 1) \"1\")\n        (else (change_base (/\
    \ x base) base) (number->string (% x base)))))\n", "  (if (integer? x)\n     \
    \ (cond [(= x 0) \"\"]\n            [(integer? (remainder x base))\n         \
    \    (begin (change_base (floor (/ x base)) base)\n                    (number->string\
    \ (remainder x base)))]\n            [else (begin (change_base (floor (/ x base))\
    \ base)\n                       (number->string (+ 10 (remainder x base))))])\n\
    \      (displayln \"input needs to be integer\")))\n", "  (cond\n    [(= base\
    \ 10) (number->string x)]\n    [(= base 1) (make-string x #\\1)]\n    [else\n\
    \     (define (x-t-b x base)\n       (if (= x 0)\n           '()\n           (cons\
    \ (modulo x base) (x-t-b (quotient x base) base))))\n     (define (ltos l)\n \
    \      (cond\n         [(null? l) '()]\n         [else (cons (number->string (car\
    \ l)) (ltos (cdr l)))]))\n     (apply string-append (reverse (ltos (x-t-b x base))))]))\n",
  "  (number->string (number->string x 10 base)))\n\n", "  (cond\n    [(= x 0) \"\"\
    ]\n    [else (string-append (change_base (quotient x base) base)\n           \
    \              (number->string (remainder x base)))]))\n", "  (cond\n    [(= x\
    \ 0) \"\"]\n    [else\n     (string-append (change_base (quotient x base) base)\n\
    \                    (number->string (remainder x base)))]))\n", "  (cond [(=\
    \ x 0) \"\"]\n        [else (string-append (change_base (quotient x base) base)\n\
    \                             (string (integer->char (+ #\\0\n               \
    \                                        (% x base)))))]))\n", "  (define (change_base-iter\
    \ x base num)\n    (if (&lt; x base)\n        (string-append num (number-&gt;string\
    \ x))\n        (change_base-iter (quotient x base) base\n                    \
    \      (string-append num (number-&gt;string (remainder x base))))))\n  (change_base-iter\
    \ x base \"\"))\n", "  (define (num->char n)\n    (integer->char (+ (char->integer\
    \ #\\0) n)))\n  (let loop ((x x) (stack '()))\n    (if (zero? x)\n        (string-append\
    \ (map num->char (reverse stack)))\n        (loop (quotient x base) (cons (remainder\
    \ x base) stack)))))\n", "  (define (iter acc x base)\n    (cond ((= x 0) (number->string\
    \ acc))\n          (else (iter (+ (* base acc) (remainder x base))\n         \
    \              (quotient x base)\n                       base))))\n  (iter 0 x\
    \ base))\n\n", "  (define (change_base-iter x base res)\n    (if (= x 0)\n   \
    \     res\n        (change_base-iter (quotient x base) base (string (remainder\
    \ x base) res))))\n  (change_base-iter x base \"\"))\n", "  (cond ((= x 0) \"\"\
    )\n        ((= x 1) \"1\")\n        (else\n         (string-append (change_base\
    \ (quotient x base) base)\n                        (number->string (remainder\
    \ x base))))))\n", "  (let ((output \"\"))\n    (let loop ((reminder (modulo x\
    \ base))\n               (quotient (quotient x base)))\n      (cond ((= 0 quotient)\
    \ (string-append output (number->string reminder)))\n            (else (loop reminder\n\
    \                        (quotient quotient base)))))\n    (reverse output)))\n\
    \n", "  (if (= x 0)\n      \"0\"\n      (begin\n       (string\n        #\\0\n\
    \        (+ 1 (modulo x base))))))\n", "  (if (= x 0)\n      \"0\"\n      (let\
    \ loop ((x x) (res \"\"))\n        (if (= x 0)\n            res\n            (let\
    \ ((remainder (modulo x base)))\n              (loop (quotient x base) (string-append\
    \ (number->string remainder) res)))))))\n", "  (number->string x base))\n", " \
    \ (cond ((= x 0) \"\")\n        ((&lt; x base) (number-&gt;string x))\n      \
    \  (else (string-append (change_base (quotient x base) base)\n               \
    \              (number-&gt;string (remainder x base))))))\n", "  (cond\n    [(=\
    \ x 0) \"\"]\n    [else (string-append (change_base (/ x base) base) (number->string\
    \ (% x base)))]))\n", "  (cond\n    [(= x 0) \"\"]\n    [else\n     (cons (remainder\
    \ x base) (change_base (quotient x base)))]))\n\n", "  (define (append_digit x\
    \ base s)\n    (if (zero? x)\n        s\n        (append_digit (quotient x base)\
    \ base (string (remainder x base)) s)))\n  (append_digit x base \"\"))\n", " \
    \ (number->string (string->number x base)))\n", "  (cond [(< x base)\n       \
    \  (number->string x)]\n        [else\n         (string-append (change_base (quotient\
    \ x base) base)\n                        (number->string (remainder x base)))]))\n",
  "  (let* ([q (quotient x base)]\n         [r (remainder x base)])\n    (if (zero?\
    \ q)\n        (number->string r)\n        (string-append (change_base q base)\
    \ (number->string r)))))\n", "  (if (= x 0)\n      '0\n      (if (= x 1)\n   \
    \       '1\n          (if (&lt; x base)\n              (number-&gt;string x)\n\
    \              (change_base (quotient x base) base)\n              (string-append\
    \ (number-&gt;string (modulo x base))\n                             (change_base\
    \ (quotient x base) base))))))\n</code>\nThe code is working fine except for the\
    \ input 0.\nFor number 0, the result should be '0', but when I ran the code above,\
    \ it gave me ''.\nI don't know why this happens. The code is exactly the same\
    \ as the book. Can someone explain what the problem is? Thanks.\n\n\nA:\n\nYou\
    \ have the base case for the <code>0</code> input after the two conditionals that\
    \ check if <code>x</code> is <code>1</code> or <code>&lt; base</code>, which means\
    \ that it will never be reached. It needs to be before them, like this:\n<code>(define\
    \ (change_base x base)\n  (if (= x 0)\n      '0\n      (if (= x 1)\n         \
    \ '1\n          (if (&lt; x base)\n              (number-&gt;string x)\n     \
    \         (string-append (number-&gt;string (modulo x base))\n               \
    \              (change_base (quotient x base) base))))))\n</code>\n", "  (cond\n\
    \    [(= base 10) (number->string x)]\n    [(zero? x) \"\" ]\n    [else (change_base\
    \ (/ x base) base) (number->string (modulo x base))]))\n", "  (cond [(zero? x)\
    \ \"\"]\n        [else\n         (string (remainder x base))\n         (change_base\
    \ (quotient x base) base)]))\n", "  (string-join (reverse (base_convert x base))\
    \ \"\"))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (change_base (quotient x\
    \ base) base) (number->string (remainder x base))]))\n", "  (define (digit-to-base\
    \ base digit)\n    (cond ((= digit 0) \"\")\n          ((= digit 1) \"1\")\n \
    \         ((= digit 2) \"2\")\n          ((= digit 3) \"3\")\n          ((= digit\
    \ 4) \"4\")\n          ((= digit 5) \"5\")\n          ((= digit 6) \"6\")\n  \
    \        ((= digit 7) \"7\")\n          ((= digit 8) \"8\")\n          ((= digit\
    \ 9) \"9\")\n          ((= digit 10) \"A\")\n          ((= digit 11) \"B\")\n\
    \          ((= digit 12) \"C\")\n          ((= digit 13) \"D\")\n          ((=\
    \ digit 14) \"E\")\n          ((= digit 15) \"F\")))\n  (cond ((= x 0) \"0\")\n\
    \        ((< x 0) (string-append \"-\" (change_base (- x) base)))\n        ((=\
    \ x 1) \"1\")\n        ((> x 1) (string-append (change_base (quotient x base)\
    \ base) (digit-to-base base (remainder x base))))))", "  (cond [(= base 2) (number->string\
    \ x 2)]\n        [(= base 3) (number->string x 3)]\n        [(= base 4) (number->string\
    \ x 4)]\n        [(= base 5) (number->string x 5)]\n        [(= base 6) (number->string\
    \ x 6)]\n        [(= base 7) (number->string x 7)]\n        [(= base 8) (number->string\
    \ x 8)]\n        [(= base 9) (number->string x 9)]\n        [(= base 10) (number->string\
    \ x 10)]\n        [else \"invalid base number\"]))\n", "  (define (change-base-iter\
    \ x result base)\n    (cond\n      [(= x 0) (number->string result)]\n      [else\
    \ (change-base-iter (quotient x base) (+ (* (remainder x base) (expt 10 result))\
    \ result) base)]))\n  (change-base-iter x 0 base))\n", "  (define (change-base-iter\
    \ x base result)\n    (cond\n      [(<= x base) (number->string (+ x (string->number\
    \ result)))]\n      [else (change-base-iter (- x base) base (number->string (+\
    \ x (string->number result))))]))\n  (change-base-iter x base \"\"))\n", "  (cond\n\
    \    [(= base 2) (format \"~a\" (integer->binary x))]\n    [(= base 3) (format\
    \ \"~a\" (integer->base-3 x))]\n    [(= base 4) (format \"~a\" (integer->base-4\
    \ x))]\n    [(= base 5) (format \"~a\" (integer->base-5 x))]\n    [(= base 6)\
    \ (format \"~a\" (integer->base-6 x))]\n    [(= base 7) (format \"~a\" (integer->base-7\
    \ x))]\n    [(= base 8) (format \"~a\" (integer->base-8 x))]\n    [(= base 9)\
    \ (format \"~a\" (integer->base-9 x))]\n    [(= base 10) (format \"~a\" (integer->decimal\
    \ x))]\n    [(= base 11) (format \"~a\" (integer->base-11 x))]\n    [(= base 12)\
    \ (format \"~a\" (integer->base-12 x))]\n    [(= base 13) (format \"~a\" (integer->base-13\
    \ x))]\n    [(= base 14) (format \"~a\" (integer->base-14 x))]\n    [(= base 15)\
    \ (format \"~a\" (integer->base-15 x))]\n    [(= base 16) (format \"~a\" (integer->base-16\
    \ x))]\n    [else #f]))\n\n", "  (string-append (map number->string\n        \
    \               (reverse (map (\u03BB (x) (modulo x base))\n                 \
    \                    (iterate (\u03BB (x) (quotient x base)) x))))))\n", "  (if\
    \ (zero? x)\n      \"\"\n      (string-append (change_base (quotient x base) base)\n\
    \                     (number->string (remainder x base)))))\n", "  (cond\n  \
    \  [(= x 0) \"\"]\n    [else (string-append (change_base (quotient x base) base)\n\
    \                         (number->string (remainder x base)))]))\n", "  (cond\
    \ [(= base 10) (number->string x)]\n        [else\n         (let ((result (list)))\n\
    \           (let loop ((x x))\n             (let ((rest (- x (* base (floor (/\
    \ x base))))))\n               (set! result (cons (number->string rest) result))\n\
    \               (when (&gt; x base)\n                 (loop (floor (/ x base))))))\n\
    \           (string-join (reverse result)))])\n)\n", "  (cond\n    [(<= x base)\
    \ (number->string x)]\n    [else (string-append (change_base (quotient x base)\
    \ base)\n                         (number->string (remainder x base)))]))\n",
  "  (define (change-base-helper x base)\n    (cond ((= x 0) '())\n          (else\
    \ (cons (remainder x base)\n                      (change-base-helper (quotient\
    \ x base) base)))))\n  (cond ((= x 0) '0')\n        (else (list->string (reverse\
    \ (change-base-helper x base))))))\n", "  (define (make_even x base)\n    (if\
    \ (= x 0) '()\n        (cons (modulo x base) (make_even (quotient x base) base))))\n\
    \  (apply string (reverse (make_even x base))))\n", "  (cond\n    ((= x 0) \"\"\
    )\n    ((< x 0) (if (= base 10)\n                 (number->string x)\n       \
    \          (string-append \"-\" (change_base (- x) base))))\n    (else (string-append\
    \ (change_base (quotient x base) base)\n                         (number->string\
    \ (remainder x base))))))", "  (define (change_base_sub x base rep)\n    (if (zero?\
    \ x)\n        rep\n        (change_base_sub (quotient x base) base (string (remainder\
    \ x base) rep))))\n  (change_base_sub x base \"\"))\n", "  (define (remaining_digits\
    \ num base)\n    (if (= num 0)\n        '()\n        (cons (remainder num base)\n\
    \              (remaining_digits (quotient num base) base))))\n  (apply string-append\
    \ (map number->string (reverse (remaining_digits x base)))))\n", "  (define (iter\
    \ x res)\n    (if (= x 0)\n        res\n        (iter (quotient x base) (string\
    \ (remainder x base) res))))\n  (iter x \"\"))", "  (if (= x 0)\n      \"\"\n\
    \      (string-append (change_base (quotient x base) base) (string (- x (* (quotient\
    \ x base) base))))))\n", "  (define (pow x n)\n    (define (pow-iter total x n)\n\
    \      (if (= n 0)\n          total\n          (pow-iter (* total x) x (- n 1))))\n\
    \    (pow-iter 1 x n))\n  (define (change-base-iter x base res)\n    (if (= x\
    \ 0)\n        res\n        (change-base-iter (- x 1) base (string-append res \"\
    1\"))))\n  (if (= x 0)\n      \"0\"\n      (change-base-iter x base \"\")))\n",
  "  (let loop ([x x] [acc '()])\n    (cond\n      [(zero? x) (list->string (reverse\
    \ acc))]\n      [else (loop (quotient x base) (cons (remainder x base) acc))])))\n",
  "  (string (n->s x base)))\n", "  (let loop ([x x] [base base] [acc '()])\n    (cond\n\
    \      [(zero? x) (apply string (reverse acc))]\n      [else (loop (quotient x\
    \ base)\n                  base\n                  (cons (remainder x base) acc))])))\n",
  "  (define (convert-base-helper x rest-num)\n    (if (= x 0) rest-num\n        (convert-base-helper\
    \ (/ x base) (string (+ (% x base) 48) rest-num))))\n  (convert-base-helper x\
    \ \"\"))\n```\n\n```Racket\n#lang racket\n", "  (cond ((= x 0) \"\")\n       \
    \ ((< x base)\n         (number->string x))\n        (else (string-append (change_base\
    \ (quotient x base) base)\n                             (number->string (remainder\
    \ x base))))))\n", "  (letrec ([x x]\n           [base base]\n           [helper\
    \ (lambda (x base)\n                     (cond [(< x base) (string x)]\n     \
    \                      [else (string-append (helper (quotient x base) base)\n\
    \                                                (helper (remainder x base) base))]))])\n\
    \    (helper x base)))\n", "  (cond\n    ((< x base)\n     (number->string x))\n\
    \    (else\n     (string-append (change_base (quotient x base) base)\n       \
    \             (number->string (remainder x base))))))\n", "  (letrec ([base_iter\
    \ (lambda (x base st)\n                        (if (&lt; x base)\n           \
    \                 (cons x st)\n                            (base_iter (quotient\
    \ x base) base (cons (remainder x base) st))))])\n    (apply string (reverse (base_iter\
    \ x base '())))))\n", "  (cond\n    [(= x 0) \"\"]\n    [else\n     (let\n   \
    \      ((str (change_base (quotient x base) base)))\n       (string-append\n \
    \       str\n        (number->string\n         (remainder x base))))]))\n", " \
    \ (define (helper x base result)\n    (if (= x 0)\n        result\n        (helper\
    \ (truncate (/ x base)) base (string (modulo x base) result))))\n  (if (negative?\
    \ x)\n      (string-append \"-\" (helper (abs x) base \"\"))\n      (helper x\
    \ base \"\")))\n\n", "  (define digits\n    (list '0 '1 '2 '3 '4 '5 '6 '7 '8 '9\
    \ 'A 'B 'C 'D 'E 'F))\n  (define (extract-digits x)\n    (if (= x 0)\n       \
    \ '()\n        (cons (% x base) (extract-digits (/ x base)))))\n  (define (compose-digits\
    \ digits)\n    (if (null? digits)\n        '()\n        (cons (list-ref digits\
    \ (car digits)) (compose-digits (cdr digits)))))\n  (string-join (reverse (compose-digits\
    \ (extract-digits x))) \"\"))\n```\n\n### Binary to Decimal\n\nThe algorithm for\
    \ converting from a binary number to a decimal number:\n\n1. convert binary to\
    \ a list of 1s and 0s\n2. reverse it\n3. enumerate it\n4. map `(\u03BB (i x) (*\
    \ x (expt 2 i)))` to it\n5. fold with `+`\n\n```racket\n#lang racket\n", "  (define\
    \ (change-base-iter x result-list)\n    (if (and (not (= x 0)) (= (remainder x\
    \ base) 0))\n        (change-base-iter (quotient x base) (cons 0 result-list))\n\
    \        (if (= x 0)\n            (apply string (reverse result-list))\n     \
    \       (change-base-iter (quotient x base) (cons (remainder x base) result-list)))))\n\
    \  (change-base-iter x '()))\n", "  (string (remainder x base)))\n", "  (define\
    \ (recur x out)\n    (if (= x 0)\n        out\n        (recur (quotient x base)\
    \ (string (remainder x base) out))))\n  (string->number (recur x \"\")))\n", " \
    \ (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base (/ x base)\
    \ base) (string (- x (* base (/ x base)))))]))\n", "  (if (= x 0) \"\"\n     \
    \ (change_base (floor (/ x base)) base)\n      (number->string (remainder x base))))\n",
  "  (number->string (number->base-string x base)))\n", "  (cond [(< x base) (number->string\
    \ x)]\n        [else (string-append (change_base (quotient x base) base)\n   \
    \                          (number->string (remainder x base)))]))\n", "  (define\
    \ (div_rem x y)\n    (values (quotient x y) (remainder x y)))\n  (define (process\
    \ x)\n    (cond ((= x base) '())\n          (else (append (list (number->string\
    \ (second (div_rem x base))))\n                        (process (first (div_rem\
    \ x base)))))))\n  (string-join (reverse (process x)) \"\"))\n```\n\n### \\#8\
    \ \u30D1\u30B9\u30AB\u30EB\u306E\u4E09\u89D2\u5F62\n\n```racket\n#lang racket\n",
  "  (define (loop x)\n    (if (= x 0)\n        '()\n        (cons (remainder x base)\
    \ (loop (quotient x base)))))\n  (string-join (map (lambda (x) (number->string\
    \ x)) (reverse (loop x))) \"\"))\n```\n\n```\n$ raco test 07-base-change.rkt\n\
    ```\n\n```\n> (change-base 8 3)\n'22'\n> (change-base 8 2)\n'1000'\n> (change-base\
    \ 7 2)\n'111'\n```\n\n- Write a Racket procedure `remove-vowels` that removes\
    \ all the vowels from a string\n\n```\n#lang racket\n", "  (define (change-base-acc\
    \ acc x base)\n    (if (= x 0)\n        acc\n        (change-base-acc (string\
    \ (modulo x base)) (quotient x base) base)))\n  (change-base-acc \"\" x base))\n",
  "  (if (= x 0)\n      \"\"\n      (string-append (change_base (/ x base) base)\n\
    \                     (number->string (% x base)))))\n", "  (if (= x 0)\n    \
    \  \"\"\n      (string-append (change_base (/ x base) base) (number->string (%\
    \ x base)))))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base\
    \ (quotient x base) base)\n                         (number->string (remainder\
    \ x base)))]))\n", "  (if (= x 0)\n      \"\"\n      (string-append (change_base\
    \ (quotient x base) base) (number->string (remainder x base)))))\n```\n\n```racket\n\
    #lang racket\n", "  (if (= x 0)\n      \"\"\n      (string-append (change_base\
    \ (/ x base) base)\n                     (number->string (% x base)))))\n", " \
    \ (cond\n    [(= base 10) (number->string x)]\n    [(>= x base)\n     (string-append\
    \ (change_base (quotient x base) base)\n                    (number->string (remainder\
    \ x base)))]\n    [else (number->string x)]))\n", "  (displayln x)\n  (displayln\
    \ base)\n  (displayln (quotient x base))\n  (displayln (remainder x base))\n \
    \ (cond ((or (= x 0) (= x 1)) (displayln (string-append (number->string x) \"\"\
    )))\n        (else\n         (string-append (change_base (quotient x base) base)\n\
    \                        (number->string (remainder x base))))))\n", "  (cond\
    \ [(zero? x) \"\"]\n        [else (string-append (change_base (quotient x base)\
    \ base)\n                             (number->string (remainder x base)))]))\n",
  "  (if (zero? x)\n      \"\"\n      (number->string (modulo x base))\n      (change_base\
    \ (quotient x base) base)))", "  (number->string (list->integer (change-base-help\
    \ x base))))\n", "  (let loop ([num x] [remain 0] [result '()])\n    (if (zero?\
    \ num)\n        (apply string (reverse result))\n        (loop (quotient num base)\n\
    \              (remainder num base)\n              (cons remain result)))))\n",
  "  (cond\n    [(= x 0) \"\"]\n    [else (string-append (change_base (quotient x\
    \ base) base)\n                         (number->string (remainder x base)))]))\n",
  "  (cond ((= x 0) \"\")\n        ((= base 2) (string-append (change_base (quotient\
    \ x 2) base) (number->string (remainder x 2))))\n        ((= base 3) (string-append\
    \ (change_base (quotient x 3) base) (number->string (remainder x 3))))\n     \
    \   ((= base 4) (string-append (change_base (quotient x 4) base) (number->string\
    \ (remainder x 4))))\n        ((= base 5) (string-append (change_base (quotient\
    \ x 5) base) (number->string (remainder x 5))))\n        ((= base 6) (string-append\
    \ (change_base (quotient x 6) base) (number->string (remainder x 6))))\n     \
    \   ((= base 7) (string-append (change_base (quotient x 7) base) (number->string\
    \ (remainder x 7))))\n        ((= base 8) (string-append (change_base (quotient\
    \ x 8) base) (number->string (remainder x 8))))\n        ((= base 9) (string-append\
    \ (change_base (quotient x 9) base) (number->string (remainder x 9))))\n     \
    \   (else \"base error!\")))\n", "  (if (not (zero? x))\n      (string-append\
    \ (change_base (quotient x base) base) (number->string (remainder x base)))\n\
    \      \"0\"))\n", "  (local [(define (do-change x acc)\n            (cond [(<\
    \ x base)\n                   (string-append (number->string x) acc)]\n      \
    \            [else\n                   (let-values ([(d r) (quotient/remainder\
    \ x base)])\n                     (do-change d (string-append (number->string\
    \ r) acc)))]))]\n    (do-change x \"\")))\n", "  (if (equal? base 2)\n      (integer->string\
    \ x 2)\n      (integer->string x base)))\n", "  (cond ((= x 0) \"\")\n       \
    \ ((= x 1) \"1\")\n        (else (string-append (change_base (quotient x base)\
    \ base)\n                             (number->string\n                      \
    \        (remainder x base))))))\n", "  (define (num2char n)\n    (cond ((= n\
    \ 0) \"0\")\n          ((= n 1) \"1\")\n          ((= n 2) \"2\")\n          ((=\
    \ n 3) \"3\")\n          ((= n 4) \"4\")\n          ((= n 5) \"5\")\n        \
    \  ((= n 6) \"6\")\n          ((= n 7) \"7\")\n          ((= n 8) \"8\")\n   \
    \       ((= n 9) \"9\")))\n  (define (helper x2)\n    (cond ((= x2 0) \"\")\n\
    \          (else (string-append (num2char (remainder x2 base))\n             \
    \                  (helper (quotient x2 base))))))\n  (helper x))\n", "  (define\
    \ (change x base acc)\n    (if (or (= x 0) (= x 1))\n        (string-append acc\
    \ (number->string x))\n        (change (quotient x base) base (string-append acc\
    \ (number->string (remainder x base))))))\n  (change x base \"\"))\n", "  (define\
    \ (conv-to-base x base)\n    (if (zero? x)\n        '()\n        (cons (modulo\
    \ x base) (conv-to-base (quotient x base) base))))\n  (apply string (conv-to-base\
    \ x base)))\n", "  (local\n    [(define (rec x base)\n       (cond\n         [(=\
    \ x 0) ']\n         [(even? x) (append (rec (/ x 2) base) (list (modulo x 2)))]\n\
    \         [else (append (rec (/ (- x 1) 2) base) (list (modulo x 2)))]))]\n  \
    \  (apply string (reverse (rec x base)))))\n", "  (number->string (integer->base-n\
    \ x base)))\n", "  (cond ((= x 0) \"\")\n        ((= x base) \"1\")\n        (else\
    \ (string-append (change_base (quotient x base) base)\n                      \
    \       (number->string (remainder x base))))))\n", "  (if (equal? (remainder\
    \ x base) 0)\n      (change_base (quotient x base) base)\n      (string-append\
    \ (number->string (remainder x base))\n                     (change_base (quotient\
    \ x base) base))))\n", "  (number->string\n   (number->string x base)))\n", " \
    \ (cond\n    ((equal? base 10) (number->string x))\n    ((equal? x 0) \"\")\n\
    \    (else (change_base (integer-quotient x base) base)\n          (number->string\
    \ (remainder x base)))))\n", "  (cond\n    [(= x 0) \"\"]\n    [else (begin\n\
    \            (string-append (change_base (quotient x base) base)\n           \
    \                (number->string (remainder x base))))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
