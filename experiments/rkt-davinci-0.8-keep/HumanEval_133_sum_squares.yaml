name: HumanEval_133_sum_squares
language: rkt
prompt: "#lang racket\n\n;; You are given a list of numbers.\n;; You need to return\
  \ the sum of squared numbers in the given list,\n;; round each element in the list\
  \ to the upper int(Ceiling) first.\n;; Examples:\n;; For lst = [1,2,3] the output\
  \ should be 14\n;; For lst = [1,4,9] the output should be 98\n;; For lst = [1,3,5,7]\
  \ the output should be 84\n;; For lst = [1.4,4.2,0] the output should be 29\n;;\
  \ For lst = [-2.4,1,1] the output should be 6\n(define (sum_squares lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_squares))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 3.0)) 14)\n    (check-equal? (candidate (list 1.0 3.0 5.0 7.0))\
  \ 84)\n    (check-equal? (candidate (list 1.4 4.2 0.0)) 29)\n    (check-equal? (candidate\
  \ (list -2.4 1.0 1.0)) 6)\n    (check-equal? (candidate (list 100.0 1.0 15.0 2.0))\
  \ 10230)\n    (check-equal? (candidate (list 10000.0 10000.0)) 200000000)\n    (check-equal?\
  \ (candidate (list -1.4 4.6 6.3)) 75)\n    (check-equal? (candidate (list -1.4 17.9\
  \ 18.9 19.9)) 1086)\n    (check-equal? (candidate (list 0.0)) 0)\n    (check-equal?\
  \ (candidate (list -1.0)) 1)\n    (check-equal? (candidate (list -1.0 1.0 0.0))\
  \ 2)\n))\n\n(test-humaneval)"
completions: ['  (apply + (map (lambda (x) (round x)) (map (lambda (x) (* x x)) lst))))',
  "  (apply + (map (lambda (x) (inexact->exact (ceiling (* x x)))) lst)))\n", "  (apply\
    \ + (map (lambda (x) (* x x)) (map ceiling lst))))\n</code>\nracket is a lisp\
    \ like language that is quite similar to scheme.\n", '  (apply + (map (lambda
    (x) (expt x 2)) (map (lambda (x) (ceiling x)) lst))))', '  (accumulate + 0 (map
    (lambda (x) (expt (ceiling x) 2)) lst)))', "  (apply + (map (lambda (x) (* x x))\
    \ (map (lambda (x) (ceiling x)) lst))))\n", "  (cond\n    [(empty? lst) 0]\n \
    \   [else (+ (ceiling (car lst)) (sum_squares (cdr lst)))]))\n", "  (apply + (map\
    \ (lambda (x) (* x x)) (map ceiling lst))))\n", '  (apply + (map (lambda (n) (*
    n n)) (map ceiling lst))))', "  (apply + (map (lambda (x) (expt (ceiling x) 2))\
    \ lst)))\n", "  (apply + (map (lambda (n) (ceiling (expt n 2))) lst)))\n", " \
    \ (accumulate + 0 (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (let ([f\
    \ (lambda (ls)\n             (if (null? ls)\n                 0\n            \
    \     (+ (ceiling (car ls))\n                    (f (cdr ls)))))]\n        [g\
    \ (lambda (ls)\n             (if (null? ls)\n                 0\n            \
    \     (+ (* (car ls) (car ls))\n                    (g (cdr ls))))])\n    (g (f\
    \ lst))))\n</code>\nBut I received the following error:\n<code>lambda: unbound\
    \ identifier in module in: f\n</code>\nThis is how I tested my program:\n<code>;;\
    \ [1,2,3] the output should be 14", "  (define (ceiling x)\n    (if (< x 0) (round\
    \ x)\n        (+ 1 (round x))))\n  (apply + (map (lambda (n) (expt (ceiling n)\
    \ 2)) lst)))\n```\n\n```racket\n#lang racket\n", "  (apply + (map (lambda (x)\
    \ (round (square x))) lst)))\n</code>\n", "  (apply + (map (lambda (x) (* x x))\
    \ (map ceiling lst))))\n</code>\n", "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n", "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n\
    </code>\nWorth noting that the higher order functions <code>map</code> and <code>apply</code>\
    \ are not native to Racket, but are part of the <code>srfi/1</code> library.\n",
  "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n</code>\nPython\n<code>#\
    \ You are given a list of numbers.\n# You need to return the sum of squared numbers\
    \ in the given list,\n# round each element in the list to the upper int(Ceiling)\
    \ first.\n# Examples:\n# For lst = [1,2,3] the output should be 14\n# For lst\
    \ = [1,4,9] the output should be 98\n# For lst = [1,3,5,7] the output should be\
    \ 84\n# For lst = [1.4,4.2,0] the output should be 29\n# For lst = [-2.4,1,1]\
    \ the output should be 6\ndef sum_squares(lst):\n    return sum([x * x for x in\
    \ map(lambda x: round(x) if x &gt; 0 else round(x-1), lst)])\n</code>\nOutputs\
    \ for the last two examples\n<code>&gt; (sum_squares '(1.4 4.2 0))\n29\n&gt; (sum_squares\
    \ '(-2.4 1 1))\n6\n</code>\n", "  (cond [(null? lst) 0]\n        [else (+ (ceiling\
    \ (car lst)) (sum_squares (cdr lst)))]))", '  (apply + (map (lambda (x) (expt
    (ceiling x) 2)) lst)))', "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n",
  '  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))', '  (apply + (map (lambda
    (x) (if (negative? x) (* x x) (* x x))) lst)))', "  (apply + (map (lambda (n)\
    \ (ceiling (expt n 2))) lst)))\n", '  (apply + (map (lambda (x) (expt x 2)) (map
    ceiling lst))))', "  (apply + (map sqr (map ceiling lst))))\n</code>\nThanks to\
    \ @Alyosha and @Ashwini I have a better solution that is faster and has less memory\
    \ usage\n<code>#lang racket\n", "  (apply + (map (lambda (x) (expt x 2)) lst)))\n",
  '  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))', "  (define (squares\
    \ lst)\n    (map (lambda (x) (expt x 2)) lst))\n  (apply + (squares lst)))\n",
  "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", '  (apply + (map
    (lambda (x) (round (square x))) lst)))', "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n", '  (apply + (map (lambda (x) (expt x 2)) (map ceiling lst))))',
  "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map\
    \ (lambda (x) (* x x)) (map ceiling lst))))\n```\n\n```racket\n#lang racket\n",
  "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map\
    \ (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (define (ceiling n)\n    (if\
    \ (or (zero? n) (zero? (remainder n 1)))\n        n\n        (+ 1 n)))\n  (define\
    \ (sum lst)\n    (if (null? lst)\n        0\n        (+ (car lst) (sum (cdr lst)))))\n\
    \  (define (sqr lst)\n    (map (lambda (x) (expt x 2)) lst))\n  (sum (sqr (map\
    \ ceiling lst))))", "  (apply + (map (lambda (x) (* x x))\n                (map\
    \ ceiling lst))))\n</code>\nWith <code>map</code> I am able to map all elements\
    \ in a list to a function, but with <code>map2</code> it behaves unexpectedly:\n\
    <code>#lang racket", "  (define (ceiling x)\n    (+ x (if (< x 0) -1 1)))\n  (define\
    \ (sq x)\n    (* x x))\n  (apply + (map sq (map ceiling lst))))", "  (apply +\
    \ (map (lambda (x) (let* ([x (round x)] [x (* x x)]) x)) lst)))\n", '  (apply
    + (map (lambda (x) (round (* x x))) lst)))', "  (apply + (map\n            (lambda\
    \ (x) (expt (ceiling x) 2))\n            lst)))\n</code>\n", '  (apply + (map
    (lambda (x) (expt (ceiling x) 2)) lst)))', "  (apply + (map (lambda (n) (* n n))\
    \ (map ceiling lst))))\n", '  (apply + (map (lambda (i) (expt i 2)) lst)))', " \
    \ (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map\
    \ (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\n", "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n</code>\nI have seen most of the solution\
    \ in python but what I want is to know how to solve this task in racket.\n\n\n\
    A:\n\nIn Racket, we start by creating a <code>main</code> function which we can\
    \ then call:\n<code>(define (main numbers)\n  ...\n)\n</code>\nWe see that we\
    \ are supposed to map a function over the list. In Racket this is done by calling\
    \ <code>map</code> on the list, and the function which we want to map. The type-signature\
    \ for <code>map</code> is <code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>. The first\
    \ argument is the function we want to map. The second argument is the list on\
    \ which we want to map the function.\nWe are given a function <code>f</code> which\
    \ we want to map over the list. The type-signature for <code>f</code> is <code>number\
    \ -&gt; number</code>. This maps nicely onto the type-signature for <code>map</code>,\
    \ because the first argument is the function which we want to map, and the second\
    \ argument is the list we want to map it over.\nBecause the type-signature for\
    \ <code>f</code> is <code>number -&gt; number</code>, we know that <code>f</code>\
    \ takes a number as an argument, and returns a number. Because we want to map\
    \ <code>f</code> over a list, and Racket uses <code>map</code> which takes the\
    \ function as the first argument, we need to create a function which takes a number\
    \ and returns <code>f</code>. This can be done using the identity function:\n\
    <code>(define (id x) x)\n</code>\nWe can now combine this with <code>map</code>\
    \ to give us:\n<code>(map (id f) list)\n</code>\nThe <code>id</code> function\
    \ returns the value it is given. Since <code>f</code> is a function which takes\
    \ a number, and returns a number, this is exactly what we want, and we", "  (if\
    \ (null? lst)\n      0\n      (+ (expt (ceiling (car lst)) 2)\n         (sum_squares\
    \ (cdr lst)))))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (* x x))\n                (map (lambda (x) (ceiling\
    \ x)) lst))))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (cond ((null? lst) 0)\n        (else (+ (ceiling (car lst)) (sum_squares (cdr\
    \ lst))))))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (round x) (round x)) lst)))\n", "  (if (null? lst)\n\
    \      0\n      (+ (* (round (car lst)) (round (car lst)))\n         (sum_squares\
    \ (cdr lst)))))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (* x x))\n                (map ceiling lst))))\n",
  '  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))', '  (apply + (map (lambda
    (e) (* e e)) (map ceiling lst))))', "  (apply + (map (lambda (x) (* x x)) (map\
    \ ceiling lst))))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (define (ceiling-helper\
    \ lst)\n    (map (lambda (x) (ceiling x)) lst))\n  (apply + (map (lambda (x) (*\
    \ x x)) (ceiling-helper lst))))\n", '  (apply + (map (lambda (x) (expt x 2)) (map
    ceiling lst))))', "  (cond [(empty? lst) 0]\n        [else (+ (square (ceiling\
    \ (first lst)))\n                 (sum_squares (rest lst)))]))\n", "  (define\
    \ (to-upper x)\n    (ceiling x))\n  (apply + (map (lambda (x) (* x x)) (map to-upper\
    \ lst))))\n", "  (for/sum ([i lst])\n    (ceiling (expt i 2))))\n", "  (apply\
    \ + (map (lambda (n) (expt (ceiling n) 2)) lst)))\n", "  (define (my-sum lst acc)\n\
    \    (if (null? lst)\n        acc\n        (my-sum (cdr lst) (+ acc (car lst)))))\n\
    \  (define (helper lst acc)\n    (if (null? lst)\n        acc\n        (helper\
    \ (cdr lst) (+ acc (my-sum (list (car lst)) 0)))))\n  (helper lst 0))", "  (apply\
    \ + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map (lambda\
    \ (n) (* n n)) (map ceiling lst))))\n", "  (sum (map square lst)))\n", "  (apply\
    \ + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map (lambda\
    \ (x) (* x x)) (map ceiling lst))))\n", '  (apply + (map (lambda (x) (round (expt
    x 2))) lst)))', '  (apply + (map (lambda (x) (expt x 2)) (map ceiling lst))))',
  "  (sum\n   (map\n    (lambda (n)\n      (expt (ceiling n) 2))\n    lst)))\n</code>\n\
    Here's a test harness written in Racket:\n<code>#lang racket\n", "  (apply + (map\
    \ (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\nbut all test cases fail,\
    \ how to modify it?\n\n\nA:\n\nYou are using <code>apply</code> and <code>+</code>\
    \ on lists which are floats.  So, the <code>expt</code> expressions is useless,\
    \ because you are taking the square of an integer.\nI think you want\n<code>(define\
    \ (sum_squares lst)\n  (apply + (map (lambda (x) (expt x 2)) lst)))\n</code>\n",
  "  (cond [(empty? lst) 0]\n        [else (+ (expt (ceiling (first lst)) 2)\n   \
    \              (sum_squares (rest lst)))]))\n", "  (apply + (map (lambda (num)\n\
    \                  (ceiling (expt num 2)))\n                lst)))\n", "  (apply\
    \ + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map (lambda\
    \ (x) (expt x 2)) lst)))\n", "  (apply + (map (lambda (x) (* x x)) (map ceiling\
    \ lst))))\n", "  (accumulate + 0 (map (lambda (x) (sqr (ceiling x))) lst)))\n",
  "  (apply + (map (lambda (n) (* n n))\n                (map (lambda (n) (ceiling\
    \ n)) lst))))\n", "  (apply + (map (lambda (x) (ceiling (* x x))) lst)))\n</code>\n\
    I'm looking for feedback on general style and clarity, as well as suggestions\
    \ for improvements.\n\n\nA:\n\nThe first thing that struck me when looking at\
    \ this code was that this is not really Racket. It looks more like Python, with\
    \ the <code>#lang racket</code> on top of it.\n\nLet's see how we could make this\
    \ code more Racket-like.\nFor starters, your <code>map</code>/<code>lambda</code>\
    \ looks like a good candidate for an <code>inline</code>:\n<code>(inline (lambda\
    \ (x) (ceiling (* x x))))\n</code>\nI would also remove the <code>lambda</code>\
    \ and just pass the <code>ceiling (* x x)</code> to <code>map</code>.\n<code>(map\
    \ ceiling (* x x))\n</code>\nNow, if we want to take this to the extreme, we might\
    \ want to replace <code>map</code> with <code>for*/list</code>:\n<code>(for*/list\
    \ ((x lst))\n  (ceiling (* x x)))\n</code>\nKeep in mind that I'm just trying\
    \ to show you how to make the code more Racket-like here, it's up to you to decide\
    \ what approach you want to follow, to be honest this is the first time I've seen\
    \ the <code>for*/list</code> approach, I've never done it myself, so I might be\
    \ completely wrong in suggesting this, but it sure looks nice.\nI would stick\
    \ with the good old <code>map</code>, though:\n<code>(map (lambda (x) (ceiling\
    \ (* x x))) lst)\n</code>\nFinally, I would also make the argument name <code>lst</code>\
    \ more descriptive, <code>numbers</code> sounds more natural:\n<code>(define (sum-squares\
    \ numbers)\n  (apply + (map (lambda (x) (ceiling (* x x))) numbers)))\n</code>\n",
  '  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))', "  (sum (map (lambda\
    \ (x) (* x x))\n            (map ceiling lst))))\n", "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n", '  (apply + (map (lambda (a) (expt (ceiling a) 2)) lst)))',
  "  (apply + (map (lambda (x) (round x)) (map (lambda (x) (* x x)) lst))))\n", " \
    \ (apply + (map (lambda (x) (ceiling x))\n                (map (lambda (x) (*\
    \ x x)) lst))))\n</code>\nThe <code>*</code> function is the built-in function\
    \ for multiplicaion. The <code>map</code> function applies the given function\
    \ to each element of the list and creates a new list with the result. Here the\
    \ list is evaluated twice. In the first evaluation the map function squares each\
    \ element. In the second evaluation the map function rounds up each element.\n\
    For higher readability I'd write it this way:\n<code>#lang racket\n", "  (define\
    \ (iter lst total)\n    (if (null? lst)\n        total\n        (let ((n (ceiling\
    \ (car lst))))\n          (iter (cdr lst) (+ total (* n n))))))\n  (iter lst 0))",
  "  (apply + (map (lambda (x) (* x x))\n                (map ceiling lst))))", " \
    \ (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\nThe <code>lst</code>\
    \ parameter is a list of numbers, i.e. it may contain integers, floats or/and\
    \ rationals. \nThe task is to sum up the squares of the elements of the list,\
    \ after they are rounded to the upper int (ceiling).\nThe solution shown above\
    \ works, but I'm looking for a way to\navoid the <code>apply</code> because the\
    \ <code>foldr</code> is much faster than the <code>apply</code>. So, I'm trying\
    \ to find a replacement for the <code>apply</code> but I've failed so far.\nI\
    \ was wondering if there is a way to avoid the <code>apply</code> and use something\
    \ else instead.\nI tried this:\n<code>(define (sum_squares lst)\n  (foldr + 0\
    \ (map (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\nand it doesn't work.\n\
    I also tried:\n<code>(define (sum_squares lst)\n  (foldr + 0 (map (lambda (x)\
    \ (expt (ceiling x) 2)) lst)))\n</code>\nbut it doesn't work either.\nI think\
    \ it has something to do with the <code>map</code>, because I can do that:\n<code>(define\
    \ (sum_squares lst)\n  (foldr + 0 (map ceiling lst)))\n</code>\nand it works fine.\n\
    But when I try to do the following:\n<code>(define (sum_squares lst)\n  (foldr\
    \ + 0 (map (lambda (x) (expt x 2)) lst)))\n</code>\nit doesn't work.\nAny ideas\
    \ on what the problem is and how to fix it?\n\n\nA:\n\nThe problem is not <code>map</code>\
    \ but <code>expt</code> you try to use.\n<code>expt</code> is defined as:\n<code>(expt\
    \ z n)\n  -&gt; number?\n  z : complex?\n  n : real?\n</code>\nYou are trying\
    \ to", "  (apply + (map (lambda (x) (* x x))\n                (map ceiling lst))))\n\
    </code>\nI'm trying to get a feel for this 'functional' programming style.  The\
    \ above works fine, I'm just wondering if there is a better way to do this?  It\
    \ kind of feels like I'm going through a list multiple times to get a final result.\
    \  I'm a bit rusty, so I could have just misunderstood this whole concept.\n\n\
    \nA:\n\nThere is indeed a better way to do this, but it takes a bit of work, and\
    \ is more of a technical exercise than something that'd be considered good practice.\
    \ The following is the most accurate definition of the <code>sum-squares</code>\
    \ procedure, without using any higher-order functions:\n<code>(define (sum-squares\
    \ lst)\n  (let loop ((lst lst)\n             (sum 0))\n    (if (null? lst)\n \
    \       sum\n        (loop (cdr lst)\n              (+ sum (square (ceiling (car\
    \ lst))))))))\n</code>\n", "  (apply + (map (lambda (x) (* x x))\n           \
    \     (map ceiling lst))))\n", "  (define (square x) (* x x))\n  (define (ceiling\
    \ x)\n    (if (= x (truncate x))\n        x\n        (+ x 1)))\n  (apply + (map\
    \ square (map ceiling lst))))\n", "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n", "  (apply + (map (lambda (x) (round x)) (map (lambda (x) (*\
    \ x x)) lst))))\n</code>\n<code>#lang racket\n", "  (if (empty? lst)\n      0\n\
    \      (+ (square (ceiling (first lst)))\n         (sum_squares (rest lst)))))\n",
  "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (for/sum ([x lst])\n\
    \    (ceiling x)))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", "  (define (sq n)\n\
    \    (* n n))\n  (apply + (map sq (map ceiling lst))))\n</code>\nThe documentation\
    \ for <code>ceiling</code> can be found here.\n", '  (foldl (lambda (acc x) (+
    acc (sqr x))) 0 lst))', "  (apply + (map square (map ceiling lst))))\n", "  (apply\
    \ + (map (lambda (x) (ceiling x) (expt x 2)) lst)))\n", "  (define sum (+ 0 0))\n\
    \  (for ([i (in-list lst)])\n    (set! sum (+ sum (round (ceiling (expt i 2)))))\n\
    \  )\n  sum\n)", '  (apply + (map (lambda (e) (sqr (ceiling e))) lst)))', '  (apply
    + (map (lambda (x) (* x x)) (map ceiling lst))))', "  (apply + (map (lambda (x)\
    \ (* x x))\n                (map ceiling lst))))\n", "  (apply + (map (lambda\
    \ (x) (round (sqr x))) lst)))\n", "  (foldl + 0 (map (lambda (x) (round (sqr x)))\
    \ lst)))\n</code>\nBonus\nI will award a bonus of 100 points to the first person\
    \ to provide a solution that doesn't use <code>foldl</code>, <code>map</code>,\
    \ <code>lambda</code>, or any other higher-order functions or macros.\n\n\nA:\n\
    \nAPL, 3 1 3\n<code>\u22A3[2]\u2218.\xD7\xA8\n</code>\nTry it online!\n<code>\u22A3\
    [2]</code> is an operator that takes the ceiling of each element to the second\
    \ power, and <code>\u2218.\xD7\xA8</code> takes the element-wise product of each\
    \ element with itself. The outer <code>\u22A3</code> is used to ensure that the\
    \ product is an integer, which is necessary due to the definition of <code>\u2218\
    .\xD7</code>.\n", "  (apply + (map (lambda (x) (ceiling x)\n                 \
    \           (* (ceiling x) (ceiling x))) lst)))\n", '  (apply + (map (lambda (x)
    (expt (ceiling x) 2)) lst)))', "  (apply + (map (lambda (x) (* x x))\n       \
    \         (map ceiling lst))))\n", '  (apply + (map (lambda (x) (* x x)) (map
    ceiling lst))))', "  (foldl + 0 (map (lambda (n) (expt (ceiling n) 2)) lst)))\n",
  "  (apply + (map (lambda (x) (* x x)) (map (lambda (x) (ceiling x)) lst))))\n",
  "  (for/sum ([x lst])\n    (* x x)))\n", '  (apply + (map (lambda (x) (expt (ceiling
    x) 2)) lst)))', "  (apply + (map (lambda (x) (* x x))\n                (map ceiling\
    \ lst))))", "  (for/sum ([x lst])\n    (* x x)))", "  (apply + (map (lambda (x)\
    \ (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (* x x)) (map\
    \ ceiling lst))))\n", "  (sum (map (lambda (x) (* x x))\n            (map ceiling\
    \ lst))))", "  (apply + (map (lambda (num)\n                  (expt num 2))\n\
    \                lst)))\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2))\
    \ lst)))\n", "  (apply + (map (lambda (x) (ceiling x) (expt x 2)) lst)))\n</code>\n\
    When I run this I get the following error:\n<code>racket@racket:~/onramp/racket/a$\
    \ racket sum_squares.rkt\n. sum_squares.rkt:10:0: procedure application: expected\
    \ procedure, given: 1; arguments were: 1\n  context...:\n   /usr/share/racket/collects/racket/private/misc.rkt:87:7\n\
    \   /usr/share/racket/collects/racket/private/more-scheme.rkt:148:2: call-with-break-parameterization\n\
    \   /usr/share/racket/collects/racket/private/more-scheme.rkt:261:2: call-with-exception-handler\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:177:0\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:187:7\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:187:7\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:187:7\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:187:7\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.rkt:187:7\n   /usr/share/racket/collects/sandbox/eval.rkt:155:8\n\
    \   /usr/share/racket/collects/sandbox/eval.", '  (apply + (map (lambda (x) (*
    x x)) (map ceiling lst))))', "  (foldl + 0 (map (lambda (x) (expt (ceiling x)\
    \ 2)) lst)))\n", "  (cond\n    [(empty? lst) 0]\n    [else\n     (+ (expt (ceiling\
    \ (first lst)) 2)\n        (sum_squares (rest lst)))]))\n", "  (apply + (map (lambda\
    \ (x) (round (** x 2))) lst)))\n", "  (apply + (map (lambda (x) (round x)) (map\
    \ (lambda (x) (* x x)) lst))))\n", "  (apply + (map (lambda (x) (* x x))\n   \
    \             (map ceiling lst))))\n", "  (define (ceiling x)\n    (if (< x 0)\n\
    \        (round x)\n        (if (and (integer? x) (= x (round x)))\n         \
    \   x\n            (add1 (round x)))))\n  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))", "  (for/sum ([n lst])\n    (exact->inexact (sqr (ceiling n)))))\n",
  "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda\
    \ (num) (expt (ceiling num) 2)) lst)))\n</code>\nThis solution works OK but I\
    \ don't like using <code>apply</code> in this case. \nIs there any way to convert\
    \ list to <code>...</code> notation so I can pass it to <code>sum_squares</code>\
    \ function ?\n\n\nA:\n\nYou could implement your own higher-order function, like\
    \ this:\n<code>(define (my-sum f xs)\n  (apply + (map f xs)))\n</code>\nAnd then\
    \ call it like this:\n<code>(my-sum (lambda (num) (expt (ceiling num) 2)) lst)\n\
    </code>\nBut it's much better to use the predefined <code>foldr</code> procedure,\
    \ which is designed to do exactly that:\n<code>(foldr + 0 (map (lambda (num) (expt\
    \ (ceiling num) 2)) lst))\n</code>\nBy the way, it's a common mistake to think\
    \ that <code>apply</code> is a bad thing to use, that's simply not true, in most\
    \ cases it's perfectly fine.\n", '  (apply + (map (lambda (x) (* x x)) (map ceiling
    lst))))', "  (apply + (map (lambda (n) (expt (ceiling n) 2)) lst)))\n</code>\n",
  "  (cond [(empty? lst) 0]\n        [else (+ (expt (ceiling (first lst)) 2)\n   \
    \              (sum_squares (rest lst)))]))", "  (apply + (map (lambda (x) (expt\
    \ (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (round (sqr x))) lst)))\n\
    </code>\n", "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\n",
  "  (define (each-lst lst acc)\n    (cond\n      [(empty? lst) acc]\n      [else\
    \ (each-lst (rest lst) (+ acc (ceiling (square (first lst)))))]))\n  (each-lst\
    \ lst 0))\n</code>\nThis is the solution provided:\n<code>#lang racket\n", " \
    \ (apply + (map (lambda (x) (round x)) (map (lambda (x) (* x x)) lst))))\n", " \
    \ (for/sum ([x lst])\n    (expt (ceiling x) 2)))\n", "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n</code>\n", "  (cond\n    [(empty? lst) 0]\n\
    \    [else\n     (+ (ceiling (car lst))\n        (sum_squares (cdr lst)))]))\n",
  '  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))', "  (apply + (map (lambda\
    \ (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n</code>\n", "  (apply + (map (lambda (n) (ceiling n) (square\
    \ n)) lst)))\n", "  (cond\n    [(null? lst) 0]\n    [else\n     (+ (ceiling (*\
    \ (car lst) (car lst)))\n        (sum_squares (cdr lst)))]))\n", "  (apply + (map\
    \ (lambda (x) (* x x)) (map (lambda (x) (ceiling x)) lst))))\n", "  (define (is-number?\
    \ str)\n    (and (number? str) (not (nan? str))))\n  (define (abs-round x)\n \
    \   (if (positive? x)\n        (ceiling x)\n        (floor x)))\n  (apply + (map\
    \ (lambda (x) (if (is-number? x)\n                                (expt (abs-round\
    \ x) 2)\n                                0))\n                 lst)))\n", "  (apply\
    \ + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\nThis works as expected.\
    \ However, this also works.\n<code>#lang racket\n", "  (foldl + 0 (map sqr (map\
    \ ceiling lst))))\n</code>\nIt seems to work fine:\n<code>&gt; (sum_squares (list\
    \ 1 2 3))\n14\n&gt; (sum_squares (list 1 4 9))\n98\n&gt; (sum_squares (list 1\
    \ 3 5 7))\n84\n&gt; (sum_squares (list 1.4 4.2 0))\n29\n&gt; (sum_squares (list\
    \ -2.4 1 1))\n6\n</code>\nBut when I submit it I get a fail. What am I doing wrong?\n\
    My code is here: http://pastebin.com/HMcuJVLA\n\n\nA:\n\nIt's an order of operations\
    \ problem. The problem requires you to use <code>sqr</code> on numbers after they've\
    \ been rounded up to the nearest integer. In Scheme, function application is left-associative,\
    \ so your statement:\n<code>(sqr (ceiling lst))\n</code>\nis read as:\n<code>(sqr\
    \ ((ceiling lst)))\n</code>\nWhat you want is:\n<code>((sqr (ceiling lst)))\n\
    </code>\nIf you make the change, your code passes the test.\n", "  (apply + (map\
    \ (lambda (x) (* x x)) (map ceiling lst))))\n", "  (cond\n    [(empty? lst) 0]\n\
    \    [else (+ (sqr (ceiling (first lst))) (sum_squares (rest lst)))]))\n", " \
    \ (apply + (map (lambda (x) (* x x))\n                (map ceiling lst))))\n",
  "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda\
    \ (x) (* x x)) (map ceiling lst))))\n", "  (apply + (map (lambda (el) (round el))\
    \ (map (lambda (el) (* el el)) lst))))\n", "  (apply + (map square (map ceiling\
    \ lst))))\n</code>\n", '  (apply + (map (lambda (x) (round (expt x 2))) lst)))',
  "  (define (ceiling x)\n    (cond\n      [(< x 0)\n       (- x (- (modulo x 1)))]\n\
    \      [else\n       (+ x (- (- 1 (modulo x 1))))]))\n  (apply + (map (lambda\
    \ (x) (ceiling x)) (map square lst))))", "  (apply + (map (lambda (x) (* x x))\
    \ (map ceiling lst))))\n```\n\n```scheme\n#lang racket\n", "  (apply + (map (lambda\
    \ (e) (expt (ceiling e) 2)) lst)))\n", "  (apply + (map (lambda (x) (expt (ceiling\
    \ x) 2)) lst)))\n", "  (apply + (map (lambda (x) (ceiling x)) (map square lst))))\n",
  "  (apply + (map (lambda (x) (expt (ceiling x) 2)) lst)))\n</code>\n", "  (for/sum\
    \ ([x lst])\n    (* x x)))\n", "  (apply + (map (lambda (x) (round x))\n     \
    \           (map (lambda (x) (* x x)) lst))))\n", "  (apply + (map (lambda (n)\
    \ (round (square n))) lst)))\n", "  (apply + (map (lambda (n) (ceiling (abs n)))\
    \ (map square lst))))\n", '  (sum (map (lambda (x) (expt (ceiling x) 2)) lst)))',
  "  (cond\n    [(empty? lst) 0]\n    [else (+ (square (ceiling (first lst)))\n  \
    \           (sum_squares (rest lst)))]))\n", '  (apply + (map (lambda (n) (* n
    n)) (map ceiling lst))))', "  (apply + (map (lambda (x) (expt (ceiling x) 2))\
    \ lst)))\n", "  (apply + (map\n            (lambda (x)\n              (expt (ceiling\
    \ x) 2))\n            lst)))\n", '  (apply + (map (lambda (x) (* x x)) (map ceiling
    lst))))', "  (apply + (map (lambda (n) (* n n)) (map ceiling lst))))\n</code>\n\
    Here are a few sample runs:\n<code>&gt; (sum_squares '(1 2 3))\n14\n&gt; (sum_squares\
    \ '(1.2 4.5 9))\n98\n&gt; (sum_squares '(1.4 4.2 0))\n29\n&gt; (sum_squares '(-2.4\
    \ 1 1))\n6\n</code>\n", "  (cond\n    [(empty? lst) 0]\n    [else (+ (ceiling\
    \ (car lst)) (sum_squares (cdr lst)))]))\n", "  (define (sum_squares_helper lst\
    \ acc)\n    (if (null? lst)\n        acc\n        (let ([x (car lst)])\n     \
    \     (sum_squares_helper (cdr lst) (+ acc (* x x))))))\n  (sum_squares_helper\
    \ lst 0))\n", "  (apply + (map square (map ceiling lst))))\n", '  (apply + (map
    (lambda (x) (expt (ceiling x) 2)) lst)))', "  (apply + (map (lambda (x) (expt\
    \ (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (* x x)) (map ceiling\
    \ lst))))\n", "  (apply + (map (lambda (x) (* x x)) (map ceiling lst))))\n", " \
    \ (apply + (map (lambda (n) (* n n)) (map ceiling lst))))\n", "  (apply + (map\
    \ (lambda (x) (expt (ceiling x) 2)) lst)))\n", "  (apply + (map (lambda (x) (expt\
    \ x 2)) (map ceiling lst))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
