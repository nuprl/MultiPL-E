name: HumanEval_59_largest_prime_factor
language: rkt
prompt: "#lang racket\n\n;; Return the largest prime factor of n. Assume n > 1 and\
  \ is not a prime.\n;; >>> largest_prime_factor(13195)\n;; 29\n;; >>> largest_prime_factor(2048)\n\
  ;; 2\n(define (largest_prime_factor n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n\
  \    (check-equal? (candidate 15) 5)\n    (check-equal? (candidate 27) 3)\n    (check-equal?\
  \ (candidate 63) 7)\n    (check-equal? (candidate 330) 11)\n    (check-equal? (candidate\
  \ 13195) 29)\n))\n\n(test-humaneval)"
completions: ["  (define (prime? n)\n    (not (or (= n 1)\n             (zero? (remainder\
    \ n 2))\n             (zero? (remainder n 3))\n             (zero? (remainder\
    \ n 5))\n             (zero? (remainder n 7)))))\n  (cond ((prime? n) n)\n   \
    \     ((prime? (remainder n 2)) 2)\n        ((prime? (remainder n 3)) 3)\n   \
    \     ((prime? (remainder n 5)) 5)\n        ((prime? (remainder n 7)) 7)\n   \
    \     (else (largest_prime_factor (quotient n 2)))))\n", "  (define (prime? n)\n\
    \    (cond\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= (remainder n 2)\
    \ 0) #f]\n      [else\n       (let loop ([m 3])\n         (cond\n           [(=\
    \ (remainder n m) 0) #f]\n           [(> (* m m) n) #t]\n           [else (loop\
    \ (+ m 2))]))]))\n  (define (divisors n)\n    (let loop ([i 2])\n      (cond\n\
    \        [(> (* i i) n) n]\n        [(= (remainder n i) 0) i]\n        [else (loop\
    \ (+ i 1))])))\n  (define (factors n)\n    (cond\n      [(= n 1) '()]\n      [(prime?\
    \ n) (list n)]\n      [else\n       (let ([d (divisors n)])\n         (append\
    \ (factors (/ n d)) (list d)))]))\n  (let ([primes (filter prime? (factors n))])\n\
    \    (apply max primes)))", "  (for/first ([f (in-range (quotient n 2) 0 -1)])\n\
    \    (and (prime? f)\n         (zero? (remainder n f))\n         f)))\n", "  (define\
    \ (largest_prime_factor_iter n i)\n    (cond\n      [(= i n) n]\n      [(= 0 (modulo\
    \ n i)) (largest_prime_factor_iter (/ n i) i)]\n      [else (largest_prime_factor_iter\
    \ n (+ i 1))]))\n  (largest_prime_factor_iter n 2))\n", "  (define (factors n)\n\
    \    (let loop ([i 2] [fs (list)])\n      (if (< n (* i i))\n          (if (null?\
    \ fs)\n              (list n)\n              fs)\n          (if (zero? (modulo\
    \ n i))\n              (loop (+ i 1) (cons i fs))\n              (loop (+ i 1)\
    \ fs)))))\n  (if (null? (cdr (factors n)))\n      (car (factors n))\n      (largest_prime_factor\
    \ (car (factors n)))))\n", "  (define (factor-of? n x)\n    (= (remainder n x)\
    \ 0))\n  (define (largest-factor-of-do n x)\n    (cond\n      [(> n x) (largest-factor-of-do\
    \ n (+ x 1))]\n      [(factor-of? n x) (largest-factor-of-do (/ n x) x)]\n   \
    \   [else n]))\n  (largest-factor-of-do n 2))\n", "  (for/first ([p (in-primes\
    \ n)])\n    (if (zero? (modulo n p))\n        p)))\n", "  (let loop ([n n] [d\
    \ 2])\n    (cond [(= n d) d]\n          [(not (integer? (/ n d))) (loop n (+ d\
    \ 1))]\n          [else (loop (/ n d) d)])))\n", "  (define (find-prime a b)\n\
    \    (if (prime? a)\n        a\n        (find-prime (+ b 1) b)))\n  (define (prime?\
    \ n)\n    (define (iter a)\n      (if (= a n)\n          #t\n          (if (divides?\
    \ a n)\n              #f\n              (iter (+ a 1)))))\n    (iter 2))\n  (define\
    \ (divides? a b)\n    (= (remainder b a) 0))\n  (define (largest-prime a b)\n\
    \    (if (divides? a b)\n        (largest-prime a (/ b a))\n        (find-prime\
    \ a b)))\n  (largest-prime 2 n))\n", "  (if (prime? n)\n      n\n      (let ([div\
    \ (next-prime 2)])\n        (while (not (or (= 0 (modulo n div))\n           \
    \             (prime? n)))\n          (set! n (/ n div))\n          (set! div\
    \ (next-prime div)))\n        n)))\n", "  (define (prime? n)\n    (define (divides?\
    \ k n) (= (remainder n k) 0))\n    (cond ((<= n 1) #f)\n          ((= n 2) #t)\n\
    \          ((divides? 2 n) #f)\n          (else (let loop ((k 3))\n          \
    \        (cond ((not (divides? k n)) (loop (+ k 2)))\n                       \
    \ ((> (* k k) n) #t)\n                        (else #f))))))\n  (define (divisors\
    \ n)\n    (cond ((not (integer? n)) (error \"n must be an integer.\"))\n     \
    \     ((<= n 1) (error \"n must be positive.\"))\n          ((prime? n) (error\
    \ \"n must not be prime.\"))\n          (else (let loop ((k 2) (lst '()))\n  \
    \                (cond ((> k n) lst)\n                        ((divides? k n)\
    \ (loop (+ k 1) (cons k lst)))\n                        (else (loop (+ k 1) lst)))))))\n\
    \  (define (max-prime-factor n)\n    (let loop ((divisors (divisors n)))\n   \
    \   (cond ((null? divisors) #f)\n            ((prime? (car divisors)) (car divisors))\n\
    \            (else (loop (cdr divisors))))))\n  (max-prime-factor n))\n", "  (define\
    \ (largest-prime-factor-iter f n prime-list)\n    (if (<= (* f f) n)\n       \
    \ (if (zero? (modulo n f))\n            (largest-prime-factor-iter f (/ n f) (cons\
    \ f prime-list))\n            (largest-prime-factor-iter (+ f 1) n prime-list))\n\
    \        (max prime-list)))\n  (largest-prime-factor-iter 2 n empty))\n", "  (define\
    \ (largest_prime_factor-iter l p)\n    (if (= l 0) p\n        (if (zero? (modulo\
    \ l p)) (largest_prime_factor-iter (/ l p) p)\n            (largest_prime_factor-iter\
    \ l (+ p 1)))))\n  (largest_prime_factor-iter n 2))\n", "  (define (largest-helper\
    \ k)\n    (if (< n (* k k))\n        n\n        (if (zero? (modulo n k))\n   \
    \         (largest-helper (/ n k))\n            (largest-helper (+ k 1)))))\n\
    \  (largest-helper 2))\n", "  (let loop ([i (inexact->exact (floor (sqrt n)))]\n\
    \             [result n])\n    (cond [(= n 1) result]\n          [(= (remainder\
    \ n i) 0)\n           (if (prime? i) i (loop (- i 1) result))]\n          [else\
    \ (loop (- i 1) result)])))\n", "  (define prime-factors (list 1))\n  (define\
    \ d 1)\n  (define last-factor n)\n  (while (> last-factor d)\n    (set! d (+ d\
    \ 1))\n    (if (and (> (remainder n d) 0) (prime? d))\n        (set! last-factor\
    \ (/ n d))\n        (set! prime-factors (cons last-factor prime-factors))))\n\
    \  (apply max prime-factors))\n", "  (letrec ((is-prime? (lambda (n)\n       \
    \                (if (zero? (remainder n 2))\n                           #f\n\
    \                           (let ((ceiling (/ n 2)))\n                       \
    \      (let loop ((i 3))\n                               (if (> i ceiling)\n \
    \                                  #t\n                                   (if\
    \ (zero? (remainder n i))\n                                       #f\n       \
    \                                (loop (+ i 2))))))))))\n    (let loop ((i 3))\n\
    \      (if (> i n)\n          #f\n          (if (and (zero? (remainder n i))\n\
    \                   (is-prime? i))\n              i\n              (loop (+ i\
    \ 2)))))))\n", "  (define (largest-prime-factor/divisor n d)\n    (if (< (* d\
    \ d) n)\n        (if (zero? (modulo n d))\n            (largest-prime-factor/divisor\
    \ (/ n d) d)\n            (largest-prime-factor/divisor n (+ d 1)))\n        n))\n\
    \  (largest-prime-factor/divisor n 2))\n", "  (define (largest-prime-factor-helper\
    \ n f)\n    (if (< f n)\n        (if (zero? (modulo n f))\n            (largest-prime-factor-helper\
    \ (/ n f) f)\n            (largest-prime-factor-helper n (+ f 1)))\n        n))\n\
    \  (largest-prime-factor-helper n 2))\n```\n\n```racket\n#lang racket\n", "  (if\
    \ (prime? n)\n      n\n      (for/first ([i (in-range 2 n)]\n                \
    \  #:when (zero? (remainder n i)))\n          (largest_prime_factor i))))\n",
  "  (largest_prime_factor_helper n 2))\n", "  (let ([i 2])\n    (for ([j (in-range\
    \ n 2 -1)])\n      (when (divides? j i)\n        (set! n j)\n        (set! i 2))\n\
    \      (set! i (+ i 1)))))\n", "  (define (next-prime x)\n    (if (prime? (+ x\
    \ 1))\n        (+ x 1)\n        (next-prime (+ x 1))))\n  (define (try-dividend\
    \ d)\n    (if (= (modulo n d) 0)\n        (if (prime? (/ n d))\n            (/\
    \ n d)\n            (try-dividend (next-prime d)))\n        (try-dividend (next-prime\
    \ d))))\n  (try-dividend 2))\n", "  (if (prime? n)\n      n\n      (largest_prime_factor\
    \ (greatest_factor n))))\n", "  (largest_prime_factor-rec n 2))\n", "  (displayln\
    \ \"Finding largest prime factor of \" n)\n  (for/first ([i (in-range 2 (quotient\
    \ n 2))]\n              #:when (and (integer? (quotient n i))\n              \
    \            (prime? i)))\n    i))\n", "  (if (prime? n)\n      n\n      (largest_prime_factor\
    \ (next-prime-factor n))))\n", "  (define (largest_prime_factor-iter n i)\n  \
    \  (cond\n      ((= n i)\n       (error \"n is prime\"))\n      ((= n 1)\n   \
    \    (error \"No prime factor exists\"))\n      ((and (= (remainder n i) 0)\n\
    \            (prime? i))\n       i)\n      (else\n       (largest_prime_factor-iter\
    \ n (+ i 1)))))\n  (largest_prime_factor-iter n 2))\n", "  (define (lpf n i)\n\
    \    (if (= n i)\n        i\n        (if (divides? i n)\n            (lpf (/ n\
    \ i) i)\n            (lpf n (+ i 1)))))\n  (lpf n 2))\n", "  (cond [(prime? n)\
    \ n]\n        [else\n         (define p (find-smallest-divisor n))\n         (define\
    \ d (largest_prime_factor (/ n p)))\n         (if (< p d) d p)]))\n", "  (largest_prime_factor-helper\
    \ n 2 (floor (sqrt n))))\n", "  (define (rec n)\n    (define d (smallest_prime_factor\
    \ n))\n    (if (= n d) d (rec (/ n d))))\n  (rec n))\n", "  (define (largest-prime-factor\
    \ n acc)\n    (if (is-prime n)\n        n\n        (let ([f (smallest-prime-factor\
    \ n)])\n          (largest-prime-factor (/ n f) f))))\n  (largest-prime-factor\
    \ n 2))\n", "  (for/first ([d (in-range 2 (quotient n 2))]\n              #:when\
    \ (divisible? n d)\n              #:when (prime? d))\n    d))\n", "  (define (lst-primes\
    \ n acc)\n    (if (prime? n)\n        (cons n acc)\n        (lst-primes (first\
    \ (prime-factors n))\n                    (cons n acc))))\n  (lst-primes n '()))\n",
  "  (largest_prime_factor_iter n 2))\n", "  (for*/first ((i (in-range n))\n     \
    \          (n (in-naturals)))\n    (if (= 0 (modulo n i)) i)))\n", "  (define\
    \ (prime-factors n)\n    (cond [(integer? n) (list n)]\n          [(= 0 (remainder\
    \ n 2)) (cons 2 (prime-factors (/ n 2)))]\n          [else (prime-factors-helper\
    \ n 3)]))\n  (define (prime-factors-helper n f)\n    (cond [(= 0 (remainder n\
    \ f)) (cons f (prime-factors-helper (/ n f) f))]\n          [else (prime-factors-helper\
    \ n (+ f 2))]))\n  (define (last-prime l)\n    (if (null? (cdr l))\n        (car\
    \ l)\n        (last-prime (cdr l))))\n  (last-prime (prime-factors n)))\n", " \
    \ (largest_prime_factor_iter n 2))\n", "  (define i 2)\n  (define lst '())\n \
    \ (do ((i i (+ i 1)))\n      ((> i (sqrt n))\n       (if (empty? lst)\n      \
    \     (- n 1)\n           (apply max lst)))\n    (if (and (divides? i n) (prime?\
    \ i))\n        (set! lst (cons i lst)))))\n", "  (largest_prime_factor-helper\
    \ n 2))\n", "  (largest_prime_factor/iter n 2))\n", "  (define (factors n)\n \
    \   (filter (lambda (i) (zero? (remainder n i)))\n            (range 2 n)))\n\
    \  (first (filter prime? (factors n))))\n```\n\n## Problem 5\n\n> 2520 is the\
    \ smallest number that can be divided by each of the numbers from 1 to 10 without\
    \ any remainder.\n>\n> What is the smallest positive number that is evenly divisible\
    \ by all of the numbers from 1 to 20?\n\n- https://projecteuler.net/problem=5\n\
    \n```racket\n#lang racket\n", "  (define (largest_prime_factor-iter n f)\n   \
    \ (if (= n 1)\n        f\n        (if (zero? (modulo n f))\n            (largest_prime_factor-iter\
    \ (/ n f) f)\n            (largest_prime_factor-iter n (+ f 1)))))\n  (largest_prime_factor-iter\
    \ n 2))\n", "  (define (prime? n)\n    (if (not (even? n))\n        (even? (remainder\
    \ (expt 2 (sub1 (expt 2 (sub1 (expt 2 1))))) n))\n        #t))\n  (define (next-divisor\
    \ n d)\n    (if (prime? d)\n        d\n        (next-divisor n (add1 d))))\n \
    \ (define (largest-divisor n d)\n    (if (zero? (remainder n d))\n        (largest-divisor\
    \ (quotient n d) d)\n        (next-divisor n (add1 d))))\n  (largest-divisor n\
    \ 2))\n", "  (define (largest_prime_factor_iter n candidate)\n    (if (even? n)\n\
    \        (largest_prime_factor_iter (/ n 2) 2)\n        (largest_prime_factor_iter\
    \ n (+ candidate 1))))\n  (largest_prime_factor_iter n 3))\n", "  (define (largest-prime-helper\
    \ n factor)\n    (if (and (integer? (/ n factor))\n             (is-prime (/ n\
    \ factor)))\n        (/ n factor)\n        (largest-prime-helper n (+ factor 1))))\n\
    \  (largest-prime-helper n 2))\n", "  (define (factor? a n)\n    (= (remainder\
    \ n a) 0))\n  (define (is-prime? n)\n    (let loop ([f 2])\n      (cond [(> f\
    \ (sqrt n)) #t]\n            [(factor? f n) #f]\n            [else (loop (+ f\
    \ 1))])))\n  (define (find-factors n)\n    (let loop ([f 2])\n      (cond [(>\
    \ f (sqrt n)) (list n)]\n            [(factor? f n) (cons f (find-factors (/ n\
    \ f)))]\n            [else (loop (+ f 1))])))\n  (car (let loop ([factors (find-factors\
    \ n)])\n          (cond [(is-prime? (car factors)) (car factors)]\n          \
    \      [else (loop (cdr factors))]))))\n", "  (prime-factors-of n (random n 2)))\n",
  "  (largest_prime_factor-list (list (list n))))\n", "  (define (prime-factors n)\n\
    \    (define (even? n) (= (remainder n 2) 0))\n    (cond ((= n 1) (list))\n  \
    \        ((even? n) (cons 2 (prime-factors (/ n 2))))\n          (else (define\
    \ (prime-test-from k)\n                  (cond ((= k n) (list n))\n          \
    \              ((= (remainder n k) 0) (cons k (prime-factors (/ n k))))\n    \
    \                    (else (prime-test-from (+ k 1)))))\n                (prime-test-from\
    \ 3))))\n  (apply max (prime-factors n)))", "  (define (prime? n)\n    (define\
    \ (prime?-loop n i)\n      (cond ((> (* i i) n) #t)\n            ((= (remainder\
    \ n i) 0) #f)\n            (else (prime?-loop n (+ i 1)))))\n    (prime?-loop\
    \ n 2))\n  (define (divisors n)\n    (define (divisors-loop n i)\n      (cond\
    \ ((= n i) '())\n            ((= (remainder n i) 0) (cons i (divisors-loop n (+\
    \ i 1))))\n            (else (divisors-loop n (+ i 1)))))\n    (divisors-loop\
    \ n 2))\n  (define (prime-divisors n)\n    (filter prime? (divisors n)))\n  (apply\
    \ max (prime-divisors n)))", "  (define (largest_prime-helper n p f)\n    (if\
    \ (and (zero? (modulo n p)) (< p n))\n        (largest_prime-helper (quotient\
    \ n p) p f)\n        (if (= n p)\n            p\n            (largest_prime-helper\
    \ n (+ p f) 6))))\n  (largest_prime-helper n 2 6))\n```\n\n### [Problem 7] 10001st\
    \ prime\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we\
    \ can see that the 6th prime is 13.\n\nWhat is the 10 001st prime number?\n\n\
    Brute force method is too slow. Let's use `modulo` and the fact that all prime\
    \ numbers are of the form 6n \xB1 1.\n\n#### Solution\n\n```scheme\n#lang racket\n",
  "  (define (iter f n)\n    (if (number? (find_factor n))\n        (iter (find_factor\
    \ n) n)\n        f))\n  (define (find_factor n)\n    (for/first ([f (in-range\
    \ 2 (sqrt n))])\n      (if (integer? (/ n f))\n          f)))\n  (iter 2 n))\n",
  "  (define (factor? n)\n    (for/or ([d (in-range 2 (add1 (quotient n 2)))])\n \
    \            (zero? (remainder n d))))\n  (define (lpd i)\n    (if (and (< i n)\
    \ (< n (* i i)))\n        (if (zero? (remainder n i))\n            (if (factor?\
    \ i)\n                i\n                (lpd (add1 i)))\n            (lpd (add1\
    \ i)))\n        n))\n  (lpd 2))\n", "  (define (largest_prime_factor-iter smallest-prime-factor\
    \ n)\n    (if (= n 1)\n        smallest-prime-factor\n        (if (prime? n)\n\
    \            n\n            (largest_prime_factor-iter\n             smallest-prime-factor\n\
    \             (div-except-trivial-factor n smallest-prime-factor)))))\n  (define\
    \ (div-except-trivial-factor n smallest-prime-factor)\n    (define (div-except-trivial-factor-iter\
    \ n smallest-prime-factor)\n      (if (= (modulo n smallest-prime-factor) 0)\n\
    \          (div-except-trivial-factor-iter (/ n smallest-prime-factor) smallest-prime-factor)\n\
    \          n))\n    (div-except-trivial-factor-iter n smallest-prime-factor))\n\
    \  (largest_prime_factor-iter 2 n))", "  (define (divisible? a b)\n    (= (remainder\
    \ a b) 0))\n  (define (sieve n sqrt-n)\n    (define (test k)\n      (define (test-helper\
    \ a)\n        (if (= a k)\n            #t\n            (if (divisible? k a)\n\
    \                #f\n                (test-helper (+ a 1)))))\n      (test-helper\
    \ 2))\n    (if (= n 1)\n        (list)\n        (if (test n)\n            (cons\
    \ n (sieve (- n 1) sqrt-n))\n            (sieve (- n 1) sqrt-n))))\n  (define\
    \ (solve n sqrt-n)\n    (define (solve-helper lst)\n      (if (null? lst)\n  \
    \        0\n          (if (divisible? n (car lst))\n              (car lst)\n\
    \              (solve-helper (cdr lst)))))\n    (solve-helper (sieve sqrt-n sqrt-n)))\n\
    \  (solve n (sqrt n)))", "  (define (recur n p)\n    (if (even? n)\n        (recur\
    \ (/ n 2) 2)\n        (if (divides? n p)\n            (if (= n p) n (recur (/\
    \ n p) p))\n            (recur n (+ p 1)))))\n  (recur n 2))\n", "  (let loop\
    \ ([remain n] [div 2])\n    (cond [(<= (* div div) remain)\n           (if (divides?\
    \ div remain)\n               (loop (/ remain div) div)\n               (loop\
    \ remain (+ div 1)))]\n          [else remain])))\n", "  (let loop ([n n] [d 2])\n\
    \    (cond\n      [(= n 1) d]\n      [(integer? (/ n d)) (loop (/ n d) d)]\n \
    \     [else (loop n (+ d 1))])))\n", "  (define (is-prime? n)\n    (define (divides?\
    \ a b) (= (modulo b a) 0))\n    (define (helper m)\n      (if (= m 2)\n      \
    \    #t\n          (and (not (divides? m n)) (helper (- m 1)))))\n    (helper\
    \ (- n 1)))\n  (define (smallest-prime-factor n)\n    (define (helper x)\n   \
    \   (if (and (is-prime? x) (divides? x n))\n          x\n          (helper (+\
    \ x 1))))\n    (helper 2))\n  (define (prime-factors n)\n    (cond ((= n 1) empty)\n\
    \          ((is-prime? n) (list n))\n          (else (cons (smallest-prime-factor\
    \ n)\n                      (prime-factors (quotient n (smallest-prime-factor\
    \ n)))))))\n  (define (largest-prime-factor n)\n    (apply max (prime-factors\
    \ n)))\n  (largest-prime-factor n))\n", "  (define (recurse n i)\n    (if (= n\
    \ 1)\n        i\n        (let ([d (gcd n i)])\n          (if (= d 1)\n       \
    \       (recurse n (+ i 1))\n              (recurse (/ n d) d)))))\n  (recurse\
    \ n 2))\n", "  (define (is-prime? n)\n    (or (eq? 1 n)\n        (and (not (zero?\
    \ (remainder n 2)))\n             (is-prime? (sub1 n)))))\n  (define (largest-prime-factor-iter\
    \ n i)\n    (cond ((is-prime? n) n)\n          ((zero? (remainder n i)) (largest-prime-factor-iter\
    \ (/ n i) i))\n          (else (largest-prime-factor-iter n (+ i 1)))))\n  (largest-prime-factor-iter\
    \ n 2))\n```\n\n## Problem 6 - Sum square difference\n\nThe sum of the squares\
    \ of the first ten natural numbers is,\n\n> 1^2 + 2^2 + ... + 10^2 = 385\n\nThe\
    \ square of the sum of the first ten natural numbers is,\n\n> (1 + 2 + ... + 10)^2\
    \ = 55^2 = 3025\n\nHence the difference between the sum of the squares of the\
    \ first ten natural numbers and the square of the sum is 3025 \u2212 385 = 2640.\n\
    \nFind the difference between the sum of the squares of the first one hundred\
    \ natural numbers and the square of the sum.\n\n```racket\n#lang racket\n", " \
    \ (define (iter k)\n    (cond\n      [(prime? k) k]\n      [else (iter (- k 1))]))\n\
    \  (define (prime? n)\n    (define (iter k)\n      (cond\n        [(= n k) #t]\n\
    \        [(zero? (modulo n k)) #f]\n        [else (iter (+ k 1))]))\n    (iter\
    \ 2))\n  (define (divisors n)\n    (define (iter k)\n      (cond\n        [(zero?\
    \ (modulo n k)) (list k (iter (+ k 1)))]\n        [else (iter (+ k 1))]))\n  \
    \  (iter 2))\n  (define divs (divisors n))\n  (cond\n    [(not (empty? divs))\
    \ (apply max (filter prime? divs))]\n    [else (iter (- n 1))]))\n", "  (if (prime?\
    \ n)\n      n\n      (largest_prime_factor (prime-divisor n))))\n", "  (define\
    \ (largest-factor n f)\n    (cond\n      [(= n f) f]\n      [(= (remainder n f)\
    \ 0) (largest-factor (/ n f) f)]\n      [else (largest-factor n (+ f 1))]))\n\
    \  (define (first-factor n)\n    (cond\n      [(> n 2) (largest-factor n 2)]\n\
    \      [else n]))\n  (first-factor n))\n", "  (let loop ([k 2] [n n])\n    (cond\
    \ [(> (* k k) n) n]\n          [(divides? k n) (loop (+ k 1) (/ n k))]\n     \
    \     [else (loop (+ k 1) n)])))\n", "  (define (largest n primes)\n    (cond\n\
    \      [(empty? primes) n]\n      [(= 0 (modulo n (first primes)))\n       (largest\
    \ (quotient n (first primes)) (first primes))]\n      [else (largest n (rest primes))]))\n\
    \  (largest n (eratosthenes n)))\n", "  (largest_prime_factor-helper n 2))\n",
  "  (if (= n 2)\n      2\n      (let loop ([primes (make-prime-generator)]\n    \
    \             [p (prime-generator-next primes)]\n                 [n n])\n   \
    \     (if (= (modulo n p) 0)\n            (loop primes p (/ n p))\n          \
    \  (loop primes (prime-generator-next primes) n)))))\n", "  (let ((i (exact-integer-sqrt\
    \ n)))\n    (for/fold ([largest-prime-factor 1]) ([i i])\n      (cond\n      \
    \  [(= (modulo n i) 0)\n         (let ((q (exact-integer-sqrt (quotient n i))))\n\
    \           (if (and (prime? i) (> i largest-prime-factor))\n               i\n\
    \               (cond\n                 [(= (modulo n q) 0)\n                \
    \  (if (and (prime? q) (> q largest-prime-factor))\n                      q\n\
    \                      largest-prime-factor)]\n                 [else\n      \
    \            largest-prime-factor])))]\n        [else\n         largest-prime-factor]))))\n",
  "  (cond ((prime? n) n)\n        ((prime? (largest_prime_factor-below n)) (largest_prime_factor-below\
    \ n))\n        (else (largest_prime_factor (largest_prime_factor-below n)))))\n",
  "  (define (prime? n)\n    (define (go m)\n      (cond\n        [(= m n) #t]\n \
    \       [(= (remainder n m) 0) #f]\n        [else (go (+ m 1))]))\n    (go 2))\n\
    \  (define (go m)\n    (cond\n      [(<= m n)\n       (if (prime? m)\n       \
    \    (if (= (remainder n m) 0)\n               m\n               (go (+ m 1)))\n\
    \           (go (+ m 1)))]\n      [else n]))\n  (go 2))\n", "  (define (is-prime?\
    \ n)\n    (let loop ([i 2])\n      (cond [(= i n) #t]\n            [(zero? (modulo\
    \ n i)) #f]\n            [else (loop (+ i 1))])))\n  (define (helper n primes)\n\
    \    (cond [(= n 1) primes]\n          [(is-prime? n) (cons n primes)]\n     \
    \     [else (let ([d (find-divisor n)])\n                  (helper (/ n d) (cons\
    \ d primes)))]))\n  (apply max (helper n '())))\n", "  (require srfi/1)\n  (require\
    \ maths/number-theory)\n  (define factors (filter is-prime? (prime-factors n)))\n\
    \  (car (reverse factors)))\n", "  (define (recurse i)\n    (if (not (prime? i))\n\
    \        (recurse (+ i 1))\n        i))\n  (recurse 2))\n", "  (cond\n    [(integer?\
    \ n) (largest_prime_factor-helper n 2)]\n    [else (error 'largest_prime_factor\
    \ \"bad argument\" n)]))\n", "  (define (lpf-aux n i)\n    (if (= n i)\n     \
    \   n\n        (if (divides? i n)\n            (lpf-aux (/ n i) i)\n         \
    \   (lpf-aux n (+ i 1)))))\n  (lpf-aux n 2))\n", "  (cond\n    [(> n 1) (largest_prime_factor-iter\
    \ 2 n)]\n    [else (error \"n is not greater than 1\")]))\n", "  (define (find-largest-prime-factor\
    \ k n)\n    (cond ((= k n) k)\n          ((prime? k) (find-largest-prime-factor\
    \ (+ k 1) n))\n          ((= (remainder n k) 0) k)\n          (else (find-largest-prime-factor\
    \ (+ k 1) n))))\n  (find-largest-prime-factor 2 n))\n", "  (define smallest-prime\
    \ 2)\n  (define (remainder-is-prime?) x\n    (define (divisible? a b) (= (remainder\
    \ a b) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square\
    \ test-divisor) n) n)\n            ((divisible? n test-divisor) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (not (divisible?\
    \ x (find-divisor x smallest-prime))))\n  (define (test-divisor n)\n    (cond\
    \ ((= n 2) 2)\n          ((remainder-is-prime? n) n)\n          (else (test-divisor\
    \ (- n 1)))))\n  (test-divisor (/ n 2)))\n", "  (cond\n    [(and (prime? n) (=\
    \ n 2)) 2] ;; if n is 2, it is the largest prime factor\n    [(prime? n) n] ;;\
    \ if n is prime, it is the largest prime factor\n    [else (largest_prime_factor\
    \ (smallest_prime_factor n))])) ;; find the largest prime factor of the smallest\
    \ prime factor of n\n", "  (define (largest_prime_factor-iter p n)\n    (cond\n\
    \      [(= 0 (modulo n p)) (largest_prime_factor-iter p (/ n p))]\n      [(prime?\
    \ (+ p 1)) (largest_prime_factor-iter (+ p 1) n)]\n      [else (largest_prime_factor-iter\
    \ (+ p 1) n)]))\n  (largest_prime_factor-iter 2 n))\n", "  (define (factorize\
    \ n)\n    (cond [(< n 4) (list n)]\n          [(even? n) (cons 2 (factorize (/\
    \ n 2)))]\n          [else (factorize-odd n 2)]))\n  (define (factorize-odd n\
    \ i)\n    (cond [(= n i) (list n)]\n          [(divides? i n) (cons i (factorize\
    \ (/ n i)))]\n          [else (factorize-odd n (+ i 1))]))\n  (define (divides?\
    \ a b)\n    (= (remainder b a) 0))\n  (apply max (factorize n)))", "  (define\
    \ (lprmfact2 m n)\n    (cond ((> m 1) (lprmfact2 (quotient m n) n))\n        \
    \  ((= 1 m) n)\n          (else (lprmfact2 m (+ n 1)))))\n  (lprmfact2 n 2))\n",
  "  (define (check-prime? n)\n    (define (iter d)\n      (if (= d n)\n         \
    \ #t\n          (if (= (remainder n d) 0)\n              #f\n              (iter\
    \ (+ d 1)))))\n    (iter 2))\n  (define (iter i)\n    (if (= (remainder n i) 0)\n\
    \        (if (check-prime? i)\n            i\n            (iter (+ i 1)))\n  \
    \      (iter (+ i 1))))\n  (iter 2))\n", "  (largest_prime_factor-helper n 2))\n",
  "  (local [(define (smallest-divisor n)\n            (if (prime? n)\n          \
    \      n\n                (local [(define (find-divisor n test-divisor)\n    \
    \                      (cond [(> (square test-divisor) n) n]\n               \
    \                 [(divides? test-divisor n) test-divisor]\n                 \
    \               [else (find-divisor n (+ test-divisor 1))]))]\n              \
    \    (find-divisor n 2))))]\n    (if (prime? n)\n        n\n        (largest-prime-factor\
    \ (/ n (smallest-divisor n))))))\n", "  (define (prime? x)\n    (define (divisible?\
    \ x y)\n      (= (modulo x y) 0))\n    (define (loop i)\n      (cond\n       \
    \ [(= i x) #t]\n        [(divisible? x i) #f]\n        [else (loop (+ i 1))]))\n\
    \    (loop 2))\n  (define (largest-factor x)\n    (define (loop i)\n      (cond\n\
    \        [(= i x) x]\n        [(divisible? x i) i]\n        [else (loop (+ i 1))]))\n\
    \    (loop 2))\n  (cond\n    [(prime? n) n]\n    [else (largest_prime_factor (largest-factor\
    \ n))]))", "  (define (aux n k factors)\n    (if (integer? (sqrt n))\n       \
    \ (if (member n factors)\n            (if (< n k) k n)\n            (aux n (+\
    \ k 1) (append factors (factorize (+ k 1)))))\n        (if (member n factors)\n\
    \            (if (< n k) k n)\n            (aux n (+ k 1) (append factors (factorize\
    \ (+ k 1)))))))\n  (aux n 2 (factorize 2)))\n", "  (largest_prime_factor_iter\
    \ n 3))\n", "  (let loop ([n n] [div 2])\n    (if (= n div)\n        div\n   \
    \     (if (zero? (modulo n div))\n            (loop (/ n div) div)\n         \
    \   (loop n (+ div 1))))))\n", "  (largest_prime_factor-iter 2 n))\n", "  (largest_prime_factor_acc\
    \ n 2))\n", "  (define (all-factors n)\n    (for/list ([i (in-range 2 (/ (sqrt\
    \ n) 2))])\n      (if (integer? (/ n i))\n          (list i (/ n i))\n       \
    \   '())))\n  (define (is-prime n)\n    (define (all-factors n)\n      (for/list\
    \ ([i (in-range 2 (/ (sqrt n) 2))])\n        (if (integer? (/ n i))\n        \
    \    (list i (/ n i))\n            '())))\n    (empty? (all-factors n)))\n  (define\
    \ (all-primes n)\n    (filter is-prime (all-factors n)))\n  (first (sort (all-primes\
    \ n) >)))\n", "  (for/first ([i (in-range (sub1 n) 2 -1)])\n    (if (zero? (modulo\
    \ n i))\n        (if (prime? i)\n            i\n            (largest_prime_factor\
    \ i)))))\n```\n\n#### Answer\n\n```racket\n#lang racket\n", "  (let ([factors\
    \ (divisors n 2)])\n    (for/fold ([largest 1]) ([factor factors])\n      (if\
    \ (prime? factor)\n          (max factor largest)\n          largest))))\n", " \
    \ (cond\n    [(= n 2) n]\n    [(= n 3) n]\n    [(= n 5) n]\n    [(= n 7) n]\n\
    \    [(= n 11) n]\n    [(= n 13) n]\n    [(= n 17) n]\n    [(= n 19) n]\n    [(=\
    \ n 23) n]\n    [(= n 29) n]\n    [(= n 31) n]\n    [(= n 37) n]\n    [(= n 41)\
    \ n]\n    [(= n 43) n]\n    [(= n 47) n]\n    [(= n 53) n]\n    [(= n 59) n]\n\
    \    [(= n 61) n]\n    [(= n 67) n]\n    [(= n 71) n]\n    [(= n 73) n]\n    [(=\
    \ n 79) n]\n    [(= n 83) n]\n    [(= n 89) n]\n    [(= n 97) n]\n    [(= n 101)\
    \ n]\n    [(= n 103) n]\n    [(= n 107) n]\n    [(= n 109) n]\n    [(= n 113)\
    \ n]\n    [(= n 127) n]\n    [(= n 131) n]\n    [(= n 137) n]\n    [(= n 139)\
    \ n]\n    [(= n 149) n]\n    [(= n 151) n]\n    [(= n 157) n]\n    [(= n 163)\
    \ n]\n    [(= n 167) n]\n    [(= n 173) n]\n    [(= n 179) n]\n    [(= n 181)\
    \ n]\n    [(= n 191) n]\n    [(= n 193) n]\n    [(= n 197) n]\n    [(= n 199)\
    \ n]\n    [(= n 211) n]\n    [(= n 223) n]\n    [(= n 227) n]\n    [(= n 229)\
    \ n]\n    [(= n 233) n]\n    [(= n 239) n]\n    [(= n 241) n]\n    [(= n 251)\
    \ n]\n    [(= n 257) n]\n    [(= n 263) n]\n    [(=", "  (define (find-factor\
    \ n i)\n    (if (or (= n i) (= n 1))\n        1\n        (if (zero? (modulo n\
    \ i))\n            (if (prime? i)\n                i\n                (find-factor\
    \ (/ n i) 2))\n            (find-factor n (+ i 1)))))\n  (find-factor n 2))\n",
  "  (define (is_prime? n)\n    (cond\n      [(= n 1) #f]\n      [(not (divisible?\
    \ n 2)) #t]\n      [else (not (member (lambda (x) (divisible? n x)) (range 2 (quotient\
    \ n 2))))]))\n  (define (largest-prime-factor n i)\n    (cond\n      [(not (divisible?\
    \ n i)) n]\n      [(is_prime? i) (largest-prime-factor (quotient n i) i)]\n  \
    \    [else (largest-prime-factor n (+ i 1))]))\n  (largest-prime-factor n 2))",
  "  (define (factor n)\n    (let loop ([i (floor (/ n 2))])\n      (cond\n      \
    \  [(= (remainder n i) 0) i]\n        [(<= i 1) n]\n        [else (loop (- i 1))])))\n\
    \  (if (prime? n)\n      n\n      (largest_prime_factor (factor n))))\n", "  (let\
    \ loop ([n n] [i 2])\n    (cond\n      [(= i (exact-floor (sqrt n))) n]\n    \
    \  [(zero? (modulo n i)) (loop (/ n i) i)]\n      [else (loop n (+ i 1))])))\n",
  "  (largest_prime_factor_helper n 2))\n", "  (define (largest-factor n i)\n    (if\
    \ (= n i)\n        n\n        (if (= (remainder n i) 0)\n            (largest-factor\
    \ (/ n i) i)\n            (largest-factor n (+ i 1)))))\n  (largest-factor n 2))\n",
  "  (let loop ([d (- n 1)] [f 2])\n    (cond\n      [(and (<= f n) (zero? (remainder\
    \ n f)))\n       (loop (quotient n f) f)]\n      [(and (<= f d) (zero? (remainder\
    \ d f)))\n       (loop n (+ f 1))]\n      [else f])))\n", "  (let ([f (first (prime-factors\
    \ n))])\n    (if (integer? f)\n        f\n        (apply max (prime-factors n)))))",
  "  (define (largest_prime_factor-iter primes candidates)\n    (if (number-is-factor-of?\
    \ (car primes) candidates)\n        (largest_prime_factor-iter (cdr primes)\n\
    \                                   (largest_prime_factor-helper (car primes)\
    \ candidates))\n        (largest_prime_factor-iter (cdr primes) candidates)))\n\
    \  (largest_prime_factor-iter (prime-generator) n))\n", "  (let loop ([i 2] [n\
    \ n])\n    (if (= n 1)\n        i\n        (if (zero? (modulo n i))\n        \
    \    (loop i (/ n i))\n            (loop (+ i 1) n)))))\n", "  (let* ([factors\
    \ (prime-factors n)]\n         [largest (car (reverse factors))])\n    largest))\n",
  "  (define (lst_prime_factor n i)\n    (if (= i n)\n        n\n        (if (and\
    \ (integer? (/ n i)) (integer? (/ n (+ i 2))))\n            (lst_prime_factor\
    \ n (+ i 2))\n            (lst_prime_factor n (+ i 1)))))\n  (lst_prime_factor\
    \ n 2))\n", "  (let loop ([n n] [i 2])\n    (cond [(integer? n) n]\n         \
    \ [(< n (* i i)) n]\n          [(zero? (modulo n i)) (loop (/ n i) i)]\n     \
    \     [else (loop n (+ i 1))])))\n", "  (for/fold ([max 1]) ([i (in-range 2 (exact-sqrt\
    \ n))])\n    (if (and (divides? i n) (prime? i)) (max i max) max)))\n", "  (define\
    \ (largest_prime_factor n i)\n    (cond ((= n i) n)\n          ((zero? (modulo\
    \ n i)) (largest_prime_factor (/ n i) i))\n          (else (largest_prime_factor\
    \ n (+ i 1)))))\n  (largest_prime_factor n 2))\n", "  (let loop ([i 2] [n n])\n\
    \    (cond\n      [(= n i) i]                                 ; n is a prime,\
    \ its largest factor is itself\n      [(zero? (modulo n i)) (loop (+ i 1) (/ n\
    \ i))] ; i is the largest prime factor of n, continue with the quotient.\n   \
    \   [else (loop (+ i 1) n)])))                  ; Continue with the next possible\
    \ factor.\n", "  (define (gen-factors i)\n    (cond\n      [(> i n) '()]\n   \
    \   [(integer? (/ n i)) (cons (/ n i) (cons i (gen-factors (+ i 1))))]\n     \
    \ [else (gen-factors (+ i 1))]))\n  (define (is-prime? i)\n    (cond\n      [(>\
    \ i n) #f]\n      [(integer? (/ n i)) #f]\n      [else (is-prime? (+ i 1))]))\n\
    \  (define (filter-primes ls)\n    (cond\n      [(null? ls) '()]\n      [(is-prime?\
    \ (car ls)) (cons (car ls) (filter-primes (cdr ls)))]\n      [else (filter-primes\
    \ (cdr ls))]))\n  (car (reverse (filter-primes (gen-factors 2)))))\n", "  (define\
    \ (aux k x)\n    (cond [(> x k) (aux k (/ x k))]\n          [(< x k) (list k x)]\n\
    \          [else (aux (+ k 1) x)]))\n  (let ([r (aux 2 n)])\n    (if (= (cadr\
    \ r) 1)\n        (car r)\n        (largest_prime_factor (cadr r)))))\n", "  (largest_prime_factor-helper\
    \ n 2))\n", "  (define (iter n acc)\n    (if (prime? n) n\n        (let ([factors\
    \ (prime-factors n)])\n          (iter (car factors) acc))))\n  (iter n 0))\n",
  "  (define (largest_prime_factor-iter n min-factor)\n    (cond\n      [(= n min-factor)\
    \ n]\n      [(= (remainder n min-factor) 0)\n       (largest_prime_factor-iter\
    \ (/ n min-factor) min-factor)]\n      [else (largest_prime_factor-iter n (+ min-factor\
    \ 1))]))\n  (largest_prime_factor-iter n 2))\n", "  (define (helper n k)\n   \
    \ (if (prime? n) n\n        (if (= (modulo n k) 0) (helper (/ n k) k)\n      \
    \      (helper n (+ k 1)))))\n  (helper n 2))\n", "  (define (largest_prime_factor-acc\
    \ n curr-prime)\n    (cond [(= n curr-prime) n]\n          [(zero? (modulo n curr-prime))\
    \ (largest_prime_factor-acc (/ n curr-prime) curr-prime)]\n          [else (largest_prime_factor-acc\
    \ n (+ curr-prime 1))]))\n  (largest_prime_factor-acc n 2))\n", "  (let loop ([n\
    \ n] [p 2])\n    (if (zero? (modulo n p))\n        (loop (quotient n p) p)\n \
    \       (if (> p (sqrt n))\n            n\n            (loop n (+ p 1))))))\n",
  "  (if (= n 1) 1\n      (let ([factor (first (prime-factors n))])\n        (if (>\
    \ factor n) n factor))))\n", "  (let* ((factors (factorization n))\n         (largest-factor\
    \ (car (reverse factors))))\n    (if (= largest-factor n)\n        (error 'largest_prime_factor\
    \ \"~a is a prime\" n)\n        largest-factor)))\n", "  (define (is-prime n)\n\
    \    (define (divides? a b) (= (remainder b a) 0))\n    (define (prime? n div)\n\
    \      (if (= div 2)\n          #t\n          (if (divides? div n)\n         \
    \     #f\n              (prime? n (- div 1)))))\n    (prime? n (- n 1)))\n  (define\
    \ (next-prime-factors n div)\n    (if (= n 1)\n        '()\n        (if (and (divides?\
    \ div n) (is-prime div))\n            (cons div (next-prime-factors (/ n div)\
    \ div))\n            (next-prime-factors n (+ div 1)))))\n  (car (reverse (next-prime-factors\
    \ n 2))))\n", "  (define (helper n factor)\n    (if (= 1 n)\n        factor\n\
    \        (if (prime? n)\n            n\n            (if (integer? (/ n factor))\n\
    \                (helper (/ n factor) factor)\n                (helper n (+ factor\
    \ 1))))))\n  (helper n 2))\n", "  (define (prime-factors n ps)\n    (if (prime?\
    \ n) (cons n ps)\n        (let ((p (first (divisors n))))\n          (cond ((=\
    \ n p) (cons n ps))\n                ((= 0 (modulo n p)) (prime-factors (/ n p)\
    \ (cons p ps)))\n                (else (prime-factors n (cdr ps)))))))\n  (first\
    \ (prime-factors n (divisors n))))\n", "  (largest_prime_factor-worker n 2))\n",
  "  (define (factors p n)\n    (cond\n      [(= (remainder n p) 0)\n       (if (=\
    \ n p)\n           (list p)\n           (cons p (factors p (/ n p))))]\n     \
    \ [else (factors (+ p 1) n)]))\n  (first (sort (factors 2 n) >)))\n", "  (define\
    \ (next-prime n)\n    (cond ((is-prime n) n)\n          (else (next-prime (+ n\
    \ 1)))))\n  (define (next-factor n)\n    (cond ((remainder n 2) (+ n 1))\n   \
    \       (else (+ n 2))))\n  (define (largest_prime_factor-iter n prime)\n    (cond\
    \ ((= (remainder n prime) 0)\n           (largest_prime_factor-iter (/ n prime)\
    \ prime))\n          ((= n 1) prime)\n          (else (largest_prime_factor-iter\
    \ n (next-prime (next-factor prime))))))\n  (largest_prime_factor-iter n (next-prime\
    \ 2)))\n", "  (define (first-factor n m)\n    (if (= 0 (modulo n m))\n       \
    \ m\n        (first-factor n (+ m 1))))\n  (define (loop n)\n    (let ((f (first-factor\
    \ n 2)))\n      (if (= f n)\n          n\n          (loop (/ n f)))))\n  (loop\
    \ n))\n", "  (define (largest_prime_factor_iter n d)\n    (if (= n d)\n      \
    \  n\n        (if (zero? (modulo n d))\n            (largest_prime_factor_iter\
    \ (/ n d) d)\n            (largest_prime_factor_iter n (+ d 1)))))\n  (largest_prime_factor_iter\
    \ n 2))\n", "  (let loop ([n n] [f 2])\n    (cond [(= n f) f]\n          [(divides?\
    \ f n) (loop (/ n f) f)]\n          [else (loop n (+ f 1))])))\n", "  (let* ([n\
    \ n]\n         [factor 2]\n         [largest-prime-factor n])\n    (do* ([n (quotient\
    \ n factor) (quotient n factor)]\n          [factor (next-prime factor) (next-prime\
    \ factor)])\n        ([= n 1]\n         largest-prime-factor))))\n", "  (let*\
    \ ([max-factor (floor (sqrt n))]\n         [factors (filter (curryr / n) (range\
    \ 2 max-factor))])\n    (find (compose prime? car) (map (curryr list factors)\
    \ factors))))\n", "  (define (even? n) (= (remainder n 2) 0))\n  (define (next-factor\
    \ k)\n    (if (= (remainder n k) 0)\n        k\n        (next-factor (+ k 1))))\n\
    \  (define (lpf n k)\n    (cond ((= n k) k)\n          ((even? n) (lpf (/ n 2)\
    \ 2))\n          (else (lpf (/ n k) (next-factor (+ k 1))))))\n  (lpf n 2))\n",
  "  (define (largest_prime_factor-helper n div)\n    (cond [(= n div) n]\n      \
    \    [(= (remainder n div) 0) (largest_prime_factor-helper (/ n div) div)]\n \
    \         [else (largest_prime_factor-helper n (+ div 1))]))\n  (largest_prime_factor-helper\
    \ n 2))\n", "  (define (factorize n)\n    (define (div-f n i)\n      (if (and\
    \ (not (zero? (remainder n i))) (<= i (sqrt n)))\n          (cons i (factorize\
    \ (/ n i)))\n          (factorize n (+ i 1))))\n    (div-f n 2))\n  (define (max-prime-factor\
    \ fs)\n    (if (and (null? (cdr fs)) (null? (member (car fs) fs)))\n        (car\
    \ fs)\n        (max-prime-factor (cdr fs))))\n  (max-prime-factor (factorize n)))\n",
  "  (define (divisible? a b)\n    (= (remainder a b) 0))\n  (define (find-divisor\
    \ n test-divisor)\n    (cond ((> (square test-divisor) n) n)\n          ((divisible?\
    \ n test-divisor) test-divisor)\n          (else (find-divisor n (+ test-divisor\
    \ 1)))))\n  (define (largest-prime-factor n test-divisor)\n    (if (= test-divisor\
    \ n)\n        n\n        (largest-prime-factor (/ n test-divisor)\n          \
    \                    (find-divisor (/ n test-divisor) test-divisor))))\n  (largest-prime-factor\
    \ n 2))\n", "  (define (largest_prime_factor-acc n acc)\n    (if (is-prime? n)\n\
    \        n\n        (let ((next-acc (next-factor acc)))\n          (if (factor?\
    \ n next-acc)\n              (largest_prime_factor-acc (/ n next-acc) next-acc)\n\
    \              (largest_prime_factor-acc n (next-factor next-acc))))))\n  (largest_prime_factor-acc\
    \ n 2))\n", "  (define (prime? n)\n    (cond\n      [(< n 2) false]\n      [(=\
    \ n 2) true]\n      [(= (remainder n 2) 0) false]\n      [else\n       (for/and\
    \ ([i (in-range 3 n 2)])\n         (< (expt i 2) n))]))\n  (define (prime-factor?\
    \ n i)\n    (and (prime? i) (= (remainder n i) 0)))\n  (define (largest-prime-factor\
    \ n i)\n    (cond\n      [(> i n) #f]\n      [(prime-factor? n i) (largest-prime-factor\
    \ n (+ i 1))]\n      [else i]))\n  (define (lpf n)\n    (largest-prime-factor\
    \ n 3))\n  (lpf n))\n```\n\n```racket\n#lang racket\n", "  (define (f g n r)\n\
    \    (cond [(= 0 (modulo n g)) (f g (/ n g) r)]\n          [(< (* g g) n) (f (+\
    \ g 1) n g)]\n          [else r]))\n  (f 2 n 2))\n", "  (define (largest_prime_factor-iter\
    \ n i)\n    (if (zero? (modulo n i))\n        (if (prime? i)\n            i\n\
    \            (largest_prime_factor-iter (quotient n i) i))\n        (largest_prime_factor-iter\
    \ n (+ i 1))))\n  (if (prime? n)\n      n\n      (largest_prime_factor-iter n\
    \ 2)))\n", "  (largest_prime_factor-internal n 2))\n", "  (let loop ([x 2] [n\
    \ n])\n    (if (prime? x)\n        (if (exact-integer-sqrt? n)\n            x\n\
    \            (loop (add1 x) n))\n        (loop (add1 x) n))))\n", "  (define (largest_prime_factor-iter\
    \ curr-factor n)\n    (if (= n 1)\n        1\n        (if (or (= (remainder n\
    \ curr-factor) 0)\n                (= curr-factor (sqrt n)))\n            curr-factor\n\
    \            (largest_prime_factor-iter (+ curr-factor 1) n))))\n  (largest_prime_factor-iter\
    \ 2 n))\n", "  (define (divisible? n m)\n    (= (remainder n m) 0))\n  (define\
    \ (is_prime? n)\n    (letrec ((check (lambda (i)\n                     (if (>\
    \ i n)\n                         #t\n                         (if (divisible?\
    \ n i)\n                             #f\n                             (check (+\
    \ i 1)))))))\n      (check 2)))\n  (define (largest-prime-factor n i)\n    (if\
    \ (> i n)\n        1\n        (if (and (divisible? n i) (is_prime? i))\n     \
    \       i\n            (largest-prime-factor n (+ i 1)))))\n  (largest-prime-factor\
    \ n 2))", "  (define (prime? n)\n    (define (iter m)\n      (if (> (* m m) n)\
    \ #t\n        (if (zero? (modulo n m)) #f\n          (iter (+ m 1)))))\n    (iter\
    \ 2))\n  (define (largest-prime-factor n)\n    (define (iter i)\n      (if (>\
    \ i n) n\n        (if (and (prime? i) (zero? (modulo n i))) i\n          (iter\
    \ (+ i 1)))))\n    (iter 2))\n  (largest-prime-factor n))\n```\n\n```racket\n\
    #lang racket\n", "  (largest_prime_factor-helper 2 n))\n", "  (largest_prime_factor-iter\
    \ n 2))\n", "  (let loop ([divisor (quotient n 2)]\n             [largest-factor\
    \ n])\n    (if (= (remainder n divisor) 0)\n        (loop (quotient divisor 2)\
    \ divisor)\n        (if (= divisor 1)\n            largest-factor\n          \
    \  (loop (sub1 divisor) largest-factor)))))\n", "  (define (is-prime n)\n    (define\
    \ (iter i)\n      (if (< (* i i) n)\n          (if (zero? (modulo n i))\n    \
    \          #f\n              (iter (+ i 1)))\n          #t))\n    (iter 2))\n\
    \  (define (iter i)\n    (if (and (not (is-prime n))\n             (not (zero?\
    \ (modulo n i))))\n        (iter (+ i 1))\n        i))\n  (iter 2))\n", "  (define\
    \ (largest-prime-helper n current-largest)\n    (cond [(= 1 n) current-largest]\n\
    \          [(divisible? n current-largest)\n           (largest-prime-helper (div\
    \ n current-largest) current-largest)]\n          [else (largest-prime-helper\
    \ n (+ current-largest 1))]))\n  (largest-prime-helper n 2))\n", "  (define (next-prime\
    \ p)\n    (cond\n      [(prime? (+ p 1)) (+ p 1)]\n      [else (next-prime (+\
    \ p 1))]))\n  (define (prime? n)\n    (define (even? n)\n      (= (remainder n\
    \ 2) 0))\n    (cond\n      [(< n 2) #f]\n      [(= n 2) #t]\n      [(even? n)\
    \ #f]\n      [else\n       (let loop ([d 3])\n         (cond\n           [(> (*\
    \ d d) n) #t]\n           [(zero? (remainder n d)) #f]\n           [else (loop\
    \ (+ d 2))]))]))\n  (define (prime-factor-of? p n)\n    (zero? (remainder n p)))\n\
    \  (define (find-largest-prime-factor n p)\n    (cond\n      [(prime-factor-of?\
    \ p n) p]\n      [else (find-largest-prime-factor n (next-prime p))]))\n  (find-largest-prime-factor\
    \ n 2))\n```\n\n### \uBD84\uC218\uB4E4\uC758 \uD569\n\uC591\uC758 \uC815\uC218\
    \ n\uC5D0 \uB300\uD574\uC11C, \uB2E4\uC74C\uACFC \uAC19\uC740 \uACC4\uC0B0 \uACFC\
    \uC815\uC744 \uBC18\uBCF5\uD558\uAE30\uB85C \uD569\uB2C8\uB2E4.\n\nn \u2192 n\
    \ / 2 (n\uC774 \uC9DD\uC218\uC77C \uB54C)\nn \u2192 3 n + 1 (n\uC774 \uD640\uC218\
    \uC77C \uB54C)\n\n13\uC5D0 \uB300\uD558\uC5EC \uC704\uC758 \uADDC\uCE59\uC744\
    \ \uC801\uC6A9\uD574\uBCF4\uBA74 \uC544\uB798\uCC98\uB7FC 10\uBC88\uC758 \uACFC\
    \uC815\uC744 \uD1B5\uD574 1\uC774 \uB429\uB2C8\uB2E4.\n\n13 \u2192 40 \u2192 20\
    \ \u2192 10 \u2192 5 \u2192 16 \u2192 8 \u2192 4 \u2192 2 \u2192 1\n\uC544", " \
    \ (let prime-factors ((n n) (p 2) (ps '()))\n    (if (or (zero? (modulo n p))\n\
    \            (prime? p))\n        (if (zero? (modulo n p))\n            (prime-factors\
    \ (quotient n p) p (cons p ps))\n            (prime-factors n (+ p 1) ps))\n \
    \       (prime-factors n (+ p 1) ps))))\n", "  (define (prime? n)\n    (define\
    \ (divisible? n x)\n      (= (modulo n x) 0))\n    (cond ((< n 2) #f)\n      \
    \    ((< n 4) #t)\n          ((< (modulo n 2) 1) #f)\n          ((< (modulo n\
    \ 3) 1) #f)\n          ((< (modulo n 5) 1) #f)\n          ((< (modulo n 7) 1)\
    \ #f)\n          (else (not (any divisible? (build-list 11 (lambda (x) (+ x 2))))))))\n\
    \  (define (factor? n k)\n    (= (modulo n k) 0))\n  (if (prime? n)\n      n\n\
    \      (largest-factor n n 2)))", "  (cond [(prime? n) n]\n        [else (largest_prime_factor\
    \ (prime-factor n))]))\n", "  (define (largest_prime_factor-iter n pf)\n    (cond\n\
    \      [(prime? n) n]\n      [(> pf n) n]\n      [(divides? pf n) (largest_prime_factor-iter\
    \ (/ n pf) pf)]\n      [else (largest_prime_factor-iter n (+ pf 1))]))\n  (if\
    \ (prime? n) n (largest_prime_factor-iter n 2)))\n", "  (define (largest_prime_factor-internal\
    \ n factor)\n    (if (= factor n)\n        n\n        (if (integer? (/ n factor))\n\
    \            (largest_prime_factor-internal (/ n factor) factor)\n           \
    \ (largest_prime_factor-internal n (+ factor 1)))))\n  (largest_prime_factor-internal\
    \ n 2))\n", "  (let loop ([factor 2] [n n])\n    (cond [(= n 1) factor]\n    \
    \      [(= (modulo n factor) 0) (loop factor (/ n factor))]\n          [else (loop\
    \ (+ factor 1) n)])))\n", "  (define (first-divisor n)\n    (define (iter i)\n\
    \      (if (= (remainder n i) 0)\n          i\n          (iter (+ i 1))))\n  \
    \  (iter 2))\n  (define (prime-factors n)\n    (if (= (remainder n (first-divisor\
    \ n)) 0)\n        (cons (first-divisor n) (prime-factors (/ n (first-divisor n))))\n\
    \        (list n)))\n  (last (prime-factors n)))\n", "  (define (sieve n)\n  \
    \  (define (iter primes divisor)\n      (cond\n        [(= 0 (modulo n divisor))\
    \ (sieve (/ n divisor))]\n        [(not (= 0 (modulo n (+ 1 divisor)))) (iter\
    \ primes (+ 2 divisor))]\n        [else (iter (cons n primes) (+ 2 divisor))]))\n\
    \    (iter (list) 2))\n  (define (iter primes)\n    (cond\n      [(empty? primes)\
    \ (error \"Exhausted sieve.\")]\n      [(= n (first primes)) (first primes)]\n\
    \      [else (iter (rest primes))]))\n  (iter (sieve n)))\n", "  (define (divisible?\
    \ a b)\n    (= (remainder a b) 0))\n  (define (find-factor n divisor)\n    (cond\
    \ ((> (sqrt n) divisor)\n           n)\n          ((divisible? n divisor)\n  \
    \         (find-factor (/ n divisor) divisor))\n          (else\n           (find-factor\
    \ n (+ divisor 1)))))\n  (find-factor n 2))\n", "  (define (largest-prime-factor-iter\
    \ n i)\n    (if (&lt; n (* i i))\n        n\n        (if (integer? (/ n i))\n\
    \            (largest-prime-factor-iter (/ n i) i)\n            (largest-prime-factor-iter\
    \ n (+ i 1)))))\n  (largest-prime-factor-iter n 2))\n", "  (define (recurse factors\
    \ n)\n    (if (empty? factors)\n        ;; All factors have been tried, so n is\
    \ prime\n        n\n        (let ([factor (first factors)])\n          (if (zero?\
    \ (modulo n factor))\n              ;; Factor divides n, so find the largest prime\
    \ factor of n/factor\n              (recurse (filter (lambda (x) (not (zero? (modulo\
    \ x factor)))) factors) (quotient n factor))\n              ;; Factor does not\
    \ divide n, so move to the next factor\n              (recurse (rest factors)\
    \ n)))))\n  (recurse (filter (lambda (x) (not (zero? (modulo n x)))) (range 2\
    \ n)) n))\n", "  (if (prime? n)\n      n\n      (largest_prime_factor (find-largest-prime-factor\
    \ n))))\n", "  (define (multp n a)\n    (zero? (modulo n a)))\n  (define (divides?\
    \ n a)\n    (multp n a))\n  (define (prime? n)\n    (cond\n      ((divides? n\
    \ 2) #f)\n      ((= n 2) #t)\n      ((divides? n 3) #f)\n      ((= n 3) #t)\n\
    \      ((divides? n 5) #f)\n      ((= n 5) #t)\n      ((divides? n 7) #f)\n  \
    \    ((= n 7) #t)\n      (else (or (divides? n 2)\n                (divides? n\
    \ 3)\n                (divides? n 5)\n                (divides? n 7)))))\n  (define\
    \ (find-max-prime n max)\n    (cond\n      ((and (prime? n)\n            (> n\
    \ max))\n       n)\n      ((= n max)\n       max)\n      (else\n       (find-max-prime\
    \ (+ n 1) max))))\n  (find-max-prime 2 n))", "  (define (prime? n)\n    (letrec\
    \ ([factors (\u03BB(n)\n                        (cond\n                      \
    \    [(= n 1) empty]\n                          [(= (remainder n x) 0) (cons x\
    \ (factors (/ n x)))]\n                          [else (factors n)]))])\n    \
    \  (if (null? (factors n))\n          #t\n          #f)))\n  (define (lpf n i)\n\
    \    (cond\n      [(> i (/ n 2)) n]\n      [(and (>= i 2) (= (remainder n i) 0)\
    \ (prime? i)) (lpf n (+ i 1))]\n      [else (lpf n (+ i 1))]))\n  (lpf n 2))\n",
  "  (let ((factors (filter prime? (factor n))))\n    (car (reverse factors))))\n",
  "  (define (run n k)\n    (cond\n      [(= n 1) k]\n      [(divides? n k) (run (/\
    \ n k) k)]\n      [else (run n (+ k 1))]))\n  (run n 2))\n", "  (largest_prime_factor_iter\
    \ n 2))\n", "  (let loop ([f (car (prime-factors n))])\n    (if (and (integer?\
    \ (/ n f)) (= (gcd n f) f))\n        f\n        (loop (car (prime-factors f))))))\n",
  "  (cond\n    [(integer? n) (largest_prime_factor_helper n 2)]\n    [else (error\
    \ 'largest_prime_factor \"expected integer\")]))\n", "  (largest_prime_factor_acc\
    \ n 2))\n", "  (define (factor x n)\n    (cond ((= n 1) #f)\n          ((even?\
    \ n) (factor x (/ n 2)))\n          ((divisible? n x) (factor (+ x 1) (/ n x)))\n\
    \          (else (factor (+ x 1) n))))\n  (factor 2 n))\n", "  (define (helper\
    \ n i)\n    (if (even? n)\n        (helper (/ n 2) 2)\n        (if (prime? i)\n\
    \            (if (divides? i n)\n                (if (eq? i n)\n             \
    \       i\n                    (helper (/ n i) i))\n                (helper n\
    \ (+ i 1)))\n            (helper n (+ i 1)))))\n  (helper n 2))\n", "  (define\
    \ (prime? n)\n    (if (= n 1) #f\n        (define (divisible? a n)\n         \
    \ (= (remainder a n) 0))\n      (not (any divisible? (list-range 2 (exact-floor\
    \ (sqrt n))) n))))\n  (define (divisors n)\n    (cond [(< n 2) empty]\n      \
    \    [(= n 2) empty]\n          [(prime? n) empty]\n          [else (cons (divisor\
    \ n) (divisors (quotient n (divisor n))))]))\n  (define (divisor n)\n    (list-ref\
    \ (list-filter prime? (list-range 2 n)) 0))\n  (last (divisors n)))\n", "  (define\
    \ (divisors r)\n    (define (accum a i)\n      (if (= 0 (modulo a i))\n      \
    \    (cons i (accum (/ a i) i))\n          (if (< i (/ a 2))\n              (accum\
    \ a (+ i 1))\n              (list a))))\n    (accum r 2))\n  (last (divisors n)))\n\
    ```\n\n## Problem 5 - Smallest multiple\n\n> 2520 is the smallest number that\
    \ can be divided by each of the numbers from 1 to 10 without any remainder.\n\
    >\n> What is the smallest positive number that is evenly divisible by all of the\
    \ numbers from 1 to 20?\n\n```racket\n#lang racket\n", "  (let loop ([i n] [l\
    \ (list n)])\n    (if (= 1 (modulo n i))\n        (if (prime? i)\n           \
    \ i\n            (loop i (filter (lambda (x) (not (prime? x))) l)))\n        (loop\
    \ (sub1 i) l))))\n", "  (let loop ([i 2] [n n])\n    (if (= i n)\n        n\n\
    \        (if (zero? (modulo n i))\n            (loop i (quotient n i))\n     \
    \       (loop (add1 i) n)))))\n", "  (let loop ([n n] [factor 2])\n    (cond [(=\
    \ n factor) factor]\n          [(zero? (modulo n factor)) (loop (/ n factor) factor)]\n\
    \          [else (loop n (+ factor 1))])))\n", "  (define (prime-factors n)\n\
    \    (define (next-prime n)\n      (if (prime? n)\n          n\n          (next-prime\
    \ (+ n 1))))\n    (if (prime? n)\n        (list n)\n        (let ((next (next-prime\
    \ 2)))\n          (if (even? n)\n              (cons 2 (prime-factors (/ n 2)))\n\
    \              (if (= (modulo n next) 0)\n                  (cons next (prime-factors\
    \ (/ n next)))\n                  (prime-factors n))))))\n  (car (sort (prime-factors\
    \ n) >)))\n", "  (define (largest-prime-factor n i)\n    (if (> n (* i i))\n \
    \       (if (zero? (modulo n i))\n            (largest-prime-factor (/ n i) i)\n\
    \            (largest-prime-factor n (+ i 1)))\n        n))\n  (largest-prime-factor\
    \ n 2))\n", "  (define (prime? n)\n    (define (divisible? n x)\n      (= (modulo\
    \ n x) 0))\n    (define (loop n x)\n      (if (> x n)\n          #t\n        \
    \  (if (divisible? n x)\n              #f\n              (loop n (+ x 1)))))\n\
    \    (loop n 2))\n  (define (factors n)\n    (define (loop n x)\n      (if (>\
    \ n x)\n          (list)\n          (if (divisible? n x)\n              (cons\
    \ x (loop n (+ x 1)))\n              (loop n (+ x 1)))))\n    (loop n 2))\n  (define\
    \ (prime-factors n)\n    (define (loop lst)\n      (if (null? lst)\n         \
    \ (list)\n          (if (prime? (car lst))\n              (cons (car lst) (loop\
    \ (cdr lst)))\n              (loop (cdr lst)))))\n    (loop (factors n)))\n  (apply\
    \ max (prime-factors n)))", "  (define (lpf_iter m factors)\n    (cond\n     \
    \ [(eq? 1 m) (last factors)]\n      [(even? m) (lpf_iter (/ m 2) (cons 2 factors))]\n\
    \      [(prime? m) (lpf_iter 1 (cons m factors))]\n      [else (lpf_iter (reduce\
    \ (lambda (x y) (if (divides? y m) y x)) factors))]))\n  (lpf_iter n (iota 2 n)))\n",
  "  (define (max-prime i n)\n    (cond ((&gt; i n) i)\n          ((and (zero? (modulo\
    \ n i)) (is-prime i)) (max-prime (+ i 1) n))\n          (else (max-prime (+ i\
    \ 1) n))))\n  (max-prime 2 n))\n", "  (define (largest-prime-factor n d)\n   \
    \ (if (= n 1)\n        d\n        (if (even? n)\n            (largest-prime-factor\
    \ (/ n 2) 2)\n            (if (integer? (/ n d))\n                (largest-prime-factor\
    \ (/ n d) d)\n                (largest-prime-factor n (+ d 1))))))\n  (largest-prime-factor\
    \ n 2))\n```\n\n## Sum of square of digits\n\n```racket\n#lang racket\n", "  (largest_prime_factor_helper\
    \ n 2))\n", "  (define (largest-prime-factor-iter n trial)\n    (cond\n      [(even?\
    \ n) (largest-prime-factor-iter (/ n 2) 2)]\n      [(= n 1) trial]\n      [(divides?\
    \ trial n) (largest-prime-factor-iter (/ n trial) trial)]\n      [else (largest-prime-factor-iter\
    \ n (+ trial 1))]))\n  (largest-prime-factor-iter n 2))\n", "  (largest_prime_factor/helper\
    \ n (largest_prime_factor/primes n)))\n", "  (largest_prime_factor_iter n 2))\n",
  "  (cond\n    ((integer? n) (largest_prime_factor_iter 2 n))\n    (else (error \"\
    Don't know how to find largest prime factor of ~s\" n))))\n", "  (define (largest-prime-factor-helper\
    \ n candidate factor)\n    (if (= 1 candidate)\n        ;; 1 is not a prime number.\n\
    \        factor\n        (if (integer? (/ n candidate))\n            (largest-prime-factor-helper\
    \ (/ n candidate) (+ candidate 1) candidate)\n            (largest-prime-factor-helper\
    \ n (+ candidate 1) factor))))\n  (largest-prime-factor-helper n 2 2))\n", " \
    \ (define (divisible x y) (= (remainder x y) 0))\n  (define (next-prime-divisor\
    \ x)\n    (let* ([i (add1 x)]\n           [found (for/or ([p (in-range i (add1\
    \ n))])\n                      (divisible n p))])\n      (if found i\n       \
    \   (next-prime-divisor i))))\n  (let* ([root (inexact->exact (sqrt n))]\n   \
    \      [first-prime-divisor (next-prime-divisor 2)])\n    (if (divisible n first-prime-divisor)\n\
    \        (if (< first-prime-divisor root)\n            (largest_prime_factor (quotient\
    \ n first-prime-divisor))\n            first-prime-divisor)\n        (error \"\
    AssertionError: N is prime!\"))))", "  (for/first ([i (in-range 2 (sqrt n))]\n\
    \              #:when (zero? (remainder n i))\n              #:when (prime? i))\n\
    \    i))\n", "  (do ([i (next-prime 2) (next-prime i)])\n      ((> n i) i)))\n",
  "  (cond\n    [(prime? n) n]\n    [else\n     (define lower-primes (filter prime?\
    \ (drop-right (range n) 1)))\n     (largest-divisor n lower-primes)]))\n", " \
    \ (largest_prime_factor-acc n 2))\n", "  (local [(define (factor n)\n        \
    \    (let loop [(i 2)]\n              (cond [(or (= n i) (= n 1)) '()]\n     \
    \               [(integer? (/ n i)) (cons i (loop (+ i 1)))]\n               \
    \     [else (loop (+ i 1))])))\n          (define (prime? n)\n            (empty?\
    \ (factor n)))]\n    (let loop [(xs (factor n))]\n      (cond [(empty? xs) 0]\n\
    \            [(prime? (first xs)) (first xs)]\n            [else (loop (rest xs))]))))\n",
  "  (if (prime? n)\n      n\n      (let loop ([prime 2] [n n])\n        (if (= (remainder\
    \ n prime) 0)\n            (loop prime (/ n prime))\n            (loop (+ prime\
    \ 1) n)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
