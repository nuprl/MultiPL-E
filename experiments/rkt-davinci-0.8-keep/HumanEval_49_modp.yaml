name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n;; >>> modp(3,\
  \ 5)\n;; 3\n;; >>> modp(1101, 101)\n;; 2\n;; >>> modp(0, 101)\n;; 1\n;; >>> modp(3,\
  \ 11)\n;; 8\n;; >>> modp(100, 101)\n;; 1\n(define (modp n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (define (mod2 n)\n    (if (even? n)\n        (define (mod2h n)\n\
    \          (if (even? n)\n              (mod2h (quotient n 2))\n             \
    \ n))\n        (lambda () (mod2h (quotient (n-1) 2)))))\n  (mod2 n))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(even? n) (modulo (modp (/ n 2) p) p)]\n    [else (modulo\
    \ (* (modp (- n 1) p) 2) p)]))\n", "  (define (modp-iter n p pwr)\n    (cond ((=\
    \ n 0) pwr)\n          ((even? n) (modp-iter (/ n 2) p (* pwr pwr) p))\n     \
    \     (else (modp-iter (- n 1) p (* pwr p) p))))\n  (modp-iter n p 1 p))\n", " \
    \ (let ((x 0)\n        (y 1)\n        (pow 2))\n    (if (= n 0)\n        1\n \
    \       (begin\n          (while (<= pow n)\n            (set! pow (* pow 2))\n\
    \            (set! x (modulo (+ x y) p))\n            (set! y (modulo (* 2 y)\
    \ p)))\n          x))))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n   \
    \       (modulo (modp (/ n 2) p) (expt 2 (quotient n 2)) p)\n          (modulo\
    \ (* (modp (- n 1) p) 2) p))))\n", "  (cond\n    [(zero? n) 1]\n    [(zero? (remainder\
    \ n 2))\n     (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\n \
    \    (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) 2) p)]))\n", "  (modulo (expt\
    \ 2 n) p))\n", "  (let ([a (modulo (expt 2 n) p)])\n    (cond [(= a p) 1]\n  \
    \        [else a])))\n\n", "  (cond\n    [(= n 0) 1]\n    [(= n 1) 2]\n    [(=\
    \ (remainder n 2) 0)\n     (define (mod-helper k)\n       (if (= k 0) 1 (remainder\
    \ (* 4 (mod-helper (- k 1))) p)))\n     (mod-helper (/ n 2))]\n    [else (remainder\
    \ (* 2 (modp (- n 1) p)) p)]))\n", "  (define (modp-iter exp t)\n    (cond ((=\
    \ 0 exp) t)\n          ((even? exp) (modp-iter (/ exp 2) (* t t p)))\n       \
    \   (else (modp-iter (- exp 1) (* t n p)))))\n  (modp-iter n 1))\n", "  (define\
    \ (modp* x)\n    (if (even? x)\n        (modp* (quotient x 2))\n        (if (=\
    \ 1 x)\n            1\n            (modulo (* n (modp* (quotient x 2))) p))))\n\
    \  (modp* n))\n", "  (let loop ([n n] [p p] [acc 1])\n    (cond\n      [(= n 0)\
    \ acc]\n      [(even? n) (loop (/ n 2) p (modulo (* acc acc) p))]\n      [else\
    \ (loop (- n 1) p (modulo (* acc p) p))])))\n", "  (let loop ([b 1] [n n])\n \
    \   (cond [(zero? n) b]\n          [(zero? (remainder n 2)) (loop (remainder (*\
    \ b b) p) (quotient n 2))]\n          [else (loop (remainder (* b 2) p) (sub1\
    \ n))])))\n", "  (cond\n    [(< n 0) (- p (modp (- n) p))]\n    [(= n 0) 1]\n\
    \    [(<= n p) (modulo n p)]\n    [else (modulo (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p)) p)]))\n", "  (define (mul-mod a b)\n    (let ((c (modulo (* a b) p)))\n\
    \      (cond\n        [(= c 0) 0]\n        [else (modulo c p)])))\n  (define (exp\
    \ a b)\n    (cond\n      [(= b 0) 1]\n      [(odd? b) (mul-mod a (exp a (- b 1)))]\n\
    \      [else (exp (mul-mod a a) (/ b 2))]))\n  (exp 2 n))\n```\n\n## Problem 243\n\
    \n[Resilience](https://projecteuler.net/problem=243)\n\n```racket\n#lang racket\n",
  "  (define base 2)\n  (define x 1)\n  (define b (integer->binary n))\n  (for ([i\
    \ (in-range (sub1 (list-length b))) (sub1 -1)])\n    (when (list-ref b i)\n  \
    \    (set! x (+ (* x base) (modulo x p))\n            x (modulo x p))))\n  x)\n",
  "  (if (= n 0)\n      1\n      (let ([n (modulo n p)])\n        (let ([n2 (modulo\
    \ (* n n) p)])\n          (letrec ([even? (lambda (n) (= (modulo n 2) 0))])\n\
    \            (letrec ([evens (lambda (n)\n                              (if (even?\
    \ n)\n                                  (cons n (evens (quotient n 2)))\n    \
    \                              '()))])\n              (let ([evens (evens n)])\n\
    \                (let ([odds (remove even? (list->vector (range 0 n)))]\n    \
    \                  [odds (vector->list odds)])\n                  (letrec ([odds\
    \ (lambda (n)\n                                  (if (even? n)\n             \
    \                         (cons 1 (odds (quotient n 2)))\n                   \
    \                   (cons 0 (odds (quotient n 2)))))])\n                    (letrec\
    \ ([reduce (lambda (nums x)\n                                       (if (empty?\
    \ nums)\n                                           1\n                      \
    \                     (let ([num (first nums)])\n                            \
    \                 (if (= num 0)\n                                            \
    \     (reduce (rest nums) x)\n                                               \
    \  (if (= num 1)\n                                                     (modulo\
    \ (* x (reduce (rest nums) x)) p)\n                                          \
    \           (modulo (* (reduce (rest nums) x) (expt x (- num 1))) p))))))])\n\
    \                      (let ([total (reduce (odds n) n2)])\n                 \
    \       (if (not (empty? evens))\n                            (modulo (* total\
    \ (reduce evens n2)) p)\n                            total))))))))))))))\n", " \
    \ (if (zero? n)\n      1\n      (modulo (* 2 (modp (sub1 n) p)) p)))\n", "  (cond\
    \ [(= n 0) 1]\n        [(= n 1) 2]\n        [(= n 2) 4]\n        [(= n 3) 8]\n\
    \        [(= n 4) 16]\n        [(= n 5) 32]\n        [(= n 6) 64]\n        [(=\
    \ n 7) 128]\n        [(= n 8) 256]\n        [(= n 9) 512]\n        [(= n 10) 1024]\n\
    \        [(= n 11) 2048]\n        [(= n 12) 4096]\n        [(= n 13) 8192]\n \
    \       [(= n 14) 16384]\n        [(= n 15) 32768]\n        [(= n 16) 65536]\n\
    \        [(= n 17) 131072]\n        [(= n 18) 262144]\n        [(= n 19) 524288]\n\
    \        [(= n 20) 1048576]\n        [(= n 21) 2097152]\n        [(= n 22) 4194304]\n\
    \        [(= n 23) 8388608]\n        [(= n 24) 16777216]\n        [(= n 25) 33554432]\n\
    \        [(= n 26) 67108864]\n        [(= n 27) 134217728]\n        [(= n 28)\
    \ 268435456]\n        [(= n 29) 536870912]\n        [(= n 30) 1073741824]\n  \
    \      [(= n 31) 2147483648]\n        [(= n 32) 4294967296]\n        [(= n 33)\
    \ 8589934592]\n        [(= n 34) 17179869184]\n        [(= n 35) 34359738368]\n\
    \        [(= n 36) 68719476736]\n        [(= n 37) 137438953472]\n        [(=\
    \ n 38) 274877906944]\n        [(= n 39) 549755813888]\n        [(= n 40) 1099511627776]\n\
    \        [(= n 41) 2199023255552]\n        [(= n 42) 4398046511104]\n        [(=\
    \ n 43) 8796093022208]\n        [(= n 44) 17592186044416]\n        [(=", "  (if\
    \ (zero? n)\n      1\n      (if (even? n)\n          (modulo (square (modp (quotient\
    \ n 2) p)) p)\n          (modulo (* (modp (quotient n 2) p)\n                \
    \     (modp (quotient (- n 1) 2) p))\n                 p))))\n", "  (if (= n 0)\n\
    \      1\n      (remainder (* 2 (modp (- n 1) p)) p)))\n", "  (define x 1)\n \
    \ (define (square x) (* x x))\n  (cond ((= n 0) x)\n        ((even? n) (modp (/\
    \ n 2) p))\n        (else (modp (- n 1) p))))\n", "  (cond [(= n 0) 1]\n     \
    \   [(even? n) (square (modp (/ n 2) p))]\n        [else (* n (modp (- n 1) p))]))\n\
    ```\n\n``` #lang racket", "  (cond ((= n 0) 1)\n        ((even? n) (remainder\
    \ (square (modp (/ n 2) p)) p))\n        (else (remainder (* (modp (- n 1) p)\
    \ n) p))))\n", "  (modulo (expt 2 n) p))\n", "  (cond\n    [(= n 0) 1]\n    [(even?\
    \ n) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* 2\
    \ (modp (- n 1) p)) p)]))\n", "  (if (= n 0)\n      1\n      (let ([x (modp (quotient\
    \ n 2) p)])\n        (if (zero? (remainder n 2))\n            (modulo (* x x)\
    \ p)\n            (modulo (* p x x) p)))))\n```\n\n## Example usage in Racket\n\
    \n```racket\n#lang racket\n", "  (if (= 0 n)\n      1\n      (* (modp (truncate\
    \ (/ n 2)) p)\n         (if (= 1 (remainder n 2))\n             (if (= 1 (remainder\
    \ p 4))\n                 p\n                 (- p 1))\n             1))))\n",
  "  (let loop ([n n] [p p] [x 2])\n    (cond\n      [(and (integer? n) (integer?\
    \ p)\n            (and (<= 1 n) (<= 1 p))\n            (<= n (expt 2 (sub1 (integer-length\
    \ p)))))\n       (modulo x p)]\n      [(zero? n) 1]\n      [(odd? n) (modulo (*\
    \ x (loop (quotient n 2) p x)) p)]\n      [else (loop (quotient n 2) p (modulo\
    \ (* x x) p))])))\n", "  (define (modp-iter a n)\n    (cond\n      [(= n 0) 1]\n\
    \      [(zero? (modulo n 2)) (modp-iter (modulo (* a a) p) (/ n 2))]\n      [else\
    \ (modulo (* a (modp-iter (modulo (* a a) p) (/ (- n 1) 2))) p)]))\n  (modp-iter\
    \ 1 n))\n", "  (cond [(= n 0) 1]\n        [(even? n) (modulo (square (modp (/\
    \ n 2) p)) p)]\n        [else (modulo (* (modp (- n 1) p) n) p)]))\n```\n\n###\
    \ Cyclotomic polynomials\n\n> Let \\phi_n(x) be the n-th cyclotomic polynomial;\
    \ this is the minimal\n> polynomial of the n-th root of unity and is given by\
    \ the formula:\n>\n> \\phi_n(x) = \\prod_{k=1}^{n-1} (x - \\omega^k)\n>\n> where\
    \ \\omega is a primitive n-th root of unity.  The degree of\n> \\phi_n(x) is \\\
    phi(n) = \\sum_{d|n} \\mu(d) n/d. \n\nWe can write a function that computes cyclotomic\
    \ polynomials directly\nfrom the definition given above.  However, it's more efficient\
    \ to\ncompute \\phi_n(x) recursively by the formula\n\n\\phi_n(x) = x^n - 1 /\
    \ \\prod_{d|n, d<n} \\phi_d(x)\n\nMoreover, we can compute \\phi_d(x) for all\
    \ divisors d of n in a single\npass, and so take only O(n) time.\n\n```racket\n\
    #lang racket\n", "  (if (zero? n)\n      1\n      (if (zero? (modulo n 2))\n \
    \         (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p) 2) p))))\n", "  (if (= n 0)\n      1\n\
    \      (let loop ((n n) (acc 1))\n        (cond\n          ((= n 0) acc)\n   \
    \       ((odd? n) (loop (quotient n 2) (* (* 2 acc) (modp (quotient n 2) p))))\n\
    \          (else (loop (quotient n 2) (* acc acc)))))))\n", "  (define (power-mod\
    \ m q)\n    (if (= m 0)\n        1\n        (let ([rm (remainder (power-mod (quotient\
    \ m 2) q) q)])\n          (if (zero? (remainder m 2))\n              (* rm rm)\n\
    \              (* rm rm 2)))))\n  (let ([r (remainder n p)])\n    (if (< r 0)\n\
    \        (+ r p)\n        r)))\n", "  (cond [(= n 0) 1]\n        [(= n 1) n]\n\
    \        [(even? n) (modulo (square (modp (/ n 2) p)) p)]\n        [else (modulo\
    \ (* n (modp (- n 1) p)) p)]))\n", "  (if (zero? n)\n      1\n      (modulo (*\
    \ 2 (modp (sub1 n) p)) p)))\n", "  (let ((f 1))\n    (for ([i (in-range n)])\n\
    \      (set! f (* f 2))\n      (when (> f p)\n        (set! f (- f p))))\n   \
    \ f))\n", "  (cond ((= n 0) 1)\n        ((and (even? n) (odd? p)) (modp (/ n 2)\
    \ p))\n        ((and (odd? n) (even? p)) (modp (- (/ n 2) 1) p))\n        ((and\
    \ (even? n) (even? p)) (modp (/ n 2) (/ p 2)))\n        ((> n p) (modp (- n p)\
    \ p))\n        (else n)))\n", "  (let loop ([n n] [p p] [r 1])\n    (cond [(zero?\
    \ n) r]\n          [(zero? (modulo n 2)) (loop (quotient n 2) p (modulo (* r r)\
    \ p))]\n          [else (loop (quotient (- n 1) 2) p (modulo (* r r n) p))])))\n",
  "  (define (check k)\n    (cond ((= k 0) (modulo 1 p))\n          ((= (remainder\
    \ k 2) 0) (modulo (square (check (quotient k 2))) p))\n          (else (modulo\
    \ (* n (check (quotient (- k 1) 2))) p))))\n  (check n))\n", "  (cond\n    [(<\
    \ n 1) 1]\n    [(= n 1) 2]\n    [else (if (odd? n)\n              (* 2 (modp (-\
    \ n 1) p))\n              (mod (* 2 (modp (- n 1) p)) p))]))\n", "  (cond [(zero?\
    \ n) 1]\n        [(even? n) (square (modp (/ n 2) p))]\n        [else (modulo\
    \ (* n (modp (- n 1) p)) p)]))\n", "  (cond\n    [(zero? n) 1]\n    [(odd? n)\
    \ (remainder (* 2 (modp (quotient n 2) p)) p)]\n    [else (remainder (square (modp\
    \ (quotient n 2) p)) p)]))\n", "  (cond ((= n 0) 1)\n        ((= n 1) n)\n   \
    \     ((= n 2) \n         (let ((x (- (modp n (/ n 2)) p)))\n           (if (<\
    \ x 0) (+ x p) x)))\n        (else \n         (let ((x (* 2 (modp n (/ n 2)))))\n\
    \           (if (< x p) x (- x p))))))\n", "  (modulo (expt 2 n) p))\n\n", " \
    \ (define (modp-1 n p a)\n    (if (= n 0)\n        a\n        (modp-1 (quotient\
    \ n 2) p\n                (if (even? n)\n                    (modulo (square a)\
    \ p)\n                    (modulo (* a (square a)) p)))))\n  (modp-1 n p 1))\n",
  "  (cond [(= n 0) 1]\n        [(even? n) (modulo (expt 2 (/ n 2)) p)]\n        [else\
    \ (modulo (* (expt 2 (/ (- n 1) 2)) 3) p)]))\n", "  (define (modp-iter n p pwr)\n\
    \    (cond\n      [(= n 0) 1]\n      [(= pwr 0) (modulo n p)]\n      [(odd? n)\n\
    \       (modulo (* p (modp-iter (- n 1) p (- pwr 1))) p)]\n      [else\n     \
    \  (modp-iter (/ n 2) p (- pwr 1))]))\n  (modp-iter n p (expt 2 (integer-length\
    \ n))))\n", "  (if (eq? n 0)\n      1\n      (let ([powmod (* n (modp (- n 1)\
    \ p))])\n        (if (> powmod p)\n            (modulo powmod p)\n           \
    \ powmod))))\n", "  (define res 1)\n  (define (modp-helper n p res)\n    (if (zero?\
    \ n)\n        res\n        (if (odd? n)\n            (modp-helper (/ n 2) p (*\
    \ res (* res p)))\n            (modp-helper (/ n 2) p (* res res)))))\n  (modp-helper\
    \ n p res))\n", "  (modulo (expt 2 n) p))\n", "  (cond ((= n 0) 1)\n        ((even?\
    \ n)\n         (cond ((= (modulo n 2) 0) (modulo (expt 2 (/ n 2)) p))\n      \
    \         (else (* (modulo (expt 2 (/ n 2)) p) (modulo (expt 2 (/ n 2)) p)))))\n\
    \        (else (modulo (* (modulo (expt 2 (/ (- n 1) 2)) p) (modulo (expt 2 (/\
    \ (- n 1) 2)) p)) p))))\n", "  (if (= n 0)\n      1\n      (remainder (* (modp\
    \ (quotient n 2) p) (modp (quotient n 2) p)) p)))\n", "  (if (= n 0)\n      1\n\
    \      (* n (modp (- n 1) p) % p)))\n", "  (match n\n    ['() 1]\n    [(cons x\
    \ xs)\n     (modulo (* (modp xs p) (modp xs p)) p)]))\n", "  (if (= n 0)\n   \
    \   1\n      (modulo (* 2 (modp (- n 1) p)) p)))\n", "  (define (aux k m)\n  \
    \  (cond\n      [(= k 0) 1]\n      [(odd? k) (modulo (* m m) p)]\n      [else\
    \ (modulo (aux (quotient k 2) (modulo (* m m) p)) p)]))\n  (aux n n))\n", "  (cond\
    \ [(zero? n) 1]\n        [(even? n) (modulo (square (modp (quotient n 2) p)) p)]\n\
    \        [else (modulo (* (modp (sub1 n) p) n) p)]))\n", "  (if (= n 0)\n    \
    \  1\n      (let ((r (modulo (* (modp (bitwise-arithmetic-shift n -1) p)\n   \
    \                      (modp (bitwise-arithmetic-shift n -1) p))\n           \
    \          p)))\n        (if (odd? n)\n            (modulo (* r 2) p)\n      \
    \      r))))\n", "  (modulo (expt 2 n) p))\n", "  (if (zero? n)\n      1\n   \
    \   (let loop ((a 2) (b 1) (n n))\n        (if (zero? n)\n            b\n    \
    \        (if (even? n)\n                (loop (modulo (* a a) p) b (/ n 2))\n\
    \                (loop (modulo (* a a) p) (modulo (* a b) p) (- n 1)))))))\n",
  "  (if (= n 0)\n      1\n      (let* ([k (quotient (- n 1) (log2 p))]\n        \
    \     [l (- n (* k (log2 p)))])\n        (let* ([b (expt 2 l)]\n             \
    \  [r (remainder (expt b 2) p)])\n          (if (= k 0)\n              r\n   \
    \           (let* ([v (modp k p)])\n                (remainder (* r (expt v 2))\
    \ p)))))))\n", "  (define (calc-mod base exp)\n    (cond\n      [(= exp 0) 1]\n\
    \      [(= exp 1) base]\n      [(odd? exp)\n       (modulo (* base (calc-mod base\
    \ (- exp 1))) p)]\n      [else\n       (modulo (calc-mod (modulo (* base base)\
    \ p) (/ exp 2)) p)]))\n  (calc-mod n (- p 1)))", "  (if (zero? n)\n      1\n \
    \     (if (even? n)\n          (modulo (square (modp (quotient n 2) p)) p)\n \
    \         (modulo (* (modp (quotient n 2) p) (modp (sub1 n) p)) p))))\n", "  (define\
    \ (modp-help n r)\n    (cond [(= n 0) 1]\n          [(even? n) (modulo (square\
    \ r) p)]\n          [else (modulo (* r n) p)]))\n  (modp-help n 2))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(even? n) (remainder (expt 2 (quotient n 2)) p)]\n    [else\
    \ (remainder (* 2 (modp (- n 1) p)) p)]))\n```\n\n### Fractional exponents\n\n\
    ```\n#lang racket\n", "  (define (iter n r)\n    (cond\n      [(zero? n) r]\n\
    \      [(zero? (remainder n 2)) (iter (/ n 2) (remainder (* r r) p))]\n      [else\
    \ (iter (- n 1) (remainder (* r 2) p))]))\n  (iter n 1))\n", "  (cond [(zero?\
    \ n) 1]\n        [(zero? (remainder n 2))\n         (modulo (* (modp (/ n 2) p)\
    \ (modp (/ n 2) p)) p)]\n        [else\n         (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p) 2) p)]))\n", "  (cond [(<= n 0) 1]\n        [(zero? (modulo n 2))\
    \ (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n        [else (modulo (*\
    \ (modp (/ n 2) p) (modp (/ n 2) p) 2) p)]))\n", "  (cond ((zero? n) 1)\n    \
    \    ((zero? (remainder n 2)) (modulo (modp (floor (/ n 2)) p) p))\n        (else\
    \ (modulo (* (modp (floor (/ n 2)) p) (modp (floor (/ n 2)) p)) p))))\n", "  (cond\n\
    \    [(zero? n) 1]\n    [(positive? n) (let* ([n (modulo n p)]\n             \
    \            [x (modp (quotient n 2) p)]\n                         [y (modulo\
    \ (* x x) p)])\n                     (if (zero? (modulo n 2))\n              \
    \           y\n                         (modulo (* 2 y) p)))]\n    [else (modulo\
    \ (- (modp (abs n) p)) p)]))\n", "  (if (zero? n)\n      1\n      (if (odd? n)\n\
    \          (* (modp (- n 1) p) 2)\n          (modp (/ n 2) p))))\n", "  (let loop\
    \ ([n n] [p p] [mod 1])\n    (if (= n 0)\n        mod\n        (loop (quotient\
    \ n 2) p\n              (if (odd? n)\n                  (* mod (* mod p))\n  \
    \                (* mod mod))))))\n", "  (cond\n    [(< n p) n]\n    [(= (remainder\
    \ n 2) 0) (modulo (modp (/ n 2) p) p)]\n    [else (modulo (* (modp (- n 1) p)\
    \ 2) p)]))\n", "  (cond\n    [(zero? n) 1]\n    [(even? n) (modulo (expt 2 (/\
    \ n 2)) p)]\n    [else (modulo (* 2 (modp (- n 1) p)) p)]))\n```\n\n## Modular\
    \ multiplicative inverse\n\n``` #lang racket\n", "  (cond [(= n 0) 1]\n      \
    \  [(even? n) (modulo (modp (/ n 2) p) p)]\n        [else (modulo (* 2 (modp (-\
    \ n 1) p)) p)]))\n", "  (if (zero? n)\n      1\n      (* (modp (remainder n 2)\
    \ p)\n         (modp (quotient n 2) p))))\n", "  (cond ((= n 0) 1)\n        ((=\
    \ (remainder n 2) 0) (modulo (square (modp (/ n 2) p)) p))\n        (else (modulo\
    \ (* n (modp (- n 1) p)) p))))\n", "  (remainder (expt 2 n) p))\n", "  (cond ((=\
    \ n 0) 1)\n        ((= (remainder n 2) 0)\n         (remainder (square (modp (/\
    \ n 2) p)) p))\n        (else\n         (remainder (* n (modp (- n 1) p)) p))))\n",
  "  (if (= n 0)\n      1\n      (let ([v (modulo (expt 2 (remainder n p)) p)])\n\
    \        (if (= n p)\n            v\n            (modp (remainder (+ n 1) p) p)))))\n",
  "  (if (zero? n)\n      1\n      (if (odd? n)\n          (modulo (* n (modp (- n\
    \ 1) p)) p)\n          (modulo (expt (modp (/ n 2) p) 2) p))))\n", "  (if (= n\
    \ 0)\n      1\n      (let* ([b (bit? n -1)]\n             [n* (* n b)]\n     \
    \        [p* (* p b)])\n        (if (and (negative? n*) (positive? p*))\n    \
    \        (modulo (- n*) p)\n            (modulo n* p)))))\n", "  (define (modp'\
    \ n p)\n    (define (recur n k)\n      (cond ((and (zero? n) (zero? k)) 1)\n \
    \           ((and (zero? n) (not (zero? k))) 0)\n            ((and (not (zero?\
    \ n)) (zero? k)) (modulo n p))\n            ((and (not (zero? n)) (not (zero?\
    \ k)))\n             (if (even? n)\n                 (recur (/ n 2) (+ k 1))\n\
    \                 (recur (/ n 2) (+ k 1))\n                 (modulo (* (modp'\
    \ (modulo n p) p)\n                            (modp' (modulo (/ n p) p) p))\n\
    \                        p)))))\n    (recur n 0))\n  (modp' n p))\n", "  (define\
    \ (modp-iter power n p)\n    (cond\n      [(= n 0) 1]\n      [(= (remainder n\
    \ 2) 0) (modp-iter (remainder (* power power) p) (/ n 2) p)]\n      [else (remainder\
    \ (* power (modp-iter (remainder (* power power) p) (/ n 2) p)) p)]))\n  (modp-iter\
    \ n n p))\n", "  (if (zero? n)\n      1\n      (if (odd? n)\n          (* (expt\
    \ 2 (- n 1)) (modp (- n 1) p))\n          (expt (modp (/ n 2) p) 2))))\n", " \
    \ (if (zero? n)\n      1\n      (let ([n (modulo n p)])\n        (if (even? n)\n\
    \            (modulo (* (modp (/ n 2) p)\n                       (modp (/ n 2)\
    \ p))\n                    p)\n            (modulo (* n (modp (- n 1) p))\n  \
    \                  p)))))\n", "  (define (square x) (* x x))\n  (cond\n    [(=\
    \ n 0) 1]\n    [(and (> n 0) (= (modulo n 2) 0)) (modulo (square (modp (/ n 2)\
    \ p)) p)]\n    [(> n 0) (modulo (* (modp (/ (- n 1) 2) p) (modp (- n 1) p)) p)]))\n",
  "  (modulo (expt 2 n) p))\n", "  (cond\n    [(= n 0) 1]\n    [(= (modulo n 2) 0)\
    \ (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p) 2) p)]))\n", "  (cond ((= n 0) 1)\n        ((= n\
    \ 1) 1)\n        ((even? n) (modp (/ n 2) p))\n        (else (* n (modp (- n 1)\
    \ p)))))\n", "  (modulo (expt 2 n) p))\n", "  (cond ((= n 0) 1)\n        ((even?\
    \ n) (remainder (square (modp (/ n 2) p)) p))\n        (else (remainder (* n (modp\
    \ (- n 1) p)) p))))\n```\n\n```racket\n#lang racket\n", "  (define (iter n p exp)\n\
    \    (cond\n      [(zero? n) 1]\n      [(zero? (modulo n 2)) (iter (/ n 2) p (*\
    \ 2 exp))]\n      [else (modulo (* (iter (/ (- n 1) 2) p (* 2 exp)) p) p)]))\n\
    \  (iter n p 1))\n", "  (if (zero? n)\n      1\n      (modulo (* (modp (- n 1)\
    \ p) 2) p)))", "  (if (= 0 n)\n      1\n      (* (modp (/ n 2) p)\n         (modp\
    \ (/ (+ n 1) 2) p)\n         p)))\n```\n\n```racket\n#lang racket\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (- n 1)\
    \ p) (modp (- n 1) p) 2) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n)\n\
    \     (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\n     (modulo\
    \ (* (modp (/ (- n 1) 2) p) (modp (/ (- n 1) 2) p) 2) p)]))\n```\n\n## Problem\
    \ 15\n\n[**Discrete Logarithm Problem**](https://en.wikipedia.org/wiki/Discrete_logarithm):\n\
    > Given a prime p and integer g, find the smallest non-negative\n> integer x such\
    \ that g^x \u2261 h (mod p).\n\nThe function in [prob15.rkt](prob15.rkt) uses\
    \ the [*baby-step giant-step*](https://en.wikipedia.org/wiki/Baby-step_giant-step)\n\
    algorithm to solve the Discrete Logarithm Problem.\n\nThe `logp` function requires\
    \ two arguments: `g` (the base) and `h` (the\nresult of raising the base to the\
    \ unknown exponent). The function also\ntakes an optional argument `p` which represents\
    \ the modulus (defaults\nto `101`).\n\n**Usage**:\n```racket\n> (logp 3 30)\n\
    2\n> (logp 2 5)\n3\n> (logp 2 9)\n3\n> (logp 2 10)\n-1\n> (logp 2 8)\n-1\n> (logp\
    \ 3 9)\n2\n> (logp 2 4)\n-1\n> (logp 2 1)\n0\n> (logp 5 -1)\n-1\n> (logp 3 -1)\n\
    -1\n> (logp 3 -1 17)\n15\n> (logp 3 -1 10000019)\n100000004\n```\n\n## Problem\
    \ 16\n\n[**Computing the nth Fibonacci Number**](https://en.wikipedia.org/wiki/Fibonacci_number):\n\
    > Write a function to compute the nth Fibonacci number.\n\nThe function in [prob16.rkt](prob16.rkt)\
    \ uses a fairly simple\nrecursive definition.\n", "  (cond\n    [(= 0 n) 1]\n\
    \    [(= 0 (modulo n 2))\n     (modulo (expt 2 (quotient n 2)) p)]\n    [else\n\
    \     (modulo (* 2 (modp (quotient n 2) p)) p)]))\n", "  (cond [(= n 0) 1]\n \
    \       [(= n 1) n]\n        [(even? n) (modulo (expt 2 (/ n 2)) p)]\n       \
    \ [else (modulo (* 2 (modp (- n 1) p)) p)]))\n", "  (cond ((zero? n) 1)\n    \
    \    ((even? n) (modulo (square (modp (quotient n 2) p)) p))\n        (else (modulo\
    \ (* (modp (sub1 n) p) n) p))))\n", "  (cond [(= n 0) 1]\n        [(= (remainder\
    \ n 2) 0)\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n      \
    \  [else\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2) p) n) p)]))\n</code>\n\
    The following function gives the same results as <code>modp</code> for all numbers\
    \ I've tried. My solution is much slower than the previous one though, so it's\
    \ probably not what's expected.\n<code>#lang racket\n", "  (modulo (expt 2 n)\
    \ p))\n", "  (cond [(zero? n) 1]\n        [(even? n) (modulo (square (modp (quotient\
    \ n 2) p)) p)]\n        [else (modulo (* (modp (quotient n 2) p) (modp (quotient\
    \ n 2) p) (modp (modulo n 2) p)) p)]))\n", "  (cond\n    [(= n 0) 1]\n    [(not\
    \ (even? n))\n     (modulo (* 2 (modp (- n 1) p)) p)]\n    [else\n     (modulo\
    \ (square (modp (/ n 2) p)) p)]))\n</code>\nThis is exactly the same implementation\
    \ in Python:\n<code>def modp(n, p):\n    if n == 0:\n        return 1\n    elif\
    \ n % 2 != 0:\n        return (2 * modp(n - 1, p)) % p\n    else:\n        return\
    \ (modp(n / 2, p)**2) % p\n</code>\nThis is an implementation of modp in Haskell:\n\
    <code>modp :: Integer -&gt; Integer -&gt; Integer\nmodp 0 _ = 1\nmodp n p =\n\
    \  if odd n\n    then 2 * modp (n - 1) p `mod` p\n    else (modp (n `div` 2) p)^2\
    \ `mod` p\n</code>\nAnd this is an implementation of modp in Clojure:\n<code>(defn\
    \ modp [n p]\n  (if (= n 0)\n    1\n    (if (odd? n)\n      (mod (* 2 (modp (-\
    \ n 1) p)) p)\n      (mod (modp (/ n 2) p) p))))\n</code>\n", "  (define (loop\
    \ n ans)\n    (cond\n      [(= n 0) 1]\n      [(= n 1) ans]\n      [else (loop\
    \ (- n 1) (modulo (* 2 ans) p))]))\n  (loop n 2))\n", "  (letrec ([modexp (lambda\
    \ (n a)\n                     (cond\n                       [(zero? n) 1]\n  \
    \                     [(odd? n)\n                        (remainder (* a (modexp\
    \ (quotient n 2)\n                                                (remainder (*\
    \ a a) p)))\n                                   p)]\n                       [else\n\
    \                        (remainder (modexp (quotient n 2)\n                 \
    \                          (remainder (* a a) p))\n                          \
    \         p)]))])\n    (modexp n n)))\n", "  (if (= n 0)\n      1\n      (* n\n\
    \         (modp (- n 1) p))))\n", "  (cond\n    [(zero? n) 1]\n    [(zero? (remainder\
    \ n 2))\n     (remainder (square (modp (quotient n 2) p)) p)]\n    [else\n   \
    \  (remainder (* 2 (modp (quotient n 2) p)) p)]))\n", "  (cond\n    [(zero? n)\
    \ 1]\n    [(even? n) (modulo (square (modp (quotient n 2) p)) p)]\n    [else (modulo\
    \ (* (modp (quotient n 2) p) (modp (+ n 1) p)) p)]))\n```\n\nWith some examples:\n\
    \n```text\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>>\
    \ modp(3, 11)\n8\n>>> modp(100, 101)\n1\n```\n\n```racket\n> (define e 19)\n>\
    \ (define c (modp m e n))\n> (modp c d n)\n10118\n```\n\nFor larger numbers, we'd\
    \ have to come up with something more efficient, like the algorithm to the right,\
    \ which works in O(log^2(n)) time instead of O(n^2).\n\n```racket", "  (if (=\
    \ n 0)\n      1\n      (let ((val (modp (bitwise-arithmetic-shift-right n 1) p)))\n\
    \        (if (even? n)\n            (modulo (* val val) p)\n            (modulo\
    \ (* val val val) p)))))\n", "  (define (helper n p i ret)\n    (cond ((zero?\
    \ n) ret)\n          ((zero? (modulo n 2)) (helper (quotient n 2) p i (* ret ret\
    \ i p)))\n          (else (helper (quotient n 2) p i (* ret ret i p)))))\n  (helper\
    \ n p 2 1))\n```\n\nThis looks reasonably simple, but we can do much better. Again,\
    \ we should start with some paper-and-pencil math to reason about how to improve.\n\
    \nThe key is to notice that `ret` is a growing number modulo `p`. In particular,\
    \ if it is `p - 1`, then multiplying by it won't change the modulus. But then\
    \ all subsequent multiplications are idempotent, because they are mod `p`. So\
    \ we only really need to compute a single power of 2 mod `p`, and the rest of\
    \ the work follows trivially.\n\nAnd computing a single power of 2 mod `p` is\
    \ a job for `modexp`, which we already have!\n\nThe trick is to treat `n` as a\
    \ binary number, and compute `2^i mod p` for each 1 bit in `n`. This is easily\
    \ done with `foldl`:\n\n```\n#lang racket\n", "  (if (zero? n)\n      1\n    \
    \  (* (modp (quotient n 2) p)\n         (if (even? n)\n             1\n      \
    \       (* 2 (modp (quotient n 2) p)))\n         )\n      )\n  )\n", "  (define\
    \ (iter n p r)\n    (cond\n      [(zero? n) r]\n      [(= (remainder n 2) 0) (iter\
    \ (/ n 2) p (modulo (* r r) p))]\n      [else (iter (- n 1) p (modulo (* r 2)\
    \ p))]))\n  (iter n p 1))\n", "  (define (modp-iter b x)\n    (cond\n      [(=\
    \ b 0) 1]\n      [(zero? (modulo b 2)) (modp-iter (/ b 2) (modulo (* x x) p))]\n\
    \      [else (modulo (* x (modp-iter (- b 1) x)) p)]))\n  (modp-iter n n))\n```\n\
    \n####\u0410\u043D\u0430\u043B\u0438\u0437 \u0410\u043B\u0433\u043E\u0440\u0438\
    \u0442\u043C\u0430\n\u0421\u043B\u043E\u0436\u043D\u043E\u0441\u0442\u044C \u0430\
    \u043B\u0433\u043E\u0440\u0438\u0442\u043C\u0430 \u0440\u0430\u0432\u043D\u0430\
    \ $O(\\log n)$, \u0442\u0430\u043A \u043A\u0430\u043A \u0432\u043D\u0443\u0442\
    \u0440\u0435\u043D\u043D\u0438\u0439 \u0446\u0438\u043A\u043B \u0432\u044B\u043F\
    \u043E\u043B\u043D\u044F\u0435\u0442\u0441\u044F $\\log n$ \u0440\u0430\u0437\
    .\n\n####\u0421\u043F\u0438\u0441\u043E\u043A \u043B\u0438\u0442\u0435\u0440\u0430\
    \u0442\u0443\u0440\u044B\n1. [\u0412\u0438\u043A\u0438\u043F\u0435\u0434\u0438\
    \u044F](https://ru.wikipedia.org/wiki/\u0410\u043B\u0433\u043E\u0440\u0438\u0442\
    \u043C_\u042D\u0432\u043A\u043B\u0438\u0434\u0430)\n2. [GeeksforGeeks](http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/)\n\
    3. [GeeksforGeeks](http://www.geeksforgeeks.org/write-an-iterative-olog-y-function-for-powx-y/)\n\
    4. [\u0412\u0438\u043A\u0438\u043F\u0435\u0434\u0438\u044F](https://ru.wikipedia.org/wiki/\u0421\
    \u0438\u043C\u0432\u043E\u043B_\u041B\u0435\u0436\u0430\u043D\u0434\u0440\u0430\
    )\n5. [\u0412\u0438\u043A\u0438\u043F\u0435\u0434\u0438\u044F](https://ru.wikipedia.org/wiki/\u0421\
    \u0442\u0435\u043F\u0435\u043D\u044C_\u043F\u043E_\u043C\u043E\u0434\u0443\u043B\
    \u044E)\n6. [\u0412\u0438\u043A\u0438\u043F\u0435\u0434\u0438\u044F](https://ru.wikipedia.org/wiki/\u0410\
    \u043B\u0433\u043E\u0440\u0438\u0442\u043C_\u0431\u044B\u0441\u0442\u0440\u043E\
    \u0433\u043E_\u0432\u043E\u0437\u0432\u0435\u0434\u0435\u043D\u0438\u044F_\u0432\
    _\u0441\u0442\u0435\u043F\u0435\u043D\u044C)\n7.", "  (if (zero? n)\n      1\n\
    \      (let* ([s (modulo n 2)]\n             [result (* s (modp (quotient n 2)\
    \ p))])\n        (modulo result p))))\n", "  (cond [(= n 0) 1]\n        [(= (modulo\
    \ n 2) 0)\n         ;; n is even: sqr(n) * sqr(n-1) = n * n - 1\n         (modulo\
    \ (* n (modp (- n 1) p)) p)]\n        [else\n         ;; n is odd: n * sqr(n-1)\n\
    \         (modulo (* n (modp (- n 1) p)) p)]))\n", "  (if (negative? n)\n    \
    \  (modulo (expt 2 (- n)) p)\n      (modulo (expt 2 n) p)))\n", "  (define (m2n\
    \ n)\n    (if (= n 0)\n        1\n        (* 2 (m2n (- n 1)))))\n  (remainder\
    \ (m2n n) p))", "  (cond [(< p 0) (error \"p must be > 0\")]\n        [(= n 0)\
    \ 1]\n        [(= n 1) n]\n        [(even? n) (modulo (expt 2 (/ n 2)) p)]\n \
    \       [else\n         (modulo (* (modp (1- n) p) 2) p)]))\n", "  (cond [(< n\
    \ 0) -1]\n        [(= n 0) 1]\n        [(even? n) (modulo (* (modp (/ n 2) p)\
    \ (modp (/ n 2) p)) p)]\n        [else (modulo (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p) 2) p)]))\n```\n\nI'm pretty sure I got it right. But I'm also pretty sure\
    \ I'm missing some\nkey insight that would let me write a much simpler, neater\
    \ solution.\n\nIn my search for a better solution, I found\n[this video](https://www.youtube.com/watch?v=pkxseNu4Bq4)\
    \ which is about\nimplementing a shift-register-based random number generator.\n\
    \n### modp-1\n\nIf you have ever learned about modular arithmetic, you may have\
    \ come across\nthis property:\n\n```text", "  (define (squared x)\n    (* x x))\n\
    \  (define (helper n i total)\n    (cond ((= n 0) total)\n          ((= i n) (helper\
    \ (- n 1) 0 (squared total)))\n          (else (helper n (+ i 1) (* total 2)))))\n\
    \  (modulo (helper n 0 1) p))\n", "  (cond\n    [(= n 0) 1]\n    [(even? n) (modulo\
    \ (modp (/ n 2) p) p)]\n    [else (modulo (* 2 (modp (- n 1) p)) p)]))\n```\n\n\
    In this question we are manipulating numbers by hand, but have access to a calculator.\
    \ I usually use a calculator when the numbers are bigger than 100-200 digits.",
  "  (cond\n    [(= n 0) 1]\n    [(odd? n)\n     (modulo (* 2 (modp (quotient n 2)\
    \ p)) p)]\n    [else\n     (modulo (expt 2 n) p)]))\n", "  (remainder (expt 2\
    \ n) p))\n", "  (define (aux n p res)\n    (cond [(= n 0) res]\n          [else\
    \ (aux (quotient n 2) p\n                     (if (zero? (remainder n 2))\n  \
    \                       (remainder (* res res) p)\n                         (remainder\
    \ (* res res res) p)))]))\n  (aux n p 1))\n", "  (cond\n    [(zero? n) 1]\n  \
    \  [(even? n) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo\
    \ (* (modp (- n 1) p) 2) p)]))\n", "  (define (exp n p)\n    (if (zero? n)\n \
    \       1\n        (if (even? n)\n            (let ([x (exp (/ n 2) p)])\n   \
    \           (remainder (* x x) p))\n            (remainder (* n (exp (- n 1) p))\
    \ p))))\n  (if (zero? n)\n      1\n      (if (zero? p)\n          0\n        \
    \  (exp n p))))\n", "  (define (modp-iter a n p)\n    (cond\n      ((= n 0) a)\n\
    \      ((even? n) (modp-iter a (/ n 2) p))\n      (else (modp-iter (* a 2 p) (-\
    \ n 1) p))))\n  (modp-iter 1 n p))\n", "  (cond ((= n 0) 1)\n        ((and (even?\
    \ n) (= p 2)) 0)\n        ((even? n) (mod (sqr (modp (/ n 2) p)) p))\n       \
    \ (else (mod (mod p n) p))))\n", "  (cond\n    [(= n 0) 1]\n    [(zero? (modulo\
    \ n 2)) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (*\
    \ (modp (/ n 2) p) (modp (/ n 2) p) 2) p)]))\n", "  (modulo (expt 2 n) p))\n",
  "  (if (= n 0)\n      1\n      (if (odd? n)\n          (modulo (* n (modp (- n 1)\
    \ p)) p)\n          (modulo (square (modp (/ n 2) p)) p))))\n", "  (cond ((= n\
    \ 0) 1)\n        ((= n 1) n)\n        ((even? n)\n         (modulo (modp (/ n\
    \ 2) p) (square p)))\n        (else\n         (modulo (* (modp (- n 1) p) n) p))))\n",
  "  (cond\n    [(= n 0) 1]\n    [(= (remainder n 2) 0)\n     (let ([n2 (/ n 2)])\n\
    \       (remainder (* (modp n2 p) (modp n2 p)) p))]\n    [else\n     (remainder\
    \ (* 2 (modp (- n 1) p)) p)]))\n", "  (define (loop n p n2)\n    (if (zero? n)\
    \ n2\n        (loop (quotient n 2) p (if (odd? n) (modulo (* n2 n2) p) (modulo\
    \ (sqr n2) p)))))\n  (loop n p 1))\n", "  (if (= n 0)\n      1\n      (if (even?\
    \ n)\n          (let ([tmp (/ n 2)])\n            (remainder (* (modp tmp p) (modp\
    \ tmp p)) p))\n          (remainder (* n (modp (- n 1) p)) p))))\n", "  (modulo\
    \ (expt 2 n) p))\n", "  (if (= n 0)\n      1\n      (modulo (* 2 (modp (- n 1)\
    \ p)) p)))\n", "  (define (modp-iter n p)\n    (cond\n      [(= n 0) 1]\n    \
    \  [(even? n) (modulo (square (modp-iter (/ n 2) p)) p)]\n      [else (modulo\
    \ (* (modp-iter (decrement n) p) 2) p)]))\n  (modp-iter n p))\n", "  (if (zero?\
    \ n)\n      1\n      (* (modp (quotient (- n 1) 2) p)\n         (if (zero? (modulo\
    \ n 2))\n             1\n             (* 2 (modp (quotient (- n 1) 2) p))\n  \
    \       )\n      )\n  )\n)\n", "  (if (zero? n)\n      1\n      (let ([mod-n (modulo\
    \ n p)])\n        (define (calc-modp n mod-n)\n          (if (even? n)\n     \
    \         (modulo (square mod-n) p)\n              (modulo (* mod-n (calc-modp\
    \ (quotient n 2) mod-n)) p)))\n        (calc-modp n mod-n))))\n", "  (define (mphelper\
    \ n p)\n    (cond\n      [(= p 1) 1]\n      [(= n 0) 1]\n      [(zero? (modulo\
    \ n 2)) (modulo (* (mphelper (/ n 2) p) (mphelper (/ n 2) p)) p)]\n      [else\
    \ (modulo (* (mphelper (/ (- n 1) 2) p) (mphelper (/ (- n 1) 2) p) (mphelper 1\
    \ p)) p)]))\n  (mphelper n p))\n", "  (modulo (expt 2 n) p))\n```", "  (cond\n\
    \    [(= n 0) 1]\n    [(odd? n) (modulo (* 2 (modp (- n 1) p)) p)]\n    [else\
    \ (modulo (square (modp (/ n 2) p)) p)]))\n", "  (cond\n    [(zero? n) 1]\n  \
    \  [(zero? (modulo n 2))\n     (let ([pp (modp (/ n 2) p)])\n       (modulo (*\
    \ pp pp) p))]\n    [else\n     (modulo (* 2 (modp (sub1 n) p)) p)]))\n```\n\n\
    ``` #lang racket\n", "  (cond\n    [(zero? n)\n     1]\n    [(even? n)\n     (remainder\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\n     (remainder (* (modp\
    \ (- n 1) p) 2) p)]))\n", "  (cond [(= n 0) 1]\n        [(= n 1) n]\n        [(=\
    \ n (- n 1)) 1]\n        [else (modulo (* n (modp (- n 1) p)) p)]))\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(even? n) (modulo (modp (/ n 2) p) p)]\n    [else (modulo\
    \ (* 2 (modp (- n 1) p)) p)]))\n", "  (cond\n    [(= n 0) 1]\n    [(= (remainder\
    \ n 2) 0)\n     ;; Even number\n     (remainder (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p)) p)]\n    [else\n     ;; Odd number\n     (remainder (* (modp (/ n 2)\
    \ p) (modp (/ n 2) p) 2) p)]))\n", "  (define (c a b c)\n    (if (zero? b) a\n\
    \        (if (odd? b) (c a (add1 (quotient b 2)) (modulo (modulo (* a a) p) c))\n\
    \            (c (modulo (* a a) p) (quotient b 2) c))))\n  (c n (quotient (- n\
    \ 1) 2) p))\n", "  (if (= n 0)\n      1\n      (let ((even? (odd? n))\n      \
    \      (half (quotient n 2)))\n        (if even?\n            (remainder (* (modp\
    \ half p) (modp half p)) p)\n            (remainder (* (modp (sub1 n) p)\n   \
    \                      (modp half p)\n                         (modp half p))\n\
    \                       p)))))\n```\n\n**First thoughts**:\n\n* the name of the\
    \ function is not great\n* this is a tail-recursive function\n* it will benefit\
    \ greatly from `(even? x)` and `(odd? x)` predicates\n* it uses \"quotient\" and\
    \ \"remainder\" functions\n* it should use a `(modulo n p)` procedure, which computes\
    \ `n mod p`\n* it should be rewritten in terms of the `(expt n m)` procedure\n\
    \n**Solution**:\n\n```racket", "  (cond [(zero? n) 1]\n        [(even? n) (modulo\
    \ (modp (quotient n 2) p) p)]\n        [else (modulo (* (modp (quotient (- n 1)\
    \ 2) p) n) p)]))\n```\n\n### Lecture 4\n\n**4.1 Intermezzo: the Rabin-Miller Algorithm**\n\
    \n``` #lang racket\n", "  (cond [(= 0 n) 1]\n        [(= 1 n) 1]\n        [(=\
    \ 0 (remainder n 2))\n         (let ([a (modp (/ n 2) p)])\n           (modulo\
    \ (* a a) p))]\n        [else\n         (let ([a (modp (- n 1) p)])\n        \
    \   (modulo (* a 2) p))]))\n```\n\nHere's my second attempt:\n\n```#lang racket\n",
  "  (define (modp-iter m p prod)\n    (cond ((= m 0) prod)\n          ((odd? m) (modp-iter\
    \ (- m 1) p (* prod 2 p)))\n          (else (modp-iter (- m 1) p (* prod p)))))\n\
    \  (modulo (modp-iter n p 1) p))\n</code>\nThe problem is that I have no idea\
    \ how to create a function that will accept a string (or in the case of Racket,\
    \ a list) as input and return <code>true</code> iff the product of all the digits\
    \ in the list is a multiple of 3.\nI've been doing a lot of reading on streams,\
    \ infinite lists, and lazy evaluation but I'm still unsure as to how to solve\
    \ this problem.\n\n\nA:\n\nHere's a way to do it, using the definition of <code>modp</code>\
    \ mentioned in the question, and assuming that the parameter <code>n</code> is\
    \ supposed to be a list of digits. \nWe first need to compute the product of the\
    \ digits:\n<code>(define (product digits)\n  (foldl * 1 digits))\n</code>\nNow\
    \ we can compute the remainder of the product divided by <code>p</code>, which\
    \ gives the result we need:\n<code>(define (modp-list p n)\n  (modulo (product\
    \ n) p))\n</code>\nFor example:\n<code>(modp-list 3 '(2 3 4 5 6 7 8 9 0))", " \
    \ (cond ((or (zero? n) (zero? p)) 1)\n        ((even? n) (modulo (modp (/ n 2)\
    \ p) p))\n        (else (modulo (* n (modp (/ n 2) p)) p))))\n", "  (define (modp-core\
    \ n p res)\n    (if (zero? n)\n        res\n        (modp-core (integer-floor\
    \ (/ n 2)) p\n                   (if (odd? n)\n                       (if (< (*\
    \ res 2) p)\n                           (* res 2)\n                          \
    \ (- (* res 2) p))\n                       (if (< (* res 2) p)\n             \
    \              (* res 2)\n                           (- (* res 2) p)))\n     \
    \              )))\n  (modp-core n p 1))\n", "  (define (f n p)\n    (cond\n \
    \     [(zero? n) 1]\n      [(even? n) (modulo (square (f (/ n 2) p)) p)]\n   \
    \   [else (modulo (* (f (- n 1) p) n) p)]))\n  (f n p))\n", "  (if (= n 0)\n \
    \     1\n      (let ([a (modulo (expt 2 n) p)])\n        (if (= a 0) p a))))\n",
  "  (define (iter n r)\n    (cond [(zero? n) 1]\n          [(zero? (modulo n 2))\
    \ (iter (quotient n 2)\n                                       (modulo (* r r)\
    \ p))]\n          [else (iter (quotient n 2)\n                      (modulo (*\
    \ r 2) p))]))\n  (iter n 1))\n", "  (define (modp-iter k x)\n    (cond\n     \
    \ [(zero? k) x]\n      [(even? k) (modp-iter (/ k 2) (modulo (* x x) p))]\n  \
    \    [else (modp-iter (- k 1) (modulo (* x 2) p))]))\n  (if (zero? n) 1 (modp-iter\
    \ n 2)))\n", "  (if (zero? n)\n      1\n      (let ((power (mod-exp n (quotient\
    \ (- p 1) 2) p)))\n        (if (even? n)\n            (remainder (* power power)\
    \ p)\n            (remainder (* power power n) p)))))\n```\n\n```racket", "  (letrec\
    \ ([f (lambda (n a)\n                (cond\n                  [(zero? n) a]\n\
    \                  [(even? n) (f (/ n 2) (remainder (* a a) p))]\n           \
    \       [else (f (/ (- n 1) 2) (remainder (* a a a) p))]))])\n    (f n 1)))\n\
    ```\n\n```racket\n#lang racket\n", "  (define-values (q r) (quotient/remainder\
    \ n p))\n  (if (= 0 q) r\n      (* p r)))\n", '  (remainder (* 2 (remainder n
    p)) p))', "  (define (modp-i n pow-of-2)\n    (cond\n      [(= n 0) 1]\n     \
    \ [(odd? n) (* (modp-i (- n 1) pow-of-2) pow-of-2)]\n      [else (modp-i (/ n\
    \ 2) (* pow-of-2 pow-of-2))]))\n  (modulo (modp-i n 2) p))\n", "  (if (= n 0)\n\
    \      1\n      (if (even? n)\n          (modulo (square (modp (/ n 2) p)) p)\n\
    \          (modulo (* n (modp (- n 1) p)) p))))\n", "  (cond\n    [(zero? n)\n\
    \     1]\n    [(odd? n)\n     (modulo (* 2 (modp (quotient n 2) p)) p)]\n    [else\n\
    \     (modulo (square (modp (quotient n 2) p)) p)]))\n", "  (let ([n (remainder\
    \ n p)])\n    (cond\n      [(zero? n) 1]\n      [(odd? n) (modulo (* n 2) p)]\n\
    \      [else    (modulo (square (modp (/ n 2) p)) p)])))\n", "  (cond ((= n 0)\
    \ 1)\n        ((= (remainder n 2) 0)\n         (modulo (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p))\n        (else\n         (modulo (* (modp (/ n 2) p) (modp (/\
    \ n 2) p) n) p))))\n", "  (cond [(= n 0) 1]\n        [(= n 1) n]\n        [(=\
    \ (modulo n 2) 0) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n        [else\
    \ (modulo (* (modp (- n 1) p) n) p)]))\n```\n\n## Summary\n\nWieder einmal war\
    \ ich etwas \xFCberrascht, dass ich die Aufgabe in 15 Minuten l\xF6sen konnte.\
    \ Ich h\xE4tte es nicht gedacht, auch mit Scheme, das ich fast nicht kenne und\
    \ mit dem ich auch bisher nie professionell gearbeitet habe.\n\nSehr toll ist,\
    \ dass das Ergebnis nicht nur kurz ist, sondern auch gut lesbar. Vermutlich kann\
    \ man es in den Details noch verbessern, aber auf den ersten Blick ist alles sehr\
    \ gut verst\xE4ndlich.", "  (define (modp-t m n)\n    (cond\n      [(= n 0) m]\n\
    \      [(= (remainder n 2) 0) (modp-t (modulo (* m m) p) (quotient n 2))]\n  \
    \    [else (modp-t (modulo (* m m) p) (quotient n 2))]))\n  (modp-t 1 n))\n",
  "  (cond [(= n 0) 1]\n        [(= n 1) n]\n        [(= n 2) (if (= (remainder n\
    \ p) 0) p n)]\n        [else (remainder (remainder (* n (modp (- n 1) p)) p) p)]))\n",
  "  (if (zero? n)\n      1\n      (if (zero? (modulo n 2))\n          (modulo (*\
    \ (modp (/ n 2) p) (modp (/ n 2) p)) p)\n          (modulo (* 2 (modp (/ n 2)\
    \ p) (modp (/ n 2) p)) p))))\n", "  (cond ((= n 0) 1)\n        ((and (even? n)\
    \ (odd? p))\n         (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p))\n    \
    \    ((and (even? n) (even? p))\n         (modulo (square (modp (/ n 2) p)) p))\n\
    \        ((and (odd? n) (even? p))\n         (modulo (* (modp (/ (- n 1) 2) p)\
    \ (modp (/ (- n 1) 2) p)) p))\n        ((and (odd? n) (odd? p))\n         (modulo\
    \ (* n (modp (/ (- n 1) 2) p) (modp (/ (- n 1) 2) p)) p))))\n", "  (if (zero?\
    \ n)\n      1\n      (if (zero? (modulo n 2))\n          (modulo (* (modp (/ n\
    \ 2) p) (modp (/ n 2) p)) p)\n          (modulo (* 2 (modp (- n 1) p)) p))))\n\
    </code>\nTesting:\n<code>&gt; (modp 3 5)\n3\n&gt; (modp 1101 101)\n2\n&gt; (modp\
    \ 0 101)\n1\n&gt; (modp 3 11)\n8\n&gt; (modp 100 101)\n1\n</code>\n", "  (cond\
    \ ((= n 0) 1)\n        ((= (remainder n 2) 0) (modulo (square (modp (/ n 2) p))\
    \ p))\n        (else (modulo (* n (modp (- n 1) p)) p))))", "  (cond [(zero? n)\
    \ 1]\n        [(zero? (remainder n 2))\n         (let ([a (modp (/ n 2) p)])\n\
    \           (remainder (* a a) p))]\n        [else\n         (let ([a (modp (/\
    \ n 2) p)])\n           (remainder (* (* a a) 2) p))]))\n```\n\nThe above code\
    \ is efficient, but the code is still not optimal. That is, the above code computes\
    \ in O(log n) time, but the code could be optimized to be even faster.\n\n## The\
    \ Project\n\nLet's look at how we could optimize the above code in Racket.\n\n\
    ## Library Code\n\nWe need a way to easily find the order of a number. That is,\
    \ we need a function `order` which, given a number `a` and a modulus `p`, finds\
    \ `k` such that `a^k \u2261 1 (mod p)`.\n\nHere is the function `order`:\n\n```racket\n\
    #lang racket\n", "  (cond ((= n 0) 1)\n        ((even? n) (modulo (square (modp\
    \ (/ n 2) p)) p))\n        (else (modulo (* n (modp (- n 1) p)) p))))", "  (if\
    \ (= n 0)\n      1\n      (let ([res (modular-exponentiation 2 n p)])\n      \
    \  (if (zero? res)\n            p\n            res))))\n", "  (define (square-and-multiply\
    \ a n)\n    (cond\n      [(= n 0) 1]\n      [(= n 1) a]\n      [(= (remainder\
    \ n 2) 0) (square-and-multiply (modulo (* a a) p) (quotient n 2))]\n      [else\
    \ (modulo (* a (square-and-multiply (modulo (* a a) p) (quotient (- n 1) 2)))\
    \ p)]))\n  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n    [else (square-and-multiply\
    \ n p)]))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n          (if (= (remainder\
    \ n 2) 0)\n              (modulo (sqr (modp (/ n 2) p)) p)\n              (modulo\
    \ (* (modp (/ n 2) p) (modp (/ n 2) p)) p))\n          (modulo (* (modp (- n 1)\
    \ p) 2) p))))\n", "  (modulo (expt 2 n) p))\n\n", "  (define (modp-iter n x)\n\
    \    (if (zero? n)\n        1\n        (if (odd? n)\n            (modulo (* x\
    \ x) p)\n            (modp-iter (quotient n 2)\n                       (modulo\
    \ (* x x) p)))))\n  (modp-iter n 2))\n", "  (if (even? n)\n      (if (= n 0)\n\
    \          1\n          (*\n           (square (modp (/ n 2) p))\n           (modp\
    \ (/ n 2) p)))\n      (* n (modp (- n 1) p))))\n", "  (define (mp n b)\n    (cond\
    \ ((= n 0) 1)\n          ((even? n) (mp (/ n 2) (remainder (* b b) p)))\n    \
    \      (else (remainder (* b (mp (- n 1) b)) p))))\n  (mp n n))\n", "  (if (zero?\
    \ n)\n      1\n      (if (zero? (modulo n 2))\n          (modulo (* (modp (/ n\
    \ 2) p) (modp (/ n 2) p)) p)\n          (modulo (* (modp (/ n 2) p) (modp (/ n\
    \ 2) p) 2) p))))\n", "  (define (divide-and-conquer v)\n    (if (zero? (remainder\
    \ v 2))\n        (if (zero? v)\n            1\n            (modulo (square (divide-and-conquer\
    \ (/ v 2))) p))\n        (modulo (* n (divide-and-conquer (- v 1))) p)))\n  (divide-and-conquer\
    \ n))\n", "  (if (= n 0)\n      1\n      (let ([x (modp (- n 1) p)])\n       \
    \ (modulo (* x 2) p))))\n", "  (if (= n 0)\n      1\n      (remainder (* (modp\
    \ (quotient n 2) p) (modp (quotient n 2) p)) p)))\n", "  (if (zero? n)\n     \
    \ 1\n      (let* ([i (inexact->exact (log2 n))]\n             [pwr (expt 2 i)])\n\
    \        (if (zero? (modulo pwr p))\n            (modp (- n pwr) p)\n        \
    \    (modulo (expt 2 (modulo i p)) p)))))\n", "  (cond\n    [(= n 0) 1]\n    [(=\
    \ (modulo n 2) 0) (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else\
    \ (modulo (* 2 (modp (- n 1) p)) p)]))\n", "  (define (modp-iter m n)\n    (cond\
    \ ((zero? n) m)\n          ((even? n) (modp-iter (remainder (square m) p) (quotient\
    \ n 2)))\n          (else (modp-iter (remainder (* m 2) p) (quotient n 2)))))\n\
    \  (modp-iter 1 n))\n", "  (if (= n 0)\n      1\n      (if (even? n)\n       \
    \   (modulo (expt 2 (/ n 2)) p)\n          (modulo (* 2 (modp (- n 1) p)) p))))\n",
  "  (define (modp-iter n p acc)\n    (cond\n      [(even? n) (modp-iter (/ n 2) p\
    \ (expt acc 2))]\n      [(= n 1) acc]\n      [else (modp-iter (- n 1) p (* acc\
    \ 2))]))\n  (modp-iter n p 1))\n", "  (let* ([p (modulo p n)]\n         [n n]\n\
    \         [out n])\n    (let loop ([n (- n 1)])\n      (cond [(zero? n) out]\n\
    \            [else (set! out (modulo (* out p) n))\n                  (loop (-\
    \ n 1))]))\n    out))\n", "  (cond\n    [(zero? n) 1]\n    [(zero? (modulo n 2))\
    \ (modulo (* (modp (/ n 2) p) (modp (/ n 2) p)) p)]\n    [else (modulo (* (modp\
    \ (/ n 2) p) (modp (/ n 2) p) 2) p)]))\n", "  (if (zero? n)\n      1\n      (if\
    \ (even? n)\n          (modulo (expt 2 (/ n 2)) p)\n          (modulo (* (expt\
    \ 2 (/ (- n 1) 2)) n) p))))\n```\n\n```racket\n#lang racket\n", "  (cond\n   \
    \ [(zero? n) 1]\n    [(zero? (modulo n 2)) (remainder (* (modp (/ n 2) p) (modp\
    \ (/ n 2) p)) p)]\n    [else (remainder (* (modp (/ n 2) p) (modp (/ n 2) p) 2)\
    \ p)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
