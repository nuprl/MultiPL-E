name: HumanEval_57_monotonic
language: rkt
prompt: "#lang racket\n\n;; Return True is list elements are monotonically increasing\
  \ or decreasing.\n;; >>> monotonic([1, 2, 4, 20])\n;; True\n;; >>> monotonic([1,\
  \ 20, 4, 10])\n;; False\n;; >>> monotonic([4, 1, 0, -10])\n;; True\n(define (monotonic\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n\
  \    (check-equal? (candidate (list 1 2 4 10)) #t)\n    (check-equal? (candidate\
  \ (list 1 2 4 20)) #t)\n    (check-equal? (candidate (list 1 20 4 10)) #f)\n   \
  \ (check-equal? (candidate (list 4 1 0 -10)) #t)\n    (check-equal? (candidate (list\
  \ 4 1 1 0)) #t)\n    (check-equal? (candidate (list 1 2 3 2 5 60)) #f)\n    (check-equal?\
  \ (candidate (list 1 2 3 4 5 60)) #t)\n    (check-equal? (candidate (list 9 9 9\
  \ 9)) #t)\n))\n\n(test-humaneval)"
completions: ["  (define (monotonic-iter l state)\n    (cond\n      [(null? l) (not\
    \ state)]\n      [(or (= (car l) (cadr l)) (< (car l) (cadr l)) (> (car l) (cadr\
    \ l)))\n       (monotonic-iter (cdr l) #t)]\n      [else #f]))\n  (if (null? l)\
    \ #t (monotonic-iter (cdr l) #t)))\n", "  (let ([monotonic? (cond [(equal? (first\
    \ l) (second l)) #t]\n                          [(< (first l) (second l)) (lambda\
    \ (l) (and (not (negative? (cadr l)))\n                                      \
    \                                (monotonic (cdr l))))]\n                    \
    \      [else (lambda (l) (and (not (positive? (cadr l)))\n                   \
    \                              (monotonic (cdr l))))])])\n    (if (null? (cdr\
    \ l))\n        #t\n        (monotonic? l))))", "  (cond ((= (length l) 1)\n  \
    \       #t)\n        ((= (length l) 2)\n         (if (< (car l) (cadr l))\n  \
    \           #t\n             #f))\n        (else\n         (let ((diff (dif-helper\
    \ l)))\n           (cond ((= (abs diff) (length l))\n                  #t)\n \
    \                ((> diff 0)\n                  (monotonic (cdr l)))\n       \
    \          ((< diff 0)\n                  (monotonic (reverse l))))))))\n", " \
    \ (cond\n    [(empty? l) true]\n    [(empty? (rest l)) true]\n    [(or (= (first\
    \ l) (first (rest l))) (< (first l) (first (rest l)))) (monotonic (rest l))]\n\
    \    [(or (= (first l) (first (rest l))) (> (first l) (first (rest l)))) (monotonic\
    \ (rest l))]\n    [else false]))\n", "  (define (inc x y) (< x y))\n  (define\
    \ (dec x y) (> x y))\n  (define (cmp? x y)\n    (or (inc x y) (dec x y)))\n  (define\
    \ (mono? x y)\n    (not (and (cmp? x y) (cmp? y x))))\n  (or (apply mono? l) (apply\
    \ cmp? l)))\n", "  (if (null? l)\n      true\n      (if (null? (cdr l))\n    \
    \      true\n          (let ([c1 (car l)]\n                [c2 (car (cdr l))])\n\
    \            (if (&lt; c1 c2)\n                (monotonic (cdr l))\n         \
    \       (if (&gt; c1 c2)\n                    (monotonic (cdr l))\n          \
    \          false))))))\n", "  (let ([prev (first l)])\n    (for/and ([el (in-list\
    \ (rest l))])\n      (and (or (> el prev) (< el prev)) (set! prev el)))))\n",
  "  (if (null? l)\n      #t\n      (let* ((current (car l))\n             (rest (cdr\
    \ l))\n             (increasing? (lambda (last current)\n                    \
    \        (if (null? current)\n                                #t\n           \
    \                     (and (<= last (car current))\n                         \
    \            (increasing? (car current) (cdr current))))))\n             (decreasing?\
    \ (lambda (last current)\n                            (if (null? current)\n  \
    \                              #t\n                                (and (>= last\
    \ (car current))\n                                     (decreasing? (car current)\
    \ (cdr current)))))))\n        (or (increasing? current rest)\n            (decreasing?\
    \ current rest)))))\n", "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n\
    \        [(= (car l) (cadr l)) (monotonic (cdr l))]\n        [(< (car l) (cadr\
    \ l)) (monotonic (cdr l))]\n        [(> (car l) (cadr l)) (monotonic (cdr l))]\n\
    \        [else #f]))\n", "  (or (increasing? l) (decreasing? l)))\n", "  (cond\
    \ [(null? l) True]\n        [(null? (cdr l)) True]\n        [(> (car l) (cadr\
    \ l)) (monotonic (cdr l))]\n        [(< (car l) (cadr l)) (monotonic (cdr l))]\n\
    \        [else False]))\n", "  (cond\n    ((null? l) #t)\n    ((null? (cdr l))\
    \ #t)\n    ((and (< (car l) (cadr l))\n          (monotonic (cdr l))) #t)\n  \
    \  ((and (> (car l) (cadr l))\n          (monotonic (cdr l))) #t)\n    (else #f)))",
  "  (let loop ([l l] [increasing? #t] [decreasing? #t])\n    (cond\n      [(null?\
    \ l) #t]\n      [(null? (cdr l)) #t]\n      [(and (and increasing? (and (number?\
    \ (car l))\n                                  (number? (cadr l))\n           \
    \                       (< (car l) (cadr l))))\n            (and decreasing? (and\
    \ (number? (car l))\n                                  (number? (cadr l))\n  \
    \                                (> (car l) (cadr l)))))\n       (loop (cdr l)\
    \ #t #t)]\n      [(and (and increasing? (and (number? (car l))\n             \
    \                     (number? (cadr l))\n                                  (<\
    \ (car l) (cadr l))))\n            (decreasing? (and (number? (car l))\n     \
    \                         (number? (cadr l))\n                              (>\
    \ (car l) (cadr l)))))\n       (loop (cdr l) #t #f)]\n      [(and (and increasing?\
    \ (and (number? (car l))\n                                  (number? (cadr l))\n\
    \                                  (< (car l) (cadr l))))\n            (not decreasing?))\n\
    \       (loop (cdr l) #t #t)]\n      [(and (and decreasing? (and (number? (car\
    \ l))\n                                  (number? (cadr l))\n                \
    \                  (> (car l) (cadr l))))\n            (not increasing?))\n  \
    \     (loop (cdr l) #f #t)]\n      [(and (and decreasing? (and (number? (car l))\n\
    \                                  (number? (cadr l))\n                      \
    \            (> (car l) (cadr l))))\n            (not increasing?))\n       (loop\
    \ (cdr l) #f #t)]\n      [else #f])))\n", "  (cond\n    [(empty? l) true]\n  \
    \  [(empty? (rest l)) true]\n    [(< (first l) (second l)) (monotonic (rest l))]\n\
    \    [(> (first l) (second l)) (monotonic (rest l))]\n    [else false]))\n```\n\
    \n[Back to problem](#P42)", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l))\
    \ #t]\n    [(and (and (>= (car l) (car (cdr l))) (monotonic (cdr l)))\n      \
    \    (and (<= (car l) (car (cdr l))) (monotonic (cdr l)))) #t]\n    [else #f]))\n",
  "  (cond [(empty? l) #t]\n        [(empty? (rest l)) #t]\n        [(> (first l)\
    \ (second l)) (monotonic-decreasing l)]\n        [(< (first l) (second l)) (monotonic-increasing\
    \ l)]\n        [else #f]))\n", "  (define (iter l first second increasing)\n \
    \   (cond\n      [(empty? l) #t]\n      [(> first second)\n       (and\n     \
    \   (equal? increasing #f)\n        (iter (rest l) second (first l) #f))]\n  \
    \    [(< first second)\n       (and\n        (equal? increasing #t)\n        (iter\
    \ (rest l) second (first l) #t))]\n      [else #f]))\n  (and (not (empty? l))\n\
    \       (iter (rest l) (first l) (first l) #t)))\n", "  (cond\n    [(empty? l)\
    \ #t]\n    [(empty? (rest l)) #t]\n    [(and (>= (first l) (second l)) (monotonic\
    \ (rest l))) #t]\n    [(and (<= (first l) (second l)) (monotonic (rest l))) #t]\n\
    \    [else #f]))\n```\n\n### Problem 8\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(and (negative? (first l)) (positive? (second l)))\
    \ #f]\n    [(and (positive? (first l)) (negative? (second l))) #f]\n    [else\
    \ (monotonic (rest l))]))\n", "  (if (empty? l)\n      #t\n      (define (monotonic-helper\
    \ l dir)\n        (if (empty? l)\n            #t\n            (if (equal? dir\
    \ 'down)\n                (and (>= (car l) (cadr l)) (monotonic-helper (cdr l)\
    \ dir))\n                (and (<= (car l) (cadr l)) (monotonic-helper (cdr l)\
    \ dir)))))\n      (if (and (> (car l) (cadr l)) (< (car l) (cadr l)))\n      \
    \    #f\n          (if (> (car l) (cadr l))\n              (monotonic-helper (cdr\
    \ l) 'down)\n              (monotonic-helper (cdr l) 'up)))))\n", "  (if (= (length\
    \ l) 1)\n      #t\n      (if (list? (rest l))\n          (if (and (>= (car l)\
    \ (car (rest l)))\n                   (monotonic (rest l)))\n              #t\n\
    \              #f)\n          #f)))\n", "  (define (iter l f)\n    (if (or (empty?\
    \ l) (empty? (cdr l))) #t\n        (if (f (car l) (cadr l)) (iter (cdr l) f) #f)))\n\
    \  (let ((cmp (apply-generic > l)))\n    (if (eq? cmp <) (iter l >) (iter l <))))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (mo? l acc)\n    (if (null? l)\n\
    \        #t\n        (cond\n         [(= (car l) (car acc)) (mo? (cdr l) acc)]\n\
    \         [(> (car l) (car acc)) (mo? (cdr l) (cons (car l) acc))]\n         [(<\
    \ (car l) (car acc)) (mo? (cdr l) (cons (car l) acc))]\n         [else #f])))\n\
    \  (mo? (cdr l) (list (car l))))\n", "  (let loop ([l l] [i 0])\n    (if (&lt;\
    \ i (length l))\n        (let ([v (nth l i)])\n          (if (&lt; i 1)\n    \
    \          (loop l (+ i 1))\n              (let ([prev (nth l (- i 1))])\n   \
    \             (if (&lt; v prev)\n                    (if (for/and ([i (in-range\
    \ 0 (- i 1))])\n                                 (&lt; (nth l i) prev))\n    \
    \                    #t\n                        #f)\n                    (if\
    \ (for/and ([i (in-range 0 (- i 1))])\n                                 (&gt;\
    \ (nth l i) prev))\n                        #t\n                        #f)))))\n\
    \        #t)))\n</code>\nIs there a cleaner way to accomplish this?\n\n\nA:\n\n\
    A few other observations:\n\nThere's no reason for <code>i</code> to be an index.\
    \ You could just as well write <code>(loop (cdr l) (car l))</code>.\nYou can use\
    \ <code>&lt;=</code> in your innermost <code>if</code>'s instead of <code>&lt;</code>\
    \ and <code>&gt;</code>.\nYou can get rid of the inner <code>if</code>'s and use\
    \ a <code>cond</code> instead.\n\nHere's what I got:\n<code>(define (monotonic\
    \ l)\n  (let loop ([l l] [prev undefined])\n    (cond\n      [(empty? l) #t]\n\
    \      [(and (defined? prev) (zero? (- (car l) prev))) #f]\n      [else (loop\
    \ (cdr l) (car l))])))\n</code>\nAnd here's a one-liner that uses the <code>in-order?</code>\
    \ procedure from <code>racket/list</code>:\n<code>(define (monotonic l)\n  (in-order?\
    \ &lt;= l))\n</code>\n", "  (cond ((empty? l) #t)\n        ((= (length l) 1) #t)\n\
    \        ((= (length l) 2) \n         (or (= (first l) (second l))\n         \
    \    (= (first l) (- (second l) 1))\n             (= (first l) (+ (second l) 1))))\n\
    \        (else\n         (let ([a (first l)]\n               [b (second l)])\n\
    \           (cond ((= a b) (monotonic (rest l)))\n                 ((< a b) (and\
    \ (monotonic (rest l))\n                               (< (first (rest l)) (second\
    \ (rest l)))))\n                 ((> a b) (and (monotonic (rest l))\n        \
    \                       (> (first (rest l)) (second (rest l))))))))))\n```\n\n\
    ### Solution 4\n\n```#lang racket\n", "  (define (monotonic' l incr)\n    (cond\n\
    \      [(empty? l) true]\n      [(= 1 (length l)) true]\n      [(and (empty? (rest\
    \ l)) (cons? (rest l))) true]\n      [(if incr\n           (<= (first l) (first\
    \ (rest l)))\n           (>= (first l) (first (rest l))))\n       (monotonic'\
    \ (rest l) incr)]\n      [else false]))\n  (cond\n    [(empty? l) true]\n    [(=\
    \ 1 (length l)) true]\n    [(and (empty? (rest l)) (cons? (rest l))) true]\n \
    \   [(and (<= (first l) (first (rest l)))\n          (>= (first l) (first (rest\
    \ l))))\n     true]\n    [(and (< (first l) (first (rest l)))\n          (monotonic'\
    \ (rest l) true))]\n    [(and (> (first l) (first (rest l)))\n          (monotonic'\
    \ (rest l) false))]\n    [else false]))\n", "  (cond\n    [(null? l) #t]\n   \
    \ [(null? (cdr l)) #t]\n    [(< (car l) (cadr l)) (monotonic (cdr l))]\n    [(>\
    \ (car l) (cadr l)) (monotonic (cdr l))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) true]\n    [(empty? (rest l)) true]\n    [(= (first l) (second l)) (monotonic\
    \ (rest l))]\n    [(or (= (first l) (+ (second l) 1)) (= (first l) (- (second\
    \ l) 1)))\n     (monotonic (rest l))]\n    [else false]))\n", "  (if (null? l)\n\
    \      #t\n      (define (helper l1 l2)\n        (if (null? l1)\n            #t\n\
    \            (if (<= (car l1) (car l2))\n                (helper (cdr l1) (cdr\
    \ l2))\n                #f)))\n      (helper (rest l) l)))\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(= (length l) 1) #t]\n    [(< (second l) (first l))\n     (monotonic-decreasing\
    \ (cdr l))]\n    [(> (second l) (first l))\n     (monotonic-increasing (cdr l))]\n\
    \    [else\n     #f]))\n", "  (cond ((null? l) #t)\n        ((= (length l) 1)\
    \ #t)\n        ((not (eq? (signum (sub1 (first l))) (signum (sub1 (second l)))))\
    \ #f)\n        (else (monotonic (rest l)))))\n", "  (cond\n    [(or (empty? l)\
    \ (empty? (rest l))) #t]\n    [(> (first l) (second l)) (monotonic (rest l))]\n\
    \    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n", "  (cond\
    \ ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((< (car l) (cadr l))\
    \ (monotonic (cdr l)))\n        ((> (car l) (cadr l)) (monotonic (cdr l)))\n \
    \       (else #f)))\n", "  (if (empty? l)\n      #t\n      (let ([is-increasing\
    \ (positive? (car l))])\n        (for/and ([x (cdr l)])\n          (cond\n   \
    \         [(positive? x) is-increasing]\n            [(negative? x) (not is-increasing)]\n\
    \            [else (error 'monotonic \"Impossible case\")])))))\n", "  (cond [(null?\
    \ l) true]\n        [(or (and (null? (cdr l)) true)\n             (and (monotonic\
    \ (cdr l))\n                  (or (and (= (car l) (- (cadr l) 1)) true)\n    \
    \                  (and (= (car l) (+ (cadr l) 1)) true)\n                   \
    \   (and (= (car l) (cadr l)) true)\n                      false))) true]\n  \
    \      [else false]))\n", "  (let ((current (first l))\n        (increasing? (first\
    \ l &lt;= (second l))))\n    (for/and ([next (in-list (rest l))])\n      (if increasing?\n\
    \          (&lt;= current next)\n          (&gt;= current next)))))\n</code>\n\
    All the tests pass successfully.\n\n\nA:\n\nYou used <code>for/and</code> and\
    \ <code>in-list</code> where you probably don't need to. The following code should\
    \ work just as well without all the extra baggage.\n<code>(define (monotonic l)\n\
    \  (let ([current (first l)]\n        [increasing? (first l &lt;= (second l))])\n\
    \    (andmap (\u03BB (next)\n              (if increasing?\n                 \
    \ (&lt;= current next)\n                  (&gt;= current next)))\n           \
    \ (rest l))))\n</code>\n", "  (cond [(empty? l) true]\n        [(= (length l)\
    \ 1) true]\n        [(> (first l) (second l)) (monotonic (rest l))]\n        [(<\
    \ (first l) (second l)) (monotonic (rest l))]\n        [else false]))", "  (define\
    \ (all-increasing l)\n    (or (null? l)\n        (and (null? (cdr l))\n      \
    \       true)\n        (and (<= (car l) (cadr l))\n             (all-increasing\
    \ (cdr l)))))\n  (define (all-decreasing l)\n    (or (null? l)\n        (and (null?\
    \ (cdr l))\n             true)\n        (and (>= (car l) (cadr l))\n         \
    \    (all-decreasing (cdr l)))))\n  (or (all-increasing l)\n      (all-decreasing\
    \ l)))\n", "  (cond [(empty? l) true]\n        [(empty? (rest l)) true]\n    \
    \    [(number? (first l))\n         (if (and (= (first l) (second l)) (monotonic\
    \ (rest l)))\n             true\n             (if (and (< (first l) (second l))\
    \ (monotonic (rest l)))\n                 true\n                 (if (and (> (first\
    \ l) (second l)) (monotonic (rest l)))\n                     true\n          \
    \           false)))]\n        [else false]))\n", "  (cond [(null? l) #t]\n  \
    \      [(null? (cdr l)) #t]\n        [(null? (cddr l)) #t]\n        [else\n  \
    \       (let* ([diffs (map - (cdr l) l)]\n                [inc (not (member -1\
    \ diffs))]\n                [dec (not (member 1 diffs))])\n           (or inc\
    \ dec))]))\n", "  (cond ((null? l) #t)\n        ((null? (cdr l)) #t)\n       \
    \ ((> (car l) (cadr l))\n         (and (monotonic (cdr l)) (or (positive? (car\
    \ l)) (negative? (cadr l)))))\n        ((< (car l) (cadr l))\n         (and (monotonic\
    \ (cdr l)) (or (negative? (car l)) (positive? (cadr l)))))))\n", "  (andmap\n\
    \   (\u03BB (x y) (or (> x y) (< x y)))\n   l\n   (rest l)))", "  (cond [(empty?\
    \ l) #t]\n        [(empty? (rest l)) #t]\n        [(< (first l) (second l)) (monotonic\
    \ (rest l))]\n        [(> (first l) (second l)) (monotonic (rest l))]\n      \
    \  [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(null? (cdr l)) #t]\n \
    \   [(and (<= (car l) (cadr l)) (monotonic (cdr l))) #t]\n    [(and (>= (car l)\
    \ (cadr l)) (monotonic (cdr l))) #t]\n    [else #f]))\n", "  (define (f result\
    \ a b)\n    (cond\n      [(empty? l) result]\n      [(or (and (zero? result) (>\
    \ a b))\n           (and (> result 0) (> b a))\n           (and (< result 0) (<\
    \ b a))) #f]\n      [else (f (if (> a b) 1 -1) b (car l))]))\n  (if (null? l)\
    \ #t\n      (f 0 (car l) (cadr l))))\n", "  (let loop ([lst l] [increasing? #t]\
    \ [decreasing? #t])\n    (cond [(empty? lst)\n           (or increasing? decreasing?)]\n\
    \          [(null? (cdr lst))\n           (or increasing? decreasing?)]\n    \
    \      [(and increasing? (< (car lst) (cadr lst)))\n           (loop (cdr lst)\
    \ #t #f)]\n          [(and decreasing? (> (car lst) (cadr lst)))\n           (loop\
    \ (cdr lst) #f #t)]\n          [else #f])))\n", "  (or (monotonic-increasing l)\n\
    \      (monotonic-decreasing l)))\n", "  (cond\n    [(empty? l)\n     #t]\n  \
    \  [(= (length l) 1)\n     #t]\n    [(and (= (length l) 2)\n          (<= (first\
    \ l) (second l)))\n     #t]\n    [(and (= (length l) 2)\n          (>= (first\
    \ l) (second l)))\n     #t]\n    [(<= (first l) (second l))\n     (monotonic (rest\
    \ l))]\n    [(>= (first l) (second l))\n     (monotonic (rest l))]\n    [else\n\
    \     #f]))\n", "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n      \
    \  [(and (<= (car l) (cadr l))\n              (monotonic (cdr l))) #t]\n     \
    \   [(and (>= (car l) (cadr l))\n              (monotonic (cdr l))) #t]\n    \
    \    [else #f]))\n", "  (define (compare l n)\n    (cond [(empty? l) true]\n \
    \         [(or (< n (first l)) (> n (first l))) false]\n          [else (compare\
    \ (rest l) (first l))]))\n  (compare (rest l) (first l)))\n", "  (let* ((len (length\
    \ l))\n         (increasing? (apply (lambda (a b) (< a b)) (take (sub1 len) l)))\n\
    \         (decreasing? (apply (lambda (a b) (> a b)) (take (sub1 len) l))))\n\
    \    (or increasing? decreasing?)))\n", "  (cond\n    [(empty? l) true]\n    [(empty?\
    \ (rest l)) true]\n    [(> (first l) (second l))\n     (if (empty? (rest (rest\
    \ l)))\n         true\n         (if (and (> (second l) (third l)) (monotonic (rest\
    \ (rest l))))\n             true\n             false))]\n    [(< (first l) (second\
    \ l))\n     (if (empty? (rest (rest l)))\n         true\n         (if (and (<\
    \ (second l) (third l)) (monotonic (rest (rest l))))\n             true\n    \
    \         false))]\n    [else false]))\n", "  (define (monotonic_helper lst asc)\n\
    \    (cond\n      [(null? lst) (if asc #t #f)]\n      [(null? (cdr lst)) #t]\n\
    \      [(and (> (car lst) (cadr lst)) (or asc #f))\n       (monotonic_helper (cdr\
    \ lst) #f)]\n      [(and (< (car lst) (cadr lst)) (or (not asc) #f))\n       (monotonic_helper\
    \ (cdr lst) #t)]\n      [else #f]))\n  (cond\n    [(null? l) #t]\n    [(null?\
    \ (cdr l)) #t]\n    [(= (car l) (cadr l)) (monotonic (cdr l))]\n    [(> (car l)\
    \ (cadr l)) (monotonic_helper (cdr l) #f)]\n    [else (monotonic_helper (cdr l)\
    \ #t)]))\n", "  (let ([len (length l)])\n    (define (m l i)\n      (if (< i len)\n\
    \        (if (or (< (list-ref l i) (list-ref l (+ i 1)))\n                (> (list-ref\
    \ l i) (list-ref l (+ i 1))))\n          (m l (+ i 1))\n          #f)\n      \
    \  #t))\n    (m l 0)))\n", "  (define (monotonic-helper l first-element)\n   \
    \ (cond\n      [(null? l) true]\n      [(> (car l) first-element) (monotonic-helper\
    \ (cdr l) (car l))]\n      [(< (car l) first-element) (monotonic-helper (cdr l)\
    \ (car l))]\n      [else false]))\n  (monotonic-helper (cdr l) (car l)))\n", " \
    \ (define (same-sign n)\n    (cond ((= n 0) true)\n          ((> n 0) 'positive)\n\
    \          ((< n 0) 'negative)))\n  (if (null? l)\n      true\n      (let* ([rest\
    \ (cdr l)]\n             [first (car l)]\n             [sign (same-sign (- (car\
    \ rest) first))])\n        (if (null? rest)\n            true\n            (and\
    \ (cond ((eq? sign 'positive) (> (- (car rest) first) 0))\n                  \
    \     ((eq? sign 'negative) (< (- (car rest) first) 0)))\n                 (monotonic\
    \ rest))))))", "  (or (monotonic-increasing l)\n      (monotonic-decreasing l)))\n",
  "  (cond [(null? l) #t]\n        [(null? (cdr l)) #t]\n        [(not (= (cadr l)\
    \ (car l)))\n         (monotonic (cdr l))]\n        [else\n         (and (null?\
    \ (memq (cadr l) (cddr l)))\n              (monotonic (cdr l)))]))\n</code>\n",
  "  (cond [(empty? l)\n         true]\n        [(= (length l) 1)\n         true]\n\
    \        [(< (length l) 3)\n         (or (= (first l) (second l))\n          \
    \   (and (zero? (modulo (first l) (second l)))\n                  (= (first l)\
    \ (* (second l) -1))))]\n        [else\n         (let ([c (modulo (first l) (second\
    \ l))])\n           (if (zero? c)\n               (or (= (first l) (second l))\n\
    \                   (and (zero? (modulo (first l) (third l)))\n              \
    \          (= (first l) (* (third l) -1))))\n               (let ([c2 (modulo\
    \ (second l) (third l))])\n                 (if (zero? c2)\n                 \
    \    (or (= (second l) (third l))\n                         (and (zero? (modulo\
    \ (second l) (last l)))\n                              (= (second l) (* (last\
    \ l) -1))))\n                     (and (or (= (first l) (second l))\n        \
    \                      (and (zero? (modulo (first l) (third l)))\n           \
    \                        (= (first l) (* (third l) -1))))\n                  \
    \        (or (= (second l) (third l))\n                              (and (zero?\
    \ (modulo (second l) (last l)))\n                                   (= (second\
    \ l) (* (last l) -1)))))))))]))\n", "  (cond\n    [(null? l) #t]\n    [(null?\
    \ (cdr l)) #t]\n    [(> (car l) (cadr l)) (and (monotonic (cdr l)) (<= (car l)\
    \ (cadr l)))]\n    [(< (car l) (cadr l)) (and (monotonic (cdr l)) (>= (car l)\
    \ (cadr l)))]\n    [else (monotonic (cdr l))]))\n", "  (let ((trend (cons 'up\
    \ l)))\n    (cond\n      [(null? l) #t]\n      [(null? (cdr l)) #t]\n      [(and\
    \ (cons? trend)\n            (or (and (< (car trend) (cadr trend))\n         \
    \            (monotonic (cdr l)))\n                (and (> (car trend) (cadr trend))\n\
    \                     (monotonic (cdr l)))))\n       #t]\n      [else #f])))\n",
  "  (if (null? l)\n      true\n      (if (< (car l) (cadr l))\n          (monotonic\
    \ (cdr l))\n          (if (< (car l) (cadr l))\n              (monotonic (cdr\
    \ l))\n              true))))\n", "  (define (inc? l)\n    (if (null? (cdr l))\n\
    \        #t\n        (if (< (car l) (cadr l))\n            (inc? (cdr l))\n  \
    \          #f)))\n  (define (dec? l)\n    (if (null? (cdr l))\n        #t\n  \
    \      (if (> (car l) (cadr l))\n            (dec? (cdr l))\n            #f)))\n\
    \  (or (inc? l) (dec? l)))\n", "  (cond\n    [(null? l)\n     #t]\n    [(null?\
    \ (cdr l))\n     #t]\n    [(and (>= (car l) (cadr l)) (monotonic (cdr l)))\n \
    \    #t]\n    [(and (<= (car l) (cadr l)) (monotonic (cdr l)))\n     #t]\n   \
    \ [else\n     #f]))\n```\n\n```\n#lang racket\n", "  (define (helper lst)\n  \
    \  (cond [(empty? lst)\n           #t]\n          [(and (empty? (rest lst))\n\
    \                #t)\n           #t]\n          [(and (empty? (rest (rest lst)))\n\
    \                (cons? (rest lst))\n                #t)\n           #t]\n   \
    \       [(and (< (first lst) (second lst))\n                (helper (rest lst)))\n\
    \           #t]\n          [(and (> (first lst) (second lst))\n              \
    \  (helper (rest lst)))\n           #t]\n          [else\n           #f]))\n \
    \ (helper l))", "  (if (null? l) #t\n      (letrec ([inc (cons #t (map (\u03BB\
    \ (x y) (< x y)) (cdr l) l))]\n               [dec (cons #t (map (\u03BB (x y)\
    \ (> x y)) (cdr l) l))])\n        (or (andmap identity inc)\n            (andmap\
    \ identity dec)))))\n", "  (or (monotonic-increasing l)\n      (monotonic-decreasing\
    \ l)))\n", "  (or (apply <= l)\n      (apply >= l)))\n", "  (cond [(null? l) (error\
    \ \"empty list\")]\n        [(null? (cdr l)) #t]\n        [(< (car l) (cadr l))\n\
    \         (for/and ([el (in-list (cdr l))])\n           (<= (car l) el))]\n  \
    \      [(> (car l) (cadr l))\n         (for/and ([el (in-list (cdr l))])\n   \
    \        (>= (car l) el))]\n        [else #f]))\n", "  (cond [(empty? l) #t]\n\
    \        [(= (length l) 1) #t]\n        [(and (monotonic (rest l))\n         \
    \     (or (= (first l) (first (rest l)))\n                  (< (first l) (first\
    \ (rest l))))) #t]\n        [else #f]))\n", "  (match (length l)\n    [(> 2)\n\
    \     (cond [(> (first l) (second l)) (and (monotonic (rest l)) (< (first l) (second\
    \ l)))]\n           [else (and (monotonic (rest l)) (> (first l) (second l)))])]\n\
    \    [(= 2) (or (> (first l) (second l)) (< (first l) (second l)))]\n    [else\
    \ #t]))\n", "  (define (sign x)\n    (if (< x 0) -1\n        (if (> x 0) 1\n \
    \           0)))\n  (for/or ([i (in-range (length l))])\n    (if (= i 0)\n   \
    \     #t\n        (let ([prev (list-ref l (- i 1))]\n              [curr (list-ref\
    \ l i)])\n          (= (sign (- curr prev))\n             (sign (- (list-ref l\
    \ 0)\n                      (list-ref l 1))))))))\n", "  (cond ((null? l) 'True)\n\
    \        ((null? (cdr l)) 'True)\n        ((> (car l) (cadr l)) (monotonic (cdr\
    \ l)))\n        ((< (car l) (cadr l)) (monotonic (cdr l)))\n        (else 'False)))",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(= (first l) (second\
    \ l)) (monotonic (rest l))]\n    [(> (first l) (second l)) (and (monotonic (rest\
    \ l)) (all < l))]\n    [(< (first l) (second l)) (and (monotonic (rest l)) (all\
    \ > l))]))\n", "  (let ([diff (map (lambda (x y) (- x y)) (cdr l) l)])\n    (eq?\
    \ '() diff)\n    (equal? (remp diff (lambda (x) (<= x 0))) (remp diff (lambda\
    \ (x) (> x 0))))))\n", "  (cond [(null? l) true]\n        [(null? (cdr l)) true]\n\
    \        [(null? (cddr l)) true]\n        [else\n         (= (- (cadr l) (car\
    \ l)) (- (caddr l) (cadr l)))]))\n", "  (or (monotonic-increasing l)\n      (monotonic-decreasing\
    \ l)))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(< (car\
    \ l) (cadr l)) (and (monotonic (cdr l)) #t)]\n    [(> (car l) (cadr l)) (and (monotonic\
    \ (cdr l)) #t)]\n    [else #f]))\n", "  (or (or (and\n           (andmap (lambda\
    \ (x y)\n                     (and (integer? x) (integer? y) (>= x y)))\n    \
    \               l (rest l))\n           (or (apply = l) (apply = (reverse l))))\n\
    \          (and\n           (andmap (lambda (x y)\n                     (and (integer?\
    \ x) (integer? y) (<= x y)))\n                   l (rest l))\n           (or (apply\
    \ = l) (apply = (reverse l)))))\n      (and (andmap integer? l) (or (apply = l)\
    \ (apply = (reverse l))))))", "  (cond ((null? l) #t)\n        ((null? (cdr l))\
    \ #t)\n        ((and (and (and (= (car l) (car (cdr l)))\n                   \
    \   (= (car l) (car (cdr (cdr l)))))\n                    (= (car l) (car (cdr\
    \ (cdr (cdr l))))))\n              (not (= (car l) (car (cdr (cdr (cdr (cdr l))))))))\n\
    \         #t)\n        ((not (or (apply < l) (apply > l))) #f)\n        (else\
    \ #t)))", "  (define (monotonic? l dir)\n    (cond\n      [(null? l) true]\n \
    \     [(null? (cdr l)) true]\n      [(and (= dir 1) (< (car l) (cadr l))) (monotonic?\
    \ (cdr l) dir)]\n      [(and (= dir -1) (> (car l) (cadr l))) (monotonic? (cdr\
    \ l) dir)]\n      [else false]))\n  (let ([a (car l)]\n        [b (cadr l)])\n\
    \    (cond\n      [(= a b) (monotonic? (cdr l) 0)]\n      [(> a b) (monotonic?\
    \ l -1)]\n      [else (monotonic? l 1)])))\n", "  (if (equal? (length l) 1)\n\
    \      #t\n      (if (equal? (length l) 2)\n          (if (equal? (car l) (cadr\
    \ l))\n              #t\n              (if (> (car l) (cadr l))\n            \
    \      (and (> (car l) (cadr l))\n                       (monotonic (cdr l)))\n\
    \                  (and (< (car l) (cadr l))\n                       (monotonic\
    \ (cdr l)))))\n          (if (> (car l) (cadr l))\n              (and (> (car\
    \ l) (cadr l))\n                   (monotonic (cdr l)))\n              (and (<\
    \ (car l) (cadr l))\n                   (monotonic (cdr l)))))))\n", "  (cond\n\
    \    [(empty? l) true]\n    [(cons? l)\n     (define l2 (cdr l))\n     (define\
    \ l1 (car l))\n     (if (empty? l2) true\n       (define l3 (cdr l2))\n      \
    \ (define l2 (car l2))\n       (and\n        (if (< l1 l2)\n            (loop\
    \ [(x l3)]\n              (cond\n                [(empty? x) true]\n         \
    \       [(cons? x)\n                 (define x2 (cdr x))\n                 (define\
    \ x1 (car x))\n                 (if (< x1 x2)\n                     (loop [x2\
    \ x2])\n                     false)]))\n            (loop [(x l3)]\n         \
    \     (cond\n                [(empty? x) true]\n                [(cons? x)\n \
    \                (define x2 (cdr x))\n                 (define x1 (car x))\n \
    \                (if (> x1 x2)\n                     (loop [x2 x2])\n        \
    \             false)])))))]))\n", "  (and (increasing? l) (decreasing? l)))\n",
  "  (define (monotonic-helper l)\n    (if (or (empty? l) (empty? (cdr l)))\n    \
    \    #t\n        (let* ([a (car l)]\n               [b (cadr l)])\n          (and\
    \ (cond ((and (&lt; a b) (&lt;= b (caddr l))) #t)\n                     ((and\
    \ (&gt; a b) (&gt;= b (caddr l))) #t)\n                     (else #f))\n     \
    \          (monotonic-helper (cdr l))))))\n  (monotonic-helper l))\n", "  (or\
    \ (monotonic-increasing l)\n      (monotonic-decreasing l)))\n", "  (cond [(null?\
    \ l) true]\n        [(null? (cdr l)) true]\n        [(< (car l) (cadr l))\n  \
    \       (and (monotonic (cdr l)) true)]\n        [(> (car l) (cadr l))\n     \
    \    (and (monotonic (cdr l)) true)]\n        [else false]))\n", "  (cond [(or\
    \ (empty? l) (empty? (rest l))) #t]\n        [(< (first l) (second l))\n     \
    \    (monotonic-decreasing (rest l))]\n        [(> (first l) (second l))\n   \
    \      (monotonic-increasing (rest l))]\n        [else #f]))\n", "  (if (empty?\
    \ l)\n      #t\n      (define (monotonic-helper l sign)\n        (if (empty? l)\n\
    \            #t\n            (let ([current (first l)]\n                  [next\
    \ (second l)])\n              (if (or (and (> current next) (= sign -1))\n   \
    \                   (and (< current next) (= sign 1)))\n                  (monotonic-helper\
    \ (rest l) sign)\n                  #f))))\n      (let ([first (first l)]\n  \
    \          [second (second l)])\n        (if (= first second)\n            (monotonic-helper\
    \ (rest l) 0)\n            (monotonic-helper (rest l)\n                      \
    \        (if (> first second) -1 1))))))\n```\n\n```racket\n#lang racket\n", " \
    \ (match l\n    [($ (? number? a) (? number? b) ...)\n     (if (or (and (&lt;\
    \ a b) (monotonic (rest l)))\n             (and (&gt; a b) (monotonic (rest l))))\n\
    \         #t\n         #f)]\n    [(else #f)]))\n</code>\nbut this code does not\
    \ work for this example:\n<code>&gt; (monotonic '(1 2 4 20))\n#t\n&gt; (monotonic\
    \ '(1 20 4 10))\n#f\n&gt; (monotonic '(4 1 0 -10))\n#f\n</code>\nWhat's wrong\
    \ with my code?\nThanks.\n\n\nA:\n\nYou can do it like this:\n<code>(define (monotonic\
    \ l)\n  (cond\n    [(empty? l) #t]\n    [(&lt; (first l) (second l)) \n     (every\
    \ &lt; l)]\n    [(&gt; (first l) (second l)) \n     (every &gt; l)]\n    [else\
    \ #f]))\n</code>\nThe pattern here is\n\nCheck if there are enough elements to\
    \ compare.\nCheck if the list is ascending and if it is use <code>every</code>\
    \ to check all elements.\nCheck if the list is descending and if it is use <code>every</code>\
    \ to check all elements.\n\nIf the list has length 1, it will return true.\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or (< (first l)\
    \ (second l)) (> (first l) (second l)))\n     (monotonic (rest l))]\n    [else\
    \ #f]))\n", "  (or (increasing l) (decreasing l)))\n", "  (define (sign x)\n \
    \   (if (&lt; x 0) \n        -1\n        (if (&gt; x 0)\n            1\n     \
    \       0)))\n  (let ([s (sign (vector-ref l 1) - (vector-ref l 0))])\n    (and\
    \ (not (zero? s))\n         (for/and ([v (in-vector l)])\n           (= s (sign\
    \ (- v (vector-ref l 0))))))))\n</code>\n", "  (cond\n    [(empty? l) #t]\n  \
    \  [(empty? (rest l)) #t]\n    [(monotonic-helper (first l) (rest l)) #t]\n  \
    \  [else #f]))\n", "  (cond\n    [(empty? l)\n     #t]\n    [(empty? (rest l))\n\
    \     #t]\n    [(= (first l) (second l))\n     (monotonic (rest l))]\n    [(<\
    \ (first l) (second l))\n     (and (andmap < l (rest l)) (monotonic (rest l)))]\n\
    \    [(> (first l) (second l))\n     (and (andmap > l (rest l)) (monotonic (rest\
    \ l)))]))\n", "  (cond\n    [(empty? l) true]\n    [(<= (first l) (second l))\
    \ (monotonic (rest l))]\n    [(>= (first l) (second l)) (monotonic (rest l))]\n\
    \    [else false]))\n", "  (define (mono l n)\n    (cond [(empty? l) true]\n \
    \         [(= n (first l)) (mono (rest l) n)]\n          [(and (> n (first l))\
    \ (positive? n))\n            (mono (rest l) (first l))]\n          [(and (< n\
    \ (first l)) (negative? n))\n            (mono (rest l) (first l))]\n        \
    \  [else false]))\n  (cond [(empty? l) true]\n        [else (mono (rest l) (first\
    \ l))]))\n", "  (cond\n    [(empty? l) true]\n    [(empty? (rest l)) true]\n \
    \   [(< (first l) (second l)) (monotonic (rest l))]\n    [(> (first l) (second\
    \ l)) (monotonic (rest l))]\n    [else false]))\n", "  (let ([f (car l)])\n  \
    \  (for ([i (cdr l)])\n      (if (> i f)\n          (set! f i)\n          (if\
    \ (< i f)\n              (set! f i)\n              (return #f))))\n    #t))\n",
  "  (and (or (and (not (null? l))\n                (null? (cdr l)))\n           (and\
    \ (not (null? l))\n                (not (null? (cdr l)))\n                (or\
    \ (and (positive? (car l))\n                         (positive? (cadr l)))\n \
    \                   (and (negative? (car l))\n                         (negative?\
    \ (cadr l))))\n                (monotonic (cdr l))))\n       #t))", "  (cond\n\
    \    [(empty? l) #t]\n    [(null? (cdr l)) #t]\n    [(or (> (car l) (cadr l))\
    \ (< (car l) (cadr l)))\n     (monotonic (cdr l))]\n    [else #f]))\n", "  (define\
    \ (monotonic-helper l incr)\n    (cond\n      [(null? l) #t]\n      [(null? (cdr\
    \ l)) #t]\n      [(and incr (not (positive? (- (cadr l) (car l))))) #f]\n    \
    \  [(and (not incr) (not (negative? (- (cadr l) (car l))))) #f]\n      [else (monotonic-helper\
    \ (cdr l) incr)]))\n  (if (null? l) #t\n      (let ([d (- (cadr l) (car l))])\n\
    \        (cond\n          [(positive? d) (monotonic-helper (cdr l) #t)]\n    \
    \      [(negative? d) (monotonic-helper (cdr l) #f)]\n          [else #t]))))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (asc? l)\n    (and (not (null? (cdr\
    \ l)))\n         (or (and (not (null? (cddr l))) (asc? (cdr l)))\n           \
    \  (and (= (car l) (cadr l))\n                  (asc? (cdr l)))\n            \
    \ (< (car l) (cadr l)))))\n  (define (desc? l)\n    (and (not (null? (cdr l)))\n\
    \         (or (and (not (null? (cddr l))) (desc? (cdr l)))\n             (and\
    \ (= (car l) (cadr l))\n                  (desc? (cdr l)))\n             (> (car\
    \ l) (cadr l)))))\n  (if (null? l) true\n      (if (null? (cdr l)) true\n    \
    \      (and (asc? l) (desc? l)))))\n", "  (cond [(empty? l)\n         true]\n\
    \        [(or (empty? (rest l))\n             (and (integer? (first l))\n    \
    \              (integer? (first (rest l)))))\n         (monotonic (rest l))]\n\
    \        [else\n         false]))\n", "  (if (null? l)\n      #t\n      (let ((direction\
    \ (if (< (car l) (cadr l)) 1 -1)))\n        (if (null? (cdr l))\n            #t\n\
    \            (if (= direction (if (< (cadr l) (caddr l)) 1 -1))\n            \
    \    (monotonic (cdr l))\n                #f)))))\n```\n\n```scheme\n#lang racket\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(and (<= (first\
    \ l) (second l)) (monotonic (rest l))) #t]\n    [(and (>= (first l) (second l))\
    \ (monotonic (rest l))) #t]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n\
    \    [(null? (cdr l)) #t]\n    [(and (positive? (diff (car l) (cadr l)))\n   \
    \       (positive? (diff (cadr l) (caddr l))))\n     (monotonic (cdr l))]\n  \
    \  [(and (negative? (diff (car l) (cadr l)))\n          (negative? (diff (cadr\
    \ l) (caddr l))))\n     (monotonic (cdr l))]\n    [else #f]))\n", "  (or (increasing\
    \ l) (decreasing l)))\n", "  (or\n   (monotonic-increasing? l)\n   (monotonic-decreasing?\
    \ l)))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(and (and\
    \ (apply < (cdr l)) (apply < (cdr l)))\n          (monotonic (cdr l))) #t]\n \
    \   [(and (and (apply > (cdr l)) (apply > (cdr l)))\n          (monotonic (cdr\
    \ l))) #t]\n    [else #f]))\n", "  (cond\n    [(empty? l)\n     true]\n    [(=\
    \ (length l) 1)\n     true]\n    [(cond\n       [(< (first l) (second l))\n  \
    \      (> (first l) (second l))])\n     false]\n    [else\n     (monotonic (rest\
    \ l))]))\n", "  (cond\n    [(null? l) #t]\n    [(< (length l) 2) #t]\n    [(<\
    \ (car l) (cadr l)) (monotonic (cdr l))]\n    [(> (car l) (cadr l)) (monotonic\
    \ (cdr l))]\n    [else #f]))", "  (cond\n    [(null? l) true]\n    [(= (length\
    \ l) 1) true]\n    [(< (car l) (cadr l))\n     (monotonic (cdr l))]\n    [(> (car\
    \ l) (cadr l))\n     (monotonic (cdr l))]\n    [else false]))\n", "  (cond [(null?\
    \ l) #t]\n        [(null? (cdr l)) #t]\n        [(or (and (null? (cdr (cdr l)))\n\
    \                  (or (< (car l) (cadr l))\n                      (> (car l)\
    \ (cadr l))))\n             (and (< (car l) (cadr l))\n                  (monotonic\
    \ (cdr l)))) #t]\n        [else #f]))\n", "  (define (loop l increasing)\n   \
    \ (cond\n      [(empty? l) true]\n      [(empty? (rest l)) true]\n      [(equal?\
    \ increasing\n               (cond\n                 [(> (first l) (second l))\
    \ #t]\n                 [(< (first l) (second l)) #f]\n                 [else\
    \ 'equal]))\n       (loop (rest l) increasing)]\n      [else false]))\n  (loop\
    \ l 'equal))\n", "  (cond\n    [(empty? l) #t]\n    [(= (length l) 1) #t]\n  \
    \  [(or (and (positive? (first l))\n            (negative? (second l)))\n    \
    \     (and (negative? (first l))\n            (positive? (second l))))\n     (monotonic\
    \ (rest l))]\n    [(< (first l) (second l))\n     (and (<= (first l) (second l))\n\
    \          (monotonic (rest l)))]\n    [(> (first l) (second l))\n     (and (>=\
    \ (first l) (second l))\n          (monotonic (rest l)))]\n    [else #f]))\n```\n\
    \nHere we use `cond` to match the possible cases and\n`or`/`and` to combine logical\
    \ expressions.\n\n## `Monotonic-Lazy`\n\n```#lang racket\n", "  (cond\n    [(empty?\
    \ l) true]\n    [(= (length l) 1) true]\n    [(< (second l) (first l)) (and (monotonic\
    \ (rest l))\n                                   (monotonic (reverse l)))]\n  \
    \  [(> (second l) (first l)) (monotonic (rest l))]\n    [else false]))\n```\n\n\
    ```racket\n#lang racket\n", "  (define (mono l inc)\n    (cond [(empty? l) true]\n\
    \          [(empty? (rest l)) true]\n          [(inc? (first l) (second l) inc)\
    \ (mono (rest l) inc)]\n          [else false]))\n  (or (mono l true) (mono l\
    \ false)))\n", "  (cond [(empty? l) #t]\n        [(< (first l) (second l)) (and\
    \ (monotonic (rest l)) #t)]\n        [(> (first l) (second l)) (and (monotonic\
    \ (rest l)) #t)]\n        [else #f]))\n", "  (if (null? l)\n      #t\n      (define\
    \ (monotonic-helper l direction)\n        (cond ((null? l) #t)\n             \
    \ ((null? (cdr l)) #t)\n              ((= direction -1) (monotonic-helper (cdr\
    \ l) -1))\n              ((= direction 0) (monotonic-helper (cdr l) (* (- (car\
    \ l) (cadr l))))\n              ((= direction 1) (monotonic-helper (cdr l) 1))\n\
    \              (else #f)))\n      (monotonic-helper l 0)))\n", "  (cond\n    [(null?\
    \ l) (error \"empty list\")]\n    [(null? (cdr l)) #t]\n    [(< (car l) (cadr\
    \ l)) (monotonic (cdr l))]\n    [(> (car l) (cadr l)) (monotonic (cdr l))]\n \
    \   [else #f]))\n", "  (cond\n    ((null? l) #t)\n    ((< (length l) 2) #t)\n\
    \    ((< (car l) (cadr l)) (monotonic (cdr l)))\n    ((> (car l) (cadr l)) (monotonic\
    \ (cdr l)))\n    (else #f)))\n```", "  (if (empty? l) #t\n      (cond ((empty?\
    \ (rest l)) #t)\n            ((< (first l) (second l)) (monotonic (rest l)))\n\
    \            ((> (first l) (second l)) (monotonic (rest l)))\n            (else\
    \ #f))))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #t]\n    [(not\
    \ (number? (first l))) (error \"non number in the list\")]\n    [(not (number?\
    \ (second l))) (error \"non number in the list\")]\n    [(< (first l) (second\
    \ l))\n     (monotonic (rest l))]\n    [(> (first l) (second l))\n     (monotonic\
    \ (rest l))]\n    [else #f]))\n", "  (cond\n    [(empty? l) true]\n    [(= (length\
    \ l) 1) true]\n    [(< (first l) (second l))\n     (monotonic (rest l))]\n   \
    \ [(> (first l) (second l))\n     (monotonic (rest l))]\n    [else false]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(< (first l) (second\
    \ l)) (monotonic (rest l))]\n    [(> (first l) (second l)) (monotonic (rest l))]\n\
    \    [else #f]))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest l)) #t]\n\
    \        [(and (<= (first l) (second l)) (monotonic (rest l))) #t]\n        [(and\
    \ (>= (first l) (second l)) (monotonic (rest l))) #t]\n        [else #f]))", " \
    \ (or (apply <= l)\n      (apply >= l)))\n", "  (let loop ([l l] [inc? #t] [dec?\
    \ #t])\n    (cond\n      [(null? l) #t]\n      [(and inc? (not (negative? (sub1\
    \ (car l)) (cadr l))))\n       (loop (cdr l) #t #f)]\n      [(and dec? (not (positive?\
    \ (sub1 (car l)) (cadr l))))\n       (loop (cdr l) #f #t)]\n      [else #f])))\n",
  "  (if (null? l)\n      #t\n      (or (monotonic-increasing l)\n          (monotonic-decreasing\
    \ l))))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(null?\
    \ (cdr (cdr l))) #t]\n    [else\n     (if (< (car l) (cadr l))\n         (if (and\n\
    \              (monotonic (cdr l))\n              (apply < (cdr l)))\n       \
    \      #t\n             #f)\n         (if (and\n              (monotonic (cdr\
    \ l))\n              (apply > (cdr l)))\n             #t\n             #f))]))\n",
  "  (let ([sl (sort l)])\n    (or (equal? l sl)\n        (equal? l (reverse sl)))))\n",
  "  (cond\n    [(empty? l)\n     #t]\n    [(empty? (rest l))\n     #t]\n    [(< (first\
    \ l) (second l))\n     (and (monotonic (rest l))\n          (apply > (map second\
    \ (partition 2 1 l)) ))]\n    [(> (first l) (second l))\n     (and (monotonic\
    \ (rest l))\n          (apply < (map second (partition 2 1 l)) ))]\n    [else\n\
    \     #f]))", "  (cond [(empty? l) true]\n        [(empty? (rest l)) true]\n \
    \       [(> (first l) (second l)) (monotonic-decreasing (rest l))]\n        [(<\
    \ (first l) (second l)) (monotonic-increasing (rest l))]\n        [else true]))\n",
  "  (cond\n    [(empty? l)\n     true]\n    [(empty? (rest l))\n     true]\n    [(<\
    \ (first l) (second l))\n     (and (monotonic (rest l))\n          (apply < (rest\
    \ l)))]\n    [(> (first l) (second l))\n     (and (monotonic (rest l))\n     \
    \     (apply > (rest l)))]\n    [else\n     false]))\n", "  (cond [(null? l) true]\n\
    \        [(null? (cdr l)) true]\n        [(< (car l) (cadr l))\n         (and\
    \ (monotonic (cdr l))\n              true)]\n        [(> (car l) (cadr l))\n \
    \        (and (monotonic (cdr l))\n              true)]\n        [else false]))\n",
  "  (match l\n    [(and (list x) (? list? rest))\n     (and (monotonic-rec x rest)\
    \ (monotonic rest))]\n    [_\n     #t]))\n", "  (let ([ordered (or (list-sort\
    \ (\u03BB (x y) (&lt; x y)) l)\n                     (list-sort (\u03BB (x y)\
    \ (&gt; x y)) l))])\n    (equal? l ordered)))\n</code>\n", "  (define (is-monotonic?\
    \ l ich)\n    (cond ((null? l) true)\n          ((null? (cdr l)) true)\n     \
    \     ((= (car l) (cadr l)) (is-monotonic? (cdr l) ich))\n          ((and (= (car\
    \ l) (+ (cadr l) ich))\n                (is-monotonic? (cdr l) ich)))\n      \
    \    (else false)))\n  (cond ((null? l) true)\n        ((null? (cdr l)) true)\n\
    \        ((= (car l) (cadr l)) (is-monotonic? (cdr l) 0))\n        ((> (car l)\
    \ (cadr l)) (is-monotonic? (cdr l) -1))\n        ((< (car l) (cadr l)) (is-monotonic?\
    \ (cdr l) 1))\n        (else false)))\n", "  (let ((diff (diff-l l)))\n    (and\
    \ (= (length diff) (- (length l) 1))\n         (every (lambda (x) (= 0 x)) diff))))\n",
  "  (define (mono l)\n    (cond\n      [(null? l) #t]\n      [(null? (cdr l)) #t]\n\
    \      [(> (car l) (cadr l)) (mono (cdr l))]\n      [(< (car l) (cadr l)) (mono\
    \ (cdr l))]\n      [else #f]))\n  (mono l))\n", "  (or (for/and ([x (in-list l)]\n\
    \                [y (in-list (rest l))])\n        (<= x y))\n      (for/and ([x\
    \ (in-list l)]\n                [y (in-list (rest l))])\n        (>= x y))))",
  "  (define (all-equal x y)\n    (= x y))\n  (define (diff x y)\n    (- x y))\n \
    \ (let ([dir (cond\n              [(> (car l) (cadr l)) #f]\n              [(<\
    \ (car l) (cadr l)) #t]\n              [else #f])])\n    (cond\n      [(null?\
    \ l) #t]\n      [(null? (cdr l)) #t]\n      [(all-equal dir (diff (car l) (cadr\
    \ l))) (monotonic (cdr l))]\n      [else #f])))", "  (let ((order 0))\n    (for\
    \ ([element l])\n      (when (not (zero? order))\n        (if (< order 0)\n  \
    \          (set! order (if (< element (cdr element)) 1 0))\n          (set! order\
    \ (if (> element (cdr element)) -1 0))))\n      (set! order (if (< element (cdr\
    \ element)) 1 -1))))\n    (and (not (zero? order)) (> 0 order))))", "  (or (every\
    \ (curry >) l)\n      (every (curry <) l)))\n", "  (define (increasing? l)\n \
    \   (cond\n      [(null? l) #t]\n      [(null? (cdr l)) #t]\n      [(< (car l)\
    \ (cadr l)) (increasing? (cdr l))]\n      [else #f]))\n  (define (decreasing?\
    \ l)\n    (cond\n      [(null? l) #t]\n      [(null? (cdr l)) #t]\n      [(> (car\
    \ l) (cadr l)) (decreasing? (cdr l))]\n      [else #f]))\n  (or (increasing? l)\
    \ (decreasing? l)))\n", "  (if (empty? l)\n      (error \"Empty list\")\n    \
    \  (let ([a (car l)]\n            [rest (cdr l)])\n        (if (empty? rest)\n\
    \            #t\n            (let ([b (car rest)])\n              (if (= a b)\n\
    \                  (monotonic rest)\n                  (if (and (> a b)\n    \
    \                       (every < rest))\n                      #t\n          \
    \            (if (and (< a b)\n                               (every > rest))\n\
    \                          #t\n                          #f))))))))\n```\n\n```python\n\
    def monotonic(l):\n    if not l:\n        raise ValueError(\"Empty list\")\n \
    \   a = l[0]\n    rest = l[1:]\n    if not rest:\n        return True\n    b =\
    \ rest[0]\n    if a == b:\n        return monotonic(rest)\n    if a > b and all(map(lambda\
    \ x: x < b, rest)):\n        return True\n    if a < b and all(map(lambda x: x\
    \ > b, rest)):\n        return True\n    return False\n```\n\n```scala\ndef monotonic(l:\
    \ List[Int]): Boolean = {\n  def go(l: List[Int]): Boolean = l match {\n    case\
    \ Nil      => true\n    case a :: Nil => true\n    case a :: b :: rest => if (a\
    \ == b) go(b :: rest)\n                           else if (a > b && rest.forall(_\
    \ < b)) true\n                           else if (a < b && rest.forall(_ > b))\
    \ true\n                           else false\n  }\n  go(l)\n}\n```\n\n### Average\n\
    \n```racket\n#lang racket\n", "  (let loop ([l l] [acc true])\n    (if (null?\
    \ l)\n        acc\n        (if (<= (first l) (second l))\n            (loop (rest\
    \ l) acc)\n            (loop (rest l) false)))))\n", "  (let loop ([res #t] [lst\
    \ l])\n    (if (or (empty? lst) (empty? (cdr lst)))\n        res\n        (loop\
    \ (and (if (positive? (difference (car lst) (cadr lst)))\n                   \
    \   (> (car lst) (cadr lst))\n                      (< (car lst) (cadr lst)))\n\
    \                  res)\n              (cdr lst)))))\n", "  (cond ((empty? l)\
    \ #t)\n        ((= (first l) (last l)) #t)\n        ((> (first l) (last l)) (monotonic\
    \ (rest l)))\n        ((< (first l) (last l)) (monotonic (rest l)))))\n", "  (cond\
    \ ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((let ((a (car l))\n \
    \              (b (cadr l)))\n           (if (or (= a b) (< a b) (> a b))\n  \
    \             (monotonic (cdr l))\n               #f)))))\n", "  (cond\n    [(empty?\
    \ l) true]\n    [(empty? (rest l)) true]\n    [(= (first l) (second l))\n    \
    \ (monotonic (rest l))]\n    [(< (first l) (second l))\n     (and (monotonic (rest\
    \ l)) (all (lambda (x) (< (first l) x)) (rest l)))]\n    [(> (first l) (second\
    \ l))\n     (and (monotonic (rest l)) (all (lambda (x) (> (first l) x)) (rest\
    \ l)))]))\n", "  (cond ((zero? (sub1 (length l))) #t)\n        ((or (= (first\
    \ l) (second l))\n             (and (> (first l) (second l))\n               \
    \   (monotonic (rest l)))\n             (and (< (first l) (second l))\n      \
    \            (monotonic (rest l)))) #t)\n        (else #f)))\n", "  (if (or (=\
    \ (length l) 1) (= (length l) 2))\n      #t\n      (if (<= (first l) (second l))\n\
    \          (if (monotonic (rest l))\n              #t\n              #f)\n   \
    \       (if (monotonic (rest l))\n              #t\n              #f))))", " \
    \ (or (monotonic-increasing l)\n      (monotonic-decreasing l)))\n", "  (cond\
    \ [(empty? l)\n         #t]\n        [(equal? (car l) (cadr l))\n         (monotonic\
    \ (cdr l))]\n        [(< (car l) (cadr l))\n         (and (monotonic (cdr l))\n\
    \              (<= (car l) (caddr l)))]\n        [(> (car l) (cadr l))\n     \
    \    (and (monotonic (cdr l))\n              (>= (car l) (caddr l)))]))\n", " \
    \ (let\n    ([cmp (lambda (a b) (< a b))])\n    (cond\n      [(empty? l) #t]\n\
    \      [(empty? (rest l)) #t]\n      [(cmp (first l) (second l)) (monotonic (rest\
    \ l))]\n      [(not (cmp (first l) (second l))) #f])))\n", "  (cond ((or (and\
    \ (null? (cdr l)) #t) (and (null? (cdr (cdr l))) #t)) #t)\n        ((= (car l)\
    \ (car (cdr l))) (monotonic (cdr l)))\n        ((< (car l) (car (cdr l))) (monotonic\
    \ (cdr l)))\n        ((> (car l) (car (cdr l))) (monotonic (cdr l)))\n       \
    \ (else #f)))", "  (define (sign l)\n    (if (zero? (first l))\n        0\n  \
    \      (let ([a (first l)]\n              [b (second l)])\n          (if (< a\
    \ b)\n              1\n              -1))))\n  (if (or (null? l) (null? (rest\
    \ l)))\n      #t\n      (if (sign l)\n          (let ([s (sign l)])\n        \
    \    (if (equal? s (sign (rest l)))\n                (monotonic (rest l))\n  \
    \              #f))\n          #f)))\n</code>\nBut I'm getting a false false for\
    \ the last test case, and I can't find why.\n\n\nA:\n\nYou check for strict monotonicity.\n\
    The last sequence you give is not strict monotonic, it is monotonic, if you allow\
    \ <code>4 == 1</code>\nA fix could be\n<code>(define (monotonic l)\n  (define\
    \ (sign l)\n    (if (zero? (first l))\n        0\n        (let ([a (first l)]\n\
    \              [b (second l)])\n          (if (&lt;= a b)\n              1\n \
    \             -1))))\n  (if (or (null? l) (null? (rest l)))\n      #t\n      (if\
    \ (sign l)\n          (let ([s (sign l)])\n            (if (equal? s (sign (rest\
    \ l)))\n                (monotonic (rest l))\n                #f))\n         \
    \ #f)))\n</code>\n", "  (cond\n    [(empty? l) true]\n    [(empty? (rest l)) true]\n\
    \    [(> (car l) (cadr l))\n     (and (monotonic (rest l))\n          (<= (car\
    \ l) (cadr l)))]\n    [(< (car l) (cadr l))\n     (and (monotonic (rest l))\n\
    \          (>= (car l) (cadr l)))]\n    [else true]))\n", "  (cond\n    [(null?\
    \ l) true]\n    [(null? (cdr l)) true]\n    [(< (car l) (cadr l)) (monotonic (cdr\
    \ l))]\n    [(> (car l) (cadr l)) (monotonic (cdr l))]\n    [else false]))\n",
  "  (let loop ([i 0] [b #t])\n    (cond\n      [(= i 1) b]\n      [(< (list-ref l\
    \ i) (list-ref l (- i 1)))\n       (loop (- i 1) #f)]\n      [else (loop (- i\
    \ 1) b)])))\n", "  (let ([delta 0])\n    (andmap (lambda (x)\n              (and\
    \ (lambda (y) (abs (- x y))\n                    (set! delta (abs (- x y)))\n\
    \                    #t)\n                   (lambda (y) (or (= (abs (- x y))\
    \ delta)\n                                   (= (abs (- x y)) 0)))))\n       \
    \     l)))\n", "  (cond ((empty? l) true)\n        ((null? (cdr l)) true)\n  \
    \      ((or (and (positive? (diff (car l) (cadr l)))\n                  (monotonic\
    \ (cdr l)))\n             (and (negative? (diff (car l) (cadr l)))\n         \
    \         (monotonic (cdr l))))\n         true)\n        (else false)))\n", " \
    \ (cond [(empty? l) #t]\n        [(empty? (rest l)) #t]\n        [(or (= (first\
    \ l) (first (rest l)))\n             (and (monotonic (rest l))\n             \
    \     (or (> (first l) (first (rest l)))\n                      (< (first l) (first\
    \ (rest l))))))\n         #t]\n        [else #f]))\n</code>\n", "  (define (helper\
    \ lst inc)\n    (cond\n      [(empty? lst) #t]\n      [(< (first lst) (second\
    \ lst)) (helper (rest lst) #t)]\n      [(> (first lst) (second lst)) (helper (rest\
    \ lst) #f)]\n      [(= (first lst) (second lst)) (helper (rest lst) inc)]))\n\
    \  (helper l #t))\n", "  (define (helper l up)\n    (cond ((null? l) #t)\n   \
    \       ((= (car l) (cadr l)) (helper (cdr l) up))\n          ((or (null? (cdr\
    \ l))\n               (not (if up (< (car l) (cadr l)) (> (car l) (cadr l)))))\
    \ #f)\n          (else (helper (cdr l) up))))\n  (helper l #t))\n", "  (cond ((=\
    \ (length l) 0)\n         #t)\n        ((= (length l) 1)\n         #t)\n     \
    \   ((< (car l) (cadr l))\n         (cond ((> (length l) 2)\n                (monotonic\
    \ (cdr l)))\n               ((= (length l) 2)\n                #t)))\n       \
    \ ((> (car l) (cadr l))\n         (cond ((> (length l) 2)\n                (monotonic\
    \ (cdr l)))\n               ((= (length l) 2)\n                #t)))))\n", " \
    \ (let* ([len (length l)]\n         [el (list-ref l 0)]\n         [first (length\
    \ (filter (lambda (e) (> e el)) (cdr l)))])\n    (if (= 0 first)\n        (if\
    \ (= len 1)\n            #t\n            (monotonic (cdr l)))\n        (let* ([second\
    \ (length (filter (lambda (e) (< e el)) (cdr l)))])\n          (if (= 0 second)\n\
    \              (if (= len 1)\n                  #t\n                  (monotonic\
    \ (cdr l)))\n              #f)))))", "  (cond [(null? l) #t]\n        [(null?\
    \ (cdr l)) #t]\n        [(or (or (and (> (car l) (cadr l)) (monotonic (cdr l)))\n\
    \                 (and (< (car l) (cadr l)) (monotonic (cdr l))))\n          \
    \   #t)\n         #f]))\n", "  (cond\n    [(empty? l) true]\n    [(empty? (rest\
    \ l)) true]\n    [(> (first l) (second l)) (all-negative? (rest l))]\n    [(<\
    \ (first l) (second l)) (all-positive? (rest l))]\n    [else false]))\n", "  (define\
    \ (monotonic? ls p)\n    (match ls\n      ([x] p)\n      ([x y xs]\n       (monotonic?\
    \ (cons y xs)\n                   (if (= p 'unset)\n                       (if\
    \ (> x y) 'decreasing 'increasing)\n                       (if (= (if (string=?\
    \ p 'increasing) (string>? x y) (string<? x y)) #t)\n                        \
    \   p\n                           'not-monotonic))))))\n  (monotonic? l 'unset))\n",
  "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(and (not (null? (cdr\
    \ l)))\n          (> (car l) (cadr l))\n          (monotonic (cdr l))) #t]\n \
    \   [(and (not (null? (cdr l)))\n          (< (car l) (cadr l))\n          (monotonic\
    \ (cdr l))) #t]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(or (positive? (difference (first l) (second l)))\n    \
    \     (negative? (difference (first l) (second l))))\n     (monotonic (rest l))]\n\
    \    [else #f]))\n", "  (define (iter l st)\n    (cond\n      [(empty? l) #t]\n\
    \      [(null? (cdr l)) #t]\n      [(or (equal? st 'increasing) (equal? st 'decreasing))\n\
    \       (if (and (>= (car l) (cadr l)) (<= (car l) (cadr l)))\n           (iter\
    \ (cdr l) st)\n           #f)]\n      [else\n       (if (< (car l) (cadr l))\n\
    \           (iter (cdr l) 'increasing)\n           (iter (cdr l) 'decreasing))]))\n\
    \  (iter l 'undef))\n", "  (define (monotonic? curr next)\n    (cond\n      ((>\
    \ curr next) (cons #t (monotonic? next (rest next))))\n      ((< curr next) (cons\
    \ #t (monotonic? next (rest next))))\n      (else #f)))\n  (if (empty? (rest l))\n\
    \      #t\n      (apply and (monotonic? (first l) (rest l)))))\n", "  (cond\n\
    \    ((null? l) (printf \"True\\n\"))\n    ((null? (cdr l)) (printf \"True\\n\"\
    ))\n    ((> (car l) (cadr l))\n     (cond\n       ((> (car l) (cadr l)) (monotonic\
    \ (cdr l)))\n       ((= (car l) (cadr l)) (monotonic (cdr l)))\n       (else (printf\
    \ \"False\\n\"))))\n    ((< (car l) (cadr l))\n     (cond\n       ((< (car l)\
    \ (cadr l)) (monotonic (cdr l)))\n       ((= (car l) (cadr l)) (monotonic (cdr\
    \ l)))\n       (else (printf \"False\\n\"))))\n    (else (printf \"True\\n\"))))\n",
  "  (cond\n    [(null? l) true]\n    [(or (= (first l) (second l))\n         (and\
    \ (> (first l) (second l))\n              (every (lambda (x) (> x (first l)))\
    \ (rest (rest l))))\n         (and (< (first l) (second l))\n              (every\
    \ (lambda (x) (< x (first l))) (rest (rest l)))))\n     true]\n    [else false]))\n",
  "  (if (null? l)\n      #t\n      (let* ([rest (cdr l)]\n             [next (car\
    \ rest)])\n        (if (null? rest)\n            #t\n            (if (< (car l)\
    \ next)\n                (monotonic (cons next rest))\n                (if (>\
    \ (car l) next)\n                    (monotonic (cons next rest))\n          \
    \          #f))))))\n", "  (cond [(empty? l) #t]\n        [(empty? (rest l)) #t]\n\
    \        [(< (first l) (second l)) (monotonic (rest l))]\n        [(> (first l)\
    \ (second l)) (monotonic (rest l))]\n        [else #f]))\n", "  (cond [(empty?\
    \ l) #t]\n        [(empty? (rest l)) #t]\n        [(empty? (rest (rest l))) #t]\n\
    \        [else\n         (let ([p (first l)]\n               [q (first (rest l)]\n\
    \               [r (first (rest (rest l)))])\n           (and (if (<= p q)\n \
    \                   (>= q r)\n                    (<= q r))\n                (monotonic\
    \ (rest l))))]))\n", "  (if (not (pair? l)) #t\n      (if (not (pair? (cdr l)))\
    \ #t\n          (if (and (>= (car l) (cadr l))\n                   (>= (cadr l)\
    \ (caddr l)))\n              (monotonic (cdr l))\n              (monotonic (cddr\
    \ l))))))\n", "  (let loop ([ls l] [last (first l)] [increasing? #t])\n    (cond\
    \ [(empty? ls) #t]\n          [(not increasing?) (loop (rest ls) (first ls) (not\
    \ (positive? (sub1 (first ls)) last))) ]\n          [(positive? (sub1 (first ls))\
    \ last) (loop (rest ls) (first ls) #t)]\n          [else (loop (rest ls) (first\
    \ ls) #f)])))\n", "  (if (null? l)\n      #t\n      (let* ([a (car l)]\n     \
    \        [b (cadr l)]\n             [c (caddr l)])\n        (cond\n         [(null?\
    \ b) #t]\n         [(null? c) #t]\n         [(< a b c) (monotonic (cdr l))]\n\
    \         [(> a b c) (monotonic (cdr l))]\n         [else #f]))))\n", "  (cond\
    \ [(empty? l) #t]\n        [(empty? (rest l)) #t]\n        [(< (first l) (second\
    \ l))\n         (and (monotonic (rest l)) (empty? (filter (lambda (x) (< x (second\
    \ l))) (rest l))))]\n        [(> (first l) (second l))\n         (and (monotonic\
    \ (rest l)) (empty? (filter (lambda (x) (> x (second l))) (rest l))))]))\n", " \
    \ (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(or (equal? (list-ref\
    \ l 1) (list-ref l 0))\n         (and (< (list-ref l 1) (list-ref l 0))\n    \
    \          (monotonic (cdr l))))\n     #t]\n    [else #f]))\n", "  (cond ((null?\
    \ l) #t)\n        ((= (length l) 1) #t)\n        ((or (and (< (car l) (cadr l))\
    \ (monotonic (cdr l)))\n             (and (> (car l) (cadr l)) (monotonic (cdr\
    \ l)))) #t)\n        (else #f)))\n", "  (let loop ([l l] [pos? #t] [neg? #t])\n\
    \    (cond\n      [(empty? l) #t]\n      [(< (first l) (second l)) (loop (rest\
    \ l) #t #f)]\n      [(> (first l) (second l)) (loop (rest l) #f #t)]\n      [else\
    \ (loop (rest l) pos? neg?)])))", "  (cond\n    [(null? l) #t]\n    [(null? (cdr\
    \ l)) #t]\n    [(> (car l) (cadr l))\n     (and (apply < (cdr l)) (monotonic (cdr\
    \ l)))]\n    [(< (car l) (cadr l))\n     (and (apply > (cdr l)) (monotonic (cdr\
    \ l)))]\n    [else #f]))\n", "  (cond\n    [(empty? l)\n     #t]\n    [(empty?\
    \ (rest l))\n     #t]\n    [(and (and (le? (first l) (second l))\n           \
    \    (monotonic (rest l)))\n          (monotonic (rest l)))\n     #t]\n    [(and\
    \ (and (ge? (first l) (second l))\n               (monotonic (rest l)))\n    \
    \      (monotonic (rest l)))\n     #t]\n    [else\n     #f]))\n</code>\nI used\
    \ <code>le?</code> and <code>ge?</code> instead of <code>&lt;=</code> and <code>&gt;=</code>\
    \ because I though it would help readability.\nIt works fine, but I am not sure\
    \ I need to check twice (and in the same function) if it is monotonically increasing\
    \ or decreasing.\n\n\nA:\n\nA single <code>cond</code> expression is usually not\
    \ a good idea. You could rewrite the above code as a <code>case</code> expression,\
    \ which would make it easier to read:\n<code>(define (monotonic l)\n  (case (first\
    \ l)\n    [prev (cond [(empty? (rest l))  #t]\n                [(monotonic/c prev\
    \ prev (rest l))  #t]\n                [else  #f])]))\n", "  (cond [(empty? l)\
    \ #t]\n        [(or (= (first l) (second l))\n             (and (> (first l) (second\
    \ l))\n                  (monotonic (rest l))))\n         #t]\n        [else #f]))",
  "  (if (null? l)\n      #t\n      (or (null? (cdr l))\n          (and (<= (car l)\
    \ (cadr l))\n               (monotonic (cdr l)))\n          (and (>= (car l) (cadr\
    \ l))\n               (monotonic (cdr l))))))\n", "  (cond\n    [(null? l) #t]\n\
    \    [(null? (cdr l)) #t]\n    [(> (car l) (cadr l))\n     (and (monotonic (cdr\
    \ l)) (not (member (car l) (cdr l)))))\n    [(< (car l) (cadr l))\n     (and (monotonic\
    \ (cdr l)) (not (member (car l) (cdr l))))]\n    [else\n     #f]))\n", "  (cond\
    \ ((null? l) #t)\n        ((null? (cdr l)) #t)\n        ((let ((a (car l))\n \
    \              (b (cadr l)))\n           (and (or (< a b) (> a b))\n         \
    \       (monotonic (cdr l)))))))\n", "  (or (or (apply < l) (apply > l))\n   \
    \   #f))\n", "  (cond [(empty? l) true]\n        [(empty? (rest l)) true]\n  \
    \      [(> (first l) (second l)) (monotonic (rest l))]\n        [(< (first l)\
    \ (second l)) (monotonic (rest l))]\n        [else false]))\n", "  (define (inc?\
    \ a b) (< a b))\n  (define (dec? a b) (> a b))\n  (or (monotonic-increasing? l)\
    \ (monotonic-decreasing? l)))\n", "  (if (or (empty? l)\n          (null? (cdr\
    \ l)))\n      #t\n      (let ((first (car l))\n            (second (cadr l)))\n\
    \        (if (> first second)\n            (and (monotonic (cons second (cddr\
    \ l)))\n                 #t)\n            (and (monotonic (cons second (cddr l)))\n\
    \                 #t)))))", "  (letrec ([monotonic-help (lambda (l)\n        \
    \                     (cond [(empty? l) '()]\n                               \
    \    [(< (first l) (second l))\n                                    (cons (first\
    \ l) (monotonic-help (rest l)))]\n                                   [(> (first\
    \ l) (second l))\n                                    (cons (first l) (monotonic-help\
    \ (rest l)))]\n                                   [else (first l)]))])\n    (cond\
    \ [(empty? l) #f]\n          [(= (length l) 1) #t]\n          [(> (length l) 1)\n\
    \           (if (and (not (empty? (monotonic-help l)))\n                    (or\
    \ (= (first (monotonic-help l)) (last l))\n                        (if (and (equal?\
    \ (second (monotonic-help l)) (first l))\n                                 (equal?\
    \ (first (monotonic-help l)) (second l)))\n                            #t\n  \
    \                          #f)))\n               #t\n               #f)]\n   \
    \       [else #f])))\n", "  (for/and ([x l] [y (in-list (cdr l))])\n    (or (<\
    \ x y) (> x y))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
