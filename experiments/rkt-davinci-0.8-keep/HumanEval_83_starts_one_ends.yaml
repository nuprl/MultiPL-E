name: HumanEval_83_starts_one_ends
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the count of the numbers\
  \ of n-digit\n;; positive integers that start or end with 1.\n(define (starts_one_ends\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate starts_one_ends))\n\
  \    (check-equal? (candidate 1) 1)\n    (check-equal? (candidate 2) 18)\n    (check-equal?\
  \ (candidate 3) 180)\n    (check-equal? (candidate 4) 1800)\n    (check-equal? (candidate\
  \ 5) 18000)\n))\n\n(test-humaneval)"
completions: ["  (define (help n d)\n    (if (= n 1)\n        1\n        (+ (help\
    \ (- n 1) (expt 10 (- d 1)))\n           (* d 9))))\n  (help n n))\n</code>\n\
    The solution is <code>(expt 10 (- n 1))</code> for the number of n-digit positive\
    \ integers with the first digit <code>1</code>, and the last digit <code>1</code>\
    \ is <code>(expt 10 (- n 1))</code>. The answer will be the sum of these two solutions.\n",
  "  ; the +1 is to account for the case when the number starts or ends with 1\n \
    \ (+1 (+ (string-length (number->string (expt 10 (- n 1))))\n\t (string-length\
    \ (number->string (+ 1 (expt 10 (- n 1))))))))\n", "  (cond\n    [(= n 1) 2]\n\
    \    [(= n 2) 12]\n    [else (exact->inexact (+ (expt 10 (- n 1)) (expt 10 (-\
    \ n 2))))]))\n", "  (if (zero? n) 0\n      (if (= n 1) 2\n          (+ (* n 9)\
    \ 1))))", "  ;; The number of numbers that start with 1 are the number of numbers\
    \ with n\n  ;; digits minus the numbers with n-1 digits. For example, with 3 digits\
    \ there\n  ;; are 111, 121, ..., 911. With 2 digits there are 11, 21, ..., 91.\
    \ And, with\n  ;; 3 digits there are 1002 numbers that start with 1 and with 2\
    \ digits there\n  ;; are 100, so 902 numbers that start with 1 have 3 digits and\
    \ 900 numbers\n  ;; that start with 1 have 2 digits.\n  (- (expt 10 n)\n     (expt\
    \ 10 (- n 1)))\n  ;; Now, given a number, we can flip all digits except the first\
    \ and last,\n  ;; which must be 1. For example, with 3 digits, we can flip digits\
    \ on 11X,\n  ;; 121, ..., 91X. With 2 digits, we can flip digits on 1X.\n  (*\
    \ (expt 10 (- n 2))\n     (expt 10 1)))\n", "  (match n\n    [(= 1 1) 1]\n   \
    \ [(= 2 2) 10]\n    [(= 3 3) 19]\n    [(= 4 4) 27]\n    [(= 5 5) 34]\n    [(=\
    \ 6 6) 40]\n    [(= 7 7) 45]\n    [(= 8 8) 49]\n    [(= 9 9) 52]\n    [(= 10 10)\
    \ 55]\n    [(= 11 11) 57]\n    [(= 12 12) 59]\n    [(= 13 13) 60]\n    [(= 14\
    \ 14) 61]\n    [(= 15 15) 62]\n    [(= 16 16) 63]\n    [(= 17 17) 63]\n    [(=\
    \ 18 18) 64]\n    [(= 19 19) 64]\n    [(= 20 20) 65]\n    [(= 21 21) 65]\n   \
    \ [(= 22 22) 66]\n    [(= 23 23) 66]\n    [(= 24 24) 67]\n    [(= 25 25) 67]\n\
    \    [(= 26 26) 68]\n    [(= 27 27) 68]\n    [(= 28 28) 69]\n    [(= 29 29) 69]\n\
    \    [(= 30 30) 70]\n    [(= 31 31) 70]\n    [(= 32 32) 71]\n    [(= 33 33) 71]\n\
    \    [(= 34 34) 72]\n    [(= 35 35) 72]\n    [(= 36 36) 73]\n    [(= 37 37) 73]\n\
    \    [(= 38 38) 74]\n    [(= 39 39) 74]\n    [(= 40 40) 75]\n    [(= 41 41) 75]\n\
    \    [(= 42 42) 76]\n    [(= 43 43) 76]\n    [(= 44 44) 77]\n    [(= 45 45) 77]\n\
    \    [(= 46 46) 78]\n    [(= 47 47) 78]\n    [(= 48 48) 79]\n    [(= 49 49) 79]\n\
    \    [(= 50 50) 80]\n    [(= 51 51) 80]\n    [(= 52 52) 81]\n    [(= 53 53) 81]\n\
    \    [(= 54 54) 82]\n    [(= 55 55) 82]\n    [(= 56 56) 83]\n    [(", "  (cond\n\
    \    [(= n 1) 2]\n    [(= n 2) 9]\n    [else\n     (+ (expt 10 (- n 1)) (* (-\
    \ n 1) 9))]))\n</code>\nI've written this to support arbitrary-length input, but\
    \ I'm pretty sure that's too much. Is my approach correct? What is a more efficient\
    \ solution?\nThe problem is from Project Euler with the following sample data:\n\
    <code>Inputs:  Outputs:", "  (if (= n 1)\n      2\n      (define (ends n)\n  \
    \      (if (= n 1)\n            2\n            (+ (ends (- n 1))\n           \
    \    (expt 10 (- n 1)))))\n      (+ (ends n)\n         (expt 10 (- n 1)))))\n",
  "  (expt (expt 10 (- n 1)) 2))\n", "  (expt (1+ (expt 2 (1- n))) 2))\n", "  (cond\
    \ [(<= n 1) 1]\n        [else (+ (expt 10 (- n 1))\n                 (starts_one_ends\
    \ (- n 1)))]))\n", "  (cond\n    ((= n 1) 1)\n    ((= n 2) 10)\n    (else\n  \
    \   (let* ([x (starts_one_ends (- n 1))]\n            [a (- (* x 10) (* x 1))]\n\
    \            [b (* (* x 9) (* (- (expt 10 (- n 2)) 1)))])\n       (+ a b)))))\n",
  "  (cond\n    [(= n 1) 10]\n    [(= n 2) 91]\n    [else (+ (* 99 (expt 10 (- n 2)))\
    \ (starts_one_ends (- n 1)))]))\n", "  (if (= n 1)\n      2\n      (+ (starts_one_ends\
    \ (- n 1))\n         (integer-length (expt 10 (- n 1))))))\n</code>\n", "  (define\
    \ (starts_one_ends-iter n count)\n    (cond [(equal? n 1) (+ count 1)]\n     \
    \     [(equal? n 0) count]\n          [else (starts_one_ends-iter (- n 1) (+ (*\
    \ n 10) count))]))\n  (starts_one_ends-iter n 0))\n", "  (let loop ([i 0] [c 0])\n\
    \    (if (= 0 i)\n        c\n        (loop (- i 1) (+ c (count (build_number n\
    \ i)))))))\n", "  (define (helper d)\n    (cond\n      [(zero? d) 1]\n      [(zero?\
    \ (remainder d 2)) (helper (quotient d 2))]\n      [else\n       (* 2 (helper\
    \ (quotient d 2)))]))\n  (if (or (zero? n) (&lt; n 0)) 0 (helper (expt 10 n))))\n",
  "  (cond [(= n 1) 2]\n        [(= n 2) 9]\n        [else (+ (* 9 (expt 10 (- n 2)))\n\
    \                 (* 2 (starts_one_ends (- n 1))))]))\n", "  (define (starts_one_ends-helper\
    \ n s e)\n    (if (= n 1)\n        (if (or (= s 1) (= e 1))\n            1\n \
    \           0)\n        (let ([sum 0])\n          (for ([d (in-range 1 10)])\n\
    \            (set! sum (+ sum (starts_one_ends-helper (- n 1) s d)))\n       \
    \     (set! sum (+ sum (starts_one_ends-helper (- n 1) d e))))\n          sum)))\n\
    \  (starts_one_ends-helper n 1 1))\n", "  (define (helper n)\n    (cond\n    \
    \  [(= n 1) 1]\n      [(= n 2) 1]\n      [else (+ (* (expt 10 (- n 2)) 9) (helper\
    \ (- n 1)))]))\n  (helper n))\n", "  (count-le (expt 10 n) (lambda (i) (or (equal?\
    \ 1 (remainder i 10))\n                                        (equal? 1 (quotient\
    \ i (expt 10 (- n 1))))))))\n", "  (define (counts c)\n    (cond\n      [(equal?\
    \ c 0) (list 1 1)]\n      [(equal? c 1) (list 1 1)]\n      [else (let ([xc (counts\
    \ (- c 1))])\n              (list (+ (car xc) (cadr xc))\n                   \
    \ (car xc)))]))\n  (cadr (counts n)))\n", "  (cond [(= n 1)\n         2]\n   \
    \     [(> n 1)\n         (+ (expt 10 (- n 1))\n            (starts_one_ends (-\
    \ n 1)))]))\n</code>\nAny help would be greatly appreciated.\n\n\nA:\n\nSo, there\
    \ are 10 possible starting digits, and 10 possible ending digits, so there are\
    \ 100 possible 1-digit numbers that begin or end with 1.\nThere are 10 possible\
    \ starting digits, and (starts_one_ends 1) possible possible ending digits, so\
    \ there are 10 * (starts_one_ends 1) possible 2-digit numbers that begin or end\
    \ with 1.\nThere are 10 possible starting digits, and (starts_one_ends 2) possible\
    \ possible ending digits, so there are 10 * (starts_one_ends 2) possible 3-digit\
    \ numbers that begin or end with 1.\nThere are 10 possible starting digits, and\
    \ (starts_one_ends 3) possible possible ending digits, so there are 10 * (starts_one_ends\
    \ 3) possible 4-digit numbers that begin or end with 1.\nSo, every number starting\
    \ with 1 can be extended with any number of digits, so there are 10 * (starts_one_ends\
    \ (n-1)) starting with 1.\nEvery number ending with 1 can be prefixed with any\
    \ number of digits, so there are 10 * (starts_one_ends (n-1)) ending with 1.\n\
    But the number that start and end with 1 have been counted twice, so it needs\
    \ to be subtracted. This is starts_one_ends(n-2) because we're looking at the\
    \ number of n-digit numbers that start and end with 1, not n-2-digit numbers that\
    \ start and end with 1, so it's the the number of (n-2)-digit numbers that start\
    \ and end with 1, which is the same as the number of (n-2)-digit numbers.\nSo,\
    \ the total number of n-digit numbers that start or end with 1 is:\n<code>(define\
    \ (starts_one_ends n)\n  (cond [(= n 1)\n         2]\n        [(&gt; n 1)\n  \
    \       (+ (* 10 (starts_one_ends (- n 1)))\n            (* 10 (starts_one_ends\
    \ (- n 1)))\n            (- (", "  (+ (starts_one_ends_r n)\n     (starts_one_ends_l\
    \ n)))\n", "  (if (= n 1)\n      1\n      (+\n       (*\n        9\n        (expt\
    \ 10 (- n 1)))\n       (*\n        9\n        (expt 10 (- n 2)))\n       1)))",
  "  (define (starts-one-ends-helper i s)\n    (cond\n      [(= i 1) (if (positive?\
    \ s) s 0)]\n      [(= i n) (starts-one-ends-helper (- i 1) (+ s (expt 10 (- i\
    \ 1))))]\n      [else (starts-one-ends-helper (- i 1) (+ s (* 2 (expt 10 (- i\
    \ 1)))))]))\n  (starts-one-ends-helper n 0))\n", "  (cond\n    [(zero? n) 0]\n\
    \    [(equal? n 1) 9]\n    [else (+ (* 9 (expt 10 (- n 2))) (starts_one_ends (-\
    \ n 1)))]))\n", "  (cond\n    [(zero? n) 1]\n    [else\n     (+ (count-ones n\
    \ 0) (count-ones n 1))]))\n", "  (cond\n    [(= 1 n) 10]\n    [(= 2 n) 99]\n \
    \   [else (let\n             ([count (starts_one_ends (- n 1))])\n           (+\
    \ count\n              (* 9 10 (- n 2))\n              (starts_one_ends (- n 2))))]))\n\
    </code>\n", "  (cond [(zero? n) 0]\n        [(= n 1) 2]\n        [else (count-matches\
    \ #rx\"^1.+|.+1$\"\n                             (with-output-to-string (\u03BB\
    () (displayln (build-list n number->string)))))]))\n", "  (let* ((x (expt 10 (-\
    \ n 1)))\n         (y (if (&gt; n 1) (- (expt 10 n) 1) 1)))\n    (if (= n 1) 1\
    \ (- y (* 2 x)))))\n", "  (define (ones_prefix n)\n    (cond\n      [(= n 1) 1]\n\
    \      [(> n 1) (let ((nn (exact-floor (sqrt n))))\n                 (+ 1 (for/sum\
    \ ([i (in-range 1 (add1 nn))])\n                      (exact-floor (/ n i)))))]))\n\
    \  (define (ones_suffix n)\n    (cond\n      [(= n 1) 1]\n      [(> n 1) (let\
    \ ((nn (exact-floor (sqrt n))))\n                 (+ 1 (for/sum ([i (in-range\
    \ 1 (add1 nn))])\n                      (exact-floor (/ n i)))))]))\n  (+ (ones_prefix\
    \ n) (ones_suffix n)))\n", "  ;; The number of integers that start with 1 is 10^(n-1)\n\
    \  (+ (* (expt 10 (- n 1)) 9)\n     ;; The number of integers that end with 1\
    \ is 9 times\n     ;; the number of (n-1)-digit integers.\n     (* 9 (starts_one_ends\
    \ (- n 1)))))\n", "  (if (= n 1)\n      1\n      (+ (expt 10 (- n 1))\n      \
    \   (expt 9 (- n 1)))))\n", "  (define (pow x y)\n    (if (= y 0)\n        1\n\
    \        (* x (pow x (- y 1)))))\n  (define (sum-starts s n)\n    (cond\n    \
    \  [(= n 1) s]\n      [(= n 0) 0]\n      [else (+ (sum-starts s (- n 1))\n   \
    \            (sum-starts (- (* (pow 10 n) 10) (* (pow 10 (- n 1)) 9)) (- n 1)))]))\n\
    \  (+ (sum-starts 9 n)\n     (sum-starts (- (* (pow 10 n) 10) (* (pow 10 (- n\
    \ 1)) 9)) (- n 1))))\n", "  (define (starts/ends i)\n    (if (&lt;= i 1)\n   \
    \     1\n        (+ (starts/ends (- i 1)) (expt 10 (- i 1)))))\n  (starts/ends\
    \ n))\n</code>\nHow would I go about making this function tail-recursive?\nIn\
    \ my first thought, I would need an argument <code>k</code> to represent the partial\
    \ result (ie <code>k * 10^(n-1)</code>), but I'm not sure how to use it.\n\n\n\
    A:\n\nA straightforward tail-recursive version would be:\n<code>(define (starts-one-ends\
    \ n)\n  (define (starts/ends i k)\n    (if (&lt;= i 1)\n        k\n        (starts/ends\
    \ (- i 1) (+ k (* 10 (- i 1))))))\n  (starts/ends n 1))\n</code>\nHowever, I don't\
    \ see any real advantage of this solution over the non-tail-recursive one.\n",
  "  (define (ends-helper d)\n    (if (= d 2) 1\n        (+ (ends-helper (- d 1))\
    \ (power 10 (- d 2)))))\n  (+ (ends-helper n) (ends-helper (- n 1))))\n", "  (cond\n\
    \    [(zero? n) 1]\n    [else (+ (starts_one_ends (- n 1)) (expt 10 (- n 1)))]))\n",
  "  (define (loop n acc)\n    (if (zero? n)\n        acc\n        (loop (- n 1) (+\
    \ acc (^ 10 (- n 1))))))\n  (+ (loop n 0) (loop (- n 1) 0)))\n", "  (if (< n 2)\n\
    \      1\n      (+ (expt 10 (- n 1))\n         (expt 9 (- n 1)))))\n", "  (let\
    \ ([d (1+ (- n 1))]) ; For n-digit numbers, I need d zeros after the one\n   \
    \ (if (= n 1)\n        1\n        (+ (expt 10 (- n 1)) ; Numbers starting with\
    \ 1 and ending with 0-9\n           (- (expt 10 d) ; Numbers ending with 1 and\
    \ starting with 0-9 (less than 11)\n              (expt 10 (- d 1)) ; Numbers\
    \ that start and end with 1 (less than 101)\n              )))))\n", "  (let ([base\
    \ (expt 10 (- n 1))])\n    (+ (* n base) base)))\n", "  (let loop ([n (- n 1)])\n\
    \    (cond\n      [(zero? n) 2]\n      [else (+ (expt 10 n) (loop (- n 1)))])))\n\
    </code>\nThe larger <code>n</code> is, the longer the result is. For instance,\
    \ for <code>n = 6</code> the result is 11,111,111 and for <code>n = 7</code> the\
    \ result is 111,111,111.\n", "  (let* ([half (quotient n 2)]\n         [result\
    \ (if (even? n) (- (expt 10 half) 1) (expt 10 (- half 1)))]\n         [subs (sub1\
    \ (expt 10 (- half 1)))])\n    (+ result (- (expt 10 half) subs))))\n</code>\n",
  "  (let loop ([n (fixnum->bigfix n)]\n             [count 0])\n    (cond [(zero?\
    \ n) count]\n          [(= n 1) (+ count 1)]\n          [else\n           (loop\
    \ (- n 1)\n                 (+ count\n                    (quotient (- n) 10)))])))\n",
  "  (cond [(= n 1) 2]\n        [(= n 2) 4]\n        [else\n         (+ (* 2 (starts_one_ends\
    \ (- n 1)))\n            (* 4 (starts_one_ends (- n 2))))]))\n", "  (if (= n 1)\n\
    \      2\n      (if (= n 2)\n          (define (num_digits n) (+ n 1))\n     \
    \     (if (= n 3)\n              (define (num_digits n) (+ n 3))\n           \
    \   (if (= n 4)\n                  (define (num_digits n) (+ n 4))\n         \
    \         (if (= n 5)\n                      (define (num_digits n) (+ n 5))\n\
    \                      (if (= n 6)\n                          (define (num_digits\
    \ n) (+ n 6))\n                          (if (= n 7)\n                       \
    \       (define (num_digits n) (+ n 7))\n                              (if (=\
    \ n 8)\n                                  (define (num_digits n) (+ n 8))\n  \
    \                                (if (= n 9)\n                               \
    \       (define (num_digits n) (+ n 9))\n                                    \
    \  (if (= n 10)\n                                          (define (num_digits\
    \ n) (+ n 10))\n                                          (define (num_digits\
    \ n) (+ n 11))))))))))))))\n", "  (if (= n 1)\n      1\n      (+ (expt 10 (- n\
    \ 1)) (* 9 n) (starts_one_ends (- n 1)))))\n", "  (cond\n    [(<= n 1)\n     1]\n\
    \    [else\n     (+ 1 (starts_one_ends (- n 1)))]))\n", "  (cond\n    [(= n 1)\
    \ 2]\n    [(= n 2) 5]\n    [else (+ (starts_one_ends (- n 1))\n             (starts_one_ends\
    \ (- n 2)))]))\n", "  (if (zero? n)\n      0\n      (+ (starts_one_ends (- n 1))\n\
    \         (expt 2 (- n 1)))))\n", "  (cond\n    ((= n 1) 2)\n    ((= n 2) 3)\n\
    \    (else (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2))))))\n", "  (define\
    \ (reducer acc x)\n    (cond\n      [(= 0 (remainder x 10)) acc]\n      [(= 1\
    \ (remainder x 10)) (+ 1 acc)]\n      [else acc]))\n  (for/fold ([acc 0]) ([i\
    \ (in-range 1 (expt 10 n))])\n    (reducer acc i)))\n", "  (define (helper n)\n\
    \    (if (= n 1)\n        1\n        (+ (if (= n 2)\n               1\n      \
    \         0)\n           (* (expt 10 (- n 2))\n              (+ 9 1)))))\n  (+\
    \ (helper n)\n     (helper (- n 1))))\n", "  (letrec ([in-range? (lambda (x) (and\
    \ (&lt;= 1 x) (&lt;= x n)))]\n           [first-digit (lambda (x) (quotient x\
    \ (expt 10 (- x 1))))]\n           [count-start-ones (lambda (n)\n           \
    \                    (if (in-range? n)\n                                   (+\
    \ (count-start-ones (+ n 1))\n                                      (if (= 1 (first-digit\
    \ n)) 1 0))\n                                   0))]\n           [count-end-ones\
    \ (lambda (n)\n                             (if (in-range? n)\n              \
    \                   (+ (count-end-ones (+ n 1))\n                            \
    \        (if (= 1 (remainder n 10)) 1 0))\n                                 0))])\n\
    \    (+ (count-start-ones 1) (count-end-ones 1))))\n", "  (if (= n 1)\n      2\n\
    \      (+ (* 10\n            (starts_one_ends (- n 1)))\n         (expt 10 (-\
    \ n 2)))))\n", "  (let loop ([n n] [count 0])\n    (cond\n      [(zero? n) count]\n\
    \      [(and (< 0 (remainder n 10)) (< (remainder n 10) 10)) (loop (quotient n\
    \ 10) (+ count 1))]\n      [else (loop (quotient n 10) count)])))\n```\n\n```\n\
    #lang racket\n", "  (match n\n    [0 1]\n    [1 1]\n    [2 3]\n    [3 13]\n  \
    \  [4 53]\n    [5 (starts_one_ends (- n 2))]\n    [6 (starts_one_ends (- n 2))]\n\
    \    [n (starts_one_ends (- n 2))]))\n</code>\nHow can I solve this with recursion\
    \ instead of the match form?\n<code>(define (starts_one_ends n)\n  (cond [(= n\
    \ 0) 1]\n        [(= n 1) 1]\n        [(= n 2) 3]\n        [(= n 3) 13]\n    \
    \    [(= n 4) 53]\n        [else (starts_one_ends (- n 2))]))\n</code>\nI think\
    \ I need more cond clauses but I'm not sure how to handle the case where <code>n</code>\
    \ is 5 or 6.\n\n\nA:\n\nThe solution for <code>n = 5</code> is a little bit different\
    \ than <code>n &gt;= 6</code>.\n<code>(define (starts_one_ends n)\n  (cond [(=\
    \ n 0) 1]\n        [(= n 1) 1]\n        [(= n 2) 3]\n        [(= n 3) 13]\n  \
    \      [(= n 4) 53]\n        [(= n 5) (starts_one_ends (- n 2))]\n        [else\
    \ (+ (starts_one_ends (- n 2)) (starts_one_ends (- n 1)))]))\n</code>\n", "  (define\
    \ (pow x y)\n    (if (= 0 y)\n        1\n        (* x (pow x (- y 1)))))\n  (define\
    \ (num_digits n)\n    (if (&lt; n 10)\n        1\n        (+ 1 (num_digits (/\
    \ n 10)))))\n  (define (num_digits_up_to n)\n    (if (= n 0)\n        0\n    \
    \    (+ n (num_digits_up_to (- n 1)))))\n  (- (num_digits_up_to (pow 10 n))\n\
    \     (num_digits_up_to (pow 10 (- n 1)))))\n", "  (cond\n    [(= n 1) 2]\n  \
    \  [(= n 2) 12]\n    [else (add1 (starts_one_ends (- n 1))\n                (*\
    \ (- n 1) (starts_one_ends (- n 2))))]))\n", "  (if (= n 1)\n      2\n      (+\
    \ (* n 9) (starts_one_ends (- n 1)))))\n</code>\nOne more solution, which is not\
    \ as elegant as the above one but is simple and fast. In the <code>starts_one_ends</code>\
    \ function, we can consider each digit as a factor and calculate the number of\
    \ numbers as follows:\n<code>#lang racket\n", "  (cond\n    [(= n 1) 1]\n    [(=\
    \ n 2) 2]\n    [else (+ (starts_one_ends (- n 1))\n             (starts_one_ends\
    \ (- n 2)))]))\n</code>\n", "  (expt 10 (- n 1)))\n", "  (cond\n    [(zero? n)\
    \ 0]\n    [(equal? n 1) 10]\n    [else (+ (* 10 (starts_one_ends (- n 1)))\n \
    \            (power 10 (- n 2)))]))", "  (if (= n 1)\n      2\n      (+ (expt\
    \ 10 (- n 1)) (expt 10 (- n 2)))))", "  (expt 2 (- n 1)))\n", "  (if (< n 10)\n\
    \      (exact-integer->inexact n)\n      (+ (starts_one_ends (- n 1)) (starts_one_ends\
    \ (- n 10)))))\n```\n\n```racket\n#lang racket\n", "  (define (power x n)\n  \
    \  (cond\n      [(= n 0) 1]\n      [else (* x (power x (- n 1)))]))\n  (if (=\
    \ n 1)\n      1\n      (+ (* (- (power 10 (- n 1)) 1) 2)\n         (starts_one_ends\
    \ (- n 1)))))\n</code>\nIs there any better way to implement this?\n\n\nA:\n\n\
    Consider the following two things:\n\nAll numbers of 1 digit (1-9) always start\
    \ and end with 1.\nAll numbers of more than 1 digit that start with 1 are made\
    \ up of:\na. the last digit which is 1\nb. the first digit which is always 1,\
    \ so we don't need to consider that\nc. all possible numbers of the remaining\
    \ digits, which can be calculated recursively.\n\nWe need to handle the case of\
    \ 1 digit separately, because it's a base case. Otherwise, we just calculate the\
    \ answer recursively with the given <code>n</code> and <code>n-1</code> digits.\n\
    <code>(define (starts-one-ends n)\n  (if (= n 1)\n      9\n      (+ (starts-one-ends\
    \ (- n 1))\n         (* (starts-one-ends (- n 1)) 9))))\n</code>\n", "  (cond\
    \ [(= n 1) 2]\n        [(= n 2) 4]\n        [else (+ (* (expt 10 (- n 2)) 3) (starts_one_ends\
    \ (- n 1)))]))\n</code>\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 9]\n    [else\
    \ (+ (* 9 (expt 10 (- n 1)))\n             (* 10 (starts_one_ends (- n 1))))]))\n",
  "  (cond\n    [(zero? n)\n     1]\n    [else\n     (+ (expt 10 (- n 1))\n      \
    \  (starts_one_ends (- n 1)))]))\n", "  (cond [(= n 1) 3]\n        [(= n 2) 9]\n\
    \        [else (+ (expt 2 (- n 2)) (* 3 (expt 2 (- n 3))))]))\n", "  (if (= n\
    \ 1) 2\n      (+ 2 (- (expt 10 (- n 1)) (expt 10 (- (/ n 2) 1))))))\n", "  ; TODO:\
    \ build n-digit numbers that start or end with 1.\n  )\n", "  (count (range (expt\
    \ 10 (- n 1)) (expt 10 n))\n         (lambda (n) (regexp-match? #rx\"^1.*$|^.*1$\"\
    \ (number->string n)))))\n", "  (let ((f (lambda (k)\n\t     (if (eq? k 0) 1\n\
    \t\t (* 10 (- (expt 10 k) 1))))))\n    (if (eq? n 1) 1\n\t(+ (f (- n 1)) (f (-\
    \ n 2))))))\n", "  ;; Let's define `maximum' as the maximum number of n-digit\
    \ positive integers\n  ;; (the pattern of repetition of numbers being 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9).\n  (define maximum (expt 10 n))\n  ;; The number of n-digit\
    \ positive integers that start with 1 is the number of\n  ;; (n-1)-digit positive\
    \ integers.\n  (define starting-with-one (- maximum (expt 10 (- n 1))))\n  ;;\
    \ The number of n-digit positive integers that end with 1 is the number of\n \
    \ ;; (n-1)-digit positive integers that start with 1.\n  (define ending-with-one\
    \ starting-with-one)\n  ;; The result is the sum of these two values.\n  (+ starting-with-one\
    \ ending-with-one))\n</code>\n", "  (let loop ([digits n] [ans 0])\n    (cond\
    \ [(zero? digits) (+ 1 ans)]\n          [(one? digits) (+ (expt 10 (- digits 1))\
    \ ans)]\n          [else (loop (- digits 1) (+ (expt 10 (- digits 2)) ans))])))\n",
  "  (define (helper num)\n    (if (= n 1)\n        1\n        (+ (if (= (modulo num\
    \ 10) 1) 1 0)\n           (helper (quotient num 10)))))\n  (helper n))\n", " \
    \ (let loop ([n n] [a 1] [b 1])\n    (match n\n      [0 b]\n      [n\n       (loop\
    \ (- n 1)\n             (* a 10)\n             (+ (* a 9) b))])))\n", "  (if (zero?\
    \ n)\n      0\n      (+ 1 (starts_one_ends (- n 1)))))\n</code>\nIf the number\
    \ of digits is non-zero, then it is the number of n-digit numbers that start with\
    \ 1 plus the number of (n-1)-digit numbers that start with 1. \n", "  (let* ((a\
    \ (expt 10 (- n 1)))\n         (b (expt 10 n)))\n    (cond ((= n 1) 2)\n     \
    \     ((= n 2) 9)\n          (else (- (* 2 a) b)))))\n", "  (define (iter s n)\n\
    \    (cond\n      ((= n 1) (+ (power 10 (sub1 s)) 1))\n      ((= n 2)\n      \
    \ (+ (power 10 s)\n          (power 10 (sub1 s))\n          (power 10 (sub1 s))))\n\
    \      (else (+\n             (power 10 s)\n             (power 10 (sub1 s))\n\
    \             (power 10 (sub1 s))\n             (expt 10 (sub1 s))))))\n  (iter\
    \ (sub1 n) n))\n", "  (let loop ([i (quotient (- (expt 10 n) 1) 9)])\n    (if\
    \ (= n 1)\n        i\n        (loop (quotient (- (expt 10 i) 1) 9)))))\n</code>\n\
    This has a runtime of O(log(n)) and I'm confident that it's correct. My question\
    \ is, how can I prove this? That is, how can I prove that the solution is correct,\
    \ and that it has the claimed runtime?\n", "  (define (count n)\n    (cond\n \
    \     [(= n 1) 2]\n      [(= n 2) 3]\n      [else (+ (count (- n 1)) (count (-\
    \ n 2)))]))\n  (count n))\n", "  ;; returns a count of the number of n-digit positive\
    \ integers which are not\n  ;; formed by prepending a zero to an (n-1)-digit positive\
    \ integer\n  (define (non_prepend n)\n    (cond [(= n 1) 1]\n          [(= n 2)\
    \ 11]\n          [else (+ (* 10 (non_prepend (- n 1)))\n                   (non_prepend\
    \ (- n 2)))]))\n  (define (prepend n)\n    (cond [(= n 1) 1]\n          [(= n\
    \ 2) 11]\n          [else (+ (* 9 (prepend (- n 1)))\n                   (prepend\
    \ (- n 2)))]))\n  (+ (non_prepend n) (prepend n)))", "  (define (build xs)\n \
    \   (cond\n      [(null? xs) 0]\n      [(zero? (car xs))\n       (build (cdr xs))]\n\
    \      [(zero? (cdr xs))\n       (add1 (build (cdr xs)))]\n      [else\n     \
    \  (let ([xs (cdr xs)])\n         (if (zero? (car xs))\n             (build xs)\n\
    \             (add1 (build xs))))]))\n  (build (iota n 0)))\n", "  (if (= 1 n)\n\
    \      2 ;; 0 and 1\n      (if (= 2 n)\n          9\n          (* (+ 2 n) 9))))\n",
  "  (unless (= n 1)\n    (+ (expt 10 (- n 1)) 1)))\n", "  (cond\n    [(equal? n 1)\
    \ 2]\n    [else (add1 (starts_one_ends (sub1 n)))]))\n", "  (local [(define (sum-digits\
    \ n)\n            (define (sum-digits-iter n sum)\n              (if (= n 0)\n\
    \                  sum\n                  (sum-digits-iter (quotient n 10) (+\
    \ sum (remainder n 10)))))\n            (sum-digits-iter n 0))]\n    (if (= n\
    \ 1)\n        1\n        (+ (starts_one_ends (- n 1)) (sum-digits (expt 10 (-\
    \ n 1)))))))\n```\n\n```racket\n#lang racket\n", "  (define (helper n current)\n\
    \    (if (= n 1)\n        (if (or (= current 1) (= current 9))\n            1\n\
    \            0)\n        (if (or (= current 1) (= current 9))\n            (+\
    \ (helper (- n 1) (+ current 2)) ; The last digit is 1 or 9\n               (helper\
    \ (- n 1) (- current 2))) ; The last digit is 0 or 8\n            (helper (- n\
    \ 1) (+ current 2))))) ; The last digit is 2, 3, ..., 7\n  (helper n 0))\n", " \
    \ (define (helper i)\n    (define (help i)\n      (if (= i 0) 0\n          (+\
    \ (expt 10 i)\n             (help (- i 1)))))\n    (cond ((= i 0) 0)\n       \
    \   ((= i 1) n)\n          ((= i 2) (help (- n 1)))\n          (else (+ (help\
    \ (- n 1))\n                   (help (- n 2))))))\n  (helper n))\n</code>\nThis\
    \ generates the same results as the original code for all but the base case. I'm\
    \ using recursion, but I'm not really sure how the problem is being solved. If\
    \ someone could explain what I'm missing that would be great. Thanks!\n\n\nA:\n\
    \nI think this is a bit of a trick question.  The cases that have n-digits are\
    \ pretty easy to count as you did.  But the numbers with n+1 digits can either\
    \ start with 1, or end with 1.  If they start with 1, it means the remaining n\
    \ digits can either start or end with 1, and there are starts_one_ends(n) of them.\
    \  And there are starts_one_ends(n) of them that end with 1 too.  So there are\
    \ twice as many numbers with n+1 digits as there are with n.  So\n<code>(define\
    \ (starts_one_ends n)\n  (if (= n 1) 1 (* 2 (starts_one_ends (- n 1)))))\n</code>\n",
  "  (let ([p (expt 10 (- n 1))])\n    (+ (add1 (expt p n)) p)))\n", "  (if (eq? n\
    \ 1)\n      10\n      (+ (* 10 (- (expt 10 (- n 1)) (expt 10 (- n 2)))) (starts_one_ends\
    \ (- n 1)))))\n</code>\nIs there any way to improve the performance of this function?\n\
    \n\nA:\n\nLet's define a new function <code>f</code> that takes a single argument\
    \ <code>n</code> and returns the number of <code>n</code>-digit numbers that start\
    \ or end with <code>1</code>. The function <code>starts_one_ends</code> just calls\
    \ <code>f</code> on <code>n</code> and <code>n - 1</code>.\nFirst, let's restate\
    \ the problem a bit. There are nine \"prefixes\" of length <code>n - 1</code>\
    \ that we can append to <code>1</code>, giving us nine numbers with length <code>n</code>\
    \ that start with <code>1</code>. Then, we have nine \"suffixes\" of length <code>n\
    \ - 1</code> that we can prepend to <code>1</code>, giving us nine more numbers\
    \ with length <code>n</code> that end with <code>1</code>. Then, there are nine\
    \ <code>n - 2</code>-digit numbers that start with <code>1</code> and nine <code>n\
    \ - 2</code>-digit numbers that end with <code>1</code>. Therefore, we have\n\
    <code>(define (f n)\n  (+ (* 9 (- n 1)) (* 9 (- n 1)) (f (- n 2))))\n</code>\n\
    Which is exactly the same as your function.\n", "  (cond [(= n 1) 1]\n       \
    \ [(= n 2) 10]\n        [else\n         (+ (expt 9 (- n 1)) (starts_one_ends (-\
    \ n 1)))]))\n", "  (define (starts_one_ends_help d)\n    (cond\n      [(= d n)\
    \ 1]\n      [(= d 1) 1]\n      [else\n       (+ (starts_one_ends_help (- d 1))\n\
    \          (starts_one_ends_help (- d 2)))]))\n  (starts_one_ends_help n))\n",
  "  ;; We are going to calculate the count of n-digit numbers that start with\n \
    \ ;; 1 and of n-digit numbers that end with 1. The total is the sum of these\n\
    \  ;; numbers minus the number of n-digit numbers starting and ending with 1.\n\
    \  ;; But we are also counting numbers of the form 100...1 (one 1), so we need\n\
    \  ;; to subtract this number, too.\n  (if (= n 1)\n      1\n      (+\n      \
    \ (-\n        (+\n         (starts_one_ends (- n 1)) ; Numbers that start with\
    \ 1\n         (starts_one_ends (- n 1))) ; Numbers that end with 1\n        (starts_one_ends\
    \ (- n 2))) ; Numbers that start and end with 1\n       (-\n        (expt 10 (-\
    \ n 1)) ; Numbers of the form 100...1\n        1)))) ; The number 100...1\n</code>\n\
    This appears to be the solution:\n<code>&gt; (starts_one_ends 9)\n512\n</code>\n",
  "  (for/sum ([i (in-range 1 n)])\n    (* (+ (expt 10 (- n i)) (expt 10 i)) 10)))\n",
  "  (let loop ([n (- n 1)])\n    (cond [(zero? n)\n           0]\n          [(zero?\
    \ (- n 1))\n           1]\n          [else\n           (+ (loop (- n 1))\n   \
    \           (loop (- n 2)))])))\n</code>\n\n<code>#lang racket\n", "  (let-values\
    \ ([(good-count bad-count) (starts_one_ends_inner n)])\n    (+ good-count bad-count)))\n",
  "  (define (starts_one_ends-helper i)\n    (if (= 1 i)\n        0\n        (+ (expt\
    \ 10 (- i 1)) (starts_one_ends-helper (- i 1)))))\n  (+ (starts_one_ends-helper\
    \ n) (starts_one_ends-helper (- n 1))))\n", "  (cond\n    ((&lt; n 2) 1)\n   \
    \ ((= n 2) 10)\n    (else\n     (+\n      (* 9 (expt 10 (- n 2)))\n      (starts_one_ends\
    \ (- n 1))))))\n", "  (starts_one_ends_helper n n (number->string n)))\n", " \
    \ (if (= 1 n)\n      0\n      (+\n       ;; starts with one\n       (expt 10 (-\
    \ n 1))\n       ;; ends with one\n       (expt 10 (- n 1))\n       ;; doesn't\
    \ start or end with one\n       (starts_one_ends (- n 1)))))\n", "  (let ([first-digit\
    \ (/ n 10)]\n        [last-digit  (% n 10)])\n    (cond\n      [(zero? first-digit)\n\
    \       (if (zero? last-digit)\n           1\n           (+ 1 (starts_one_ends\
    \ (/ n 10))))]\n      [(and (zero? last-digit)\n            (not (zero? first-digit)))\n\
    \       (starts_one_ends (/ n 10))]\n      [else 2])))\n", "  (if (eq? n 1) 1\n\
    \      (+ (expt 10 (- n 1)) (starts_one_ends (- n 1)))))\n", "  (let ([d (string->number\
    \ (string-reverse (number->string n)))]\n        [diff (sub1 (expt 10 (sub1 n)))]\n\
    \        [s (* n (expt 9 (sub1 n)))])\n    (if (zero? n)\n        0\n        (+\
    \ 1\n           (if (and (> n 1) (> diff 1))\n               (* n (- s diff) diff)\n\
    \               s)))))\n", "  (cond\n    [(= 1 n) 10]\n    [(= 2 n) 18]\n    [(=\
    \ 3 n) 28]\n    [(= 4 n) 40]\n    [(= 5 n) 54]\n    [(= 6 n) 70]\n    [(= 7 n)\
    \ 88]\n    [(= 8 n) 108]\n    [(= 9 n) 130]\n    [(= 10 n) 154]\n    [(= 11 n)\
    \ 180]\n    [(= 12 n) 208]\n    [(= 13 n) 238]\n    [(= 14 n) 270]\n    [(= 15\
    \ n) 304]\n    [(= 16 n) 340]\n    [(= 17 n) 378]\n    [(= 18 n) 418]\n    [(=\
    \ 19 n) 460]\n    [(= 20 n) 504]\n    [(= 21 n) 550]\n    [(= 22 n) 598]\n   \
    \ [(= 23 n) 648]\n    [(= 24 n) 700]\n    [(= 25 n) 754]\n    [(= 26 n) 810]\n\
    \    [(= 27 n) 868]\n    [(= 28 n) 928]\n    [(= 29 n) 990]\n    [(= 30 n) 1054]\n\
    \    [(= 31 n) 1120]\n    [(= 32 n) 1188]\n    [(= 33 n) 1258]\n    [(= 34 n)\
    \ 1330]\n    [(= 35 n) 1404]\n    [(= 36 n) 1480]\n    [(= 37 n) 1558]\n    [(=\
    \ 38 n) 1638]\n    [(= 39 n) 1720]\n    [(= 40 n) 1804]\n    [(= 41 n) 1890]\n\
    \    [(= 42 n) 1978]\n    [(= 43 n) 2068]\n    [(= 44 n) 2160]\n    [(= 45 n)\
    \ 2254]\n    [(= 46 n) 2350]\n    [(= 47 n) 2448]\n    [(= 48 n) 2548]\n    [(=\
    \ 49 n) 2650]\n    [(= 50 n) 2754]\n    [(= 51 n) 2860]\n    [(= 52 n) 2968]\n\
    \    [(= 53 n) 3078]\n   ", "  (define (f n)\n    (if (or (= n 1) (= n 0))\n \
    \       1\n        (+ (f (- n 1))\n           (f (- n 2)))))\n  (define (g n)\n\
    \    (if (= n 1)\n        10\n        (+ (g (- n 1))\n           10\n        \
    \   (f (- n 2)))))\n  (+ (g n)\n     (f (- n 1))))\n", "  (if (= n 1)\n      1\n\
    \      (+ (expt 10 (- n 1))\n         (starts_one_ends (- n 1)))))\n", "  (cond\
    \ [(= n 1) 2]\n        [(= n 2) 11]\n        [else (+ (starts_one_ends (- n 1))\
    \ (starts_one_ends (- n 2)))]))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n\
    \    [else (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2)))]))\n", "  ;;\
    \ check for valid n\n  (if (= n 1) 1\n    (letrec ([d (expt 10 (- n 1))]\n   \
    \          [h (+ d (- d (/ d 10)))]\n             [e (- d (- d (/ d 10)))])\n\
    \      (+ h e))))\n", "  (+ (expt 10 (- n 1))\n     (expt 10 (- n 2))))\n", " \
    \ (let loop ([i (expt 10 (- n 1))] [j 1] [k 0])\n    (if (< i 1)\n        k\n\
    \        (if (and (< i 10) (positive? (remainder i 10)))\n            (loop (-\
    \ i 1) j (+ k 1))\n            (loop (- i 1) j k)))))\n", "  (define (starts_ends\
    \ n i)\n    (if (= n 1)\n        1\n        (+ (* (expt 10 (sub1 n)) i)\n    \
    \       (* (expt 10 (sub1 n))\n              (starts_ends (sub1 n) (+ i 1))))))\n\
    \  (starts_ends n 1))\n", "  (cond [(= 1 n) 2]\n        [(= 2 n) 3]\n        [else\
    \ (+ (starts_one_ends (- n 1))\n                 (starts_one_ends (- n 2)))]))\n",
  "  (if (= n 1)\n      2\n      (+ (expt 10 (- n 1)) (expt 10 (- n 2)))))\n", " \
    \ (let ((result 0))\n    (do ([i 1 (+ i 1)])\n        ((< i n) result)\n     \
    \ (set! result (+ result (power 10 (- n i)))))))\n", "  (let ([max-n (expt 10\
    \ n)])\n    (cond [(= n 1) 1]\n          [(= n 2) 10]\n          [else (- max-n\
    \ (+ 1 (* (- max-n 2) (- max-n 1))))])))\n", "  (if (= n 1) 1\n      (letrec ((ends\
    \ (lambda (n)\n                       (if (= n 1) 1\n                        \
    \   (let ((no_ends (ends (- n 1))))\n                             (+ no_ends (*\
    \ no_ends 9)))))\n                     (starts (lambda (n)\n                 \
    \              (if (= n 1) 1\n                                   (let ((no_starts\
    \ (starts (- n 1))))\n                                     (+ no_starts (* no_starts\
    \ 8)))))))\n        (+ (ends n) (starts n)))))\n</code>\nThis seems like a problem\
    \ that should have a closed form, but I can't\nsee what it is.", "  (let loop\
    \ ([acc 0] [i (expt 10 (- n 1))])\n    (if (zero? i)\n        acc\n        (loop\
    \ (+ acc (if (zero? (modulo i 10)) 0 1))\n              (- i 1)))))\n", "  (let*\
    \ ([min-n-digit-int (expt 10 (- n 1))]\n         [max-n-digit-int (sub1 (expt\
    \ 10 n))])\n    (- max-n-digit-int min-n-digit-int)))\n", "  (let ([10 (expt 10\
    \ (dec n))])\n    (let loop ([n (- n 1)])\n      (cond [(zero? n) 10]\n      \
    \      [else (+ 10 (* 10 (expt 10 (dec n))) (loop (dec n)))]))))\n</code>\nThe\
    \ first result is from taking the number of <code>n</code>-digit numbers that\
    \ start with a <code>1</code> and subtracting the number of <code>n</code>-digit\
    \ numbers that don't end with a <code>1</code>.\n<code>;; Given a positive integer\
    \ n, return the count of the numbers of n-digit", "  (define (helper n)\n    (cond\n\
    \      ((= n 0) #f)\n      ((= n 1) 1)\n      ((> n 1) (+ (* n (expt 10 (- n 1)))\
    \ (helper (- n 1))))))\n  (+ (helper n) (helper (- n 1))))\n", "  (let ((digits\
    \ (- n 1)))\n    (+ 9\n       (for/sum ([i (in-range (+ 1 digits))])\n       \
    \  (expt 10 i)))))\n</code>\n<code>#lang racket\n", "  (cond\n    [(zero? n) (error\
    \ \"starts_one_ends: received zero\")]\n    [(equal? n 1) 2]\n    [else (add1\
    \ (multiply 2 (expt 10 (- n 1))))]))\n", "  (count-number-of-n-digit-positives-that-start-or-end-with-1\
    \ n 0))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 3]\n        [else (+ (count-ends\
    \ n) (count-starts n))]))\n", "  (define (helper a)\n    (cond\n      ((= 1 a)\
    \ a)\n      ((< 1 a)\n       (+ (expt 10 (- a 1))\n          (helper (- a 1))))))\n\
    \  (+ (helper n)\n     (helper (- n 1))))\n", "  ;; The task here is to return\
    \ the number of digits where the first digit is\n  ;; 1, the second digit is either\
    \ 0 or a number between 1 and 8, and the third\n  ;; digit is 1.\n  (define (inner\
    \ n)\n    (cond\n      [(zero? n) 1]\n      [(= n 1) 0]\n      [else\n       (+\n\
    \        (inner (- n 1))\n        (inner (- n 2)))]))\n  (*\n   (inner n)\n  \
    \ (- 9 (+ 2 (expt 10 (- n 2))))))\n", "  (define (ends n)\n    (cond\n      [(zero?\
    \ n) 1]\n      [(one? n) 9]\n      [else (ends (sub1 n))]))\n  (* 2 (ends n)))\n",
  "  (define (count i n)\n    (cond\n      [(= n 0) 1]\n      [(< i 10) (count (+\
    \ i 1) (- n 1))]\n      [else (+ (count 1 (- n 1)) (count (+ i 1) (- n 1)))]))\n\
    \  (count 1 n))\n", "  (define (count_helper d)\n    (cond\n      [(= d 1) 2]\n\
    \      [(= d 2) 3]\n      [else (+ (count_helper (- d 1)) (count_helper (- d 2)))]))\n\
    \  (count_helper n))\n", "  (if (zero? n)\n      1\n      (if (one? n)\n     \
    \     3\n          (+ (expt 2 (- n 1))\n             (expt 10 (- n 2))))))\n",
  "  (cond [(= n 1) 1]\n        [(= n 2) 9]\n        [else (+ (starts_one_ends (-\
    \ n 1))\n                 (starts_one_ends (- n 2)))]))\n", "  (define (count\
    \ d)\n    (let ([n (expt 10 d)])\n      (if (zero? d)\n          0\n         \
    \ (+ (expt 10 (- d 1))\n             (modulo n 10)\n             (- n 1)))))\n\
    \  (cond [(zero? n) 0]\n        [(zero? (modulo n 10)) (+ 1 (count (- n 1)))]\n\
    \        [else (count (- n 1))]))\n", "  (cond\n    [(zero? n) 1]\n    [else (+\
    \ (expt 10 (- n 1))\n             (expt 10 (- n 2)))]))\n</code>\nYour code example\
    \ doesn't have the base case of the recursion.  I'll leave that to you to fix.\n\
    I do recommend against giving a function name and an argument the same name. \
    \ I renamed the argument to the function.\n", "  (if (= n 1)\n      2\n      (count\
    \ (range (expt 10 (- n 1)) (expt 10 n)) \n             (lambda (x) (or (equal?\
    \ (remainder x 10) 1)\n                             (equal? (remainder (quotient\
    \ x (expt 10 (- n 1))) 10) 1))))))\n</code>\nThis results in the correct answer.\
    \ In fact, I can even modify it to test all positive integers:\n<code>#lang racket\n",
  "  (let* ([lower (expt 10 (- n 1)))\n         [upper (expt 10 n)])\n    (for/fold\
    \ ([result 0]) ([i (in-range lower upper)])\n      (cond\n        [(= 0 (modulo\
    \ i 10)) result]\n        [(= 1 (modulo i 10)) (add1 result)]\n        [else (add1\
    \ result)]))))\n</code>\nWhen I run this, I get:\n<code>&gt; (starts_one_ends\
    \ 1)\n1\n&gt; (starts_one_ends 2)\n20\n&gt; (starts_one_ends 3)\n300\n&gt; (starts_one_ends\
    \ 5)\n30000\n</code>\nWhich is the right answer.\n", "  (define (count-1-digit\
    \ n)\n    (cond [(= n 1) 2]\n          [(= n 2) 3]\n          [else (+ 2 (count-1-digit\
    \ (- n 1)))]))\n  (cond [(= n 1) 2]\n        [(= n 2) 3]\n        [else (+ 1 (count-1-digit\
    \ (- n 1)) (count-1-digit (- n 2))))]))\n", "  (cond\n    [(zero? n)\n     0]\n\
    \    [(one? n)\n     1]\n    [else\n     (+ 1 (starts_one_ends (- n 1)))]))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 2]\n    [else (add1 (+ (starts_one_ends\
    \ (sub1 n)) (starts_one_ends (sub1 n))))]))\n", "  (define (base n)\n    (expt\
    \ 10 n))\n  (define (ends-one n)\n    (- (base n) (/ (base n) 10)))\n  (define\
    \ (starts-one n)\n    (- (* 10 (base (- n 1))) (/ (base (- n 1)) 10)))\n  (+ (ends-one\
    \ n) (starts-one n)))\n</code>\nThis is a question from Cracking the Coding Interview.\
    \ I have my own code as above, and I've looked at a few answers in the Google\
    \ results, but none of them seem to be correct. My code seems to be working, and\
    \ I've tested all the results I could.\nCan anyone offer any suggestions on how\
    \ to fix the algorithm, or why it's not working?\n\n\nA:\n\nThere are many ways\
    \ to count this. For example, you could just list all the possibilities. If you\
    \ have 3 digits, then you could start with\n<code>100\n101\n...\n199\n201\n...\n\
    999\n</code>\nSo you get 900 values total. You could also use algebra to solve\
    \ this problem. If you have n digits, then the number of possibilities is <code>10^(n-1)</code>.\
    \ \nAfter some experimentation, I think that your code works for all n except\
    \ for n=1. The problem for n=1 is that you have the expression <code>(base (-\
    \ n 1))</code>, which is evaluated as <code>(base 0)</code>, which is undefined.\
    \ You need to replace this expression with an <code>if</code> statement.\n", " \
    \ (count-values \n   (lambda (s) \n     (and (string-prefix? \"1\" s)\n      \
    \    (string-suffix? \"1\" s)))\n   (generate-strings n)))\n", "  (let loop ([n\
    \ n] [num 1] [count 0])\n    (if (= n 1)\n        count\n        (loop (- n 1)\
    \ (* num 10) (+ count (loop (- n 1) num count))))))\n", "  (cond\n    [(= n 1)\
    \ 2]\n    [(= n 2) 10]\n    [else\n     (let ([n_minus_one (starts_one_ends (-\
    \ n 1))])\n       (+ (* n_minus_one 10)\n          (if (odd? n) (* n_minus_one\
    \ n_minus_one) (* n_minus_one n_minus_one (- n_minus_one)))))])\n  )\n</code>\n\
    I could work it out. But I cannot find the pattern. Can someone help me?\n\n\n\
    A:\n\nUsing your approach, the problem is easier if you split the cases:\n\nn\
    \ is odd:\n\nthere are n_minus_one ways to choose the non-1 digits\nand there\
    \ are (n_minus_one)^2 ways to choose the remaining digits\n\nn is even:\n\nthere\
    \ are n_minus_one ways to choose the non-1 digits\nand there are (n_minus_one)^2\
    \ - n_minus_one ways to choose the remaining digits\n\n", "  (if (= n 1)\n   \
    \   2\n      (+ (starts_one_ends (- n 1))\n         (power 10 (- n 1)))))\n",
  "  (cond\n    [(= n 1) 3]\n    [(= n 2) 9]\n    [else\n     (+ (* 9 (expt 10 (-\
    \ n 2))) (starts_one_ends (- n 1)))]))\n</code>\nI think that your first question\
    \ is why do we have <code>3</code> in the first base case, and <code>9</code>\
    \ in the second. \nLet's start with the base case for <code>n = 1</code>. We have\
    \ three single-digit numbers that start or end with <code>1</code>: <code>1</code>,\
    \ <code>3</code>, and <code>5</code>. If we write <code>1</code> as <code>10^0</code>,\
    \ then we have:\n<code>1  =  10^0\n3  =  10^0\n5  =  10^0\n</code>\nSince we have\
    \ three numbers, we return <code>3</code>.\nNow let's consider the next base case,\
    \ where <code>n = 2</code>. We have three 2-digit numbers that start with <code>1</code>:\
    \ <code>10</code>, <code>13</code>, and <code>15</code>. If we write these as\
    \ <code>10^1</code>, then we have:\n<code>10  =  10^1\n13  =  10^1\n15  =  10^1\n\
    </code>\nNotice that these are equivalent to the base case for <code>n = 1</code>,\
    \ but with an extra zero.\nWe also have three 2-digit numbers that end with <code>1</code>:\
    \ <code>31</code>, <code>51</code>, and <code>71</code>. If we write these as\
    \ <code>10^1</code>, then we have:\n<code>31  =  10^1\n51  =  10^1\n71  =  10^1\n\
    </code>\nThese are also equivalent to the base case for <code>n = 1</code>, but\
    \ with an extra zero.\nFinally, we have three single-digit numbers that start\
    \ or end with <code>1</code>: <code>1</code>, <code>3</code>, and <code", "  (for/sum\
    \ ([d (in-range 1 n)])\n           (expt 10 (- d 1))))\n", "  (cond [(zero? n)\
    \ 1]\n        [(one? n) 10]\n        [else (+ 9 (power 10 (- n 2)) (starts_one_ends\
    \ (- n 1)))]))\n", "  (cond\n    ((= n 1) 2)\n    ((= n 2) 3)\n    (else\n   \
    \  (let\n       ((ones (lambda (n) (+ n 1)))\n        (tens (lambda (n) (* n 10))))\n\
    \       (+ (ones n)\n          (tens n)\n          (* 2 (- (tens n) (ones n)))\n\
    \          (starts_one_ends (- n 1)))))))\n</code>\nHere's my Python solution.\
    \ It relies on a recent optimization\nof CPython (3.3+), which short-circuits\
    \ tail recursion.\n<code># Python 3\n\n# Given a positive integer n, return the\
    \ count of the numbers of n-digit\n# positive integers that start or end with\
    \ 1.\ndef starts_one_ends(n):\n    if n == 1:\n        return 2\n    if n == 2:\n\
    \        return 3\n    ones = lambda n: n + 1\n    tens = lambda n: n * 10\n \
    \   return ones(n) + tens(n) + 2 * (tens(n) - ones(n)) + starts_one_ends(n - 1)\n\
    </code>\n", "  (if (= n 1) 2\n      (letrec ([f (lambda (n)\n                \
    \    (cond [(= n 0) 0]\n                          [(= n 1) 2]\n              \
    \            [(= n 2) 3]\n                          [else (+ (f (- n 1))\n   \
    \                                (f (- n 2)))]))])\n        (f n))))\n", "  (cond\n\
    \    [(= n 1) 2]\n    [(= n 2) 3]\n    [else (+ (starts_one_ends (- n 1))\n  \
    \           (starts_one_ends (- n 2)))]))\n", "  (cond\n    [(= n 1) (values 2\
    \ 1)]\n    [(= n 2) (values 2 11)]\n    [(> n 2) (let ([start (starts_one_ends\
    \ (- n 1))])\n               (values (+ (second start) (first start)) (* (second\
    \ start) 10)))]))\n", "  (define nums (build-list n add1))\n  (foldl (lambda (x\
    \ y) (add1 (+ y (power x 10))))\n         1\n         nums))\n", "  (cond\n  \
    \  [(= n 1) 2]\n    [(= n 2) 3]\n    [else (+ (starts_one_ends (- n 1)) (starts_one_ends\
    \ (- n 2)))]))\n", "  (define (ends n)\n    (let ((ends-n\n           (add1 (*\
    \ n (expt 10 (- n 1))))))\n      (for/sum ([i (in-range n)])\n        (expt 10\
    \ i))))\n  (+ (ends n) (ends (add1 n))))\n", "  (let ([start-ends (make-vector\
    \ n 0)])\n    (for ([i n]\n          [j n])\n      (vector-set! start-ends i (+\
    \ 1 (vector-ref start-ends (- i 1)))))\n    (vector-set! start-ends 0 1)\n   \
    \ (vector-ref start-ends n)))\n", "  (cond [(= n 1) 10]\n        [(= n 2) 90]\n\
    \        [else (+ 90 (starts_one_ends (- n 2)))]))\n", "  (if (equal? n 1)\n \
    \     1\n      (let ((a 0)\n            (b 0))\n        (for ((i 1 (add1 i)))\n\
    \          (if (equal? i 1)\n              (set! a (add1 a))\n              (set!\
    \ b (add1 b))))\n        (add1 (+ a b)))))\n", "  (if (zero? n)\n      1\n   \
    \   (+ (expt 10 (- n 1)) (* 9 n))))\n</code>\nMy <code>racket</code> tests:\n\
    <code>&gt; (starts_one_ends 0)\n1\n&gt; (starts_one_ends 1)\n10\n&gt; (starts_one_ends\
    \ 2)\n90\n&gt; (starts_one_ends 3)\n900\n&gt; (starts_one_ends 4)\n9000\n&gt;\
    \ (starts_one_ends 5)\n90000\n&gt; (starts_one_ends 6)\n900000\n&gt; (starts_one_ends\
    \ 7)\n9000000\n&gt; (starts_one_ends 8)\n90000000\n&gt; (starts_one_ends 9)\n\
    900000000\n&gt; (starts_one_ends 10)\n9000000000\n</code>\nMy <code>java</code>\
    \ solution:\n<code>public class OneStartsEnds {\n    public static int starts_one_ends(int\
    \ n) {\n        if (n == 0) {\n            return 1;\n        } else {\n     \
    \       return (int) Math.pow(10, n - 1) + 9 * n;\n        }\n    }\n}\n</code>\n\
    My <code>ruby</code> solution:\n<code>def starts_one_ends(n)\n  if n == 0\n  \
    \  1\n  else\n    10 ** (n - 1) + 9 * n\n  end\nend\n</code>\nMy <code>haskell</code>\
    \ solution:\n<code>starts_one_ends :: Integer -&gt; Integer\nstarts_one_ends 0\
    \ = 1\nstarts_one_ends n = 10 ^ (n - 1) + 9 * n\n</code>\n\n<code>Haskell</code>\
    \ has a <code>Data.Bits</code> package that has a <code>bit</code> function that\
    \ returns the i-th bit of a number as an Int. \nWrite a function <code>int_to_bin</code>\
    \ that takes a number and returns a list of the bits in reverse", "  (define (fill\
    \ x)\n    (cond\n      [(= x 0) '()]\n      [else (cons x (fill (- x 1)))]))\n\
    \  (define (starts_one_ends_iter i x y)\n    (cond\n      [(= i (- n 2)) (add1\
    \ (+ x y))]\n      [else\n       (starts_one_ends_iter\n        (+ i 1)\n    \
    \    (+ x (expt 10 (- n 2)))\n        (+ y (* 2 (expt 10 (- n 2)))))]))\n  (if\
    \ (even? n)\n      0\n      (starts_one_ends_iter 0 1 1)))\n", "  (define (helper\
    \ n len tmp)\n    (cond\n      [(= len 0)\n       1]\n      [(and (&lt;= (remainder\
    \ n 10) 1)\n            (= len 1))\n       (add1 tmp)]\n      [else\n       (helper\
    \ (quotient n 10) (sub1 len)\n               (if (&lt;= (remainder n 10) 1)\n\
    \                   (add1 tmp)\n                   tmp))]))\n  (helper n (inexact-&gt;exact\
    \ (log n 10)) 0))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 4]\n    [else\n\
    \     (+ (starts_one_ends (- n 1)) (starts_one_ends (- n 2)))]))\n", "  (define\
    \ (starts_one n)\n    (cond\n      [(zero? n) 1]\n      [(and (even? n) (> n 1))\n\
    \       (starts_one_ends (- n 2))]\n      [(even? n)\n       (starts_one_ends\
    \ (- n 1))]\n      [(and (odd? n) (> n 1))\n       (starts_one_ends (- n 2))]\n\
    \      [(odd? n)\n       (starts_one_ends (- n 1))]))\n  (+ (starts_one n) (starts_one\
    \ (- n 1))))\n", "  (cond [(= 1 n) 10]\n        [else (+ (count-with-prefix-one\
    \ n)\n                 (count-with-suffix-one n))]))\n", "  (cond\n    ((= n 1)\
    \ (list 1))\n    ((= n 2) (list 11))\n    (else\n     (for/list ((i (in-range\
    \ 2 n)))\n       (+ (* i 9)\n          (if (= i 2) 10\n              (for/sum\
    \ ((j (in-range 2 i)))\n                (* j (- (expt 10 (- i j)) 1)))))))))\n",
  "  (cond [(<= n 1) 0]\n        [(<= n 9) 1]\n        [else (+ (starts_one_ends (-\
    \ n 1)) (- (expt 10 (- n 1)) 1))]))\n", "  (define (is_valid_first-digit? n)\n\
    \    (let ((first-digit (modulo n 10)))\n      (member first-digit '(1))))\n \
    \ (define (is_valid_last-digit? n)\n    (let ((last-digit (modulo (quotient n\
    \ 10) 10)))\n      (member last-digit '(1))))\n  (define (is_valid? n)\n    (or\
    \ (is_valid_first-digit? n)\n        (is_valid_last-digit? n)))\n  (define (count\
    \ n)\n    (if (is_valid? n)\n        1\n        0))\n  (apply + (map count (range\
    \ 1 (expt 10 n)))))\n", "  (define (s_or_e n l)\n    (cond [(> n 10) 0]\n    \
    \      [(= 1 (modulo n 10)) (+ 1 (s_or_e (+ n 1) l))]\n          [(= 1 (modulo\
    \ l 10)) (+ 1 (s_or_e (+ n 1) l))]\n          [else (s_or_e (+ n 1) l)]))\n  (s_or_e\
    \ 1 n))\n", "  (define (ends n)\n    (let* ([fact (pow n 10)]\n           [first\
    \ (modulo fact 100)]\n           [last (modulo fact 10)])\n      (+ first last)))\n\
    \  (define (pow n m)\n    (cond [(zero? m) 1]\n          [else (define (iter i)\n\
    \                  (cond [(>= i m) 1]\n                        [else (* n (iter\
    \ (add1 i)))]))\n                (iter 1)]))\n  (define (aux n total)\n    (cond\
    \ [(equal? n 1) (+ 1 total)]\n          [else (aux (sub1 n) (+ (ends n) total))]))\n\
    \  (aux n 0))\n", "  (cond\n    [(< n 1) 0]\n    [(= n 1) 2]\n    [else (+ (starts_one_ends\
    \ (- n 1)) (starts_one_ends (- n 2)))]))\n", "  (if (= n 1)\n      1\n      (+\
    \ (starts_one_ends (- n 1))\n         (* (starts_one_ends (- n 1))\n         \
    \   9))))\n", "  (cond\n    [(equal? n 1) 2]\n    [else (+\n            ;; number\
    \ which ends with 1\n            (* (expt 10 (- n 1)) starts_one_ends (- n 1))\n\
    \            ;; number which starts with 1\n            (* (- n 1) (expt 10 (-\
    \ n 2))))]))\n", "  (if (= n 1) 1\n      (cond [(= n 2) 11]\n            [(= n\
    \ 3) 111]\n            [(= n 4) 1111]\n            [(= n 5) 11111]\n         \
    \   [(= n 6) 111111]\n            [(= n 7) 1111111]\n            [(= n 8) 11111111]\n\
    \            [(= n 9) 111111111]\n            [(= n 10) 1111111111]\n        \
    \    [(= n 11) 11111111111]\n            [(= n 12) 111111111111]\n           \
    \ [(= n 13) 1111111111111]\n            [(= n 14) 11111111111111]\n          \
    \  [(= n 15) 111111111111111]\n            [(= n 16) 1111111111111111]\n     \
    \       [(= n 17) 11111111111111111]\n            [(= n 18) 111111111111111111]\n\
    \            [(= n 19) 1111111111111111111]\n            [(= n 20) 11111111111111111111]\n\
    \            [(= n 21) 111111111111111111111]\n            [(= n 22) 1111111111111111111111]\n\
    \            [(= n 23) 11111111111111111111111]\n            [(= n 24) 111111111111111111111111]\n\
    \            [(= n 25) 1111111111111111111111111]\n            [(= n 26) 11111111111111111111111111]\n\
    \            [(= n 27) 111111111111111111111111111]\n            [(= n 28) 1111111111111111111111111111]\n\
    \            [(= n 29) 11111111111111111111111111111]\n            [(= n 30) 111111111111111111111111111111]))))\n\
    </code>\nThe interesting thing here is that it produces the correct output for\
    \ <code>n = 31</code>, but that <code>n = 32</code> produces an overflow error.\n\
    The most interesting thing is that this happens on the <code>cond</code> line.\
    \ I'm using DrRacket, and here's what the error stack-trace looks like:\n<code>Overflow\
    \ in (if (= n 32) 1111111111111111111111111111111 11111111111111111111111111111111)\n\
    \    context...:\n      /usr/share/racket/collects/racket/private", "  (if (=\
    \ n 1)\n      2\n      (+ (* 9 (expt 10 (- n 1))) (starts_one_ends (- n 1)))))\n",
  "  (let* ((mid (expt 10 (- n 1)))\n         (left (modulo mid 2)))\n    (* (+ (*\
    \ 2 left) 1) mid)))\n</code>\nThis returns <code>90</code> and <code>900</code>\
    \ for <code>n</code> equals <code>2</code> and <code>3</code> respectively. However,\
    \ when I write a similar code in Haskell (like below), it returns <code>98</code>\
    \ and <code>988</code> for <code>n</code> equals <code>2</code> and <code>3</code>\
    \ respectively. Please point out my error in Haskell.\n<code>module Main where\n\
    \nstarts_one_ends :: Int -&gt; Int\nstarts_one_ends n = let mid = 10 ^ (n - 1)\n\
    \                        left = mod mid 2\n                    in 2 * left * mid\
    \ + mid\n\nmain :: IO ()\nmain = do\n    putStrLn $ show $ starts_one_ends 2\n\
    \    putStrLn $ show $ starts_one_ends 3\n</code>\n\n\nA:\n\nThe problem is this\
    \ line:\n<code>left = mod mid 2\n</code>\nThis is not how you get the first digit\
    \ of a number in Haskell. What this does, is take the remainder after <code>mid</code>\
    \ is divided by <code>2</code>, which will be either <code>0</code> or <code>1</code>.\n\
    What you want is the quotient, which is <code>div mid 10</code>.\n", "  (let ([n-1\
    \ (- n 1)])\n    (+ (expt 10 n-1)\n       (expt 9 n-1))))\n", "  (cond\n    ((<\
    \ n 2) 0)\n    ((= n 2) 4)\n    (else\n     (apply +\n       (map\n         (lambda\
    \ (x)\n           (starts_one_ends (- n x)))\n         (range 2 n))))))\n", " \
    \ (define (starts_one_ends-acc n lst max)\n    (if (= n 1)\n        (count lst\
    \ max)\n        (starts_one_ends-acc (sub1 n) (cons 1 lst) max)))\n  (starts_one_ends-acc\
    \ n (list 1) (expt 10 n)))\n", "  (if (eq? n 1)\n      10\n      (+ (* 10 (- (expt\
    \ 10 (- n 1)) 1)) (starts_one_ends (- n 1)))))\n", "  (cond\n    [(= n 1) 2]\n\
    \    [(= n 2) 4]\n    [else (+ (* (starts_one_ends (- n 1)) 8) 4)]))\n", "  (cond\n\
    \    ((= n 1) 2)\n    ((= n 2) 3)\n    (else\n     (+ (starts_one_ends (- n 1))\
    \ (starts_one_ends (- n 2))))))\n```\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(zero? n) 1] ;# start count at 1 so the value returned matches the example\n\
    \    [(zero? (remainder n 2)) (+ 2 (starts_one_ends (- n 1)))]\n    [else (starts_one_ends\
    \ (- n 1))]))\n", "  ;; The number of these integers is equal to the sum of the\
    \ number of\n  ;; integers of k digits that start or end with one, for k from\
    \ 1 to n.\n  (for/sum ([k (in-range 1 (add1 n))])\n    ;; The number of k-digit\
    \ integers that start or end with one is\n    ;; equal to the number of k-digit\
    \ integers minus the number of\n    ;; k-digit integers that neither start nor\
    \ end with one, which is\n    ;; the number of k-digit integers that start and\
    \ end with zero.\n    (subtract (expt 10 k)\n              (expt 9 (sub1 k)))))\n\
    </code>\n", "  (cond [(= n 1) 1]\n        [(= n 2) 9]\n        [else (+ (expt\
    \ 10 (- n 2)) (starts_one_ends (- n 1)))]))\n", "  (cond\n    [(= n 1) (apply\
    \ + '(1 2 3 4 5 6 7 8 9))]\n    [else (apply + (map\n                    (lambda\
    \ (c)\n                      (* c\n                         (+ (* c (- (expt 10\
    \ (- n 2)) 1))\n                            (starts_one_ends (- n 1)))))\n   \
    \                 '(2 3 4 5 6 7 8 9)))]))\n", "  (cond\n    [(equal? n 1) 2]\n\
    \    [else (+ (starts_one_ends (- n 1)) (expt 10 (- n 1)))]))\n", "  (define (inner\
    \ n acc)\n    (cond\n      ((&lt;= n 1) acc)\n      ((= n 2) (+ acc 1))\n    \
    \  (else (inner (- n 1)\n                   (+ acc (expt 10 (- n 2)))))))\n  (inner\
    \ n 0))\n</code>\nWhich works as expected:\n<code>&gt; (starts_one_ends 1)\n1\n\
    &gt; (starts_one_ends 2)\n11\n&gt; (starts_one_ends 3)\n101\n&gt; (starts_one_ends\
    \ 4)\n1001\n&gt; (starts_one_ends 5)\n10001\n&gt; (starts_one_ends 7)\n1000001\n\
    </code>\n", "  (if (zero? n)\n      1\n      (+ (starts_one_ends (- n 1)) (expt\
    \ 10 (- n 1)))))\n", "  (cond\n    [(= n 1) 2]\n    [(= n 2) 9]\n    [else (+\
    \ (inexact->exact (* 9 (expt 10 (- n 1))))\n             (starts_one_ends (- n\
    \ 1)))]))\n", "  (cond [(= n 1) 2]\n        [(= n 2) 9]\n        [else\n     \
    \    (+ (starts_one_ends (- n 1))\n            (starts_one_ends (- n 2)))]))\n",
  "  (for/sum ([i (in-range 1 n)])\n    (let* ([k (sub1 (expt 10 i))]\n          \
    \ [start-num (+ k 1)]\n           [end-num (expt 10 i)])\n      (+ start-num end-num))))\n",
  "  (cond\n    [(zero? n)\n     (error \"n must be positive\")]\n    [(= n 1)\n \
    \    1]\n    [else\n     (+ 1 (* 9 (expt 10 (- n 2))))]))\n", "  (cond [(= n 1)\
    \ 2]\n        [(= n 2) 3]\n        [else (+ (expt 10 (- n 1)) (expt 10 (- n 2)))]))\n",
  "  (let loop ([n n] [count 0])\n    (if (&lt; n 1)\n        count\n        (loop\
    \ (- n 1) (+ count (expt 10 (- n 1)))))))\n", "  (cond [(= n 1) (+ 1 (starts_one_ends\
    \ 0))]\n        [(= n 2) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 3)\
    \ (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 4) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 5) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 6)\
    \ (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 7) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 8) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 9)\
    \ (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 10) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 11) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n\
    \ 12) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 13) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 14) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n\
    \ 15) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 16) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 17) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n\
    \ 18) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 19) (+ (expt 10 1) (starts_one_ends\
    \ 1))]\n        [(= n 20) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n\
    \ 21) (+ (expt 10 1) (starts_one_ends 1))]\n        [(= n 22) (+ (expt", "  (cond\n\
    \    [(= n 1) 2]\n    [(even? n) (+ (starts_one_ends (- n 1))\n              \
    \    (expt 10 (- n 2)))]\n    [else (+ (starts_one_ends (- n 1))\n           \
    \  (expt 10 (- n 1)))]))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
