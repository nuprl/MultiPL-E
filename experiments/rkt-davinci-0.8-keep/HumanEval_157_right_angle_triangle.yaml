name: HumanEval_157_right_angle_triangle
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ True if the three\n;; sides form a right-angled triangle, False otherwise.\n;;\
  \ A right-angled triangle is a triangle in which one angle is right angle or \n\
  ;; 90 degree.\n;; Example:\n;; right_angle_triangle(3, 4, 5) == True\n;; right_angle_triangle(1,\
  \ 2, 3) == False\n(define (right_angle_triangle a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n\
  \    (check-equal? (candidate 3 4 5) #t)\n    (check-equal? (candidate 1 2 3) #f)\n\
  \    (check-equal? (candidate 10 6 8) #t)\n    (check-equal? (candidate 2 2 2) #f)\n\
  \    (check-equal? (candidate 7 24 25) #t)\n    (check-equal? (candidate 10 5 7)\
  \ #f)\n    (check-equal? (candidate 5 12 13) #t)\n    (check-equal? (candidate 15\
  \ 8 17) #t)\n    (check-equal? (candidate 48 55 73) #t)\n    (check-equal? (candidate\
  \ 1 1 1) #f)\n    (check-equal? (candidate 2 2 10) #f)\n))\n\n(test-humaneval)"
completions: ["  (define (square x) (* x x))\n  (define squares (list (square a) (square\
    \ b) (square c)))\n  (define (check x y) (= (sort x <) (sort y <)))\n  (check\
    \ squares (list (+ (square a) (square b)) (square c))))\n", "  (cond\n    [(and\
    \ (< a b) (< a c)) (= (* a a) (+ (* b b) (* c c)))]\n    [(and (< b a) (< b c))\
    \ (= (* b b) (+ (* a a) (* c c)))]\n    [(and (< c a) (< c b)) (= (* c c) (+ (*\
    \ a a) (* b b)))]\n    [else #f]))\n", "  (and (> a 0)\n       (> b 0)\n     \
    \  (> c 0)\n       (= (expt a 2) (+ (expt b 2) (expt c 2)))\n       ))\n", " \
    \ (and (or (= (hypotenuse a b) c) (= (hypotenuse a c) b) (= (hypotenuse b c) a))\n\
    \       (or (= (hypotenuse a b) c) (= (hypotenuse a c) b) (= (hypotenuse b c)\
    \ a))))\n", "  (and\n   (= (expt (max a b c) 2) (+ (expt (min a b) 2) (expt (min\
    \ a c) 2)))\n   (and (> a 0) (> b 0) (> c 0))))\n", "  (define h (list a b c))\n\
    \  (define sm (apply max h))\n  (define s (apply + h))\n  (= (* 2 sm) (- s sm)))\n",
  "  (and (= a (sqrt (+ (* b b) (* c c))))\n       (= b (sqrt (+ (* a a) (* c c))))\n\
    \       (= c (sqrt (+ (* a a) (* b b))))))", "  (= 90 (smallest_angle a b c)))\n",
  "  (and (or (= (sqrt (+ (* a a) (* b b))) c)\n           (= (sqrt (+ (* a a) (*\
    \ c c))) b)\n           (= (sqrt (+ (* b b) (* c c))) a))\n       (<= a b c)))\n",
  "  (let ((hypotenuse c)\n        (side1 (min a b))\n        (side2 (max a b)))\n\
    \    (= (square side1)\n       (+ (square side2)\n          (square hypotenuse)))))\n\
    </code>\n", "  (and\n   (equal? (max (list a b c)) c)\n   (or\n    (and\n    \
    \ (equal? (min (list a b c)) a)\n     (equal? (* a a) (+ (* b b) (* c c))))\n\
    \    (and\n     (equal? (min (list a b c)) b)\n     (equal? (* b b) (+ (* a a)\
    \ (* c c)))))))\n", "  (if (or (= a 0) (= b 0) (= c 0))\n      #f\n      (if (or\
    \ (and (> a b) (> a c))\n              (and (> b a) (> b c))\n              (and\
    \ (> c a) (> c b)))\n          #f\n          (and (or (= (+ (* a a) (* b b)) (*\
    \ c c))\n                   (= (+ (* a a) (* c c)) (* b b))\n                \
    \   (= (+ (* b b) (* c c)) (* a a)))\n               #t))))", "  (let ([m (max\
    \ a b c)]\n        [s (set-add (list a b c) 0)])\n    (= (* m m) (+ (- (* s s))\
    \ (- (* m m))))))\n</code>\n", "  (and (&gt; a 0) (&gt; b 0) (&gt; c 0)\n    \
    \   (&gt; (abs (- (square a) (- (square b) (square c)))) 0.000001)\n       (=\
    \ (square a) (+ (square b) (square c)))))\n", "  ;; check if this is a valid triangle\n\
    \  (define (square x) (* x x))\n  (define (sum_of_two x y) (+ (square x) (square\
    \ y)))\n  (define (valid? x y z)\n    (and (<= x (+ y z))\n         (<= y (+ x\
    \ z))\n         (<= z (+ x y))))\n  (cond\n    ((valid? a b c) (= (sum_of_two\
    \ a b) (square c)))\n    ((valid? a c b) (= (sum_of_two a c) (square b)))\n  \
    \  ((valid? b a c) (= (sum_of_two b a) (square c)))\n    ((valid? b c a) (= (sum_of_two\
    \ b c) (square a)))\n    ((valid? c a b) (= (sum_of_two c a) (square b)))\n  \
    \  ((valid? c b a) (= (sum_of_two c b) (square a)))\n    (else #f)))\n", "  (and\
    \ (= (+ a b) c)\n       (= (- c b) a)\n       (= (- c a) b)))\n", "  (cond\n \
    \   [(or (< a 1) (< b 1) (< c 1)) false]\n    [(or (= a 1) (= b 1) (= c 1)) false]\n\
    \    [(and (>= a b) (>= a c)) (= a (+ b c))]\n    [(and (>= b a) (>= b c)) (=\
    \ b (+ a c))]\n    [(and (>= c a) (>= c b)) (= c (+ a b))]\n    [else false]))\n",
  "  (equal? 'True\n          (cond\n            [(and (equal? (sqr a)\n         \
    \                 (+ (sqr b)\n                             (sqr c)))\n       \
    \           (equal? (sqr b)\n                          (+ (sqr a)\n          \
    \                   (sqr c)))\n                  (equal? (sqr c)\n           \
    \               (+ (sqr a)\n                             (sqr b))))\n        \
    \     True]\n            [else False])))\n", "  (if (and (positive? a) (positive?\
    \ b) (positive? c))\n      (or\n       (and (= (square a) (+ (square b) (square\
    \ c)))\n            (= b c))\n       (and (= (square b) (+ (square a) (square\
    \ c)))\n            (= a c))\n       (and (= (square c) (+ (square a) (square\
    \ b)))\n            (= a b)))\n      #f))\n", "  (= (max a b c) (sqrt (+ (square\
    \ a) (square b) (square c)))))\n</code>\nThe last test case is failing, though\
    \ I can't find any flaw in my code.\nCan someone help?\n\n\nA:\n\nIs this a Racket\
    \ course? \n<code>(define (right_angle_triangle a b c)\n  (= (max a b c) (sqrt\
    \ (+ (square a) (square b) (square c)))))\n</code>\nReturns a <code>Boolean</code>\
    \ (i.e., <code>#t</code> or <code>#f</code>), not a <code>Number</code> (i.e.,\
    \ <code>30</code>).\nYou can solve the last test by checking <code>(= (right_angle_triangle\
    \ 3 4 5) 30)</code>\n", "  (define (square x) (* x x))\n  (define (is-right-angle\
    \ x y z)\n    (cond ((= (square x) (+ (square y) (square z))) #t)\n          ((=\
    \ (square y) (+ (square x) (square z))) #t)\n          ((= (square z) (+ (square\
    \ x) (square y))) #t)\n          (else #f)))\n  (is-right-angle a b c))\n", " \
    \ (= (sqrt (+ (* a a) (* b b))) c))\n", "  (if (and (list? a) (list? b) (list?\
    \ c))\n      (for ([x a] [y b] [z c])\n           (cond [(> x 0) (and (integer?\
    \ x) (integer? y) (integer? z))]\n                 [(and (> y 0) (> z 0)) (= (+\
    \ (square x) (square y)) (square z))]\n                 [else false]))\n     \
    \ false))\n```\n\n### Complex Language Syntax\n\n#### Error Messages\n\nError\
    \ messages are usually a direct effect of an incorrect syntax. The error message\
    \ associated with a given syntax will be printed to the screen if the code is\
    \ compiled.\n\nThe error message \"application: not a procedure\" is often a symptom\
    \ of forgetting to quote a symbol.\n\n```racket\n#lang racket\n", "  (and (>=\
    \ a b c)\n       (= (+ (* a a) (* b b)) (* c c))))\n", "  (and (= (sum (list a\
    \ b c)) 180)\n       (or (= (max (list a b c)) (* 2 (min (list a b c))))\n   \
    \        (= (max (list a b c)) (* 3 (min (list a b c)))))))\n", "  (if (and (>\
    \ a 0) (> b 0) (> c 0))\n      (if (= (sqrt (+ (* a a) (* b b))) c)\n        \
    \  true\n          false)\n      false))\n", "  (if (< a b c)\n      (if (< a\
    \ (+ b c))\n          (if (< b (+ a c))\n              (if (< c (+ a b))\n   \
    \               (if (= (* a a) (+ (* b b) (* c c)))\n                      #t\n\
    \                      #f)\n                  #f)\n              #f)\n       \
    \   #f)\n      #f))\n", "  (and (or (= (sqrt (+ (* a a) (* b b))) c)\n       \
    \    (= (sqrt (+ (* b b) (* c c))) a)\n           (= (sqrt (+ (* a a) (* c c)))\
    \ b))\n       (&gt; a 0)\n       (&gt; b 0)\n       (&gt; c 0)))\n", "  (and (and\
    \ (&lt; a (+ b c)) (&lt; b (+ a c)) (&lt; c (+ a b)))\n       (= (square a) (+\
    \ (square b) (square c)))\n       (= (square b) (+ (square a) (square c)))\n \
    \      (= (square c) (+ (square a) (square b)))))\n", "  (define (square n) (*\
    \ n n))\n  (define (big-of-three n1 n2 n3)\n    (if (&gt; n1 n2)\n        (if\
    \ (&gt; n1 n3) n1 n3)\n        (if (&gt; n2 n3) n2 n3)))\n  (define (pythagoras-theorem\
    \ n1 n2 n3)\n    (= n3 (sqrt (+ (square n1) (square n2)))))\n  (pythagoras-theorem\
    \ a b (big-of-three a b c)))\n", "  (define (square n) (* n n))\n  (define (hypotenuse\
    \ a b) (expt (+ (square a) (square b)) 0.5))\n  (define (max a b) (if (&gt; a\
    \ b) a b))\n  (define (min a b) (if (&lt; a b) a b))\n  (define (is_triangle a\
    \ b c)\n    (and (and (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n         (&gt;= (min\
    \ a b) (- c (max a b)))\n         (&gt;= (max a b) (- c (min a b)))))\n  (define\
    \ (right_angle? a b c)\n    (or (and (or (= a (hypotenuse b c)) (= b (hypotenuse\
    \ a c)) (= c (hypotenuse a b)))\n             (is_triangle a b c))\n        (and\
    \ (or (= a (hypotenuse b c)) (= b (hypotenuse a c)) (= c (hypotenuse a b)))\n\
    \             (is_triangle a b c))))\n  (right_angle? a b c))\n", "  (and (= (expt\
    \ a 2) (+ (expt b 2) (expt c 2)))\n       (or (= a b) (= b c) (= a c))))\n", " \
    \ (and (or (= a (+ b c)) (= b (+ a c)) (= c (+ a b)))\n       (not (equal? (+\
    \ a b) c))))\n", "  (define (hypotenuse a b)\n    (cond\n      [(> a b) a]\n \
    \     [else b]))\n  (define (hypotenuse-plus-smaller a b)\n    (+ (hypotenuse\
    \ a b)\n       (cond\n         [(> a b) b]\n         [else a])))\n  (= (hypotenuse-plus-smaller\
    \ a b) c))\n", "  (define (is_right_angle_triangle)\n    ;; Make sure the sum\
    \ of the two shorter sides are greater than the longest\n    ;; side.\n    (and\
    \ (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a)))\n  (define (is_right_angle)\n\
    \    ;; For a right angle, the sum of the squares of the two shorter sides\n \
    \   ;; equals the square of the longest side.\n    (= (+ (expt a 2) (expt b 2))\
    \ (expt c 2)))\n  (define (is_equal_angles)\n    ;; For an equilateral triangle,\
    \ all three sides are equal.\n    (and (= a b) (= b c)))\n  (cond\n    [(is_right_angle_triangle)\
    \ (is_right_angle)]\n    [(is_equal_angles) #f]))\n", "  (and (and (= (+ a c)\
    \ (* 2 b)) (or (and (= a c) (= b a)) (and (= b c) (= a b))))\n       (and (and\
    \ (= (+ a b) (* 2 c)) (or (and (= a c) (= b a)) (and (= b c) (= a b))))\n    \
    \   (and (and (= (+ b c) (* 2 a)) (or (and (= a c) (= b a)) (and (= b c) (= a\
    \ b))))))))\n", "  (cond\n    [(>= c (add1 (max a b))) false]\n    [(>= b (add1\
    \ (max a c))) false]\n    [(>= a (add1 (max b c))) false]\n    [else (= (sqr b)\
    \ (add (sqr a) (sqr c))) ]))", "  (cond\n    [(and (and (< a (+ b c)) (< b (+\
    \ a c)) (< c (+ a b)))\n          (and (< a (sqrt (+ (* b b) (* c c))))\n    \
    \           (< b (sqrt (+ (* a a) (* c c))))\n               (< c (sqrt (+ (*\
    \ a a) (* b b)))))) #t]\n    [else #f]))", "  (and (&gt; (expt a 2) (+ (expt b\
    \ 2) (expt c 2)))\n       (&gt; (expt b 2) (+ (expt a 2) (expt c 2)))\n      \
    \ (&gt; (expt c 2) (+ (expt a 2) (expt b 2)))))\n", "  (and (= a (+ b c))\n  \
    \     (= b (+ a c))\n       (= c (+ a b))))\n", "  (or (and (= c (sqrt (+ (* a\
    \ a) (* b b))))\n           (= c (sqrt (+ (* b a) (* b b))))\n           (= c\
    \ (sqrt (+ (* a b) (* a b)))))\n      (and (= b (sqrt (+ (* a a) (* c c))))\n\
    \           (= b (sqrt (+ (* a c) (* a c))))\n           (= b (sqrt (+ (* c a)\
    \ (* c a)))))\n      (and (= a (sqrt (+ (* b b) (* c c))))\n           (= a (sqrt\
    \ (+ (* b c) (* b c))))\n           (= a (sqrt (+ (* c b) (* c b)))))))\n</code>\n\
    If anyone knows how to fix this or thinks I'm doing something wrong, let me know.\
    \ :)\n\n\nA:\n\nI think your implementation is right, but that the problem wants\
    \ you to exploit the following:\n\nThe sum of any two sides is bigger than the\
    \ third side\nThe biggest side is always opposite to the biggest angle\nThe Pythagorean\
    \ Theorem states that <code>a^2 + b^2 = c^2</code>\n\nSo you can use this information\
    \ to solve the problem:\n<code>(define (right-angle-triangle a b c)\n  (and (or\
    \ (= a b) (= a c) (= b c))\n       (&gt; (max a b c) ; biggest side is the opposite\
    \ of the biggest angle\n          (+ (min a b) (min b c)))))\n</code>\n", "  (and\
    \ (< a b c) (> (abs (- (* a a) (* b b) (* c c))) 0.0001)))\n", "  (or (and (=\
    \ a (sqrt (+ (* b b) (* c c))))\n           (= c (sqrt (+ (* a a) (* b b))))\n\
    \           (= b (sqrt (+ (* a a) (* c c)))))\n      (and (= b (sqrt (+ (* a a)\
    \ (* c c))))\n           (= c (sqrt (+ (* a a) (* b b))))\n           (= a (sqrt\
    \ (+ (* b b) (* c c)))))\n      (and (= a (sqrt (+ (* b b) (* c c))))\n      \
    \     (= b (sqrt (+ (* a a) (* c c))))\n           (= c (sqrt (+ (* a a) (* b\
    \ b)))))))", "  (cond ((and (>= a b) (>= a c))\n         (= (square a) (+ (square\
    \ b) (square c))))\n        ((and (>= b a) (>= b c))\n         (= (square b) (+\
    \ (square a) (square c))))\n        ((and (>= c a) (>= c b))\n         (= (square\
    \ c) (+ (square a) (square b))))\n        (else #f)))\n", "  (eq? (max a b c)\
    \ (sqrt (+ (sqr a) (sqr b))) c))\n", "  (cond\n    [(or (= a b) (= b c) (= a c))\
    \ false]\n    [(and (= (expt a 2) (+ (expt b 2) (expt c 2))) (= (expt b 2) (+\
    \ (expt a 2) (expt c 2))) (= (expt c 2) (+ (expt a 2) (expt b 2)))) true]\n  \
    \  [else false]))", "  (or (and (= a (expt b 2)) (= c (expt (+ b b) 2)))\n   \
    \   (and (= b (expt a 2)) (= c (expt (+ a a) 2)))\n      (and (= c (expt a 2))\
    \ (= b (expt (+ a a) 2)))))\n", "  (define (sqr x) (* x x))\n  (and (or (= (sqr\
    \ (+ (sqr a) (sqr b))) (sqr c))\n           (= (sqr (+ (sqr a) (sqr c))) (sqr\
    \ b))\n           (= (sqr (+ (sqr b) (sqr c))) (sqr a)))\n       (< a (+ b c))\n\
    \       (< b (+ a c))\n       (< c (+ a b))))", "  (and (or (= a 90) (= b 90)\
    \ (= c 90)) \n       (or (= a (sqrt (+ (* b b) (* c c))))\n           (= b (sqrt\
    \ (+ (* a a) (* c c))))\n           (= c (sqrt (+ (* a a) (* b b)))))))\n", " \
    \ (cond\n    [(and\n       (= (quotient (+ a b) c) 1)\n       (= (quotient (+\
    \ a c) b) 1)\n       (= (quotient (+ b c) a) 1)) #t]\n    [else #f]))\n", "  (cond\
    \ ((or (< a 0) (< b 0) (< c 0)) #f)\n        ((> a b) (right_angle_triangle b\
    \ a c))\n        ((> b c) (right_angle_triangle a c b))\n        ((< a (* b b))\
    \ #f)\n        ((= (+ (* b b) (* c c)) (* a a)) #t)\n        (#t #f)))\n", " \
    \ (cond\n    [(< (square a) (+ (square b) (square c))) #t]\n    [(< (square b)\
    \ (+ (square a) (square c))) #t]\n    [(< (square c) (+ (square a) (square b)))\
    \ #t]\n    [else #f]))\n", "  (let ((angle-sum (* a a) (* b b) (* c c)))\n   \
    \ (if (= (expt a 2) (+ (expt b 2) (expt c 2)))\n        true\n        false)))\n",
  "  (cond\n    ((= a c)\n     (or (= a b) (= b c)))\n    ((= a b)\n     (= a c))\n\
    \    ((= b c)\n     (= a b))\n    (else #f)))\n", "  (define (is-right-angle?\
    \ a b c)\n    (and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n         (= (expt\
    \ b 2) (+ (expt a 2) (expt c 2)))\n         (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2)))))\n  (cond\n    [(and (>= a b) (>= a c)) (is-right-angle? a b c)]\n \
    \   [(and (>= b a) (>= b c)) (is-right-angle? b a c)]\n    [(and (>= c a) (>=\
    \ c b)) (is-right-angle? c a b)]\n    [else #f]))\n", "  (and (and (&lt; a b)\
    \ (&lt; a c))\n       (= (expt a 2) (+ (expt b 2) (expt c 2)))))\n", "  (equal?\
    \ 0 (modulo (- (* a a) (+ (* b b) (* c c))) 2)))\n</code>\nIf you are unsure how\
    \ to handle the negative cases, try this code:\n<code>#lang racket\n", "  (= (expt\
    \ a 2) (+ (expt b 2) (expt c 2))))\n</code>\n", "  (cond\n    [(or\n      (and\
    \ (= (expt a 2) (+ (expt b 2) (expt c 2)))\n        (&gt; a b c))\n      (and\
    \ (= (expt b 2) (+ (expt a 2) (expt c 2)))\n        (&gt; b a c))\n      (and\
    \ (= (expt c 2) (+ (expt a 2) (expt b 2)))\n        (&gt; c a b)))\n     #t]\n\
    \    [else #f]))\n</code>\nThe code above is working, but I feel the <code>cond</code>\
    \ is not the right solution in this case. Can I improve it?\n\n\nA:\n\n<code>#lang\
    \ racket\n", "  (and (>= a b c)\n       (>= (+ (square a) (square b)) (square\
    \ c))\n       (<= (+ (square a) (square b)) (square c))))\n", "  (let ([max (max\
    \ (max a b) c)])\n    (let ([a (- a max)]\n          [b (- b max)]\n         \
    \ [c (- c max)])\n      (eqv? (* a a) (+ (* b b) (* c c))))))\n", "  (cond\n \
    \   [(> (square a) (+ (square b) (square c))) (not True)]\n    [(> (square b)\
    \ (+ (square a) (square c))) (not True)]\n    [(> (square c) (+ (square a) (square\
    \ b))) (not True)]\n    [else True]))\n", "  (let ([sides (list a b c)])\n   \
    \ (cond\n      [(and (= (sort (list (square a) (square b) (square c)) <) sides)\
    \ (= (sum sides) 24)) #t]\n      [else #f])))\n", "  (and (= (expt a 2) (+ (expt\
    \ b 2) (expt c 2)))\n       (not (eq? a b))\n       (not (eq? a c))\n       (not\
    \ (eq? b c))))\n", "  (cond\n    [(>= a b c)\n     (>= (* a a) (+ (* b b) (* c\
    \ c)))]\n    [(>= b a c)\n     (>= (* b b) (+ (* a a) (* c c)))]\n    [(>= c a\
    \ b)\n     (>= (* c c) (+ (* a a) (* b b)))]))\n", "  (define (triangle? a b c)\n\
    \    (and (&gt; a 0)\n         (&gt; b 0)\n         (&gt; c 0)\n         (&lt;=\
    \ (max a b c) (+ (min a b) (min b c)))))\n  (and (triangle? a b c)\n       (or\
    \ (and (= a (sqrt (+ (* b b) (* c c))))\n                (= b (sqrt (+ (* a a)\
    \ (* c c))))\n                (= c (sqrt (+ (* a a) (* b b)))))\n           (and\
    \ (= a (sqrt (+ (* b b) (* c c))))\n                (= c (sqrt (+ (* a a) (* b\
    \ b))))\n                (= b (sqrt (+ (* a a) (* c c)))))\n           (and (=\
    \ b (sqrt (+ (* a a) (* c c))))\n                (= a (sqrt (+ (* b b) (* c c))))\n\
    \                (= c (sqrt (+ (* a a) (* b b)))))\n           (and (= b (sqrt\
    \ (+ (* a a) (* c c))))\n                (= c (sqrt (+ (* a a) (* b b))))\n  \
    \              (= a (sqrt (+ (* b b) (* c c)))))\n           (and (= c (sqrt (+\
    \ (* a a) (* b b))))\n                (= a (sqrt (+ (* b b) (* c c))))\n     \
    \           (= b (sqrt (+ (* a a) (* c c)))))\n           (and (= c (sqrt (+ (*\
    \ a a) (* b b))))\n                (= b (sqrt (+ (* a a) (* c c))))\n        \
    \        (= a (sqrt (+ (* b b) (* c c))))))))\n</code>\nTest:\n<code>;; test cases",
  "  (if (and (&lt;= a b) (&lt;= b c))\n      (or (= (sqr a) (+ (sqr b) (sqr c)))\n\
    \          (= (sqr b) (+ (sqr a) (sqr c)))\n          (= (sqr c) (+ (sqr a) (sqr\
    \ b))))\n      (right_angle_triangle b a c)))\n</code>\nWith that change, it's\
    \ more than fast enough:\n<code>$ racket right_angle_triangle.rkt\n#t\n$ time\
    \ racket right_angle_triangle.rkt\n#t\n\nreal    0m0.338s\nuser    0m0.328s\n\
    sys     0m0.008s\n</code>\nA little explanation:\n<code>(if (and (&lt;= a b) (&lt;=\
    \ b c))\n    (or ...\n        ...\n        ...)\n    (right_angle_triangle b a\
    \ c))\n</code>\nHere, we first check if <code>a</code> and <code>b</code> are\
    \ out of order. If they are, we call ourselves with the same arguments but in\
    \ reverse order. The first time it's not out of order, we take the <code>or</code>\
    \ branch, which checks all three cases (<code>a</code> is the hypotenuse, <code>b</code>\
    \ is the hypotenuse, and <code>c</code> is the hypotenuse). We can do this because\
    \ the only way that we can get here is if <code>a</code> and <code>b</code> are\
    \ already in order.\n", "  (and (=\n         (expt a 2)\n         (+ (expt b 2)\
    \ (expt c 2)))\n       (> a 0)\n       (> b 0)\n       (> c 0)))\n", "  ;; your\
    \ code goes here\n  )\n", "  ;; Your code goes here.\n  )\n\n```\n\n```racket\n\
    #lang racket\n", "  (let ((a2 (* a a))\n        (b2 (* b b))\n        (c2 (* c\
    \ c)))\n    (if (and (&lt; a b) (&lt; b c))\n        (= a2 (+ b2 c2))\n      \
    \  #f)))\n", "  (let ([max-length (apply max (list a b c))])\n    (cond ((= (expt\
    \ a 2) (+ (expt b 2) (expt c 2))) True)\n          ((= (expt b 2) (+ (expt a 2)\
    \ (expt c 2))) True)\n          ((= (expt c 2) (+ (expt a 2) (expt b 2))) True)\n\
    \          (else False))))\n", "  (let ((asq (sqr a))\n        (bsq (sqr b))\n\
    \        (csq (sqr c)))\n    (and (and (<= a b c)\n              (<= (+ b c) a))\n\
    \         (= c (sqrt (+ asq bsq))))))\n", "  (cond\n    [(and (> a 0) (> b 0)\
    \ (> c 0)) (and (= (+ a c) b) (= (+ b c) a) (= (+ a b) c))]\n    [else false]))\n",
  "  (define (square x) (* x x))\n  (define (hypotenuse a b)\n    (cond\n      [(=\
    \ (square a) (+ (square b) (square c))) a]\n      [(= (square b) (+ (square a)\
    \ (square c))) b]\n      [(= (square c) (+ (square a) (square b))) c]\n      [else\
    \ #f]))\n  (cond\n    [(= (hypotenuse a b) (hypotenuse a c)) #t]\n    [(= (hypotenuse\
    \ a b) (hypotenuse b c)) #t]\n    [(= (hypotenuse a c) (hypotenuse b c)) #t]\n\
    \    [else #f]))\n```\n\n```racket\n#lang racket\n", "  (or (and (= (+ b c) (*\
    \ 2 a))\n\t   (= b c))\n      (and (= (+ a c) (* 2 b))\n\t   (= a c))\n      (and\
    \ (= (+ a b) (* 2 c))\n\t   (= a b))))\n", "  (let ([cds (sort (list a b c) <)])\n\
    \    (apply = (map (\u03BB (x y) (* y y)) cds (sort (map (\u03BB (x y) (- x y))\
    \ cds (cdr cds)) <)))))\n", "  (define (compare x y)\n    (and (= x y) (&gt; x\
    \ 0) (&gt; y 0)))\n  (and (compare a b) (compare b c) (compare c a)))\n", "  (if\
    \ (>= c (sqrt (+ (* a a) (* b b))))\n      (define max-side c)\n      (define\
    \ max-side (sqrt (+ (* a a) (* b b)))))\n  (and (= (- max-side a) (- max-side\
    \ b))\n       (= (- max-side a) (* (- max-side a) (/ b a)))))", "  (let ([hypotenuse\
    \ (max a b c)]\n        [a (if (= a hypotenuse) (min a b c) a)]\n        [b (if\
    \ (= b hypotenuse) (min a b c) b)])\n    (= (+ (* a a) (* b b)) (* hypotenuse\
    \ hypotenuse))))", "  (let ([a2 (+ (* a a) (* b b))]\n        [b2 (+ (* b b) (*\
    \ c c))]\n        [c2 (+ (* c c) (* a a))])\n    (or (= a2 c) (= b2 c) (= c2 a))))\n",
  "  (= (max (max a b) c)\n     (max a (max b c))))\n", "  (cond\n    [(< a 0) (error\
    \ \"One of the arguments was less than 0\")]\n    [(< b 0) (error \"One of the\
    \ arguments was less than 0\")]\n    [(< c 0) (error \"One of the arguments was\
    \ less than 0\")]\n    [(= a 0) #f]\n    [(= b 0) #f]\n    [(= c 0) #f]\n    [else\
    \ (or (= (square a) (+ (square b) (square c)))\n              (= (square b) (+\
    \ (square a) (square c)))\n              (= (square c) (+ (square a) (square b))))]))",
  "  (and (and (<= a b) (<= b c))\n       (= (+ (* a a) (* b b)) (* c c))))\n", " \
    \ (or (and (= a (sqrt (+ (* b b) (* c c))))\n           (= b (sqrt (+ (* a a)\
    \ (* c c))))\n           (= c (sqrt (+ (* a a) (* b b)))))\n      (and (= b (sqrt\
    \ (+ (* a a) (* c c))))\n           (= c (sqrt (+ (* a a) (* b b))))\n       \
    \    (= a (sqrt (+ (* b b) (* c c)))))\n      (and (= c (sqrt (+ (* a a) (* b\
    \ b))))\n           (= a (sqrt (+ (* b b) (* c c))))\n           (= b (sqrt (+\
    \ (* a a) (* c c)))))))\n", "  (cond ((and (and (&lt; a (max b c)) (&lt; b (max\
    \ a c)) (&lt; c (max a b)))\n              (and (= (sqr a) (+ (sqr b) (sqr c)))\n\
    \                   (= (sqr b) (+ (sqr a) (sqr c)))\n                   (= (sqr\
    \ c) (+ (sqr a) (sqr b)))))\n         #t)\n        (else #f)))\n</code>\nIn the\
    \ above example, for one of the test cases, it said that I am returning False\
    \ when I should return True. However, in the DrRacket environment, it always gives\
    \ the right answer:\n<code>&gt; (right_angle_triangle 3 4 5)\n#t\n&gt; (right_angle_triangle\
    \ 1 2 3)\n#f\n</code>\nIs there something I missed?\n\n\nA:\n\nIf all three sides\
    \ are smaller than the longest side, then we know it's a triangle! Also, I added\
    \ a few more tests, to see what was happening in some cases:\n<code>(define (right_angle_triangle\
    \ a b c)\n  (cond ((and (and (&lt; a (max b c))\n                  (&lt; b (max\
    \ a c))\n                  (&lt; c (max a b)))\n              (and (= (sqr a)\
    \ (+ (sqr b) (sqr c)))\n                   (= (sqr b) (+ (sqr a) (sqr c)))\n \
    \                  (= (sqr c) (+ (sqr a) (sqr b)))))\n         #t)\n        (else\
    \ #f)))\n", "  (cond [(< a b c) (= (+ a b) c)]\n        [(< b a c) (= (+ b a)\
    \ c)]\n        [(< b c a) (= (+ b c) a)]\n        [(< c b a) (= (+ c b) a)]\n\
    \        [(< c a b) (= (+ c a) b)]\n        [(< a c b) (= (+ a c) b)]))\n", " \
    \ (and\n   (and (< a (+ b c))\n        (< b (+ a c))\n        (< c (+ a b)))\n\
    \   (or (= (expt a 2) (+ (expt b 2) (expt c 2)))\n       (= (expt b 2) (+ (expt\
    \ a 2) (expt c 2)))\n       (= (expt c 2) (+ (expt a 2) (expt b 2))))))", "  (equal?\
    \ (sort a b c) '(3 4 5)))\n", "  (if (or (equal? (max a b c) a)\n          (equal?\
    \ (max a b c) b))\n      (and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n     \
    \      (or (= a b) (= b c) (= a c)))\n      (and (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2)))\n           (or (= a b) (= b c) (= a c)))))\n", "  (define (sq a) (*\
    \ a a))\n  (cond ((or (< a 1) (< b 1) (< c 1)) False)\n        ((and (= a b) (=\
    \ b c)) False)\n        ((and (>= a b) (>= a c)) (and (= a (+ (sq b) (sq c)))\
    \ True))\n        ((and (>= b a) (>= b c)) (and (= b (+ (sq a) (sq c))) True))\n\
    \        ((and (>= c a) (>= c b)) (and (= c (+ (sq a) (sq b))) True))\n      \
    \  (else False)))\n", "  (let ((m #f) (n #f) (p #f))\n    (cond\n      [(>= a\
    \ b) (and (set! m a) (set! n b))]\n      [(>= b a) (and (set! m b) (set! n a))])\n\
    \    (cond\n      [(>= c m) (and (set! p c) (set! m m) (set! n n))]\n      [(>=\
    \ m c) (and (set! p m) (set! m c) (set! n n))]\n      [(>= n c) (and (set! p n)\
    \ (set! m m) (set! n c))])\n    (= (* m m) (+ (* n n) (* p p)))))\n", "  (let\
    \ ([coor (map (cut abs <> -90) \n                   (map (cut - <> 90) \n    \
    \                    (map atan \n                             (map (/ <> (sqrt\
    \ (+ (* a a) (* b b))))\n                                  (list a b c)))))]\n\
    \    (or (= 90 (car coor))\n        (= 90 (cadr coor))\n        (= 90 (caddr coor)))))\n\
    ```\n\n```racket\n#lang racket\n", "  (and (and (and (&lt; a (+ b c)) (&lt; b\
    \ (+ a c))) (&lt; c (+ a b)))\n       (= (pow a 2) (+ (pow b 2) (pow c 2)))))\n\
    </code>\nQuestion:\nHow to make this function even better?\nHow to test this function?\n\
    How would you test it?\n\n\nA:\n\nAre all numbers positive?\nIf they are, you\
    \ can lose the <code>&lt;</code> guards.\nThe guard <code>(&lt; c (+ a b))</code>\
    \ is not necessary, because it is the same as saying that <code>(&lt; a (+ b c))</code>\
    \ is true.  So you can remove it.\nThe <code>and</code> in the two <code>and</code>s\
    \ can be removed, because <code>and</code> does that automatically.\n<code>(define\
    \ (right_angle_triangle a b c)\n  (and (&lt; a (+ b c))\n       (&lt; b (+ a c))\n\
    \       (= (pow a 2) (+ (pow b 2) (pow c 2)))))\n</code>\nThis is getting better,\
    \ but it's still not very nice.  It's not very clear, and it's not very efficient.\n\
    Remember the order of operations?  If you ask if a number is equal to a sum, you\
    \ should probably do the sum first.  Then you can test the equality.\n<code>(define\
    \ (right_angle_triangle a b c)\n  (and (&lt; a (+ b c))\n       (&lt; b (+ a c))\n\
    \       (= (pow a 2) (+ (pow b 2) (pow c 2)))))\n</code>\nNow the goal of the\
    \ function is clear: to find out if three numbers form a right triangle.  So let's\
    \ rewrite the function name.\n<code>(define (right-triangle? a b c)\n  (and (&lt;\
    \ a (+ b c))\n       (&lt; b (+ a c))\n       (= (pow a 2) (+ (pow b 2) (pow c\
    \ 2)))))\n</code>\nHow can we be more efficient about this?  Remember the Pythagorean\
    \ theorem? ", "  (cond\n    [(= c (+ (* a a) (* b b))) True]\n    [(= b (+ (*\
    \ a a) (* c c))) True]\n    [(= a (+ (* b b) (* c c))) True]\n    [else False]))\n",
  "  (let* ((max (max (max a b) c))\n         (min (min (min a b) c))\n         (other\
    \ (/ (- (+ a b c) (+ max min)) 2)))\n    (= (+ (* min min) (* other other)) (*\
    \ max max))))\n", "  (define (max a b)\n    (if (> a b) a b))\n  (define (hypotenuse\
    \ a b)\n    (sqrt (+ (* a a) (* b b))))\n  (equal? c (hypotenuse a b)))\n</code>\n",
  "  (let* ([sides (list a b c)]\n         [hypotenuse (apply max sides)]\n      \
    \   [legs (remove hypotenuse sides)])\n    (= (apply + legs) hypotenuse)))\n",
  "  (cond ((or (> a b) (> a c)) (right_angle_triangle b a c))\n        ((or (> b\
    \ c) (> b a)) (right_angle_triangle c b a))\n        ((= (+ a b) c) #t)\n    \
    \    (else #f)))\n", "  (define (square n) (* n n))\n  (define (hypotenuse x y)\
    \ (sqrt (+ (square x) (square y))))\n  (define (is_right_angle-triangle x y z)\n\
    \    (= z (hypotenuse x y)))\n  (let loop ([lst (list a b c)])\n    (if (null?\
    \ lst) #f\n        (if (is_right-angle-triangle (car lst) (cadr lst) (caddr lst))\n\
    \            #t\n            (loop (append (cdr lst) (list (car lst))))))))\n\
    ```\n\n## 10. Write a Racket function to sum of two given integers. However, if\
    \ the sum is between 15 to 20 it will return 20.\n\n```\n#lang racket\n", "  (cond\n\
    \    [(or (or (= a 90) (= b 90) (= c 90))\n      (or (= (+ a b) c) (= (+ a c)\
    \ b) (= (+ b c) a))) #t]\n    [else #f]))\n", "  (define (max-in-list lst)\n \
    \   (if (null? (cdr lst))\n        (car lst)\n        (if (&gt; (car lst) (max-in-list\
    \ (cdr lst)))\n            (car lst)\n            (max-in-list (cdr lst)))))\n\
    \  (define (sum-in-list lst)\n    (if (null? (cdr lst))\n        (car lst)\n \
    \       (+ (car lst) (sum-in-list (cdr lst)))))\n  (define (square x) (* x x))\n\
    \  (define (triangle-side-of-max lst)\n    (if (equal? (car lst) (max-in-list\
    \ lst))\n        (sum-in-list (cdr lst))\n        (if (equal? (cadr lst) (max-in-list\
    \ lst))\n            (+ (car lst) (caddr lst))\n            (+ (car lst) (cadr\
    \ lst)))))\n  (if (and (not (equal? a b)) (not (equal? b c)) (not (equal? a c)))\n\
    \      (if (&gt; (square (max-in-list (list a b c))) (square (triangle-side-of-max\
    \ (list a b c))))\n          #t\n          #f)\n      #f))\n", "  (let ((ab (+\
    \ a b))\n        (ac (+ a c))\n        (bc (+ b c)))\n    (cond ((= ab c) #t)\n\
    \          ((= ac b) #t)\n          ((= bc a) #t)\n          (else #f))))\n",
  "  (let ([max-len (apply max (list a b c))])\n    (and\n     (or (and (= (abs (-\
    \ max-len a)) (abs (- max-len b))) (= (* max-len max-len) (+ (* a a) (* b b))))\n\
    \         (and (= (abs (- max-len a)) (abs (- max-len c))) (= (* max-len max-len)\
    \ (+ (* a a) (* c c))))\n         (and (= (abs (- max-len b)) (abs (- max-len\
    \ c))) (= (* max-len max-len) (+ (* b b) (* c c)))))\n     (not (= max-len 0)))))\n",
  "  (define (max a b)\n    (if (&gt; a b) a b))\n  (define (max-in-three a b c)\n\
    \    (max (max a b) c))\n  (define (sum-other-two a b c)\n    (+ a b c (- (max-in-three\
    \ a b c))))\n  (define (max-square a b c)\n    (expt (max-in-three a b c) 2))\n\
    \  (= (max-square a b c)\n     (* (sum-other-two a b c)\n        (sum-other-two\
    \ a b c))))\n</code>\nHowever, I'm not sure if this is really the most elegant\
    \ solution, or if there are any Racket specific features that could be used to\
    \ make it even shorter.\nEdit:\nAdded Racket-specific suggestions and comments\
    \ on my solution below.\n\n\nA:\n\nI don't have Racket installed, but I'll give\
    \ it a shot.\nFirst, your use of <code>define</code> is nearly correct:\n<code>(define\
    \ (foo . x)\n  (apply + x))\n</code>\nI'll call that one <code>sum</code>.\nBut\
    \ you could have written <code>sum</code> with <code>lambda</code> instead of\
    \ <code>define</code>, so you could use it like this:\n<code>(apply (lambda x\
    \ (apply + x)) '(1 2 3))\n</code>\nThat one is harder to read and type, so only\
    \ use <code>lambda</code> when you need to.\nNext, we'll implement <code>map</code>\
    \ and <code>apply</code> in terms of <code>lambda</code>s and <code>sum</code>.\
    \ I'll let you figure out the definitions.\nNow, rewriting your code without <code>define</code>s,\
    \ it looks like this:\n<code>(define (sum . x)\n  (apply + x))\n", "  (let ([a*a\
    \ (+ (* a a) (* b b))])\n    (= c (exact-round (sqrt a*a)))))\n", "  (let* ([lst\
    \ (sort (list a b c) <)]\n         [first (car lst)]\n         [second (cadr lst)]\n\
    \         [third (caddr lst)])\n    (= (* first first) (+ (* second second) (*\
    \ third third)))))\n", "  (equal?\n   (sort (list a b c) <)\n   (list (sqrt (+\
    \ (* a a) (* b b)))\n         (sqrt (+ (* a a) (* c c)))\n         (sqrt (+ (*\
    \ b b) (* c c))))))\n", "  (let ([s (sort (list a b c) <)])\n    (zero? (- (*\
    \ (car s) (car s)) (+ (* (cadr s) (cadr s)) (* (caddr s) (caddr s)))))))\n", " \
    \ (cond\n    [(= b (sqrt (+ (* a a) (* c c))))]\n    [(= c (sqrt (+ (* a a) (*\
    \ b b))))]\n    [(= a (sqrt (+ (* b b) (* c c))))]\n    [else #f]))\n", "  (define\
    \ (is_right_angle_triangle ab bc ca)\n    (define ab-bc (truncate (* 1000 (- (sqr\
    \ ab) (sqr bc)))))\n    (define bc-ca (truncate (* 1000 (- (sqr bc) (sqr ca)))))\n\
    \    (define ca-ab (truncate (* 1000 (- (sqr ca) (sqr ab)))))\n    (and (= 0 (modulo\
    \ ab-bc 1000))\n         (= 0 (modulo bc-ca 1000))\n         (= 0 (modulo ca-ab\
    \ 1000))))\n  (cond\n    ((and (positive? a) (positive? b) (positive? c))\n  \
    \   (cond\n       ((or (= 0 a) (= 0 b) (= 0 c)) #f)\n       ((is_right_angle_triangle\
    \ a b c) #t)\n       ((is_right_angle_triangle b c a) #t)\n       ((is_right_angle_triangle\
    \ c a b) #t)\n       (else #f)))\n    (else #f)))\n", "  (and (or (= a c) (= b\
    \ c))\n       (if (= a c)\n           (> b c)\n           (> a c))))\n", "  (define\
    \ (right? a b c)\n    (and\n     (and\n      (= (expt a 2) (+ (expt b 2) (expt\
    \ c 2)))\n      (= a b c))\n     (and\n      (= (expt b 2) (+ (expt a 2) (expt\
    \ c 2)))\n      (= a b c))\n     (and\n      (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2)))\n      (= a b c))))\n  (right? a b c))\n</code>\n", "  (cond\n    [(or\
    \ (or (= a 0) (= b 0) (= c 0))\n         (< a b c)\n         (< b a c)\n     \
    \    (< c a b))\n     #f]\n    [(and (= (* a a) (+ (* b b) (* c c)))\n       \
    \   (= (* b b) (+ (* a a) (* c c)))\n          (= (* c c) (+ (* a a) (* b b))))\n\
    \     #t]\n    [else\n     #f]))\n", "  (and (> a 0)\n       (> b 0)\n       (>\
    \ c 0)\n       (or (= (expt a 2) (+ (expt b 2) (expt c 2)))\n           (= (expt\
    \ b 2) (+ (expt a 2) (expt c 2)))\n           (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2))))))\n```\n\n```racket\n#lang racket\n", "  (or (= (list-max (list a b\
    \ c)) (* a a))\n      (= (list-max (list a b c)) (* b b))\n      (= (list-max\
    \ (list a b c)) (* c c))))", "  (cond\n    [(or (or (= (max a b c) a) (= (max\
    \ a b c) b)) (= (max a b c) c)) True]\n    [else False]))\n", "  (and (and (=\
    \ (sqrt (+ (* a a) (* b b))) c)\n\t    (= (sqrt (+ (* a a) (* c c))) b)\n\t  \
    \  (= (sqrt (+ (* b b) (* c c))) a))\n       #t))\n", "  (cond\n    [(>= a 0)\
    \ (sqrt (+ (* a a) (* b b)))]\n    [(>= b 0) (sqrt (+ (* a a) (* c c)))]\n   \
    \ [(>= c 0) (sqrt (+ (* b b) (* c c)))]))\n", "  (= (* c c) (+ (* a a) (* b b))))\n",
  "  (= 90 (angle a b c)))\n", "  (equal?\n   (sort (list a b c) <)\n   (map (curry\
    \ square) (list 3 4 5))))\n", "  (let ([ab (+ a b)]\n        [ac (+ a c)]\n  \
    \      [bc (+ b c)])\n    (or (= a ab) (= a ac) (= a bc)\n        (= b ab) (=\
    \ b ac) (= b bc)\n        (= c ab) (= c ac) (= c bc))))\n", "  (equal? (sqrt (+\
    \ (* a a) (* b b))) c))\n", "  (and (= (sqrt (+ (* a a) (* b b))) c)\n       (=\
    \ (sqrt (+ (* a a) (* c c))) b)\n       (= (sqrt (+ (* b b) (* c c))) a)))\n",
  "  (let* ((max-side (max a b c))\n         (other-two-sides (list (if (eq? a max-side)\
    \ b c)\n                                (if (eq? b max-side) a c))))\n    (and\
    \ (member (sqr (car other-two-sides))\n                 (list (sqr (cadr other-two-sides))\n\
    \                       (sqr max-side)))\n         (not (null? other-two-sides)))))\n",
  "  (cond ((< a 0) #f)\n        ((< b 0) #f)\n        ((< c 0) #f)\n        ((= c\
    \ (sqrt (+ (* a a) (* b b)))) #t)\n        ((= b (sqrt (+ (* a a) (* c c)))) #t)\n\
    \        ((= a (sqrt (+ (* b b) (* c c)))) #t)\n        (else #f)))", "  (let*\
    \ ([side-a (max a b c)]\n         [side-b (min a b c)]\n         [side-c (car\
    \ (filter\n                       (lambda (x)\n                         (and (not\
    \ (= x side-a))\n                              (not (= x side-b))))\n        \
    \               (list a b c)))]\n         [hypotenuse (sqrt (+ (* side-a side-a)\
    \ (* side-b side-b)))])\n    (= hypotenuse side-c)))\n", "  (define (square n)\
    \ (* n n))\n  (or (= (square a) (+ (square b) (square c)))\n      (= (square b)\
    \ (+ (square a) (square c)))\n      (= (square c) (+ (square a) (square b)))))\n",
  "  (let ([m (find-max a b c)])\n    (and (= 3 m) (= a b c))))", "  (and\n   (>=\
    \ a b c)\n   (= (expt a 2) (+ (expt b 2) (expt c 2)))))\n", "  (define (find-hypotenuse\
    \ abc)\n    (cond ((> a b) (cond ((> a c) a) (else c)))\n          ((> b c) b)\n\
    \          (else c)))\n  (if (= (find-hypotenuse (list a b c)) (sqrt (+ (* a a)\
    \ (* b b))))\n      #t\n      #f))\n", "  (define sqr (lambda (x) (* x x)))\n\
    \  (cond [(or (= 0 a) (= 0 b) (= 0 c)) false]\n        [(= a b c) false]\n   \
    \     [(= a (sqr c)) true]\n        [(= b (sqr c)) true]\n        [(= c (sqr a))\
    \ true]\n        [else false]))\n", "  (and (or (= (square b) (+ (square a) (square\
    \ c)))\n           (= (square a) (+ (square b) (square c)))\n           (= (square\
    \ c) (+ (square a) (square b))))\n       (= (+ a b c) 180)))\n", "  (if (and (and\
    \ (&lt; a (+ b c)) (&gt; a (- b c)))\n           (and (&lt; b (+ a c)) (&gt; b\
    \ (- a c)))\n           (and (&lt; c (+ a b)) (&gt; c (- a b))))\n      (and (equal?\
    \ (expt a 2) (+ (expt b 2) (expt c 2)))\n           (equal? (expt b 2) (+ (expt\
    \ a 2) (expt c 2)))\n           (equal? (expt c 2) (+ (expt a 2) (expt b 2))))\n\
    \      false))\n", "  (or (= a (sqrt (+ (* b b) (* c c))))\n      (= b (sqrt (+\
    \ (* a a) (* c c))))\n      (= c (sqrt (+ (* a a) (* b b))))))\n", "  (and (and\
    \ (and (&lt; a b) (&lt; a c))\n            (&lt;= (+ (* a a) (* b b)) (* c c)))\n\
    \       (and (and (&lt; b a) (&lt; b c))\n            (&lt;= (+ (* b b) (* a a))\
    \ (* c c)))\n       (and (and (&lt; c a) (&lt; c b))\n            (&lt;= (+ (*\
    \ c c) (* a a)) (* b b)))))\n", "  (and (and (and (not (= a b)) (= (expt a 2)\
    \ (+ (expt b 2) (expt c 2))))\n            (not (= a c)) (= (expt a 2) (+ (expt\
    \ b 2) (expt c 2))))\n       (not (= b c)) (= (expt a 2) (+ (expt b 2) (expt c\
    \ 2)))))\n</code>\nIt works, but it is ugly.\nMy question is: is there some elegant\
    \ way to write the same thing?\n\n\nA:\n\nYou could use <code>andmap</code> to\
    \ generalize the pattern:\n<code>(define (right_angle_triangle a b c)\n  (andmap\
    \ (lambda (x) (= x a)) '(b c)))\n</code>\nThe above should return <code>#t</code>\
    \ if <code>a</code> is the greatest side.\n", "  (define (right_angle-helper a\
    \ b c)\n    (if (or (equal? a (+ b c)) (equal? b (+ a c)) (equal? c (+ a b)))\n\
    \        true\n        false))\n  (right_angle-helper a b c))\n</code>\nOf course,\
    \ there are other ways to accomplish this goal, but at least it will work in both\
    \ Racket and Python.\n", "  (and (<= a c) (<= b c) (= (+ (sqr (- a (/ c 2))) (sqr\
    \ (- b (/ c 2)))) (sqr c))))\n", "  (define (square x) (* x x))\n  (cond [(= (square\
    \ a) (+ (square b) (square c))) true]\n        [(= (square b) (+ (square a) (square\
    \ c))) true]\n        [(= (square c) (+ (square a) (square b))) true]\n      \
    \  [else false]))\n</code>\n", "  (and (= 90 (exact-integer-sqrt ( + (expt a 2)\
    \ (expt b 2))))\n       (= 90 (exact-integer-sqrt ( + (expt a 2) (expt c 2))))\n\
    \       (= 90 (exact-integer-sqrt ( + (expt b 2) (expt c 2))))))\n", "  (cond\n\
    \    [(= a (sqrt (+ (sqr b) (sqr c)))) #t]\n    [(= b (sqrt (+ (sqr a) (sqr c))))\
    \ #t]\n    [(= c (sqrt (+ (sqr a) (sqr b)))) #t]\n    [else #f]))\n</code>\nIn\
    \ the <code>right_angle_triangle</code> function, my if statement looks like this:\n\
    <code>(= a (sqrt (+ (sqr b) (sqr c))))\n</code>\nI know it is checking if <code>a</code>\
    \ is equal to the square root of <code>b</code> squared plus <code>c</code> squared,\
    \ but can someone explain in more detail what the <code>sqr</code> and <code>sqrt</code>\
    \ functions are doing?\n\n\nA:\n\nIf you run that in DrRacket, it will actually\
    \ show you what <code>sqr</code> and <code>sqrt</code> are:\n<code>#lang racket\n",
  "  (and (< a (+ b c))\n       (< b (+ a c))\n       (< c (+ a b))\n       (= (expt\
    \ c 2) (+ (expt a 2) (expt b 2)))))\n", "  (cond\n    [(and\n      (and\n    \
    \    (= c (sqrt (+ (* a a) (* b b))))\n        (= c (sqrt (+ (* b b) (* a a)))))\n\
    \      (and\n        (and\n          (> a b)\n          (> a c))\n        (and\n\
    \          (> b a)\n          (> b c))))\n     #t]\n    [else #f]))\n", "  (cond\
    \ [(or (= a (* b b)) (= b (* a a)) (= c (* a a))) True]\n        [else False]))\n",
  "  (let ([triangle-list (list a b c)])\n    (define (is-right? triangle-list)\n\
    \      (cond\n        [(null? triangle-list) false]\n        [(= 0 (modulo (car\
    \ triangle-list) 90)) true]\n        [else (is-right? (cdr triangle-list))]))\n\
    \    (let ([squared-list (map (lambda (x) (* x x)) triangle-list)])\n      (and\
    \ (is-right? triangle-list)\n           (= (apply + squared-list)\n          \
    \    (car (sort (lambda (x y) (< x y)) squared-list)))))))", "  (or (= a (sqrt\
    \ (+ (* b b) (* c c))))\n      (= b (sqrt (+ (* a a) (* c c))))\n      (= c (sqrt\
    \ (+ (* a a) (* b b))))))\n", "  (equal? (square a) (+ (square b) (square c))))\n",
  "  (or (and (>= a (+ b c))\n           (< a (+ b c)))\n      (and (>= b (+ a c))\n\
    \           (< b (+ a c)))\n      (and (>= c (+ a b))\n           (< c (+ a b)))))\n",
  "  (and (or (or (= a (expt b 2)) (= b (expt a 2)))\n           (or (= a (expt c\
    \ 2)) (= c (expt a 2)))\n           (or (= b (expt c 2)) (= c (expt b 2))))\n\
    \       (not (or (= a 0) (= b 0) (= c 0)))))", "  (let ([sorted (sort (list a\
    \ b c) <)])\n    (and (and (< (car sorted) (+ (cadr sorted) (caddr sorted)))\n\
    \              (> (cadr sorted) (caddr sorted)))\n         (= (expt (car sorted)\
    \ 2) (+ (expt (cadr sorted) 2) (expt (caddr sorted) 2))))))\n", "  ;; As the longest\
    \ side will always be the hypotenuse of the triangle,\n  ;; I decided to rewrite\
    \ the input list by sorting by the length of the\n  ;; sides and swap the first\
    \ two elements if the list is sorted in descending\n  ;; order.\n  (define (swap-first-two\
    \ lst)\n    (define (swap-first-two-helper lst i acc)\n      (if (&lt; i 2)\n\
    \          (cons (car lst) acc)\n          (swap-first-two-helper (cdr lst) (-\
    \ i 1) (cons (car lst) acc))))\n    (swap-first-two-helper lst 3 '()))\n  (define\
    \ (calculate-pythagorean-triple lst)\n    (if (empty? lst)\n        '()\n    \
    \    (define (square-num num)\n          (* num num))\n        (if (=\n      \
    \      (+ (square-num (car lst)) (square-num (cadr lst)))\n            (square-num\
    \ (caddr lst)))\n            #t\n            #f)))\n  (calculate-pythagorean-triple\
    \ (swap-first-two (sort &lt; (list a b c)))))\n</code>\nI am sure there is a better\
    \ way to implement this than I have. I decided to swap the first two elements\
    \ so that the longest side is always the hypotenuse as it seemed easier than to\
    \ check if the right conditions are met for the side lengths.\nI am open to any\
    \ other suggestions for this exercise as I feel like I've over-complicated it\
    \ a bit.\n\n\nA:\n\nWelcome to Stack Overflow!\nWith your question, you have some\
    \ formatting/identation problems which you should fix asap.\nAs you noted, your\
    \ solution is too complicated. You can just get the hypotenuse value and check\
    \ if the sum of the other two values is the same as the square of the hypotenuse\
    \ value. You can use <code>apply</code> to put a variable number of arguments\
    \ into a function call.\n<code>(define (right_angle_triangle a b c)\n  (define\
    \ (hypotenuse x y) (sqrt (+ (* x x) (* y y))))\n  (", "  (cond\n    [(or (or (or\
    \ (= a (* b b)) (= b (* a a))) (= c (* a a))) (= c (* b b))) #t]\n    [else #f]))\n",
  "  (define (has_right_angle? triangle)\n    (equal? (length triangle) 2))\n  (define\
    \ (get-right-angle-index triangle)\n    (cond ((has_right-angle? triangle) (add1\
    \ (list-ref triangle 1)))\n          (else -1)))\n  (define (get-right-angle-value\
    \ triangle)\n    (cond ((has_right-angle? triangle) (list-ref triangle 1))\n \
    \         (else -1)))\n  (define (gcd a b)\n    (cond ((equal? a 0) b)\n     \
    \     ((equal? b 0) a)\n          ((= a b) a)\n          ((> a b) (gcd (sub1 a)\
    \ b))\n          (else (gcd a (sub1 b)))))\n  (define (gcd-list lst)\n    (cond\
    \ ((empty? lst) 0)\n          ((= (length lst) 1) (car lst))\n          (else\
    \ (gcd (car lst) (gcd-list (cdr lst))))))\n  (define (get-triangle-sides triangle)\n\
    \    (cond ((has_right-angle? triangle)\n           (list (list-ref triangle 0)\
    \ (list-ref triangle 2)))\n          (else\n           (list (list-ref triangle\
    \ 0) (list-ref triangle 1) (list-ref triangle 2)))))\n  (define (get-triangle-hypotenuse\
    \ triangle)\n    (if (has_right-angle? triangle)\n        (list-ref triangle 2)\n\
    \        (list-ref triangle 2)))\n  (define (get-triangle-right-angle-index triangle)\n\
    \    (if (has_right-angle? triangle)\n        (add1 (list-ref triangle 1))\n \
    \       (list-ref triangle 1)))\n  (define (get-area triangle)\n    (if (has_right-angle?\
    \ triangle)\n        (list-ref triangle 0)\n        (list-ref triangle 0)))\n\
    \  (define (get-legs-area triangle)\n    (if (has_right-angle? triangle)\n   \
    \     (list-ref triangle 1)\n        (list-ref triangle 1)))\n  (define (get-hypot",
  "  (define (is-right-angle-triangle a b c)\n    (let (([a b c] (sort (list a b c)\
    \ <)))\n      (= (* a a) (+ (* b b) (* c c)))))\n  (and (and (and (< a (+ b c))\
    \ (< b (+ a c)) (< c (+ a b)))\n            (and (> a (- b c)) (> b (- a c)) (>\
    \ c (- a b))))\n       (is-right-angle-triangle a b c)))\n", "  (if (and (&lt;=\
    \ a b)\n           (&lt;= b c)\n           (&lt;= c (+ a b)))\n      (equal? (sqrt\
    \ (+ (* a a) (* b b))) c)\n      #f))\n", "  (cond\n    [(or (= a 0) (= b 0) (=\
    \ c 0)) #f]\n    [(and (> a 0) (> b 0) (> c 0)) (and (= (sqr a) (+ (sqr b) (sqr\
    \ c)))\n                                         (and (> a b) (> a c)))]\n   \
    \ [else #f]))", "  (and (= (expt a 2) (+ (expt b 2) (expt c 2)))\n       (or (=\
    \ a b) (= b c) (= a c))))\n", "  (and (and (&lt; a b) (&lt; a c))\n       (= (expt\
    \ a 2) (+ (expt b 2) (expt c 2)))))\n", "  (and (and (and (> a 0) (> b 0) (> c\
    \ 0))\n            (or (= a b) (= b c) (= a c)))\n       (or (and (= (expt a 2)\
    \ (+ (expt b 2) (expt c 2))) (= (expt b 2) (+ (expt a 2) (expt c 2))))\n     \
    \      (and (= (expt b 2) (+ (expt a 2) (expt c 2))) (= (expt c 2) (+ (expt a\
    \ 2) (expt b 2))))\n           (and (= (expt c 2) (+ (expt a 2) (expt b 2))) (=\
    \ (expt a 2) (+ (expt b 2) (expt c 2)))))))\n", "  (and (not (zero? (+ (* a a)\
    \ (* b b))))\n       (= (expt (expt a 2) 1/2) c)))\n", "  (and (or (= b c) (=\
    \ a c) (= a b)) (or (= (expt a 2) (+ (expt b 2) (expt c 2))) (= (expt b 2) (+\
    \ (expt a 2) (expt c 2))) (= (expt c 2) (+ (expt a 2) (expt b 2))))))\n", "  (and\
    \ (<= a c) (<= b c) (<= (+ a b) (* 2 c))))\n", "  (cond\n    [(and (= (expt a\
    \ 2) (+ (expt b 2) (expt c 2)))\n          (<= a b c))\n     #t]\n    [else\n\
    \     #f]))\n", "  (and (and (and (&lt; a b) (&lt; a c))\n            (&lt; b\
    \ c))\n       (= (+ (* a a) (* b b)) (* c c))))\n</code>\nTest:\n<code>#lang racket\n",
  "  (and\n   (= (square a) (+ (square b) (square c)))\n   (= (square b) (+ (square\
    \ a) (square c)))\n   (= (square c) (+ (square a) (square b)))))\n", "  (define\
    \ (hypot a b)\n    (sqrt (+ (* a a) (* b b))))\n  (define (length list)\n    (cond\n\
    \      [(empty? list) 0]\n      [else (+ 1 (length (rest list)))]))\n  (define\
    \ (sort-list list)\n    (cond\n      [(empty? list) empty]\n      [else (append\
    \ (sort-list (filter (lambda (item) (&lt; item (first list))) list))\n       \
    \             (list (first list))\n                    (sort-list (filter (lambda\
    \ (item) (&gt; item (first list))) list)))]))\n  (define (eq-len list a b)\n \
    \   (cond\n      [(empty? list) #f]\n      [(= (first list) a) (if (= (first (rest\
    \ list)) b) #t #f)]\n      [(= (first list) b) (if (= (first (rest list)) a) #t\
    \ #f)]\n      [else (eq-len (rest list) a b)]))\n  (let* ([len-list (sort-list\
    \ (list a b c))]\n         [l3 (first len-list)]\n         [l2 (first (rest len-list))]\n\
    \         [l1 (first (rest (rest len-list)))]\n         [h  (hypot l2 l1)])\n\
    \    (cond\n      [(= (length len-list) 3) (eq-len (list l1 l2 l3) h l2)]\n  \
    \    [else #f])))\n", "  (cond\n    [(or (= a 0) (= b 0) (= c 0)) false]\n   \
    \ [(= (sqrt (+ (* a a) (* b b))) c) true]\n    [(= (sqrt (+ (* a a) (* c c)))\
    \ b) true]\n    [(= (sqrt (+ (* b b) (* c c))) a) true]\n    [else false]))\n\
    </code>\nYour own example would have been even better, because you would have\
    \ seen that it did not work (for your example it returns <code>#f</code>). But\
    \ it works for mine:\n<code>&gt; (right_angle_triangle 3 4 5)\n#t\n</code>\n",
  "  (define (square x) (* x x))\n  (define (hypotenuse x y)\n    (define (min x y)\n\
    \      (if (< x y) x y))\n    (define (max x y)\n      (if (> x y) x y))\n   \
    \ (max (min x y) (- (max x y) (min x y))))\n  (define (square-of-hypotenuse x\
    \ y)\n    (square (hypotenuse x y)))\n  (define (square-of-cathetus x y)\n   \
    \ (- (square (max x y)) (square (min x y))))\n  (= (+ (square-of-hypotenuse a\
    \ b) (square-of-hypotenuse a c))\n     (square-of-hypotenuse b c)))\n</code>\n\
    There are several Racket versions of the Pythagorean theorem and the definition\
    \ of right-angled triangle, so I would like to know if I have missed an existing\
    \ Racket function which would be useful for the task or if my implementation is\
    \ the most efficient possible way.\n", "  (or (= a (+ b c))\n      (= b (+ a c))\n\
    \      (= c (+ a b))))\n", "  (and (> c a) (> c b)\n       (= (expt (+ (expt a\
    \ 2) (expt b 2)) 0.5) c)))\n", "  (let ([sides (sort (list a b c) <)])\n    (and\
    \ (equal? 3 (length sides))\n         (<= (square (first sides)) (+ (square (second\
    \ sides)) (square (third sides)))))))\n", "  (equal? (equal? (max (max a b) c)\
    \ c) (equal? (+ a b) (+ c (- c)))))\n", "  (let ([max (max a b c)])\n    (if (=\
    \ max a)\n        (if (= (+ (sqr b) (sqr c)) (sqr a))\n            #t\n      \
    \      #f)\n        (if (= max b)\n            (if (= (+ (sqr a) (sqr c)) (sqr\
    \ b))\n                #t\n                #f)\n            (if (= (+ (sqr a)\
    \ (sqr b)) (sqr c))\n                #t\n                #f)))))\n", "  (let ((sqr\
    \ (lambda (x) (* x x))))\n    (cond [(and (= (sqr a) (+ (sqr b) (sqr c))) (= a\
    \ (+ b c))) #t]\n          [(and (= (sqr b) (+ (sqr a) (sqr c))) (= b (+ a c)))\
    \ #t]\n          [(and (= (sqr c) (+ (sqr a) (sqr b))) (= c (+ a b))) #t]\n  \
    \        [else #f])))\n</code>\nBut I think it doesn't look as good as it could.\
    \ Can you help me make it better?\n\n\nA:\n\nIn the same language, here's a possible\
    \ refactoring that improves readability and efficiency by using <code>let*</code>\
    \ and <code>or</code> to simplify the conditions, and by moving the computation\
    \ of <code>sqr</code> inside the <code>cond</code> clause:\n<code>(define (right_angle_triangle\
    \ a b c)\n  (let* ((sqr (lambda (x) (* x x)))\n         (triangle (list a b c))\n\
    \         (legs (sort triangle &lt;))\n         (hypotenuse (last legs)))\n  \
    \  (or (and (= (sqr (first legs)) (+ (sqr (second legs)) (sqr hypotenuse)))\n\
    \             (= hypotenuse (+ (first legs) (second legs))))\n        (and (=\
    \ (sqr (second legs)) (+ (sqr (first legs)) (sqr hypotenuse)))\n             (=\
    \ hypotenuse (+ (first legs) (second legs)))))))\n</code>\nA possible improvement\
    \ in readability could be to create an <code>angle-triangle?</code> procedure\
    \ that will receive a list of legs and compute the hypotenuse and then return\
    \ <code>#t</code> or <code>#f</code>.\n<code>(define (angle-triangle? legs)\n\
    \  (or (and (= (sqr (first legs)) (+ (sqr (second legs)) (sqr (last legs))))\n\
    \           (= (last legs) (+ (first legs) (second legs))))\n      (and (= (sqr\
    \ (second legs)) (+ (sqr (first legs)) (sqr (last", "  (cond ((and (&lt;= a b)\
    \ (&lt;= b c))\n         (= (+ (* a a) (* b b)) (* c c)))\n        ((and (&lt;=\
    \ a c) (&lt;= c b))\n         (= (+ (* a a) (* c c)) (* b b)))\n        ((and\
    \ (&lt;= b a) (&lt;= a c))\n         (= (+ (* b b) (* a a)) (* c c)))\n      \
    \  ((and (&lt;= b c) (&lt;= c a))\n         (= (+ (* b b) (* c c)) (* a a)))\n\
    \        ((and (&lt;= c a) (&lt;= a b))\n         (= (+ (* c c) (* a a)) (* b\
    \ b)))\n        ((and (&lt;= c b) (&lt;= b a))\n         (= (+ (* c c) (* b b))\
    \ (* a a)))))\n", "  (let ([n (list a b c)])\n    (equal? (list-sort (lambda (x\
    \ y) (< x y)) n)\n            (list (apply max n)\n                  (- (apply\
    \ max n) (apply min n))\n                  (apply min n)))))\n", "  (cond\n  \
    \  ((and (<= a 0) (<= b 0) (<= c 0)) False)\n    ((= a (expt b 2)) (= a (expt\
    \ c 2))) True)\n    ((= b (expt a 2)) (= b (expt c 2))) True)\n    ((= c (expt\
    \ a 2)) (= c (expt b 2))) True)\n    (else False)))\n", "  (and (and (not (= c\
    \ (square a))) (not (= c (square b))))\n       (or (= c (square (+ a b))) (= b\
    \ (square (+ a c))) (= a (square (+ b c))))))\n", "  (and (<= a b c)\n       (and\
    \ (>= a (+ b c))\n            (<= a (- b c)))))\n```\n\n```python\n# Given the\
    \ lengths of the three sides of a triangle. Return True if the three\n# sides\
    \ form a right-angled triangle, False otherwise.\n# A right-angled triangle is\
    \ a triangle in which one angle is right angle or \n# 90 degree.\n# Example:\n\
    # right_angle_triangle(3, 4, 5) == True\n# right_angle_triangle(1, 2, 3) == False\n\
    def right_angle_triangle(a, b, c):\n    return (a <= b <= c) and (a >= b - c)\
    \ and (a <= b + c)\n```\n\n```javascript\n// Given the lengths of the three sides\
    \ of a triangle. Return True if the three\n// sides form a right-angled triangle,\
    \ False otherwise.\n// A right-angled triangle is a triangle in which one angle\
    \ is right angle or \n// 90 degree.\n// Example:\n// right_angle_triangle(3, 4,\
    \ 5) == True\n// right_angle_triangle(1, 2, 3) == False\nfunction right_angle_triangle(a,\
    \ b, c) {\n  return (a <= b <= c) && (a >= b - c) && (a <= b + c);\n}\n```\n\n\
    ```swift\n// Given the lengths of the three sides of a triangle. Return True if\
    \ the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled\
    \ triangle is a triangle in which one angle is right angle or \n// 90 degree.\n\
    // Example:\n// right_angle_triangle(3, 4, 5) == True\n// right_angle_triangle(1,\
    \ 2, 3) == False\nfunc right_angle_triangle(a: Int, b: Int, c: Int) -> Bool {\n\
    \  return (a <= b && b <= c) && (a >= b - c) && (a <= b + c)\n}\n```\n\n```typescript\n\
    // Given the lengths of the three sides of a triangle. Return True if the three\n\
    // sides form a right-angled triangle", "  (let ([cosine-angle (acos (/ (sqr (-\
    \ a b)) (+ (* a a) (* b b))))])\n    (>= (/ (sqr (- 90 cosine-angle)) 100) 0.01)))\n",
  "  (let ((max (max a b c)))\n    (and (equal? (sqrt (- (* max max) (+ (* a a) (*\
    \ b b)))) c)\n         (equal? (sqrt (- (* max max) (+ (* a a) (* c c)))) b)\n\
    \         (equal? (sqrt (- (* max max) (+ (* b b) (* c c)))) a))))\n", "  (and\n\
    \   (>= a b c)\n   (or (= a (+ b c))\n       (= b (+ a c))\n       (= c (+ a b)))))\n\
    ```\n\n## Testing\n\n```racket\n#lang racket\n", "  (if (and (= (expt (+ (expt\
    \ a 2) (expt b 2)) 0.5) c)\n           (or (= a 90) (= b 90) (= c 90)))\n    \
    \  True\n      False))\n", "  (let ((a_squared (* a a))\n        (b_squared (*\
    \ b b))\n        (c_squared (* c c)))\n    (or (= a_squared (+ b_squared c_squared))\n\
    \        (= b_squared (+ a_squared c_squared))\n        (= c_squared (+ a_squared\
    \ b_squared)))))\n", "  (cond\n    [(or (= a 0) (= b 0) (= c 0)) #f]\n    [(and\
    \ (= (sqr a) (+ (sqr b) (sqr c)))\n          (= (sqr b) (+ (sqr a) (sqr c)))\n\
    \          (= (sqr c) (+ (sqr a) (sqr b)))) #t]\n    [else #f]))\n</code>\n",
  "  (let ([(max-side) (max a b c)])\n    (and (= (expt (- max-side a) 2)\n      \
    \      (+ (expt (- max-side b) 2)\n               (expt (- max-side c) 2)))\n\
    \         (and (<= a (+ b c))\n              (<= b (+ a c))\n              (<=\
    \ c (+ a b))))))\n", "  (or (= a (expt (+ (expt b 2) (expt c 2)) 0.5))\n     \
    \ (= b (expt (+ (expt a 2) (expt c 2)) 0.5))\n      (= c (expt (+ (expt a 2) (expt\
    \ b 2)) 0.5))))\n", "  (= 90 (angle-of-triangle a b c)))\n", "  (not (or (or (=\
    \ a b) (= a c) (= b c))\n           (or (&lt; a 0) (&lt; b 0) (&lt; c 0))\n  \
    \         (or (not (= (+ (* a a) (* b b)) (* c c)))\n               (not (= (+\
    \ (* a a) (* c c)) (* b b)))\n               (not (= (+ (* b b) (* c c)) (* a\
    \ a)))))))\n", "  (let* ([a2 (+ (* a a) (* b b))]\n         [b2 (+ (* a a) (*\
    \ c c))]\n         [c2 (+ (* b b) (* c c))])\n    (or (and (= a2 c2) (= c b))\n\
    \        (and (= a2 b2) (= b c))\n        (and (= b2 c2) (= c a)))))\n", "  (=\
    \ 90 (right_angle_triangle.angle-of-triangle a b c)))\n", "  (and (not (zero?\
    \ a))\n       (not (zero? b))\n       (not (zero? c))\n       (and (and (= (pow\
    \ a 2) (+ (pow b 2) (pow c 2)))\n                (= (pow c 2) (+ (pow a 2) (pow\
    \ b 2))))\n            (or (= (pow a 2) (+ (pow b 2) (pow c 2)))\n           \
    \     (= (pow b 2) (+ (pow a 2) (pow c 2)))))))\n", "  (and (= (max a b c) c)\n\
    \       (= (min a b c) (sqrt (+ (* a a) (* b b))))))\n", "  (cond\n    [(and (>\
    \ c a) (> c b))\n     (and\n       (= (expt a 2) (+ (expt b 2) (expt c 2)))\n\
    \       (= (expt b 2) (+ (expt a 2) (expt c 2)))\n       (= (expt c 2) (+ (expt\
    \ a 2) (expt b 2))))]\n    [(and (> b a) (> b c))\n     (and\n       (= (expt\
    \ a 2) (+ (expt b 2) (expt c 2)))\n       (= (expt b 2) (+ (expt a 2) (expt c\
    \ 2)))\n       (= (expt c 2) (+ (expt a 2) (expt b 2))))]\n    [(and (> a b) (>\
    \ a c))\n     (and\n       (= (expt a 2) (+ (expt b 2) (expt c 2)))\n       (=\
    \ (expt b 2) (+ (expt a 2) (expt c 2)))\n       (= (expt c 2) (+ (expt a 2) (expt\
    \ b 2))))]\n    [else #f]))\n", "  (and (= (sqrt (+ (* a a) (* b b))) c)\n   \
    \    (= (sqrt (+ (* a a) (* c c))) b)\n       (= (sqrt (+ (* b b) (* c c))) a)))\n\
    </code>\nResult:\n<code>Welcome to DrRacket, version 6.10 [3m].\nLanguage: racket\
    \ [custom]; memory limit: 1024 MB.\n&gt; (right_angle_triangle 3 4 5)\n#t\n&gt;\
    \ (right_angle_triangle 1 2 3)\n#f\n&gt; \n</code>\nHowever, this doesn't seem\
    \ to be the most efficient way of doing it (using three\n<code>sqrt</code>), and\
    \ it doesn't work with negative values.\nAny idea how to make this better?\n\n\
    \nA:\n\nThe problem is that the relation:\n<code>sqrt(a^2 + b^2) = c\n</code>\n\
    Only applies for positive integers a, b, c, and does not imply the inverse relation:\n\
    <code>a^2 + b^2 = c^2\n</code>\nIf you want to check whether a right triangle\
    \ exists, you need to use the latter relation.\n", "  (cond\n    [(equal? a (sqrt\
    \ (+ (sqr b) (sqr c)))) true]\n    [(equal? b (sqrt (+ (sqr a) (sqr c)))) true]\n\
    \    [(equal? c (sqrt (+ (sqr a) (sqr b)))) true]\n    [else false]))\n", "  (and\
    \ (and (> a 0) (> b 0) (> c 0))\n       (and (< (+ a b) c)\n            (< (+\
    \ a c) b)\n            (< (+ b c) a))\n       (and (< (- (- a b) c) 0)\n     \
    \       (< (- (- a c) b) 0)\n            (< (- (- b c) a) 0))))", "  (if (or (and\
    \ (> a 0) (> b 0) (> c 0))\n          (and (> a 0) (> (- b c) 0) (> (- a c) 0))\n\
    \          (and (> b 0) (> (- a c) 0) (> (- a b) 0))\n          (and (> c 0) (>\
    \ (- a b) 0) (> (- b c) 0)))\n      #t\n      #f))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
