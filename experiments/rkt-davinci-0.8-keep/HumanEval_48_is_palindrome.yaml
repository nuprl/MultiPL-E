name: HumanEval_48_is_palindrome
language: rkt
prompt: "#lang racket\n\n;; Checks if given string is a palindrome\n;; >>> is_palindrome('')\n\
  ;; True\n;; >>> is_palindrome('aba')\n;; True\n;; >>> is_palindrome('aaaaa')\n;;\
  \ True\n;; >>> is_palindrome('zbcd')\n;; False\n(define (is_palindrome text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_palindrome))\n\
  \    (check-equal? (candidate \"\") #t)\n    (check-equal? (candidate \"aba\") #t)\n\
  \    (check-equal? (candidate \"aaaaa\") #t)\n    (check-equal? (candidate \"zbcd\"\
  ) #f)\n    (check-equal? (candidate \"xywyx\") #t)\n    (check-equal? (candidate\
  \ \"xywyz\") #f)\n    (check-equal? (candidate \"xywzx\") #f)\n))\n\n(test-humaneval)"
completions: ["  (define (match-from-the-center length)\n    (and (&lt; length (string-length\
    \ text))\n         (= (string-ref text (- length 1))\n            (string-ref\
    \ text (+ length 1)))))\n  (define (palindrome-helper n)\n    (cond ((= n 0) #t)\n\
    \          ((match-from-the-center n) (palindrome-helper (- n 1)))\n         \
    \ (else #f)))\n  (palindrome-helper (quotient (string-length text) 2)))\n</code>\n\
    Below is the Python solution:\n<code># Checks if given string is a palindrome\n\
    # &gt;&gt;&gt; is_palindrome('')\n# True\n# &gt;&gt;&gt; is_palindrome('aba')\n\
    # True\n# &gt;&gt;&gt; is_palindrome('aaaaa')\n# True\n# &gt;&gt;&gt; is_palindrome('zbcd')\n\
    # False\ndef is_palindrome(text):\n    def match_from_the_center(length):\n  \
    \      return (length &lt; len(text) and text[length-1] == text[-length-1])\n\
    \    def palindrome_helper(n):\n        if n == 0:\n            return True\n\
    \        elif match_from_the_center(n):\n            return palindrome_helper(n-1)\n\
    \        else:\n            return False\n    return palindrome_helper(len(text)//2)\n\
    </code>\n", "  (cond [(empty? text) true]\n        [(string=? (substring text\
    \ 0 1) (substring text -1)) (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))]\n        [else false]))\n", "  (if (empty? text)\n      true\n \
    \     (if (eq? (first text) (last text))\n          (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))\n          false)))\n", "  (cond [(empty?\
    \ text) true]\n        [(empty? (rest text)) true]\n        [(eq? (first text)\
    \ (last text)) (is_palindrome (rest (butlast text)))]\n        [else false]))\n",
  "  (define (equal-chars a b)\n    (char=? (string-ref a 0) (string-ref b 0)))\n\
    \  (define (sub-palindrome text left right)\n    (if (&gt;= left right)\n    \
    \    #t\n        (if (equal-chars (substring text left (+ left 1)) (substring\
    \ text right (+ right 1)))\n            (sub-palindrome text (+ left 1) (- right\
    \ 1))\n            #f)))\n  (sub-palindrome text 0 (- (string-length text) 1)))\n",
  "  (define (head text)\n    (first text))\n  (define (tail text)\n    (rest text))\n\
    \  (define (length text)\n    (cond\n      [(null? text) 0]\n      [else (+ 1\
    \ (length (tail text)))]))\n  (define (l-to-r text)\n    (cond\n      [(null?\
    \ text) '()]\n      [else (cons (head text) (l-to-r (tail text)))]))\n  (define\
    \ (r-to-l text)\n    (cond\n      [(null? text) '()]\n      [else (cons (head\
    \ (reverse text)) (r-to-l (tail (reverse text))))]))\n  (and\n    (= (length text)\
    \ (length (l-to-r text)))\n    (= (length text) (length (r-to-l text)))))\n",
  "  ;; first use map with identity function to convert to a list\n  ;; then use reverse\
    \ to compare to see if it's the same\n  (and (equal? text (string-join (reverse\
    \ (map identity (string->list text)))))\n       text))\n", "  (cond\n    [(empty?\
    \ text) True]\n    [(or (empty? (rest text))\n         (string=? (first text)\
    \ (last text)))\n     (is_palindrome (rest (first-n (sub1 (string-length text))\
    \ text)))]\n    [else False]))\n", "  (define (helper start stop)\n    (cond ((<\
    \ start stop) #t)\n          ((char=? (string-ref text start) (string-ref text\
    \ stop))\n           (helper (+ start 1) (- stop 1)))\n          (else #f)))\n\
    \  (helper 0 (- (string-length text) 1)))\n", "  (cond\n    [(empty? text) #t]\n\
    \    [(empty? (rest text)) #t]\n    [(char=? (first text) (last text))\n     (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))]\n    [else #f]))\n", "  (define\
    \ (palindrome-iter text rev)\n    (cond ((null? text) rev)\n          ((string=?\
    \ (car text) (car rev)) (palindrome-iter (cdr text) (cdr rev)))\n          (else\
    \ false)))\n  (palindrome-iter text (reverse text)))\n", "  (eq? (reverse text)\
    \ text))\n", "  (and (= 0 (remainder (string-length text) 2))\n       (equal?\
    \ (substring text 0 (/ (string-length text) 2))\n               (substring text\
    \ (- (/ (string-length text) 2) 1) -1))))\n", "  (cond [(empty? text) #t]\n  \
    \      [(string=? (string-append text \"\") (string-reverse text)) #t]\n     \
    \   [else #f]))\n", "  (define (loop i j)\n    (cond [(> i j) #t]\n          [(not\
    \ (char=? (string-ref text i) (string-ref text j))) #f]\n          [else (loop\
    \ (+ i 1) (- j 1))]))\n  (loop 0 (- (string-length text) 1)))\n", "  (define (recursion)\n\
    \    (if (and (not (string=? text \"\"))\n             (not (string=? (substring\
    \ text 0 1) (substring text -1))))\n        #f\n        (and (not (string=? text\
    \ \"\"))\n             (recursion (substring text 1 -1)))))\n  (recursion))\n",
  "  (cond\n    [(empty? text) (displayln \"True\")]\n    [(= (first text) (last text))\n\
    \     (is_palindrome (rest (butlast text)))]\n    [else (displayln \"False\")]))\n",
  "  (if (string= text (string-reverse text))\n      #t\n      #f))\n", "  (cond\n\
    \    [(string=? text \"\") true]\n    [(not (string=? (string-head text) (string-last\
    \ text))) false]\n    [else (is_palindrome (string-drop-right text 1))]))\n```\n\
    ### 1.14 Find all common substrings of two strings\n```#lang racket\n", "  (if\
    \ (string=? text \"\")\n      #t\n      (if (= (string-length text) 1)\n     \
    \     #t\n          (if (string=? (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1)))\n              (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))\n              #f))))\n", "  (define length (string-length text))\n\
    \  (define i 0)\n  (define j (- length 1))\n  (while (&lt; i j)\n    (if (not\
    \ (char=? (string-ref text i) (string-ref text j)))\n        (return #f))\n  \
    \  (set! i (+ i 1))\n    (set! j (- j 1)))\n  #t)\n", "  (define (loop i j)\n\
    \    (and (<= i j)\n         (or (equal? (substring text i (add1 i))\n       \
    \              (substring text j (add1 j)))\n             (loop (add1 i) (sub1\
    \ j)))))\n  (loop 0 (sub1 (string-length text))))\n", "  (let loop ([text text]\
    \ [i 0] [j (- (string-length text) 1)])\n    (cond [(or (= i j) (= i (- j 1)))\
    \ #t]\n          [(not (char=? (string-ref text i) (string-ref text j))) #f]\n\
    \          [else (loop text (+ i 1) (- j 1))])))\n", "  (let* ([palindrome-text\
    \ (reverse text)])\n    (and (= text palindrome-text)\n         (not (or (string=?\
    \ text \"\")\n                  (string=? text \" \"))))))\n", "  (if (= (string-length\
    \ text) 0)\n      #t\n      (let* ((first (string-ref text 0))\n             (last\
    \ (string-ref text (- (string-length text) 1))))\n        (if (= first last)\n\
    \            (is_palindrome (substring text 1 (- (string-length text) 1)))\n \
    \           #f))))\n", "  ;; Convert string to lowercase\n  (define t (string-downcase\
    \ text))\n  ;; Remove all non alpha characters\n  (define t (string-filter (lambda\
    \ (x) (string-alphabetic? x)) t))\n  ;; Split string and convert to a list\n \
    \ (define t (string->list t))\n  ;; Remove all non alpha characters\n  (define\
    \ t (filter (lambda (x) (char-alphabetic? x)) t))\n  ;; Reverse the list\n  (define\
    \ t (reverse t))\n  ;; Check if the list is equal to its reversed version\n  (equal?\
    \ t (reverse t)))", "  (cond\n    [(empty? text) true]\n    [(empty? (rest text))\
    \ true]\n    [(not (= (first text) (last text))) false]\n    [else (is_palindrome\
    \ (rest (butlast text)))]))\n", "  (string=? text (string-reverse text)))\n",
  "  (define (is_p text left right)\n    (cond\n      ((<= left right)\n       (equal?\
    \ (string-ref text left) (string-ref text right))\n       (is_p text (+ left 1)\
    \ (- right 1)))\n      (else #t)))\n  (is_p text 0 (- (string-length text) 1)))\n",
  "  (cond\n    [(empty? text) (display \"True\")]\n    [(empty? (rest text)) (display\
    \ \"True\")]\n    [(not (equal? (first text) (last text))) (display \"False\"\
    )]\n    [else (is_palindrome (string-drop-right (string-drop-left text 1) 1))]))\n",
  "  (and (not (empty? text))\n       (or (and (empty? (rest text)) (equal? (first\
    \ text) (last text)))\n           (and (equal? (first text) (last text))\n   \
    \             (is_palindrome (substring (rest text) 0 (- (length text) 2)))))))\n",
  "  (define (palindrome_helper left right)\n    (cond\n      ((string=? left right)\
    \ #t)\n      ((or (= (string-length left) 0) (= (string-length right) 0)) #f)\n\
    \      ((string=? (string-take left 1) (string-take right 1))\n       (palindrome_helper\
    \ (string-drop left 1) (string-drop right 1)))\n      (else #f)))\n  (palindrome_helper\
    \ text (string-reverse text)))\n", "  (define text_length (string-length text))\n\
    \  (define (is_palindrome_helper i)\n    (cond [(= i text_length) #t]\n      \
    \    [(char=? (string-ref text i) (string-ref text (- text_length i 1)))\n   \
    \        (is_palindrome_helper (+ i 1))]\n          [else #f]))\n  (is_palindrome_helper\
    \ 0))\n", "  (let loop ([text text] [len (string-length text)])\n    (if (string=?\
    \ text (reverse text))\n        #t\n        #f)))\n", "  (define (is_palindrome_tr\
    \ text start end)\n    (if (> end start)\n        (if (char=? (string-ref text\
    \ start) (string-ref text end))\n            (is_palindrome_tr text (+ start 1)\
    \ (- end 1))\n            #f)\n        #t))\n  (is_palindrome_tr text 0 (- (string-length\
    \ text) 1)))", "  (if (= (length text) 0)\n      #t\n      (if (= (length text)\
    \ 1)\n          #t\n          (if (equal? (substring text 0 1) (substring text\
    \ (- (length text) 1) (length text)))\n              (is_palindrome (substring\
    \ text 1 (- (length text) 1)))\n              #f))))\n", "  (cond\n    [(empty?\
    \ text) true]\n    [(= (count text) 1) true]\n    [(and (= (first text) (last\
    \ text))\n          (is_palindrome (rest (butlast text))))]\n    [else false]))\n",
  "  (or (empty? text)\n      (and (char=? (first text) (last text))\n           (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))))\n", "  (define (is_palindrome_rec\
    \ text index1 index2)\n    (if (and (<= index1 index2) (equal? (string-ref text\
    \ index1) (string-ref text index2)))\n        (is_palindrome_rec text (+ index1\
    \ 1) (- index2 1))\n        (if (<= index1 index2) #f #t)))\n  (is_palindrome_rec\
    \ text 0 (- (string-length text) 1)))\n", "  (and (not (empty? text))\n      \
    \ (or (empty? (string-drop text 1))\n           (and (char=? (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1)))\n                (is_palindrome\
    \ (string-drop text 1 (- (string-length text) 1)))))))\n```\n\n```#lang racket\n",
  "  (equal? text (reverse text)))\n", "  (equal? (reverse text) text))\n", "  (if\
    \ (string=? text \"\")\n      #t\n      (let* ([first-char (string-ref text 0)]\n\
    \             [last-char (string-ref text (- (string-length text) 1))])\n    \
    \    (and (equal? first-char last-char)\n             (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))))))", "  (define (helper text left right)\n\
    \    (if (= right left)\n        #t\n        (if (equal? (string-ref text left)\
    \ (string-ref text right))\n            (helper text (+ left 1) (- right 1))\n\
    \            #f)))\n  (helper text 0 (- (string-length text) 1)))\n", "  (match\
    \ text\n    ['() #t]\n    [(cons first (cons second (cons third rest)))\n    \
    \ (and (= first third)\n          (is_palindrome (cons second rest)))]))\n", " \
    \ (define (rev text)\n    (if (null? text)\n        '()\n        (append (rev\
    \ (rest text)) (list (first text)))))\n  (string=? text (apply string-append (rev\
    \ text))))\n", "  (or (and (eq? (string-length text) 0) (eq? (string-length text)\
    \ 1))\n      (and (eq? (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1)))\n           (is_palindrome (substring text 1 (- (string-length text)\
    \ 1))))))\n", "  (if (= (string-length text) 0)\n      true\n      (if (= (string-length\
    \ text) 1)\n          true\n          (if (string=? (substring text 0 1) (substring\
    \ text (- (string-length text) 1) (string-length text)))\n              (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))\n              false))))\n",
  "  (define (next-letter text)\n    (string-ref text 1))\n  (define (same-letter-p\
    \ x y)\n    (char=? x y))\n  (define (has-more-letter-p text)\n    (not (string=?\
    \ text \"\")))\n  (define (palindrome-iter text left right)\n    (cond\n     \
    \ [(empty? text) 'true]\n      [(and (same-letter-p left right)\n            (has-more-letter-p\
    \ text))\n       (palindrome-iter\n        (substring text 1 (- (string-length\
    \ text) 1))\n        (next-letter text)\n        (string-ref text (- (string-length\
    \ text) 2)))]\n      [else 'false]))\n  (palindrome-iter text (string-ref text\
    \ 0) (string-ref text (- (string-length text) 1))))\n", "  (cond\n    [(empty?\
    \ text)\n     #t]\n    [(eq? (first text) (last text))\n     (is_palindrome (rest\
    \ (butlast text)))]\n    [else\n     #f]))\n```", "  (define (check i)\n    (cond\n\
    \      [(= i (- (string-length text) 1)) true]\n      [(char=? (string-ref text\
    \ i) (string-ref text (- (string-length text) 1 i))) (check (+ i 1))]\n      [else\
    \ false]))\n  (check 0))\n", "  (eq? text (reverse text)))\n", "  (define (is_palindrome_helper\
    \ text pos1 pos2)\n    (cond ((string=? text \"\") #t)\n          ((and (string=?\
    \ (string-ref text pos1) (string-ref text pos2))\n                (>= (- pos2\
    \ pos1) 0))\n           (is_palindrome_helper text (+ pos1 1) (- pos2 1)))\n \
    \         (else #f)))\n  (is_palindrome_helper text 0 (- (string-length text)\
    \ 1)))\n```\n\n```racket\n#lang racket\n", "  ;; YOUR CODE HERE\n  (if (empty?\
    \ text)\n      #t\n      (if (= (first text) (last text))\n          (if (= (length\
    \ text) 2)\n              #t\n              (is_palindrome (substring text 1 (-\
    \ (length text) 1))))\n          #f)))\n", "  (define (helper text first-char-index\
    \ last-char-index)\n    (if (= first-char-index last-char-index)\n        #t\n\
    \        (if (= (string-ref text first-char-index) (string-ref text last-char-index))\n\
    \            (helper text (+ first-char-index 1) (- last-char-index 1))\n    \
    \        #f)))\n  (helper text 0 (- (string-length text) 1)))\n", "  (cond\n \
    \   [(empty? text) True]\n    [(empty? (rest text)) True]\n    [(eq? (first text)\
    \ (last text)) (is_palindrome (substring (rest text) 0 (- (string-length text)\
    \ 2)))]\n    [else False]))\n", "  (if (= (string-length text) 0)\n      true\n\
    \      (let ([c1 (string-ref text 0)]\n            [c2 (string-ref text (- (string-length\
    \ text) 1))])\n        (if (= c1 c2)\n            (is_palindrome (substring text\
    \ 1 (- (string-length text) 1)))\n            false))))\n", "  (define (compare-chars\
    \ pos)\n    (if (= pos (- (string-length text) 1))\n        #t\n        (if (not\
    \ (char=? (string-ref text pos) (string-ref text (- (string-length text) 1 pos))))\n\
    \            #f\n            (compare-chars (+ pos 1)))))\n  (compare-chars 0))\n",
  "  (equal? text (string-reverse text)))\n", "  (cond [(empty? text) true]\n    \
    \    [(and (eq? (first text) (last text))\n              (is_palindrome (rest\
    \ (butlast text)))) true]\n        [else false]))\n", "  (is_palindrome_helper\
    \ text (string-length text)))\n", "  (if (empty? text)\n      #t\n      (if (equal?\
    \ (first text) (last text))\n          (is_palindrome (rest (butlast text)))\n\
    \          #f)))\n```\n\n## sum of squares\n\n```racket\n#lang racket\n", "  (cond\
    \ ((string=? text \"\") #t)\n        ((string=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))\n         (is_palindrome (substring text 1\
    \ (- (string-length text) 1))))\n        (else #f)))\n", "  (cond [(empty? text)\
    \ #t]\n        [(and (equal? (first text) (last text))\n              (is_palindrome\
    \ (but-last (rest text)))) #t]\n        [else #f]))\n", "  (string=? text (string-reverse\
    \ text)))\n", "  (define (palindrome? text)\n    (cond ((string=? text \"\") #t)\n\
    \          ((string=? (substring text 0 1) (substring text (- (string-length text)\
    \ 1) (string-length text))) (palindrome? (substring text 1 (- (string-length text)\
    \ 1))))\n          (else #f)))\n  (palindrome? text))\n", "  (if (empty? text)\n\
    \      true\n      (if (empty? (cdr text))\n          true\n          (if (equal?\
    \ (car text) (last text))\n              (is_palindrome (cdr (reverse (cdr text))))\n\
    \              false))))\n```\n\n## H.3 The Collatz Sequence\n\n```#lang racket\n",
  "  (cond\n    [(null? text) \n     #t]\n    [(string=? (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1)))\n     (is_palindrome (substring text 1 (-\
    \ (string-length text) 1)))]\n    [else\n     #f]))\n", "  (define (help text\
    \ start end)\n    (if (>= start end)\n        #t\n        (let ([a (string-ref\
    \ text start)]\n              [b (string-ref text end)])\n          (and (char=?\
    \ a b)\n               (help text (+ start 1) (- end 1))))))\n  (help text 0 (-\
    \ (string-length text) 1)))\n", "  (cond [(empty? text) True]\n        [(= (string-length\
    \ text) 1) True]\n        [(char=? (string-ref text 0) (string-ref text (- (string-length\
    \ text) 1))) (is_palindrome (substring text 1 (- (string-length text) 1)))]\n\
    \        [else False]))\n", "  (if (= (string-length text) 0)\n      #t\n    \
    \  (if (= (string-length text) 1)\n          #t\n          (if (string=? (substring\
    \ text 0 1) (substring text (- (string-length text) 1) (string-length text)))\n\
    \              (is_palindrome (substring text 1 (- (string-length text) 1)))\n\
    \              #f))))\n", "  (cond ((null? text) #t)\n        ((and (char=? (car\
    \ text) (last text))\n              (is_palindrome (substring (cdr text) 0 (-\
    \ (string-length text) 2))))\n         #t)\n        (else #f)))\n", "  (and (not\
    \ (empty? text))\n       (or (and (empty? (cdr text)) #t)\n           (and (char=?\
    \ (car text) (car (last text)))\n                (is_palindrome (substring text\
    \ 1 (- (string-length text) 1)))))))\n", "  (if (empty? text) #t\n      (char=?\
    \ (first text) (last text))\n      (is_palindrome (rest (butlast text)))))\n",
  "  (define (check-it head tail)\n    (cond\n      ((null? text) #t)\n      ((string=?\
    \ head tail) #t)\n      (else #f)))\n  (check-it (string-ref text 0) (string-ref\
    \ text (- (string-length text) 1))))\n", "  (string=? (string-reverse text) text))\n",
  "  (cond ((null? text) #t)\n        ((null? (cdr text)) #t)\n        ((equal? (car\
    \ text) (last text))\n         (is_palindrome (cdr (reverse (cdr (reverse text))))))\n\
    \        (else #f)))\n", "  (define (is_palindrome? text reverse)\n    (cond [(empty?\
    \ text) reverse]\n          [(empty? (rest text)) (and (= (first text) (first\
    \ reverse)) reverse)]\n          [else (is_palindrome? (rest text) (cons (first\
    \ text) reverse))]))\n  (is_palindrome? text '()))\n", "  (let loop ([a (string-length\
    \ text)] [b 0])\n    (if (and (> a b) (= (string-ref text a) (string-ref text\
    \ b)))\n        (loop (- a 1) (+ b 1))\n        (eq? a b))))\n```\n\n```racket\n\
    #lang racket\n", "  (not (null? text))\n  (display text)\n  (display '\\n')\n\
    \  (begin0\n   (display (string-length text))\n   (display '\\n'))\n  (define\
    \ (is_palindrome_aux text i j)\n    (if (= i j)\n        #t\n        (if (= (string-ref\
    \ text i) (string-ref text j))\n            (is_palindrome_aux text (+ i 1) (-\
    \ j 1))\n            #f)))\n  (is_palindrome_aux text 0 (- (string-length text)\
    \ 1)))\n", "  (equal? text (string-reverse text)))\n", "  (define (is_empty text)\n\
    \    (eq? text \"\"))\n  (define (is_single_char text)\n    (eq? (string-length\
    \ text) 1))\n  (define (first_char text)\n    (substring text 0 1))\n  (define\
    \ (last_char text)\n    (substring text (- (string-length text) 1) (string-length\
    \ text)))\n  (define (middle_chars text)\n    (substring text 1 (- (string-length\
    \ text) 1)))\n  (define (is_palindrome_aux text)\n    (if (is_empty text)\n  \
    \      #t\n        (if (is_single_char text)\n            #t\n            (if\
    \ (equal? (first_char text) (last_char text))\n                (is_palindrome_aux\
    \ (middle_chars text))\n                #f))))\n  (is_palindrome_aux text))\n\
    ```\n\n```racket", "  (define (p text length)\n    (cond\n      [(= length 1)\n\
    \       true]\n      [(= length 2)\n       (equal? (string-ref text 0) (string-ref\
    \ text 1))]\n      [else\n       (and (equal? (string-ref text 0) (string-ref\
    \ text (- length 1)))\n            (p (substring text 1 (- length 2)) (- length\
    \ 2)))]))\n  (p text (string-length text)))\n", "  (define (string-reverse text)\n\
    \    (cond\n      [(empty? text) empty]\n      [else (append (string-reverse (rest\
    \ text)) (list (first text)))]))\n  (equal? text (string-reverse text)))\n", " \
    \ (if (= (string-length text) 0)\n      true\n      (if (= (string-length text)\
    \ 1)\n          true\n          (if (char=? (string-ref text 0) (string-ref text\
    \ (- (string-length text) 1)))\n              (is_palindrome (substring text 1\
    \ (- (string-length text) 1)))\n              false))))\n", "  (not (null? text))\n\
    \  (cond\n    [(= 1 (string-length text)) #t]\n    [(equal? (string-ref text 0)\
    \ (string-ref text (- (string-length text) 1)))\n     (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))]\n    [else #f]))\n", "  (or (eq? '() text)\n\
    \      (and (eq? (first text) (last text))\n           (is_palindrome (remove-last\
    \ (remove-first text))))))\n```\n\n```\n#lang racket\n", "  (or (string=? text\
    \ \"\")\n      (and (string=? (substring text 0 1) (substring text -1))\n    \
    \       (is_palindrome (substring text 1 -1)))))\n", "  (cond\n    [(empty? text)\
    \ true]\n    [(< (length text) 2) true]\n    [(char=? (first text) (last text))\
    \ (is_palindrome (substring text 1 (- (length text) 1)))]\n    [else false]))\n",
  "  (cond [(empty? text) (displayln \"True\")]\n        [(= (length text) 1) (displayln\
    \ \"True\")]\n        [(equal? (string-&gt;list (first text))\n              \
    \  (string-&gt;list (rest text)))\n         (displayln \"True\")]\n        [else\
    \ (displayln \"False\")]))\n", "  (let* ((helper (lambda (text)\n            \
    \       (if (= (string-length text) 0)\n                       #t\n          \
    \             (and (= (string-ref text 0) (string-ref text (- (string-length text)\
    \ 1)))\n                            (helper (substring text 1 (- (string-length\
    \ text) 1)))))))\n         (res (helper text)))\n    res))\n", "  (let loop ([left\
    \ 0] [right (- (string-length text) 1)])\n    (cond [(negative? left) #t]\n  \
    \        [(negative? right) #t]\n          [(< left right) #t]\n          [(string=?\
    \ (string-ref text left) (string-ref text right))\n           (loop (+ left 1)\
    \ (- right 1))]\n          [else #f])))\n", "  (if (string=? text \"\")\n    \
    \  (error \"Provide some text\")\n      (letrec ([text (string-normalize-spaces\
    \ text)]\n               [text (string-downcase text)]\n               [head (substring\
    \ text 0 1)]\n               [tail (substring text (- (string-length text) 1)\
    \ (string-length text))])\n        (cond [(string=? head tail) (if (= (string-length\
    \ text) 2) #t\n                                       (is_palindrome (substring\
    \ text 1 (- (string-length text) 1))))]\n              [else #f]))))\n", "  (define\
    \ (is_palindrome-inner text)\n    (if (empty? text)\n        '()\n        (append\
    \ (list (first text))\n                (is_palindrome-inner (rest text)))))\n\
    \  (equal? text (is_palindrome-inner text)))\n", "  (equal? (reverse text) text))\n",
  "  (let ([text-length (string-length text)])\n    (if (= 1 text-length)\n      \
    \  #t\n        (if (= text-length 0)\n            #t\n            (if (equal?\
    \ (string-ref text 0) (string-ref text (- text-length 1)))\n                (is_palindrome\
    \ (substring text 1 (- text-length 1)))\n                #f)))))\n```\n\n```racket\n\
    #lang racket\n", "  (define (check-char-pair pair)\n    (if (equal? (car pair)\
    \ (cdr pair))\n        #t\n        #f))\n  (define (check-chars chars)\n    (if\
    \ (&lt;= (length chars) 1)\n        #t\n        (and (check-char-pair chars)\n\
    \             (check-chars (rest (rest chars))))))\n  (check-chars (string-&gt;list\
    \ text)))\n", "  (eq? (string-reverse text) text))\n", "  (cond ((not (string?\
    \ text)) (error \"bad argument - not a string\"))\n        ((string=? text \"\"\
    ) #t)\n        ((and (string=? (substring text 0 1) (substring text (- (string-length\
    \ text) 1) (string-length text)))\n              (is_palindrome (substring text\
    \ 1 (- (string-length text) 1)))) #t)\n        (else #f)))\n```\n\n```racket\n\
    #lang racket\n", "  (define (is_palindrome-iter text reverse)\n    (cond\n   \
    \   [(empty? text)\n       (= text reverse)]\n      [else\n       (is_palindrome-iter\
    \ (rest text)\n                           (append reverse (list (first text))))]))\n\
    \  (is_palindrome-iter text '()))\n", "  (or (equal? text \"\")\n      (and (char=?\
    \ (string-ref text 0) (string-ref text (- (string-length text) 1)))\n        \
    \   (is_palindrome (substring text 1 (- (string-length text) 1))))))\n", "  (cond\n\
    \    [(empty? text) #t]\n    [(and (char=? (string-ref text 0) (string-ref text\
    \ (- (string-length text) 1)))\n          (is_palindrome (substring text 1 (-\
    \ (string-length text) 1)))) #t]\n    [else #f]))\n", "  (if (empty? text)\n \
    \     #t\n      (let ([len (string-length text)])\n        (and (equal? (string-ref\
    \ text 0) (string-ref text (- len 1)))\n             (is_palindrome (substring\
    \ text 1 (- len 2)))))))\n", "  (define (helper first second)\n    (cond\n   \
    \   [(empty? (rest second)) #t]\n      [(empty? (rest first)) #t]\n      [(char=?\
    \ (first first) (last second)) (helper (rest first) (butlast second))]\n     \
    \ [else #f]))\n  (helper (string->list text) (string->list text)))\n```\n\n```\n\
    $ racket palindrome.rkt\n```\n\n```racket\n> (is_palindrome \"abba\")\n#t\n> (is_palindrome\
    \ \"ababa\")\n#t\n> (is_palindrome \"madam\")\n#t\n> (is_palindrome \"abc\")\n\
    #f\n> (is_palindrome \"abcba\")\n#f\n```\n\n![screenshot from 2018-09-10 21-37-29](https://user-images.githubusercontent.com/2780619/45346619-4e4d4c80-b5ab-11e8-9912-c6b15f6d1f6e.png)\n\
    \n[racket]: https://racket-lang.org/\n[racket-package]: https://pkgs.racket-lang.org/",
  "  (cond\n    [(null? text) #t]\n    [(null? (cdr text)) #t]\n    [(char=? (car\
    \ text) (car (last text))) (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))]\n    [else #f]))\n", "  (define (p text length)\n    (cond [(or\
    \ (null? text) (= length 1)) true]\n          [(and (= (string-ref text 0) (string-ref\
    \ text (- length 1)))\n                (p (substring text 1 (- length 2)) (- length\
    \ 2))) true]\n          [else false]))\n  (p text (string-length text)))\n", " \
    \ (cond [(empty? text) true]\n        [(equal? (first text) (last text)) (is_palindrome\
    \ (rest (butlast text)))]\n        [else false]))\n", "  (define (char=? a b)\n\
    \    (if (or (char=? a #\\ ) (char=? b #\\ ))\n        #f\n        (char=? (string-downcase\
    \ a) (string-downcase b))))\n  (define (r-palindrome l r)\n    (if (and (not (char=?\
    \ (string-ref text l) #\\ ))\n             (not (char=? (string-ref text r) #\\\
    \ )))\n        (if (or (char=? (string-ref text l) (string-ref text r))\n    \
    \            (< l r))\n            (r-palindrome (+ l 1) (- r 1))\n          \
    \  #f)\n        #t))\n  (r-palindrome 0 (- (string-length text) 1)))\n", "  (if\
    \ (string=? \"\" text)\n      #t\n      (if (string=? (substring text 0 1) (substring\
    \ text (- (string-length text) 1) (string-length text)))\n          (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))\n          #f)))\n```\n\n```racket\n\
    #lang racket\n", "  (let ((len (string-length text)))\n    (if (= len 0)\n   \
    \     #t\n        (if (= len 1)\n            #t\n            (if (char=? (string-ref\
    \ text 0) (string-ref text (- len 1)))\n                (is_palindrome (substring\
    \ text 1 (- len 2)))\n                #f)))))", "  (define (double-reverse lst)\n\
    \    (reverse (reverse lst)))\n  (equal? (string->list text) (double-reverse (string->list\
    \ text))))\n", "  (define (is_palindrome-iter text left right)\n    (if (< left\
    \ right)\n        (if (char=? (string-ref text left) (string-ref text right))\n\
    \            (is_palindrome-iter text (+ left 1) (- right 1))\n            #f)\n\
    \        #t))\n  (is_palindrome-iter text 0 (- (string-length text) 1)))", " \
    \ (define (is_palindrome-iter text left right)\n    (if (> left right)\n     \
    \   #t\n        (if (equal? (string-ref text left) (string-ref text right))\n\
    \            (is_palindrome-iter text (+ left 1) (- right 1))\n            #f)))\n\
    \  (is_palindrome-iter text 0 (- (string-length text) 1)))\n", "  (or (string=?\
    \ text \"\")\n      (string=? (substring text 0 1) (substring text -1))\n    \
    \  (is_palindrome (substring text 1 -1))))\n", "  (equal? (reverse text) text))\n",
  "  (define (helper start end)\n    (if (> start end)\n        #t\n        (if (string-ci=?\
    \ (string-ref text start) (string-ref text end))\n            (helper (+ start\
    \ 1) (- end 1))\n            #f)))\n  (helper 0 (- (string-length text) 1)))\n",
  '  (or (empty? text) (and (char=? (first text) (last text)) (is_palindrome (substring
    text 1 (- (string-length text) 1))))))', "  ;; TODO\n  )\n", "  (and (= (length\
    \ text) 0)\n       (eq? '() (filter (lambda (c) (eq? c (last text))) (string->list\
    \ text)))))\n", "  (define (check-palindrome-reverse text l)\n    (cond\n    \
    \  [(= l (- (string-length text) 1))\n       (if (= (string-ref text 0) (string-ref\
    \ text l))\n           #t\n           #f)]\n      [else\n       (if (= (string-ref\
    \ text 0) (string-ref text l))\n           (check-palindrome-reverse text (- l\
    \ 1))\n           #f)]))\n  (check-palindrome-reverse text (- (string-length text)\
    \ 1)))\n", "  (cond\n    [(empty? text) #t]\n    [(= (first text) (last text))\
    \ (is_palindrome (bf text))]\n    [else #f]))\n", "  (if (null? text)\n      #t\n\
    \      (if (string=? (substring text 0 1) (substring text (- (string-length text)\
    \ 1) (- (string-length text) 0)))\n          (is_palindrome (substring text 1\
    \ (- (string-length text) 1)))\n          #f)))\n", "  (not (equal? (reverse text)\
    \ text)))\n", "  (string=? text (string-reverse text)))\n", "  (cond [(empty?\
    \ text) #t]\n        [(empty? (rest text)) #t]\n        [(char=? (first text)\
    \ (last text))\n         (is_palindrome (substring text 1 (- (string-length text)\
    \ 1)))]\n        [else #f]))\n", "  (define (palindrome-helper left right)\n \
    \   (if (> left right)\n        #t\n        (and (string=? (string-ref text left)\
    \ (string-ref text right))\n             (palindrome-helper (+ left 1) (- right\
    \ 1)))))\n  (palindrome-helper 0 (- (string-length text) 1)))\n", "  (if (= (string-length\
    \ text) 0)\n      true\n      (if (= (string-length text) 1)\n          true\n\
    \          (if (string=? (substring text 0 1) (substring text (- (string-length\
    \ text) 1) (string-length text)))\n              (is_palindrome (substring text\
    \ 1 (- (string-length text) 1)))\n              false))))\n", "  ;; Function to\
    \ reverse a string\n  (define (rev str)\n    (if (string=? str \"\")\n       \
    \ \"\"\n        (string-append (substring str (sub1 (string-length str))) (rev\
    \ (substring str 0 (sub1 (string-length str)))))))\n  (string=? text (rev text)))\n",
  "  (equal? (string-reverse text) text))\n```\n\n[Back to top](#top)\n\n---\n\n###\
    \ 6. Generate the n-th Fibonacci number\n```racket\n#lang racket\n", "  (is_palindrome_loop\
    \ text (string-length text) (string-length text)))\n", "  (and \n    (= (length\
    \ text) (length (list-tail text)))\n    (or (null? text) (and (equal? (first text)\
    \ (first (list-tail text))) (is_palindrome (list-tail (list-tail text)))))))\n",
  "  (cond\n    [(empty? text)\n     #t]\n    [(empty? (rest text))\n     #t]\n  \
    \  [(= (first text) (last text))\n     (is_palindrome (but-last (rest text)))]\n\
    \    [else\n     #f]))\n", "  (is_palindrome_helper text 0 (sub1 (string-length\
    \ text))))\n", "  (let loop ([pos1 (length text)]\n             [pos2 0])\n  \
    \  (cond [(or (= pos1 pos2)\n               (= pos1 (add1 pos2)))\n          \
    \ #t]\n          [(char=? (string-ref text pos1)\n                   (string-ref\
    \ text pos2))\n           (loop (sub1 pos1)\n                 (add1 pos2))]\n\
    \          [else #f])))\n", "  (eq? text (reverse text)))\n", "  (and (not (empty?\
    \ text))\n       (or (empty? (rest text))\n           (and (char=? (first text)\
    \ (last text))\n                (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))))))\n", "  (if (string=? text (reverse text))\n      #t\n      #f))\n",
  "  (define (inner text)\n    (if (or (empty? text) (empty? (rest text)))\n     \
    \   #t\n        (and (= (first text) (last text))\n             (inner (but-last\
    \ (rest text))))))\n  (inner (string-&gt;list text)))\n", "  (if (empty? text)\n\
    \      #t\n      (cond\n        ((equal? (car text) (last text))\n         (is_palindrome\
    \ (rest (butlast text))))\n        (else #f))))\n", "  (equal? text (reverse text)))\n",
  "  (define (is_palindrome-inner text start end)\n    (if (> start end)\n       \
    \ #t\n        (if (string-ci=? (string-ref text start) (string-ref text end))\n\
    \            (is_palindrome-inner text (+ start 1) (- end 1))\n            #f)))\n\
    \  (is_palindrome-inner text 0 (- (string-length text) 1)))\n", "  (if (string=?\
    \ text \"\")\n      #t\n      (if (= (string-length text) 1)\n          #t\n \
    \         (if (string=? (string-index text 0) (string-index text (- (string-length\
    \ text) 1)))\n              (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))\n              #f))))\n", "  (define (is_palindrome_rec text-reversed\
    \ text-normal)\n    (cond\n      [(empty? text-normal) true]\n      [(and (char=?\
    \ (first text-normal) (first text-reversed))\n            (is_palindrome_rec (rest\
    \ text-reversed) (rest text-normal)))\n       true]\n      [else false]))\n  (is_palindrome_rec\
    \ (reverse text) text))", "  (define (palindrome-helper to-check)\n    (cond ((null?\
    \ to-check) #t)\n          ((null? (cdr to-check)) #t)\n          ((equal? (car\
    \ to-check) (cdr to-check)) (palindrome-helper (cdr (cdr to-check))))\n      \
    \    (else #f)))\n  (palindrome-helper (string->list text)))\n", "  (define (is_palindrome-iter\
    \ text)\n    (cond\n      [(empty? text) #t]\n      [(empty? (rest text)) #t]\n\
    \      [(char=? (first text) (last text)) (is_palindrome-iter (but-last (rest\
    \ text)))]\n      [else #f]))\n  (is_palindrome-iter (string-&gt;list text)))\n",
  "  (if (= (string-length text) 0)\n      #t\n      (let* ([first-char (string-ref\
    \ text 0)]\n             [last-char (string-ref text (- (string-length text) 1))])\n\
    \        (and (= first-char last-char)\n             (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))))))\n", "  (if (string=? text \"\")\n  \
    \    #t\n      (let* ((first-char (string-ref text 0))\n             (last-char\
    \ (string-ref text (- (string-length text) 1)))\n             (rest-text (substring\
    \ text 1 (- (string-length text) 1))))\n        (and (char=? first-char last-char)\n\
    \             (is_palindrome rest-text)))))\n", "  (define (helper text1 text2)\n\
    \    (cond\n      [(empty? text1) empty?]\n      [(empty? text2) empty?]\n   \
    \   [(char=? (first text1) (first text2)) (helper (rest text1) (rest text2))]\n\
    \      [else #f]))\n  (helper text (reverse text)))\n", "  (cond\n    [(empty?\
    \ text) true]\n    [(not (equal? (first text) (last text))) false]\n    [else\
    \ (is_palindrome (substring text 1 -1))]))\n", "  (equal? (reverse text) text))\n",
  "  (if (empty? text)\n      true\n      (if (equal? (first text) (last text))\n\
    \          (is_palindrome (remove-first-last text))\n          false)))\n", " \
    \ (define (palindrome? str)\n    (if (equal? (substring str 0 1) (substring str\
    \ (sub1 (string-length str)) 1))\n      (palindrome? (substring str 1 (sub1 (string-length\
    \ str))))\n      (not (equal? text \"\"))))\n  (palindrome? text))\n", "  (is_palindrome_help\
    \ text 0 (string-length text)))\n", "  (define (is_palindrome_h text reversed)\n\
    \    (cond ((string=? text \"\") string=? reversed \"\")\n          ((string=?\
    \ text reversed) #t)\n          (else (is_palindrome_h (substring text 1 (string-length\
    \ text)) (string-append (substring reversed 0 1) text)))))\n  (is_palindrome_h\
    \ text \"\"))\n", "  (or (eq? text \"\")\n      (and\n       (eq? (string-ref\
    \ text 0) (string-ref text (- (string-length text) 1)))\n       (is_palindrome\
    \ (substring text 1 (- (string-length text) 1))))))\n", "  (cond\n    [(string=?\
    \ text \"\") #t]\n    [(string=? (substring text 0 1) (substring text (sub1 (string-length\
    \ text)) (string-length text))) (is_palindrome (substring text 1 (sub1 (string-length\
    \ text))))]\n    [else #f]))\n", "  (cond [(equal? text \"\")\n         #t]\n\
    \        [(equal? (substring text 0 1) (substring text (- (string-length text)\
    \ 1) (string-length text)))\n         (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))]\n        [else\n         #f]))\n", "  (let ([len (string-length\
    \ text)])\n    (if (= len 0)\n        #t\n        (and (string=? (substring text\
    \ 0 1) (substring text (- len 1) len))\n             (is_palindrome (substring\
    \ text 1 (- len 1)))))))\n", "  (equal? text (reverse text)))\n", "  (if (empty?\
    \ text)\n      #t\n      (let ([left (car text)]\n            [right (last text)])\n\
    \        (if (eq? left right)\n            (is_palindrome (bulk-string-remove\
    \ text left #:end 1))\n            #f))))\n", "  (define (is_palindrome-from text\
    \ i1 i2)\n    (cond [(= i1 i2)\n           #t]\n          [(< i1 i2)\n       \
    \    (and (char=? (string-ref text i1) (string-ref text i2))\n               \
    \ (is_palindrome-from text (+ i1 1) (- i2 1)))]))\n  (is_palindrome-from text\
    \ 0 (- (string-length text) 1)))", "  (let ([len (string-length text)])\n    (for/or\
    \ ([i (in-range (quotient len 2))])\n      (equal? (string-ref text i) (string-ref\
    \ text (- len i 1))))))\n", "  (cond [(empty? text) #t]\n        [(equal? (car\
    \ text) (last text)) (is_palindrome (rest (butlast text)))]\n        [else #f]))\n",
  "  (cond\n    [(empty? text) #t]\n    [(empty? (rest text)) #t]\n    [(char=? (first\
    \ text) (last text))\n     (is_palindrome (substring text 1 (sub1 (string-length\
    \ text))))]\n    [else #f]))\n```", "  ;; implement me\n  )\n```", "  (define\
    \ (helper text)\n    (if (&lt;= (string-length text) 1)\n        #t\n        (if\
    \ (equal? (string-ref text 0) (string-ref text (- (string-length text) 1)))\n\
    \            (helper (substring text 1 (- (string-length text) 1)))\n        \
    \    #f)))\n  (helper text))\n", "  (define (helper text i j)\n    (if (= i j)\n\
    \        #t\n        (if (= (string-ref text i) (string-ref text j))\n       \
    \     (helper text (+ i 1) (- j 1))\n            #f)))\n  (helper text 0 (- (string-length\
    \ text) 1)))\n", "  (if (empty? text)\n      #t\n      (define first (first text))\n\
    \      (define last (last text))\n      (if (eq? first last)\n          (is_palindrome\
    \ (rest (butlast text)))\n          #f)))\n```\n\n[main.rkt](main.rkt)\n```racket\n\
    #lang racket\n", "  (define (str_rev text)\n    (if (empty? text)\n        text\n\
    \        (string-append (str_rev (substring text 1 (string-length text)))\n  \
    \                     (string (string-ref text 0)))))\n  (equal? text (str_rev\
    \ text)))\n", "  (define (reverse text acc)\n    (if (equal? text \"\")\n    \
    \    acc\n        (reverse (substring text 1 (string-length text))\n         \
    \        (string-append acc (string (string-ref text 0))))))\n  (equal? text (reverse\
    \ text \"\")))\n", "  (define (iter front back)\n    (cond\n      [(empty? front)\
    \ (empty? back)]\n      [(empty? back) #f]\n      [(char=? (first front) (first\
    \ back)) (iter (rest front) (rest back))]\n      [else #f]))\n  (iter (string->list\
    \ text) (reverse (string->list text))))\n", "  (cond\n    [(empty? text) #t]\n\
    \    [(= (count text) 1) #t]\n    [(= (first text) (last text)) (is_palindrome\
    \ (but-last (rest text)))]\n    [else #f]))\n", "  (if (empty? text)\n      #t\n\
    \      (let ([c (first text)])\n        (if (equal? c (last text))\n         \
    \   (is_palindrome (rest (butlast text)))\n            #f))))\n", "  (define (helper\
    \ left right)\n    (cond ((string=? left right) #t)\n          ((string-empty?\
    \ left) #f)\n          ((string-empty? right) #f)\n          ((and (string=? (string-take\
    \ left 1) (string-take right 1))\n                (helper (string-drop left 1)\
    \ (string-drop right 1))) #t)\n          (else #f)))\n  (helper text (string-reverse\
    \ text)))", "  (define (inner first last)\n    (if (&lt; first last)\n       \
    \ (if (equal? (string-ref text first) (string-ref text last))\n            (inner\
    \ (+ first 1) (- last 1))\n            #f)\n        #t))\n  (inner 0 (- (string-length\
    \ text) 1)))\n", "  (cond\n    [(equal? text \"\") #t]\n    [(equal? (string-index\
    \ text 0) (string-index text (- (string-length text) 1)))\n     (is_palindrome\
    \ (substring text 1 (- (string-length text) 1)))]\n    [else #f]))\n", "  (if\
    \ (string=? text \"\")\n      #t\n      (let ([text-len (string-length text)])\n\
    \        (if (string=? (substring text 0 1) (substring text (- text-len 1) text-len))\n\
    \            (is_palindrome (substring text 1 (- text-len 1)))\n            #f))))\n",
  "  (cond\n    [(empty? text) #t]\n    [(empty? (rest text)) #t]\n    [(equal? (first\
    \ text) (last text))\n     (is_palindrome (substring text 1 (- (string-length\
    \ text) 1)))]\n    [else #f]))\n", "  (define (is_palindrome_inner text counter)\n\
    \    (if (= 0 counter)\n        #t\n        (and (= (string-ref text (- (string-length\
    \ text) counter))\n                  (string-ref text counter))\n            \
    \  (is_palindrome_inner text (- counter 1)))))\n  (if (= 0 (string-length text))\n\
    \      #t\n      (is_palindrome_inner text (- (string-length text) 1))))\n", " \
    \ (cond [(empty? text) #t]\n        [(and (eq? (first text) (last text))\n   \
    \           (is_palindrome (rest (drop-right text 1)))) #t]\n        [else #f]))\n",
  "  (and (even? (string-length text)) (equal? text (reversed text))))\n", "  (define\
    \ (is_palindrome_helper l c)\n    (cond ((< c 0) true)\n          ((char=? (string-ref\
    \ text l) (string-ref text c))\n           (is_palindrome_helper (+ l 1) (- c\
    \ 1)))\n          (else false)))\n  (is_palindrome_helper 0 (- (string-length\
    \ text) 1)))\n", "  (define (aux str len)\n    (cond [(= len 1) true]\n      \
    \    [(= len 2) (= (string-ref str 0) (string-ref str 1))]\n          [(string=?\
    \ (string-take str (/ len 2)) (string-drop str (/ len 2)))]\n          [else false]))\n\
    \  (aux text (string-length text)))\n", "  (let ([n (string-length text)])\n \
    \   (or (= n 0)\n        (and (char=? (string-ref text 0) (string-ref text (-\
    \ n 1)))\n             (is_palindrome (substring text 1 (- n 1)))))))\n", "  (cond\
    \ [(empty? text) True]\n        [(and (= (first text) (last text))\n         \
    \     (is_palindrome (substring (rest text) 0 (- (string-length text) 2)))) True]\n\
    \        [else False]))\n", "  (string= text (string-reverse text)))\n", "  (equal?\
    \ (string-reverse text) text))\n", "  (and (not (empty? text))\n       (or (equal?\
    \ (first text) (last text))\n           (equal? (length text) 1))\n       (is_palindrome\
    \ (rest (butlast text)))))\n", "  (cond ((empty? text) #t)\n        ((empty? (rest\
    \ text)) #t)\n        ((char=? (first text) (last text))\n         (is_palindrome\
    \ (substring (rest text) 0 (- (string-length text) 2))))\n        (else #f)))\n",
  "  (if (empty? text) true\n      (if (equal? (first text) (last text))\n       \
    \   (is_palindrome (rest (butlast text)))\n          false)))\n", "  ;; Just reverse\
    \ the string and compare it to original\n  (equal? text (reverse text)))\n", " \
    \ (cond\n    [(empty? text) #t]\n    [(and (char=? (first text) (last text))\n\
    \          (is_palindrome (rest (butlast text)))) #t]\n    [else #f]))\n", " \
    \ ;; >>> is_palindrome('aba')\n  ;; True\n  ;; >>> is_palindrome('zbcd')\n  ;;\
    \ False\n  (is_palindrome_helper (string->list text) 0 (string-length text) #f))\n",
  "  (define (recur text1 text2)\n    (if (&lt;= (string-length text1) 0)\n      \
    \  (if (&lt;= (string-length text2) 0)\n            #t\n            #f)\n    \
    \    (if (= (string-ref text1 0) (string-ref text2 (- (string-length text2) 1)))\n\
    \            (recur (substring text1 1) (substring text2 0 (- (string-length text2)\
    \ 1)))\n            #f)))\n  (recur text text))\n", "  (define (filter-non-characters\
    \ text)\n    (regexp-replace* #rx\"[^[:alpha:]]\" text \"\"))\n  (define (remove-non-alphanumeric-and-case\
    \ text)\n    (regexp-replace* #rx\"[^[:alnum:]]\" text \"\"))\n  (define (palindrome?\
    \ text)\n    (string=? text (string-reverse text)))\n  (palindrome? (remove-non-alphanumeric-and-case\
    \ text)))\n", "  (define (is_palindrome-helper text start end)\n    (if (= start\
    \ end)\n        #t\n        (if (= (char-downcase (string-ref text start)) (char-downcase\
    \ (string-ref text end)))\n            (is_palindrome-helper text (+ start 1)\
    \ (- end 1))\n            #f)))\n  (is_palindrome-helper text 0 (- (string-length\
    \ text) 1)))\n", "  (let loop ([start 0] [end (- (string-length text) 1)])\n \
    \   (if (= start end)\n        #t\n        (if (= (string-ref text start) (string-ref\
    \ text end))\n            (loop (+ start 1) (- end 1))\n            #f))))\n",
  "  (if (zero? (string-length text))\n      #t\n      (let ([first-char (string-ref\
    \ text 0)]\n            [last-char (string-ref text (- (string-length text) 1))])\n\
    \        (and (char=? first-char last-char)\n             (is_palindrome (substring\
    \ text 1 (- (string-length text) 1)))))))\n```\n\n### Version 1.1\n\n#### Problem\n\
    \nGiven a string, check if it is a palindrome.\n\n#### Solution\n\n```racket\n\
    #lang racket\n", "  (define (helper text h i)\n    (if (or (= h i) (= h (- i 1)))\n\
    \        #t\n        (and (equal? (string-ref text h) (string-ref text (- i 1)))\n\
    \             (helper text (+ h 1) (- i 1)))))\n  (helper text 0 (string-length\
    \ text)))", "  (and (not (empty? text))\n       (or (equal? text (reverse text))\
    \ (is_palindrome (substring text 1 -1)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
