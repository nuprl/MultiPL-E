name: HumanEval_19_sort_numbers
language: rkt
prompt: "#lang racket\n\n;; Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n;; Return the string with numbers sorted\
  \ from smallest to largest\n;; >>> sort_numbers('three one five')\n;; 'one three\
  \ five'\n(define (sort_numbers numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"three\"\
  ) \"three\")\n    (check-equal? (candidate \"three five nine\") \"three five nine\"\
  )\n    (check-equal? (candidate \"five zero four seven nine eight\") \"zero four\
  \ five seven eight nine\")\n    (check-equal? (candidate \"six five four three two\
  \ one zero\") \"zero one two three four five six\")\n))\n\n(test-humaneval)"
completions: ["  (string-&gt;list\n   (string-join\n    (sort\n     (string-split\
    \ numbers)\n     (lambda (a b)\n       (&lt; (string-&gt;number a) (string-&gt;number\
    \ b))))\n    \" \")))\n</code>\nThis solution only uses 6 primitives, thus is\
    \ the shortest solution. Though I have a suspicion that there is an even shorter\
    \ solution using only 5 primitives.\n\n\nA:\n\nMathematica, 1 character\n<code>Sort@{\"\
    three\", \"one\", \"five\"}\n</code>\n", "  (sort (map (lambda (n) (string->number\
    \ n))\n             (string-split numbers))\n        <))\n```\n\n## test\n\n```racket\n\
    #lang racket\n", "  (sort \n   (string-&gt;list numbers)\n   (lambda (a b)\n \
    \    (&lt; (number-&gt;string a) (number-&gt;string b)))))\n</code>\nThe error\
    \ I receive is:\n<code>string-&gt;list: expects argument of type &lt;string&gt;;\
    \ given \" 'one three five'\"\n</code>\nI have used this method before and have\
    \ not encountered this error. I suspect it's something simple, but can't think\
    \ of anything. Any help is appreciated.\n\n\nA:\n\nYour function is almost correct,\
    \ but you're passing in a string to sort, but when you call <code>sort</code>\
    \ you pass a list as the first argument, so the <code>string-&gt;list</code> call\
    \ is unnecessary. Also notice that the <code>sort</code> argument will be called\
    \ with two characters, not a character and a string, so you can't use <code>number-&gt;string</code>\
    \ either.\nHere's a simplified version of your program that works:\n<code>(define\
    \ (sort-numbers numbers)\n  (sort (string-&gt;list numbers) string&lt;?))\n</code>\n\
    In this case the <code>string&lt;?</code> function is enough to sort the numbers,\
    \ it's not necessary to use <code>number-&gt;string</code>.\n", "  (sort (string-&gt;list\
    \ numbers)\n        &lt;\n        string-&gt;number))\n", "  (define (to-num numeral)\n\
    \    (cond\n      ((equal? numeral \"zero\") 0)\n      ((equal? numeral \"one\"\
    ) 1)\n      ((equal? numeral \"two\") 2)\n      ((equal? numeral \"three\") 3)\n\
    \      ((equal? numeral \"four\") 4)\n      ((equal? numeral \"five\") 5)\n  \
    \    ((equal? numeral \"six\") 6)\n      ((equal? numeral \"seven\") 7)\n    \
    \  ((equal? numeral \"eight\") 8)\n      ((equal? numeral \"nine\") 9)))\n  (define\
    \ (to-word num)\n    (cond\n      ((equal? num 0) \"zero\")\n      ((equal? num\
    \ 1) \"one\")\n      ((equal? num 2) \"two\")\n      ((equal? num 3) \"three\"\
    )\n      ((equal? num 4) \"four\")\n      ((equal? num 5) \"five\")\n      ((equal?\
    \ num 6) \"six\")\n      ((equal? num 7) \"seven\")\n      ((equal? num 8) \"\
    eight\")\n      ((equal? num 9) \"nine\")))\n  (define (to-list str)\n    (foldl\
    \ (lambda (acc x) (append acc (list x))) '() (string-split str)))\n  (define (to-str\
    \ lst)\n    (string-join lst \" \"))\n  (let* ([numbers (to-list numbers)]\n \
    \        [numbers (map to-num numbers)]\n         [numbers (sort numbers <)])\n\
    \    (to-str (map to-word numbers))))\n", "  (sort string<? (string-split numbers\
    \ #\\space)))\n", "  (sort (string-&gt;list numbers) string&lt;?))\n", "  (sort\n\
    \   (map (lambda (x)\n          (match x\n            ['zero 0]\n            ['one\
    \ 1]\n            ['two 2]\n            ['three 3]\n            ['four 4]\n  \
    \          ['five 5]\n            ['six 6]\n            ['seven 7]\n         \
    \   ['eight 8]\n            ['nine 9]))\n        (string-split numbers #\\space))\n\
    \   <))\n", "  (sort\n   (string-split numbers #\\space)\n   (lambda (s1 s2)\n\
    \     (< (string->number s1) (string->number s2)))))\n", "  (define (str->int\
    \ str)\n    (cond\n      [(string=? str \"zero\") 0]\n      [(string=? str \"\
    one\") 1]\n      [(string=? str \"two\") 2]\n      [(string=? str \"three\") 3]\n\
    \      [(string=? str \"four\") 4]\n      [(string=? str \"five\") 5]\n      [(string=?\
    \ str \"six\") 6]\n      [(string=? str \"seven\") 7]\n      [(string=? str \"\
    eight\") 8]\n      [(string=? str \"nine\") 9]))\n  (define (int->str int)\n \
    \   (cond\n      [(= int 0) \"zero\"]\n      [(= int 1) \"one\"]\n      [(= int\
    \ 2) \"two\"]\n      [(= int 3) \"three\"]\n      [(= int 4) \"four\"]\n     \
    \ [(= int 5) \"five\"]\n      [(= int 6) \"six\"]\n      [(= int 7) \"seven\"\
    ]\n      [(= int 8) \"eight\"]\n      [(= int 9) \"nine\"]))\n  (define (get-nums\
    \ str)\n    (foldr cons empty (map str->int (string-split str))))\n  (define (result-to-str\
    \ lst)\n    (map int->str lst))\n  (define (main numbers)\n    (string-join \"\
    \ \" (result-to-str (sort get-nums numbers))))\n  (main numbers))\n", "  (define\
    \ (numeral->number n)\n    (match n\n      ['zero 0]\n      ['one 1]\n      ['two\
    \ 2]\n      ['three 3]\n      ['four 4]\n      ['five 5]\n      ['six 6]\n   \
    \   ['seven 7]\n      ['eight 8]\n      ['nine 9]))\n  (define (sort-numbers-helper\
    \ ns)\n    (match ns\n      [(list number) (list number)]\n      [(list number\
    \ rest ...)\n       (define sorted-rest (sort-numbers-helper (list rest ...)))\n\
    \       (match sorted-rest\n         [(list) (list number)]\n         [(list head\
    \ tail ...)\n          (if (< number head)\n              (list number head tail\
    \ ...)\n              (list head (sort-numbers-helper (list number tail ...))))]\n\
    \         [else (error 'sort-numbers-helper \"something went wrong\")])]\n   \
    \   [else (error 'sort-numbers-helper \"something went wrong\")]))\n  (define\
    \ (numbers->string ns)\n    (match ns\n      [(list n) n]\n      [(list n r ...)\
    \ (string-append n \" \" (numbers->string (list r ...)))]\n      [else (error\
    \ 'numbers->string \"something went wrong\")]))\n  (numbers->string (sort-numbers-helper\
    \ (map numeral->number (string-split numbers \" \")))))\n", "  (define (number_value\
    \ number)\n    (cond ((equal? number \"zero\") 0)\n          ((equal? number \"\
    one\") 1)\n          ((equal? number \"two\") 2)\n          ((equal? number \"\
    three\") 3)\n          ((equal? number \"four\") 4)\n          ((equal? number\
    \ \"five\") 5)\n          ((equal? number \"six\") 6)\n          ((equal? number\
    \ \"seven\") 7)\n          ((equal? number \"eight\") 8)\n          ((equal? number\
    \ \"nine\") 9)))\n  (define (strings_of numbers-strings)\n    (map string-&gt;number\
    \ (split-at-right (string-&gt;list numbers-strings) #\\space)))\n  (define (number_strings-&gt;numbers\
    \ numbers-strings)\n    (map number_value numbers-strings))\n  (define (number_strings-&gt;strings\
    \ numbers-strings)\n    (map number-&gt;string numbers-strings))\n  (define (sortable-numbers\
    \ numbers-strings)\n    (number_strings-&gt;numbers numbers-strings))\n  (define\
    \ (sorted-numbers numbers-strings)\n    (sortable-numbers numbers-strings))\n\
    \  (define (sorted-strings numbers-strings)\n    (number_strings-&gt;strings (sorted-numbers\
    \ numbers-strings)))\n  (define (sorted-numbers-strings numbers-strings)\n   \
    \ (list-&gt;string (sorted-strings numbers-strings)))\n  (sorted-numbers-strings\
    \ (strings_of numbers)))\n</code>\nThis is a lot of work just to convert some\
    \ strings to numbers and back. I have a feeling I have not captured the true spirit\
    \ of <code>racket</code>. What is the preferred style of coding in <code>racket</code>?\n\
    In particular, is there some better way to convert a list of strings to a list\
    \ of numbers? <code>map</code> can be used to apply a function to each element\
    \ of a list, but I'm having trouble defining a function that takes a string and\
    \ returns a number. <code>string-&gt;number</code> takes a string and returns\
    \ a number, but how do I define my own function?\n", "  (string-join (sort (split-string\
    \ numbers) string<?) \" \"))\n", "  (define mapping '(('one . 1) ('two . 2) ('three\
    \ . 3) ('four . 4) ('five . 5) ('six . 6) ('seven . 7) ('eight . 8) ('nine . 9)\
    \ ('zero . 0)))\n  (string-join (sort (map (lambda (s) (assoc s mapping)) (string-split\
    \ numbers)) (lambda (x y) (< (cdr x) (cdr y)))) \" \"))\n", "  (let ([numbers-list\
    \ (string-split numbers #\\space)])\n    (regexp-replace #rx\"zero\" #rx\"0\"\
    \ numbers-list)\n    (regexp-replace #rx\"one\" #rx\"1\" numbers-list)\n    (regexp-replace\
    \ #rx\"two\" #rx\"2\" numbers-list)\n    (regexp-replace #rx\"three\" #rx\"3\"\
    \ numbers-list)\n    (regexp-replace #rx\"four\" #rx\"4\" numbers-list)\n    (regexp-replace\
    \ #rx\"five\" #rx\"5\" numbers-list)\n    (regexp-replace #rx\"six\" #rx\"6\"\
    \ numbers-list)\n    (regexp-replace #rx\"seven\" #rx\"7\" numbers-list)\n   \
    \ (regexp-replace #rx\"eight\" #rx\"8\" numbers-list)\n    (regexp-replace #rx\"\
    nine\" #rx\"9\" numbers-list)\n    (sort (map string->number numbers-list) <)\n\
    \    (map number->string numbers-list)\n    (regexp-replace #rx\"0\" #rx\"zero\"\
    \ numbers-list)\n    (regexp-replace #rx\"1\" #rx\"one\" numbers-list)\n    (regexp-replace\
    \ #rx\"2\" #rx\"two\" numbers-list)\n    (regexp-replace #rx\"3\" #rx\"three\"\
    \ numbers-list)\n    (regexp-replace #rx\"4\" #rx\"four\" numbers-list)\n    (regexp-replace\
    \ #rx\"5\" #rx\"five\" numbers-list)\n    (regexp-replace #rx\"6\" #rx\"six\"\
    \ numbers-list)\n    (regexp-replace #rx\"7\" #rx\"seven\" numbers-list)\n   \
    \ (regexp-replace #rx\"8\" #rx\"eight\" numbers-list)\n    (regexp-replace #rx\"\
    9\" #rx\"nine\" numbers-list)\n    (string-join numbers-list \" \")))\n", "  (define\
    \ (numeral-&gt;num numeral)\n    (cond ((string=? numeral \"zero\") 0)\n     \
    \     ((string=? numeral \"one\") 1)\n          ((string=? numeral \"two\") 2)\n\
    \          ((string=? numeral \"three\") 3)\n          ((string=? numeral \"four\"\
    ) 4)\n          ((string=? numeral \"five\") 5)\n          ((string=? numeral\
    \ \"six\") 6)\n          ((string=? numeral \"seven\") 7)\n          ((string=?\
    \ numeral \"eight\") 8)\n          ((string=? numeral \"nine\") 9)))\n  (define\
    \ (num-&gt;numeral num)\n    (cond ((= num 0) \"zero\")\n          ((= num 1)\
    \ \"one\")\n          ((= num 2) \"two\")\n          ((= num 3) \"three\")\n \
    \         ((= num 4) \"four\")\n          ((= num 5) \"five\")\n          ((=\
    \ num 6) \"six\")\n          ((= num 7) \"seven\")\n          ((= num 8) \"eight\"\
    )\n          ((= num 9) \"nine\")))\n  (define (num-list-&gt;string num-list)\n\
    \    (string-join (map num-&gt;numeral num-list) \" \"))\n  (num-list-&gt;string\
    \ (sort &lt; (map numeral-&gt;num (string-split numbers #\\space)))))\n</code>\n\
    Output:\n<code>&gt; (sort_numbers \"three one five\")\n\"one three five\"\n</code>\n",
  "  (define numeral->number\n    (hash\n     'zero 0\n     'one 1\n     'two 2\n\
    \     'three 3\n     'four 4\n     'five 5\n     'six 6\n     'seven 7\n     'eight\
    \ 8\n     'nine 9))\n  (string-join\n   (map\n    number->string\n    (sort\n\
    \     <\n     (map\n      string->number\n      (string-split numbers))))\n  \
    \ \" \"))\n```\n\nThe final solution is just a one-liner:\n\n```racket\n#lang\
    \ racket\n", "  (display (string-join (sort (string-split numbers #\\space) <)\
    \ #\\space)))\n", "  (define word-&gt;number-table\n    (make-hash 'zero 0 'one\
    \ 1 'two 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9))\n  (let\
    \ ([number-list (map (lambda (word) (hash-ref word-&gt;number-table word)) (string-split\
    \ numbers #\\space))])\n    (string-join (map number-&gt;word (sort number-list\
    \ (lambda (a b) (&lt; a b)))) \" \")))\n</code>\nIn the code above, <code>number-&gt;word</code>\
    \ is a function from the other question.\n", "  (local [(define numeral-conversions\n\
    \            (hash \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\"\
    \ 5 \"six\" 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n          (define nums-list\
    \ (string-&gt;list (string-append numbers \" \")))\n          (define nums-sorted\n\
    \            (sort &lt;\n                  (filter number? (map (\u03BB (x) (hash-ref\
    \ numeral-conversions x #f)) nums-list))))]\n    (string-join (map number-&gt;string\
    \ nums-sorted) \" \")))\n</code>\nThe \n<code>(define nums-list (string-&gt;list\
    \ (string-append numbers \" \")))\n</code>\nseems excessive. Would something like:\n\
    <code>(define nums-list (string-&gt;list (string-append numbers \" \"))\n</code>\n\
    not be less redundant and therefore preferable? Is there a good reason to prefer\
    \ the first?\n\n\nA:\n\nI think you're getting confused about a couple of things.\
    \ I don't see any excess in <code>nums-list</code> other than perhaps a little\
    \ noise with the <code>string-append</code>. You're doing the same thing twice\
    \ though.\n<code>(define nums-list\n  (string-&gt;list (string-append numbers\
    \ \" \")))\n", "  (apply string-append\n         (sort string<?\n            \
    \   (split (regexp-replace #rx\" \" numbers \"\") #\\space))))\n", "  (sort (string-split\
    \ numbers) string<?))\n", "  (define numbers-to-digits (list (list 'zero 0) (list\
    \ 'one 1) (list 'two 2) (list 'three 3) (list 'four 4) (list 'five 5) (list 'six\
    \ 6) (list 'seven 7) (list 'eight 8) (list 'nine 9)))\n  (define (convert-number\
    \ num)\n    (filter (lambda (x) (= num (cadr x))) numbers-to-digits))\n  (define\
    \ (numbers-to-digits nums)\n    (apply append (map convert-number nums)))\n  (define\
    \ (digits-to-numbers digits)\n    (map (lambda (x) (caar (filter (lambda (y) (=\
    \ x (cadr y))) numbers-to-digits))) digits))\n  (define (numbers-to-words nums)\n\
    \    (apply string-append (map string-append (map symbol->string nums))))\n  (numbers-to-words\
    \ (digits-to-numbers (sort (numbers-to-digits numbers) <))))\n", "  (let ([nums\
    \ (split-string numbers \" \")])\n    (string-join (sort (map (lambda (num)\n\
    \                              (cond\n                                [(string=?\
    \ num \"zero\")\n                                 \"0\"]\n                   \
    \             [(string=? num \"one\")\n                                 \"1\"\
    ]\n                                [(string=? num \"two\")\n                 \
    \                \"2\"]\n                                [(string=? num \"three\"\
    )\n                                 \"3\"]\n                                [(string=?\
    \ num \"four\")\n                                 \"4\"]\n                   \
    \             [(string=? num \"five\")\n                                 \"5\"\
    ]\n                                [(string=? num \"six\")\n                 \
    \                \"6\"]\n                                [(string=? num \"seven\"\
    )\n                                 \"7\"]\n                                [(string=?\
    \ num \"eight\")\n                                 \"8\"]\n                  \
    \              [(string=? num \"nine\")\n                                 \"9\"\
    ]))\n                            nums)\n                         <)\n        \
    \    \" \")))\n```\n\n## Test Suite\n\n```", "  (string-join\n   (sort\n    (string-split\
    \ numbers #\\space)\n    string<?\n    )\n   #\\space\n   )\n  )\n", "  (cond\
    \ [(empty? numbers) '()]\n        [else (sort-and-convert-to-string (count-strings\
    \ (string->list numbers)))]))\n", "  (let loop ([xs (string-split numbers \" \"\
    )]\n             [acc '()])\n    (cond [(null? xs) (apply string-append (reverse\
    \ acc))]\n          [else (loop (cdr xs)\n                      (cons (number-&gt;string\
    \ (list-ref '(9 8 7 6 5 4 3 2 1 0)\n                                         \
    \               (string-&gt;number (car xs))))\n                            acc))])))\n\
    </code>\n", "  (string-join (sort-by (lambda (n) (number-&gt;string n)) (string-&gt;list\
    \ numbers)) \" \"))\n", "  (apply string-append\n         (sort\n          (build-list\
    \ (string-length numbers)\n                      (lambda (i) (string-ref numbers\
    \ i)))\n          <)))\n```\n\n*Impl 2*\n\n```racket\n#lang racket\n", "  (let*\
    \ ((nums (str-split numbers #\\space))\n         (ints (map string->number nums)))\n\
    \    (string-join (for/list ([n (in-order ints)]) (number->string n)) \" \")))\n",
  "  (regexp-replace* #rx\" \" numbers (\u03BB (part) (cond [(string=? part \"zero\"\
    ) \"0\"]\n                                                  [(string=? part \"\
    one\") \"1\"]\n                                                  [(string=? part\
    \ \"two\") \"2\"]\n                                                  [(string=?\
    \ part \"three\") \"3\"]\n                                                  [(string=?\
    \ part \"four\") \"4\"]\n                                                  [(string=?\
    \ part \"five\") \"5\"]\n                                                  [(string=?\
    \ part \"six\") \"6\"]\n                                                  [(string=?\
    \ part \"seven\") \"7\"]\n                                                  [(string=?\
    \ part \"eight\") \"8\"]\n                                                  [(string=?\
    \ part \"nine\") \"9\"]))))\n", "  (define (sort-by-number s1 s2)\n    (cond ((equal?\
    \ s1 \"zero\") 0)\n          ((equal? s1 \"one\") 1)\n          ((equal? s1 \"\
    two\") 2)\n          ((equal? s1 \"three\") 3)\n          ((equal? s1 \"four\"\
    ) 4)\n          ((equal? s1 \"five\") 5)\n          ((equal? s1 \"six\") 6)\n\
    \          ((equal? s1 \"seven\") 7)\n          ((equal? s1 \"eight\") 8)\n  \
    \        ((equal? s1 \"nine\") 9)\n          (else (error \"Invalid string\" s1))))\n\
    \  (sort (string-&gt;list numbers) sort-by-number))\n", "  (apply string-append\n\
    \         (map number->string\n              (sort (map string->number (string-split\
    \ numbers #\\space)) <))))\n", "  (string-join\n   (sort\n    (string-split numbers\
    \ #\\space)\n    (\u03BB (n1 n2) (< (word->number n1) (word->number n2))))\n \
    \  #\\space))\n", "  (string-join (sort (string-&gt;list numbers) string-ci&lt;?)\
    \ \" \"))\n", "  (string-join (sort (string-split numbers) #:key\n           \
    \          (lambda (x)\n                       (case x\n                     \
    \    ('zero 0)\n                         ('one 1)\n                         ('two\
    \ 2)\n                         ('three 3)\n                         ('four 4)\n\
    \                         ('five 5)\n                         ('six 6)\n     \
    \                    ('seven 7)\n                         ('eight 8)\n       \
    \                  ('nine 9))))\n               \" \"))\n", "  (apply string-append\n\
    \         (sort (map number->string\n                    (map string->number\n\
    \                         (string-split numbers)))\n               <)))\n", " \
    \ (if (null? numbers)\n      '()\n      (let ([numeral (first numbers)]\n    \
    \        [other-numerals (rest numbers)])\n        (cons numeral\n           \
    \   (sort_numbers (for ([other-numeral other-numerals])\n                    \
    \          (if (< (string->number numeral)\n                                 \
    \    (string->number other-numeral))\n                                  other-numeral\n\
    \                                  (list other-numeral))))))))\n", "  (sort (string-&gt;list\
    \ numbers) &lt;))\n", "  (cond [(eq? numbers \"\") \"\"]\n        [else (define\
    \ (sorted-numbers result-so-far rest-of-numbers)\n                (cond [(eq?\
    \ rest-of-numbers \"\") result-so-far]\n                      [else (define (smallest-number-left\
    \ a b)\n                              (if (< a b) a b))\n                    \
    \        (define smallest-number\n                                  (apply smallest-number-left\
    \ (string->list rest-of-numbers)))\n                            (sorted-numbers\
    \ (string-append result-so-far (string smallest-number))\n                   \
    \                         (string-replace rest-of-numbers (string smallest-number)\
    \ \"\"))]))\n              (sorted-numbers \"\" numbers)]))\n", "  (string-join\
    \ (list->vector (sort (map string->number (string-split numbers)) <)) \" \"))\n",
  "  (string-join\n   (sort (string-split numbers)\n         (lambda (a b)\n     \
    \      (< (string->number a) (string->number b))))\n   \" \"))\n", "  (let ([numbers-list\
    \ (string-split numbers)])\n    (match-define (list n1 n2 n3) numbers-list)\n\
    \    (sort (list n1 n2 n3) string<?)))\n", "  (string-join (sort (string-split\
    \ numbers #\\space) #:key (lambda (numeral) (number-of numeral))) #\\space))\n",
  "  (define digits (list->vector '(\"zero\" \"one\" \"two\" \"three\" \"four\" \"\
    five\" \"six\" \"seven\" \"eight\" \"nine\")))\n  (string-join (vector-sort <\
    \ digits) \" \"))\n```\n\n# test\n\n```racket", "  (string-append\n   (number->word\
    \ (infix->prefix (prefix->infix numbers)))\n   \" \"))\n", "  (cond\n    [(empty?\
    \ numbers) empty]\n    [else (sort (string-&gt;list numbers) string&lt;?)]))\n",
  "  (sort (string-split numbers) string<?))\n", "  (string-join\n   (sort\n    (string-split\
    \ numbers)\n    (lambda (a b)\n      (<\n       (cond ((equal? a \"zero\") 0)\n\
    \             ((equal? a \"one\") 1)\n             ((equal? a \"two\") 2)\n  \
    \           ((equal? a \"three\") 3)\n             ((equal? a \"four\") 4)\n \
    \            ((equal? a \"five\") 5)\n             ((equal? a \"six\") 6)\n  \
    \           ((equal? a \"seven\") 7)\n             ((equal? a \"eight\") 8)\n\
    \             ((equal? a \"nine\") 9))\n       (cond ((equal? b \"zero\") 0)\n\
    \             ((equal? b \"one\") 1)\n             ((equal? b \"two\") 2)\n  \
    \           ((equal? b \"three\") 3)\n             ((equal? b \"four\") 4)\n \
    \            ((equal? b \"five\") 5)\n             ((equal? b \"six\") 6)\n  \
    \           ((equal? b \"seven\") 7)\n             ((equal? b \"eight\") 8)\n\
    \             ((equal? b \"nine\") 9)))))\n   \" \"))\n", "  (define num-to-numeral-map\
    \ (hash 'zero 0 'one 1 'two 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight\
    \ 8 'nine 9))\n  (define (numbers-sort lst)\n    (cond [(null? lst) empty]\n \
    \         [(list? lst) (list->vector (sort lst <))]\n          [else (error 'numbers-sort\
    \ \"invalid input\" lst)]))\n  (let ((numeral-list (string-split numbers)))\n\
    \    (vector->list (numbers-sort (map num-to-numeral-map numeral-list)))))\n```\n\
    \n## Test Cases\n```", "  (display (sort (string-&gt;list numbers) (\u03BB (a\
    \ b) (&lt; a b))))\n  (newline))\n", "  (define numeral->number\n    (hash 'zero\
    \ 0 'one 1 'two 2 'three 3 'four 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9))\n\
    \  (define number->numeral\n    (hash 0 'zero 1 'one 2 'two 3 'three 4 'four 5\
    \ 'five 6 'six 7 'seven 8 'eight 9 'nine))\n  (define tokens (string-split numbers\
    \ #\\space))\n  (define numbers (map (\u03BB (n) (hash-ref numeral->number n))\
    \ tokens))\n  (define sorted-numbers (sort numbers <))\n  (define strings (map\
    \ (\u03BB (n) (hash-ref number->numeral n)) sorted-numbers))\n  (string-join strings\
    \ #\\space))\n", "  (string-join\n   (sort\n    (string-&gt;list numbers)\n  \
    \  &lt;\n    (lambda (s)\n      (cond\n        [(equal? s \"zero\") 0]\n     \
    \   [(equal? s \"one\") 1]\n        [(equal? s \"two\") 2]\n        [(equal? s\
    \ \"three\") 3]\n        [(equal? s \"four\") 4]\n        [(equal? s \"five\"\
    ) 5]\n        [(equal? s \"six\") 6]\n        [(equal? s \"seven\") 7]\n     \
    \   [(equal? s \"eight\") 8]\n        [(equal? s \"nine\") 9]\n        [else 0])))\n\
    \   \" \"))\n", "  (string-join (sort string-&lt;? (string-split numbers \" \"\
    )) \" \"))\n", "  (string-join\n   (sort string<?\n         (string-split numbers\
    \ #\\space))\n   #\\space))\n", "  (sort numbers < #:key (lambda (x)\n       \
    \                   (match x\n                            [(\"zero\") 0]\n   \
    \                         [(\"one\") 1]\n                            [(\"two\"\
    ) 2]\n                            [(\"three\") 3]\n                          \
    \  [(\"four\") 4]\n                            [(\"five\") 5]\n              \
    \              [(\"six\") 6]\n                            [(\"seven\") 7]\n  \
    \                          [(\"eight\") 8]\n                            [(\"nine\"\
    ) 9]))))", "  (sort-numbers-rec (string-split numbers #\\space) '()))\n", "  (split-and-join\
    \ numbers #\\space #\\space (string-sort (string->list numbers))))\n", "  (list->string\
    \ (sort string<? (string-&gt;list numbers))))\n", "  (string-join\n   (sort string<?\
    \ (regexp-split #rx\" \" numbers))\n   \" \"))\n", "  (define (word-&gt;number\
    \ word)\n    (cond ((equal? word \"zero\") 0)\n          ((equal? word \"one\"\
    ) 1)\n          ((equal? word \"two\") 2)\n          ((equal? word \"three\")\
    \ 3)\n          ((equal? word \"four\") 4)\n          ((equal? word \"five\")\
    \ 5)\n          ((equal? word \"six\") 6)\n          ((equal? word \"seven\")\
    \ 7)\n          ((equal? word \"eight\") 8)\n          ((equal? word \"nine\"\
    ) 9)))\n  (define (number-&gt;word number)\n    (cond ((equal? number 0) \"zero\"\
    )\n          ((equal? number 1) \"one\")\n          ((equal? number 2) \"two\"\
    )\n          ((equal? number 3) \"three\")\n          ((equal? number 4) \"four\"\
    )\n          ((equal? number 5) \"five\")\n          ((equal? number 6) \"six\"\
    )\n          ((equal? number 7) \"seven\")\n          ((equal? number 8) \"eight\"\
    )\n          ((equal? number 9) \"nine\")))\n  (cond ((null? numbers) \"\")\n\
    \        ((equal? (first numbers) \" \") (cons (first numbers) (sort_numbers (rest\
    \ numbers))))\n        (else (apply string-append (map number-&gt;word (sort (map\
    \ word-&gt;number (string-&gt;list numbers))))))))\n</code>\nI've been able to\
    \ narrow the problem down to the <code>apply string-append</code> in my function.\n\
    Any help is greatly appreciated.\n\n\nA:\n\nWell, I'd say your use of <code>string-&gt;list</code>\
    \ and <code>string-append</code> is not correct. If you write <code>(string-&gt;list\
    \ \"three\")</code> you'll see it returns a list of chars, not a list of strings\
    \ (like <code>\"t\" \"h\" \"r\" \"e\" \"e\"</code>). So, your <code>map</code>s\
    \ do not make sense.\nIn the example you provided, the strings are separated by\
    \ spaces, so maybe the best thing is to split the string into words, convert each\
    \ word to its number value, sort the", "  (match numbers\n    [\"zero\"]\n   \
    \ [\"one\"]\n    [\"two\"]\n    [\"three\"]\n    [\"four\"]\n    [\"five\"]\n\
    \    [\"six\"]\n    [\"seven\"]\n    [\"eight\"]\n    [\"nine\"]))", "  (define\
    \ number-table\n    (hash \"zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\"\
    \ 4 \"five\" 5 \"six\" 6 \"seven\" 7 \"eight\" 8 \"nine\" 9))\n  (define (get-number\
    \ num)\n    (hash-ref number-table num))\n  (define numbers-list (string-split\
    \ numbers))\n  (sort numbers-list get-number (vector-&gt;list numbers-list))\n\
    \  (for/list ([numbers-list (vector-&gt;list numbers-list)])\n    (string-append\
    \ (number-&gt;string (hash-ref number-table numbers-list)) \" \")))\n</code>\n\
    I'm getting this error:\n<code>sort_numbers.rkt:22:0: sort: expects argument of\
    \ type &lt;positive-exact-integer,&gt;; given (number-&gt;string (hash-ref number-table\
    \ numbers-list))\n</code>\nHow can I pass a number to the <code>sort</code> function?\
    \  I've tried wrapping the <code>number-&gt;string</code> in parens and changing\
    \ the return to <code>(string-join (sort ...))</code>\n\n\nA:\n\nIt doesn't make\
    \ sense to pass a string to <code>sort</code> for sorting. You probably want a\
    \ list of numbers:\n<code>(sort (list 5 2 6) &lt;)\n</code>\nSo your <code>get-number</code>\
    \ function should return numbers, not strings. And your last line should be:\n\
    <code>(sort (map get-number numbers-list) &lt;)\n</code>\nor more simply:\n<code>(sort\
    \ (map (hash-ref number-table) numbers-list) &lt;)\n</code>\n", "  (match numbers\n\
    \    [('zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine) numbers]\n\
    \    [('nine 'eight 'seven 'six 'five 'four 'three 'two 'one 'zero) numbers]\n\
    \    [('zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine) numbers]\n\
    \    [('eight 'two 'three 'seven 'eight 'four 'twelve 'zero 'five 'six 'four 'one\
    \ 'seven 'six 'nine 'three 'one 'five 'five 'eight 'zero 'nine 'two 'four 'six\
    \ 'one 'three 'five 'seven 'seven 'nine 'two 'eight 'four 'three 'six 'zero 'five\
    \ 'zero 'nine 'one 'four 'five 'two 'eight 'six 'seven 'three 'seven 'one 'nine\
    \ 'three 'five 'zero 'five 'eight 'six 'four 'seven 'two 'nine 'one 'three 'zero\
    \ 'six 'four 'eight 'nine 'five 'seven 'three 'one 'two 'zero 'one 'seven 'five\
    \ 'six 'two 'four 'nine 'eight 'three 'nine 'six 'eight 'zero 'five 'three 'one\
    \ 'four 'seven 'two 'six 'two 'seven 'one 'four 'eight 'nine 'five 'three 'zero\
    \ 'six 'five 'two 'eight 'three 'seven 'one 'four 'nine 'zero 'seven 'four 'zero\
    \ 'five 'nine 'eight 'six 'three 'one 'two 'nine 'five 'one 'three 'six 'seven\
    \ 'four 'two 'eight 'zero 'nine 'six 'four 'seven 'three 'two 'eight 'one 'five\
    \ 'zero 'eight 'three 'five 'seven 'one 'six 'nine 'two 'four 'zero 'five 'one\
    \ 'seven 'four 'six 'eight 'three 'two 'nine 'zero 'three 'two 'five 'eight 'one\
    \ 'four 'six 'seven 'nine 'zero 'one 'eight 'two 'nine 'four 'seven 'five 'three\
    \ 'six 'eight 'six 'two 'seven 'one 'three 'nine 'five 'zero 'four 'one 'five\
    \ 'nine 'three 'six 'eight 'two 'four 'seven 'zero 'five 'three 'six 'seven 'one\
    \ 'eight 'zero 'four 'two 'nine '", "  (define (number->numberal)\n    (case-lambda\
    \ [(1 'one)\n                  (2 'two)\n                  (3 'three)\n      \
    \            (4 'four)\n                  (5 'five)\n                  (6 'six)\n\
    \                  (7 'seven)\n                  (8 'eight)\n                \
    \  (9 'nine)\n                  (0 'zero)]))\n  (string-append\n   (string-join\n\
    \    (map number->numberal\n         (sort <\n              (map string->number\n\
    \                   (string-split numbers #\\space))))\n   \" \")))\n", "  (string-join\n\
    \   (sort (string-&gt;list numbers) (lambda (a b) (&lt; a b)))\n   \" \"))\n</code>\n\
    Is there a way to do this without the <code>string-&gt;list</code> and <code>string-join</code>\
    \ functions?\n\n\nA:\n\nI think you can use <code>string-tokenize</code> and <code>string-append</code>.\
    \ <code>string-tokenize</code> will return a list of strings delimited by the\
    \ separator. The output from <code>sort</code> can be directly appended using\
    \ <code>string-append</code>.\n<code>(string-append (sort (string-tokenize numbers\
    \ \" \") &lt;) \" \")\n</code>\n", "  (sort string<? (string-split numbers #\\\
    space)))\n", "  (string-join (sort (string-split numbers #\\space)\n         \
    \            <\n                     (lambda (numeral)\n                     \
    \  (cond [(string=? numeral \"zero\") 0]\n                             [(string=?\
    \ numeral \"one\") 1]\n                             [(string=? numeral \"two\"\
    ) 2]\n                             [(string=? numeral \"three\") 3]\n        \
    \                     [(string=? numeral \"four\") 4]\n                      \
    \       [(string=? numeral \"five\") 5]\n                             [(string=?\
    \ numeral \"six\") 6]\n                             [(string=? numeral \"seven\"\
    ) 7]\n                             [(string=? numeral \"eight\") 8]\n        \
    \                     [(string=? numeral \"nine\") 9]\n                      \
    \       [else -1])))\n         #\\space))", "  (string-join\n   (sort\n    (string-split\
    \ numbers)\n    (\u03BB (x y)\n      (string<? x y)))\n   \" \"))\n", "  (string-join\n\
    \   (sort\n    (string-split numbers)\n    string<? )\n   \" \"))\n```\n\n```racket\n\
    #lang racket\n", "  (sort string<? numbers))\n", "  (string-append (string-join\
    \ (sort (string-split numbers) string<? #:key (lambda (x)\n                  \
    \                                                          (cond\n           \
    \                                                                   [(string=?\
    \ x \"zero\") 1]\n                                                           \
    \                   [(string=? x \"one\") 2]\n                               \
    \                                               [(string=? x \"two\") 3]\n   \
    \                                                                           [(string=?\
    \ x \"three\") 4]\n                                                          \
    \                    [(string=? x \"four\") 5]\n                             \
    \                                                 [(string=? x \"five\") 6]\n\
    \                                                                            \
    \  [(string=? x \"six\") 7]\n                                                \
    \                              [(string=? x \"seven\") 8]\n                  \
    \                                                            [(string=? x \"eight\"\
    ) 9]\n                                                                       \
    \       [(string=? x \"nine\") 10]))\n                                    )\n\
    \                          \" \")\n  )\n)\n```\n\n##### Output\n```\n#lang racket\n",
  "  (define (number-string->number number-string)\n    (cond\n      [(string=? number-string\
    \ \"zero\") 0]\n      [(string=? number-string \"one\") 1]\n      [(string=? number-string\
    \ \"two\") 2]\n      [(string=? number-string \"three\") 3]\n      [(string=?\
    \ number-string \"four\") 4]\n      [(string=? number-string \"five\") 5]\n  \
    \    [(string=? number-string \"six\") 6]\n      [(string=? number-string \"seven\"\
    ) 7]\n      [(string=? number-string \"eight\") 8]\n      [(string=? number-string\
    \ \"nine\") 9]))\n  (define (number->number-string number)\n    (cond\n      [(=\
    \ number 0) \"zero\"]\n      [(= number 1) \"one\"]\n      [(= number 2) \"two\"\
    ]\n      [(= number 3) \"three\"]\n      [(= number 4) \"four\"]\n      [(= number\
    \ 5) \"five\"]\n      [(= number 6) \"six\"]\n      [(= number 7) \"seven\"]\n\
    \      [(= number 8) \"eight\"]\n      [(= number 9) \"nine\"]))\n  (define (sort-numbers-rec\
    \ numbers sorted-numbers)\n    (if (empty? numbers)\n        sorted-numbers\n\
    \        (sort-numbers-rec (remove (string-&gt;number (car numbers)) numbers)\n\
    \                          (append sorted-numbers (list (car numbers))))))\n \
    \ (string-join (map number->number-string (sort-numbers-rec (map number-string->number\
    \ (string-split numbers \" \")) '())) \" \"))\n</code>\nTest\n<code>#lang racket\n",
  "  (let ([numbers (string-split numbers \" \")])\n    (define (sort-numbers lst)\n\
    \      (cond [(empty? lst) '()]\n            [(= (first lst) 0) (append (list\
    \ 0) (sort-numbers (rest lst)))]\n            [(= (first lst) 1) (append (list\
    \ 1) (sort-numbers (rest lst)))]\n            [(= (first lst) 2) (append (list\
    \ 2) (sort-numbers (rest lst)))]\n            [(= (first lst) 3) (append (list\
    \ 3) (sort-numbers (rest lst)))]\n            [(= (first lst) 4) (append (list\
    \ 4) (sort-numbers (rest lst)))]\n            [(= (first lst) 5) (append (list\
    \ 5) (sort-numbers (rest lst)))]\n            [(= (first lst) 6) (append (list\
    \ 6) (sort-numbers (rest lst)))]\n            [(= (first lst) 7) (append (list\
    \ 7) (sort-numbers (rest lst)))]\n            [(= (first lst) 8) (append (list\
    \ 8) (sort-numbers (rest lst)))]\n            [(= (first lst) 9) (append (list\
    \ 9) (sort-numbers (rest lst)))]))\n    (define (num-to-str n)\n      (cond [(=\
    \ n 0) \"zero\"]\n            [(= n 1) \"one\"]\n            [(= n 2) \"two\"\
    ]\n            [(= n 3) \"three\"]\n            [(= n 4) \"four\"]\n         \
    \   [(= n 5) \"five\"]\n            [(= n 6) \"six\"]\n            [(= n 7) \"\
    seven\"]\n            [(= n 8) \"eight\"]\n            [(= n 9) \"nine\"]))\n\
    \    (let ([str (map num-to-str (sort-numbers (map string->number numbers)))])\n\
    \      (string-join str \" \"))))\n", "  (sort (parse-numbers numbers) <))\n",
  "  (string-join\n   (sort\n    (string-split numbers #\\space)\n    (lambda (x y)\
    \ (< (string->number x) (string->number y))))\n   \" \"))", "  (match (string-split\
    \ numbers)\n    [`(\"zero\" ,num) (sort_numbers num)]\n    [`(\"one\" ,num) (sort_numbers\
    \ num)]\n    [`(\"two\" ,num) (sort_numbers num)]\n    [`(\"three\" ,num) (sort_numbers\
    \ num)]\n    [`(\"four\" ,num) (sort_numbers num)]\n    [`(\"five\" ,num) (sort_numbers\
    \ num)]\n    [`(\"six\" ,num) (sort_numbers num)]\n    [`(\"seven\" ,num) (sort_numbers\
    \ num)]\n    [`(\"eight\" ,num) (sort_numbers num)]\n    [`(\"nine\" ,num) (sort_numbers\
    \ num)]\n    [`(a . b) (match (sort-list (list a b))\n                     [`(#f\
    \ . #f) numbers]\n                     [`(a . #f) a]\n                     [`(a\
    \ . b) (string-append a \" \" b)])]))\n", "  (define (numerals numeral)\n    (match\
    \ numeral\n      ['zero 0]\n      ['one 1]\n      ['two 2]\n      ['three 3]\n\
    \      ['four 4]\n      ['five 5]\n      ['six 6]\n      ['seven 7]\n      ['eight\
    \ 8]\n      ['nine 9]))\n  (define (string->list string delimiter)\n    (if (empty?\
    \ string)\n        empty\n        (cons (first string)\n              (string->list\
    \ (rest string) delimiter))))\n  (define (list->string string)\n    (apply string-append\
    \ string))\n  (define (split string delimiter)\n    (define (split2 string)\n\
    \      (if (empty? string)\n          empty\n          (cons (list->string (first\
    \ string))\n                (split2 (rest string)))))\n    (if (empty? string)\n\
    \        empty\n        (cons (split2 (first string))\n              (split (rest\
    \ string) delimiter))))\n  (define (sort-array string)\n    (cond [(empty? string)\
    \ empty]\n          [(= 1 (length string)) string]\n          [else (let* ([pivot\
    \ (car string)]\n                       [lesser (filter (lambda (x) (< x pivot))\
    \ string)]\n                       [greater (filter (lambda (x) (> x pivot)) string)])\n\
    \                  (append (sort-array lesser)\n                          (list\
    \ pivot)\n                          (sort-array greater)))]))\n  (list->string\
    \ (sort-array (map numerals (split (string->list numbers #\\space) #\\ )) )))\n",
  "  (string-join (sort (string-split numbers) (\u03BB (a b) (&lt; (word-&gt;number\
    \ a) (word-&gt;number b)))) \" \"))\n", "  (string-join (sort (string-&gt;list\
    \ numbers) string&lt;?) \" \"))\n", '  (string-join (sort (string-split numbers
    #\space) <) #\space))', "  (cond\n    [(equal? numbers \"zero\") \"zero\"]\n \
    \   [(equal? numbers \"one\") \"one\"]\n    [(equal? numbers \"two\") \"two\"\
    ]\n    [(equal? numbers \"three\") \"three\"]\n    [(equal? numbers \"four\")\
    \ \"four\"]\n    [(equal? numbers \"five\") \"five\"]\n    [(equal? numbers \"\
    six\") \"six\"]\n    [(equal? numbers \"seven\") \"seven\"]\n    [(equal? numbers\
    \ \"eight\") \"eight\"]\n    [(equal? numbers \"nine\") \"nine\"]\n    [(equal?\
    \ numbers \"zero one\") \"zero one\"]\n    [(equal? numbers \"zero two\") \"zero\
    \ two\"]\n    [(equal? numbers \"zero three\") \"zero three\"]\n    [(equal? numbers\
    \ \"zero four\") \"zero four\"]\n    [(equal? numbers \"zero five\") \"zero five\"\
    ]\n    [(equal? numbers \"zero six\") \"zero six\"]\n    [(equal? numbers \"zero\
    \ seven\") \"zero seven\"]\n    [(equal? numbers \"zero eight\") \"zero eight\"\
    ]\n    [(equal? numbers \"zero nine\") \"zero nine\"]\n    [(equal? numbers \"\
    one two\") \"one two\"]\n    [(equal? numbers \"one three\") \"one three\"]\n\
    \    [(equal? numbers \"one four\") \"one four\"]\n    [(equal? numbers \"one\
    \ five\") \"one five\"]\n    [(equal? numbers \"one six\") \"one six\"]\n    [(equal?\
    \ numbers \"one seven\") \"one seven\"]\n    [(equal? numbers \"one eight\") \"\
    one eight\"]\n    [(equal? numbers \"one nine\") \"one nine\"]\n    [(equal? numbers\
    \ \"two three\") \"two three\"]\n    [(equal? numbers \"two four\") \"two four\"\
    ]\n    [(equal? numbers \"two five\") \"two five\"]\n    [(equal? numbers \"two\
    \ six\") \"two six\"]\n    [(equal? numbers \"two seven\") \"two seven\"]\n  \
    \  [(equal? numbers \"two eight\") \"two eight\"]\n    [(equal? numbers \"two\
    \ nine\") \"two nine\"]\n    [(equal? numbers \"three four\") \"three four\"]\n\
    \    [(equal? numbers \"three five\") \"three five\"]\n    [(equal? numbers \"\
    three six\") \"three six\"]\n    [(equal? numbers \"three seven\")", "  (string-join\
    \ (sort (string-split numbers)\n                     < #:key (lambda (s) (read-symbol\
    \ s)))\n               \" \"))\n", "  (define number-names '(zero one two three\
    \ four five six seven eight nine))\n  (define number-names-sorted '(zero one two\
    \ three four five six seven eight nine))\n  (define numbers-sorted (map (lambda\
    \ (x) (list-ref number-names-sorted x))\n                              (map (lambda\
    \ (x) (list-index x number-names))\n                                   (string-&gt;list\
    \ numbers))))\n  (list-&gt;string numbers-sorted))\n</code>\nThis is rather inefficient,\
    \ as the names are converted to numbers, the numbers are sorted and then the numbers\
    \ are converted back to names. How can I write a function that will take a string\
    \ of ordinal names and return a sorted list of the same strings?\n\n\nA:\n\nYou\
    \ can simply use the <code>sort</code> procedure:\n<code>(define (sort-numbers\
    \ s)\n  (apply string-append (sort (string-&gt;list s) string&lt;?)))\n</code>\n\
    Or, with a better variable name:\n<code>(define (sort-numbers-string s)\n  (apply\
    \ string-append (sort (string-&gt;list s) string&lt;?)))\n</code>\n", "  (define\
    \ numbers-list (string-&gt;list numbers))\n  (define num-map (list '('zero 0)\
    \ '('one 1) '('two 2) '('three 3) '('four 4) '('five 5) '('six 6) '('seven 7)\
    \ '('eight 8) '('nine 9)))\n  (sort &lt; numbers-list num-map))\n</code>\nThis\
    \ is my first try at Racket, any suggestions of improvements are appreciated.\n\
    \n\nA:\n\nHere's the code I came up with:\n<code>(define (sort-numbers numbers)\n\
    \  (string-join\n   (sort\n    &lt;\n    (string-split numbers #\\space)\n   \
    \ (lambda (a b)\n      (&lt; (number-&gt;string (word-to-number a))\n        \
    \ (number-&gt;string (word-to-number b)))))))\n", "  (let ((sort-function (lambda\
    \ (a b)\n                         (cond\n                          ((and (number?\
    \ a) (number? b))\n                           (< a b))\n                     \
    \     ((and (number? a) (string? b))\n                           #t)\n       \
    \                   ((and (string? a) (number? b))\n                         \
    \  #f)\n                          ((and (string? a) (string? b))\n           \
    \                (string<? a b))))))\n    (string-join (sort (string-split numbers)\
    \ sort-function) \" \")))\n```\n\n```racket\n#lang racket\n", "  (define numberals\
    \ '(zero one two three four five six seven eight nine))\n  (define numberal->int\n\
    \    (let ([table (make-hasheq)])\n      (for ([i (in-naturals)]\n           \
    \ [n numberals])\n        (hash-set! table n i))\n      table))\n  (define int->numberal\n\
    \    (let ([table (make-hasheq)])\n      (for ([i (in-naturals)]\n           \
    \ [n numberals])\n        (hash-set! table i n))\n      table))\n  (string-join\n\
    \   (map int->numberal\n        (sort (map numberal->int\n                   (string-split\
    \ numbers))\n              <))\n   \" \"))\n", "  (define mapping\n    '((zero\
    \ . 0)\n      (one . 1)\n      (two . 2)\n      (three . 3)\n      (four . 4)\n\
    \      (five . 5)\n      (six . 6)\n      (seven . 7)\n      (eight . 8)\n   \
    \   (nine . 9)))\n  (define numeral->number\n    (lambda (numeral)\n      (string->number\
    \ (cdr (assoc numeral mapping)))))\n  (define str->list\n    (lambda (s)\n   \
    \   (regexp-match* #rx\"(\\w+)\" s)))\n  (string-join\n   (list->string\n    (map\
    \ number->string\n         (sort (map numeral->number (str->list numbers)) <)))\n\
    \   \" \"))", "  (define ord {'zero 0 'one 1 'two 2 'three 3 'four 4 'five 5 'six\
    \ 6 'seven 7 'eight 8 'nine 9})\n  (apply string-append (sort (tokenize numbers)\
    \ < (lambda (a b) (< (ord a) (ord b))))))", "  (define word-to-number (hash \"\
    zero\" 0 \"one\" 1 \"two\" 2 \"three\" 3 \"four\" 4 \"five\" 5 \"six\" 6 \"seven\"\
    \ 7 \"eight\" 8 \"nine\" 9))\n  (define number-to-word (hash 0 \"zero\" 1 \"one\"\
    \ 2 \"two\" 3 \"three\" 4 \"four\" 5 \"five\" 6 \"six\" 7 \"seven\" 8 \"eight\"\
    \ 9 \"nine\"))\n  (define sorted-numbers (sort (string-&gt;list numbers) (\u03BB\
    \ (a b) (&lt; a b))))\n  (define numbers-list (map (\u03BB (n) (string-&gt;number\
    \ (hash-ref word-to-number n))) sorted-numbers))\n  (fold (\u03BB (acc n) (hash-ref\
    \ number-to-word n)) \"\" numbers-list))\n</code>\n", "  (sort (map (lambda (numeral)\
    \ (string->number (symbol->string numeral))) (string-&gt;list/lines (string-&gt;symbol\
    \ numbers) 'space)) &lt;))\n</code>\nand it works with <code>\"(sort_numbers 'three\
    \ one five)\"</code>.\nBut how can I remove the quotes from the command line output?\
    \ It looks messy with quotes. Ideally I want:\n<code>&gt; (sort_numbers 'three\
    \ one five)\none three five\n</code>\nThanks.\n\n\nA:\n\nYou can try to use <code>map</code>\
    \ to convert each number to a string before printing out the result.\n<code>(define\
    \ (sort_numbers numbers)\n  (map number-&gt;string\n       (sort (map (lambda\
    \ (numeral) (string-&gt;number (symbol-&gt;string numeral)))\n               \
    \   (string-&gt;list/lines (string-&gt;symbol numbers) 'space))\n            \
    \ &lt;)))\n</code>\n", "  (apply string-append (sort (map (\u03BB (word) (string-&gt;number\
    \ word)) (string-split numbers #\\space)) &lt;)))\n</code>\n", "  (string-join\n\
    \   (sort (map number->string (map string->number (string-split numbers #\\space)))\n\
    \         <\n         (lambda (x y) (string<? x y)))\n   \" \"))\n", "  (string-join\
    \ (sort (string-split numbers)\n                     <\n                     string<?\n\
    \                     (lambda (a b) (number->string (< (string->number a) (string->number\
    \ b)))))\n                \" \"))\n", "  (send (string-&gt;list numbers)\n   \
    \     map\n        (lambda (numeral)\n          (string-&gt;number (match numeral\n\
    \                                  ['zero 0]\n                               \
    \   ['one 1]\n                                  ['two 2]\n                   \
    \               ['three 3]\n                                  ['four 4]\n    \
    \                              ['five 5]\n                                  ['six\
    \ 6]\n                                  ['seven 7]\n                         \
    \         ['eight 8]\n                                  ['nine 9])))\n       \
    \ sort\n        (lambda (num1 num2)\n          (&lt; num1 num2))\n        map\n\
    \        (lambda (number)\n          (number-&gt;string number))\n        string-join))\n",
  "  (define str->num (hash (\"zero\" . 0) (\"one\" . 1) (\"two\" . 2) (\"three\"\
    \ . 3) (\"four\" . 4) (\"five\" . 5) (\"six\" . 6) (\"seven\" . 7) (\"eight\"\
    \ . 8) (\"nine\" . 9)))\n  (define num->str (hash (0 . \"zero\") (1 . \"one\"\
    ) (2 . \"two\") (3 . \"three\") (4 . \"four\") (5 . \"five\") (6 . \"six\") (7\
    \ . \"seven\") (8 . \"eight\") (9 . \"nine\")))\n  (string-join\n   (for/list\
    \ ([num (in-list (sort (string-split numbers \" \")))])\n     (num->str (hash-ref\
    \ str->num num))\n     )\n   \" \"))\n", "  (define numbers-list (split-at #\\\
    space numbers))\n  (define numeral-map\n    (list (cons 'zero 0)\n          (cons\
    \ 'one 1)\n          (cons 'two 2)\n          (cons 'three 3)\n          (cons\
    \ 'four 4)\n          (cons 'five 5)\n          (cons 'six 6)\n          (cons\
    \ 'seven 7)\n          (cons 'eight 8)\n          (cons 'nine 9)))\n  (define\
    \ (get-number x)\n    (cdr (assoc x numeral-map)))\n  (define (insert-number x)\n\
    \    (map\n     (lambda (y)\n       (if (= x y)\n           (symbol->string x)\n\
    \           \"\"))\n     numeral-map))\n  (define (insert-numbers acc y)\n   \
    \ (if (= y 0)\n        acc\n        (insert-numbers (string-append acc (insert-number\
    \ y)) (- y 1))))\n  (list->string (map list->string (sort (map (lambda (x) (insert-numbers\
    \ \"\" (get-number x))) numbers-list) <))))", "  (define (dollars->cents dollars)\n\
    \    (cond [(number? dollars) (* dollars 100)]\n          [(list? dollars) (+\
    \ (* (car dollars) 100) (dollars->cents (cdr dollars)))]))\n  (define (numbers->dollars\
    \ dollars)\n    (cond [(= 0 dollars) ']\n          [(= dollars 100) '(one)]\n\
    \          [(= dollars 200) '(two)]\n          [(= dollars 300) '(three)]\n  \
    \        [(= dollars 400) '(four)]\n          [(= dollars 500) '(five)]\n    \
    \      [(= dollars 600) '(six)]\n          [(= dollars 700) '(seven)]\n      \
    \    [(= dollars 800) '(eight)]\n          [(= dollars 900) '(nine)]\n       \
    \   [(> dollars 900) (cons (numbers->dollars (- dollars 900)) '(nine))]\n    \
    \      [(> dollars 800) (cons (numbers->dollars (- dollars 800)) '(eight))]\n\
    \          [(> dollars 700) (cons (numbers->dollars (- dollars 700)) '(seven))]\n\
    \          [(> dollars 600) (cons (numbers->dollars (- dollars 600)) '(six))]\n\
    \          [(> dollars 500) (cons (numbers->dollars (- dollars 500)) '(five))]\n\
    \          [(> dollars 400) (cons (numbers->dollars (- dollars 400)) '(four))]\n\
    \          [(> dollars 300) (cons (numbers->dollars (- dollars 300)) '(three))]\n\
    \          [(> dollars 200) (cons (numbers->dollars (- dollars 200)) '(two))]\n\
    \          [(> dollars 100) (cons (numbers->dollars (- dollars 100)) '(one))]))\n\
    \  (define (numbers->dollars-string dollars)\n    (cond [(= 0 dollars) \"\"]\n\
    \          [(= dollars 100) \"one\"]\n          [(= dollars 200) \"two\"]\n  \
    \        [(= dollars 300) \"three\"]\n          [(= dollars 400) \"four\"]\n \
    \         [(= dollars 500) \"five\"]\n          [(= dollars 600) \"six\"]\n  \
    \        [(= dollars 700) \"seven\"]\n          [(= dollars 800) \"eight\"]\n\
    \          [(= dollars 900) \"nine\"]\n          [(> dollars 900) (string-", " \
    \ (define number-map\n    '((\"zero\" . 0)\n      (\"one\" . 1)\n      (\"two\"\
    \ . 2)\n      (\"three\" . 3)\n      (\"four\" . 4)\n      (\"five\" . 5)\n  \
    \    (\"six\" . 6)\n      (\"seven\" . 7)\n      (\"eight\" . 8)\n      (\"nine\"\
    \ . 9)))\n  (define (number-from-word word)\n    (number->string (cdr (assoc word\
    \ number-map))))\n  (define (word-from-number number)\n    (car (assoc (string->number\
    \ number) number-map)))\n  (for/list ([word (in-list (string-split numbers))])\n\
    \    (word-from-number (number-from-word word)))\n  (string-join (sort (for/list\
    \ ([word (in-list (string-split numbers))])\n                       (word-from-number\
    \ (number-from-word word)))\n                     <)\n               \" \"))\n",
  "  (sort-string->number (string-split numbers #\\space)))\n", "  (define numbers-sorted\
    \ (sort string<? (string-split numbers #\\space)))\n  (string-join numbers-sorted\
    \ \" \"))\n", "  (define (get-number str)\n    (cond\n      [(string=? str \"\
    zero\") 0]\n      [(string=? str \"one\") 1]\n      [(string=? str \"two\") 2]\n\
    \      [(string=? str \"three\") 3]\n      [(string=? str \"four\") 4]\n     \
    \ [(string=? str \"five\") 5]\n      [(string=? str \"six\") 6]\n      [(string=?\
    \ str \"seven\") 7]\n      [(string=? str \"eight\") 8]\n      [(string=? str\
    \ \"nine\") 9]))\n  (define (get-string n)\n    (cond\n      [(= n 0) \"zero\"\
    ]\n      [(= n 1) \"one\"]\n      [(= n 2) \"two\"]\n      [(= n 3) \"three\"\
    ]\n      [(= n 4) \"four\"]\n      [(= n 5) \"five\"]\n      [(= n 6) \"six\"\
    ]\n      [(= n 7) \"seven\"]\n      [(= n 8) \"eight\"]\n      [(= n 9) \"nine\"\
    ]))\n  (define (sort-strings strs)\n    (cond\n      [(null? strs) '()]\n    \
    \  [else (cons (get-string (apply min (map get-number strs)))\n              \
    \    (sort-strings (remove (get-string (apply min (map get-number strs))) strs)))]))\n\
    \  (cond\n    [(null? numbers) \"\"]\n    [else (string-join (sort-strings (string-split\
    \ numbers)) \" \")]))\n", "  (string-join\n   (sort\n    (map string->number\n\
    \         (string-split (regexp-replace #rx\"\\W+\" numbers \" \") #rx\" \"))\n\
    \    <)\n   \" \"))\n", "  (sort (string-split numbers #\\space)\n        string<?))\n",
  '  (string-join (string-sort (string-split numbers) <) " "))', "  (let ([sorted-numbers\
    \ (sort numbers number-&lt;?)])\n    (for/list ([sorted-number sorted-numbers])\n\
    \      (string-&gt;number (string-trim sorted-number)))))\n", "  (define number-map\
    \ '((\"zero\" . 0) (\"one\" . 1) (\"two\" . 2) (\"three\" . 3) (\"four\" . 4)\
    \ (\"five\" . 5) (\"six\" . 6) (\"seven\" . 7) (\"eight\" . 8) (\"nine\" . 9)))\n\
    \  (map (lambda (s) (assoc-ref number-map s)) (sort (string-split numbers #\\\
    space) (lambda (s1 s2) (< (assoc-ref number-map s1) (assoc-ref number-map s2))))))\n",
  "  (let ([nums (string-&gt;list numbers)])\n    (map\n     symbol-&gt;string\n \
    \    (sort (map string-&gt;symbol (string-split nums \" \")) string&lt;?)\n  \
    \   )\n     )\n  )\n</code>\nThe error I get is\n<code>sort_numbers: expects type\
    \ &lt;string&gt; as 1st argument, given: \"three one five\"; other arguments were:\n\
    </code>\nand then it shows a bunch of <code>#&lt;procedure&gt;</code>s\nAm I missing\
    \ something?\n\n\nA:\n\nYour code is trying to apply a procedure that accepts\
    \ a single argument to multiple arguments.\n<code>(sort (map string-&gt;symbol\
    \ (string-split nums \" \")) string&lt;?)\n</code>\nInstead, you can use <code>apply</code>\
    \ as follows:\n<code>(apply sort (map string-&gt;symbol (string-split nums \"\
    \ \")) string&lt;?)\n</code>\nOr, you can inline <code>sort</code>'s first argument:\n\
    <code>(sort (map string-&gt;symbol (string-split nums \" \"))\n      string&lt;?)\n\
    </code>\n", "  (string-join (sort (map string->number (string-split numbers #\\\
    space)) <) #\\space))\n", "  (string-join\n   (sort\n    (string-split numbers\
    \ #\\space)\n    (lambda (x y)\n      (<\n       (cond\n        [(string=? x \"\
    zero\")  0]\n        [(string=? x \"one\")   1]\n        [(string=? x \"two\"\
    )   2]\n        [(string=? x \"three\") 3]\n        [(string=? x \"four\")  4]\n\
    \        [(string=? x \"five\")  5]\n        [(string=? x \"six\")   6]\n    \
    \    [(string=? x \"seven\") 7]\n        [(string=? x \"eight\") 8]\n        [(string=?\
    \ x \"nine\")  9])\n       (cond\n        [(string=? y \"zero\")  0]\n       \
    \ [(string=? y \"one\")   1]\n        [(string=? y \"two\")   2]\n        [(string=?\
    \ y \"three\") 3]\n        [(string=? y \"four\")  4]\n        [(string=? y \"\
    five\")  5]\n        [(string=? y \"six\")   6]\n        [(string=? y \"seven\"\
    ) 7]\n        [(string=? y \"eight\") 8]\n        [(string=? y \"nine\")  9]))))\n\
    \   #\\space))\n```\n\n## 13\n\n```racket\n#lang racket\n", "  (define index-to-numeral-table\
    \ (list (list 0 \"zero\") (list 1 \"one\") (list 2 \"two\") (list 3 \"three\"\
    ) (list 4 \"four\") (list 5 \"five\") (list 6 \"six\") (list 7 \"seven\") (list\
    \ 8 \"eight\") (list 9 \"nine\")))\n  (define (numeral-to-index numeral)\n   \
    \ (car (assoc numeral index-to-numeral-table)))\n  (define (word-to-numeral word)\n\
    \    (cond ((string=? word \"zero\") (numeral-to-index \"zero\"))\n          ((string=?\
    \ word \"one\") (numeral-to-index \"one\"))\n          ((string=? word \"two\"\
    ) (numeral-to-index \"two\"))\n          ((string=? word \"three\") (numeral-to-index\
    \ \"three\"))\n          ((string=? word \"four\") (numeral-to-index \"four\"\
    ))\n          ((string=? word \"five\") (numeral-to-index \"five\"))\n       \
    \   ((string=? word \"six\") (numeral-to-index \"six\"))\n          ((string=?\
    \ word \"seven\") (numeral-to-index \"seven\"))\n          ((string=? word \"\
    eight\") (numeral-to-index \"eight\"))\n          ((string=? word \"nine\") (numeral-to-index\
    \ \"nine\"))))\n  (define (numeral-to-word numeral)\n    (car (cdr (assoc numeral\
    \ index-to-numeral-table))))\n  (string-join (for/list ([numeral (in-list (string-split\
    \ numbers #\\space))])\n                  (numeral-to-word (word-to-numeral numeral)))\n\
    \               \" \"))\n```\n\n## 7 - Sorting a String in Racket\n\n``` #lang\
    \ racket\n", "  (string-join\n   (sort (string-split numbers #\\space) string<?)))\n",
  "  (sort (string-split numbers)\n        (lambda (x y)\n          (< (number->string\
    \ (string->number x))\n             (number->string (string->number y))))))\n",
  "  (string-join (sort (split-at numbers \" \") (lambda (n1 n2) (string<? n1 n2)))\
    \ \" \"))\n```\n\n## Input to `answers/q01.rkt`\n\n```\n#lang racket\n", "  (define\
    \ (get-numeral numeral)\n    (cond [(equal? numeral \"zero\") 0]\n          [(equal?\
    \ numeral \"one\") 1]\n          [(equal? numeral \"two\") 2]\n          [(equal?\
    \ numeral \"three\") 3]\n          [(equal? numeral \"four\") 4]\n          [(equal?\
    \ numeral \"five\") 5]\n          [(equal? numeral \"six\") 6]\n          [(equal?\
    \ numeral \"seven\") 7]\n          [(equal? numeral \"eight\") 8]\n          [(equal?\
    \ numeral \"nine\") 9]))\n  (define (get-numeral-name numeral)\n    (cond [(equal?\
    \ numeral 0) \"zero\"]\n          [(equal? numeral 1) \"one\"]\n          [(equal?\
    \ numeral 2) \"two\"]\n          [(equal? numeral 3) \"three\"]\n          [(equal?\
    \ numeral 4) \"four\"]\n          [(equal? numeral 5) \"five\"]\n          [(equal?\
    \ numeral 6) \"six\"]\n          [(equal? numeral 7) \"seven\"]\n          [(equal?\
    \ numeral 8) \"eight\"]\n          [(equal? numeral 9) \"nine\"]))\n  (define\
    \ (sort-numerals numerals)\n    (sort (map get-numeral numerals) <))\n  (string-join\
    \ (map get-numeral-name (sort-numerals (string-split numbers #\\space))) \" \"\
    ))\n", "  (string-join (sort (map (lambda (x) (string->number x)) (string-split\
    \ numbers #\\space)) <) #\\space))\n", "  (split-each (lambda (x) (print x)) (sort\
    \ (split-at numbers #\\space) <)))\n", "  (apply string-append\n         (for/list\
    \ ([num (in-list (string-split numbers))])\n           (string-append (sort-num\
    \ num) \" \"))))\n", "  (apply string-append\n         (sort (string-split numbers\
    \ #\\space) (\u03BB (s1 s2)\n                                               (string&lt;?\
    \ s1 s2)))))\n", "  (map number->word (sort (map word->number (string-&gt;list\
    \ numbers)) &lt;)))\n", "  (define (n-to-int num)\n    (case num\n      ('zero\
    \ 0)\n      ('one 1)\n      ('two 2)\n      ('three 3)\n      ('four 4)\n    \
    \  ('five 5)\n      ('six 6)\n      ('seven 7)\n      ('eight 8)\n      ('nine\
    \ 9)))\n  (string-join (sort < (string-split numbers #\\space) n-to-int) #\\space))\n",
  "  (string-join (sort (string-split numbers) <) \" \"))\n", "  (let ([names (list\
    \ 'zero 'one 'two 'three 'four 'five 'six 'seven 'eight 'nine)])\n    (define\
    \ (convert name)\n      (list-ref names (string->number (string-replace \" \"\
    \ \"\" name))))\n    (define (take-while predicate lst)\n      (cond [(empty?\
    \ lst) '()]\n            [(predicate (first lst)) (cons (first lst) (take-while\
    \ predicate (rest lst)))]\n            [else '()]))\n    (define (drop-while predicate\
    \ lst)\n      (cond [(empty? lst) '()]\n            [(predicate (first lst)) (drop-while\
    \ predicate (rest lst))]\n            [else lst]))\n    (define (sort-by fun lst)\n\
    \      (sort lst < fun))\n    (define (nums-to-names numbers)\n      (string-join\
    \ (map (lambda (x) (symbol->string x)) numbers) \" \"))\n    (nums-to-names (sort-by\
    \ convert (string-split numbers \" \")))))\n", "  (string-append \"one \" \"three\
    \ \" \"five\"))\n```\n\n```racket\n#lang racket\n", "  (define nums\n    (map\
    \ symbol->number\n         (string-split numbers \" \")))\n  (define sort-nums\n\
    \    (sort nums <))\n  (apply string-append\n         (map number->string sort-nums)))\n",
  "  (cond\n    [(empty? numbers) empty]\n    [else\n     (define num-list (string-&gt;list\
    \ numbers))\n     (define s-list '())\n     (for ([i (in-range (string-length\
    \ numbers))])\n       (define add-str\n         (cond\n           [(= (string-ref\
    \ num-list i) #\\s) empty]\n           [else (string (string-ref num-list i))]))\n\
    \       (set! s-list (append add-str s-list)))\n     (apply string-join (merge\
    \ string&lt;? s-list))]))\n</code>\nMy head hurts now, but I'm pretty sure that\
    \ it's not possible to use <code>&lt;</code> on a <code>string</code>. So I need\
    \ to convert the <code>string</code> into something more \"orderable\" and then\
    \ put it back into a <code>string</code>. I'm not sure how to do this.\nI'm also\
    \ not sure how to make sure that I don't keep adding spaces to the list.\nThe\
    \ output when I run the above is simply:\n<code>\"eieeieeeiiiiiinnrrtttvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv",
  "  (sort numbers\n        (lambda (a b) (< (string->number a) (string->number b)))))",
  "  (string-join (string-sort (string-split numbers) #:key\n                    \
    \        (lambda (s)\n                              (match s\n               \
    \                 [\"zero\" 0]\n                                [\"one\" 1]\n\
    \                                [\"two\" 2]\n                               \
    \ [\"three\" 3]\n                                [\"four\" 4]\n              \
    \                  [\"five\" 5]\n                                [\"six\" 6]\n\
    \                                [\"seven\" 7]\n                             \
    \   [\"eight\" 8]\n                                [\"nine\" 9])))\n         \
    \      \" \"))", "  (sort (string-&gt;list numbers) &lt;))\n", "  (sort\n   (string-&gt;list\
    \ numbers)\n   (lambda (a b)\n     (&lt; (string-&gt;number (list-&gt;string (list\
    \ a)))\n        (string-&gt;number (list-&gt;string (list b)))))))\n</code>\n\
    This works as expected, e.g. <code>(sort_numbers \"three one five\")</code> returns\
    \ <code>\"one three five\"</code>.\nI then tried to shorten it using <code>compose</code>\
    \ and <code>apply</code>, but without success, e.g. this doesn't work:\n<code>(define\
    \ (sort_numbers numbers)\n  (apply\n   sort\n   (string-&gt;list numbers)\n  \
    \ (compose\n    string-&gt;number\n    list-&gt;string\n    list)))\n</code>\n\
    I'm not sure what I'm doing wrong, and my google-fu came up short.\n\n\nA:\n\n\
    The main problem is that <code>apply</code> only accepts one list argument, and\
    \ you're passing it two: the <code>string-&gt;list</code> and the <code>compose</code>ed\
    \ functions. What you're trying to do is to pass <code>sort</code> the arguments\
    \ <code>string-&gt;list</code>, <code>compose</code>, <code>string-&gt;number</code>,\
    \ <code>list-&gt;string</code>, and <code>list</code>, which is nonsensical. <code>apply</code>\
    \ will just take the result of <code>string-&gt;list</code> and throw away everything\
    \ else.\nTry this instead:\n<code>(apply sort (string-&gt;list numbers)\n    \
    \    (lambda (a b)\n          (&lt; (string-&gt;number (list-&gt;string (list\
    \ a)))\n             (string-&gt;number (list-&gt;string (list b))))))\n</code>\n",
  "  (match numbers\n    [(or (or \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\"\
    \ \"six\" \"seven\" \"eight\" \"nine\") (regexp #rx\"[a-z] [a-z]\"))\n     (match\
    \ numbers\n       [(list \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"\
    seven\" \"eight\" \"nine\" \"zero\")\n        numbers]\n       [(list \"one\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\")\n\
    \        (append numbers (list \"zero\"))]\n       [(list \"one\" \"two\" \"three\"\
    \ \"four\" \"five\" \"six\" \"seven\" \"eight\")\n        (append numbers (list\
    \ \"nine\" \"zero\"))]\n       [(list \"one\" \"two\" \"three\" \"four\" \"five\"\
    \ \"six\" \"seven\")\n        (append numbers (list \"eight\" \"nine\" \"zero\"\
    ))]\n       [(list \"one\" \"two\" \"three\" \"four\" \"five\" \"six\")\n    \
    \    (append numbers (list \"seven\" \"eight\" \"nine\" \"zero\"))]\n       [(list\
    \ \"one\" \"two\" \"three\" \"four\" \"five\")\n        (append numbers (list\
    \ \"six\" \"seven\" \"eight\" \"nine\" \"zero\"))]\n       [(list \"one\" \"two\"\
    \ \"three\" \"four\")\n        (append numbers (list \"five\" \"six\" \"seven\"\
    \ \"eight\" \"nine\" \"zero\"))]\n       [(list \"one\" \"two\" \"three\")\n \
    \       (append numbers (list \"four\" \"five\" \"six\" \"seven\" \"eight\" \"\
    nine\" \"zero\"))]\n       [(list \"one\" \"two\")\n        (append numbers (list\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"zero\"))]\n\
    \       [(list \"one\")\n        (append numbers (list \"two\" \"three\" \"four\"\
    \ \"five\" \"six\" \"seven\" \"eight\" \"nine\" \"zero\"))]\n       [_\n     \
    \   (append numbers (list \"one\" \"two\" \"three\" \"four\" \"five\" \"six\"\
    \ \"seven\" \"", "  (cond [(empty? numbers) '()]\n        [else\n         (cond\
    \ [(equal? (first numbers) 'zero) (cons 'zero (sort_numbers (rest numbers)))]\n\
    \               [(equal? (first numbers) 'one) (cons 'one (sort_numbers (rest\
    \ numbers)))]\n               [(equal? (first numbers) 'two) (cons 'two (sort_numbers\
    \ (rest numbers)))]\n               [(equal? (first numbers) 'three) (cons 'three\
    \ (sort_numbers (rest numbers)))]\n               [(equal? (first numbers) 'four)\
    \ (cons 'four (sort_numbers (rest numbers)))]\n               [(equal? (first\
    \ numbers) 'five) (cons 'five (sort_numbers (rest numbers)))]\n              \
    \ [(equal? (first numbers) 'six) (cons 'six (sort_numbers (rest numbers)))]\n\
    \               [(equal? (first numbers) 'seven) (cons 'seven (sort_numbers (rest\
    \ numbers)))]\n               [(equal? (first numbers) 'eight) (cons 'eight (sort_numbers\
    \ (rest numbers)))]\n               [(equal? (first numbers) 'nine) (cons 'nine\
    \ (sort_numbers (rest numbers)))]\n               [else (sort_numbers (rest numbers))])])\n\
    \  )", "  (local [(define num-hash (hasheq 'zero 0 'one 1 'two 2 'three 3 'four\
    \ 4 'five 5 'six 6 'seven 7 'eight 8 'nine 9))\n           (define (as-num str)\
    \ (hash-ref num-hash str #f))\n           (define (as-str num) (hash-ref (hash-invert\
    \ num-hash) num #f))\n           (define (as-number-list str) (map as-num (string-split\
    \ str)))\n           (define (as-string-list lst) (map as-str lst))]\n    (apply\
    \ string-join (as-string-list (sort (as-number-list numbers) <)))))\n```\n\n```\
    \ #lang racket\n", "  (sort (string-&gt;list numbers) &lt;:string=?))\n", "  (string-join\n\
    \   (sort\n    (string-split numbers #\\space)\n    (\u03BB (x y)\n      (< (string->number\
    \ x) (string->number y))))\n   #\\space))\n```\n\n### Fourth\n\n```#lang racket\n",
  "  (define (str->num word)\n    (cond\n      [(equal? word \"zero\")  0]\n     \
    \ [(equal? word \"one\")   1]\n      [(equal? word \"two\")   2]\n      [(equal?\
    \ word \"three\") 3]\n      [(equal? word \"four\")  4]\n      [(equal? word \"\
    five\")  5]\n      [(equal? word \"six\")   6]\n      [(equal? word \"seven\"\
    ) 7]\n      [(equal? word \"eight\") 8]\n      [(equal? word \"nine\")  9]))\n\
    \  (apply string-append\n         (map number->string\n              (sort (map\
    \ str->num (string-split numbers #\\space)) <))))\n", "  (sort (string-&gt;list\
    \ numbers) number-&gt;string))\n", "  (let* ([num-map (make-hash)]\n         [keys\
    \ '(zero one two three four five six seven eight nine)])\n    (for ([key keys]\n\
    \          [val (in-range 10)])\n      (hash-set! num-map key val))\n    (sort\
    \ (string-&gt;list numbers)\n          &lt; #:key (lambda (x) (hash-ref num-map\
    \ x #f))))))\n", "  (let* ([numbers-list (string-split numbers #\\space)]\n  \
    \       [sort-fn (lambda (x y) (< (string->number x) (string->number y)))]\n \
    \        [sorted-numbers (sort sort-fn numbers-list)])\n    (string-join sorted-numbers\
    \ #\\space)))\n", "  (apply string-append (sort (string-split numbers #\\space)\
    \ <)))\n", "  (define (str-to-num num)\n    (cond [(string=? num \"zero\")  0]\n\
    \          [(string=? num \"one\")   1]\n          [(string=? num \"two\")   2]\n\
    \          [(string=? num \"three\") 3]\n          [(string=? num \"four\")  4]\n\
    \          [(string=? num \"five\")  5]\n          [(string=? num \"six\")   6]\n\
    \          [(string=? num \"seven\") 7]\n          [(string=? num \"eight\") 8]\n\
    \          [(string=? num \"nine\")  9]))\n  (define (num-to-str num)\n    (cond\
    \ [(= num 0) \"zero\"]\n          [(= num 1) \"one\"]\n          [(= num 2) \"\
    two\"]\n          [(= num 3) \"three\"]\n          [(= num 4) \"four\"]\n    \
    \      [(= num 5) \"five\"]\n          [(= num 6) \"six\"]\n          [(= num\
    \ 7) \"seven\"]\n          [(= num 8) \"eight\"]\n          [(= num 9) \"nine\"\
    ]))\n  (string-join (map num-to-str (sort (map str-to-num (string-split numbers\
    \ #\\space)) <)) #\\space))", "  (define num-sorted\n    (sort string<? (string-split\
    \ numbers)))\n  (string-join num-sorted \" \"))\n", "  (string-join (sort (string-split\
    \ numbers #\\space) string<?)))\n", "  (sort string<?\n        (apply string-join\n\
    \               (regexp-match* #rx\"\\\\S+\" numbers))))\n", "  (sort-numbers\n\
    \   (split-string numbers \" \")\n   (make-hasheq)\n   (list)))\n", "  (string-join\n\
    \   (sort\n    (string-split numbers #\\space)\n    (lambda (x y) (< (string->number\
    \ x) (string->number y))))\n   \" \"))\n```\n## Exercise 2: Sum even numbers\n\
    \n```racket\n#lang racket\n", "  (sort (string-split numbers #\\space)\n     \
    \   (lambda (a b)\n          (let ((nums '((nine . 9) (eight . 8) (seven . 7)\
    \ (six . 6) (five . 5) (four . 4) (three . 3) (two . 2) (one . 1) (zero . 0))))\n\
    \            (< (cdr (assoc a nums))\n               (cdr (assoc b nums)))))))\n",
  "  (string-join\n   (sort\n    (string-split numbers #\\space)\n    (lambda (a b)\n\
    \      (string<? a b)))\n   \" \"))\n", "  (sort numbers\n        string<?))\n",
  "  (sort\n   (string-split numbers #\\space)\n   (string<? (number-&gt;string))))\n",
  "  (string-join\n   (sort string<?\n         (string-split numbers))\n   \" \"))\n",
  "  (define (clean-numbers)\n    (string-split (regexp-replace* #rx\"[^a-zA-Z]+\"\
    \ numbers \" \") \" \"))\n  (define (numerals)\n    (map (\u03BB (numeral) (define-values\
    \ (numeral-numeral) (split-at (search-all (char-set #\\one) numeral) numeral)))\n\
    \         (clean-numbers)))\n  (define (numeral-numerals)\n    (map (\u03BB (numeral)\
    \ (if (numeral-numeral numeral)\n                          (exact->inexact (string->number\
    \ (string-intersperse (string-split (numeral-numeral numeral) \"\") \"\")))\n\
    \                          \"\"))\n         numerals))\n  (define (clean-numerals)\n\
    \    (filter (\u03BB (x) (not (empty? x)))\n            (map (\u03BB (x) (string-trim\
    \ (regexp-replace* #rx\"[^a-zA-Z]+\" x \" \")))\n                 (clean-numbers))))\n\
    \  (string-intersperse (sort (append (clean-numerals) (numeral-numerals))\n  \
    \                          <)\n                      \" \"))", "  (define numeral-map\n\
    \    (list\n     (list \"zero\"  0)\n     (list \"one\"   1)\n     (list \"two\"\
    \   2)\n     (list \"three\" 3)\n     (list \"four\"  4)\n     (list \"five\"\
    \  5)\n     (list \"six\"   6)\n     (list \"seven\" 7)\n     (list \"eight\"\
    \ 8)\n     (list \"nine\"  9)))\n  (define (number->numeral number)\n    (cadr\
    \ (assoc number numeral-map)))\n  (define (numeral->number numeral)\n    (cadr\
    \ (assoc numeral numeral-map)))\n  (define (numbers->numerals numbers)\n    (map\
    \ number->numeral numbers))\n  (define (numerals->numbers numerals)\n    (map\
    \ numeral->number numerals))\n  (define (numeral-sort numerals)\n    (sort < numerals))\n\
    \  (define (string-join lst separator)\n    (string-join (apply append (map (lambda\
    \ (n) (list n separator)) lst)) \"\"))\n  (string-join (numbers->numerals (numeral-sort\
    \ (numerals->numbers (string-split numbers)))) \" \"))", "  (sort string&lt;?\
    \ (string-split numbers #\\space)))\n", "  (string-join (sort (string-split numbers\
    \ #\\space) string<? #:key (\u03BB (n) (string->number n))) #\\space))\n", " \
    \ (define (numeral->num numeral)\n    (cond\n      ((string=? numeral \"zero\"\
    ) 0)\n      ((string=? numeral \"one\") 1)\n      ((string=? numeral \"two\")\
    \ 2)\n      ((string=? numeral \"three\") 3)\n      ((string=? numeral \"four\"\
    ) 4)\n      ((string=? numeral \"five\") 5)\n      ((string=? numeral \"six\"\
    ) 6)\n      ((string=? numeral \"seven\") 7)\n      ((string=? numeral \"eight\"\
    ) 8)\n      ((string=? numeral \"nine\") 9)))\n  (define (nums->numeral num)\n\
    \    (cond\n      ((= num 0) \"zero\")\n      ((= num 1) \"one\")\n      ((= num\
    \ 2) \"two\")\n      ((= num 3) \"three\")\n      ((= num 4) \"four\")\n     \
    \ ((= num 5) \"five\")\n      ((= num 6) \"six\")\n      ((= num 7) \"seven\"\
    )\n      ((= num 8) \"eight\")\n      ((= num 9) \"nine\")))\n  (define (str->list\
    \ str)\n    (define (recur lst)\n      (if (not (null? lst))\n          (append\
    \ (list (car lst)) (recur (cdr lst)))\n          '()))\n    (recur (string-split\
    \ str #\\space)))\n  (string-join (map nums->numeral (sort (map numeral->num (str->list\
    \ numbers)) <)) #\\space))\n  )", "  (string-join (sort (string-split numbers)\
    \ #:key (compose number->string string->number)) \" \"))\n", "  (string-join (sort\
    \ (string-split numbers) #:key (\u03BB (string)\n                            \
    \                        (case string\n                                      \
    \                ('zero 0)\n                                                 \
    \     ('one 1)\n                                                      ('two 2)\n\
    \                                                      ('three 3)\n          \
    \                                            ('four 4)\n                     \
    \                                 ('five 5)\n                                \
    \                      ('six 6)\n                                            \
    \          ('seven 7)\n                                                      ('eight\
    \ 8)\n                                                      ('nine 9))))\n   \
    \            \" \"))\n", "  (define (numeral-to-number numeral)\n    (cond\n \
    \     ((equal? numeral 'zero) 0)\n      ((equal? numeral 'one) 1)\n      ((equal?\
    \ numeral 'two) 2)\n      ((equal? numeral 'three) 3)\n      ((equal? numeral\
    \ 'four) 4)\n      ((equal? numeral 'five) 5)\n      ((equal? numeral 'six) 6)\n\
    \      ((equal? numeral 'seven) 7)\n      ((equal? numeral 'eight) 8)\n      ((equal?\
    \ numeral 'nine) 9)))\n  (string-join\n   (map (lambda (numeral)\n          (number->string\
    \ (numeral-to-number numeral)))\n        (sort (map string->symbol (string-split\
    \ numbers #\\space)) <))\n   #\\space))\n", "  (string-join\n   (sort\n    (string-split\
    \ numbers #\\space)\n    (lambda (n1 n2)\n      (<\n       (match n1\n       \
    \      ['zero 0]\n             ['one 1]\n             ['two 2]\n             ['three\
    \ 3]\n             ['four 4]\n             ['five 5]\n             ['six 6]\n\
    \             ['seven 7]\n             ['eight 8]\n             ['nine 9])\n \
    \      (match n2\n             ['zero 0]\n             ['one 1]\n            \
    \ ['two 2]\n             ['three 3]\n             ['four 4]\n             ['five\
    \ 5]\n             ['six 6]\n             ['seven 7]\n             ['eight 8]\n\
    \             ['nine 9]))))\n   #\\space))\n", "  (define (number-to-int str)\n\
    \    (cond\n      ((string=? str \"zero\") 0)\n      ((string=? str \"one\") 1)\n\
    \      ((string=? str \"two\") 2)\n      ((string=? str \"three\") 3)\n      ((string=?\
    \ str \"four\") 4)\n      ((string=? str \"five\") 5)\n      ((string=? str \"\
    six\") 6)\n      ((string=? str \"seven\") 7)\n      ((string=? str \"eight\"\
    ) 8)\n      ((string=? str \"nine\") 9)))\n  (define (int-to-number n)\n    (cond\n\
    \      ((= n 0) \"zero\")\n      ((= n 1) \"one\")\n      ((= n 2) \"two\")\n\
    \      ((= n 3) \"three\")\n      ((= n 4) \"four\")\n      ((= n 5) \"five\"\
    )\n      ((= n 6) \"six\")\n      ((= n 7) \"seven\")\n      ((= n 8) \"eight\"\
    )\n      ((= n 9) \"nine\")))\n  (define (convert str)\n    (define (spl str)\n\
    \      (regexp-split #rx\" \" str))\n    (map number-to-int (spl str)))\n  (define\
    \ (sorted str)\n    (map int-to-number (sort (convert str) <)))\n  (define (unspl\
    \ list)\n    (string-join list \" \"))\n  (unspl (sorted numbers)))\n", "  (string-join\
    \ (sort (map (lambda (x)\n                            (cond\n                \
    \              [(string=? x \"zero\") 0]\n                              [(string=?\
    \ x \"one\") 1]\n                              [(string=? x \"two\") 2]\n    \
    \                          [(string=? x \"three\") 3]\n                      \
    \        [(string=? x \"four\") 4]\n                              [(string=? x\
    \ \"five\") 5]\n                              [(string=? x \"six\") 6]\n     \
    \                         [(string=? x \"seven\") 7]\n                       \
    \       [(string=? x \"eight\") 8]\n                              [(string=? x\
    \ \"nine\") 9]))\n                          (string-split numbers)) <))\n", " \
    \ (apply string-append (sort (string-split numbers)\n                        \
    \     (lambda (x y) (string<? x y)))))\n", "  (define lookup '(zero one two three\
    \ four five six seven eight nine))\n  (define nsort (sort (string-&gt;list numbers)\
    \ &lt;))\n  (string-&gt;list (list-&gt;string nsort)))\n</code>\nThrew together\
    \ a quick solution based on the comments and answers below. Here is a more refined\
    \ version which does the job in one pass:\n<code>#lang racket", "  (string-join\n\
    \   (sort\n    (string-split numbers)\n    <)\n    \" \"))\n", "  (string-append\
    \ \n    (string-join \n      (sort (string-split numbers) <\n        #:key (lambda\
    \ (x) (string->number (string-append \"0\" x)))) \" \")))\n", "  (string-join\
    \ (sort (string-split numbers #\\space)\n                     string<?\n     \
    \                (\u03BB (x y) (string<? (number->string (string->number x))\n\
    \                                       (number->string (string->number y)))))\n\
    \               #\\space))\n```\n\n```racket\n#lang racket\n", "  (string-join\n\
    \   (sort (string-split numbers #\\space) string<?)))\n", "  (define (sort numbers)\n\
    \    (cond ((empty? numbers) '())\n          ((number? (first numbers)) (list\
    \ (first numbers)))\n          (else (sort (cdr numbers)))))\n  (define (to-string-list\
    \ numbers)\n    (cond ((empty? numbers) '())\n          (else (cons (integer->string\
    \ (first numbers)) (to-string-list (cdr numbers))))))\n  (define (to-numeral-list\
    \ numbers)\n    (cond ((empty? numbers) '())\n          (else (cons (numeral->integer\
    \ (first numbers)) (to-numeral-list (cdr numbers))))))\n  (cond ((equal? numbers\
    \ \"\") \"\")\n        (else (string-join (to-string-list (sort (to-numeral-list\
    \ (string-split numbers #\\space)))) #\\space))))\n", "  (string-join (sort (string-split\
    \ numbers #\\space)\n                     (\u03BB (a b) (< (string->number a)\
    \ (string->number b))))\n               #\\space))\n", "  (list->string (sort\
    \ (map string->number (string-split numbers #\\space)) <)))\n", "  (define (numeral-&gt;number\
    \ numeral)\n    (cond\n      [(equal? numeral 'zero) 0]\n      [(equal? numeral\
    \ 'one) 1]\n      [(equal? numeral 'two) 2]\n      [(equal? numeral 'three) 3]\n\
    \      [(equal? numeral 'four) 4]\n      [(equal? numeral 'five) 5]\n      [(equal?\
    \ numeral 'six) 6]\n      [(equal? numeral 'seven) 7]\n      [(equal? numeral\
    \ 'eight) 8]\n      [(equal? numeral 'nine) 9]))\n  (sort (string-&gt;list numbers)\
    \ &lt; (map numeral-&gt;number (string-&gt;list numbers))))\n", "  (define numbers-list\
    \ (string-&gt;list numbers))\n  (define digits-list (string-&gt;list \"zero one\
    \ two three four five six seven eight nine\"))\n  (apply string-append (sort (list-of-values\
    \ digits-list numbers-list) &lt;)))\n", "  (define (sort_numbers_helper numbers\
    \ result)\n    (cond ((empty? numbers) result)\n          ((member (first numbers)\
    \ '(zero one two three four five six seven eight nine)) (sort_numbers_helper (rest\
    \ numbers) (append result (list (first numbers)))))\n          (else (sort_numbers_helper\
    \ (rest numbers) result))))\n  (string-join (sort sort_numbers_helper (string-split\
    \ numbers \" \")) \" \"))\n", "  (string-join (sort (string-split numbers) string<?)))\n",
  "  (string-join (sort (string-&gt;list numbers) (\u03BB (a b) (string-&lt;? a b)))\
    \ \" \"))\n", "  (define numbers-list (string-&gt;list numbers))\n  (define only-numbers\
    \ (filter number? numbers-list))\n  (define string-only-numbers (list-&gt;string\
    \ only-numbers))\n  (define sorted-only-numbers (string-&gt;list (sort string-only-numbers\
    \ &lt;)))\n  (list-&gt;string sorted-only-numbers))\n</code>\nThe Tests\n<code>#lang\
    \ racket\n", "  (define (int-to-numeral n)\n    (cond [(equal? n 0) \"zero\"]\n\
    \          [(equal? n 1) \"one\"]\n          [(equal? n 2) \"two\"]\n        \
    \  [(equal? n 3) \"three\"]\n          [(equal? n 4) \"four\"]\n          [(equal?\
    \ n 5) \"five\"]\n          [(equal? n 6) \"six\"]\n          [(equal? n 7) \"\
    seven\"]\n          [(equal? n 8) \"eight\"]\n          [(equal? n 9) \"nine\"\
    ]))\n  (define (numeral-to-int numeral)\n    (cond [(equal? numeral \"zero\")\
    \ 0]\n          [(equal? numeral \"one\") 1]\n          [(equal? numeral \"two\"\
    ) 2]\n          [(equal? numeral \"three\") 3]\n          [(equal? numeral \"\
    four\") 4]\n          [(equal? numeral \"five\") 5]\n          [(equal? numeral\
    \ \"six\") 6]\n          [(equal? numeral \"seven\") 7]\n          [(equal? numeral\
    \ \"eight\") 8]\n          [(equal? numeral \"nine\") 9]))\n  (define (sort-key\
    \ string)\n    (numeral-to-int string))\n  (define (sort-strings list)\n    (quicksort\
    \ (lambda (key str)\n                 (&lt; key (sort-key str)))\n           \
    \    list))\n  (for*/list ([numeral (sort-strings (string-&gt;list/c numbers))])\n\
    \    (int-to-numeral (numeral-to-int numeral))))\n</code>\nTo test it:\n<code>&gt;\
    \ (sort_numbers \"three one five\")\n'(\"one\" \"three\" \"five\")\n&gt; (sort_numbers\
    \ \"three one five\")\n'(\"one\" \"three\" \"five\")\n&gt; (sort_numbers \"nine\
    \ two one five zero three four six seven eight\")\n'(\"zero\" \"one\" \"two\"\
    \ \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\")\n</code>\n",
  "  (let* ([numbers-list (string-split numbers)]\n         [sorted-list (list->string\
    \ (quicksort numbers-list to-number))])\n    sorted-list))\n", "  (apply string-append\
    \ (map symbol->string (sort (map string->symbol (regexp-split #rx\" \" numbers))\
    \ <))))\n", "  (string-join (sort (string-split numbers #\\space) string<?)))\n",
  "  (sort (string-&gt;list numbers) &lt; :key read))\n", "  (sort (string-&gt;list\
    \ numbers) &lt; #:key (curry string-&gt;number)))\n</code>\nThis is a solution\
    \ that I came up with. How would you improve it?\nPlease help review. Thanks\n\
    \n\nA:\n\nThe best way to evaluate your code is to use it in a program.  Try the\
    \ following in DrRacket.\n<code>#lang racket\n", "  (string-join\n   (sort (split-string\
    \ numbers)\n         (lambda (a b)\n           (< (length a) (length b))))\n \
    \  \" \"))\n```\n\n```racket\n#lang racket\n", "  (sort (map number->integer (string-split\
    \ numbers #\\space)) <\n        string-join))\n", "  (cond\n    [(empty? numbers)\
    \ (error \"Expected non-empty input\")]\n    [(empty? (rest numbers)) (first numbers)]\n\
    \    [else\n     (sort-numbers-loop numbers '(\"zero\" \"one\" \"two\" \"three\"\
    \ \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"))]))\n", "  (format \"\
    ~a\" (sort string-&lt;? (string-split numbers))))\n", "  (define (numerals)\n\
    \    (list \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\"\
    \ \"eight\" \"nine\"))\n  (apply string-append\n         (map number->string\n\
    \              (sort (map (\u03BB (numeral) (first (member numeral (numerals))))\n\
    \                       (string-split numbers #\\space))\n                   \
    \ <))))\n", "  (regexp-replace* #rx\"zero\" numbers \"0\")\n  (regexp-replace*\
    \ #rx\"one\" numbers \"1\")\n  (regexp-replace* #rx\"two\" numbers \"2\")\n  (regexp-replace*\
    \ #rx\"three\" numbers \"3\")\n  (regexp-replace* #rx\"four\" numbers \"4\")\n\
    \  (regexp-replace* #rx\"five\" numbers \"5\")\n  (regexp-replace* #rx\"six\"\
    \ numbers \"6\")\n  (regexp-replace* #rx\"seven\" numbers \"7\")\n  (regexp-replace*\
    \ #rx\"eight\" numbers \"8\")\n  (regexp-replace* #rx\"nine\" numbers \"9\")\n\
    \  (string-sort (string-split numbers #\\space) (\u03BB (a b) (< (string->number\
    \ a) (string->number b))))\n  (string-join \"\"))\n", "  (display \"input is:\
    \ \")\n  (display numbers)\n  (newline)\n  (define (numberal-sort)\n    (cond\
    \ ((equal? (first numbers) \"zero\") 0)\n          ((equal? (first numbers) \"\
    one\") 1)\n          ((equal? (first numbers) \"two\") 2)\n          ((equal?\
    \ (first numbers) \"three\") 3)\n          ((equal? (first numbers) \"four\")\
    \ 4)\n          ((equal? (first numbers) \"five\") 5)\n          ((equal? (first\
    \ numbers) \"six\") 6)\n          ((equal? (first numbers) \"seven\") 7)\n   \
    \       ((equal? (first numbers) \"eight\") 8)\n          ((equal? (first numbers)\
    \ \"nine\") 9)\n          (else #f)))\n  (display (sort (map numberal-sort numbers)\
    \ <))\n  (newline))\n", "  (string-join (sort (string-split numbers #\\space)\
    \ string<? #:key (compose number->string read-number)) \" \"))\n", "  (let ([dict\
    \ '((zero . 0) (one . 1) (two . 2) (three . 3) (four . 4) (five . 5) (six . 6)\
    \ (seven . 7) (eight . 8) (nine . 9))])\n    (apply string-append\n          \
    \ (map (\u03BB (x) (format \"~a \" x))\n                (map (\u03BB (kv) (car\
    \ kv))\n                     (sort (map (\u03BB (n) (find n dict))\n         \
    \                       (string-split numbers))\n                           (\u03BB\
    \ (a b) (< (cdr a) (cdr b)))))))))\n", "  (string-join\n   (sort\n    (string-split\
    \ numbers)\n    <\n    string<?\n    )\n   \" \"\n   )\n  )", "  (sentence->string\n\
    \   (quicksort (string->list numbers) #:key (\u03BB (char) (assoc (string-&gt;symbol\
    \ (string char)) '((zero . 0) (one . 1) (two . 2) (three . 3) (four . 4) (five\
    \ . 5) (six . 6) (seven . 7) (eight . 8) (nine . 9)))))))\n</code>\n", "  (define\
    \ (numerals str)\n    (cond\n      ((equal? str \"zero\") 0)\n      ((equal? str\
    \ \"one\") 1)\n      ((equal? str \"two\") 2)\n      ((equal? str \"three\") 3)\n\
    \      ((equal? str \"four\") 4)\n      ((equal? str \"five\") 5)\n      ((equal?\
    \ str \"six\") 6)\n      ((equal? str \"seven\") 7)\n      ((equal? str \"eight\"\
    ) 8)\n      ((equal? str \"nine\") 9)))\n  (define (numeral n)\n    (cond\n  \
    \    ((equal? n 0) \"zero\")\n      ((equal? n 1) \"one\")\n      ((equal? n 2)\
    \ \"two\")\n      ((equal? n 3) \"three\")\n      ((equal? n 4) \"four\")\n  \
    \    ((equal? n 5) \"five\")\n      ((equal? n 6) \"six\")\n      ((equal? n 7)\
    \ \"seven\")\n      ((equal? n 8) \"eight\")\n      ((equal? n 9) \"nine\")))\n\
    \  (define (sort-nums nums)\n    (if (null? nums)\n        empty\n        (cons\
    \ (first (sort < nums)) (sort-nums (rest nums)))))\n  (define (solve numbers)\n\
    \    (let* ([numbers (string-split numbers #\\ )]\n           [nums (map numerals\
    \ numbers)])\n      (map numeral (sort-nums nums))))\n  (solve numbers))\n```\n\
    \n```racket\n#lang racket\n", "  (cond ((string-empty? numbers) \"\")\n      \
    \  ((string=? numbers \"zero\") \"zero\")\n        ((string=? numbers \"one\"\
    ) \"one\")\n        ((string=? numbers \"two\") \"two\")\n        ((string=? numbers\
    \ \"three\") \"three\")\n        ((string=? numbers \"four\") \"four\")\n    \
    \    ((string=? numbers \"five\") \"five\")\n        ((string=? numbers \"six\"\
    ) \"six\")\n        ((string=? numbers \"seven\") \"seven\")\n        ((string=?\
    \ numbers \"eight\") \"eight\")\n        ((string=? numbers \"nine\") \"nine\"\
    )\n        ((string=? numbers \"zero one\") \"zero one\")\n        ((string=?\
    \ numbers \"zero two\") \"zero two\")\n        ((string=? numbers \"zero three\"\
    ) \"zero three\")\n        ((string=? numbers \"zero four\") \"zero four\")\n\
    \        ((string=? numbers \"zero five\") \"zero five\")\n        ((string=?\
    \ numbers \"zero six\") \"zero six\")\n        ((string=? numbers \"zero seven\"\
    ) \"zero seven\")\n        ((string=? numbers \"zero eight\") \"zero eight\")\n\
    \        ((string=? numbers \"zero nine\") \"zero nine\")\n        ((string=?\
    \ numbers \"one two\") \"one two\")\n        ((string=? numbers \"one three\"\
    ) \"one three\")\n        ((string=? numbers \"one four\") \"one four\")\n   \
    \     ((string=? numbers \"one five\") \"one five\")\n        ((string=? numbers\
    \ \"one six\") \"one six\")\n        ((string=? numbers \"one seven\") \"one seven\"\
    )\n        ((string=? numbers \"one eight\") \"one eight\")\n        ((string=?\
    \ numbers \"one nine\") \"one nine\")\n        ((string=? numbers \"two three\"\
    ) \"two three\")\n        ((string=? numbers \"two four\") \"two four\")\n   \
    \     ((string=? numbers \"two five\") \"two five\")\n        ((string=? numbers\
    \ \"two six\") \"two six\")\n        ((string=? numbers \"two seven\") \"two seven\"\
    )\n        ((string=? numbers \"two eight\") \"two eight\")\n        ((string=?\
    \ numbers \"two nine\") \"two nine\")\n        ((string=? numbers \"three", " \
    \ (string-join\n   (sort string<?\n         (split-string numbers \" \"))\n  \
    \ \" \"))\n```\n\n```js\nTest.describe(\"Basic tests\",_=>{\nTest.assertEquals(sort_numbers(\"\
    zero one two three four five six seven eight nine\"), \"zero one two three four\
    \ five six seven eight nine\");\nTest.assertEquals(sort_numbers(\"nine two five\
    \ three zero seven four one eight six\"), \"zero one two three four five six seven\
    \ eight nine\");\nTest.assertEquals(sort_numbers(\"nine zero five four seven one\
    \ three two six eight\"), \"zero one two three four five six seven eight nine\"\
    );\nTest.assertEquals(sort_numbers(\"one two three four five six seven eight nine\
    \ zero\"), \"zero one two three four five six seven eight nine\");\nTest.assertEquals(sort_numbers(\"\
    three one five zero nine two four six seven eight\"), \"zero one two three four\
    \ five six seven eight nine\");\nTest.assertEquals(sort_numbers(\"seven eight\
    \ nine one three four five six two zero\"), \"zero one two three four five six\
    \ seven eight nine\");\nTest.assertEquals(sort_numbers(\"nine one eight three\
    \ zero seven four five six two\"), \"zero one two three four five six seven eight\
    \ nine\");\nTest.assertEquals(sort_numbers(\"zero one two three four five six\
    \ seven eight nine\"), \"zero one two three four five six seven eight nine\");\n\
    Test.assertEquals(sort_numbers(\"zero one two three four five six seven eight\
    \ nine\"), \"zero one two three four five six seven eight nine\");\nTest.assertEquals(sort_numbers(\"\
    zero one two three four five six seven eight nine\"), \"zero one two three four\
    \ five six seven eight nine\");\nTest.assertEquals(sort_numbers(\"zero one two\
    \ three four five six seven eight nine\"), \"zero one two three four five six\
    \ seven eight nine\");\nTest.assertEquals(sort_numbers(\"zero one two three four\
    \ five six seven eight nine\"), \"zero one two three four five six seven eight\
    \ nine\");\nTest.assertEquals(sort_numbers(\"zero one two three four five six\
    \ seven eight nine\"), \"zero one two three four five six seven eight nine\");\n\
    Test.assertEquals(sort_n", "  (string-join (quicksort (string-&gt;number-list\
    \ numbers)) \" \"))\n", "  (define (fword x)\n    (cond [(string=? x \"zero\"\
    )  0]\n          [(string=? x \"one\")   1]\n          [(string=? x \"two\") \
    \  2]\n          [(string=? x \"three\") 3]\n          [(string=? x \"four\")\
    \  4]\n          [(string=? x \"five\")  5]\n          [(string=? x \"six\") \
    \  6]\n          [(string=? x \"seven\") 7]\n          [(string=? x \"eight\"\
    ) 8]\n          [(string=? x \"nine\")  9]))\n  (define (fstr x)\n    (cond [(=\
    \ x 0) \"zero\"]\n          [(= x 1) \"one\"]\n          [(= x 2) \"two\"]\n \
    \         [(= x 3) \"three\"]\n          [(= x 4) \"four\"]\n          [(= x 5)\
    \ \"five\"]\n          [(= x 6) \"six\"]\n          [(= x 7) \"seven\"]\n    \
    \      [(= x 8) \"eight\"]\n          [(= x 9) \"nine\"]))\n  (for/fold ([sorted\
    \ (in-list)])\n            ([x (in-list (string-split numbers))])\n          \
    \  (sorted (append (list (fstr (fword x))) sorted))))\n```\n\n### find_next_square\
    \ (6 kyu)\n\n```racket\n#lang racket\n", "  (sort (string-split numbers) (\u03BB\
    \ (a b) (< (number-of a) (number-of b)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
