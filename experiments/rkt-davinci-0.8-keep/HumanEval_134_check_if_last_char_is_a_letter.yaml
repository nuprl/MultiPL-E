name: HumanEval_134_check_if_last_char_is_a_letter
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns True if the last character\n\
  ;; of a given string is an alphabetical character and is not\n;; a part of a word,\
  \ and False otherwise.\n;; Note: \"word\" is a group of characters separated by\
  \ space.\n;; Examples:\n;; check_if_last_char_is_a_letter(\"apple pie\") \u279E\
  \ False\n;; check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n;; check_if_last_char_is_a_letter(\"\
  apple pi e \") \u279E False\n;; check_if_last_char_is_a_letter(\"\") \u279E False\n\
  (define (check_if_last_char_is_a_letter txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n\
  \    (check-equal? (candidate \"apple\") #f)\n    (check-equal? (candidate \"apple\
  \ pi e\") #t)\n    (check-equal? (candidate \"eeeee\") #f)\n    (check-equal? (candidate\
  \ \"A\") #t)\n    (check-equal? (candidate \"Pumpkin pie \") #f)\n    (check-equal?\
  \ (candidate \"Pumpkin pie 1\") #f)\n    (check-equal? (candidate \"\") #f)\n  \
  \  (check-equal? (candidate \"eeeee e \") #f)\n    (check-equal? (candidate \"apple\
  \ pie\") #f)\n    (check-equal? (candidate \"apple pi e \") #f)\n))\n\n(test-humaneval)"
completions: ["  (let ((chars (string->list txt)))\n    (let* ((txt-len (length chars))\n\
    \           (last-char (list-ref chars (- txt-len 1))))\n      (and (char-alphabetic?\
    \ last-char)\n           (not (list-ref chars (- txt-len 2)))\n           (not\
    \ (list-ref chars (- txt-len 3)))))))\n", "  (and (not (empty? txt))\n       (is-a-letter?\
    \ (last txt))\n       (or (empty? (rest txt))\n           (space? (last (rest\
    \ txt))))))\n", "  (if (not (string=? \"\" txt))\n      (if (not (regexp-match\
    \ \"\\\\w$\" txt)) #t #f)\n      #f))\n", "  (and \n   (not (empty? txt))\n  \
    \ (not (letter? (last-char txt)))\n   (alphabetic? (last-char txt))))\n", "  (and\
    \ (not (empty? txt))\n       (char-alphabetic? (last-char txt))\n       (or (empty?\
    \ (rest txt))\n           (not (char-alphabetic? (first-char (rest txt)))))))\n",
  "  (if (string=? \"\" txt)\n      #f\n      (if (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n               (not (equal? #\\ (string-ref\
    \ txt (- (string-length txt) 2)))))\n          #t\n          #f)))", "  (and (not\
    \ (empty? txt))\n       (char-alphabetic? (last-char txt))\n       (or (empty?\
    \ (last-char (string-trim-both txt)))\n           (not (char-alphabetic? (last-char\
    \ (string-trim-both txt)))))))\n", "  (cond ((or (string=? txt \"\") (string=?\
    \ (string-ref txt (- (string-length txt) 1)) \" \")) #f)\n        ((string-contains?\
    \ \"abcdefghijklmnopqrstuvwxyz\" (string-ref txt (- (string-length txt) 1))) #t)\n\
    \        (else #f)))\n", "  (if (empty? txt)\n      false\n      (let ([last (last\
    \ txt)])\n        (if (char-alphabetic? last)\n            (if (null? (cdr (member\
    \ (last txt) (string->list txt))))\n                true\n                false)\n\
    \            false))))\n", "  (let ((chars (list->string (reverse (string->list\
    \ txt)))))\n    (let ((first-char (substring chars 0 1)))\n      (let ((sub-txt\
    \ (substring chars 1)))\n        (or (string-contains? sub-txt \" \")\n      \
    \      (string-empty? first-char))))))\n", "  (let* ([words (string-split txt\
    \ #\\ )]\n         [idx (sub1 (length words))]\n         [last-word (list-ref\
    \ words idx)])\n    (char-alphabetic? (string-ref last-word (sub1 (string-length\
    \ last-word))))))\n", "  (and (empty? txt)\n       (character-upcase? (string-ref\
    \ txt (- (string-length txt) 1)))\n       (not (member (string-ref txt (- (string-length\
    \ txt) 1)) \" ,.!?\"))))\n", "  (cond\n    [(string=? txt \"\") #f]\n    [(char-alphabetic?\
    \ (substring txt (- (string-length txt) 1) (string-length txt))) #t]\n    [else\
    \ #f]))\n", "  (if (or (empty? txt)\n          (string-contains? txt \" \"))\n\
    \      #f\n      (char-alphabetic? (string-ref txt (- (string-length txt) 1)))))",
  "  (if (zero? (length txt))\n      #f\n      (if (not (string-contains-word? txt\
    \ (substring txt (- (length txt) 1))))\n          (char-alphabetic? (string-ref\
    \ txt (- (length txt) 1)))\n          #f)))\n", "  (cond\n    [(string-empty?\
    \ txt) false]\n    [(char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \     (char-alphabetic? (string-ref txt (- (string-length txt) 2)))]\n    [else\
    \ false]))\n", "  (cond [(string-empty? txt) #f]\n        [(not (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))) #f]\n        [(not (string-empty?\
    \ (string-trim txt))) #f]\n        [else #t]))\n", "  (and (list? (last txt))\
    \ (char-alphabetic? (last txt))))\n", "  (define len (string-length txt))\n  (define\
    \ last-char (string-ref txt (- len 1)))\n  (if (and (string-contains \"a-zA-Z\"\
    \ last-char) (string-contains \" \" last-char))\n      true\n      false))\n",
  "  (let ([lastchar (substring txt (sub1 (string-length txt)) (string-length txt))])\n\
    \    (string-ci=? lastchar \"e\")))\n", "  (string-alphabetic? (substring txt\
    \ (sub1 (string-length txt)))))\n", "  (regexp-match? #rx\"([a-z]$)\" txt))\n",
  "  (and\n   (string-alphabetic? (string-ref txt (- (string-length txt) 1)))\n  \
    \ (not (string-alphabetic? (string-ref txt (- (string-length txt) 2))))))\n",
  "  (let* ([chars (string->list txt)]\n         [is-letter (char-alphabetic? (last\
    \ chars))])\n    (if is-letter\n        (find (compose char-alphabetic? second)\
    \ (cdr (segment (lambda (x) (= (string-ref x 0) #\\space)) (reverse chars))))\n\
    \        #f)))\n</code>\n", "  (define len (string-length txt))\n  (cond ((or\
    \ (= 0 len) (= 32 (string-ref txt (- len 1)))) false)\n        ((char-alphabetic?\
    \ (string-ref txt (- len 1))) true)\n        (else false)))\n", "  (let ([lst\
    \ (string-split txt)])\n    (not (or (null? lst) (not (char-alphabetic? (string-ref\
    \ (car (last lst)) (sub1 (string-length (car (last lst)))))))))))\n</code>\n",
  "  (let ([lst (string-&gt;list txt)])\n    (define (is-a-letter ch)\n      (eq?\
    \ (char-alphabetic? ch) #t))\n    (cond [(empty? lst) #f]\n          [(empty?\
    \ (rest lst)) #f]\n          [(is-a-letter (first lst)) #f]\n          [(is-a-letter\
    \ (second lst)) #f]\n          [(eq? (char-whitespace? (second lst)) #t)\n   \
    \        (and (is-a-letter (first lst))\n                (not (is-a-letter (second\
    \ lst))))]\n          [else #f])))\n</code>\nI wonder if there is a more elegant\
    \ way to do this? It'd be nice to not have to hardcode a check that the string\
    \ isn't empty.\n\n\nA:\n\nThis is a bit more elegant\n<code>(define (check_if_last_char_is_a_letter\
    \ txt)\n  (cond [(empty? txt) #f]\n        [(char-whitespace? (string-ref txt\
    \ -1)) #f]\n        [(not (char-whitespace? (string-ref txt -2))) #f]\n      \
    \  [else #t]))\n</code>\nbut you have a bug:\n<code>(check_if_last_char_is_a_letter\
    \ \"apple pi e \")\n=&gt; #t\n</code>\n", "  (and (alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n       (not (alphabetic? (string-ref txt (- (string-length\
    \ txt) 2))))))\n", "  (let ((len (string-length txt)))\n    (and (char-alphabetic?\
    \ (string-ref txt (- len 1)))\n         (not (char-alphabetic? (string-ref txt\
    \ (- len 2)))))))\n", "  (cond\n    [(string=? txt \"\") false]\n    [(string=?\
    \ txt \" \") false]\n    [(char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1))) true]\n    [else false]))\n", "  (cond [(empty? txt) false]\n    \
    \    [(empty? (rest txt)) false]\n        [(alphabetic? (last txt))\n        \
    \ (cond\n           [(or (alphabetic? (rest (last txt)))\n                (equal?\
    \ (rest (last txt)) \" \")) false]\n           [else true])]\n        [else false]))\n",
  "  (and (char-alphabetic? (last-char txt))\n       (not (char-alphabetic? (char-after\
    \ (string-&gt;symbol txt -1))))))\n</code>\nAnd here is the error:\n<code>string-&gt;symbol:\
    \ expects type &lt;number&gt; as 1st argument, given: -1; other arguments were:\
    \ \"apple pie\"\n</code>\nI can't seem to find the cause of this error, it seems\
    \ to be\nin the last line.\nI have checked the racket documentation, but I have\
    \ to admit\nI don't understand it all.\n\n\nA:\n\nYou seem to have all the right\
    \ ideas. The problem is just that <code>char-after</code> expects a position,\
    \ not a symbol.\n<code>(char-alphabetic? (char-after (string-&gt;symbol txt -1)))\n\
    </code>\nis trying to find the character after the symbol <code>-1</code>, and\
    \ that is where the error is coming from. You probably want:\n<code>(char-alphabetic?\
    \ (char-after txt (- (string-length txt) 1)))\n</code>\nwhich finds the character\
    \ after the symbol <code>txt</code> at position <code>(- (string-length txt) 1)</code>,\
    \ which is what <code>string-&gt;symbol</code> would have done if it had accepted\
    \ that argument in the first place.\n", "  (if (or (string=? txt \"\")\n     \
    \     (= (string-length txt) 1))\n      #f\n      (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))))\n</code>\nIt feels a bit messy to me, but\
    \ I can't find a more elegant solution.\nIs there a more elegant way to express\
    \ this function?\n\n\nA:\n\nThe main problem I see is that you're reinventing\
    \ the wheel in a very inefficient way: you're writing your own <code>string-ref</code>-style\
    \ procedure to extract the last character of a string, and you're doing it in\
    \ a not very efficient way.\nInstead of <code>(string-ref txt (- (string-length\
    \ txt) 1))</code>, you could simply use <code>(string-ref txt (- (string-length\
    \ txt) 2))</code> (because Racket strings are indexed from 0).\n<code>(define\
    \ (check_if_last_char_is_a_letter txt)\n  (if (or (string=? txt \"\")\n      \
    \    (= (string-length txt) 1))\n      #f\n      (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))))\n</code>\nOr, even better, you could use one\
    \ of the standard Racket string library procedures to extract a substring starting\
    \ at a given index and ending at a given index:\n<code>(define (check_if_last_char_is_a_letter\
    \ txt)\n  (if (or (string=? txt \"\")\n          (= (string-length txt) 1))\n\
    \      #f\n      (char-alphabetic? (substring txt (- (string-length txt) 2) (-\
    \ (string-length txt) 1)))))\n</code>\nOr, even better, you could just use <code>string-take</code>\
    \ to extract the last character of a string:\n<code>(define (check_if_last_char_is_a_letter\
    \ txt)\n  (if (or (string=? txt \"\")\n          (= (string-length txt) 1))\n\
    \      #f\n      (char-alphabetic? (string-take txt", "  (cond\n    [(empty? txt)\
    \ false]\n    [(regexp-match #rx\"[a-z]\" (string-trim txt)) true]\n    [else\
    \ false]))\n", "  (cond\n    [(= (length txt) 0) False]\n    [(and (string=? (substring\
    \ txt (- (length txt) 1) (length txt)) \" \")\n          (not (not-all-char-in-str?\
    \ txt \" \"))) False]\n    [(char-alphabetic? (string-ref txt (- (length txt)\
    \ 1))) True]\n    [else False]))\n", "  (and (not (empty? txt))\n       (or (char-alphabetic?\
    \ (last-char txt))\n           (check_if_last_char_is_a_letter (substring txt\
    \ 0 (- (string-length txt) 1))))))", "  (define (not-word-letter? c)\n    (and\
    \ (char-alphabetic? c)\n         (not (string-contains-char? \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \ c))))\n  (not-word-letter? (string-ref txt (- (string-length txt) 1))))\n",
  "  (if (string=? \"\" txt)\n      #f\n      (if (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n          (if (and (string-contains txt #\\ )\n\
    \                   (char-alphabetic? (string-ref txt (- (string-length txt) 2))))\n\
    \              #f\n              #t)\n          #f)))\n", "  (define (is-alpha\
    \ char)\n    (and (&gt;= char #\\a) (&lt;= char #\\z)))\n  (define (is-alpha?\
    \ char)\n    (not (= #\\space char)))\n  (and (not (empty? txt)) (is-alpha? (last\
    \ txt)) (is-alpha (last txt))))\n", "  (if (empty? txt)\n      #f\n      (if (not\
    \ (char-alphabetic? (last-char txt)))\n          #f\n          (if (not (char-whitespace?\
    \ (last-char (butlast txt))))\n              #f\n              #t))))", "  (cond\n\
    \    [(empty? txt) false]\n    [(in-between? (last txt) '#\\a '#\\z) true]\n \
    \   [else false]))\n</code>\nFor the following input:\n<code>(check_if_last_char_is_a_letter\
    \ \"apple pie\") \n</code>\nit returns <code>False</code> as expected.\nHowever,\
    \ when I change the input to \n<code>(check_if_last_char_is_a_letter \"apple pi\
    \ e\")\n</code>\nit returns <code>False</code> again, which is not what I expected,\
    \ since the last character is an alphabetical character.\nI also tried the following\
    \ \n<code>(in-between? (last \"apple pi e\") '#\\a '#\\z)\n</code>\nand it returns\
    \ <code>#t</code>.\nCan someone please explain why the first one doesn't work?\n\
    Thank you.\n\n\nA:\n\nAs @tfb has explained, the issue is that <code>last</code>\
    \ returns a string, not a character.\nTo get the last character, write <code>(last\
    \ txt)</code> instead.\n", "  (if (or (null? txt) (= 1 (count-words txt)))\n \
    \     #f\n      (string-contains-word? (car (last-word txt)) #:char (string-ref\
    \ txt (sub1 (string-length txt)))))\n  )\n</code>\nThe <code>string-contains-word?</code>\
    \ function is a built-in Racket function, and the <code>last-word</code> function\
    \ is:\n<code>(define (last-word txt)\n  (map string-upcase (regexp-match* #rx\"\
    \\w+$\" txt))\n)\n</code>\nHere's a test run:\n<code>&gt; (check_if_last_char_is_a_letter\
    \ \"apple pie\")", "  (cond [(empty? txt) false]\n        [(member (last txt)\
    \ \"abcdefghijklmnopqrstuvwxyz\") true]\n        [else false]))\n</code>\n", " \
    \ (cond\n    [(not (string? txt)) (error 'check_if_last_char_is_a_letter \"need\
    \ a string\")]\n    [(empty? txt) #f]\n    [(char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n     #t]\n    [else #f]))", "  (and (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n       (not (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2))))))\n", "  (if (string=? txt \"\")\n      false\n\
    \      (let ((txt2 (string-trim txt)))\n        (if (string=? txt2 \"\")\n   \
    \         false\n            (if (string-contains txt2 #\\ )\n               \
    \ (let ((txt3 (string-before txt2 #\\ )))\n                  (check_if_last_char_is_a_letter\
    \ txt3))\n                (if (char-alphabetic? (string-ref txt2 (- (string-length\
    \ txt2) 1)))\n                    true\n                    false))))))", "  (and\
    \ (string-alphabetic? (string-ref txt (- (string-length txt) 1)))\n       (not\
    \ (string-alphabetic? (string-ref txt (- (string-length txt) 2))))))\n", "  (define\
    \ (is-alpha? ch)\n    (and (char-alphabetic? ch)\n         (not (char-whitespace?\
    \ ch))))\n  (is-alpha? (string-ref txt (- (string-length txt) 1))))\n", "  (if\
    \ (string=? \"\" txt)\n      #f\n      (if (and (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n               (not (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))))\n          #t\n          #f)))\n</code>\n\
    The test cases I have are not giving the expected result, what am I doing wrong?\n\
    \n\nA:\n\nThis is how I would write this function:\n<code>(define (check-if-last-char-is-a-letter\
    \ txt)\n  (and (not (string=? \"\" txt))\n       (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n       (not (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 2))))))\n</code>\n", "  (let ((txt (regexp-replace #rx\"\
    (^\\\\s*)|(\\\\s*$)\" txt \"\")))\n    (let ((last-char (string-length txt)))\n\
    \      (if (= 0 last-char)\n          false\n          (let ((alpha? (regexp-match\
    \ #rx\"\\\\w\" (string-append \" \" (string-take txt last-char)))))\n        \
    \    (if (= 1 alpha?)\n                false\n                true\n         \
    \       )\n            )\n          )\n      )\n    )\n  )\n", "  (regexp-match?\
    \ #rx\"[a-zA-Z]$\" txt))\n", "  (if (empty? txt)\n      false\n      (let ([len\
    \ (string-length txt)])\n        (if (not (= (string-ref txt (- len 1)) (string-ref\
    \ txt (- len 2))))\n            (and (alphabetic? (string-ref txt (- len 1)))\n\
    \                 (or (empty? (regexp-match #rx\"[a-z]\" (substring txt 0 (- len\
    \ 1))))\n                     (and (= (string-ref txt (- len 1)) #\\ )\n     \
    \                     (not (empty? (regexp-match #rx\"[a-z]\" (substring txt 0\
    \ (- len 2))))))))\n            false))))\n", "  (and (string-contains txt (regexp\
    \ #\"[a-z]\"))\n       (not (string-contains txt (regexp #\"[a-z]\\s\")))))\n",
  "  (and (not (empty? txt))\n       (regexp-match? #rx\"[a-zA-Z]\" (string-trim txt))))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char txt))\n\
    \          (char-whitespace? (first-char (substring txt 0 -1)))) #t]\n    [else\
    \ #f]))\n", "  (and (not (empty? txt))\n       (string-alphabetic? (string-last\
    \ txt))\n       (not (string-whitespace? (string-last txt)))))\n", "  (cond [(or\
    \ (= (string-length txt) 0) (= (string-length txt) 1)) #f]\n        [(or (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1))) (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 2)))) #f]\n        [else #t]))\n", "  (if (string=? txt\
    \ \"\")\n      (display #f)\n      (cond\n        [(string-search-backward\n \
    \          (regexp \"[a-zA-Z]\") txt\n           (sub1 (string-length txt)))\n\
    \         (display #t)]\n        [else (display #f)])))\n</code>\nHowever, it\
    \ shows an error like this:\n<code>string-search-backward: expected a regexp,\
    \ given \"[a-zA-Z]\"\n</code>\nAny suggestions? Thank you!\n\n\nA:\n\nThe function\
    \ <code>string-search-backward</code> expects a regexp, but you're providing a\
    \ string, so you can use <code>regexp</code> to create a regexp from the string.\n\
    <code>(define (check_if_last_char_is_a_letter txt)\n  (if (string=? txt \"\")\n\
    \      (display #f)\n      (cond\n        [(string-search-backward\n         \
    \  (regexp \"[a-zA-Z]\") txt\n           (sub1 (string-length txt)))\n       \
    \  (display #t)]\n        [else (display #f)])))\n</code>\nAnother way is to use\
    \ <code>regexp-match-positions</code> which returns a list of the matching positions,\
    \ and if it's not empty it means it matched, which is shorter and clearer:\n<code>(define\
    \ (check_if_last_char_is_a_letter txt)\n  (not (empty? (regexp-match-positions\
    \ \"[a-zA-Z]\" txt))))\n</code>\nThe <code>not</code> is there because <code>regexp-match-positions</code>\
    \ returns an empty list when it doesn't match, so <code>not</code> will invert\
    \ that result.\n", "  (define (last-char txt)\n    (string-ref txt (- (string-length\
    \ txt) 1)))\n  (define (is-alpha? c)\n    (or (char-alphabetic? c) (char-numeric?\
    \ c)))\n  (cond\n    [(string=? txt \"\") false]\n    [(string=? (string-ref txt\
    \ (- (string-length txt) 1)) \" \") false]\n    [(is-alpha? (last-char txt)) true]\n\
    \    [else false]))\n</code>\n", "  (cond\n    ((eq? (string-length txt) 0) #f)\n\
    \    ((> (string-length txt) 0) (let ([last-chr (substring txt -1)])\n       \
    \                         (if (is-a-letter? last-chr)\n                      \
    \              (if (is-space? (substring txt -2 -1))\n                       \
    \                 #t\n                                        #f)\n          \
    \                          #f)))\n    (#t #f)))\n", "  (define (letter? c)\n \
    \   (and (char-alphabetic? c)\n         (not (char-whitespace? c))))\n  (and (letter?\
    \ (string-ref txt (- (string-length txt) 1)))\n       (not (string-ref txt (-\
    \ (string-length txt) 2)))\n       (char-whitespace? (string-ref txt (- (string-length\
    \ txt) 2)))))\n", "  (and (> (string-length txt) 0)\n       (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n       (or (string-null? (regexp-match\
    \ #rx\"\\s\" txt))\n           (string-null? (regexp-match #rx\"\\s\" (substring\
    \ txt (- (string-length txt) 2)))))))\n", "  (if (empty? txt)\n      false\n \
    \     (let ([x (string-&gt;list txt)])\n        (if (char-alphabetic? (last x))\n\
    \            (if (= (length x) 1)\n                true\n                (if (char-alphabetic?\
    \ (char-downcase (last (butlast x))))\n                    false\n           \
    \         true))\n            false))))\n", '  (regexp-match? #rx"\w$" txt))',
  "  (if (string=? txt \"\")\n      #f\n      (if (alphabetic? (string-ref txt (-\
    \ (string-length txt) 1)))\n          (if (string=? (string-ref txt (- (string-length\
    \ txt) 2)) \" \")\n              #t\n              #f)\n          #f)))\n", " \
    \ (cond\n    [(empty? txt) false]\n    [(char-alphabetic? (last-char txt))\n \
    \    (cond\n       [(<= #\\space (char-downcase (last-char txt))) false]\n   \
    \    [else true])]\n    [else false]))\n", "  (let ((len (string-length txt)))\n\
    \    (and\n     (> len 0)\n     (char-alphabetic? (string-ref txt (- len 1)))\n\
    \     (not (char-whitespace? (string-ref txt (- len 1)))))))", "  (if (string=?\
    \ txt \"\")\n      #f\n      (string-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))))\n", "  (not (empty? txt)))\n", "  (let ([len (string-length txt)])\n\
    \    (cond\n      [(= len 0) #f]\n      [(string-titlecase (substring txt (- len\
    \ 1)))\n       (regexp-match? (regexp \"[A-Z]+\") (substring txt (- len 2)))]\n\
    \      [else #f])))\n", "  (if (string=? \"\" txt)\n      #f\n      (if (not (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1))))\n          #f\n          (let ((last-letter\
    \ (string-ref txt (- (string-length txt) 1))))\n            (for ([ch (in-string\
    \ txt)])\n              (if (char-alphabetic? ch)\n                  (if (char=?\
    \ ch last-letter)\n                      #t\n                      #f)\n     \
    \             #f))\n            #f))\n      )\n  )\n", "  (cond\n    [(empty?\
    \ txt) false]\n    [(alphabetic? (last-char txt)) #t]\n    [else false]))\n</code>\n\
    And here is the Racket solution:\n<code>#lang racket\n", "  (define (is-letter?\
    \ c)\n    (and (char-alphabetic? c)\n         (not (char-whitespace? c))))\n \
    \ (is-letter? (string-ref txt (- (string-length txt) 1))))", "  (match (regexp-match\
    \ #rx\"\\\\w*$\" txt)\n    [\"\" #f]\n    [_ #t]))\n", "  (let ((len (string-length\
    \ txt)))\n    (and (< 0 len)\n         (regexp-match #rx\"[[:alpha:]]\" (substring\
    \ txt (- len 1) len))\n         (regexp-match #rx\"\\s$\" txt))))\n", "  (if (or\
    \ (empty? txt) (string=? txt \" \"))\n      false\n      (if (and (string-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n              (string=? (string-ref\
    \ txt (- (string-length txt) 2)) \" \"))\n          true\n          false)))\n",
  "  (define (last-char txt)\n    (substring txt (- (string-length txt) 1) (string-length\
    \ txt)))\n  (and (string? txt) (char-alphabetic? (string-&gt;char (last-char txt)))\
    \ (not (in-string? (last-char txt) \" aeiou \"))))\n", "  (cond\n    [(empty?\
    \ txt) #f]\n    [(alphabetic? (last txt)) #t]\n    [else #f]))\n", "  (and\n \
    \  (not (= (string-length txt) 0))\n   (or\n    (and (= (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1))) #t) (= (char-whitespace? (string-ref txt (-\
    \ (string-length txt) 2))) #t))\n    (and (= (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1))) #t) (= (string-length txt) 1)))))", "  (cond\n \
    \   [(string-empty? txt) false]\n    [(string-ci=? txt \"\") false]\n    [(string-empty?\
    \ (regexp-replace* #rx\"\\s+$\" txt \"\")) false]\n    [(string-empty? (regexp-replace*\
    \ #rx\"\\s+\" txt \"\")) false]\n    [(string-ci=? (regexp-replace* #rx\"\\s+$\"\
    \ txt \"\")\n                  (regexp-replace* #rx\"\\s+\" txt \"\")) false]\n\
    \    [else (not (string-ci=? (regexp-replace* #rx\"\\s+$\" txt \"\")\n       \
    \                     (regexp-replace* #rx\"\\s+\" txt \"\")))]))\n</code>\nI\
    \ tried to run it from <code>drracket</code> and I got this error:\n<code>check_if_last_char_is_a_letter:\
    \ expects argument of type &lt;string&gt;; given #&lt;syntax:23:5&gt;\n</code>\n\
    Would you please help me to resolve this issue and make this code working?\nI\
    \ would be glad if you could also provide more efficient solution.\n\n\nA:\n\n\
    The problem is that <code>txt</code> is not a string but a symbol. This can be\
    \ fixed by writing a string instead of a symbol.\n<code>(define (check_if_last_char_is_a_letter\
    \ txt)\n  (cond\n    [(string-empty? txt) false]\n    [(string-ci=? txt \"\")\
    \ false]\n    [(string-empty? (regexp-replace* #rx\"\\s+$\" txt \"\")) false]\n\
    \    [(string-empty? (regexp-replace* #rx\"\\s+\" txt \"\")) false]\n    [(string-ci=?\
    \ (regexp-replace* #rx\"\\s+$\" txt \"\")\n                  (regexp-replace*\
    \ #rx\"\\s+\" txt \"\")) false]\n    [else (not (string-ci=? (regexp-replace*\
    \ #rx\"\\s+$\"", "  (not (string-empty? txt))\n  (string-ref txt (- (string-length\
    \ txt) 1))\n  (or (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \      (char-numeric? (string-ref txt (- (string-length txt) 1)))))\n", "  (or\
    \ (and (= 0 (string-length txt))\n           #f)\n      (and (not (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt)))))\n           (not (string-ref txt\
    \ (sub1 (string-length txt)))))\n      (and (char-alphabetic? (string-ref txt\
    \ (sub1 (string-length txt))))\n           (not (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2)))))))\n", "  (define (check_if_last_char_is_a_letter-iter\
    \ txt-chars)\n    (if (empty? txt-chars)\n        false\n        (and (char-alphabetic?\
    \ (last txt-chars))\n             (not (member? (last txt-chars) (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\")))\n             (not (member? (last txt-chars)\
    \ (string->list \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))\n             (not (char-whitespace?\
    \ (last txt-chars)))\n             (check_if_last_char_is_a_letter-iter (butlast\
    \ txt-chars)))))\n  (check_if_last_char_is_a_letter-iter (string->list txt)))\n\
    </code>\nIs this a good or a bad code? What can be improved?\n\n\nA:\n\nI think\
    \ the best way to improve your code is to learn the standard library. Racket is\
    \ designed to make you productive, and it does that by packing a ton of functionality\
    \ into the standard library. You should learn as much of it as you can.\n<code>#lang\
    \ racket\n", "  (define the-last-char (string-ref txt (- (string-length txt) 1)))\n\
    \  (define word-char? (char-alphabetic? the-last-char))\n  (define word-space?\
    \ (char=? the-last-char #\\space))\n  (not (or word-char? word-space?)))\n", " \
    \ (and (string-&gt;list txt)\n       (not (equal? \"\" (substring txt -1)))\n\
    \       (char-alphabetic? (string-&gt;list txt))))\n</code>\nIt should return\
    \ true for the first case and false for the second, but it returns false for both.\n\
    \n\nA:\n\nYou can't use <code>string-&gt;list</code> to get the last character\
    \ of a string, because it returns a list of characters:\n<code>(string-&gt;list\
    \ \"hello\")\n=&gt; '(#\\h #\\e #\\l #\\l #\\o)\n</code>\nThe last character of\
    \ a string is the last character of that string, which has the index <code>-1</code>\
    \ (start counting from the end):\n<code>(string-ref \"hello\" -1)\n=&gt; #\\o\n\
    </code>\nThen you need to define a predicate that returns <code>#t</code> when\
    \ a given character is an alphabetical character:\n<code>(char-alphabetic? #\\\
    o)\n=&gt; #t\n</code>\nFinally you need to apply the predicate to the last character\
    \ of the string, with <code>apply</code>:\n<code>(apply char-alphabetic? (string-ref\
    \ \"hello\" -1))\n=&gt; #t\n</code>\n", '  (regexp-match #rx"^.*[^\s][^\s]$" txt))',
  "  (string-contains-char-set? txt \"a-zA-Z\")\n  )", "  (let ([last-char (last-char\
    \ txt)])\n    (and (char-alphabetic? last-char)\n         (not (char-whitespace?\
    \ last-char)))))\n</code>\n", "  (if (empty? txt)\n      #f\n      (or\n     \
    \  (and\n        (char-alphabetic? (last-char txt))\n        (not (char-alphabetic?\
    \ (last-char (string-drop-right txt 1)))))\n       (and\n        (not (char-alphabetic?\
    \ (last-char txt)))\n        (check_if_last_char_is_a_letter (string-drop-right\
    \ txt 1))))))\n", "  (or (= (string-length txt) 0)\n      (and (is-char-whitespace?\
    \ (string-ref txt (- (string-length txt) 1)))\n           (check_if_last_char_is_a_letter\
    \ (substring txt 0 (- (string-length txt) 1))))\n      (and (is-char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n           (not (is-char-whitespace?\
    \ (string-ref txt (- (string-length txt) 2)))))))", "  (cond\n    [(not (string?\
    \ txt)) (error 'check_if_last_char_is_a_letter \"txt is not a string\")]\n   \
    \ [(string=? txt \"\") #f]\n    [(regexp-match? #rx\"\\s*[a-zA-Z]\\s*$\" txt)\
    \ #t]\n    [else #f]))\n", "  (string-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1))))\n", "  (let* ((len (string-length txt))\n         (last-char (substring\
    \ txt (- len 1) len)))\n    (and (alphabetic? last-char)\n         (not (regexp-match\
    \ #rx\" \" txt)))))\n", "  (define (lastchar txt)\n    (string-ref txt (- (string-length\
    \ txt) 1)))\n  (define (only-letters txt)\n    (string-ref txt (- (string-length\
    \ txt) 2)))\n  (define (is-alpha? c)\n    (regexp-match #rx\"[a-zA-Z]\" c))\n\
    \  (and (= 1 (string-length txt)) (is-alpha? (lastchar txt)))\n  (and (> (string-length\
    \ txt) 1)\n       (is-alpha? (lastchar txt))\n       (is-alpha? (only-letters\
    \ txt))))\n", "  (define alnum? (lambda (c) (or (char-alphabetic? c) (char-numeric?\
    \ c))))\n  (let lp ((rest txt) (prev #\\space))\n    (if (null? rest) #f\n   \
    \     (let ((c (car rest)))\n          (if (not (alnum? c))\n              (if\
    \ (alnum? prev) #t\n                  (lp (cdr rest) #\\space))\n            \
    \  (lp (cdr rest) c))))))\n", "  (define (is-alpha x)\n    (char-alphabetic? x))\n\
    \  (and (string? txt)\n       (not (null? txt))\n       (not (string-empty? txt))\n\
    \       (is-alpha (string-ref txt (- (string-length txt) 1)))\n       (not (string-index-right\
    \ txt #\\space (- (string-length txt) 1)))))", "  (if (or (string=? txt \"\")\
    \ (string=? txt \" \"))\n      #f\n      (let ([ch (last-char txt)])\n       \
    \ (and (char-alphabetic? ch)\n             (and (string=? txt (list->string (reverse\
    \ (list ch))))\n                  (not (char-whitespace? ch)))))))\n", "  (and\
    \ (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n       (not (member\
    \ (string-ref txt (- (string-length txt) 1)) \" ,.\"))))", "  (if (empty? txt)\n\
    \      false\n      (if (char-alphabetic? (last-char txt))\n          (if (char-alphabetic?\
    \ (last-char (string-copy txt -2)))\n              false\n              true)\n\
    \          false)))", "  (let ((last-char (last-char txt)))\n    (and (char-alphabetic?\
    \ last-char)\n         (not (char-whitespace? last-char)))))\n", "  (if (empty?\
    \ txt)\n      false\n      (if (equal? (substring txt (sub1 (string-length txt))\
    \ (string-length txt)) \" \")\n          false\n          (if (char-alphabetic?\
    \ (substring txt (sub1 (string-length txt)) (string-length txt)))\n          \
    \    true\n              false))))\n", "  (if (empty? txt)\n      false\n    \
    \  (match txt\n             [($ (? string? str))\n              (let ((last-char\
    \ (last-char str)))\n                (or (char-alphabetic? last-char)\n      \
    \              (char-numeric? last-char)\n                    (char=? last-char\
    \ #\\_)))]\n             [_ false])))\n", "  (and (not (null? txt))\n       (and\
    \ (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n            (not\
    \ (string-contains (substring txt 0 (- (string-length txt) 1)) \" \")))))\n</code>\n\
    Is there a way to make it more readable? How can this be optimized?\n\n\nA:\n\n\
    Readability\nThe main issue I have with the readability of your code is the overuse\
    \ of parentheses. While this is a matter of style, I would argue that in Racket\
    \ (and in Scheme in general) the parentheses actually help make code more readable,\
    \ as they show the structure of the expression. However, they shouldn't be used\
    \ excessively, otherwise they will start to become a nuisance. For example, the\
    \ following expression is difficult to parse visually:\n<code>(and (not (null?\
    \ txt))\n     (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \          (not (string-contains (substring txt 0 (- (string-length txt) 1)) \"\
    \ \"))))\n</code>\nWhile the one below is much easier to understand:\n<code>(and\
    \ (not (null? txt))\n     (and (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n          (not (string-contains (substring txt 0 (- (string-length\
    \ txt) 1)) \" \"))))\n</code>\nNotice how in the second one it's easy to see that\
    \ the outer <code>and</code> has two arguments, and the first one is another <code>and</code>\
    \ with two arguments itself. Here's another example:\n<code>(not (string-contains\
    \ (substring txt 0 (- (string-length txt) 1)) \" \"))\n</code>\nThe lack of parentheses\
    \ here makes it a bit hard to tell that <code>not</code> is actually an argument\
    \ to <code>string-contains</code>.\nRemoving some of the parentheses in the code\
    \ above will help make it easier to understand.\nOther things you could do to\
    \ improve readability:\n\nWrite a helper function to avoid repeating <code>(string-length\
    \ txt)</code>.\nUse Racket's", "  (if (string=? txt \"\")\n      false\n     \
    \ (if (string=? (substring txt -1 -1) \" \")\n          false\n          (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n              true\n          \
    \    false))))\n", "  (and (not (empty? txt))\n       (and (not (char-alphabetic?\
    \ (last-char txt)))\n            (not (char-alphabetic? (last-char (string-drop-right\
    \ txt 1)))))))\n", "  (let ([txt (string-trim txt)])\n    (cond\n      [(empty?\
    \ txt) false]\n      [(and (alpha? (last txt))\n            (empty? (string-&gt;list\
    \ (string-trim (string-take txt (sub1 (string-length txt))))))) true]\n      [else\
    \ false])))\n</code>\nI was wondering if it is possible to do this using only\
    \ built-in functions and without using any custom functions.\n\n\nA:\n\nYou can\
    \ use <code>string-split</code> to get a list of words and <code>string-&gt;symbol</code>\
    \ to convert the last word to symbol, then check if the last character of that\
    \ symbol is an alphabetical character:\n<code>(define (check_if_last_char_is_a_letter\
    \ txt)\n  (let ([words (string-split txt)])\n    (not (empty? words))\n    (alpha?\
    \ (string-ref (symbol-&gt;string (string-&gt;symbol (last words))) -1))))\n</code>\n",
  "  (define (is-alpha? x)\n    (and (char&lt;=? #\\a x) (char&lt;=? x #\\z)))\n \
    \ (or (zero? (string-length txt))\n      (and (is-alpha? (string-ref txt (- (string-length\
    \ txt) 1)))\n           (not (is-alpha? (string-ref txt (- (string-length txt)\
    \ 2)))))))\n</code>\n", "  (define (is_letter? c)\n    (and (char-alphabetic?\
    \ c) (not (char-numeric? c))))\n  (and (not (string=? \"\" txt)) (string-any is_letter?\
    \ (string-&gt;list txt))))\n", "  (let ([len (string-length txt)])\n    (if (zero?\
    \ len)\n        #f\n        (let ([ch (string-ref txt (- len 1))])\n         \
    \ (or (char-alphabetic? ch)\n              (char-digit? ch))))))\n", "  (cond\n\
    \    [(empty? txt) false]\n    [(or (char-alphabetic? (last-char txt)) (char-alphabetic?\
    \ (last-char (butlast txt))))\n     (not (char-alphabetic? (last-char (butlast\
    \ txt))))]\n    [else false]))", "  (define (char? c)\n    (string=? (regexp-match\
    \ #rx\"^[a-zA-Z]\" c) c))\n  (define (last-char s)\n    (string-ref s (- (string-length\
    \ s) 1)))\n  (define (check-last-char s)\n    (let ((c (last-char s)))\n     \
    \ (char? c)))\n  (cond ((string=? txt \"\") #f)\n        ((check-last-char txt)\
    \ #t)\n        (else #f)))\n", "  (let ((non-word-break? (string-ref txt (sub1\
    \ (string-length txt)))))\n    (cond\n      ((string=? non-word-break? #\\ ) #f)\n\
    \      ((char-alphabetic? non-word-break?) #t)\n      (else #f))))\n", "  (equal?\
    \ (racket-char-alphabetic? (last-char txt)) #t))\n</code>\nI want to use the last-char\
    \ function, but I'm not sure how to implement it.\n\n\nA:\n\nThere is no <code>last-char</code>\
    \ function in Racket. However, <code>string-ref</code> might do what you want.\n\
    <code>(define (check_if_last_char_is_a_letter txt)\n  (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1))))\n</code>\nThis does return false for an empty\
    \ string.\n", "  (if (empty? txt)\n      #f\n      (char-alphabetic? (last-char\
    \ txt))))\n", "  (or (char-alphabetic? (last-char txt))\n      (char-whitespace?\
    \ (last-char txt))))\n", "  (let loop ([i (- (string-length txt) 1)]\n       \
    \      [result #f])\n    (cond\n      [(negative? i) result]\n      [(char-alphabetic?\
    \ (string-ref txt i))\n       (loop (- i 1)\n             (not (char-whitespace?\
    \ (string-ref txt (- i 1))))) ]\n      [else (loop (- i 1) result)])))\n", " \
    \ (define (my-is-alphabetical-char? ch)\n    (and (char-alphabetic? ch)\n    \
    \     (not (char-numeric? ch))))\n  (define (get-last-char txt)\n    (substring\
    \ txt (- (string-length txt) 1) (string-length txt)))\n  (cond\n    [(empty? txt)\
    \ #f]\n    [(my-is-alphabetical-char? (get-last-char txt)) #t]\n    [else #f]))\n",
  "  (if (empty? txt)\n      #f\n      (if (is-alpha (last txt))\n          (if (string-contains\
    \ txt \" \")\n              #f\n              #t)\n          #f)))", '  (string-contains-word?
    (substring txt -1) txt))', "  (and\n   (> (string-length txt) 0)\n   (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n   (not (string-contains txt (string\
    \ (string-ref txt (- (string-length txt) 1)))))))", "  (let* ((last-char (last-char\
    \ txt))\n         (last-char-is-alpha? (char-alphabetic? last-char)))\n    (if\
    \ (last-char-is-alpha?)\n        (not (regexp-match #rx\"\\s\" (string-tail txt\
    \ 1)))\n        false)))\n", "  (let ([lst (string-&gt;list txt)])\n    (if (empty?\
    \ lst)\n        #f\n        (if (char-alphabetic? (last lst))\n            (if\
    \ (char-&gt;integer (last lst))\n                #t\n                #f)\n   \
    \         #f))))\n</code>\nI know this is ugly, but it's only for learning.\n\
    Any advice is welcome. Thanks!\n\n\nA:\n\nYou\u2019re on the right track, but\
    \ your function doesn\u2019t really check whether the last character is part of\
    \ a word or not.\nFirst of all, you should use <code>char-lower-case?</code> instead\
    \ of <code>char-alphabetic?</code> to check whether a character is a letter or\
    \ not. This is because <code>char-alphabetic?</code> will return <code>#t</code>\
    \ for uppercase letters, and you don\u2019t want that.\nThen, the \u201Ccheck\u201D\
    \ you\u2019re making is too simple. You\u2019re only checking whether there\u2019\
    s a space after the last letter, but what if there\u2019s a space or a newline\
    \ or something before it?\nA better way to check whether the last character is\
    \ a letter would be to remove all the non-letter characters before the last letter,\
    \ and see if the remaining string is equal to the original string.\nHere\u2019\
    s an implementation of that:\n<code>(define (check-if-last-char-is-a-letter txt)\n\
    \  (let* ([lst (string-&gt;list txt)]\n         [last-letter (string-&gt;list\n\
    \                       (regexp-replace*\n                        #rx\"[^a-zA-Z]+$\"\
    \n                        txt\n                        \"\"))])\n    (equal? lst\
    \ last-letter)))\n</code>\n<code>(regexp-replace* #rx\"[^a-zA-Z]+$\" txt \"\"\
    )</code> will remove all non-letters from the end of the string <code>txt</code>.\n\
    So if we pass the string <code>\"apple pi e\"</code> to the function, we get <code>\"\
    apple pi e\"</code> back,", "  (define (is-char? txt)\n    (regexp-match? #rx\"\
    [a-zA-Z]\" txt))\n  (and\n   (is-char? txt)\n   (not (string-contains txt #\\\
    space))))\n", "  (define (alphabet? c)\n    (and (char-alphabetic? c)\n      \
    \   (char-lower-case? c)))\n  (if (string-empty? txt)\n      #f\n      (if (alphabet?\
    \ (string-ref txt (- (string-length txt) 1)))\n          #t\n          #f)))\n",
  "  (define last-char (string-ref txt (- (string-length txt) 1)))\n  (define alpha-chars\
    \ (string-join\n                       (map (\u03BB (x) (string x)) (range #\\\
    a #\\z)) \"\"))\n  (define lower-alpha-chars (string-join\n                  \
    \           (map (\u03BB (x) (string x)) (range #\\a #\\z)) \"\"))\n  (cond\n\
    \    [(char-alphabetic? last-char) (string-contains? alpha-chars last-char)]\n\
    \    [(char-lower-case? last-char) (string-contains? lower-alpha-chars last-char)]\n\
    \    [else #f]))\n", "  (if (string=? \"\" txt)\n      #f\n      (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 2)))\n              #f\n            \
    \  #t)\n          #f)))", "  (if (string=? \"\" txt)\n      #f\n      (or (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (and\n           (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 2)))\n           (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 3)))))))\n", "  (cond\n    ((eq? (string-length txt)\
    \ 0)\n     false)\n    ((and (char-alphabetic? (string-ref txt (sub1 (string-length\
    \ txt))))\n          (or (eq? (string-length txt) 1)\n              (char-alphabetic?\
    \ (string-ref txt (sub1 (sub1 (string-length txt)))))))\n     false)\n    (else\n\
    \     true)))\n", "  (cond\n    [(or (= (string-length txt) 0)\n         (zero?\
    \ (string-ref txt (- (string-length txt) 1))))\n     #f]\n    [(string-ref txt\
    \ (- (string-length txt) 1)) #t]))", "  (regexp-match? #rx\"^.*(\\s+|[^a-zA-Z]*[a-zA-Z])$\"\
    \ txt))\n", "  (string-alphabetic? (substring txt (- (string-length txt) 1))))\n",
  "  (cond\n    [(empty? txt) false]\n    [(alphabetic? (last-char txt))\n     (let\
    \ [word (string-split txt #\\space)]\n       (and (= 1 (length word))\n      \
    \      (alphabetic? (last-char (first word)))))\n    ]\n    [else false]))\n",
  "  (if (empty? txt)\n      false\n      (if (empty? (regexp-match #rx\" $\" txt))\n\
    \          true\n          false)))\n", "  (and\n   (= 1 (string-length txt))\n\
    \   (char-alphabetic? (string-ref txt 0))))\n", "  (and\n   (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n   (not (char-whitespace? (string-ref\
    \ txt (- (string-length txt) 1))))))", "  (cond [(empty? txt) (error \"Input string\
    \ is empty\")]\n        [(not (last-char-is-alpha? txt)) #f]\n        [(prev-char-is-alpha?\
    \ txt) #f]\n        [else #t]))\n", "  (and (char-alphabetic? (string-ref txt\
    \ (- (string-length txt) 1)))\n       (not (char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 2))))))\n", "  (cond\n    [(string=? txt \"\") false]\n\
    \    [(not (char-alphabetic? (last-char txt))) false]\n    [(string-ref txt (-\
    \ (string-length txt) 2)) false]\n    [else true]))\n", "  (let ((len (string-length\
    \ txt)))\n    (and\n     (> len 0)\n     (and (char-alphabetic? (string-ref txt\
    \ (- len 1)))\n          (not (char-alphabetic? (string-ref txt (- len 2))))))))\n",
  "  (regexp-match? #rx\"^.*\\\\b[a-zA-Z]$\" txt))\n", "  (and\n   (is-alpha (char-downcase\
    \ (string-ref txt (- (string-length txt) 1))))\n   (not (char=? (string-ref txt\
    \ (- (string-length txt) 1)) #\\space))))\n</code>\nI am looking for ways to improve\
    \ this code, mainly in regards to Racket's built-in functions. \n\n\nA:\n\nUse\
    \ <code>string-any</code>\n<code>(define (check_if_last_char_is_a_letter txt)\n\
    \  (and\n   (not (string-any (curry char=? #\\space) txt))\n   (is-alpha (char-downcase\
    \ (string-ref txt (- (string-length txt) 1))))))\n</code>\nor <code>string-index</code>\
    \ and <code>string-ref</code>\n<code>(define (check_if_last_char_is_a_letter txt)\n\
    \  (and\n   (is-alpha (char-downcase (string-ref txt (- (string-length txt) 1))))\n\
    \   (not (char=? (string-ref txt (string-index txt #\\space)) #\\space))))\n</code>\n",
  "  (and\n   (not (empty? txt))\n   (char-alphabetic? (last-char txt))\n   (not (char-whitespace?\
    \ (last-char txt)))\n   (not (char-alphabetic? (char-before (last-char txt))))))\n",
  "  (let ([lst (string-&gt;list txt)])\n    (or (not (empty? lst))\n        (and\
    \ (char-alphabetic? (last lst))\n             (or (empty? (rest lst))\n      \
    \           (char-whitespace? (second-to-last lst)))))))\n", "  (cond\n    [(empty?\
    \ txt) (display false)]\n    [(char-alphabetic? (last txt)) (display true)]\n\
    \    [else (display false)]))\n", "  (if (empty? txt) (string=? txt \"\")\n  \
    \    (if (string-contains-regexp txt \".*\\\\W$\")\n          (string=? (string-ref\
    \ txt (sub1 (string-length txt))) #\\_)\n          (not (string-contains-regexp\
    \ txt \".*\\\\s$\")))))", "  (let ([lst (string-split txt \" \")])\n    (cond\n\
    \      [(empty? lst) #f]\n      [(alphabetic? (string-ref (car (reverse lst))\
    \ 0)) #t]\n      [else #f])))\n", "  (if (string=? txt \"\")\n      #f\n     \
    \ (or\n       (string-alphabetic? (string-ref txt (- (string-length txt) 1)))\n\
    \       (string-whitespace? (string-ref txt (- (string-length txt) 1))))))\n</code>\n\
    The definition of <code>string-alphabetic?</code> is:\n<code>(define (string-alphabetic?\
    \ char)\n  (let ((c (char-&gt;integer char)))\n    (and (&gt;= c 65)\n       \
    \  (&lt;= c 90)\n         (char=? char (integer-&gt;char c)))))\n</code>\nThe\
    \ test cases are correct.\nIs there something I can do to improve this solution?\n\
    \n\nA:\n\nThere are multiple problems with your code:\n\nIn Racket, the convention\
    \ is to use <code>-&gt;</code> in the name of a function when it returns a value.\
    \ For example, a function called <code>string-to-list</code> is preferred over\
    \ <code>string-list</code>.\nNames of variables should be lowercase, while names\
    \ of functions and types are uppercase.\nYour function would be clearer if you\
    \ used a variable instead of passing the argument in as an argument.\nIf you want\
    \ to use a function in a non-standard way (i.e. <code>check_if_last_char_is_a_letter</code>),\
    \ make the function names easier to understand by changing them (i.e. <code>string-last-char-is-a-letter?</code>).\n\
    <code>string-whitespace?</code> doesn't work the way you think it does. Instead\
    \ of checking if the character is a whitespace character, it checks if the whole\
    \ string is only whitespace characters. For example, <code>(string-whitespace?\
    \ \" \")</code> returns <code>#t</code>, but <code>(string-whitespace? \"&lt;tab&gt;\
    \ \")</code> returns <code>#f</code>.\nThe <code>check_if_last_char_is_a_letter</code>\
    \ function does not work the way it should. For example, it will return <code>",
  "  (if (empty? txt)\n      false\n      (let ([c (first txt)])\n        (if (char-alphabetic?\
    \ c)\n            (if (char-whitespace? (first (rest txt)))\n                true\n\
    \                false)\n            (check_if_last_char_is_a_letter (rest txt))))))\n",
  "  (cond\n    ((= (string-length txt) 0) #f)\n    ((string-contains-from (regexp\
    \ \"[[:alpha:]]\") txt (- (string-length txt) 1)) #t)\n    (else #f)))\n", " \
    \ (if (string=? txt \"\")\n      #f\n      (or\n       (char-alphabetic? (substring\
    \ txt (- (string-length txt) 1) (string-length txt)))\n       (string=? (substring\
    \ txt (- (string-length txt) 1) (string-length txt)) \" \"))))\n", "  (and (not\
    \ (string=? txt \"\"))\n       (and (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n            (not (string-contains txt \" \" (- (string-length txt)\
    \ 1))))))\n", "  (if (string=? txt \"\") #f\n      (if (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n          (and (not (string-contains txt \"\
    \ \"))\n               (not (string-contains txt (string-ref txt (- (string-length\
    \ txt) 1)) (- (string-length txt) 2))))\n          #f)))\n", "  (define (is-letter?\
    \ ch)\n    (regexp-match? #rx\"[a-zA-Z]\" ch))\n  (define (last-char txt)\n  \
    \  (substring txt (sub1 (string-length txt)) (string-length txt)))\n  (define\
    \ (last-is-letter? txt)\n    (is-letter? (last-char txt)))\n  (define (last-is-in-word?\
    \ txt)\n    (regexp-match? #rx\"\\w \" txt))\n  (define (last-is-in-word txt)\n\
    \    (string=? \" \" (substring txt (sub1 (string-length txt)) (string-length\
    \ txt))))\n  (cond\n    [(empty? txt) #f]\n    [(last-is-letter? txt) (and (last-is-letter?\
    \ txt) (not (last-is-in-word? txt)))]\n    [else #f]))", "  (if (= (length txt)\
    \ 0)\n      #f\n      (if (or (char-alphabetic? (string-ref txt (- (length txt)\
    \ 1)))\n              (char-alphabetic? (string-ref txt (- (length txt) 2))))\n\
    \          #f\n          #t)))\n", "  (if (string=? \"\" txt)\n      #f\n    \
    \  (and\n       (char-alphabetic? (substring txt (- (string-length txt) 1) (string-length\
    \ txt)))\n       (not (char-alphabetic? (substring txt (- (string-length txt)\
    \ 2) (- (string-length txt) 1)))))))\n", "  (and (not (null? txt))\n       (not\
    \ (regexp-match #rx\" \" txt))\n       (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))))\n", "  (cond\n    [(string-null? txt) #f]\n    [(alphabetic? (string-ref\
    \ txt (sub1 (string-length txt))))\n     (not (string-contains? txt \" \"))]\n\
    \    [else #f]))\n</code>\n", "  (match txt\n    [\"\" #f]\n    [('word* [c ...])\n\
    \     (if (char-alphabetic? c) #t #f)]))\n", "  (let loop ([txt txt] [last #\\\
    ?])\n    (cond [(empty? txt) \n           (= (char-alphabetic? last) #t)]\n  \
    \        [(char-alphabetic? (car txt)) \n           (loop (cdr txt) (car txt))]\n\
    \          [else (loop (cdr txt) last)])))\n", "  (define (not-space? c) (char-alphabetic?\
    \ c))\n  (define (is-space? c) (not (not-space? c)))\n  (define (is-last-char-a-letter?\
    \ txt)\n    (and (not (empty? txt))\n         (not-space? (last-char txt))\n \
    \        (is-space? (penultimate-char txt))))\n  (is-last-char-a-letter? txt))\n",
  "  (and (not (equal? (string-length txt) 0))\n       (and (not (equal? (string-length\
    \ txt) 1))\n            (or (char-alphabetic? (string-ref txt (sub1 (string-length\
    \ txt))))\n                (not (char-alphabetic? (string-ref txt (sub1 (sub1\
    \ (string-length txt))))))))))", "  (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1))))\n", "  (cond ((null? txt) #f)\n        ((string-contains? txt \"\
    \ \") (check_if_last_char_is_a_letter (substring txt 0 (- (string-length txt)\
    \ 1))))\n        ((char-alphabetic? (string-ref txt (- (string-length txt) 1)))\
    \ #t)\n        (else #f)))", "  (if (or (zero? (string-length txt))\n        \
    \  (char-alphabetic? (string-ref txt (- (string-length txt) 1))))\n      (if (regexp-match\
    \ #rx\"\\S.*\\S\" txt)\n          false\n          true)\n      false))\n", " \
    \ (and\n   (not (empty? txt))\n   (char-alphabetic? (last-char txt))\n   (not\
    \ (word? txt))))", "  (if (empty? txt)\n      #f\n      (if (equal? (string-length\
    \ txt) 1)\n          (if (char-alphabetic? (string-ref txt 0))\n             \
    \ #t\n              #f)\n          (let ((txt-last (string-ref txt (- (string-length\
    \ txt) 1))))\n            (if (char-alphabetic? txt-last)\n                (if\
    \ (char-whitespace? (string-ref txt (- (string-length txt) 2)))\n            \
    \        #t\n                    #f)\n                #f)))))\n", "  (and\n  \
    \ (and\n    (regexp-match? #rx\".\" txt)\n    (regexp-match? #rx\"\\s+$\" txt))\n\
    \   (regexp-match? #rx\"[a-zA-Z]\" (string-right txt 1))))\n", "  (string-match\
    \ \"^$\" txt)\n  (string-match \"[a-zA-Z]\" txt)\n  (string-match \"[A-Z]\" txt)\n\
    \  (string-match \"[a-z]\" txt)\n  (string-match \"[0-9]\" txt)\n  (string-match\
    \ \"[!@#$%^&*(){}[]]\" txt)\n  (string-match \"[\"\"]\" txt)\n  (string-match\
    \ \"^[a-zA-Z][A-Za-z][^A-Za-z0-9]$\" txt)\n  (string-match \"^[^A-Za-z0-9]+$\"\
    \ txt)\n  (string-match \"^[a-zA-Z][a-zA-Z0-9]*[^A-Za-z0-9]+$\" txt)\n  (string-match\
    \ \"^[^A-Za-z0-9]*[a-zA-Z0-9]+[^A-Za-z0-9]+$\" txt)\n  (string-match \"^[^A-Za-z0-9]*[a-zA-Z0-9]+[^A-Za-z0-9]*$\"\
    \ txt)\n  (string-match \"[a-zA-Z]+[^A-Za-z0-9]$\" txt)\n  (string-match \"^[a-zA-Z]+[^A-Za-z0-9]$\"\
    \ txt)\n  (string-match \"^[a-zA-Z]+[^A-Za-z0-9]+$\" txt)\n  (string-match \"\
    ^[a-zA-Z]+[^A-Za-z0-9]*$\" txt)\n  (string-match \"^[^A-Za-z0-9]+[a-zA-Z]+[^A-Za-z0-9]*$\"\
    \ txt)\n  (string-match \"^[^A-Za-z0-9]+[", "  (match txt\n    ('() false)\n \
    \   (_   \n      (let ([last-char (last-item txt)])\n        (or (char-alphabetic?\
    \ last-char) (char-numeric? last-char))))))\n", "  (cond ((or (equal? (substring\
    \ txt -1) \" \")\n             (equal? (substring txt -1) \"\"))\n         false)\n\
    \        ((string-alphabetic? (substring txt -1))\n         true)\n        (else\
    \ false)))\n", "  (cond\n    [(empty? txt) false]\n    [(last-char-is-letter?\
    \ txt) true]\n    [else false]))\n", "  (define (last-char str)\n    (substring\
    \ str (sub1 (string-length str)) (string-length str)))\n  (and (char-alphabetic?\
    \ (string-&gt;char (last-char txt)))\n       (not (char-alphabetic? (string-&gt;char\
    \ (last-char (substring txt 0 (sub1 (string-length txt)))))))))\n</code>\nThis\
    \ works, but seems to use quite a lot of steps. Is there a shorter, more efficient\
    \ way of doing this?\n\n\nA:\n\nI think you're overthinking this. I'm not sure\
    \ I've seen all your edge cases, but this works for all the ones you have.\n<code>(define\
    \ (check-if-last-char-is-a-letter str)\n  (and (not (empty? str))\n       (and\
    \ (char-alphabetic? (string-ref str (sub1 (string-length str))))\n           \
    \ (or (not (char-alphabetic? (string-ref str (sub1 (sub1 (string-length str))))))\n\
    \                (empty? (regexp-match #rx\"^.*\\s+$\" str))))))\n</code>\nWe\
    \ can do better by using <code>string-split</code>, which splits by a regex.\n\
    <code>(define (check-if-last-char-is-a-letter str)\n  (and (not (empty? str))\n\
    \       (and (char-alphabetic? (string-ref str (sub1 (string-length str))))\n\
    \            (or (not (char-alphabetic? (string-ref str (sub1 (sub1 (string-length\
    \ str))))))\n                (empty? (cdr (string-split str #rx\"\\S+\"))))))\n\
    </code>\n", "  (and (not (empty? txt))\n       (char-alphabetic? (last-char txt))\n\
    \       (not (char-whitespace? (char-before (last-char txt))))))\n</code>\nBut\
    \ this is a problem that can be solved in pure logic very easily. I'd like to\
    \ show the same thing in Racket in a way that doesn't rely on a lot of helper\
    \ functions.\n<code>#lang racket\n", "  (cond ((string=? txt \"\") #f)\n     \
    \   ((string-ref txt (- (string-length txt) 1)) \n         (not (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))))\n        (else (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1))))))\n", "  (and (not (empty? txt))\n\
    \       (or (letter? (last txt))\n           (char=? (last txt) #\\space))))\n",
  "  (match (string-&gt;list txt)\n    ['() #f]\n    [(list '_) #f]\n    [(list (cons\
    \ a b))\n     (and (alphabetic? a) (or (alphabetic? b) (char=? b #\\space)))]))\n\
    </code>\nBut the test is failing!\n<code>; check_if_last_char_is_a_letter\ncheck_if_last_char_is_a_letter",
  "  (let* ((ch (substring txt -1))\n         (match (regexp-match #rx\"[A-Za-z]\"\
    \ ch)))\n    (and match\n         (string-empty? (regexp-match #rx\" \" ch)))))",
  "  (cond\n    [(empty? txt) false]\n    [(and (alphabetic? (last-char txt)) (alphabetic?\
    \ (last-char (rest txt)))) false]\n    [else true]))", "  (and (not (empty? txt))\n\
    \       (and (char-alphabetic? (last-char txt))\n            (not (char-alphabetic?\
    \ (last-char (string-trim-right txt)))))))\ncheck_if_last_char_is_a_letter\n",
  "  (if (empty? txt)\n      false\n      (or (char-alphabetic? (last-char txt))\n\
    \          (and (char-alphabetic? (string-ref txt (- (string-length txt) 2)))\n\
    \               (eq? (last-char txt) #\\ ))\n          (check_if_last_char_is_a_letter\
    \ (substring txt 0 (- (string-length txt) 1))))))\n</code>\nThis one is O(n^2)\
    \ I'm sure, but it works and is simple.\nI'm sure there's a way to do it in O(n)\
    \ time, but this got the job done for me.\n", "  (cond\n    [(string=? txt \"\"\
    ) #f]\n    [(not (string-ci=? (regexp-match #rx\"\\w*$\" txt) \"\")) #f]\n   \
    \ [else #t]))\n", "  (let ([txt (string-append txt \" \")])\n    (or (string-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))\n        (string-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2))))))\n", "  (if (not (empty? txt))\n      (if\
    \ (and (char-alphabetic? (last-char txt))\n               (not (char-word? (last-char\
    \ txt))))\n          #t\n          #f)\n      #f))\n", "  (let* ([txt-len (string-length\
    \ txt)]\n         [last-char (substring txt (- txt-len 1) txt-len)])\n    (and\
    \ (char-alphabetic? (string-&gt;char last-char))\n         (not (string-index\
    \ (string-&gt;list last-char) \" \" #t)))))\n", "  (cond [(string=? \"\" txt)\
    \ false]\n        [(not (char-alphabetic? (string-ref txt (- (string-length txt)\
    \ 1)))) false]\n        [(and (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n              (not (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 2))))) true]\n        [else false]))\n", "  (define last-char (string-ref\
    \ txt (- (string-length txt) 1)))\n  (if (= last-char #\\space)\n      false\n\
    \      (char-alphabetic? last-char)))\n", "  (cond\n    [(empty? txt) false]\n\
    \    [(char-alphabetic? (last-char txt)) true]\n    [else false]))", "  (or (char-alphabetic?\
    \ (string-ref txt (sub1 (string-length txt))))\n      (space? (string-ref txt\
    \ (sub1 (string-length txt))))))\n</code>\nWe get a stack overflow error.\n<code>racket@v6.12\
    \ /home/newmarch/racket-programming/2020/08/aug-29\n$ racket\nWelcome to Racket\
    \ v6.12.\n&gt; (load \"aug-29.rkt\")", "  (and \n   (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 1)))\n   (char-whitespace? (string-ref txt (- (string-length\
    \ txt) 2)))))\n", "  (cond [(empty? txt) #f]\n        [(char-alphabetic? (last-char\
    \ txt))\n         (if (last-char (string-trim-right txt))\n             #f\n \
    \            #t)]\n        [else #f]))\n", "  (and\n   (string-contains? txt #\\\
    \ )\n   (not (string-contains? (substring txt (- (string-length txt) 2)) #\\ ))))\n",
  "  (define (iter txt n)\n    (cond ((&gt; n 0)\n           (if (char-alphabetic?\
    \ (string-ref txt (- n 1)))\n               (if (char-alphabetic? (string-ref\
    \ txt (- n 2)))\n                   (iter txt (- n 1))\n                   #t)\n\
    \               #f))\n          (else #f)))\n  (iter txt (string-length txt)))\n",
  "  (let ([txt (string-trim txt)])\n    (if (string-empty? txt)\n        #f\n   \
    \     (and (char-alphabetic? (string-ref txt (- (string-length txt) 1)))\n   \
    \          (not (char-alphabetic? (string-ref txt (- (string-length txt) 2))))))))\n",
  "  (and (not (empty? txt))\n       (and (char-alphabetic? (last-char txt))\n   \
    \         (not (char-alphabetic? (last-char (substring txt 0 (- (string-length\
    \ txt) 1))))))))\n", "  (define size (string-length txt))\n  (if (zero? size)\n\
    \      false\n      (let* ([c (string-ref txt (- size 1))]\n             [c1 (string-ref\
    \ txt (- size 2))])\n        (not (or (char-alphabetic? c)\n                 (or\
    \ (char-alphabetic? c1)\n                     (char-whitespace? c)))))))\n</code>\n\
    Tests\n<code>;; (check_if_last_char_is_a_letter \"apple pie\")", "  (and (string=?\
    \ (regexp-replace* #rx\"[^a-zA-Z]$\" txt \"\") txt)\n       (not (equal? (string-ref\
    \ txt (sub1 (string-length txt))) #\\space))))\n", "  (and\n   (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n   (not (char-alphabetic? (string-ref\
    \ txt (- (string-length txt) 2))))))\n", "  (local [(define (alphanum? txt)\n\
    \            (regexp-match? #rx\"[a-zA-Z0-9]\" txt))\n          (define (last-char\
    \ txt)\n            (substring txt (- (string-length txt) 1) (string-length txt)))]\n\
    \    (and (alphanum? (last-char txt))\n         (not (alphanum? (substring txt\
    \ (- (string-length txt) 2) (- (string-length txt) 1)))))))\n", "  (if (empty?\
    \ txt)\n      false\n      (char-alphabetic? (last-char txt))))\n", "  (regexp-match?\
    \ #rx\"\\w$\" txt))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
