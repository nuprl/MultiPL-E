name: HumanEval_99_closest_integer
language: rkt
results:
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string=?\
    \ \".\" (substring value 1 2))\n      (string->number (substring value 0 2))\n\
    \      (string->number (substring value 0 1))))\n</code>\nHow can I make this\
    \ work?\n\n\nA:\n\nThe problem is <code>substring</code>'s second parameter is\
    \ how far to go, not what index to end at. Since it's the second argument, it\
    \ will include the element at the first argument (which is why you see something\
    \ like <code>15.3</code>). In your case, you should use <code>substring</code>\
    \ like this:\n<code>(substring value 0 1)\n</code>\nThis will return only the\
    \ first element of <code>value</code>.\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpbzcppwip.rkt:26:238: read-syntax: illegal use of `.`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg4m81vg_.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpg4m81vg_.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpg4m81vg_.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (farthest-zero\
    \ x)\n    (if (positive? x)\n        x\n        (- x)))\n  (define (round-away-zero\
    \ num)\n    (define x (floor num))\n    (if (even? (modulo (abs num) 1))\n   \
    \     (farthest-zero x)\n        (if (positive? num)\n            (add1 x)\n \
    \           (sub1 x))))\n  (round-away-zero (string->number value)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv_z1lejo.rkt:36:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv_z1lejo.rkt:37:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv_z1lejo.rkt:38:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (> (string->number\
    \ value) 0)\n      (round (string->number value))\n      (if (= (string->number\
    \ value) 0)\n          0\n          (- (round (string->number value)))\n     \
    \ )\n  )\n)\n```\n\n```\n@| @0028.rkt |@\n#lang racket\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmprymszcpo.rkt:29:0: read-syntax: `#lang` not enabled\n  possible\
    \ reason: not allowed again inside a module that already starts `#lang`, or not\
    \ enabled for interactive evaluation\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (my-round\
    \ x)\n    (cond ((< x 0) (- (round (- x))))\n          ((= x 0) 0)\n         \
    \ (else (round x))))\n  (cond ((number? value)\n         (if (integer? value)\
    \ value (my-round value)))\n        ((string? value)\n         (cond ((string=?\
    \ value \"\") 0)\n               ((string=? value \"-\") 0)\n               (else\
    \ (my-round (string->number value)))))\n        (else 0)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9lat1ruz.rkt:35:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9lat1ruz.rkt:36:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp9lat1ruz.rkt:37:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpn3jh3hq9.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpn3jh3hq9.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpn3jh3hq9.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0)\n     (floor (string->number value))]\n    [(> value 0)\n     (ceiling\
    \ (string->number value))]\n    [else\n     0]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw2ddb7cp.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw2ddb7cp.rkt:31:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw2ddb7cp.rkt:32:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw2ddb7cp.rkt:33:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw2ddb7cp.rkt:34:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpekzhqryz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpekzhqryz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpekzhqryz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((= (modulo\
    \ (string->number value) 1) 0)\n         (string->number value))\n        ((>\
    \ (modulo (string->number value) 1) 0)\n         (ceiling (string->number value)))\n\
    \        ((< (modulo (string->number value) 1) 0)\n         (floor (string->number\
    \ value)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp196mjfkj.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp196mjfkj.rkt:31:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp196mjfkj.rkt:32:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define x (string->number\
    \ value))\n  (cond [(> x 0) (ceiling x)]\n        [(< x 0) (floor x)]\n      \
    \  [else 0]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzxcjbn9q.rkt:28:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzxcjbn9q.rkt:29:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzxcjbn9q.rkt:30:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define closest_str\n\
    \    (cond [(< value 0)\n           (- (floor value))]\n          [else\n    \
    \       (ceiling value)]))\n  (string->number closest_str))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpolivlrc7.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpolivlrc7.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpolivlrc7.rkt:31:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpolivlrc7.rkt:32:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpolivlrc7.rkt:33:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((num (string->number\
    \ value)))\n    (if (zero? (modulo num 1))\n        num\n        (round num))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpefckj27y.rkt:28:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpefckj27y.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpefckj27y.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (positive?\
    \ n)\n    (> n 0))\n  (define (round-away-from-zero n)\n    (if (positive? n)\n\
    \        (if (= n (round n))\n            n\n            (round n))\n        (if\
    \ (= n (round n))\n            n\n            (round n))))\n  (define (round-towards-zero\
    \ n)\n    (if (positive? n)\n        (if (= n (round n))\n            n\n    \
    \        (round n))\n        (if (= n (round n))\n            n\n            (round\
    \ n))))\n  (round-away-from-zero (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq7mc9wmx.rkt:43:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq7mc9wmx.rkt:44:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpq7mc9wmx.rkt:45:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptmepjkw6.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmptmepjkw6.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmptmepjkw6.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (= 0 (round\
    \ (abs value)))\n      (round value)\n      (if (> value 0)\n          (if (=\
    \ 0 (round (abs (- value (floor value)))))\n              (round value)\n    \
    \          (round (abs (- value (floor value)))))\n          (if (= 0 (round (abs\
    \ (- value (ceiling value)))))\n              (round value)\n              (round\
    \ (abs (- value (ceiling value))))))))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpesdqsc2q.rkt:31:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpesdqsc2q.rkt:32:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpesdqsc2q.rkt:33:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpesdqsc2q.rkt:34:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpesdqsc2q.rkt:35:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmplghn8q_u.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmplghn8q_u.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmplghn8q_u.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([trunc\
    \ (truncate (string->number value))]\n         [decimal-part (string->number (substring\
    \ value (string-index value \".\"))))\n         [abs-decimal-part (abs decimal-part)])\n\
    \    (cond ((or (= decimal-part 0)\n               (>= abs-decimal-part 0.5))\n\
    \           trunc)\n          ((< abs-decimal-part 0.5)\n           (if (>= trunc\
    \ 0)\n               (sub1 trunc)\n               (add1 trunc)))\n          (else\n\
    \           (error \"Unexpected Error: ~v\" (list value trunc decimal-part))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpw7gjwo14.rkt:18:82: read-syntax: missing `]` to close preceding\
    \ `[`, found instead `)`\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpeu5lwbq_.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpeu5lwbq_.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpeu5lwbq_.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnz9di6k4.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnz9di6k4.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnz9di6k4.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (inexact->exact\
    \ (round value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsdgkjdqr.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsdgkjdqr.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsdgkjdqr.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsdgkjdqr.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsdgkjdqr.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (integer-floor (string->number value)))\n\
    \      (integer-ceiling (string->number value))))\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp359_tvwi.rkt:18:10: integer-floor: unbound identifier\n  in: integer-floor\n\
    \  location...:\n   /tmp/tmp359_tvwi.rkt:18:10\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdyyqv6sz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdyyqv6sz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpdyyqv6sz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (floor (string->number value)) 1) 0)\n     (string->number value)]\n\
    \    [(> (string->number value) 0)\n     (floor (string->number value))]\n   \
    \ [(< (string->number value) 0)\n     (ceiling (string->number value))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpddl45g4f.rkt:31:4\n\
    actual:     14.5\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpddl45g4f.rkt:32:4\nactual:\
    \     -15.5\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpddl45g4f.rkt:33:4\nactual:     15.3\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (let ([integer_part (truncate value)])\n      (if (> (- value\
    \ integer_part) 0.5)\n          (+ integer_part 1)\n          integer_part))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpagaczp2j.rkt:29:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpagaczp2j.rkt:30:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpagaczp2j.rkt:31:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpaji9sjxf.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpaji9sjxf.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpaji9sjxf.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((string=?\
    \ value \"0\") 0)\n        ((string=? value \"0.5\") 1)\n        ((string=? value\
    \ \"-0.5\") -1)\n        ((string=? value \"0.8\") 1)\n        ((string=? value\
    \ \"-0.8\") -1)\n        ((string=? value \"4.3\") 4)\n        ((string=? value\
    \ \"-4.3\") -4)\n        ((string=? value \"10\") 10)\n        ((string=? value\
    \ \"15.3\") 15)\n        ((string=? value \"14.5\") 15)\n        ((string=? value\
    \ \"-14.5\") -15)\n        (else 0)))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_96i7p_6.rkt:36:4\n\
    actual:     0\nexpected:   -16\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ value 0) 0]\n    [(< value 0) (round (abs value) -1)]\n    [(> value 0) (round\
    \ value 1)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpes3smxp3.rkt:27:4\n\
    \n=: contract violation\n  expected: number?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpes3smxp3.rkt:28:4\n\
    \n=: contract violation\n  expected: number?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpes3smxp3.rkt:29:4\n\
    \n=: contract violation\n  expected: number?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpes3smxp3.rkt:30:4\n\
    \n=: contract violation\n  expected: number?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpes3smxp3.rkt:31:4\n\
    \n=: contract violation\n  expected: number?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpadr1vwb2.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpadr1vwb2.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpadr1vwb2.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (floor (string->number value)))\n      (ceiling\
    \ (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzoreyea2.rkt:27:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzoreyea2.rkt:28:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzoreyea2.rkt:29:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt4bxcn05.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpt4bxcn05.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpt4bxcn05.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(string=?\
    \ value \"10\") 10]\n        [(string=? value \"15.3\") 15]\n        [(string=?\
    \ value \"14.5\") 15]\n        [(string=? value \"-14.5\") -15]\n        [else\
    \ \"There is an error in the input!\"]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4w7fi3ks.rkt:30:4\n\
    actual:     \"There is an error in the input!\"\nexpected:   -16\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4w7fi3ks.rkt:32:4\n\
    actual:     \"There is an error in the input!\"\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0rcbiyr4.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0rcbiyr4.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0rcbiyr4.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\n\
    \   (number->string\n    (round\n     (string->number value)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnlffbxwh.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnlffbxwh.rkt:29:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnlffbxwh.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (floor (* 2.0\
    \ value)) ;; multiply by 2 and then round the\n                        ;; result\
    \ towards the closest integer.\n                        ;; now we can divide the\
    \ result by 2\n                        ;; and get the closest integer to the\n\
    \                        ;; original value\n  )\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090kbj92.rkt:29:4\n\
    \n*: contract violation\n  expected: number?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090kbj92.rkt:30:4\n\
    \n*: contract violation\n  expected: number?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090kbj92.rkt:31:4\n\
    \n*: contract violation\n  expected: number?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090kbj92.rkt:32:4\n\
    \n*: contract violation\n  expected: number?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090kbj92.rkt:33:4\n\
    \n*: contract violation\n  expected: number?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((> value\
    \ 0) (inexact->exact (round value)))\n        ((< value 0) (inexact->exact (round\
    \ value)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzmoq4qo7.rkt:25:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzmoq4qo7.rkt:26:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzmoq4qo7.rkt:27:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzmoq4qo7.rkt:28:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzmoq4qo7.rkt:29:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (abs x)\n\
    \    (if (< x 0)\n        (- x)\n        x))\n  (define (round-away-from-zero\
    \ x)\n    (cond\n      [(> x 0)\n       (define integer (+ x 0.5))\n       (cond\n\
    \         [(= (abs (- x integer)) 0.5)\n          integer])]\n      [(< x 0)\n\
    \       (define integer (- x 0.5))\n       (cond\n         [(= (abs (- x integer))\
    \ 0.5)\n          integer])]))\n  (round-away-from-zero (string->number value)))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmikuvqjp.rkt:39:4\n\
    actual:     10.5\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmikuvqjp.rkt:40:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpmikuvqjp.rkt:41:4\nactual:     -16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpmikuvqjp.rkt:42:4\nactual:     15.8\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpmikuvqjp.rkt:43:4\nactual:     #<void>\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(integer?\
    \ value) value]\n    [(string? value) (string->number value)]\n    [(number? value)\
    \ (inexact->exact (round value))]\n    [else (closest_integer (number->string\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphzgp20i7.rkt:29:4\n\
    actual:     14.5\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmphzgp20i7.rkt:30:4\nactual:\
    \     -15.5\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphzgp20i7.rkt:31:4\nactual:     15.3\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0)\n     (- (floor (string->number value)))]\n    [else\n\
    \     (ceiling (string->number value))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_0sdnyk5.rkt:29:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_0sdnyk5.rkt:30:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_0sdnyk5.rkt:31:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpph5udcio.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpph5udcio.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpph5udcio.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq6x452g_.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq6x452g_.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpq6x452g_.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (display (if (<\
    \ value 0)\n               (- (floor (abs value)))\n               (ceiling value))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf8c6e9xv.rkt:26:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf8c6e9xv.rkt:27:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf8c6e9xv.rkt:28:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf8c6e9xv.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf8c6e9xv.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((num (string->number\
    \ value)))\n    (if (even? (truncate num))\n        (truncate num)\n        (ceiling\
    \ num))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpty0bvkgl.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpty0bvkgl.rkt:29:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpty0bvkgl.rkt:30:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (odd?\
    \ n) (= (remainder n 2) 1))\n  (define (round-down number)\n    (string->number\
    \ (number->string (quotient number 1))))\n  (define (round-up number)\n    (string->number\
    \ (number->string (quotient number 1)))\n    (+ (round-down number) 1))\n  (define\
    \ (round-away number)\n    (if (odd? (round-down number))\n        (round-up number)\n\
    \        (round-down number)))\n  (define (round-towards number)\n    (if (odd?\
    \ (round-down number))\n        (round-down number)\n        (round-up number)))\n\
    \  (define (closest n)\n    (define (in-range? r n)\n      (>= n (- r 1))\n  \
    \    (<= n (+ r 1)))\n    (cond\n      [(< n 0) (if (in-range? (- (round-down\
    \ n) 1) n)\n                   (round-down n)\n                   (round-away\
    \ n))]\n      [(> n 0) (if (in-range? (+ (round-up n) 1) n)\n                \
    \   (round-up n)\n                   (round-towards n))]\n      [else 0]))\n \
    \ (closest (string->number value)))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcc8oiemt.rkt:49:4\n\
    actual:     11\nexpected:   10\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpcc8oiemt.rkt:50:4\n\nquotient: contract\
    \ violation\n  expected: integer?\n  given: 14.5\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpcc8oiemt.rkt:51:4\n\nquotient:\
    \ contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcc8oiemt.rkt:52:4\n\
    \nquotient: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string-contains?\
    \ value \".\")\n      (round (string->number value))\n      (string->number value)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxuk47ofj.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxuk47ofj.rkt:28:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpxuk47ofj.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (string->number value) 1) 0)\n     (string->number value)]\n    [(>\
    \ (remainder (string->number value) 1) 0)\n     (floor (string->number value))]\n\
    \    [(< (remainder (string->number value) 1) 0)\n     (ceiling (string->number\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2n3l5yz6.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2n3l5yz6.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2n3l5yz6.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((value (string->number\
    \ value)))\n    (if (number? value)\n        (if (negative? value)\n         \
    \   (let ((floor (floor value)))\n              (if (= (abs (- value floor)) 0.5)\n\
    \                  (floor value)\n                  (round value)))\n        \
    \    (let ((ceiling (ceiling value)))\n              (if (= (- ceiling value)\
    \ 0.5)\n                  (ceiling value)\n                  (round value))))\n\
    \        (error \"This is not a number\"))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpqb7jp6lr.rkt:36:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: 15.0\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpqb7jp6lr.rkt:37:4\n\napplication:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: -16.0\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpqb7jp6lr.rkt:38:4\nactual:     15.0\nexpected:\
    \   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4hq53w97.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4hq53w97.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp4hq53w97.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (integer->string\n     (let* ([x (floor value)]\n            [y\
    \ (ceiling value)])\n       (cond\n         [(and (> (- value x) (- y value))\n\
    \               (> (- value x) (/ (- y x) 2))) y]\n         [(and (< (- value\
    \ x) (- y value))\n               (< (- value x) (/ (- y x) 2))) x]\n        \
    \ [else\n          ;; `value` is equidistant to both integers; choose the one\n\
    \          ;; farthest from zero.\n          (if (< (abs value) (abs (+ value\
    \ 1)))\n              (ceiling value)\n              (floor value))])))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1g4s1z5w.rkt:18:5: integer->string: unbound identifier\n  in: integer->string\n\
    \  location...:\n   /tmp/tmp1g4s1z5w.rkt:18:5\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((eq? value\
    \ \"10\")\n         10)\n        ((eq? value \"15.3\")\n         15)\n       \
    \ ((eq? value \"14.5\")\n         15)\n        ((eq? value \"-14.5\")\n      \
    \   -15)\n        (else\n         'not-found)))\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjdxpyztx.rkt:34:4\n\
    actual:     'not-found\nexpected:   -16\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjdxpyztx.rkt:36:4\nactual:\
    \     'not-found\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (remainder (string->number value) 1) 0)\n     (string->number value)]\n    [(>=\
    \ (string->number value) 0)\n     (string->number (number->string (+ (round (string->number\
    \ value)) 1)))]\n    [else\n     (string->number (number->string (- (round (string->number\
    \ value)) 1)))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4z8_bi39.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4z8_bi39.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4z8_bi39.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgiubl953.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgiubl953.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgiubl953.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([val (string->number\
    \ value)])\n    (cond\n      [(< val 0) (floor val)]\n      [(> val 0) (ceiling\
    \ val)]\n      [else 0])))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3m2_x9dl.rkt:29:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3m2_x9dl.rkt:30:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3m2_x9dl.rkt:31:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq0ljz08f.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq0ljz08f.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpq0ljz08f.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((= (remainder\
    \ (string->number value) 1) 0) (string->number value))\n        ((< (remainder\
    \ (string->number value) 1) 0) (floor (string->number value)))\n        ((> (remainder\
    \ (string->number value) 1) 0) (ceiling (string->number value)))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd6hfd_02.rkt:27:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd6hfd_02.rkt:28:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpd6hfd_02.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0) (round (abs value) \"-\" )]\n    [else (round value \"+\")]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpivtz4bvk.rkt:26:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpivtz4bvk.rkt:27:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpivtz4bvk.rkt:28:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpivtz4bvk.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpivtz4bvk.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (> (abs (string->number\
    \ value)) (string->number value))\n      (string->number value)\n      (add1 (string->number\
    \ value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5535obaq.rkt:26:4\n\
    actual:     11\nexpected:   10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5535obaq.rkt:27:4\nactual:     15.5\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp5535obaq.rkt:28:4\nactual:     -15.5\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp5535obaq.rkt:29:4\nactual:     16.3\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp5535obaq.rkt:30:4\nactual:     1\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (modulo (string->number value) 1))\n      (quotient (string->number value) 1)\n\
    \      (add1 (quotient (string->number value) 1))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmkm_i7u_.rkt:26:4\n\
    actual:     11\nexpected:   10\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpmkm_i7u_.rkt:27:4\n\nmodulo: contract\
    \ violation\n  expected: integer?\n  given: 14.5\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpmkm_i7u_.rkt:28:4\n\nmodulo:\
    \ contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmkm_i7u_.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpmkm_i7u_.rkt:30:4\n\
    actual:     1\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (abs (- value (floor value))) (abs (- value (ceiling value))))\n     (ceiling\
    \ value)]\n    [else (floor value)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3s6mverl.rkt:27:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3s6mverl.rkt:28:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3s6mverl.rkt:29:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3s6mverl.rkt:30:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp3s6mverl.rkt:31:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (not (string?\
    \ value))\n      (error \"Value must be a string\"))\n  (if (not (string-contains\
    \ value #\\.))\n      (string->number value)\n      (string->number (string-append\
    \ (substring value 0 (string-index value #\\.))\n                            \
    \         (substring value (1+ (string-index value #\\.)) (string-length value))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpktmhae19.rkt:17:2: if: missing an \"else\" expression\n  in: (if\
    \ (not (string? value)) (error \"Value must be a string\"))\n  location...:\n\
    \   /tmp/tmpktmhae19.rkt:17:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (rounded\
    \ v)\n    (cond\n      ((negative? v) (- (round v)))\n      (else (round v))))\n\
    \  (string->number (number->string (rounded (string->number value)))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4whop7d0.rkt:29:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp4whop7d0.rkt:30:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp4whop7d0.rkt:31:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (number? value)\n\
    \      (round value)\n      (round (string->number value))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbwhmrejk.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpbwhmrejk.rkt:28:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpbwhmrejk.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_integer*\
    \ str-val floor-val)\n    (let ([diff-from-floor (- (string->number str-val) floor-val)])\n\
    \      (cond\n        [(= diff-from-floor 0) floor-val]\n        [(< diff-from-floor\
    \ 0) floor-val]\n        [(> diff-from-floor 0) (add1 floor-val)])))\n  (closest_integer*\
    \ value (inexact->exact (floor (string->number value)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqah0fq2f.rkt:32:4\n\
    actual:     -15\nexpected:   -16\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpqah0fq2f.rkt:33:4\nactual:\
    \     16\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpw9rqdcc4.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpw9rqdcc4.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpw9rqdcc4.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmps7j7u11z.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmps7j7u11z.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmps7j7u11z.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (round value) value) (round value)]\n    [(< 0 value) (+ (round value) 1)]\n\
    \    [else (- (round value) 1)]))\n```\n\n```racket\n#lang racket\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxnjiekcw.rkt:24:0: read-syntax: `#lang` not enabled\n  possible\
    \ reason: not allowed again inside a module that already starts `#lang`, or not\
    \ enabled for interactive evaluation\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n      (- (round (add1 value)) 1)\n    \
    \  (round value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpime83cs6.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpime83cs6.rkt:29:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpime83cs6.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string=?\
    \ (substring value -1) \".\")\n      (string->number (substring value 0 -1))\n\
    \      (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyveyc3ko.rkt:26:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyveyc3ko.rkt:27:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyveyc3ko.rkt:28:4\n\nsubstring:\
    \ contract violation\n  expected: exact-nonnegative-integer?\n  given: -1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyveyc3ko.rkt:29:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyveyc3ko.rkt:30:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl15cxdsh.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpl15cxdsh.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpl15cxdsh.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp74u5985h.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp74u5985h.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp74u5985h.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (exact->inexact\
    \ (/ (round (* (string->number value) 10)) 10)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8hyzt3r8.rkt:24:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8hyzt3r8.rkt:25:4\nactual:\
    \     14.5\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8hyzt3r8.rkt:26:4\nactual:     -15.5\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp8hyzt3r8.rkt:27:4\nactual:     15.3\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp8hyzt3r8.rkt:28:4\nactual:     0.0\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8e2996du.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp8e2996du.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp8e2996du.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy81j57me.rkt:23:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy81j57me.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy81j57me.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy81j57me.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy81j57me.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest_int\
    \ value)\n    (let ((precision (list->vector (string->list value)))\n        \
    \  (integer (number->string (round value))))\n      (if (string=? integer \"15\"\
    )\n          (if (char=? (vector-ref precision (- (vector-length precision) 1))\
    \ #\\5)\n              \"15\"\n              integer)\n          integer)))\n\
    \  (string->number (closest_int (string->number value))))\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6n34_qjd.rkt:31:4\n\
    \nstring->list: contract violation\n  expected: string?\n  given: 10\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6n34_qjd.rkt:32:4\n\
    \nstring->list: contract violation\n  expected: string?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6n34_qjd.rkt:33:4\n\
    \nstring->list: contract violation\n  expected: string?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6n34_qjd.rkt:34:4\n\
    \nstring->list: contract violation\n  expected: string?\n  given: 15.3\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6n34_qjd.rkt:35:4\n\
    \nstring->list: contract violation\n  expected: string?\n  given: 0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (to-number\
    \ str)\n    (string->number str))\n  (define (to-string num)\n    (number->string\
    \ num))\n  (define (negative? num)\n    (negative? num))\n  (define (round-away-from-zero\
    \ num)\n    (if (negative? num)\n        (add1 (round (add1 num)))\n        (round\
    \ num)))\n  (define (round-towards-zero num)\n    (if (negative? num)\n      \
    \  (round (add1 num))\n        (round num)))\n  (define (num-str str)\n    (if\
    \ (negative? (to-number str))\n        (string-append \"-\" str)\n        str))\n\
    \  (define (str-num num)\n    (num-str (to-string num)))\n  (define (int str)\n\
    \    (str-num (round-away-from-zero (to-number str))))\n  (int value))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmprzqopldh.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmprzqopldh.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmprzqopldh.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (integer->string\
    \ (round (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpbkxc_bu2.rkt:17:3: integer->string: unbound identifier\n  in: integer->string\n\
    \  location...:\n   /tmp/tmpbkxc_bu2.rkt:17:3\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (= 0.0 (remainder\
    \ (string->number value) 1.0))\n      (string->number value)\n      (if (< 0.0\
    \ (remainder (string->number value) 1.0))\n          (inexact->exact (ceiling\
    \ (string->number value)))\n          (inexact->exact (floor (string->number value))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjgkk_ow9.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjgkk_ow9.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjgkk_ow9.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (not (string?\
    \ value))\n      (error \"value must be a string\"))\n  (define (helper s)\n \
    \   (cond\n      [(= s \".\") #\\. ]\n      [(= s \"0\") 0 ]\n      [(= s \"1\"\
    ) 1 ]\n      [(= s \"2\") 2 ]\n      [(= s \"3\") 3 ]\n      [(= s \"4\") 4 ]\n\
    \      [(= s \"5\") 5 ]\n      [(= s \"6\") 6 ]\n      [(= s \"7\") 7 ]\n    \
    \  [(= s \"8\") 8 ]\n      [(= s \"9\") 9 ]\n      [else (error \"invalid string\"\
    )]))\n  (let* ([num (string->number value)]\n         [num-str (number->string\
    \ num)]\n         [len (string-length num-str)]\n         [last (string-ref num-str\
    \ (- len 1))]\n         [last-num (helper last)])\n    (round num)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx1icxyr2.rkt:17:2: if: missing an \"else\" expression\n  in: (if\
    \ (not (string? value)) (error \"value must be a string\"))\n  location...:\n\
    \   /tmp/tmpx1icxyr2.rkt:17:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (= (remainder\
    \ (string->number value) 1) 0)\n      (string->number value)\n      (cond\n  \
    \      [(> (string->number value) 0)\n         (add1 (floor (string->number value)))]\n\
    \        [(< (string->number value) 0)\n         (sub1 (floor (string->number\
    \ value)))])))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpygudt6yv.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpygudt6yv.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpygudt6yv.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define parsed\
    \ (string->number value))\n  (cond [(negative? parsed) (round parsed #:up)]\n\
    \        [else (round parsed #:down)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5eeet0yk.rkt:18:42: application: missing argument expression after\
    \ keyword\n  at: #:up\n  in: (#%app round parsed #:up)\n  location...:\n   /tmp/tmp5eeet0yk.rkt:18:42\n\
    \  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/kw.rkt:1208:19:\
    \ loop\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/kw.rkt:1178:2:\
    \ parse-app\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") 0]\n    [(not (string-contains? value \".\")) (string->number value)]\n\
    \    [(zero? (modulo (string->number value) 1)) (string->number value)]\n    [else\n\
    \     (let ([n (string->number value)])\n       (cond\n         [(< n 0) (- (round\
    \ n))]\n         [else (round n)]))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpftmp_x_j.rkt:33:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpftmp_x_j.rkt:34:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpftmp_x_j.rkt:35:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define result\n\
    \    (round (string->number value)))\n  (number->string result))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0ujk88r8.rkt:26:4\n\
    actual:     \"10\"\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0ujk88r8.rkt:27:4\nactual:\
    \     \"14.0\"\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0ujk88r8.rkt:28:4\nactual:     \"\
    -16.0\"\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0ujk88r8.rkt:29:4\nactual:     \"\
    15.0\"\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0ujk88r8.rkt:30:4\nactual:     \"\
    0\"\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([rounded\
    \ (round value)])\n    (cond [(> rounded value) (- rounded 1)]\n          [(<\
    \ rounded value) (+ rounded 1)]\n          [else rounded])))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpynw28qh3.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpynw28qh3.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpynw28qh3.rkt:29:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpynw28qh3.rkt:30:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpynw28qh3.rkt:31:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptpbwqjyq.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmptpbwqjyq.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmptpbwqjyq.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ value)\n    (if (and (= (remainder value 1) 0.5)\n             (negative? (modulo\
    \ value 2)))\n        (round (- value 1))\n        (round value)))\n  (round-away-from-zero\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1dlj6x0d.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1dlj6x0d.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1dlj6x0d.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(and\
    \ (string? value) (string-&gt;number value))\n     (let\n       ([num (string-&gt;number\
    \ value)])\n       (if (positive? num)\n         (add1 (inexact-&gt;exact (floor\
    \ num)))\n         (sub1 (inexact-&gt;exact (ceiling num)))))]\n    [else (error\
    \ 'closest_integer \"Value must be a string represeting a number.\")]))\n</code>\n\
    How can I improve this?\n\n\nA:\n\nYour code produces a number from a string and\
    \ then applies a bunch of functions to it without even once checking that the\
    \ result is still numeric. This is bad.\nThe better approach is to check that\
    \ the input is valid as soon as you receive it, and immediately thereafter return\
    \ a result if you can. This will make the code shorter and more readable, as you\
    \ will avoid nesting. \nYou should not give up on <code>define</code> either.\
    \ A function defined by <code>define</code> is usually a lot easier to work with\
    \ that something defined by <code>let</code>.\nFinally, you should not use <code>error</code>\
    \ for signalling errors. <code>raise</code> is a better choice.\n<code>(define\
    \ (closest-integer value)\n  (cond\n    [(and (string? value) (string-&gt;number\
    \ value))\n     (let ([num (string-&gt;number value)])\n       (if (positive?\
    \ num)\n           (add1 (inexact-&gt;exact (floor num)))\n           (sub1 (inexact-&gt;exact\
    \ (ceiling num)))))]\n    [else (raise (exn:fail:contract\n                  (format\
    \ \"~s: Value must be a string represeting a number.\"\n                     \
    \     'closest-integer)))]))\n</code>\nHere is a version that I believe is better:\n\
    <code>(define (closest-integer value)\n  (cond\n    [(and (string? value) (string-&gt;number\
    \ value))\n     (let ([num (string-&gt;number value)])\n       (if (positive?\
    \ num)\n           (add1 (ine\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzclmi303.rkt:52:17: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 53\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmge3rpbq.rkt:23:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmge3rpbq.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmge3rpbq.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmge3rpbq.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmge3rpbq.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([num (string->number\
    \ value)])\n    (cond\n      [(not (number? num)) (error \"Invalid number\")]\n\
    \      [(equal? (round num) num) (round num)]\n      [(> (abs (- num (round num)))\
    \ (abs (- num (floor num)))) (floor num)]\n      [else (round num)])))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp27a5cmll.rkt:30:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp27a5cmll.rkt:31:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp27a5cmll.rkt:32:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpn6z5zpfm.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpn6z5zpfm.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpn6z5zpfm.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp__6f0s0d.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp__6f0s0d.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp__6f0s0d.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (string-append (integer->string (round (string->number value))) \"\")))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmzsfm4gf.rkt:17:34: integer->string: unbound identifier\n  in:\
    \ integer->string\n  location...:\n   /tmp/tmpmzsfm4gf.rkt:17:34\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(>\
    \ (string->number value) 0)\n     (integer->string (round (string->number value)))]\n\
    \    [(< (string->number value) 0)\n     (integer->string (round (string->number\
    \ value)))]\n    [else (integer->string (round (string->number value)))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphxfce4hl.rkt:19:6: integer->string: unbound identifier\n  in: integer->string\n\
    \  location...:\n   /tmp/tmphxfce4hl.rkt:19:6\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let-values ([(whole\
    \ frac) (values (quotient (string->number value) 1)\n                        \
    \             (remainder (string->number value) 1))])\n    (if (< frac 0.5)\n\
    \        whole\n        (+ whole 1))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnshlfb3o.rkt:29:4\n\
    \nquotient: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnshlfb3o.rkt:30:4\n\
    \nquotient: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnshlfb3o.rkt:31:4\n\
    \nquotient: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round\
    \ n)\n    (cond ((> n 0) (cond ((>= n (+ 0.5 (floor n)))\n                   \
    \       (floor n))\n                         (else (floor n))))\n          ((<\
    \ n 0) (cond ((<= n (- 0.5 (floor n)))\n                          (floor n))\n\
    \                         (else (floor n))))\n          (else (floor n))))\n \
    \ (round (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq5s92n79.rkt:33:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpq5s92n79.rkt:34:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpq5s92n79.rkt:35:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    ((string=?\
    \ value \"0\")\n     0)\n    ((string-contains value \".\")\n     (round (string->number\
    \ value)))\n    (else\n     (string->number value))))\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx__3940t.rkt:20:6: string-contains: unbound identifier\n  in: string-contains\n\
    \  location...:\n   /tmp/tmpx__3940t.rkt:20:6\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string=?\
    \ \".\" (substring value (sub1 (string-length value))))\n      (string->number\
    \ (substring value 0 (sub1 (string-length value))))\n      (string->number (substring\
    \ value 0 (sub1 (string-length value))))))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpoawcou13.rkt:25:4\n\
    actual:     1\nexpected:   10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpoawcou13.rkt:26:4\nactual:     14.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpoawcou13.rkt:27:4\nactual:     -15.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpoawcou13.rkt:28:4\nactual:     15.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpoawcou13.rkt:29:4\nactual:     #f\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (exact->inexact\
    \ (round (string->number value))))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp19a4_a74.rkt:23:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp19a4_a74.rkt:24:4\nactual:\
    \     14.0\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp19a4_a74.rkt:25:4\nactual:     -16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp19a4_a74.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp19a4_a74.rkt:27:4\nactual:     0.0\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5hynuu9c.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5hynuu9c.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5hynuu9c.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmps4yei9v9.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmps4yei9v9.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmps4yei9v9.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfab6y29t.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfab6y29t.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpfab6y29t.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkax3dvg6.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkax3dvg6.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkax3dvg6.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_pgeau3m.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_pgeau3m.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_pgeau3m.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(>\
    \ value 0) (round value)]\n    [(< value 0) (round value)]\n    [else 0]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp37jf1a01.rkt:27:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp37jf1a01.rkt:28:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp37jf1a01.rkt:29:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp37jf1a01.rkt:30:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp37jf1a01.rkt:31:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(integer?\
    \ value) value]\n    [(> (abs value) (abs (round value)))\n     (if (> value 0)\
    \ (round value) (floor value))]\n    [else (if (> value 0) (ceiling value) (round\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdean3s90.rkt:28:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdean3s90.rkt:29:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdean3s90.rkt:30:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdean3s90.rkt:31:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdean3s90.rkt:32:4\n\
    \nabs: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (equal? (string-length\
    \ value) 1)\n      (string->number value)\n      (let ((first-digit (string-ref\
    \ value 0))\n            (other-digits (substring value 1 (string-length value))))\n\
    \        (string->number (string-append first-digit \n                       \
    \                 (if (positive? (string->number other-digits))\n            \
    \                                \"1\" \"0\"))))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf0dqc502.rkt:30:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: #\\1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf0dqc502.rkt:31:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: #\\1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf0dqc502.rkt:32:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: #\\-\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf0dqc502.rkt:33:4\n\
    \nstring-append: contract violation\n  expected: string?\n  given: #\\1\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb7c6_owo.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpb7c6_owo.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpb7c6_owo.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3f7zrqmw.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3f7zrqmw.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3f7zrqmw.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_w4b9jyo.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_w4b9jyo.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_w4b9jyo.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_w4b9jyo.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_w4b9jyo.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (integer->string\
    \ (round (string->number value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpiv93mfpk.rkt:17:3: integer->string: unbound identifier\n  in: integer->string\n\
    \  location...:\n   /tmp/tmpiv93mfpk.rkt:17:3\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hcxrqw2.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_hcxrqw2.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_hcxrqw2.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(= (string-length\
    \ value) 0) value]\n        [(equal? (substring value -1) \".\")\n         (closest_integer\
    \ (substring value 0 -1))]\n        [(and (equal? (substring value -2) \".5\"\
    )\n              (equal? (string-ref value 0) #\\-))\n         (string->number\
    \ (substring value 0 -2))]\n        [(equal? (substring value -2) \".5\")\n  \
    \       (string->number (substring value 0 -2))]\n        [(= (string->number\
    \ (substring value -1)) 5)\n         (closest_integer (substring value 0 -1))]\n\
    \        [(and (equal? (string-ref value 0) #\\-))\n         (string->number (substring\
    \ value 0 -1))]\n        [else (string->number (substring value 0 -1))]))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp__wuvaue.rkt:36:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp__wuvaue.rkt:37:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp__wuvaue.rkt:38:4\n\nsubstring:\
    \ contract violation\n  expected: exact-nonnegative-integer?\n  given: -1\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp__wuvaue.rkt:39:4\n\
    \nsubstring: contract violation\n  expected: exact-nonnegative-integer?\n  given:\
    \ -1\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp__wuvaue.rkt:40:4\n\nsubstring: contract violation\n  expected:\
    \ exact-nonnegative-integer?\n  given: -1\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (is-integer?\
    \ value)\n    (not (string-contains? value #\\.)))\n  (define (str->int str)\n\
    \    (string->number str))\n  (define (str->flt str)\n    (string->number str))\n\
    \  (define (neg? x)\n    (if (string-contains? x #\\- ) #t #f))\n  (define (truncate\
    \ x)\n    (quotient x 1))\n  (cond\n    [(is-integer? value) (str->int value)]\n\
    \    [(neg? value) (- (truncate (str->flt value)))]\n    [else (truncate (str->flt\
    \ value))]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphgru2n5e.rkt:37:4\n\
    \nstring-contains?: contract violation\n  expected: string?\n  given: #\\.\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphgru2n5e.rkt:38:4\n\
    \nstring-contains?: contract violation\n  expected: string?\n  given: #\\.\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphgru2n5e.rkt:39:4\n\
    \nstring-contains?: contract violation\n  expected: string?\n  given: #\\.\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphgru2n5e.rkt:40:4\n\
    \nstring-contains?: contract violation\n  expected: string?\n  given: #\\.\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmphgru2n5e.rkt:41:4\n\
    \nstring-contains?: contract violation\n  expected: string?\n  given: #\\.\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp93oqf239.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp93oqf239.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp93oqf239.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp93oqf239.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp93oqf239.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (validate-number\
    \ value)\n    (cond ((or (eq? \"\" value) (not (number? (string->number value))))\
    \ #f)\n          (else #t)))\n  (define (round-away-from-zero value)\n    (cond\
    \ ((< value 0) (floor value))\n          (else (ceiling value))))\n  (cond ((validate-number\
    \ value) (round-away-from-zero (string->number value)))\n        (else #f)))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm1kj1ul1.rkt:31:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpm1kj1ul1.rkt:32:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpm1kj1ul1.rkt:33:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(>\
    \ value 0) (+ 0.5 (floor value))]\n    [(< value 0) (- 0.5 (floor (- value)))]\n\
    \    [else 0]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnu9vj2j9.rkt:27:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnu9vj2j9.rkt:28:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnu9vj2j9.rkt:29:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnu9vj2j9.rkt:30:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnu9vj2j9.rkt:31:4\n\
    \n>: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string-suffix?\
    \ \".0\" value)\n      (string->number value)\n      (string->number\n       (string-append\n\
    \        (string-append\n         (substring value 0 (string-index value #\\.))\n\
    \         (string-append\n          (cond\n            [(> (string->number (substring\
    \ value (add1 (string-index value #\\.)) (add1 (string-index value #\\.)))) 0)\
    \ \"\"]\n            [(< (string->number (substring value (add1 (string-index\
    \ value #\\.)) (add1 (string-index value #\\.)))) 0) \"-\"])\n          (string-append\n\
    \           (integer->string\n            (cond\n              [(< (string->number\
    \ (substring value (add1 (string-index value #\\.)) (add1 (string-index value\
    \ #\\.)))) 5) 0]\n              [(> (string->number (substring value (add1 (string-index\
    \ value #\\.)) (add1 (string-index value #\\.)))) 5) 1]\n              [(= (string->number\
    \ (substring value (add1 (string-index value #\\.)) (add1 (string-index value\
    \ #\\.)))) 5)\n               (cond\n                 [(> (string->number (substring\
    \ value (add1 (add1 (string-index value #\\.))) (add1 (add1 (string-index value\
    \ #\\.))))) 0) 1]\n                 [(< (string->number (substring value (add1\
    \ (add1 (string-index value #\\.))) (add1 (add1 (string-index value #\\.)))))\
    \ 0) 0]\n                 [(= (string->number (substring value (add1 (add1 (string-index\
    \ value #\\.))) (add1 (add1 (string-index value #\\.))))) 0)\n               \
    \   (cond\n                    [(> (string->number (substring value (add1 (add1\
    \ (add1 (string-index value #\\.)))) (add1 (add1 (add1 (string-index value #\\\
    .)))))) 0) 1]\n                    [(< (string->number (substring value (add1\
    \ (add1 (add1 (string-index value #\\.)))) (add1\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2b7x9y5p.rkt:39:103: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 40\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (signum\
    \ x)\n    (if (and (exact? x) (> x 0)) 1 -1))\n  (define (ceiling x)\n    (signum\
    \ x\n            (if (negative? x)\n                (floor x)\n              \
    \  (exact->inexact (add1 (inexact->exact (floor x)))))))\n  (define (ceiling-frac\
    \ x)\n    (signum x\n            (if (negative? x)\n                (floor-frac\
    \ x)\n                (add1 (floor-frac x)))))\n  (if (integer? value)\n     \
    \ value\n      (if (not (numerator (fraction value)))\n          (ceiling value)\n\
    \          (ceiling-frac value))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_rmz3jic.rkt:27:17: floor-frac: unbound identifier\n  in: floor-frac\n\
    \  location...:\n   /tmp/tmp_rmz3jic.rkt:27:17\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpukdwybqn.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpukdwybqn.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpukdwybqn.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpukdwybqn.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpukdwybqn.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((number\
    \ (string->number value)))\n    (if (&lt;= (number-&gt;string number) value)\n\
    \        (floor number)\n        (ceiling number))))\n</code>\nCode is working\
    \ fine but it is not possible to use <code>number-&gt;string</code> for comparing\
    \ two strings. How to compare two strings correctly in this case?\n\n\nA:\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmprvopbq09.rkt:16:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 21\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(string=?\
    \ value \"0\") 0]\n        [(string=? (substring value 0 1) \"-\")\n         (substring\
    \ (number->string\n                     (- (round (string->number value)))) 1)]\n\
    \        [else (number->string (round (string->number value)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmprqwbbgmh.rkt:28:4\n\
    actual:     \"10\"\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmprqwbbgmh.rkt:29:4\nactual:\
    \     \"14.0\"\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmprqwbbgmh.rkt:30:4\nactual:     \"\
    6.0\"\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmprqwbbgmh.rkt:31:4\nactual:     \"\
    15.0\"\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([x (string->number\
    \ value)]\n         [y (if (negative? x) (ceiling x) (floor x))])\n    y))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpra7zizyh.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpra7zizyh.rkt:28:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpra7zizyh.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmposeqq69u.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmposeqq69u.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmposeqq69u.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round_away_from_zero\
    \ num)\n    (cond ((and (positive? num) (even? (round num))) (- (round num) 1))\n\
    \          ((and (positive? num) (odd? (round num))) (round num))\n          ((and\
    \ (negative? num) (even? (round num))) (round num))\n          ((and (negative?\
    \ num) (odd? (round num))) (- (round num) 1))))\n  (round_away_from_zero (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjox1vv3q.rkt:29:4\n\
    actual:     9\nexpected:   10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpjox1vv3q.rkt:30:4\nactual:     13.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpjox1vv3q.rkt:31:4\nactual:     -16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpjox1vv3q.rkt:32:4\nactual:     15.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpjox1vv3q.rkt:33:4\nactual:     #<void>\n\
    expected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define n (string->number\
    \ value))\n  (if (negative? n)\n      (- (exact->inexact (floor n)))\n      (exact->inexact\
    \ (ceiling n))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp7s9avbkh.rkt:27:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp7s9avbkh.rkt:28:4\nactual:\
    \     15.0\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp7s9avbkh.rkt:29:4\nactual:     16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp7s9avbkh.rkt:30:4\nactual:     16.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp7s9avbkh.rkt:31:4\nactual:     0.0\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define n (string->number\
    \ value))\n  (if (exact-integer? n)\n      n\n      (if (negative? n)\n      \
    \    (if (&lt; n (- (floor n) 0.5))\n              (floor n)\n              (ceiling\
    \ n))\n          (if (&lt; n (- (ceiling n) 0.5))\n              (floor n)\n \
    \             (ceiling n)))))\n</code>\nIs there a simpler, more idiomatic way\
    \ to achieve this?\n\n\nA:\n\nI would say:\n<code>(define (closest-integer x)\n\
    \  (if (positive? x)\n      (floor (+ x 0.5))\n      (ceiling (- x 0.5))))\n</code>\n\
    You don't need the <code>exact-integer?</code> check because in Racket there are\
    \ only exact integers, and they print as such. For example:\n<code>(closest-integer\
    \ 0.5)\n=&gt; 1\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpsdxawbzw.rkt:18:2: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 27\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-away-from-zero\
    \ n)\n    (if (< n 0)\n        (ceiling n)\n        (floor n)))\n  (round-away-from-zero\
    \ (string->number value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpindrwxv6.rkt:28:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpindrwxv6.rkt:29:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpindrwxv6.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpyjw5d8qo.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpyjw5d8qo.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpyjw5d8qo.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjb116uyn.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpjb116uyn.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpjb116uyn.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((not (real?\
    \ value)) #f)\n        ((= 0 (remainder value 1)) (string->number value))\n  \
    \      ((< (remainder value 1) 0) (floor value))\n        (else (ceiling value))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpih7g4xah.rkt:27:4\n\
    actual:     #f\nexpected:   10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpih7g4xah.rkt:28:4\nactual:     #f\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpih7g4xah.rkt:29:4\nactual:     #f\nexpected:\
    \   -16\n--------------------\n--------------------\nFAILURE\nname:       check-equal?\n\
    location:   /tmp/tmpih7g4xah.rkt:30:4\nactual:     #f\nexpected:   15\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpih7g4xah.rkt:31:4\n\
    actual:     #f\nexpected:   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmph046k7y2.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmph046k7y2.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmph046k7y2.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest\
    \ value1 value2)\n    (if (<= (abs (- value value1)) (abs (- value value2)))\n\
    \        value1\n        value2))\n  (if (not (string? value))\n      'ERROR\n\
    \      (if (not (number? (string->number value)))\n          'ERROR\n        \
    \  (if (eq? (remainder (string->number value) 1) 0)\n              (string->number\
    \ value)\n              (closest (round (string->number value)) (round (string->number\
    \ value) 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nhnk1qm.rkt:35:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nhnk1qm.rkt:36:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2nhnk1qm.rkt:37:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(and (number?\
    \ value) (< 0 value)) (round value)]\n        [(and (number? value) (> 0 value))\
    \ (round value)]\n        [(and (number? value) (= 0 value)) 0]\n        [(= 0.5\
    \ (sub1 (modulo value 1))) (sub1 (round value))]\n        [(= -0.5 (sub1 (modulo\
    \ value 1))) (add1 (round value))]\n        [else (round value)]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbuasjce.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbuasjce.rkt:30:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbuasjce.rkt:31:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbuasjce.rkt:32:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbuasjce.rkt:33:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((< (real->decimal-string\
    \ value) \"0\")\n         (- (round (string->number value))))\n        (else (round\
    \ (string->number value)))))\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpasqym82r.rkt:25:4\n\
    \nreal->decimal-string: contract violation\n  expected: rational?\n  given: \"\
    10\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpasqym82r.rkt:26:4\n\nreal->decimal-string: contract violation\n\
    \  expected: rational?\n  given: \"14.5\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpasqym82r.rkt:27:4\n\nreal->decimal-string:\
    \ contract violation\n  expected: rational?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpasqym82r.rkt:28:4\n\
    \nreal->decimal-string: contract violation\n  expected: rational?\n  given: \"\
    15.3\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpasqym82r.rkt:29:4\n\nreal->decimal-string: contract violation\n\
    \  expected: rational?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (exact->inexact\
    \ (string->number value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5mgfqidm.rkt:24:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp5mgfqidm.rkt:25:4\nactual:\
    \     14.5\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp5mgfqidm.rkt:26:4\nactual:     -15.5\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmp5mgfqidm.rkt:27:4\nactual:     15.3\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmp5mgfqidm.rkt:28:4\nactual:     0.0\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"10\") 10]\n    [(string=? value \"15.3\") 15]\n    [(string=? value\
    \ \"14.5\") 15]\n    [(string=? value \"-14.5\") -15]\n    [else 0]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp9056oe3q.rkt:31:4\n\
    actual:     0\nexpected:   -16\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-integer-iter\
    \ value-itr first-digit rest-digits)\n    (if (zero? first-digit)\n        (if\
    \ (or (null? rest-digits)\n                (zero? (car rest-digits)))\n      \
    \      0\n            (closest-integer-iter (cdr value-itr)\n                \
    \                  (car value-itr)\n                                  (cdr value-itr)))\n\
    \        (if (null? rest-digits)\n            (if (zero? first-digit)\n      \
    \          0\n                (if (< first-digit 0)\n                    (cons\
    \ first-digit rest-digits)\n                    (cons (- first-digit 1) rest-digits)))\n\
    \            (if (= first-digit 5)\n                (if (zero? (car rest-digits))\n\
    \                    (if (< first-digit 0)\n                        (cons first-digit\
    \ rest-digits)\n                        (cons (- first-digit 1) rest-digits))\n\
    \                    (if (< first-digit 0)\n                        (cons first-digit\
    \ rest-digits)\n                        (cons (+ first-digit 1) rest-digits)))\n\
    \                (if (< first-digit 0)\n                    (cons first-digit\
    \ rest-digits)\n                    (cons (- first-digit 1) rest-digits))))))\n\
    \  (closest-integer-iter (string->list value)\n                        (string->number\
    \ (substring value 0 1))\n                        (string->list (substring value\
    \ 1))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfpuhxsq_.rkt:51:4\n\
    actual:     '(0 #\\0)\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfpuhxsq_.rkt:52:4\nactual:\
    \     '(0 #\\4 #\\. #\\5)\nexpected:   15\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpuhxsq_.rkt:53:4\n\nzero?:\
    \ contract violation\n  expected: number?\n  given: #f\n--------------------\n\
    --------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpfpuhxsq_.rkt:54:4\n\
    actual:     '(0 #\\5 #\\. #\\3)\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((val (string->number\
    \ value)))\n    (if (negative? val)\n        (floor val)\n        (ceiling val))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzwxxmfgk.rkt:28:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzwxxmfgk.rkt:29:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzwxxmfgk.rkt:30:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define result\
    \ (inexact->exact (round (string->number value))))\n  (if (integer? result)\n\
    \      result\n      (if (> result 0)\n          (add1 result)\n          (sub1\
    \ result))))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmppe42zxck.rkt:29:4\n\
    actual:     14\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    </code>\nWhen I enter the following into Dr. Racket:\n<code>(closest_integer \"\
    14.5\")\n</code>\nI get the following:\n<code>; \"14.5\" is not a number\n</code>\n\
    Why is this and how do I fix it? I tried using <code>number?</code> but I kept\
    \ getting errors.\n\n\nA:\n\nThe error message is in fact pretty self-explanatory:\
    \ <code>\"14.5\"</code> is not a number, it's a string. You can convert a string\
    \ to a number using <code>string-&gt;number</code>, but in your case you don't\
    \ need to do that, since <code>round</code> will do the conversion for you - just\
    \ remove the quotes from the value you're passing to <code>closest_integer</code>,\
    \ like this:\n<code>(closest_integer 14.5)\n=&gt; 15\n</code>\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzd5zcyn_.rkt:25:12: and: bad syntax\n  in: and\n  location...:\n\
    \   /tmp/tmpzd5zcyn_.rkt:25:12\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/qq-and-or.rkt:442:6\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/wrap-modbeg.rkt:46:4\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpuryvxuwk.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpuryvxuwk.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpuryvxuwk.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpan2aqpk3.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpan2aqpk3.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpan2aqpk3.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpan2aqpk3.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpan2aqpk3.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(= (floor\
    \ value) (ceiling value))\n         (floor value)]\n        [(> value 0)\n   \
    \      (ceiling value)]\n        [(< value 0)\n         (floor value)]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090weyn4.rkt:29:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090weyn4.rkt:30:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090weyn4.rkt:31:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090weyn4.rkt:32:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp090weyn4.rkt:33:4\n\
    \nfloor: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define value-floored\
    \ (inexact->exact (floor (string->number value))))\n  (define value-ceiled (inexact->exact\
    \ (ceiling (string->number value))))\n  (define value-current (string->number\
    \ value))\n  (cond ((= value-current value-floored) value-floored)\n        ((=\
    \ value-current value-ceiled) value-ceiled)\n        ((> (- value-current value-floored)\
    \ (- value-ceiled value-current)) value-ceiled)\n        (else value-floored)))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpu39m8436.rkt:31:4\n\
    actual:     14\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((num (string->number\
    \ value)))\n    (if (= (round num) (floor num))\n        (round num)\n       \
    \ (if (> num 0)\n            (floor num)\n            (ceiling num)))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpik9udmhp.rkt:30:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpik9udmhp.rkt:31:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpik9udmhp.rkt:32:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk3n5rwe3.rkt:23:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk3n5rwe3.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk3n5rwe3.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk3n5rwe3.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk3n5rwe3.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(string=?\
    \ (substring value -1) \"5\") (string->number (substring value 0 -1))]\n     \
    \   [(string=? (substring value -1) \"0\") (string->number value)]\n        [(string=?\
    \ (substring value -1) \"1\") (string->number (substring value 0 -1))]\n     \
    \   [(string=? (substring value -1) \"2\") (string->number (substring value 0\
    \ -1))]\n        [(string=? (substring value -1) \"3\") (string->number (substring\
    \ value 0 -1))]\n        [(string=? (substring value -1) \"4\") (string->number\
    \ (substring value 0 -1))]\n        [(string=? (substring value -1) \"6\") (string->number\
    \ (substring value 0 -1))]\n        [(string=? (substring value -1) \"7\") (string->number\
    \ (substring value 0 -1))]\n        [(string=? (substring value -1) \"8\") (string->number\
    \ (substring value 0 -1))]\n        [(string=? (substring value -1) \"9\") (string->number\
    \ (substring value 0 -1))]\n        [(< (substring value -1) \"5\") (string->number\
    \ (substring value 0 -1))]\n        [(> (substring value -1) \"5\") (string->number\
    \ (substring value 0 -1))]))\n```\n\n### Ignoring Case\n\n```#lang racket\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4jw5aifr.rkt:31:0: read-syntax: bad syntax `##`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (integer->string\n\
    \   (inexact->exact\n    (round\n     (string->number value)))))\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4vclawym.rkt:17:3: integer->string: unbound identifier\n  in: integer->string\n\
    \  location...:\n   /tmp/tmp4vclawym.rkt:17:3\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpc4xuxbvz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpc4xuxbvz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpc4xuxbvz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (closest-int\
    \ x)\n    (define (absolute x)\n      (if (< x 0)\n          (- x)\n         \
    \ x))\n    (define (square x)\n      (* x x))\n    (define (good-enough? y)\n\
    \      (< (absolute (- y (* x x))) 0.001))\n    (define (improve x)\n      (average\
    \ x (/ x y)))\n    (define (average x y)\n      (/ (+ x y) 2))\n    (define (sqrt-iter\
    \ x y)\n      (if (good-enough? y)\n          x\n          (sqrt-iter (improve\
    \ x) y)))\n    (sqrt-iter 1.0 x))\n  (define (round x)\n    (if (positive? x)\n\
    \        (floor x)\n        (ceiling x)))\n  (round (closest-int (string->number\
    \ value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpjn9jnycg.rkt:27:22: y: unbound identifier\n  in: y\n  location...:\n\
    \   /tmp/tmpjn9jnycg.rkt:27:22\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([input (string->number\
    \ value)])\n    (if (or (= (remainder input 1) 0) (= (remainder input 1) -0))\n\
    \        input\n        (if (> input 0)\n            (round input)\n         \
    \   (round input)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwekil5s.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwekil5s.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgwekil5s.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((positive?\
    \ value) (round value))\n        ((negative? value) (floor value))\n        (else\
    \ 0)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpopeuzkw4.rkt:26:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpopeuzkw4.rkt:27:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpopeuzkw4.rkt:28:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpopeuzkw4.rkt:29:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpopeuzkw4.rkt:30:4\n\
    \npositive?: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(=\
    \ (round value) value) (round value)]\n    [(&gt; value 0) (+ (round value) 1)]\n\
    \    [(&lt; value 0) (- (round value) 1)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp95yvm0gk.rkt:20:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 22\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ((value (string->number\
    \ value)))\n    (if (negative? (remainder value 1))\n        (round value)\n \
    \       (round value 1))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\")\
    \ 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpojyefvtr.rkt:27:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpojyefvtr.rkt:28:4\n\nremainder:\
    \ contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpojyefvtr.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpojyefvtr.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpojyefvtr.rkt:31:4\n\
    \nround: arity mismatch;\n the expected number of arguments does not match the\
    \ given number\n  expected: 1\n  given: 2\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcxj99puz.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcxj99puz.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpcxj99puz.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3075nu6d.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp3075nu6d.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp3075nu6d.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (round-up\
    \ value)\n    (let ([value-floor (floor value)])\n      (cond [(= 1 (abs (- value\
    \ value-floor)))\n             value-floor]\n            [else\n             (add1\
    \ value-floor)])))\n  (round-up (string->number value)))\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzta1si64.rkt:29:4\n\
    actual:     11\nexpected:   10\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzta1si64.rkt:30:4\nactual:     15.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpzta1si64.rkt:31:4\nactual:     -15.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpzta1si64.rkt:32:4\nactual:     16.0\n\
    expected:   15\n--------------------\n--------------------\nFAILURE\nname:   \
    \    check-equal?\nlocation:   /tmp/tmpzta1si64.rkt:33:4\nactual:     1\nexpected:\
    \   0\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj3kh0rr.rkt:23:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj3kh0rr.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj3kh0rr.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj3kh0rr.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj3kh0rr.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpraxhhr3a.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpraxhhr3a.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpraxhhr3a.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpwl8amt6t.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpwl8amt6t.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpwl8amt6t.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmip29qax.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmip29qax.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmip29qax.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmip29qax.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpmip29qax.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (is-negative\
    \ value)\n    (string-contains? value \"-\"))\n  (define (get-value-without-sign\
    \ value)\n    (if (is-negative value)\n        (substring value 1)\n        value))\n\
    \  (define (get-integer-part value)\n    (substring value 0 (string-index value\
    \ \".\")))\n  (define (get-decimal-part value)\n    (substring value (string-index\
    \ value \".\") (string-length value)))\n  (define (round-away-from-zero value)\n\
    \    (if (is-negative value)\n        (- (get-integer-part value))\n        (get-integer-part\
    \ value)))\n  (define (round-to-nearest value)\n    (if (> (string->number (get-decimal-part\
    \ value)) 5)\n        (+ (get-integer-part value) 1)\n        (get-integer-part\
    \ value)))\n  (if (string-contains? value \".\")\n      (round-to-nearest (get-value-without-sign\
    \ value))\n      (round-away-from-zero (get-value-without-sign value))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4a1ynk0d.rkt:24:24: string-index: unbound identifier\n  in: string-index\n\
    \  location...:\n   /tmp/tmp4a1ynk0d.rkt:24:24\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (string-trim value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdv5tkfkn.rkt:25:4\n\
    actual:     14.5\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpdv5tkfkn.rkt:26:4\nactual:\
    \     -15.5\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpdv5tkfkn.rkt:27:4\nactual:     15.3\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let ([val (string->number\
    \ value)])\n    (if (= val (floor val))\n        val\n        (if (and (> val\
    \ 0) (>= val 0.5))\n            (floor val)\n            (ceiling val)))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhflhb7k.rkt:30:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhflhb7k.rkt:31:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkhflhb7k.rkt:32:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (aux value)\n\
    \    (round (/ value 1.0)))\n  (aux (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxedlmymb.rkt:26:4\n\
    actual:     10.0\nexpected:   10\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpxedlmymb.rkt:27:4\nactual:\
    \     14.0\nexpected:   15\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpxedlmymb.rkt:28:4\nactual:     -16.0\n\
    expected:   -16\n--------------------\n--------------------\nFAILURE\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpxedlmymb.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (float->int\
    \ v)\n    (cond\n      [(and (positive? v)\n            (negative? (modulo v 1)))\n\
    \       (floor v)]\n      [(and (negative? v)\n            (positive? (modulo\
    \ v 1)))\n       (ceiling v)]\n      [else (round v)]))\n  (float->int (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmploabt6az.rkt:34:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmploabt6az.rkt:35:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmploabt6az.rkt:36:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj0q2oelf.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpj0q2oelf.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpj0q2oelf.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define input\
    \ (string->number value))\n  (if (= (remainder input 1) 0)\n      input\n    \
    \  (begin\n        (define (sign-int n)\n          (if (< n 0)\n             \
    \ -1\n              1))\n        (sign-int (round input)))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpyoiw5qjv.rkt:21:8: define: not allowed in an expression context\n\
    \  in: (define (sign-int n) (if (< n 0) -1 1))\n  location...:\n   /tmp/tmpyoiw5qjv.rkt:21:8\n\
    \  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/norm-define.rkt:9:4:\
    \ normalize-definition/mk-rhs\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/norm-define.rkt:165:4:\
    \ normalize-definition\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/private/kw.rkt:1117:2\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (format \"~a\" (round (string->number value)))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvt6p5zq9.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpvt6p5zq9.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpvt6p5zq9.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnu6o176d.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpnu6o176d.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpnu6o176d.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (eq? (value\
    \ -1) '-1)\n      (round (string->number value))\n      (round (string->number\
    \ value) (value -1))))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n \
    \   (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwxaykg4d.rkt:25:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: \"10\"\n--------------------\n--------------------\nERROR\n\
    name:       check-equal?\nlocation:   /tmp/tmpwxaykg4d.rkt:26:4\n\napplication:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: \"14.5\"\n--------------------\n--------------------\nERROR\nname:  \
    \     check-equal?\nlocation:   /tmp/tmpwxaykg4d.rkt:27:4\n\napplication: not\
    \ a procedure;\n expected a procedure that can be applied to arguments\n  given:\
    \ \"-15.5\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwxaykg4d.rkt:28:4\n\napplication: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwxaykg4d.rkt:29:4\n\
    \napplication: not a procedure;\n expected a procedure that can be applied to\
    \ arguments\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define pi (string->number\
    \ value))\n  (cond [(negative? pi) (- (round pi))]\n        [else (round pi)]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa1o2wb9u.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpa1o2wb9u.rkt:28:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpa1o2wb9u.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (not (integer?\
    \ (string->number value)))\n      (let* ((input (string->number value))\n    \
    \         (floor (floor input))\n             (ceiling (ceiling input)))\n   \
    \     (if (or (= floor ceiling)\n                (not (integer? floor))\n    \
    \            (not (integer? ceiling)))\n            (- ceiling 1)\n          \
    \  (if (< (- ceiling input) (- input floor))\n                ceiling\n      \
    \          floor)))\n      (string->number value)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_ah8uao9.rkt:36:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp_ah8uao9.rkt:37:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp_ah8uao9.rkt:38:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ value 0) (- (floor (- value)))]\n    [(= value 0) 0]\n    [else (ceiling value)]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwjtmq0vo.rkt:27:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwjtmq0vo.rkt:28:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwjtmq0vo.rkt:29:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwjtmq0vo.rkt:30:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwjtmq0vo.rkt:31:4\n\
    \n<: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    ((not\
    \ (string? value)) (error \"Input must be a string!\"))\n    ((not (number? (string->number\
    \ value))) (error \"Input must be a number!\"))\n    (else (round (string->number\
    \ value)))))\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhrsv5vi.rkt:27:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpkhrsv5vi.rkt:28:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpkhrsv5vi.rkt:29:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define val (string->number\
    \ value))\n  (let ([l (floor val)]\n        [r (ceiling val)])\n    (cond [(=\
    \ val l) l]\n          [(= val r) r]\n          [(< val 0) (if (> val (* 0.5 (-\
    \ l r))) l r)]\n          [(> val 0) (if (> val (* 0.5 (- r l))) r l)])))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmphsi78k3v.rkt:31:4\n\
    actual:     15.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmphsi78k3v.rkt:32:4\nactual:\
    \     -15.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmphsi78k3v.rkt:33:4\nactual:     16.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzwfefxu4.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpzwfefxu4.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpzwfefxu4.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp7vs5nuvb.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp7vs5nuvb.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp7vs5nuvb.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (string->number value))\n      (- (round (string->number value)))\n      (round\
    \ (string->number value))))\n```\n\n```racket\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: "'`````racket\n"
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpknnmmlyz.rkt:29:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpknnmmlyz.rkt:30:4\nactual:\
    \     16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpknnmmlyz.rkt:31:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([parsed\
    \ (string->number value)]\n         [floored (inexact->exact (floor parsed))]\n\
    \         [ceiled (inexact->exact (ceiling parsed))])\n    (cond\n      [(zero?\
    \ (exact-floor (- parsed floored))) floored]\n      [(zero? (exact-floor (- parsed\
    \ ceiled))) ceiled]\n      [(> (abs (round (abs parsed))) (abs parsed)) (exact->inexact\
    \ (exact-floor parsed))]\n      [else (exact->inexact (exact-ceiling parsed))])))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpec8u3dv0.rkt:32:4\n\
    actual:     14\nexpected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((> (remainder\
    \ value 1) 0.5)\n\t (round value))\n\t((= (remainder value 1) 0.5)\n\t (cond ((>\
    \ (remainder (round value) 2) 0)\n\t\t(round value))\n\t       ((= (remainder\
    \ (round value) 2) 0)\n\t\t(+ (round value) 1))))\n\t(else (round value))))\n\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu23o1fiz.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu23o1fiz.rkt:32:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu23o1fiz.rkt:33:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu23o1fiz.rkt:34:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpu23o1fiz.rkt:35:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (let* ([number\
    \ (string->number value)]\n         [decimal-part (remainder number 1)])\n   \
    \ (if (>= decimal-part 0.5)\n        (ceiling number)\n        (floor number))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbuuel96v.rkt:29:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbuuel96v.rkt:30:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbuuel96v.rkt:31:4\n\
    \nremainder: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (negative?\
    \ (real->rational (string->number value)))\n      (string->number (number->string\
    \ (ceiling (string->number value))))\n      (string->number (number->string (floor\
    \ (string->number value))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp3pwtupul.rkt:17:18: real->rational: unbound identifier\n  in: real->rational\n\
    \  location...:\n   /tmp/tmp3pwtupul.rkt:17:18\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcm1iom23.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcm1iom23.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcm1iom23.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcm1iom23.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcm1iom23.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(<\
    \ (string->number value) 0) (- (string->number value))]\n    [else (string->number\
    \ value)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0mfbz7oa.rkt:27:4\n\
    actual:     14.5\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp0mfbz7oa.rkt:28:4\nactual:\
    \     15.5\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp0mfbz7oa.rkt:29:4\nactual:     15.3\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (helper\
    \ value)\n    (cond\n      ((&lt;= (abs (- (string-&gt;number value) (floor (string-&gt;number\
    \ value)))) 0.5) (floor (string-&gt;number value)))\n      (else (ceiling (string-&gt;number\
    \ value)))))\n  (helper value))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpwlzuhj08.rkt:20:12: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 23\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    </code>\nI am unsure how to implement the round away from zero part of the question.\
    \ The rest I think I can do, but I don't understand what is meant by 'round away\
    \ from zero'. The examples that are provided don't seem to help.\nThank you for\
    \ your time and consideration.\n\n\nA:\n\nYou can use the <code>round</code> procedure\
    \ from Racket to get the rounded value of a number. It rounds to the nearest integer,\
    \ as you can see in this example:\n<code>(round -15.5)\n=&gt; -15\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdrsuis33.rkt:19:165: read-syntax: illegal use of `.`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (string->number\
    \ (number->string (round (string->number value)))))\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp36ueza3v.rkt:24:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp36ueza3v.rkt:25:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp36ueza3v.rkt:26:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond ((and (=\
    \ (remainder value 1) 0)\n              (= (floor value) (ceiling value)))\n \
    \        (round value))\n        ((and (= (remainder value 1) 0)\n           \
    \   (/= (floor value) (ceiling value)))\n         (cond ((positive? value)\n \
    \               (floor value))\n               ((negative? value)\n          \
    \      (ceiling value))))\n        ((and (/= (remainder value 1) 0)\n        \
    \      (positive? value))\n         (round value))\n        ((and (/= (remainder\
    \ value 1) 0)\n              (negative? value))\n         (round value))))\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppxt54j8v.rkt:21:15: /=: unbound identifier\n  in: /=\n  location...:\n\
    \   /tmp/tmppxt54j8v.rkt:21:15\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7uz5weok.rkt:24:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"10\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7uz5weok.rkt:25:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"14.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7uz5weok.rkt:26:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"-15.5\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7uz5weok.rkt:27:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"15.3\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7uz5weok.rkt:28:4\n\
    \nround: contract violation\n  expected: real?\n  given: \"0\"\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (= 0.0 (modulo\
    \ (string->number value) 1.0))\n      (string->number value)\n      (round (string->number\
    \ value))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy1vtx_es.rkt:27:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 14.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy1vtx_es.rkt:28:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: -15.5\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy1vtx_es.rkt:29:4\n\
    \nmodulo: contract violation\n  expected: integer?\n  given: 15.3\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define floatvalue\
    \ (string->number value))\n  (round floatvalue))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgnuf04kz.rkt:26:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpgnuf04kz.rkt:27:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpgnuf04kz.rkt:28:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmp06016m1q.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmp06016m1q.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmp06016m1q.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcuajkqy7.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcuajkqy7.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpcuajkqy7.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round (string->number\
    \ value)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ closest_integer))\n    (check-equal? (candidate \"10\") 10)\n    (check-equal?\
    \ (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\") -16)\n   \
    \ (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate \"0\")\
    \ 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcoouxmh5.rkt:25:4\n\
    actual:     14.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmpcoouxmh5.rkt:26:4\nactual:\
    \     -16.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmpcoouxmh5.rkt:27:4\nactual:     15.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(integer?\
    \ value) value]\n        [(= (round value) value) value]\n        [else (round\
    \ value)]))\nclosest_integer\n</code>\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdlcx8zls.rkt:21:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmpdlcx8zls.rkt:21:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (round value))\n\
    </code>\nExercise 2:\n<code>#lang racket\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\"\
    ) 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate\
    \ \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal?\
    \ (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphf38xg4t.rkt:18:0: </code>: unbound identifier\n  in: </code>\n\
    \  location...:\n   /tmp/tmphf38xg4t.rkt:18:0\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond\n    [(string=?\
    \ value \"0\") (string->number value)]\n    [(string=? value \"0.0\") (string->number\
    \ value)]\n    [(string=? value \"\") (string->number value)]\n    [(string=?\
    \ value \".\") (string->number value)]\n    [(string=? value \".\" \"\") (string->number\
    \ value)]\n    [(string=? value \"-\") (string->number value)]\n    [(string=?\
    \ value \"-.\" \"-\") (string->number value)]\n    [(string=? value \"0.\" \"\
    0\") (string->number value)]\n    [(string=? value \"-0.\" \"-0\") (string->number\
    \ value)]\n    [(string=? value \"0.0\") (string->number value)]\n    [(string=?\
    \ value \"-0.0\") (string->number value)]\n    [(string=? value \".\") (string->number\
    \ value)]\n    [(string=? value \"-.\") (string->number value)]\n    [(string=?\
    \ value \" \") (string->number value)]\n    [(string=? value \"-\") (string->number\
    \ value)]\n    [(string=? value \"+\") (string->number value)]\n    [(string=?\
    \ value \"--\") (string->number value)]\n    [(string=? value \"++\") (string->number\
    \ value)]\n    [(string=? value \"--0\") (string->number value)]\n    [(string=?\
    \ value \"++0\") (string->number value)]\n    [(string=? value \"++0.0\") (string->number\
    \ value)]\n    [(string=? value \"--0.0\") (string->number value)]\n    [(string=?\
    \ value \"+++\") (string->number value)]\n    [(string=? value \"+++0\") (string->number\
    \ value)]\n    [(string=? value \"+++0.0\") (string->number value)]\n    [(string=?\
    \ value \"---\") (string->number value)]\n    [(string=? value \"---0\") (string->number\
    \ value)]\n    [(string=? value \"---0.0\") (string->number value)]\n    [(string=?\
    \ value \"++.\") (string->number value)]\n    [(string=? value \"--.\") (string->number\
    \ value)]\n    [(string=\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate closest_integer))\n    (check-equal? (candidate \"10\") 10)\n\
    \    (check-equal? (candidate \"14.5\") 15)\n    (check-equal? (candidate \"-15.5\"\
    ) -16)\n    (check-equal? (candidate \"15.3\") 15)\n    (check-equal? (candidate\
    \ \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp852nl268.rkt:48:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 49\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (if (string-match\
    \ \"\\\\.5$\" value)\n      (if (string-match \"^-\" value)\n          (- (string->number\
    \ value) 1)\n          (string->number value))\n      (round (string->number value))))\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
    \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
    ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
    \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpwfiwbwec.rkt:17:7: string-match: unbound identifier\n  in: string-match\n\
    \  location...:\n   /tmp/tmpwfiwbwec.rkt:17:7\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (cond [(empty?\
    \ value) \"\"]\n        [(eq? (first value) #\\.) (closest_integer (rest value))]\n\
    \        [(eq? (first value) #\\-)(string-append (list #\\-)(closest_integer (rest\
    \ value)))]\n        [(empty? (rest value)) (list (first value))]\n        [(>=\
    \ (string->number (list (first value) (second value)))\n             (string->number\
    \ (list (first value) #\\. #5)))\n         (string-append (list (first value))\
    \ (closest_integer (rest (rest value))))]\n        [else (string-append (list\
    \ (first value)) (closest_integer (rest (rest value))))]))\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp33p9qz3s.rkt:22:53: read-syntax: bad syntax `#5)`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; Create a function that takes a value (string) representing\
    \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
    ;; from two integers, round it away from zero.\n;; Examples\n;; >>> closest_integer(\"\
    10\")\n;; 10\n;; >>> closest_integer(\"15.3\")\n;; 15\n;; Note:\n;; Rounding away\
    \ from zero means that if the given number is equidistant\n;; from two integers,\
    \ the one you should return is the one that is the\n;; farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"\
    -14.5\") should return -15.\n(define (closest_integer value)\n  (define (is_positive?\
    \ v) (>= v 0))\n  (define (is_negative? v) (< v 0))\n  (define (is_integer? v)\
    \ (= (round v) v))\n  (define (half-integer n)\n    (round (floor (/ (+ n 1) 2))))\n\
    \  (define (closest-integer-helper n)\n    (if (is_integer? n)\n        n\n  \
    \      (if (is_positive? n)\n            (half-integer n)\n            (half-integer\
    \ (- n)))))\n  (closest-integer-helper (string->number value)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n    (check-equal?\
    \ (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\") 15)\n    (check-equal?\
    \ (candidate \"-15.5\") -16)\n    (check-equal? (candidate \"15.3\") 15)\n   \
    \ (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nFAILURE\nname:       check-equal?\nlocation:   /tmp/tmptnyie6mx.rkt:36:4\n\
    actual:     7.0\nexpected:   15\n--------------------\n--------------------\n\
    FAILURE\nname:       check-equal?\nlocation:   /tmp/tmptnyie6mx.rkt:37:4\nactual:\
    \     8.0\nexpected:   -16\n--------------------\n--------------------\nFAILURE\n\
    name:       check-equal?\nlocation:   /tmp/tmptnyie6mx.rkt:38:4\nactual:     8.0\n\
    expected:   15\n--------------------\n"
  exit_code: 0
  status: Exception
