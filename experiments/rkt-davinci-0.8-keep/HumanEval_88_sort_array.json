{
  "name": "HumanEval_88_sort_array",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Given an array of non-negative integers, return a copy of the given array after sorting,\n;; you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n;; or sort it in descending order if the sum( first index value, last index value) is even.\n;; Note:\n;; * don't change the given array.\n;; Examples:\n;; * sort_array([]) => []\n;; * sort_array([5]) => [5]\n;; * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n;; * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n(define (sort_array array)\n",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list 5)) (list 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3 4 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0))\n    (check-equal? (candidate (list 2 1)) (list 1 2))\n    (check-equal? (candidate (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87))\n    (check-equal? (candidate (list 21 14 23 11)) (list 23 21 14 11))\n))\n\n(test-humaneval)",
  "completions": [
    "  (if (empty? array)\n      '()\n      (sort (array-&gt;list array) &lt; #:key (lambda (x) (if (odd? (+ (car array) (car (reverse array)))) x (- x))))))\n</code>\nI'm getting an error. Which is:\n<code>Expected result: '(0 1 2 3 4 5)\nActual result: '(4 3 2 1 0 5)\n</code>\nI'm sure there's a better way to do this. Any suggestions?\n\n\nA:\n\nIf you can use a small amount of mutability, then you can construct the list in the correct order and then sort it, without the need to worry about keeping track of the first and last elements.\n",
    "  (define (merge a b)\n    (cond [(empty? a) b]\n          [(empty? b) a]\n          [(< (first a) (first b)) (cons (first a) (merge (rest a) b))]\n          [else (cons (first b) (merge a (rest b)))]))\n  (define (merge-sort arr)\n    (if (< (length arr) 2)\n        arr\n        (let* ([split (quotient (length arr) 2)]\n               [a (merge-sort (slice arr 0 split))]\n               [b (merge-sort (slice arr split))])\n          (merge a b))))\n  (let* ([odd? (odd? (+ (first array) (last array)))]\n         [sorted (merge-sort array)])\n    (if odd?\n        sorted\n        (reverse sorted))))\n",
    "  (if (= (length array) 0)\n      '()\n      (if (= (length array) 1)\n          array\n          (sort_array_helper array 0 (sub1 (length array))\n                             (< (modulo (+ (list-ref array 0) (list-ref array (sub1 (length array)))) 2)\n                                0)))))\n",
    "  (if (null? array) '()\n      (let ((odd_nums (filter odd? array))\n            (even_nums (filter even? array)))\n        (if (odd? (+ (car array) (car (reverse array))))\n            (append (sort < odd_nums) (sort > even_nums))\n            (append (sort > odd_nums) (sort < even_nums))))))\n",
    "  (define (helper array n)\n    (if (null? array) (list)\n        (let ([x (car array)])\n          (append (helper (cdr array) n) (list x)))))\n  (if (= 0 (modulo (+ (first array) (last array)) 2))\n      (helper array -1)\n      (helper array 1)))\n",
    "  (if (empty? array)\n      '()\n      (let loop ([odd #t] [even #t] [index 0] [index-max (sub1 (length array))])\n        (cond [(< index index-max)\n               (let ([first (array-ref array index)]\n                     [last (array-ref array (sub1 index-max))])\n                 (if (odd? (+ first last))\n                     (if odd (loop #f even (add1 index) (sub1 index-max))\n                         (loop odd #f (add1 index) (sub1 index-max)))\n                     (if even (loop odd #f (add1 index) (sub1 index-max))\n                         (loop odd even (add1 index) (sub1 index-max)))))\n               (if even (reverse array) array)]\n              [else (if even (reverse array) array)]))))\n",
    "  (if (null? array)\n      '()\n      (cond ((= (modulo (+ (car array) (last array)) 2) 0)\n             (reverse array))\n            (else\n             array))))\n",
    "  (define (is_even? n)\n    (= (remainder n 2) 0))\n  (define (sum lst)\n    (if (null? lst)\n        0\n        (+ (car lst) (sum (cdr lst)))))\n  (define (sort-ascending? lst)\n    (let ([first (car lst)]\n          [last (car (reverse lst))])\n      (is_even? (+ first last))))\n  (define (merge lst1 lst2)\n    (cond\n      [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [(> (car lst1) (car lst2)) (cons (car lst2) (merge lst1 (cdr lst2)))]\n      [else (cons (car lst1) (merge (cdr lst1) lst2))]))\n  (define (merge-sort lst)\n    (let ([len (length lst)])\n      (cond\n        [(= len 1) lst]\n        [else (merge (merge-sort (take lst (/ len 2)))\n                     (merge-sort (drop lst (/ len 2))))])))\n  (define (sort lst asc?)\n    (if asc?\n        (merge-sort lst)\n        (reverse (merge-sort lst))))\n  (sort array (sort-ascending? array)))\n```\n\n## Example Tests\n\n### Racket\n\n```racket\n#lang racket\n",
    "  (cond [(null? array) '()]\n        [(< (length array) 2) array]\n        [else (sort-helper array 0)]))\n",
    "  (define (is-odd? n) (= 1 (remainder n 2)))\n  (define (head arr) (car arr))\n  (define (tail arr) (cdr arr))\n  (define (last arr) (car (reverse arr)))\n  (define (sum a b) (+ a b))\n  (cond\n    [(empty? array) array]\n    [(empty? (tail array)) array]\n    [(is-odd? (sum (head array) (last array))) (reverse (sort array <))]\n    [else (sort array >)]))\n```\n\n> \uc774\ub807\uac8c \uc2e4\uc81c\ub85c \ud504\ub85c\uadf8\ub798\ubc0d\ud574\ubcf4\uba74, \uadf8\ub7f0 \uacbd\uc6b0\uac00 \uc788\uad6c\ub098 \ud558\ub294 \uc0dd\uac01\uc774 \ub4e4\uc5c8\ub2e4. \uc774\ub7f0 \uacbd\uc6b0\uc758 \uc218\ub97c \ubaa8\ub450 \uc0dd\uac01\ud558\uba74\uc11c \ud480\uac8c \ub418\ub294 \uac83\uc774 \uc544\ub2c8\ub77c, \uae30\ubcf8\uc801\uc778 \ud504\ub85c\uadf8\ub798\ubc0d \uc6d0\ub9ac\ub97c \uac00\uc9c0\uace0 \uc788\uc73c\uba74 \ub41c\ub2e4. \uc774\ub807\uac8c \ud480\uac8c \ub418\uba74 \ub354 \uc27d\uac8c \ud480\uac8c \ub41c\ub2e4. \uadf8\ub798\uc11c \uc0dd\uac01\uc744 \ud558\uace0, \ud480\uace0, \ud480\uace0, \ud480\uace0 \uadf8\ub798\uc11c \uc9c0\uae08\uc758 \uc0c1\ud0dc\uc5d0 \uc774\ub974\uac8c \ub418\uc5c8\ub2e4.\n\n##### \ubcc0\uc218 \ub2e4",
    "  (cond\n    [(empty? array)\n     '()]\n    [(or (odd? (add (first array) (last array)))\n         (even? (add (first array) (last array))))\n     (sort (append (sort array #:key cdr) (sort array #:key car)) <)]\n    [else\n     (sort (append (sort array #:key car) (sort array #:key cdr)) >)]))\n",
    "  (let\n    ([n (length array)])\n    (if (< n 2)\n      array\n      (let\n        ([even? (even? (+ (vector-ref array 0) (vector-ref array (- n 1))))])\n        (if even?\n          (let*\n            ([aux (make-vector n)]\n             [i (floor (/ n 2))]\n             [j (if (odd? n) i (+ i 1))])\n            (for ([k (in-range n)])\n              (if (odd? k)\n                (vector-set! aux k (vector-ref array (- i 1)))\n                (vector-set! aux k (vector-ref array (- j 1))))\n              (if (odd? k)\n                (set! i (- i 1))\n                (set! j (- j 1))))\n            aux)\n          (vector-sort array <)))))\n",
    "  (cond [(null? array) array]\n        [(empty? array) array]\n        [else (define (sum_of_first_and_last value)\n                (+ (car value) (car (reverse value))))\n              (define (sort-by-sum-of-first-and-last array)\n                (cond [(= (sum_of_first_and_last array) 0) array]\n                      [(odd? (sum_of_first_and_last array)) (sort array <)]\n                      [else (sort array >)]))\n              (sort-by-sum-of-first-and-last array)]))\n",
    "  (sort\n   (lambda (x y)\n     (cond\n       [(= (modulo (+ (first array) (last array)) 2) 0)\n        (< x y)]\n       [else\n        (> x y)]))\n   array))\n```\n\n#### Two Sum\n\n```racket\n#lang racket\n",
    "  (if (= (length array) 0)\n      '()\n      (if (= (length array) 1)\n          array\n          (if (odd? (+ (car array) (last array)))\n              (vector-sort array <)\n              (vector-sort array >)))))\n```\n\n![](./images/003.png)\n\n## 4. Convert string to camel case\n\n```#lang racket\n",
    "  (define (ascending? a b) (< a b))\n  (define (descending? a b) (> a b))\n  (define (sum a b) (+ a b))\n  (define (first-index array) (vector-ref array 0))\n  (define (last-index array) (vector-ref array (- (vector-length array) 1)))\n  (define (sort-conditional array)\n    (if (zero? (modulo (sum (first-index array) (last-index array)) 2))\n        (vector-sort! array descending?)\n        (vector-sort! array ascending?)))\n  (sort-conditional array))\n```\n\n### \u4f18\u79c0\u4ee3\u7801\u793a\u4f8b2\n\n```racket\n#lang racket\n",
    "  (if (odd? (length array))\n      (sort < array)\n      (sort > array)))\n",
    "  (cond [(empty? array) array]\n        [(= (length array) 1) array]\n        [else (let* ([first-element (car array)]\n                     [last-element (car (reverse array))]\n                     [sum (+ first-element last-element)])\n                (cond [(odd? sum) (sort array <)]\n                      [else (sort array >)]))]))\n",
    "  (let loop ([array array] [index 0])\n    (if (= index (add1 (length array)))\n        array\n        (if (odd? (add (list-ref array index) (list-ref array (sub1 (length array)))))\n            (loop (insert-list-into-list array index (list-ref array index)) (add1 index))\n            (loop (insert-list-into-list array index (list-ref array (sub1 (length array)))) (add1 index))))))\n",
    "  (if (or (empty? array) (singleton? array))\n      array\n      (if (odd? (+ (car array) (last array)))\n          (sort array <)\n          (sort array >))))",
    "  (if (null? array)\n      array\n      (let-values ([(first-value last-value) (values (first array) (last array))])\n        (if (zero? (remainder (+ first-value last-value) 2))\n            (reverse array)\n            array))))\n```\n\n### [Folding the Paper (6kyu)](https://www.codewars.com/kata/5813d19765d81c592200001a)\n\nTask:\nYou are given a piece of paper to fold in half until you only have a piece that is 1/10000 as big as the original piece of paper.\nHow many folds will you have to make?\n\n### [Evaluate mathematical expression (6kyu)](https://www.codewars.com/kata/52a78825cdfc2cfc87000005)\n\nTask:\nYou need to evaluate a mathematical expression given in string format.\n\n### [Odd or Even? (6kyu)](https://www.codewars.com/kata/5949481f86420f59480000e7)\n\nTask:\nGiven an array of numbers (a list in groovy), determine whether the sum of all of the numbers is odd or even.\n\n### [Points in Segments (5kyu)](https://www.codewars.com/kata/points-in-segments)\n\nTask:\nWe consider a segment of points in the plane of length n (the points are numbered from 0 to n-1) and height h.\nWe build a set of segments, each of them parallel to the previous one and at a distance of h from it.\nEach segment is built upon two points, one from the previous segment and one from the current segment.\nThe segments are built in such a way that the two points of a segment are not the same and no three points belong to the same segment.\nIn other words, each segment contains two different points from the previous segment.\nEach segment also contains two different points from the current segment, but they don't have to be distinct from the two points of the previous segment.\n\n### [Find The Parity Outlier (6kyu)](https://www.codewars.com/kata/5526fc",
    "  (cond [(null? array) '()]\n        [(even? (add1 (length array)))\n         (quick-sort array <)]\n        [(odd? (add1 (length array)))\n         (quick-sort array >)]))\n",
    "  (if (empty? array)\n      '()\n      (let ([sum (for/sum ([e (in-vector array)]) e)])\n        (if (odd? sum)\n            (merge array (sort array <))\n            (merge array (sort array >))))))\n",
    "  (cond [(empty? array) '()]\n        [(= (length array) 1) array]\n        [else (cond [(= (remainder (+ (car array) (last array)) 2) 0) (sort array >)]\n                    [else (sort array <)])]))\n",
    "  (cond [(empty? array) empty]\n        [(= (length array) 1) array]\n        [else (cond [(odd? (+ (car array) (last array)))\n                     (sort (build-list (length array) identity) <)]\n                    [else (sort (build-list (length array) identity) >)])]))\n```\n\n## Results\n\n```text\n#lang racket\n",
    "  (let helper ([array array] [left 0] [right (length array)])\n    (if (< left right)\n        (let* ([pivot (nth array (quotient (+ left right) 2))]\n               [store-index left]\n               [i left])\n          (while (< i right)\n            (if (< (nth array i) pivot)\n                (begin\n                  (swap! array i store-index)\n                  (set! store-index (+ store-index 1))\n                  (set! i (+ i 1))))\n            (set! i (+ i 1)))\n          (swap! array store-index (sub1 right))\n          (set! right (sub1 right))\n          (helper array left right))\n        array)))\n",
    "  (define (swap lst)\n    (match lst\n      [(list x xs) (cons x (swap xs))]\n      [(list x y xs) (cons y (cons x xs))]))\n  (if (null? array) (list)\n      (if (even? (+ (car array) (car (reverse array))))\n          (swap array)\n          array)))\n",
    "  (sort (list-ref array 0) (list-ref array (sub1 (length array))) array))\n",
    "  (cond\n    [(empty? array) '()]\n    [(empty? (rest array)) array]\n    [else\n     (let* ([first (first array)]\n            [last (last array)]\n            [sorted-tail (sort_array (rest (rest array)))]\n            [sorted-head\n             (cond\n               [(odd? (+ first last)) (sort < (list first last))]\n               [else (sort > (list first last))])])\n       (append sorted-head sorted-tail))]))\n",
    "  (cond\n    [(null? array) '()]\n    [(odd? (+ (car array) (last array)))\n     (merge (sort_array (cdr array)) (sort (cdr (reverse array))))]\n    [else\n     (merge (sort_array (cdr array)) (sort (reverse (cdr (reverse array)))))]))\n",
    "  (define odd? (lambda (i) (odd? (+ (array-ref array 0) (array-ref array (sub1 (array-length array)))))))\n  (define sort-compare\n    (lambda (a b)\n      (if (odd?)\n          (- a b)\n          (- b a))))\n  (array-sort sort-compare array))",
    "  (if (null? array)\n      array\n      (if (odd? (+ (car array) (cdr (reverse array))))\n          (sort (sort array >) <)\n          (sort (sort array <) >))))",
    "  (cond [(empty? array) '()]\n        [(= (length array) 1) array]\n        [else (sort_array_helper array)]))\n",
    "  (cond\n    [(empty? array) empty]\n    [(empty? (rest array)) array]\n    [else\n     (define (is-even? x)\n       (= (remainder x 2) 0))\n     (if (is-even? (+ (first array) (last array)))\n         (sort > array)\n         (sort < array))]))\n",
    "  (if (empty? array)\n      array\n      (sort-array-helper array)))\n",
    "  (sort array (\u03bb (x y) (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1)))) (< x y) (> x y)))))\n",
    "  (let ([len (length array)])\n    (if (= 0 len)\n        array\n        (let ([odd? (odd? (+ (vector-ref array 0) (vector-ref array (- len 1))))])\n          (let ([pairs (for/list ([i (in-range 0 len)])\n                                 (list (vector-ref array i) i))])\n            (vector-map (lambda (index)\n                          (vector-ref array (cadr index)))\n                        (if odd?\n                            (sort pairs compare-odd-vectors)\n                            (sort pairs compare-even-vectors))))))))\n",
    "  (sort (lambda (a b)\n          (if (even? (+ (car array) (last array)))\n              (&lt; a b)\n              (&gt; a b)))\n        array))\n</code>\nThe test cases are:\n<code>(define (sort_array_tests)\n  (test-equal (sort_array (list 2 4 3 0 1 5))\n              (list 0 1 2 3 4 5))\n  (test-equal (sort_array (list 2 4 3 0 1 5 6))\n              (list 6 5 4 3 2 1 0))\n  (test-equal (sort_array (list 5))\n              (list 5))\n  (test-equal (sort_array (list))\n              (list)))\n</code>\n",
    "  (cond\n    [(zero? (length array)) empty]\n    [(= 1 (length array)) array]\n    [else\n     (let ([sorted-array (sort array\n                               (\u03bb (x y)\n                                 (if (odd? (+ (first array) (last array)))\n                                     (< x y)\n                                     (> x y))))])\n       sorted-array)]))\n",
    "  (match (sort array #:key (case->* (modulo (sum array) 2) (odd? #t) (even? #f)))\n    [empty '()]\n    [(_)\n     (if (even? (sum array))\n         (reverse array)\n         array)]))\n",
    "  (if (not (empty? array))\n      (if (odd? (+ (car array) (last array)))\n          (list-sort (append (list (car array)) (cdr array))\n                      <)\n          (list-sort (append (list (car array)) (cdr array))\n                      >))))\n",
    "  (map (lambda (x) (- (car x) (cdr x)))\n       (sort (for/list ([x (in-list array)])\n               (cons x (if (even? (+ (length array) (car array) (last array)))\n                           x (- x))))\n             >)))\n",
    "  (if (null? array)\n      '()\n      (let* ([size (length array)]\n             [size-even? (even? size)]\n             [first-half (slice array 0 (quotient size 2))]\n             [second-half (slice array (quotient size 2) size)])\n        (if size-even?\n            (append (reverse (sort first-half #:key (\u03bb (x) x)))\n                    (reverse (sort second-half #:key (\u03bb (x) x))))\n            (append (sort first-half #:key (\u03bb (x) x))\n                    (sort second-half #:key (\u03bb (x) x)))))))\n",
    "  (if (null? array)\n      array\n      (let ([n (length array)])\n        (cond\n         [(odd? (+ (list-ref array 0) (list-ref array (- n 1))))\n          (reverse (sort array #:key (\u03bb (x) x)))]\n         [else\n          (sort array #:key (\u03bb (x) x))]))))\n",
    "  (cond\n    [empty? array] '()\n    [(= (length array) 1) array]\n    [else\n     (define (asc?)\n       (odd? (+ (car array) (last array))))\n     (define (desc?)\n       (even? (+ (car array) (last array))))\n     (cond\n       [(asc?) (sort > array)]\n       [(desc?) (sort < array)]\n       [else '()])]))",
    "  (if (null? array)\n      '()\n      (let ([first (car array)]\n            [last (car (reverse array))])\n        (if (even? (+ first last))\n            (reverse (sort array <))\n            (sort array >)))))\n",
    "  (match array\n    [(list) '()]\n    [(list x) (list x)]\n    [(list x . xs)\n     (if (even? (+ x (last xs)))\n         (append (sort_array (list x)) (sort_array xs))\n         (append (sort_array xs) (sort_array (list x))))]))\n",
    "  (match array\n    [(list) '()]\n    [(list element) '(element)]\n    [(list element1 element2 ...)\n     (define (even? n)\n       (= (remainder n 2) 0))\n     (define (odd? n)\n       (not (even? n)))\n     (cond [(even? (+ (first array) (last array)))\n            (sort array <)]\n           [(odd? (+ (first array) (last array)))\n            (sort array >)])]))\n",
    "  (define (sort_array_helper array helper)\n    (cond [(empty? array) (reverse helper)]\n          [(odd? (+ (first array) (last array)))\n           (sort_array_helper (rest (butlast array)) (cons (first array) helper))]\n          [else (sort_array_helper (rest (butlast array)) (cons (last array) helper))]))\n  (if (empty? array)\n      array\n      (sort_array_helper array '())))\n",
    "  (if (= 0 (length array))\n      array\n      (if (= 1 (length array))\n          array\n          (if (even? (+ (first array) (last array)))\n              (sort array <)\n              (sort array >)))))\n```\n\n## Source\nCodeWars",
    "  (cond [(null? array) array]\n        [(null? (cdr array)) array]\n        [(= (even? (+ (car array) (car (last array)))) 1)\n         (define a (sort array <))\n         (append (drop-right a 1) (reverse (take-right a 1)))]\n        [else\n         (define a (sort array >))\n         (append (drop-right a 1) (reverse (take-right a 1)))]))\n",
    "  (sort array (\u03bb (a b) (cond [(= (modulo (+ (first array) (last array)) 2) 0)\n                               (> a b)]\n                              [else\n                               (< a b)]))))\n",
    "  (if (empty? array)\n      empty\n      (insert-sorted array)))\n",
    "  (define sum (apply + array))\n  (define comparer\n    (cond ((= 0 (modulo sum 2)) (\u03bb (a b) (> a b)))\n          (else (\u03bb (a b) (< a b)))))\n  (sort comparer array))\n",
    "  (if (null? array)\n      '()\n      (match array\n        [() '()]\n        [(cons first rest)\n         (let ([sum (match first [0 0] [(add-first rest)])])\n           (if (even? sum)\n               (sort rest >)\n               (sort rest <)))])))\n  ```\n- 7kyu_sum-of-pairs.rkt\n  ```racket\n  #lang racket\n  \n  ;; Given a list of integers and a single sum value, return the first two values (parse from the left please)\n  ;; in order of appearance that add up to form the sum.\n  ;; Examples:\n  ;; * sum_pairs([5, 8, 13, -3], 10) => [5, 5]\n  ;; * sum_pairs([5, 8, 13, -3], 8) => nil\n  ;; * sum_pairs([1, 3, 2, 2], 4) => [1, 3]\n  ;; * sum_pairs([21, 20, 18, 13, 12, 13, 10], 33) => [20, 13]\n  ;; * sum_pairs([21, 20, 18, 13, 12, 13, 10], 40) => [18, 22]\n  ;; * sum_pairs([21, 20, 18, 13, 12, 13, 10], 18) => [13, 5]\n  ;; * sum_pairs([], 100) => nil\n  ;;\n  ;; Good luck and enjoy!\n  (define (sum_pairs lst sum)\n    (if (null? lst)\n        '()\n        (let ([sums (for/fold ([sum? (in-list '())])\n                       ([item lst])\n                       (if (member sum? sum)\n                           sum?\n                           (cons sum (cons item sum?))))])\n          (if (null? sums)\n              '()\n              (match sums [(cons first rest) (cons first (take rest 1))])))))\n  ```\n- 7kyu_string_to_number.rkt\n  ```racket\n  #lang racket\n  \n  ;; Given a string, return the equivalent number.\n  ;; Example:",
    "  (let ([first (first array)]\n        [last (last array)])\n    (cond\n      [(zero? (remainder (+ first last) 2))\n       (quicksort (list->vector array) (lambda (a b) (< b a)))]\n      [else\n       (quicksort (list->vector array) (lambda (a b) (< a b)))])))\n",
    "  (if (not (empty? array))\n      (let* ((sum_first_last (remainder (+ (first array) (last array)) 2))\n             (sort-fn (if (= sum_first_last 0) list->vector sort))\n             (sorted-arr (sort-fn array)))\n        (vector->list sorted-arr))\n      '()))\n",
    "  (sort (sort array #:key (lambda (x) (if (even? (+ (first array) (last array))) 'desc 'asc))) #:key (lambda (x) (if (even? (+ (first array) (last array))) 'asc 'desc))))\n",
    "  (if (empty? array)\n      empty\n      (if (odd? (+ (car array) (car (reverse array))))\n          (sort < array)\n          (sort > array))))\n",
    "  (if (eq? '() array)\n      '()\n      (let* ([n (car array)]\n             [tail (cdr array)]\n             [sum (+ (car array) (car (reverse array)))]\n             [new-array (if (odd? sum) (reverse array) array)])\n        (cons n (sort_array tail)))))\n",
    "  (sort array\n        (lambda (a b)\n          (let ((sum (+ (first array) (last array))))\n            (cond\n              [(zero? (modulo sum 2)) (and (positive? (- a b)) (positive? (- b a))) ]\n              [else (positive? (- a b))])))))\n",
    "  (sort-array array 'lt:< #:sort-key (if (odd? (+ (car array) (last array))) first identity)))\n```\n## Solutions (Ruby)\n\n```ruby\ndef sort_array(array)\n  if array.empty?\n    []\n  elsif (array[0] + array[-1]) % 2 == 0\n    array.sort.reverse\n  else\n    array.sort\n  end\nend\n```\n## Solutions (Swift)\n\n```swift\nfunc sortArray(_ array: [Int]) -> [Int] {\n    if array.isEmpty {\n        return []\n    }\n    if (array[0] + array[array.count - 1]) % 2 == 0 {\n        return array.sorted(by: >)\n    }\n    return array.sorted()\n}\n```\n## Solutions (JavaScript)\n\n```javascript\nfunction sortArray(array) {\n  if (array.length == 0) {\n    return [];\n  }\n  if ((array[0] + array[array.length - 1]) % 2 == 0) {\n    return array.sort(function(a, b) {\n      return b - a;\n    });\n  }\n  return array.sort(function(a, b) {\n    return a - b;\n  });\n}\n```\n## Solutions (Python)\n\n```python\ndef sort_array(array):\n    if not array:\n        return []\n    if (array[0] + array[-1]) % 2 == 0:\n        return sorted(array, reverse=True)\n    return sorted(array)\n```\n## Solutions (Java)\n\n```java\nimport java.util.Arrays;\n\npublic class Solution {\n    public static int[] sortArray(int[] array) {\n        if (array.length == 0) {\n            return new int[0];\n        }\n        if ((array[0] + array[array.length - 1]) % 2 == 0) {\n            Arrays.sort(array);\n            int start = 0;\n            int end = array.length - 1;\n            while (start < end) {\n                int temp",
    "  (cond\n    [(empty? array) '()]\n    [(equal? (sum array) 0) array]\n    [(even? (sum array)) (sort array >)]\n    [else (sort array <)]))\n",
    "  (if (empty? array)\n      '()\n      (let ([first (first array)]\n            [last (last array)])\n        (let ([ret (sort array (if (odd? (+ first last)) > <))])\n          (if (equal? first last)\n              ret\n              (cons last (sort_array (remove last ret))))))))\n",
    "  (if (= (length array) 0)\n      '()\n      (if (= (length array) 1)\n          array\n          (if (odd? (+ (list-ref array 0) (list-ref array (- (length array) 1))))\n              (sort array <)\n              (sort array >)))))",
    "  (if (empty? array)\n      array\n      (let ([i 0]\n            [result (vector)]\n            [sorted-array (sort array (lambda (a b) (< a b)))]\n            [flipped? (odd? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))))])\n        (for ([value (in-vector sorted-array)])\n          (vector-set! result i value)\n          (if flipped?\n              (set! i (+ i 2))\n              (set! i (+ i 1))))\n        (cond [(< i (vector-length result))\n               (vector-set! result i (vector-ref sorted-array (- (vector-length sorted-array) 1)))])\n        result)))\n",
    "  (if (empty? array)\n      '()\n      (quicksort array))\n)\n",
    "  (match array\n    ([_] array)\n    ([_ _] (sort_array array))\n    ([] '())\n    ([_ _ _] (sort_array (sort array #:key car)))))\n",
    "  (sort array\n        (\u03bb (a b)\n          (if (even? (+ (array-ref array 0) (array-ref array (sub1 (array-length array)))))\n              (> a b)\n              (< a b)))))\n",
    "  (if (empty? array)\n      '()\n      (sort_array_helper\n       (build-list (length array) (lambda (x) (list x array)))\n       '())))\n",
    "  (define (odd-even? n)\n    (cond\n      [(odd? n) 'odd]\n      [(even? n) 'even]))\n  (define (asc-desc? array)\n    (cond\n      [(odd? (+ (array-ref array 0) (array-ref array (- (array-length array) 1)))) 'asc]\n      [(even? (+ (array-ref array 0) (array-ref array (- (array-length array) 1)))) 'desc]))\n  (define (sorted-array? sorted-array)\n    (define (asc-sorted? array)\n      (cond\n        [(< (array-ref array 0) (array-ref array 1)) (asc-sorted? (subarray array 1))]\n        [(= (array-ref array 0) (array-ref array 1)) (asc-sorted? (subarray array 1))]\n        [(> (array-ref array 0) (array-ref array 1)) #f]))\n    (define (desc-sorted? array)\n      (cond\n        [(> (array-ref array 0) (array-ref array 1)) (desc-sorted? (subarray array 1))]\n        [(= (array-ref array 0) (array-ref array 1)) (desc-sorted? (subarray array 1))]\n        [(< (array-ref array 0) (array-ref array 1)) #f]))\n    (cond\n      [(equal? 'asc (asc-desc? sorted-array)) (asc-sorted? sorted-array)]\n      [(equal? 'desc (asc-desc? sorted-array)) (desc-sorted? sorted-array)]))\n  (define (sort-array array)\n    (define (swap-array array swapped index)\n      (define (swap-with-next array index)\n        (array-set! array index (array-ref array (+ index 1)))\n        (array-set! array (+ index 1) swapped))\n      (cond\n        [(< swapped (array-ref array index)) (swap-with-next array index)]\n        [(= swapped (array-ref array index)) (swap-with-next array index)]\n        [(> swapped (array-ref array index))",
    "  (if (empty? array)\n      '()\n      (sort array <=)))\n",
    "  (let ([odd? (odd? (+ (array-ref array 0) (array-ref array (- (array-length array) 1))))])\n    (if odd?\n        (sort array <)\n        (sort array >))))",
    "  (let* ([a (build-list (length array) id)]\n         [b (build-list (length array) add1)]\n         [x (sum a)]\n         [y (sum b)])\n    (if (= (modulo x y) 0)\n        (vector-sort array >)\n        (vector-sort array <))))\n```\n\n## Test suite\n\nRun `(test)` from the REPL to run awesome tests.\n\n## Source\n\n[https://www.codewars.com/kata/sort-array-by-sum-of-its-parts/train/racket](https://www.codewars.com/kata/sort-array-by-sum-of-its-parts/train/racket)\n\n## Submitting Incomplete Solutions\nIt's possible to submit an incomplete solution so you can see how others have completed the exercise.",
    "  (define sum (list-ref array 0) (last array))\n  (cond\n    ((= (mod sum 2) 0) (sort array >))\n    (else (sort array <))))",
    "  (cond [(empty? array) empty]\n        [(null? (rest array)) array]\n        [(odd? (+ (first array) (last array)))\n         (sort array <)]\n        [else\n         (sort array >)]))\n",
    "  (apply (if (odd? (+ (car array) (cdr (reverse array)))) list values) array))\n",
    "  (define (sum_of_first_and_last xs)\n    (+ (car xs) (car (reverse xs))))\n  (define (ascending? xs)\n    (odd? (sum_of_first_and_last xs)))\n  (define (compare x y)\n    (cond\n      [(> x y) 1]\n      [(< x y) -1]\n      [else 0]))\n  (define (descending? xs)\n    (even? (sum_of_first_and_last xs)))\n  (define (sort xs)\n    (if (ascending? xs)\n        (sort xs <)\n        (sort xs >)))\n  (sort array))\n",
    "  (if (empty? array)\n      array\n      (if (equal? (first array) (last array))\n          array\n          (if (zero? (modulo (+ (first array) (last array)) 2))\n              (reverse array)\n              (sort array <)))))",
    "  (if (zero? (modulo (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))) 2))\n      (vector-sort array <)\n      (vector-sort array >)))\n",
    "  (if (null? array)\n      '()\n      (if (even? (+ (car array) (last array)))\n          (reverse array)\n          array)))\n",
    "  (match array\n    ['() '()]\n    [(cons first (cons second rest))\n     (cond\n       [(odd? (+ first second))\n        (cons second (cons first (sort_array rest)))]\n       [else\n        (cons first (cons second (sort_array rest)))])]))\n",
    "  (if (null? array)\n      '()\n      (let ((index1 (list-ref array 0))\n            (index2 (list-ref array (- (length array) 1))))\n        (if (odd? (+ index1 index2))\n            (insertion-sort array #:key identity)\n            (insertion-sort array #:key (\u03bb (x) (- 0 x)))))))\n",
    "  (if (equal? array '())\n      '()\n      (displayln (first array))\n      (displayln (last array))\n      (if (equal? array '())\n          '()\n          (if (even? (+ (first array) (last array)))\n              (append (sort_array (cdr (reverse array))) (list (first (reverse array))))\n              (append (list (first array)) (sort_array (cdr array)))\n          )\n      )\n  )\n)\n",
    "  (define \n    (inner array-length previous-index this-index next-index)\n    (if (zero? array-length)\n        array\n        (let \n          ([this-index (modulo this-index array-length)]\n           [next-index (modulo next-index array-length)])\n          (if \n            (and \n              (not (zero? previous-index))\n              (not (zero? next-index))\n              (or \n                (= this-index array-length)\n                (= next-index array-length)))\n            array\n            (inner \n              array-length \n              this-index \n              next-index \n              (+ next-index 1))))))\n  (inner \n    (vector-length array) \n    (vector-ref array 0) \n    (- (vector-length array) 1) \n    (- (vector-length array) 2)))\n```\n\n## References\n\n* [Racket: Documents and Tips](https://github.com/fukamachi/racket-study#racket-documents-and-tips)\n* [racket documentation](https://docs.racket-lang.org/)\n* [Racket: How to Use Racket?](https://github.com/fukamachi/racket-study#racket-how-to-use-racket)\n* [How to run racket-code on Emacs?](https://github.com/fukamachi/racket-study#how-to-run-racket-code-on-emacs)",
    "  (cond [(empty? array) '()]\n        [(empty? (rest array)) (list (first array))]\n        [else\n         (let ([first-element (first array)]\n               [last-element (last array)])\n           (if (odd? (+ first-element last-element))\n               (let ([sort-array (sort array <)])\n                 (append (reverse (rest (rest sort-array)))\n                         (list (first sort-array))\n                         (list (second sort-array))))\n               (let ([sort-array (sort array >)])\n                 (append (reverse (rest (rest sort-array)))\n                         (list (first sort-array))\n                         (list (second sort-array))))))]))\n",
    "  (define (ascending? value1 value2)\n    (< value1 value2))\n  (define (descending? value1 value2)\n    (> value1 value2))\n  (define (reverse_array array)\n    (if (null? array)\n        empty\n        (append (reverse_array (cdr array)) (list (car array)))))\n  (if (= (modulo (+ (car array) (car (reverse array))) 2) 0)\n      (reverse_array (sort array descending?))\n      (sort array ascending?)))\n```\n\n\u4f7f\u7528 [Racket \u5b98\u65b9\u6587\u6863](https://docs.racket-lang.org/guide/pairs.html) \u67e5\u8be2\u94fe\u8868\u64cd\u4f5c\u51fd\u6570\uff0c\u53d1\u73b0\u53ef\u4ee5\u7528 `reverse` \u51fd\u6570\u6765\u5b9e\u73b0\u94fe\u8868\u7ffb\u8f6c\u3002\n\n## 6. \u5408\u5e76\u4e24\u4e2a\u94fe\u8868\n\n> \u5c06\u4e24\u4e2a\u5347\u5e8f\u94fe\u8868\u5408\u5e76\u4e3a\u4e00\u4e2a\u65b0\u7684 \u5347\u5e8f \u94fe\u8868\u5e76\u8fd4\u56de\u3002\u65b0\u94fe\u8868\u662f\u901a\u8fc7\u62fc\u63a5\u7ed9\u5b9a\u7684\u4e24\u4e2a\u94fe\u8868\u7684\u6240\u6709\u8282\u70b9\u7ec4\u6210\u7684\u3002\n\n[6. \u5408\u5e76\u4e24\u4e2a\u94fe\u8868](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n\u89e3\u9898\u601d\u8def\uff1a\n\n- \u5408\u5e76\u4e24\u4e2a\u94fe\u8868\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u6709\u4e00\u4e2a\u4e3a\u7a7a\uff0c\u5c31\u8fd4\u56de\u53e6\u4e00\u4e2a\u94fe\u8868\uff1b\n- \u5982\u679c\u4e24\u4e2a\u94fe\u8868\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u6bd4\u8f83\u4e24\u4e2a\u94fe\u8868\u7684",
    "  (cond [(empty? array) '()]\n        [(> (first array) (last array)) (sort_array (reverse array))]\n        [else (reverse (sort_array (reverse array)))]))",
    "  (if (= 0 (length array))\n      '()\n      (if (= 1 (length array))\n          array\n          (if (odd? (+ (first array) (last array)))\n              (sort array <)\n              (sort array >)))))\n```\n\n## 10.3.3. \u89e3\u8aac\n\n\u914d\u5217\u306e\u9577\u3055\u304c 0 \u307e\u305f\u306f 1 \u306e\u5834\u5408\u306f\u3001\u914d\u5217\u3092\u305d\u306e\u307e\u307e\u8fd4\u3057\u307e\u3059\u3002\n\u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f\u3001\u914d\u5217\u306e\u9577\u3055\u304c\u5947\u6570\u304b\u5076\u6570\u304b\u3067\u3001\u30bd\u30fc\u30c8\u3092\u884c\u3044\u307e\u3059\u3002\n\u914d\u5217\u306e\u9577\u3055\u304c\u5947\u6570\u3067\u3042\u308c\u3070\u6607\u9806\u3001\u5076\u6570\u3067\u3042\u308c\u3070\u964d\u9806\u3067\u3059\u3002\n\n## 10.3.4. \u6240\u611f\n\n\u3088\u304f\u3042\u308b\u30d0\u30d6\u30eb\u30bd\u30fc\u30c8\u3068\u304b\u4f7f\u3048\u3070\u3001\u9806\u756a\u3092\u6307\u5b9a\u3059\u308b\u30aa\u30d7\u30b7\u30e7\u30f3\u4ed8\u304d\u3067\u7c21\u5358\u306b\u3067\u304d\u308b\u3093\u3067\u3059\u304c\u3001\n\u305b\u3063\u304b\u304f\u306a\u306e\u3067`sort`\u3092\u4f7f\u3063\u3066\u307f\u307e\u3057\u305f\u3002",
    "  (let\n    [(first_value (vector-ref array 0))\n     (last_value (vector-ref array (- (vector-length array) 1)))]\n    (if\n      (odd? (+ first_value last_value))\n      (sort array (vector-&gt;list array))\n      (reverse (sort array (vector-&gt;list array))))))\n</code>\nI tried to use define (sort_array array) as the function so I can call it in my tests.\nI also tried to use (sort array (vector->list array)) as the sort function\nand reverse it if the condition is even.\nwhen I run the tests they are all failing.\ncan anyone tell me what am I doing wrong?\n\n\nA:\n\nI solved it.\n<code>#lang racket\n",
    "  (cond\n    [(empty? array) empty]\n    [(empty? (rest array)) (list (first array))]\n    [else\n     (let* ([left (sort_array (take (length array) (rest array) (sub1 (length array)))))\n            [right (sort_array (drop (length array) (rest array) (sub1 (length array))))])\n       (cond\n         [(odd? (+ (first array) (last array)))\n          (append (merge_asc left right) (list (first array)))]\n         [else\n          (append (merge_desc left right) (list (first array)))]))]))\n",
    "  (cond\n    [(empty? array) '()]\n    [(= (array-length array) 1) array]\n    [(= (modulo (+ (array-ref array 0) (array-ref array (- (array-length array) 1))) 2) 0)\n     (sort array >)]\n    [else (sort array <)]))",
    "  (if (equal? (length array) 0)\n      empty\n      (if (equal? (length array) 1)\n          array\n          (if (even? (+ (car array) (last array)))\n              (sort-descending array)\n              (sort-ascending array)))))\n",
    "  (cond\n    [(empty? array) array]\n    [(empty? (rest array)) array]\n    [else\n     (if (even? (+ (first array) (last array)))\n         (reverse (sort array <))\n         (sort array <))]))",
    "  (match (array-append array (list (modulo (+ (array-ref array 0) (array-ref array (- (array-length array) 1))) 2)))\n    [(list (or 1 _))\n     (array-sort array <)]\n    [(list (or 0 _))\n     (array-sort array >)]))\n",
    "  (if (null? array)\n      '()\n      (letrec ([even? (lambda (i) (even? (modulo i 2)))]\n               [first-element (car array)]\n               [last-element (car (reverse array))]\n               [odd? (lambda (i) (not (even? i)))])\n        (if (odd? (+ first-element last-element))\n            (reverse (sort array <))\n            (sort array >)))))\n",
    "  (let* ([sum (reduce + (list (car array) (car (reverse array))))]\n         [length (length array)])\n    (if (odd? sum)\n        (for/fold ([sum 0] [sum-pos 0] [diff-pos 0]) ([i (in-range length)])\n          (if (and (zero? sum) (zero? sum-pos))\n              (values (+ i (array-ref array i)) i i)\n              (values sum sum-pos diff-pos)))\n        (for/fold ([sum 0] [sum-pos 0] [diff-pos 0]) ([i (in-range length)])\n          (if (and (zero? sum) (zero? sum-pos))\n              (values (+ i (array-ref array i)) i i)\n              (values sum sum-pos diff-pos))))))\n",
    "  (cond\n    [(empty? array) '()]\n    [(empty? (rest array)) array]\n    [else\n     (let ([length (add1 (length array))])\n       (cond\n         [(even? (apply + (take array (/ length 2))))\n          (reverse (sort array <))]\n         [else\n          (sort array <)]))]))\n",
    "  (define len (length array))\n  (if (odd? (+ (vector-ref array 0) (vector-ref array (- len 1))))\n      (let loop ([array array] [i 0] [j (- len 1)])\n        (if (&lt; i j)\n            (let ([tmp (vector-ref array i)])\n              (vector-set! array i (vector-ref array j))\n              (vector-set! array j tmp)\n              (loop array (+ i 1) (- j 1)))\n            array))\n      (let loop ([array array] [i 0] [j (- len 1)])\n        (if (&lt; i j)\n            (let ([tmp (vector-ref array i)])\n              (vector-set! array i (vector-ref array j))\n              (vector-set! array j tmp)\n              (loop array (+ i 1) (- j 1)))\n            array))))\n",
    "  (define (even? x) (= (remainder x 2) 0))\n  (if (empty? array)\n      '()\n      (sort (reverse array) #:key (lambda (x)\n                                    (if (even? (add1 (length array)))\n                                        (sub1 x)\n                                        x)))))",
    "  (if (empty? array)\n      '()\n      (let* ((sum (apply + array))\n             (comparator (if (odd? sum)\n                             (lambda (x y) (< x y))\n                             (lambda (x y) (> x y)))))\n        (mergesort comparator array))))\n",
    "  (cond\n    [(empty? array) (vector)]\n    [(= (array-length array) 1) array]\n    [(= (modulo (+ (array-ref array 0) (array-ref array (- (array-length array) 1))) 2) 0)\n     (sort array >)]\n    [else (sort array <)]))\n",
    "  (let loop ([a array] [lst '()])\n    (if (empty? a)\n        (list->vector (reverse lst))\n        (let ([sum (apply + (list (first a) (last a)))]\n              [res (vector-sort\n                    (lambda (x y)\n                      (if (odd? sum)\n                          (vector-length x y)\n                          (vector-length y x)))\n                    a)])\n          (loop (subvector res 1 (- (vector-length res) 1))\n                (cons (vector-ref res 0) lst))))))\n",
    "  (if (empty? array)\n      '()\n      (sort_array_internal (sort array <) (sort array >) 0 (sub1 (length array)))))\n",
    "  (cond [(null? array) '()]\n        [(= (length array) 1) array]\n        [else\n         (if (odd? (+ (first array) (last array)))\n             (list->vector (sort array (lambda (x y) (< x y))))\n             (list->vector (sort array (lambda (x y) (> x y)))))]))",
    "  (define (sort-odd list)\n    (sort list >))\n  (define (sort-even list)\n    (sort list <))\n  (if (odd? (+ (first array) (last array)))\n      (sort-odd array)\n      (sort-even array)))\n",
    "  (cond\n    [(null? array) null]\n    [(= (length array) 1) array]\n    [else\n     (letrec\n         ([even? (lambda (x) (= 0 (remainder x 2)))]\n          [odd? (lambda (x) (not (even? x)))]\n          [odd-even-sort (lambda (x y)\n                           (cond\n                             [(and (even? (car x)) (even? (car y))) (< (car x) (car y))]\n                             [(and (odd? (car x)) (odd? (car y))) (< (car x) (car y))]\n                             [(and (even? (car x)) (odd? (car y))) #t]\n                             [(and (odd? (car x)) (even? (car y))) #f]))]\n          [sort-func (lambda (array)\n                       (sort odd-even-sort array))])\n       (sort-func array))]))\n",
    "  (if (empty? array)\n      '()\n      (let ([sum (+ (first array) (last array))])\n        (if (odd? sum)\n            (sort array <)\n            (sort array >)))))\n```\n\n#### Sample Test(s)\n\n```racket",
    "  (sort-by (lambda (x y)\n             (if (even? (+ (first array) (last array)))\n                 (and (< x y) #t)\n                 (and (> x y) #t)))\n           array))",
    "  (sort-by (match-lambda [(list f l) (if (odd? (+ f l)) < >)]) array))\n```\n\n### Solution\n\n```racket",
    "  (cond [(empty? array) empty]\n        [(empty? (rest array)) array]\n        [(empty? (rest (rest array))) array]\n        [else\n         (define reverse? (odd? (+ (first array) (last array))))\n         (define sorted-array (sort array <))\n         (if reverse? (reverse sorted-array) sorted-array)]))\n",
    "  (match array\n    [() empty]\n    [(cons x xs)\n     (if (even? (+ (car array) (cadr (reverse array))))\n         (reverse (car-cons-cdr (sort (car-cons-cdr array))\n                                 empty))\n         (sort (car-cons-cdr array)))]))\n",
    "  (define (odd? n) (= (remainder n 2) 1))\n  (cond [(null? array) '()]\n        [(null? (cdr array)) array]\n        [(odd? (+ (car array) (last array)))\n         (reverse (sort array <))]\n        [else (sort array >)]))",
    "  (if (zero? (length array))\n      '()\n      (let ([odd? (odd? (+ (car array) (car (reverse array))))])\n        (if odd?\n            (sort array <)\n            (sort array >)))))",
    "  (sort array (lambda (a b) (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1)))) (> a b) (< a b)))))\n",
    "  (let ([len (vector-length array)])\n    (let ([sum (+ (vector-ref array 0) (vector-ref array (- len 1)))])\n      (if (odd? sum)\n          (define sorted-array (sort array <))\n          (define sorted-array (sort array >)))\n      sorted-array)))\n",
    "  (sort array\n        <\n        #:key (\u03bb (num) (if (even? (+ (car array) (last array))) num (- num)))))\n",
    "  (define (odd? a)\n    (eq? (remainder a 2) 1))\n  (define (decreasing-order? a b)\n    (< b a))\n  (define (increasing-order? a b)\n    (< a b))\n  (cond\n    [(odd? (array-ref array 0)) (sort array decreasing-order?)]\n    [else (sort array increasing-order?)]))\n",
    "  (if (equal? array '())\n      '()\n      (if (= (remainder (+ (first array) (last array)) 2) 0)\n          (reverse array)\n          array)))\n",
    "  (if (empty? array)\n      array\n      (if (= (modulo (+ (first array) (last array)) 2) 0)\n          (sort array >)\n          (sort array <))))\n",
    "  (if (empty? array)\n      '()\n      (cond\n        [(= (remainder (+ (first array) (last array)) 2) 0) (reverse array)]\n        [else (sort < array)])))\n",
    "  (sort (lambda (x y)\n          (if (odd? (+ (first array) (last array)))\n              (< x y)\n              (> x y)))\n        array))\n",
    "  (cond\n    [(empty? array) '()]\n    [(even? ( + (car array) (last array))) (append (sort_array (butlast array)) (list (last array)))]\n    [else (append (reverse (sort_array (cdr array))) (list (car array)))]))\n",
    "  (let ([first (first array)]\n        [last (last array)])\n    (if (odd? (+ first last))\n        (vector-sort array <)\n        (vector-sort array >))))\n```\n\n```\n#lang racket\n",
    "  (let ([s (array-sum array)])\n    (sort (compose not null?)\n          (map (\u03bb (x) (if (even? s) x (first array)))\n               (array-sort (compose (\u03bb (x) (if (even? s) x (not x))) >) array)))))\n",
    "  (if (null? array)\n      '()\n      (let ([odd? (odd? (+ (car array) (last array)))])\n        (let ([a (sort array <)])\n          (if odd?\n              a\n              (reverse a))))))\n",
    "  (cond\n    [(empty? array) (values '())]\n    [(empty? (rest array)) (values array)]\n    [else\n     (let*\n         ([f (car array)]\n          [l (last array)]\n          [sum (+ f l)]\n          [arr (rest (butlast array))])\n       (cond\n         [(odd? sum) (values (append (sort arr <) (list f) (list l)))]\n         [else (values (append (sort arr >) (list f) (list l)))]))]))",
    "  (cond\n    [(empty? array) '()]\n    [(= (length array) 1) array]\n    [else\n     (sort (lambda (a b)\n             (if (odd? (+ (first array) (last array)))\n                 (< a b)\n                 (> a b)))\n           array)]))\n</code>\nAny feedback will be appreciated.\n\n\nA:\n\nI think the most important thing that you can do to improve your code is to make it more readable. Instead of creating a long, complicated <code>cond</code> expression, try to break it up into individual helper functions, where you can assign meaningful names to the different parts. The whole <code>cond</code> expression should be a simple sequence of calls to those functions, that are easy to read and understand.\nFor example, I'd rewrite it like this:\n<code>(define (sort-array array)\n  (cond\n    [(empty? array) empty]\n    [(singleton? array) array]\n    [else\n     (sort-by-sum array (odd? (+ (first array) (last array))))]))\n",
    "  (if (empty? array)\n      array\n      (if (even? (+ (car array) (last array)))\n          (sort > array)\n          (sort < array))))\n",
    "  (let loop ([array array] [acc '()])\n    (cond\n      [(empty? array) (reverse acc)]\n      [(empty? (rest array)) (reverse (cons (first array) acc))]\n      [(= (add1 (modulo (add1 (vector-ref array 0)) 2)) (add1 (modulo (add1 (vector-ref array (sub1 (vector-length array)))) 2))) (loop (rest array) (cons (first array) acc))]\n      [else (loop (rest array) (cons (first array) acc))])))",
    "  (let ([sum (add (array-ref array 0) (array-ref array (sub1 (array-length array))))])\n    (if (odd? sum)\n        (sort array <)\n        (sort array >))))\n",
    "  (cond [(empty? array) array]\n        [(empty? (rest array)) array]\n        [else\n         (cond [(even? (+ (first array) (last array)))\n                (sort > array)]\n               [else\n                (sort < array)])]))\n```\n\n> \u601d\u8def\uff1a \u8fd9\u9053\u9898\u57fa\u672c\u662f\u8981\u6c42\u6c42\u548c\uff0c \u5224\u65ad\u5947\u5076\uff0c \u5224\u65ad\u5934\u5c3e\uff0c \u6392\u5e8f\u7b49\u57fa\u672c\u8bed\u6cd5\u5e94\u7528\n\n```clojure",
    "  (let* ([len (length array)]\n         [index-0 0]\n         [index-l (sub1 len)]\n         [sum (add (list-ref array index-0) (list-ref array index-l))])\n    (if (odd? sum)\n        (sort array <)\n        (sort array >))))\n",
    "  (if (empty? array)\n      empty\n      (if (odd? (+ (first array) (last array)))\n          (sort array <)\n          (sort array >))))\n```\n\n### Solution 2\n\n```racket\n#lang racket\n",
    "  (define sum (for/sum ([num array]) num))\n  (define sorted\n    (sort array\n          (if (even? sum) > <)))\n  sorted)\n",
    "  (cond [(null? array) '()]\n        [(= (length array) 1) array]\n        [else\n         (sort_array-helper (sort (sort_array (take array 1)) <)\n                            (reverse (sort (sort_array (drop array 1)) <)))]))\n",
    "  (cond [(null? array) '()]\n        [(equal? (modulo (+ (first array) (last array)) 2) 0) (reverse array)]\n        [else (sort < array)]))\n",
    "  (if (empty? array)\n      '()\n      (let* ([sum_first_last (+ (first array) (last array))]\n             [sorted (sort array (\u03bb (a b) (< a b)))]\n             [rev (sort sorted (\u03bb (a b) (> a b)))]\n             [front (take array (quotient (length array) 2))]\n             [rear (reverse (drop array (quotient (length array) 2)))])\n        (if (even? sum_first_last)\n            (append front rear)\n            (append rear front)))))\n",
    "  (define (is-even? n) (= (remainder n 2) 0))\n  (define (sum-first-last array)\n    (define (sum-i-j i j) (+ (list-ref array i) (list-ref array j)))\n    (sum-i-j 0 (- (length array) 1)))\n  (define (sort-ascending array)\n    (sort array <))\n  (define (sort-descending array)\n    (sort array >))\n  (cond\n    [(empty? array) empty]\n    [(is-even? (sum-first-last array)) (sort-descending array)]\n    [else (sort-ascending array)]))",
    "  (if (empty? array)\n      array\n      (if (even? (+ (first array) (last array)))\n          (sort array >)\n          (sort array <))))",
    "  (if (empty? array)\n      array\n      (cond ((<= (add1 (car array)) (length array))\n             (cons (sort_array (sub1 (car array)))\n                   (sort_array (sub1 (cdr array)))))\n            (else (sort_array (sub1 (car array)))))))",
    "  (let ((smaller-than-first-index? (lambda (x)\n                                     (< x (vector-ref array 0))))\n        (greater-than-first-index? (lambda (x)\n                                     (> x (vector-ref array 0)))))\n    (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))))\n        (append (vector-map smaller-than-first-index? array)\n                (vector-map greater-than-first-index? array))\n        (append (vector-map greater-than-first-index? array)\n                (vector-map smaller-than-first-index? array)))))\n```\n\nBut we can't be sure of this yet. Let's try some tests.\n\n```racket",
    "  (define (sorti array)\n    (if (empty? array)\n        empty\n        (cons (first array) (sorti (sort-rest array)))))\n  (define (sort-rest array)\n    (if (empty? array)\n        empty\n        (sorti (filter (\u03bb (x) (eq? x (second array))) (rest array)))))\n  (sorti array))\n",
    "  (cond [(empty? array) empty]\n        [(even? (array-sum array)) (sort array >)]\n        [else (sort array <)]))\n",
    "  (cond [(empty? array) '()]\n        [(null? (cdr array)) array]\n        [(even? (+ (car array) (car (last array))))\n         (sort > array)]\n        [else (sort < array)]))\n",
    "  (sort array\n        (\u03bb (x y)\n          (let* ([s (add1 (+ (first array) (last array)))]\n                 [cx (cond [(= 0 (modulo x 2)) x]\n                           [else (sub1 x)])]\n                 [cy (cond [(= 0 (modulo y 2)) y]\n                           [else (sub1 y)])])\n            (if (even? s)\n                (or (> cx cy) (= cx cy))\n                (or (< cx cy) (= cx cy)))))))\n```\n* Examples:\n```racket",
    "  (define (even? x) (= (remainder x 2) 0))\n  (define (sort-ascending a b)\n    (cond [(< a b) #t]\n          [(> a b) #f]\n          [else #f]))\n  (define (sort-descending a b)\n    (cond [(> a b) #t]\n          [(< a b) #f]\n          [else #f]))\n  (define (sort-asc-or-desc lst)\n    (cond [(empty? lst) empty]\n          [(= (length lst) 1) lst]\n          [(even? (sum (first lst) (last lst))) (sort sort-descending lst)]\n          [else (sort sort-ascending lst)]))\n  (sort-asc-or-desc array))\n",
    "  (match array\n    [(list) array]\n    [(list _) array]\n    [(list _ _) (if (odd? (+ (car array) (last array)))\n                   (sort array <)\n                   (sort array >))]\n    [_ (if (odd? (+ (car array) (last array)))\n        (sort array <)\n        (sort array >))]))\n",
    "  (let loop ((array array) (result (list)))\n    (cond ((null? array) (reverse result))\n          ((= (remainder (+ (car array) (cadr array)) 2) 0) (loop (cdr array) (cons (car array) result)))\n          (else (loop (cdr array) (cons (car array) result))))))\n",
    "  (define (odd? x)\n    (= (remainder x 2) 1))\n  (define (sort-even array)\n    (sort array >))\n  (define (sort-odd array)\n    (sort array <))\n  (if (= (length array) 0)\n      array\n      (if (odd? (+ (array-ref array 0) (array-ref array (- (length array) 1))))\n          (sort-odd array)\n          (sort-even array))))\n",
    "  (cond [(empty? array) '()]\n        [(= (sum-even-odd? array) 0) (sort array >)]\n        [(= (sum-even-odd? array) 1) (sort array <)]))\n",
    "  (sort array (lambda (x y)\n                (if (= (modulo (+ (vector-ref array 0) (vector-ref array (vector-length array))) 2) 0)\n                    (> x y)\n                    (< x y)))))\n",
    "  (match array\n    ['() '()]\n    [array\n     (let ([sorted-list (list-sort < array)])\n       (match (add1 (modulo (add1 (length array)) 2))\n         [0 (reverse sorted-list)]\n         [_ sorted-list]))]))\n",
    "  (cond [(null? array) '()]\n        [(even? (add1 (length array))) (list-sort < array)]\n        [else (list-sort > array)]))",
    "  (cond\n    [(empty? array) array]\n    [(even? (add1 (last array)))\n     (reverse array)]\n    [else\n     (sort array <)]))\n",
    "  (sort\n   array\n   (lambda (a b)\n     (and\n      (let* ((array-length (length array))\n             (sum-index (modulo (+ 0 (sub1 array-length)) 2)))\n        (cond\n          ((= sum-index 0)\n           (and (> a b)) )\n          ((= sum-index 1)\n           (and (< a b)) ))) ))) )\n",
    "  (sort (lambda (x y)\n          (if (and (even? (+ (first array) (last array)))\n                   (< x y))\n              #t\n              (and (odd? (+ (first array) (last array)))\n                   (> x y))))\n        array))\n",
    "  (cond\n    [(empty? array) array]\n    [(even? (add1 (length array))) (reverse array)]\n    [else array]))\n",
    "  (if (= (length array) 0)\n      array\n      (if (= (length array) 1)\n          array\n          (if (odd? (+ (array-ref array 0) (array-ref array (- (length array) 1))))\n              (sort (array->list array) <)\n              (sort (array->list array) >)))))\n",
    "  (define (get-sum a b)\n    (+ a b))\n  (define (is-sorted? arr)\n    (and (not (null? arr))\n         (let loop ([arr (cdr arr)])\n           (or (null? arr)\n               (and (<= (car arr) (cadr arr))\n                    (loop (cdr arr)))))))\n  (define (bubble-sort arr)\n    (define (swap lst)\n      (cond [(null? lst) null]\n            [(null? (cdr lst)) lst]\n            [(< (cadr lst) (car lst)) (cons (cadr lst) (cons (car lst) (cddr lst)))]\n            [else (cons (car lst) (swap (cdr lst)))]))\n    (cond [(is-sorted? arr) arr]\n          [else (bubble-sort (swap arr))]))\n  (define (quick-sort arr)\n    (define (partition xs pivot-index)\n      (define (swap xs i j)\n        (define (swap-help xs a b)\n          (define (append x y)\n            (if (null? x) y\n                (cons (car x) (append (cdr x) y))))\n          (append (append (take xs a) (list (list-ref xs b)))\n                  (append (list (list-ref xs a)) (drop xs (+ b 1)))))\n        (swap-help xs i j))\n      (define (partition-help xs pivot-index result-list)\n        (cond [(null? xs) result-list]\n              [(< (car xs) (list-ref xs pivot-index))\n               (partition-help (cdr xs) pivot-index (append result-list (list (car xs))))]\n              [else (partition-help (cdr xs) pivot-index (append result-list (list (list-ref xs pivot-index))))]))\n      (define (take-drop xs n)\n        (if (< n 1) (values null xs)\n            (",
    "  (if (= (length array) 0)\n      array\n      (if (= (length array) 1)\n          array\n          (if (zero? (remainder (+ (first array) (last array)) 2))\n              (reverse array)\n              (sort < array)))))\n",
    "  (if (even? (add1 (length array)))\n      (sort array >)\n      (sort array <)))",
    "  (cond [(empty? array) empty]\n        [(empty? (rest array)) array]\n        [(if (odd? (+ (car array) (last array))) (odd? (car array)) (even? (car array)))\n         (cons (car array) (sort_array (rest array)))]\n        [else\n         (append (sort_array (cdr array)) (list (car array)))]))\n",
    "  (cond\n    [(empty? array) empty]\n    [(= (length array) 1) array]\n    [else\n     (let* ([mid (quotient (length array) 2)]\n            [left (take array mid)]\n            [right (drop array mid)]\n            [sum (add (car array) (car (reverse array)))])\n       (if (odd? sum)\n           (append (sort_array left) (sort_array right))\n           (append (reverse (sort_array left)) (reverse (sort_array right)))))]))\n```\n\n### Best practice:\n```\n#lang racket\n",
    "  (cond\n    [(empty? array) array]\n    [(= (length array) 1) array]\n    [else\n     (let ([sorted-array (sort (lambda (a b)\n                                 (if (even? (+ (first array) (last array)))\n                                     (> a b)\n                                     (< a b)))\n                               array)])\n       sorted-array)]))\n```\n\n```ruby\n#lang racket\n",
    "  (define (odd? index)\n    (odd? index))\n  (define (is-even? index)\n    (even? index))\n  (define (sum-of-first-and-last-value array)\n    (+ (array-ref array 0) (array-ref array (- (array-length array) 1))))\n  (define (sort-odd array)\n    (sort array <))\n  (define (sort-even array)\n    (sort array >))\n  (cond ((null? array) '())\n        ((array-length array) 1)\n        ((is-even? (sum-of-first-and-last-value array)) (sort-even array))\n        (else (sort-odd array))))\n",
    "  (sort array <))\n",
    "  (if (empty? array)\n      '()\n      (define len (length array))\n      (define sum (apply + (take array len)))\n      (if (odd? sum)\n          (sort array <)\n          (sort array >))))\n```\n\n#### JavaScript\n\n```js\n// Given an array of non-negative integers, return a copy of the given array after sorting,\n// you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n// or sort it in descending order if the sum( first index value, last index value) is even.\n// Note:\n// * don't change the given array.\n// Examples:\n// * sort_array([]) => []\n// * sort_array([5]) => [5]\n// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\nfunction sort_array(array) {\n  if (array.length == 0) {\n    return [];\n  }\n\n  var len = array.length;\n  var sum = array.slice(0, len).reduce((a, b) => a + b);\n  if (sum % 2 == 0) {\n    return array.sort((a, b) => b - a);\n  } else {\n    return array.sort((a, b) => a - b);\n  }\n}\n```\n\n#### Ruby\n\n```ruby\n# Given an array of non-negative integers, return a copy of the given array after sorting,\n# you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n# or sort it in descending order if the sum( first index value, last index value) is even.\n# Note:\n# * don't change the given array.\n# Examples:\n# * sort_array([]) => []\n# * sort_array([5]) => [5]\n# * sort_array([2, 4, 3, 0, 1, 5]) => [0,",
    "  (if (zero? (length array))\n      array\n      (sort_array_unsorted array (length array)\n                           (length array)\n                           (if (odd? (+ (first array) (last array)))\n                               ascending\n                               descending))))\n",
    "  (if (empty? array) '()\n      (cond [(= (modulo (+ (car array) (last array)) 2) 0)\n             (reverse array)]\n            [else\n             (sort array (\u03bb (a b) (&lt; a b)))])))\n</code>\nAm I on the right track?\n\n\nA:\n\nIt seems like you are on the right track. The only thing that I noticed was that you were mutating the variable <code>array</code> in the first part of the <code>cond</code>. This can be avoided by using <code>reverse</code> and <code>sort</code> with a key function. The key function will be a lambda that returns a boolean (true) or an integer (false). So,\n<code>(define (sort_array array)\n  (if (empty? array) '()\n      (if (zero? (modulo (+ (car array) (last array)) 2))\n          (sort array (\u03bb (a b) (&gt; a b)))\n          (reverse (sort array (\u03bb (a b) (&lt; a b)))))))\n</code>\n",
    "  (cond\n    [(empty? array) '()]\n    [(null? (cdr array)) array]\n    [else\n     (let ([s (+ (car array) (car (last array)))])\n       (cond\n         [(odd? s) (sort array <)]\n         [else (sort array >)]))]))",
    "  (if (empty? array)\n      empty\n      (if (= (length array) 1)\n          array\n          (if (even? (+ (first array) (last array)))\n              (quicksort (reverse array))\n              (quicksort array)))))\n```",
    "  (let ([odd? (odd? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))))])\n    (sort array (if odd? < >))))\n",
    "  (if (empty? array)\n      array\n      (if (= (list-length array) 1)\n          array\n          (if (odd? (+ (car array) (last array)))\n              (sort array <)\n              (sort array >)))))\n```\n\n### Kata7\n[Kata7](https://www.codewars.com/kata/57eae65a4321032ce000002d)\n\n```racket\n#lang racket\n",
    "  (cond\n    [(= (length array) 0) array]\n    [(= (length array) 1) array]\n    [(odd? (+ (first array) (last array)))\n     (list->vector (sort array (\u03bb (x y) (< x y))))]\n    [else\n     (list->vector (sort array (\u03bb (x y) (> x y))))]))\n",
    "  (if (zero? (remainder (+ (first array) (last array)) 2))\n      (sort array <)\n      (sort array >)))\n```\n\n## \u4f4e\u843d\u7684\u79d1\u6280\n\n> \u4e00\u4e2a\u540d\u53eb\u201cLow Tech Magazine\u201d\u7684\u7f51\u7ad9\u5f00\u59cb\u505a\u6280\u672f\u4e0a\u7684\u5b9e\u9a8c\uff0c\u5e0c\u671b\u80fd\u591f\u521b\u9020\u4e00\u4e2a\u80fd\u8fd0\u884c\u4e45\u4e00\u70b9\u7684\u7f51\u7ad9\uff0c\u4ee5\u53ca\u63d0\u4f9b\u4e00\u4e2a\u66f4\u771f\u5b9e\u7684\u7f51\u7edc\u7ecf\u9a8c\u3002\u4f5c\u4e3a\u6280\u672f\u7684\u4e00\u90e8\u5206\uff0c\u4ed6\u4eec\u51b3\u5b9a\u7528 HTML \u521b\u5efa\u4e00\u4e2a\u7f51\u7ad9\uff0c\u800c\u4e0d\u662f WordPress \u4e4b\u7c7b\u7684\u5de5\u5177\u3002\u4f46\u662f\uff0c\u4ed6\u4eec\u540e\u6765\u53d1\u73b0\uff0c\u4f7f\u7528 HTML \u521b\u5efa\u4e00\u4e2a\u7f51\u7ad9\u662f\u4ef6\u56f0\u96be\u7684\u4e8b\u3002\u6bcf\u6b21\u4ed6\u4eec\u8981\u4e3a\u7f51\u7ad9\u65b0\u589e\u4e00\u4e2a\u9875\u9762\uff0c\u4ed6\u4eec\u90fd\u8981\u590d\u5236\u5e76\u7c98\u8d34\u4e00\u4e2a\u57fa\u672c\u7684 HTML \u6846\u67b6\u3002\n>\n> \u8bf7\u4f60\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\uff0c\u4e3a\u4ed6\u4eec\u751f\u6210\u8fd9\u4e2a HTML \u6846\u67b6\u3002\u9664\u4e86\u63d0\u4f9b\u4e00\u4e2a\u51fd\u6570\u548c\u4e00\u4e2a URL \u4e4b\u5916\uff0c\u4f60\u5e94\u8be5\u4ec0\u4e48\u90fd\u4e0d\u505a\u3002\u4f60\u7684\u51fd\u6570\u5e94\u8be5\u4ea7\u751f\u4e00\u4e2a\u9002\u5f53\u7684 HTML \u6587\u6863\uff0c\u5b83\u7684\u9875\u7709\u5e94\u8be5\u5982\u4e0b\u6240\u793a\uff1a\n>\n> ```",
    "  (sort (lambda (a b) (if (odd? (+ (car array) (cadr (reverse array)))) (< a b) (> a b))) array))",
    "  (cond\n    [(empty? array) '()]\n    [(empty? (rest array)) array]\n    [else\n     (let ([first (first array)]\n           [last (last array)])\n       (if (even? (+ first last))\n           (sort (rest array) >)\n           (sort (rest array) <)))]))\n",
    "  (let ([sum (for/sum ([i (in-range (length array))]) (+ (vector-ref array i) i))])\n    (if (odd? sum)\n        (array-sort array <)\n        (array-sort array >))))\n",
    "  (if (empty? array)\n      '()\n      (if (< (length array) 2)\n          array\n          (if (odd? (+ (first array) (last array)))\n              (let ([sorted-array (sort array <)])\n                (cons (first sorted-array) (cons (last sorted-array) (butlast (butfirst sorted-array)))))\n              (let ([sorted-array (sort array >)])\n                (cons (first sorted-array) (cons (last sorted-array) (butlast (butfirst sorted-array)))))))))",
    "  (let* ([sum (apply + array)]\n         [n (length array)])\n    (if (= 0 (% sum n))\n        (sort array <)\n        (sort array >))))",
    "  (if (null? array)\n      array\n      (sort array <)))",
    "  (let ((first (car array))\n        (last (car (reverse array))))\n    (cond ((= (add1 (remainder (+ first last) 2)) 1)\n           (sort array <))\n          (else\n           (sort array >)))))",
    "  (if (null? array)\n      '()\n      (let* ([first (car array)]\n             [last (last array)]\n             [first_last (list first last)])\n        (if (odd? (apply + first_last))\n            (sort array <)\n            (sort array >)))))\n```\n\n```racket\n#lang racket\n",
    "  (if (even? (add1 (car array))) (sort array <) (sort array >)))\n```\n\n> https://www.codewars.com/kata/sorting-on-planet-twisted-3-7/train/racket\n\n```racket\n#lang racket\n",
    "  (if (= 0 (length array))\n      '()\n      (if (= 1 (length array))\n          array\n          (let ((first-value (vector-ref array 0))\n                (last-value (vector-ref array (- (length array) 1))))\n            (if (odd? (+ first-value last-value))\n                (ascending-sort-array array)\n                (descending-sort-array array))))))\n",
    "  (define (swap-two-elements arr n m)\n    (let ([tmp (vector-ref arr n)])\n      (vector-set! arr n (vector-ref arr m))\n      (vector-set! arr m tmp)))\n  (define (sort-sub-array arr n)\n    (let loop ([i 0])\n      (when (< i n)\n        (if (odd? (+ (vector-ref arr i) (vector-ref arr (- n 1 i))))\n            (swap-two-elements arr i (- n 1 i))\n            #f)\n        (loop (+ i 1)))))\n  (sort-sub-array array (vector-length array))\n  array)\n",
    "  (let ([n (length array)])\n    (if (odd? (+ (array-ref array 0) (array-ref array (- n 1))))\n        (sort array <)\n        (sort array >))))",
    "  (cond\n    [(empty? array) '()]\n    [(= (length array) 1) array]\n    [else\n     (begin\n       (define (partition array pivot-pos)\n         (define pivot (list-ref array pivot-pos))\n         (define (collect-smaller-elements array pivot-pos left-pos)\n           (cond\n             [(= (length array) left-pos)\n              (list (reverse array) pivot-pos)]\n             [(<= (list-ref array left-pos) pivot)\n              (collect-smaller-elements array pivot-pos (+ left-pos 1))]\n             [else\n              (collect-smaller-elements (append (list (list-ref array left-pos)) (remove (list-ref array left-pos) array)) pivot-pos (+ left-pos 1))]))\n         (define (collect-larger-elements array pivot-pos right-pos)\n           (cond\n             [(= (- (length array) 1) right-pos)\n              (list (reverse array) (- right-pos 1))]\n             [(>= (list-ref array right-pos) pivot)\n              (collect-larger-elements array pivot-pos (- right-pos 1))]\n             [else\n              (collect-larger-elements (append (list (list-ref array right-pos)) (remove (list-ref array right-pos) array)) pivot-pos (- right-pos 1))]))\n         (define (swap array pivot-pos left-pos)\n           (define left-element (list-ref array left-pos))\n           (define (replace-at array index value)\n             (append (sublist array 0 index) (list value) (sublist array (+ index 1) (length array))))\n           (define (swap-and-collect array pivot-pos left-pos right-pos)\n             (append (reverse (sublist array 0 left-pos)) (list (list-ref array right-pos)) (reverse (sublist array left-pos right-pos)) (list left-element) (sublist array (+ right-pos 1) (length array))))\n           (if (= left-pos pivot-pos)\n               (swap-and-collect array pivot",
    "  (if (empty? array)\n      '()\n      (let ((first (first array))\n            (last (last array)))\n        (quicksort array\n                   (if (even? (+ first last))\n                       >\n                       <)))))\n",
    "  (cond\n    [(or (empty? array) (= (length array) 1)) array]\n    [(even? (+ (first array) (last array)))\n     (list-sort array >)]\n    [else\n     (list-sort array <)]))\n",
    "  (if (null? array)\n      array\n      (if (= (modulo (+ (car array) (last array)) 2) 0)\n          (sort array <)\n          (sort array >))))\n```\n\n## Test Cases\n\n```racket",
    "  (define (check-sum a b)\n    (if (odd? (+ a b))\n        #t\n        #f))\n  (define (sort-array-aux array a b)\n    (if (equal? a 0)\n        array\n        (sort-array-aux (if (check-sum (list-ref array a) (list-ref array (- b 1)))\n                            (reverse (remove (list-ref array a) (append (list (list-ref array a)) (sort-array-aux (remove (list-ref array (- b 1)) array) (- a 1) (- b 2)))))\n                            (reverse (remove (list-ref array (- b 1)) (append (list (list-ref array (- b 1))) (sort-array-aux (remove (list-ref array a) array) (- a 1) (- b 2)))))) (- a 1) (- b 1)))\n  (if (empty? array)\n      array\n      (sort-array-aux array (- (length array) 1) (length array))))\n",
    "  (cond ((empty? array) '())\n        ((= (length array) 1) array)\n        ((even? (+ (first array) (last array)))\n         (sort >= array))\n        (else (sort <= array))))\n",
    "  (define (odd? n) (= (remainder n 2) 1))\n  (define (first a) (array-ref a 0))\n  (define (last a) (array-ref a (- (array-length a) 1)))\n  (if (null? array) array\n      (if (odd? (+ (first array) (last array))) (sort array <) (sort array >))))\n",
    "  (let ([len (array-length array)])\n    (if (odd? (+ (array-ref array 0) (array-ref array (- len 1))))\n        (sort array <)\n        (sort array >))))\n```\n\n```\n#lang racket\n",
    "  (sort (if (odd? (+ (car array) (cadr (reverse array)))) array (reverse array))))\n",
    "  (cond\n    [(empty? array) array]\n    [(> (count array) 1)\n     (sort array (\u03bb (a b)\n                   (define sum (+ (first array) (last array)))\n                   (if (odd? sum) (< a b) (> a b))))]\n    [else array]))",
    "  (if (= (length array) 0)\n      array\n      (let ([first (first array)]\n            [last (last array)])\n        (if (odd? (+ first last))\n            (sort array <)\n            (sort array >)))))\n",
    "  (let ([len (vector-length array)])\n    (if (odd? (+ (vector-ref array 0) (vector-ref array (- len 1))))\n        (sort array <)\n        (sort array >))))"
  ],
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ]
}