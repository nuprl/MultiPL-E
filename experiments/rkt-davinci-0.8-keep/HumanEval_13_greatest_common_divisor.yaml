name: HumanEval_13_greatest_common_divisor
language: rkt
prompt: "#lang racket\n\n;; Return a greatest common divisor of two integers a and\
  \ b\n;; >>> greatest_common_divisor(3, 5)\n;; 1\n;; >>> greatest_common_divisor(25,\
  \ 15)\n;; 5\n(define (greatest_common_divisor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate greatest_common_divisor))\n\
  \    (check-equal? (candidate 3 7) 1)\n    (check-equal? (candidate 10 15) 5)\n\
  \    (check-equal? (candidate 49 14) 7)\n    (check-equal? (candidate 144 60) 12)\n\
  ))\n\n(test-humaneval)"
completions: ["  (if (= b 0)\n      a\n      (greatest_common_divisor b (% a b))))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (let loop ([d (abs a)] [e (abs b)])\n    (cond\n      [(< d e) (loop d (- e\
    \ d))]\n      [(> d e) (loop (- d e) e)]\n      [else d])))\n```\n\n### Chapter\
    \ 11.8\n\n#### Ex.11.8.1\n\n[Source code](ex-11-8-1.rkt)\n\n```racket\n#lang racket\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n\
    \  (if (&lt; a b)\n      (gcd b a)\n      (gcd a b)))\n", "  (if (= a 0)\n   \
    \   b\n      (greatest_common_divisor (modulo b a) a)))\n\n", "  (if (= a 0)\n\
    \      b\n      (greatest_common_divisor (modulo b a) a)))\n", "  (let ([abs-a\
    \ (abs a)]\n        [abs-b (abs b)])\n    (cond [(= abs-a 0) abs-b]\n        \
    \  [(= abs-b 0) abs-a]\n          [(and (even? abs-a) (even? abs-b))\n       \
    \    (* 2 (greatest_common_divisor (/ abs-a 2) (/ abs-b 2)))]\n          [(even?\
    \ abs-a) (greatest_common_divisor (/ abs-a 2) abs-b)]\n          [(even? abs-b)\
    \ (greatest_common_divisor abs-a (/ abs-b 2))]\n          [(> abs-a abs-b) (greatest_common_divisor\
    \ (- abs-a abs-b) abs-b)]\n          [else (greatest_common_divisor abs-a (- abs-b\
    \ abs-a))])))\n", "  (define (gcd a b)\n    (cond [(= b 0) a]\n          [else\
    \ (gcd b (modulo a b))]))\n  (if (&lt; a b)\n      (gcd b a)\n      (gcd a b)))\n",
  "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor\
    \ b a)]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (define (iter\
    \ a b (count 1))\n    (cond [(> a b) (iter b a count)]\n          [(= b 0) a]\n\
    \          [else (iter b (% a b) (+ count 1))]))\n  (iter a b 1))\n```", "  (let\
    \ ((a (abs a))\n        (b (abs b)))\n    (cond ((< a b) (greatest_common_divisor\
    \ b a))\n          ((= a 0) b)\n          (else (greatest_common_divisor (- a\
    \ b) b)))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor\
    \ a (- b a))]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (define\
    \ (iter a b)\n    (if (= b 0)\n        a\n        (iter b (modulo a b))))\n  (iter\
    \ (abs a) (abs b)))\n```\n\n## Problem 3:\nImplement a function that returns true\
    \ if the given integer is an ugly number, otherwise it returns false.\n\nUgly\
    \ numbers are positive numbers whose prime factors only include 2, 3, 5.\n\nExample\
    \ 1:\n\n```racket", "  (define (gcd a b)\n    (if (= b 0)\n        a\n       \
    \ (gcd b (remainder a b))))\n  (gcd (abs a) (abs b)))\n", "  (cond [(= a 0) b]\n\
    \        [(= b 0) a]\n        [(= a b) a]\n        [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n        [else (greatest_common_divisor a (- b a))]))\n", "  (define\
    \ (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n \
    \ (gcd (abs a) (abs b)))\n", "  (let ((a (abs a))\n        (b (abs b)))\n    (cond\n\
    \      [(< a b) (greatest_common_divisor a (- b a))]\n      [(< b a) (greatest_common_divisor\
    \ (- a b) b)]\n      [else a])))\n", "  (greatest_common_divisor_recursive (max\
    \ a b) (min a b)))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(> a b)\
    \ (greatest_common_divisor (- a b) b)]\n    [else (greatest_common_divisor a (-\
    \ b a))]))\n\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n", "  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd\
    \ b (remainder a b))))\n  (if (< b a)\n      (gcd b a)\n      (gcd a b)))\n",
  "  (cond [(= a 0) b]\n        [(= b 0) a]\n        [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n        [else (greatest_common_divisor a (- b a))]))\n", "  (if\
    \ (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond\
    \ [(zero? a) b]\n        [(zero? b) a]\n        [(< a b)\n         (greatest_common_divisor\
    \ a (- b a))]\n        [else\n         (greatest_common_divisor (- a b) b)]))\n",
  "  (cond [(= b 0) a]\n        [else (greatest_common_divisor b (modulo a b))]))\n",
  "  (if (= a 0)\n      b\n      (greatest_common_divisor (modulo b a) a)))\n", " \
    \ (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor\
    \ a (- b a))]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (define\
    \ (gcd_iter a b)\n    (cond ((= b 0) a)\n          (else (gcd_iter b (remainder\
    \ a b)))))\n  (if (&lt; a b) (gcd_iter b a) (gcd_iter a b)))\n", "  (let ([x (abs\
    \ a)]\n        [y (abs b)])\n    (if (= x 0)\n        y\n        (greatest_common_divisor\
    \ y (modulo x y)))))\n", "  (cond [(= a 0) b]\n        [(= b 0) a]\n        [(>\
    \ a b) (greatest_common_divisor (- a b) b)]\n        [else (greatest_common_divisor\
    \ a (- b a))]))\n", "  (cond\n    [(or (zero? a) (zero? b))\n     1]\n    [(=\
    \ 0 (modulo a b))\n     b]\n    [else\n     (greatest_common_divisor b (modulo\
    \ a b))]))\n```\n\n### Solution 2\n\nBy Euclid's algorithm.\n\n```racket\n#lang\
    \ racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (define (abs x)\n    (if (< x 0)\n        (- x)\n        x))\n\
    \  (cond ((= a 0) (abs b))\n        ((= b 0) (abs a))\n        ((= a b) (abs a))\n\
    \        ((> a b) (greatest_common_divisor (- a b) b))\n        ((< a b) (greatest_common_divisor\
    \ a (- b a)))))\n```\n\n```racket\n#lang racket\n", "  (define (iter a b)\n  \
    \  (if (= a 0)\n        b\n        (iter (modulo b a) a)))\n  (iter a b))\n",
  "  (define (recurse a b)\n    (if (= b 0)\n        a\n        (recurse b (modulo\
    \ a b))))\n  (let loop ([a (abs a)] [b (abs b)])\n    (if (&lt; a b)\n       \
    \ (recurse b a)\n        (recurse a b))))\n", "  (let loop ([a (abs a)] [b (abs\
    \ b)])\n    (cond [(= b 0) a]\n          [else (loop b (modulo a b))])))\n", " \
    \ (cond ((< a 0) (greatest_common_divisor (abs a) b))\n        ((< b 0) (greatest_common_divisor\
    \ a (abs b)))\n        ((< a 0) (greatest_common_divisor (abs a) (abs b)))\n \
    \       ((< a b) (greatest_common_divisor b a))\n        ((= a b) a)\n       \
    \ ((= 0 (modulo a b)) b)\n        (else (greatest_common_divisor b (modulo a b)))))\n\
    ```\n\n### `egyptian_fraction(numerator, denominator)`\n\n```racket\n#lang racket\n",
  "  (let ([sub (sub1 a)])\n    (cond\n      [(equal? a b) a]\n      [(equal? a sub)\
    \ 1]\n      [(equal? b sub) 1]\n      [(= (modulo a sub) 0) (greatest_common_divisor\
    \ sub b)]\n      [(= (modulo b sub) 0) (greatest_common_divisor a sub)]\n    \
    \  [else (greatest_common_divisor sub b)])))\n```\n\n```py\n#lang python\n\n#\
    \ Return a greatest common divisor of two integers a and b\n# >>> greatest_common_divisor(3,\
    \ 5)\n# 1\n# >>> greatest_common_divisor(25, 15)\n# 5\ndef greatest_common_divisor(a,\
    \ b):\n    sub = a - 1\n    if a == b:\n        return a\n    elif a == sub:\n\
    \        return 1\n    elif b == sub:\n        return 1\n    elif a % sub == 0:\n\
    \        return greatest_common_divisor(sub, b)\n    elif b % sub == 0:\n    \
    \    return greatest_common_divisor(a, sub)\n    else:\n        return greatest_common_divisor(sub,\
    \ b)\n```\n\n```ruby\n#lang ruby\n\n# Return a greatest common divisor of two\
    \ integers a and b\n# >>> greatest_common_divisor(3, 5)\n# 1\n# >>> greatest_common_divisor(25,\
    \ 15)\n# 5\ndef greatest_common_divisor(a, b)\n  sub = a - 1\n  if a == b\n  \
    \  a\n  elsif a == sub\n    1\n  elsif b == sub\n    1\n  elsif a % sub == 0\n\
    \    greatest_common_divisor(sub, b)\n  elsif b % sub == 0\n    greatest_common_divisor(a,\
    \ sub)\n  else\n    greatest_common_divisor(sub, b)\n  end\nend\n```\n\n```clojure\n\
    #lang clojure\n", "  (let* ([diff (abs (- a b))]\n         [small (min a b)])\n\
    \    (cond\n      [(&lt;= diff small) diff]\n      [else (greatest_common_divisor\
    \ diff small)])))\n", "  (cond\n    ((= a 0) b)\n    ((= b 0) a)\n    ((> a b)\
    \ (greatest_common_divisor (- a b) b))\n    ((< a b) (greatest_common_divisor\
    \ a (- b a)))))\n```\n\n```racket\n#lang racket\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (% a b))))\n\n", "  (if (= b 0)\n      a\n \
    \     (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= a 0)\n      b\n\
    \      (greatest_common_divisor (- b (% a b)) a)))\n```\n\n#### Exercise 2\n\n\
    ```racket\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (find-min a b)\n    (if (&lt; a b)\n      \
    \  a\n        b))\n  (define (greatest-common-divisor a b)\n    (let loop ((a\
    \ a) (b b))\n      (if (= b 0)\n          a\n          (loop b (remainder a b)))))\n\
    \  (greatest-common-divisor (find-min a b) (find-min b a)))\n</code>\nI'm looking\
    \ for feedback on anything you'd consider a bad practice or if there is a better\
    \ way to write it in Racket.\n\n\nA:\n\nI think your code looks good.\nHere are\
    \ a few suggestions:\n\nYou're using the idiomatic naming style, where functions\
    \ that return a boolean value have a name starting with <code>is-</code>. You're\
    \ doing this for <code>find-min</code>, but since it returns a number and not\
    \ a boolean, I would call it <code>min</code> instead. Note that there is a built-in\
    \ <code>min</code> function that does the same thing, so you should avoid using\
    \ that name for your own functions.\nYou're using exactly the same definition\
    \ for <code>greatest-common-divisor</code> and <code>greatest_common_divisor</code>.\
    \ You don't need to define both functions.\nIn the <code>greatest-common-divisor</code>\
    \ function, I would explicitly use <code>zero?</code> instead of just <code>=</code>\
    \ when checking if the number is zero.\nThe <code>find-min</code> function calls\
    \ itself recursively. But since you only call it once, you don't need to define\
    \ it as a recursive function. You can just use a simple <code>cond</code> expression.\n\
    \nHere's the code after applying all the suggestions:\n<code>(define (greatest-common-divisor\
    \ a b)\n  (define (min a b)\n    (cond\n      [(&lt; a b) a]\n      [else b]))\n\
    \  (let loop ((a a) (b b))\n    (cond\n      [(zero? b) a]\n      [else (loop\
    \ b (remainder a b))])))", "  (if (= 0 (remainder b a))\n      a\n      (greatest_common_divisor\
    \ b (remainder b a))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n", "  (cond [(= b 0) a]\n        [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (letrec ([gcd (\u03BB (a b)\n                  (if\
    \ (= b 0)\n                      a\n                      (gcd b (modulo a b))))])\n\
    \    (gcd a b)))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor (modulo\
    \ b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor (- b (%\
    \ a b)) a)))\n```\n\n## Fibonacci sequence\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor a (-\
    \ b a))]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (define (gcd\
    \ x y)\n    (if (= y 0)\n        x\n        (gcd y (modulo x y))))\n  (if (> a\
    \ b)\n      (gcd a b)\n      (gcd b a)))\n", "  (define (helper a b)\n    (if\
    \ (= b 0)\n        a\n        (helper b (modulo a b))))\n  (if (< a b)\n     \
    \ (helper b a)\n      (helper a b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (let ([abs-a (abs a)]\n        [abs-b (abs b)])\n \
    \   (cond\n      [(= abs-a 0) abs-b]\n      [(= abs-b 0) abs-a]\n      [(> abs-a\
    \ abs-b) (greatest_common_divisor (- abs-a abs-b) abs-b)]\n      [else (greatest_common_divisor\
    \ abs-a (- abs-b abs-a))])))\n", "  (define (smaller a b)\n    (if (< a b)\n \
    \       a\n        b))\n  (define (greater a b)\n    (if (< a b)\n        b\n\
    \        a))\n  (define (gcd a b)\n    (if (zero? b)\n        a\n        (gcd\
    \ b (remainder a b))))\n  (gcd (greater a b) (smaller a b)))\n", "  (cond\n  \
    \  [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor (- b a)\
    \ a)]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (if (= b 0)\n \
    \     a\n      (greatest_common_divisor b (modulo a b))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond [(= b 0) a]\n        [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (let ([min (min a b)])\n    (let loop ([i min])\n\
    \      (if (= 0 (modulo a i))\n          (if (= 0 (modulo b i))\n            \
    \  i\n              (loop (- i 1)))\n          (loop (- i 1))))))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (gcd\
    \ a b))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (greatest_common_divisor_helper (abs a) (abs b)))\n", "  (define\
    \ (divisor a b)\n    (if (= b 0)\n        a\n        (divisor b (modulo a b))))\n\
    \  (divisor (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```\n\n## Task 13\n\nImplement the least common multiple of two integers\n\
    \n```#lang racket\n", "  (define (greatest_common_divisor-iter a b c)\n    (if\
    \ (= b 0)\n        c\n        (greatest_common_divisor-iter b (modulo a b) c)))\n\
    \  (greatest_common_divisor-iter a b 1))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n## Comparison\n\n```racket\n#lang racket\n", "  (cond\
    \ [(> a b) (greatest_common_divisor b a)]\n        [(= b 0) a]\n        [else\
    \ (greatest_common_divisor b (- a b))]))\n", "  (cond\n    [(= a 0) b]\n    [(=\
    \ b 0) a]\n    [(> a b) (greatest_common_divisor (- a b) b)]\n    [else (greatest_common_divisor\
    \ a (- b a))]))\n", "  (define (loop a b)\n    (if (= a 0)\n        b\n      \
    \  (loop (modulo b a) a)))\n  (loop a b))\n\n", "  (cond [(= b 0) a]\n       \
    \ [else (greatest_common_divisor b (modulo a b))]))\n", "  (cond\n    [(= a 0)\
    \ b]\n    [(= b 0) a]\n    [(> a b) (greatest_common_divisor (- a b) b)]\n   \
    \ [else (greatest_common_divisor a (- b a))]))\n", "  (cond\n    [(zero? b) a]\n\
    \    [else (greatest_common_divisor b (modulo a b))]))\n", "  (if (= b 0)\n  \
    \    a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond\n    [(zero?\
    \ b) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n", "  (if (= b\
    \ 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (let loop\
    \ ([a a] [b b])\n    (if (= b 0)\n        a\n        (loop b (modulo a b)))))\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", " \
    \ (if (= b 0)\n      a\n      (greatest_common_divisor b (% a b))))\n", "  (cond\n\
    \    [(> a b) (greatest_common_divisor (- a b) b)]\n    [(> b a) (greatest_common_divisor\
    \ a (- b a))]\n    [else a]))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (local ((define (gcd a b)\n            (if (= b 0)\n\
    \                a\n                (gcd b (remainder a b)))))\n    (gcd (abs\
    \ a) (abs b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b\
    \ (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor\
    \ b a)]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= 0 b)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (let loop ([a\
    \ (if (positive? a) a (- a))]\n             [b (if (positive? b) b (- b))])\n\
    \    (if (zero? a)\n        b\n        (loop b (modulo a b)))))\n", "  (cond\n\
    \    [(= a 0) b]\n    [(= b 0) a]\n    [(> a b) (greatest_common_divisor (- a\
    \ b) b)]\n    [else (greatest_common_divisor a (- b a))]))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (% a b))))\n", "  (if (= b 0)\n   \
    \   a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n \
    \     a\n      (greatest_common_divisor b (modulo a b))))\n", "  (gcd (abs a)\
    \ (abs b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n```", "  (cond ((= a 0) b)\n        ((= b 0) a)\n        ((< a b) (greatest_common_divisor\
    \ a (- b a)))\n        (else (greatest_common_divisor (- a b) b))))\n```\n\n```racket",
  "  (cond [(zero? b) a]\n        [else (greatest_common_divisor b (modulo a b))]))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond ((= a 0) b)\n        ((= b 0) a)\n        ((&lt;\
    \ a b) (greatest_common_divisor a (- b a)))\n        (else (greatest_common_divisor\
    \ (- a b) b))))\n", "  (let loop ([a a] [b b])\n    (cond [(= b 0) a]\n      \
    \    [else (loop b (modulo a b))])))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (gcd a b c)\n    (if (= b 0)\n        c\n \
    \       (gcd b (modulo a b) (greatest_common_divisor b (modulo a b)))))\n  (gcd\
    \ a b 0))\n```\n\n## <a name=\"7\">\u041D\u0430\u0438\u0431\u043E\u043B\u044C\u0448\
    \u0438\u0439 \u043E\u0431\u0449\u0438\u0439 \u0434\u0435\u043B\u0438\u0442\u0435\
    \u043B\u044C \u0447\u0438\u0441\u0435\u043B \u0441\u043F\u0438\u0441\u043A\u0430\
    \n\n```racket\n#lang racket\n", "  (define (gcd a b)\n    (if (= b 0)\n      \
    \  a\n        (gcd b (remainder a b))))\n  (gcd (abs a) (abs b)))\n", "  (cond\n\
    \    [(zero? a) b]\n    [(zero? b) a]\n    [(< a b) (greatest_common_divisor a\
    \ (- b a))]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (cond ((=\
    \ b 0) a)\n        (else (greatest_common_divisor b (modulo a b)))))\n", "  (cond\
    \ ((zero? b) a)\n        (else (greatest_common_divisor b\n                  \
    \                     (remainder a b)))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (letrec\n      ([gcd (lambda (a b)\n              (cond\n\
    \                [(zero? b) a]\n                [else (gcd b (remainder a b))]))])\n\
    \    (gcd a b)))\n```\n\n### 1.3 Write a function that takes a non-negative integer\
    \ and returns the largest integer whose square is less than or equal to the integer\
    \ given.\n\n```\n#lang racket\n", "  (define (gcd a b)\n    (if (= a 0)\n    \
    \    b\n        (gcd (modulo b a) a)))\n  (if (= a 0)\n      (abs b)\n      (gcd\
    \ (abs a) (abs b))))\n\n", "  (let* ([a-abs (abs a)]\n         [b-abs (abs b)])\n\
    \    (cond\n      [(= a-abs 0) b-abs]\n      [(= b-abs 0) a-abs]\n      [(< a-abs\
    \ b-abs) (greatest_common_divisor a-abs (- b-abs a-abs))]\n      [else (greatest_common_divisor\
    \ b-abs (- a-abs b-abs))])))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n#### euclidean_algorithm\n\n```racket\n#lang racket\n",
  "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n```\n\
    \n```scheme\n#lang racket\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (define (gcd b a)\n    (if (= b 0)\n        a\n   \
    \     (gcd (modulo a b) b)))\n  (gcd a b))\n", "  (cond [(= a 0) b]\n        [(=\
    \ b 0) a]\n        [(> a b) (greatest_common_divisor (- a b) b)]\n        [else\
    \ (greatest_common_divisor a (- b a))]))\n", "  (cond\n    [(= a 0) b]\n    [(=\
    \ b 0) a]\n    [(= a b) a]\n    [(< a b) (greatest_common_divisor a (- b a))]\n\
    \    [else (greatest_common_divisor (- a b) b)]))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n      a\n\
    \      (greatest_common_divisor b (modulo a b))))\n", "  (cond ((= a 0) b)\n \
    \       ((= b 0) a)\n        ((< a b) (greatest_common_divisor a (- b a)))\n \
    \       (else (greatest_common_divisor (- a b) b))))\n", "  (if (= b 0)\n    \
    \  a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n  \
    \    a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (= b 0)\n\
    \      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (define (gcd\
    \ a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (gcd\
    \ (abs a) (abs b)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (define (gcd a b)\n    (cond\n      [(= b 0) a]\n \
    \     [else (gcd b (modulo a b))]))\n  (gcd (abs a) (abs b)))\n", "  (if (= b\
    \ 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond [(> a b) (greatest_common_divisor (- a b) b)]\n    \
    \    [(> b a) (greatest_common_divisor a (- b a))]\n        [else a]))\n", " \
    \ (if (= a 0)\n      b\n      (greatest_common_divisor b (% a b))))\n", "  (let\
    \ ((d (gcd a b)))\n    d))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n```\n\n### 2.3.2. Compute the Lowest Common Multiple\n\n```racket\n\
    #lang racket\n", "  (cond ((< a b) (greatest_common_divisor b a))\n        ((=\
    \ a b) a)\n        ((> a b) (greatest_common_divisor a (- a b)))))\n", "  (define\
    \ (gcd a b)\n    (cond ((= b 0) a)\n          (else (gcd b (remainder a b)))))\n\
    \  (if (and (integer? a) (integer? b))\n      (if (> a b)\n          (gcd a b)\n\
    \          (gcd b a))\n      (error \"greatest_common_divisor: arguments must\
    \ be integers\")))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (% a b))))\n", "  (cond ((<= a b)\n         (greatest_common_divisor b a))\n\
    \        ((= 0 (modulo a b))\n         b)\n        (else\n         (greatest_common_divisor\
    \ b (modulo a b)))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a\
    \ b) (greatest_common_divisor b a)]\n    [else (greatest_common_divisor b (modulo\
    \ a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (cond\n    [(or (= a 0) (= b 0)) 0]\n    [(= a b) a]\n    [(<\
    \ a b) (greatest_common_divisor (- b a) a)]\n    [else (greatest_common_divisor\
    \ (- a b) b)]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b\
    \ (modulo a b))))\n", "  (define (gcd a b)\n    (if (= b 0)\n        a\n     \
    \   (gcd b (remainder a b))))\n  (gcd (abs a) (abs b)))\n", "  (cond\n    [(zero?\
    \ b) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n", "  (if (= b\
    \ 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (let ((gcd\
    \ (and (zero? a) b))\n        (a (abs a))\n        (b (abs b)))\n    (if (zero?\
    \ gcd)\n        (let loop ((a a) (b b))\n          (if (zero? b)\n           \
    \   a\n              (loop b (remainder a b))))\n        gcd)))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond\
    \ [(> b a) (greatest_common_divisor b a)]\n        [(= b 0) a]\n        [else\
    \ (greatest_common_divisor b (modulo a b))]))\n", "  (cond\n    [(= b 0) a]\n\
    \    [else (greatest_common_divisor b (modulo a b))]))\n", "  (let ([g (gcd a\
    \ b)])\n    (display g)\n    (newline)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n## Solution\n\n```racket", "  (let ([a (abs a)]\n\
    \        [b (abs b)])\n    (if (= a 0)\n        b\n        (greatest_common_divisor\
    \ (modulo b a) a))))\n", "  (define (gcd a b)\n    (cond ((= a 0) b)\n       \
    \   ((= b 0) a)\n          ((= a b) a)\n          ((< a b) (gcd a (- b a)))\n\
    \          ((> a b) (gcd (- a b) b))))\n  (if (= a 0)\n      0\n      (gcd (abs\
    \ a) (abs b))))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b\
    \ (modulo a b))))\n", "  (if (= a 0)\n      b\n      (greatest_common_divisor\
    \ (modulo b a) a)))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n", "  (cond [(= a 0) (abs b)]\n        [(= b 0) (abs a)]\n\
    \        [(= a b) (abs a)]\n        [(< a b) (greatest_common_divisor (+ a a)\
    \ (- b a))]\n        [else (greatest_common_divisor (+ b b) (- a b))]))\n", " \
    \ (cond\n    [(= a 0) b]\n    [(= b 0) a]\n    [(< a b) (greatest_common_divisor\
    \ (- b a) a)]\n    [else (greatest_common_divisor (- a b) b)]))\n", "  (greatest_common_divisor_iter\
    \ a b a))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (% a b))))\n\
    \n", "  (define (gcd a b)\n    (cond\n      [(= b 0) a]\n      [else (gcd b (modulo\
    \ a b))]))\n  (let ([a (abs a)]\n        [b (abs b)])\n    (gcd a b)))\n", " \
    \ (cond\n    [(= b 0) a]\n    [else (greatest_common_divisor b (modulo a b))]))\n",
  "  (let loop ((a a) (b b))\n    (if (= b 0)\n        a\n        (loop b (modulo\
    \ a b)))))\n\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor b (modulo\
    \ a b))))\n", "  (define (iter a b)\n    (cond [(= a 0) b]\n          [(= b 0)\
    \ a]\n          [(> a b) (iter (- a b) b)]\n          [else (iter a (- b a))]))\n\
    \  (iter (abs a) (abs b)))\n", "  (cond [(= b 0) a]\n        [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (cond\n    [(= b 0) a]\n    [else (greatest_common_divisor\
    \ b (modulo a b))]))\n", "  (if (= b 0)\n      a\n      (greatest_common_divisor\
    \ b (modulo a b))))\n```\n\n```scheme\n#lang racket\n", "  (if (= 0 b)\n     \
    \ a\n      (greatest_common_divisor b (modulo a b))))\n", "  (cond\n    [(= a\
    \ 0) (abs b)]\n    [(= b 0) (abs a)]\n    [(< a 0) (greatest_common_divisor (-\
    \ a) b)]\n    [(< b 0) (greatest_common_divisor a (- b))]\n    [(> a b) (greatest_common_divisor\
    \ (- a b) b)]\n    [else (greatest_common_divisor a (- b a))]))\n", "  (if (=\
    \ b 0)\n      a\n      (greatest_common_divisor b (modulo a b))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond [(or (positive? a) (positive? b))\n         (cond [(<\
    \ a b)\n                (greatest_common_divisor b a)]\n               [(= (modulo\
    \ a b) 0)\n                b]\n               [else\n                (greatest_common_divisor\
    \ b (modulo a b))])]\n        [else\n         0]))\n", "  (define (divides? a\
    \ b)\n    (= (% b a) 0))\n  (define (gcd a b)\n    (if (= b 0)\n        a\n  \
    \      (gcd b (% a b))))\n  (cond [(divides? a b) a]\n        [(divides? b a)\
    \ b]\n        [else (gcd a b)]))\n", "  (cond\n    [(= a 0) b]\n    [(= b 0) a]\n\
    \    [(= a b) a]\n    [(< a b) (greatest_common_divisor a (- b a))]\n    [else\
    \ (greatest_common_divisor (- a b) b)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
