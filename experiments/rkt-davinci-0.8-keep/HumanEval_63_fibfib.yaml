name: HumanEval_63_fibfib
language: rkt
prompt: "#lang racket\n\n;; The FibFib number sequence is a sequence similar to the\
  \ Fibbonacci sequnece that's defined as follows:\n;; fibfib(0) == 0\n;; fibfib(1)\
  \ == 0\n;; fibfib(2) == 1\n;; fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n\
  ;; Please write a function to efficiently compute the n-th element of the fibfib\
  \ number sequence.\n;; >>> fibfib(1)\n;; 0\n;; >>> fibfib(5)\n;; 4\n;; >>> fibfib(8)\n\
  ;; 24\n(define (fibfib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fibfib))\n\
  \    (check-equal? (candidate 2) 1)\n    (check-equal? (candidate 1) 0)\n    (check-equal?\
  \ (candidate 5) 4)\n    (check-equal? (candidate 8) 24)\n    (check-equal? (candidate\
  \ 10) 81)\n    (check-equal? (candidate 12) 274)\n    (check-equal? (candidate 14)\
  \ 927)\n))\n\n(test-humaneval)"
completions: ["  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n   \
    \     (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\nHow would I use the memoization\
    \ technique to make this more efficient?\nI've been following this guide: http://www.greghendershott.com/fibonacci.html.\
    \ But I'm not quite sure how to implement it in this case.\n\n\nA:\n\nThe <code>memoize</code>\
    \ procedure provided in the guide returns a new function that remembers the values\
    \ of <code>f</code> for arguments that have already been computed.  Your function\
    \ has three recursive calls, so you need to memoize each of them.  The technique\
    \ is similar to the one in the article, except you need to pass the memoized function\
    \ to itself so that each recursive call uses the memoized version of the function.\n\
    <code>(define (fibfib n)\n  (define fibfib2\n    (memoize\n     (lambda (n1 n2\
    \ n3)\n       (cond\n         [(= n 0) 0]\n         [(= n 1) 0]\n         [(=\
    \ n 2) 1]\n         [else (fibfib2 (- n 1) n2 n3)]\n         [(= n 3) (+ n1 n2\
    \ n3)]\n         [else (fibfib2 (- n 1) (- n 2) (- n 3))]))))\n  (fibfib2 0 0\
    \ 1))\n</code>\nTo understand how this works, note that <code>fibfib2</code> remembers\
    \ the value of <code>fibfib</code> for the arguments <code>n1</code>, <code>n2</code>,\
    \ and <code>n3</code>.  The first three lines of the <code>cond</code> check for\
    \ the common cases (base cases), and the remaining ones handle the recursive calls.\
    \  The call to <code>fibfib2</code> with <code>n1</code>, <code>n2</code>, and\
    \ <code>n3</code> as arguments corresponds to the first recursive call in", " \
    \ (if (< n 2)\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-iter a b\
    \ c count)\n    (if (= count n)\n        a\n        (fibfib-iter (+ a b c) a b\
    \ (- count 1))))\n  (fibfib-iter 0 0 1 n))\n</code>\nEdit: Clarification: n is\
    \ the index of the sequence.\nI would like to know if you can detect any problems\
    \ with the code, if it's idiomatic and if you can propose a better solution. Thank\
    \ you in advance.\n\n\nA:\n\nWrt. <code>fibfib</code> I'd probably use a parameter\
    \ for the <code>count</code> argument. This would make it more explicit that the\
    \ count-parameter is the first thing that is affected by recursion. Eg.:\n<code>(define\
    \ (fibfib n)\n  (define (fibfib-iter count a b c)\n    (if (= count n)\n     \
    \   a\n        (fibfib-iter (- count 1) (+ a b c) a b)))\n  (fibfib-iter n 0 0\
    \ 1))\n</code>\nWhen I was looking at the code I didn't immediately recognize\
    \ that the <code>-</code> function was actually the <code>dec</code> function,\
    \ which I think is good to show.\nHere's a recursive version that works by using\
    \ the <code>accumulate</code> function.\n<code>(define (fibfib n)\n  (define (fibfib-iter\
    \ a b c n)\n    (if (= n 0)\n        0\n        (fibfib-iter b c (+ a b c) (-\
    \ n 1))))\n  (fibfib-iter 0 0 1 n))\n</code>\nI haven't tested this out on the\
    \ python version I posted earlier, but I'm quite certain it's much faster than\
    \ the iterative version.\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n\
    \      (if (= n 1)\n          0\n          (if (= n 2)\n              1\n    \
    \          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n</code>\n\
    ...and here's the Racket code I wrote to solve the problem with the help of lists:\n\
    <code>#lang racket\n", "  (if (< n 3)\n      (if (= n 2) 1 0)\n      (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (if (< n 3)\n      (if (zero? n)\n         \
    \ 0\n          1)\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n    \
    \     (fibfib (- n 3)))))\n", "  (if (&lt; n 2)\n      0\n      (if (= n 2)\n\
    \          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n\
    </code>\nExample:\n<code>&gt; (fibfib 1)\n0\n&gt; (fibfib 5)\n4\n&gt; (fibfib\
    \ 8)\n24\n</code>\n", "  (if (< n 2)\n      n\n      (+ (fibfib (- n 1))\n   \
    \      (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "    (cond [(= n 0)\
    \ 0]\n          [(= n 1) 0]\n          [(= n 2) 1]\n          [else (+ (fibfib\
    \ (- n 1))\n                   (fibfib (- n 2))\n                   (fibfib (-\
    \ n 3)))]))\n", "  (define (fibfib-iter n c1 c2 c3)\n    (cond\n      [(= n 0)\
    \ c1]\n      [(= n 1) c2]\n      [(= n 2) c3]\n      [else (fibfib-iter (- n 1)\
    \ c2 c3 (+ c1 c2 c3))]))\n  (fibfib-iter n 0 0 1))\n", "  (let loop ([i 0] [j\
    \ 0] [k 1] [cnt 3])\n    (cond [(= n 0) i]\n          [(= n 1) j]\n          [(=\
    \ n 2) k]\n          [(= n cnt) (+ (+ i j) k)]\n          [else (loop j k (+ (+\
    \ i j) k) (+ cnt 1))])))\n", "  (define (fibfib-helper n-1 n-2 n-3)\n    (cond\
    \ ((= n 0) n-3)\n          ((= n 1) n-2)\n          ((= n 2) n-1)\n          (else\
    \ (fibfib-helper (+ n-1 n-2 n-3) n-1 n-2))))\n  (fibfib-helper 1 0 0))\n", " \
    \ (define (fibfib-int n a b c)\n    (if (= n 0)\n        a\n        (fibfib-int\
    \ (- n 1) b c (+ a b c))))\n  (fibfib-int n 0 0 1))\n", "  (if (&lt; n 2)\n  \
    \    0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (define (recurse k)\n    (if (< k 3)\n        k\n      \
    \  (+ (recurse (- k 1)) (recurse (- k 2)) (recurse (- k 3)))))\n  (recurse n))\n",
  "  (define (f n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2)\
    \ 1]\n      [else (+ (f (- n 1)) (f (- n 2)) (f (- n 3)))]))\n  (f n))\n", " \
    \ (define (helper index n1 n2 n3)\n    (cond ((= index n) n1)\n          (else\
    \ (helper (+ index 1) n2 n3 (+ n1 n2 n3)))))\n  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (helper 3 0 1 1))))\n", "  (match\
    \ n\n    [(0) 0]\n    [(1) 0]\n    [(2) 1]\n    [(n) (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (if (or (= n 0) (= n 1))\n      0\n   \
    \   (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (< n 3)\n      n\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n   \
    \      (fibfib (- n 3)))))\n", "  (define (ff n1 n2 n3 n)\n    (cond\n      [(=\
    \ n 0) n1]\n      [(= n 1) n2]\n      [(= n 2) n3]\n      [else (ff n2 n3 (+ n2\
    \ n3 n1) (- n 1))]))\n  (ff 0 0 1 n))\n", "  (cond [(= n 0) 0]\n        [(= n\
    \ 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n", "  (if (or (= n 0) (= n 1))\n      0\n      (if (=\
    \ n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3))))))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", " \
    \ (cond\n    [(zero? n) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((< n 3) n)\n  \
    \      (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n```\n\n\
    ```racket\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond [(zero? n) 0]\n\
    \        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))", "  (if (= n 0)\n      0\n      (fibfib-tr (list\
    \ 0 0 1) 2 n)))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (zero? n)\n      0\n      (if (zero? (sub1 n))\n          0\n          (if (zero?\
    \ (sub1 (sub1 n)))\n              1\n              (+ (fibfib (sub1 n))\n    \
    \             (fibfib (sub1 (sub1 n)))\n                 (fibfib (sub1 (sub1 (sub1\
    \ n)))))))))\n</code>\nI wrote the following program in Haskell:\n<code>module\
    \ Main where\n\nfibfib :: Integer -&gt; Integer\nfibfib 0 = 0\nfibfib 1 = 0\n\
    fibfib 2 = 1\nfibfib n = fibfib (n-1) + fibfib (n-2) + fibfib (n-3)\n\nmain ::\
    \ IO ()\nmain = do\n  putStrLn (show (fibfib 3))\n</code>\nThe program works,\
    \ but is terribly slow. Could somebody help me to make it faster please?\nThank\
    \ you!\n\n\nA:\n\nYou can use the method of storing already calculated numbers\
    \ in a cache. For example:\n<code>module Main where\n\nimport Data.Maybe\n\nfibfib\
    \ :: Integer -&gt; Integer\nfibfib 0 = 0\nfibfib 1 = 0\nfibfib 2 = 1\nfibfib n\
    \ = fromMaybe (fibfib (n-1) + fibfib (n-2) + fibfib (n-3)) (M.lookup n cache)\n\
    \nmain :: IO ()\nmain = do\n  putStrLn (show (fibfib 3))\n</code>\nThe cache is\
    \ a map from <code>n</code> to <code>fibfib n</code>. You can use <code>M.insert</code>\
    \ to fill the cache from bottom up.\n", "  (cond [(= n 0) 0]\n        [(= n 1)\
    \ 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))", "  (match n\n    [(or 0 1) 0]\n    [2 1]\n    [_ (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\nI don't really like\
    \ that last line, but that seems the most straightforward.  I wonder if there\
    \ is a more elegant solution, though.  If anyone has any improvement suggestions,\
    \ feel free to answer.  I'd like to see this get an \"accepted\" answer.\n\n\n\
    A:\n\nNote that <code>fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3)</code>\
    \ is fibonacci with <code>fibfib(0) = 0</code>, <code>fibfib(1) = 0</code>, <code>fibfib(2)\
    \ = 1</code> i.e.\n<code>#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n</code>\nI have written the above solution which is inefficient\
    \ as it uses recursion with repeated function calls.  Could someone please suggest\
    \ an efficient way to solve this problem.\n\n\nA:\n\nHere is a solution with memoization:\n\
    <code>(define fibfib\n  (let ((memo '()))\n    (lambda (n)\n      (cond\n    \
    \    [(null? memo) (set! memo (vector 0 0 1))]\n        [(&lt; n (vector-length\
    \ memo))]\n        [else (set! memo (build-vector (+ 3 n) (lambda (i) (fibfib\
    \ (- i 1)))))])\n      (vector-ref memo n))))\n</code>\nLet me know if you don't\
    \ understand the code.\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (if (= n 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n\
    \              1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))))\n", "  (define (fibfib-helper n cache)\n    (if (and (not (null?\
    \ cache)) (not (zero? (vector-ref cache n))))\n      (vector-ref cache n)\n  \
    \    (if (< n 2)\n        0\n        (let* ([n-1 (fibfib-helper (- n 1) cache)]\n\
    \               [n-2 (fibfib-helper (- n 2) cache)]\n               [n-3 (fibfib-helper\
    \ (- n 3) cache)]\n               [n-3-new (+ n-1 n-2 n-3)])\n          (vector-set!\
    \ cache n n-3-new)\n          n-3-new))))\n  (fibfib-helper n (make-vector (+\
    \ n 1) 0)))\n", "  (let recur ((n n) (a 0) (b 0) (c 1))\n    (cond ((zero? n)\
    \ a)\n          ((= n 1) b)\n          ((= n 2) c)\n          (else (recur (-\
    \ n 1) b c (+ b c a))))))\n</code>\nMy problem is that I cannot find a sequence\
    \ of tests that fully cover the code under test.\nThis is what I tried:\n<code>#lang\
    \ racket\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n          0\n       \
    \   (if (= n 2)\n              1\n              (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)) (fibfib (- n 3)))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (let* ([fibfib1 (make-vector (+ n 1))]\n         [fibfib2 (make-vector\
    \ (+ n 1))])\n    (vector-set! fibfib1 0 0)\n    (vector-set! fibfib1 1 0)\n \
    \   (vector-set! fibfib1 2 1)\n    (vector-set! fibfib2 0 0)\n    (vector-set!\
    \ fibfib2 1 0)\n    (vector-set! fibfib2 2 1)\n    (let loop ([i 3])\n      (when\
    \ (< i (+ n 1))\n        (vector-set! fibfib1 i (+ (vector-ref fibfib1 (- i 1))\
    \ (vector-ref fibfib1 (- i 2)) (vector-ref fibfib1 (- i 3))))\n        (vector-set!\
    \ fibfib2 i (+ (vector-ref fibfib2 (- i 1)) (vector-ref fibfib2 (- i 2)) (vector-ref\
    \ fibfib2 (- i 3))))\n        (loop (+ i 1))))\n    (vector-ref fibfib1 n)))\n",
  "  (cond\n    [(< n 2) n]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n\
    \        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (cond ((= n 0)\
    \ 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n\
    \ 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n  \
    \  [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))\n```\n\n```#lang racket\n", "  (cond [(= n 0) 0]\n    \
    \    [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n\
    \          0\n          (if (= n 2)\n              1\n              (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond\n    [(zero? n)\
    \ 0]\n    [(equal? n 1) 0]\n    [(equal? n 2) 1]\n    [else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-iter f1 f2 f3 n)\n    (if (=\
    \ n 0)\n        f1\n        (fibfib-iter f2 f3 (+ f1 f2 f3) (- n 1))))\n  (fibfib-iter\
    \ 0 0 1 n))\n", "  (let loop ([n n] [a 0] [b 0] [c 1])\n    (cond\n      [(= n\
    \ 0) a]\n      [(= n 1) b]\n      [(= n 2) c]\n      [else (loop (- n 1) b c (+\
    \ a b c))])))\n", "  (define (fibfib_iter a b c count)\n    (if (= count n)\n\
    \        c\n        (fibfib_iter b c (+ a b c) (+ count 1))))\n  (fibfib_iter\
    \ 0 0 1 0))\n```\n\n### Question 3\n\n```\n#lang racket\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n\
    \        (fibfib (- n 2))\n        (fibfib (- n 3)))]))\n", "  (if (< n 3)\n \
    \     (if (= n 0)\n          0\n          1)\n      (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))))", "  (if (= n 0)\n      0\n      (if (= n 1)\n\
    \          0\n          (if (= n 2)\n              1\n              (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (if (or (= n 0) (= n\
    \ 1))\n      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define fibfib-array (make-vector\
    \ (add1 n) 0))\n  (vector-set! fibfib-array 0 0)\n  (vector-set! fibfib-array\
    \ 1 0)\n  (vector-set! fibfib-array 2 1)\n  (define (recur i)\n    (if (eq? i\
    \ n)\n        0\n        (vector-set! fibfib-array (add1 i) (add (vector-ref fibfib-array\
    \ i) (vector-ref fibfib-array (sub1 i)) (vector-ref fibfib-array (sub1 (sub1 i)))))\n\
    \        (recur (add1 i))))\n  (recur 2)\n  (vector-ref fibfib-array n))\n", " \
    \ (if (or (eq? n 0) (eq? n 1))\n      0\n      (if (eq? n 2)\n          1\n  \
    \        (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (fibfib-inner\
    \ n a b c)\n    (if (= n 0)\n        a\n        (fibfib-inner (- n 1) b c (+ a\
    \ b c))))\n  (fibfib-inner n 0 0 1))\n", "  (cond ((= n 0) 0)\n        ((= n 1)\
    \ 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3))))))\n", "  (if (< n 2)\n      0\n      (letrec ([fibfibhelp\
    \ (lambda (n)\n                             (if (< n 2)\n                    \
    \             0\n                                 (if (= n 2)\n              \
    \                       1\n                                     (+ (fibfibhelp\
    \ (- n 1))\n                                        (fibfibhelp (- n 2))\n   \
    \                                     (fibfibhelp (- n 3))))))])\n        (fibfibhelp\
    \ n))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else\
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define l (list\
    \ 0 0 1))\n  (let loop ([n n] [idx 2])\n    (if (= n 0)\n        (list-ref l 0)\n\
    \        (loop (- n 1) (+ idx 1)))))\n", "  (define (helper a b c n)\n    (if\
    \ (= n 0)\n        a\n        (helper b c (+ a b c) (- n 1))))\n  (helper 0 0\
    \ 1 n))", "  (fibfib-iter 0 1 1 0 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (letrec\n      ((fib (lambda (n)\n              (cond\n\
    \                ((= n 0) 0)\n                ((= n 1) 0)\n                ((=\
    \ n 2) 1)\n                (else (+ (fib (- n 1)) (fib (- n 2)) (fib (- n 3))))))))\n\
    \    (fib n)))", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond [(equal? n 0) 0]\n        [(equal? n 1) 0]\n        [(equal? n 2) 1]\n\
    \        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibiter a b c\
    \ count)\n    (if (zero? count)\n        a\n        (fibiter b c (+ a b c) (-\
    \ count 1))))\n  (fibiter 0 0 1 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1)\
    \ 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n\
    \    [(equal? n 0) 0]\n    [(equal? n 1) 0]\n    [(equal? n 2) 1]\n    [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (< n 3)\n\
    \      (sub1 n)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond [(= n 0) 0]\n  \
    \      [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n\
    \          0\n          (if (= n 2)\n              1\n              (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))", "  (define (f n1 n2 n3 n)\n\
    \    (if (= n 0)\n        n1\n        (f n2 n3 (+ n2 n3 n1) (- n 1))))\n  (f 0\
    \ 0 1 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n  \
    \  [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define\
    \ (fibfib-impl n-pre n-pre-pre n-pre-pre-pre)\n    (cond ((= n 0) 0)\n       \
    \   ((= n 1) 0)\n          ((= n 2) 1)\n          (else (fibfib-impl (+ n-pre\
    \ n-pre-pre n-pre-pre-pre) n-pre n-pre-pre))))\n  (fibfib-impl 1 0 0))", "  (define\
    \ (rec-fibfib n f0 f1 f2)\n    (cond ((= n 0) f0)\n          ((= n 1) f1)\n  \
    \        ((= n 2) f2)\n          (else (rec-fibfib (- n 1) f1 f2 (+ f0 f1 f2)))))\n\
    \  (rec-fibfib n 0 0 1))\n", "  (define (fibfib-iter n a b c)\n    (cond ((= n\
    \ 0) a)\n          ((= n 1) b)\n          ((= n 2) c)\n          (else (fibfib-iter\
    \ (- n 1) b c (+ a b c)))))\n  (fibfib-iter n 0 0 1))\n", "  (if (or (= n 0) (=\
    \ n 1))\n      0\n      (cond [(= n 2) 1]\n            [else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))])))\n\n", "  (cond ((= n 0) 0)\n        ((=\
    \ n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3))))))\n", "  (if (or (= n 0) (= n 1))\n      0\n      (if\
    \ (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (match n\n    [(0) 0]\n    [(1) 0]\n    [(2) 1]\n    [(3)\
    \ 1]\n    [(4) 3]\n    [(5) 4]\n    [(6) 8]\n    [(7) 12]\n    [(8) 24]\n    [(9)\
    \ 37]\n    [(10) 65]\n    [(11) 104]\n    [(12) 176]\n    [(13) 281]\n    [(14)\
    \ 461]\n    [(15) 745]\n    [(16) 1206]\n    [(17) 1958]\n    [(18) 3164]\n  \
    \  [(19) 5122]\n    [(20) 8286]\n    [(21) 13467]\n    [(22) 21752]\n    [(23)\
    \ 35219]\n    [(24) 57019]\n    [(25) 91532]\n    [(26) 148538]\n    [(27) 239608]\n\
    \    [(28) 387752]\n    [(29) 627644]\n    [(30) 1015388]\n    [(31) 1643259]\n\
    \    [(32) 2658742]\n    [(33) 4303179]\n    [(34) 6910539]\n    [(35) 11140779]\n\
    \    [(36) 17969565]\n    [(37) 29008290]\n    [(38) 46978177]\n    [(39) 75947122]\n\
    \    [(40) 123044998]\n    [(41) 198090696]\n    [(42) 319807335]\n    [(43) 517905527]\n\
    \    [(44) 835811272]\n    [(45) 1353705373]\n    [(46) 2189515335]\n    [(47)\
    \ 3543077696]\n    [(48) 5731584963]\n    [(49) 9274660207]\n    [(50) 15006344591]\n\
    \    [(51) 24280986640]\n    [(52) 39287331257]\n    [(53) 63577786385]\n    [(54)\
    \ 102865119949]\n    [(55) 166440299181]\n    [(56) 269325874945]\n    [(57)",
  "  (define (fibfib-loop n a b c)\n    (cond\n      [(zero? n) a]\n      [(= n 1)\
    \ b]\n      [(= n 2) c]\n      [else (fibfib-loop (- n 1) b c (+ a b c))]))\n\
    \  (fibfib-loop n 0 0 1))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (if (< n 2)\n      0\n      (if (< n 3)\n          1\n          (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (define (loop n-1 n-2 n-3\
    \ count)\n    (cond\n      [(= count n) n-1]\n      [else (loop (+ n-1 n-2 n-3)\
    \ n-1 n-2 (+ count 1))]))\n  (loop 1 0 0 0))\n", "  (cond ((= n 0) 0)\n      \
    \  ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n\
    \        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))", "  (if (&lt; n 3) (- n)\n      (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)) (fibfib (- n 3)))))\n</code>\nAnd here's the better solution:\n<code>#lang\
    \ racket\n", "  (if (< n 2)\n      0\n      (if (= n 2)\n          1\n       \
    \   (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", "  (cond\n   \
    \ [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ n 1) 0]\n    [(= n 2) 1]\n    [else\n     (+ (fibfib (- n 1))\n        (fibfib\
    \ (- n 2))\n        (fibfib (- n 3)))]))\n", "  (if (= n 0)\n      0\n      (if\
    \ (= n 1)\n          0\n          (if (= n 2)\n              1\n             \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (cond\n  \
    \  [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (ff inner n)\n    (cond\n\
    \      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= n 2) 1]\n      [else (+ (ff inner\
    \ (- n 1)) (ff inner (- n 2)) (ff inner (- n 3)))]))\n  (ff ff n))", "  (define\
    \ (fibfib-rec last-two-fibfibs n)\n    (cond\n      [(< n 2) (vector-ref last-two-fibfibs\
    \ (- n 1))]\n      [else (fibfib-rec (vector (+ (vector-ref last-two-fibfibs 0)\
    \ (vector-ref last-two-fibfibs 1) (vector-ref last-two-fibfibs 2)) last-two-fibfibs)\
    \ (- n 1))]))\n  (fibfib-rec (vector 0 0 1) n))\n", "  (cond [(= n 0) 0]\n   \
    \     [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n\
    \        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (if (&lt; n 3)\n      (- n 1)\n      (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\nSince <code>fibfib(3)</code>\
    \ is <code>fibfib(2) + fibfib(1) + fibfib(0)</code>, which is <code>1 + 0 + 0</code>,\
    \ which is <code>1</code>, I believe the answer should be 1, but it says I'm wrong.\
    \ I would like to know what I did wrong.\nEdit:\nI understand where I made the\
    \ mistake now. The answer is 1, not 0.\n\n\nA:\n\nIt is a good thing you have\
    \ included a link to the actual question, because your description of it is erroneous.\
    \ You have the <code>if</code> test backwards, and your last equation is wrong.\
    \ It should be:\n<code>(define (fibfib n)\n  (if (&lt; n 3)\n      (- n 1)\n \
    \     (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\nYour\
    \ answer is correct, but you were asked for the <code>n</code>th FibFib number,\
    \ not the <code>n</code>th Fibonacci number.\n", "  (if (or (= n 0) (= n 1))\n\
    \      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (if (and (&lt;= 0 n) (&lt;= n 2))\n   \
    \   (- n 1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (define (fibfib-iter n result1 result2 result3)\n    (if (= n 0)\n        result1\n\
    \        (fibfib-iter (- n 1) result2 result3 (+ result1 result2 result3))))\n\
    \  (fibfib-iter n 0 0 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n   \
    \ [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (define (fibfib-rec a b c n)\n    (if (&lt;= n 2)\n        c\n        (fibfib-rec\
    \ b c (+ a b c) (- n 1))))\n  (fibfib-rec 0 0 1 n))\n", "  (match n\n    [0 0]\n\
    \    [1 0]\n    [2 1]\n    [_ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))]))\n```\n\n```racket", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n  \
    \      ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))\n", "  (if (&lt; n 3)\n      (if (= n 0) 0\n          1)\n    \
    \  (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n</code>\n", "  (if\
    \ (< n 3)\n      (if (zero? n)\n          0\n          1)\n      (+ (fibfib (-\
    \ n 1))\n         (fibfib (- n 2))\n         (fibfib (- n 3)))))\n", "  (if (<\
    \ n 3)\n      n\n      (+ (fibfib (- n 1))\n         (fibfib (- n 2))\n      \
    \   (fibfib (- n 3)))))\n", "  (define (fibfib_rec n)\n    (cond [(= n 0) 0]\n\
    \          [(= n 1) 0]\n          [(= n 2) 1]\n          [else (+ (fibfib_rec\
    \ (- n 1)) (fibfib_rec (- n 2)) (fibfib_rec (- n 3)))]))\n  (fibfib_rec n))\n",
  "  (if (or (= n 0) (= n 1))\n      0\n      (if (= n 2)\n          1\n         \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n\
    \ 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (-\
    \ n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (match n\n    [(0) 0]\n \
    \   [(1) 0]\n    [(2) 1]\n    [(? number?) (cond\n                   [(= n 3)\
    \ 1]\n                   [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))])]))\n\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (let\
    \ ([fibs (list 0 0 1)])\n    (for ([i (in-range 2 n)])\n      (set! fibs (cons\
    \ (+ (car fibs) (second fibs) (third fibs)) fibs)))\n    (first fibs)))\n", " \
    \ (fibfib-helper n 0 1 0))\n", "  (define (helper n1 n2 n3 count)\n    (cond\n\
    \      [(= count n) n3]\n      [else (helper n2 n3 (+ n1 n2 n3) (+ count 1))]))\n\
    \  (helper 0 0 1 0))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n\
    \ 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(< n 0) (error \"n must be a non-negative integer\")]\n    [(= n\
    \ 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (if (< n 3)\n      (if (zero? n) 0 1)\n      (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (if (or (= n 0) (= n 1))\n\
    \      0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (fibfib-iter 1 0 0 1 n))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n   \
    \ [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n\
    </code>\nAnd my Java solution:\n<code>public class FibFib {\n    public static\
    \ int fibfib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return\
    \ 0;\n        if (n == 2) return 1;\n        return fibfib(n - 1) + fibfib(n -\
    \ 2) + fibfib(n - 3);\n    }\n\n    public static void main(String[] args) {\n\
    \        for (int i = 0; i &lt; 20; i++) {\n            System.out.printf(\"%d\
    \ %d\\n\", i, fibfib(i));\n        }\n    }\n}\n</code>\nI have no idea how to\
    \ write efficient code using a functional programming language.  I'm also not\
    \ sure if there is an online community for a functional programming language like\
    \ Racket.  Is there an online community for functional programming languages?\
    \  Does StackOverflow have a sister site for functional programming?\n\n\nA:\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-rec n\
    \ a b c)\n    (if (= n 0)\n        a\n        (fibfib-rec (- n 1) b c (+ c b a))))\n\
    \  (fibfib-rec n 0 0 1))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n     \
    \   ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3))))))\n", "  (define (fibfib-iter f1 f2 f3 n)\n    (if (= n 0)\n       \
    \ f1\n        (fibfib-iter f2 f3 (+ f1 f2 f3) (- n 1))))\n  (fibfib-iter 0 0 1\
    \ n))\n", "  (define (fibfib-iter n counter-1 counter-2 counter-3)\n    (cond\n\
    \      [(= n 0) counter-1]\n      [(= n 1) counter-2]\n      [(= n 2) counter-3]\n\
    \      [else\n       (fibfib-iter (- n 1) counter-2 counter-3 (+ counter-1 counter-2\
    \ counter-3))]))\n  (fibfib-iter n 0 0 1))\n", "  (define (fibfib-inner a b c\
    \ n)\n    (if (zero? n)\n        a\n        (fibfib-inner b c (+ a b c) (- n 1))))\n\
    \  (fibfib-inner 0 0 1 n))", "  (cond [(equal? n 0) 0]\n        [(equal? n 1)\
    \ 0]\n        [(equal? n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n   \
    \     [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))", "  (fibfib-recurse 0 1 1 n))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-tail n p0 p1 p2)\n    (cond\
    \ ((= n 0) p0)\n          ((= n 1) p1)\n          ((= n 2) p2)\n          (else\
    \ (fibfib-tail (- n 1) p1 p2 (+ p0 p1 p2)))))\n  (fibfib-tail n 0 0 1))\n", " \
    \ (define (fibfib-rec n-1 n-2 n-3)\n    (cond ((= n-1 0) 0)\n          ((= n-1\
    \ 1) 0)\n          ((= n-1 2) 1)\n          (else (+ n-1 (fibfib-rec n-2 n-3 (+\
    \ n-2 n-3))))))\n  (fibfib-rec n 1 0))\n", "  (if (= n 0)\n      0\n      (if\
    \ (= n 1)\n          0\n          (if (= n 2)\n              1\n             \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n</code>\nThis works,\
    \ but is horribly inefficient.  I'm looking for more elegant, efficient solutions.\n\
    \n\nA:\n\nThis is what I get:\n<code>(define (fibfib n)\n  (let loop ((n n) (a\
    \ 0) (b 0) (c 1))\n    (if (zero? n)\n        a\n        (loop (sub1 n) (+ a b\
    \ c) a b))))\n</code>\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((=\
    \ n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n\
    </code>\nThis function runs in exponential time. I want to make it run in linear\
    \ time by memoizing the results.\nI thought a helper function with a list as a\
    \ parameter could do the trick. This seems to be the right way to do it in Haskell:\n\
    <code>import Data.Array\n\n-- A helper function to fibfib that can be used to\
    \ memoize results\nfibfib' :: Int -&gt; Array Int Int -&gt; Int\nfibfib' 0 _ =\
    \ 0\nfibfib' 1 _ = 0\nfibfib' 2 _ = 1\nfibfib' n arr = (arr ! (n-1)) + (arr !\
    \ (n-2)) + (arr ! (n-3))\n\n-- Returns the nth element of the fibfib number sequence\n\
    fibfib :: Int -&gt; Int\nfibfib n = last $ take n a\n  where a = [fibfib' x (listArray\
    \ (0,n) a) | x &lt;- [0..n]]\n</code>\nBut I am not sure how to translate this\
    \ to Racket. It seems that Racket does not have the same construct for \"lazy\
    \ evaluation\" as Haskell does. I found the memoize function in racket's documentation\
    \ but this does not seem to be what I want.\nHelp would be greatly appreciated.\n\
    \n\nA:\n\n<code>#lang racket\n", "  (if (or (= n 0) (= n 1))\n      0\n      (if\
    \ (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3))))))", "  (define (fib-aux n1 n2 n3 n)\n    (cond\n      [(= n 1) 0]\n\
    \      [(= n 2) 1]\n      [(= n 3) 2]\n      [else (fib-aux n2 n3 (+ n2 n3 n1)\
    \ (- n 1))]))\n  (fib-aux 0 1 2 n))\n", "  (define (helper current n-1 n-2 n-3)\n\
    \    (cond [(= n 0) n-3]\n          [(= n 1) n-2]\n          [(= n 2) n-1]\n \
    \         [else (helper (+ current 1) (+ current n-2) (+ current n-1) n-3)]))\n\
    \  (helper 0 0 1 0))\n", "  (cond ((< n 3) n)\n        (else (+ (fibfib (- n 1))\
    \ (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (if (< n 3)\n      (if (zerop n)\
    \ 0 1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", " \
    \ (if (= n 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n\
    \              1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))))\n", "  (if (not (and (integer? n)\n                (>= n 0)))\n \
    \     (error \"Invalid input\")\n      (cond\n        [(= n 0) 0]\n        [(=\
    \ n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1))\n          \
    \       (fibfib (- n 2))\n                 (fibfib (- n 3)))])))\n", "  (define\
    \ (fibfib-iter a b c n)\n    (if (= n 0)\n      a\n      (fibfib-iter b c (+ a\
    \ b c) (- n 1))))\n  (fibfib-iter 0 0 1 n))\n", "  (cond ((= n 0) 0)\n       \
    \ ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n```\n\n```racket", "  (cond ((= n 0) 0)\n   \
    \     ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (let loop ([n n] [f1 0] [f2 0] [f3 1])\n\
    \    (cond\n      [(zero? n) f1]\n      [(= n 1) f2]\n      [(= n 2) f3]\n   \
    \   [else (loop (- n 1) f2 f3 (+ f1 f2 f3))])))\n\n", "  (if (= n 0)\n      0\n\
    \      (if (= n 1)\n          0\n          (if (= n 2)\n              1\n    \
    \          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n", "  (define\
    \ (fib-iter a b c count)\n    (if (= count n)\n      b\n      (fib-iter a (+ b\
    \ c) b (+ count 1))))\n  (fib-iter 0 0 1 0))", "  (if (or (= n 0) (= n 1))\n \
    \     0\n      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n\
    \ 3)))]))\n", "  (if (or (= n 0) (= n 1))\n      0\n      (if (= n 2)\n      \
    \    1\n          (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n",
  "  (if (not (and (integer? n) (&gt;= n 0)))\n      (error \"number must be a positive\
    \ integer\" n)\n      (if (&lt; n 3)\n          (if (= n 0) 0 n)\n          (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n</code>\nThis works\
    \ fine for the small numbers but fails for bigger ones:\n<code>&gt; (fibfib 10)\n\
    34\n&gt; (fibfib 20)\nstack overflow\n</code>\nThe problem is that <code>fibfib</code>\
    \ is very naive in its implementation, it doesn't memoize the function. We can\
    \ fix that by using a let with a <code>cond</code> to memoize the function.\n\
    <code>#lang racket\n", "  (define (do-fibfib n f1 f2 f3)\n    (cond [(= n 0) f1]\n\
    \          [(= n 1) f2]\n          [(= n 2) f3]\n          [else (do-fibfib (-\
    \ n 1) f2 f3 (+ f1 f2 f3))]))\n  (do-fibfib n 0 0 1))\n", "  (define (fibfib-inner\
    \ n)\n    (cond [(= n 0) 0]\n          [(= n 1) 0]\n          [(= n 2) 1]\n  \
    \        [else (+ (fibfib-inner (- n 1)) (fibfib-inner (- n 2)) (fibfib-inner\
    \ (- n 3)))]))\n  (fibfib-inner n))\n", "  (cond\n    [(zero? n) 0]\n    [(equal?\
    \ n 1) 0]\n    [(equal? n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3)))]))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n\
    \ 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n",
  "  (cond\n    [(zero? n) 0]\n    [(one? n) 0]\n    [(two? n) 1]\n    [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if (< n 2)\n      0\n\
    \      (if (= n 2)\n          1\n          (+ (fibfib (- n 1)) (fibfib (- n 2))\
    \ (fibfib (- n 3))))))\n", "  (define (fibfib-aux n-1 n-2 n-3)\n    (cond\n  \
    \    [(= n-1 n) n-1]\n      [(= n-2 n) n-2]\n      [(= n-3 n) n-3]\n      [else\
    \ (fibfib-aux (+ n-1 n-2 n-3) n-1 n-2)]))\n  (fibfib-aux 0 0 1))\n", "  (cond\
    \ ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond [(= n 0) 0]\n  \
    \      [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (if\
    \ (= n 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n  \
    \            1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (-\
    \ n 3)))))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n\
    \    [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))", "  (if\
    \ (< n 3)\n      (case n\n        [0 0]\n        [1 0]\n        [2 1])\n     \
    \ (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n", "  (define (fibfib-aux\
    \ n a b c)\n    (cond\n      [(= n 0) a]\n      [(= n 1) b]\n      [(= n 2) c]\n\
    \      [else (fibfib-aux (- n 1) b c (+ a b c))]))\n  (fibfib-aux n 0 0 1))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n</code>\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 1]\n        [else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))]))\n", "  (define (f n)\n    (cond\
    \ ((= n 0) 0)\n          ((= n 1) 0)\n          ((= n 2) 1)\n          (else (+\
    \ (f (- n 1)) (f (- n 2)) (f (- n 3))))))\n  (f n))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib\
    \ (- n 2)) (fibfib (- n 3)))]))\n", "  (define (fibfib-aux a b c count)\n    (if\
    \ (zero? count)\n      a\n      (fibfib-aux b c (+ a b c) (- count 1))))\n  (fibfib-aux\
    \ 0 0 1 n))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n\
    \        (else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n</code>\n\
    It's O(n^3) time complexity. Is there a way to get it O(n) time complexity?\n\n\
    \nA:\n\nYes, there is a way. It's called memoization. This article explains it\
    \ well.\n", "  (if (= n 0)\n      0\n      (if (= n 1)\n          0\n        \
    \  (if (= n 2)\n              1\n              (+ (fibfib (- n 1)) (fibfib (-\
    \ n 2)) (fibfib (- n 3)))))))\n", "  (if (< n 3)\n      (if (= n 0)\n        \
    \  0\n          1)\n      (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))\n",
  "  (letrec ([fibfib1 (lambda (n)\n                      (cond [(= n 0) 0]\n    \
    \                        [(= n 1) 0]\n                            [(= n 2) 1]\n\
    \                            [else (+ (fibfib1 (- n 1)) (fibfib1 (- n 2)) (fibfib1\
    \ (- n 3)))]))])\n    (fibfib1 n)))\n", "  (define (iter a b c n)\n    (if (=\
    \ n 0)\n        0\n        (if (= n 1)\n            0\n            (if (= n 2)\n\
    \                1\n                (iter b c (+ a b c) (- n 1))))))\n  (iter\
    \ 0 0 1 n))\n", "  (define (fibfib-acc a b c n)\n    (if (zero? n) a\n       \
    \ (fibfib-acc b c (+ a b c) (- n 1))))\n  (fibfib-acc 0 0 1 n))\n", "  (if (=\
    \ n 0)\n      0\n      (if (= n 1)\n          0\n          (if (= n 2)\n     \
    \         1\n              (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3)))))))\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+\
    \ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))", "  (if (not (integer?\
    \ n)) (error \"fibfib must be called with an integer\"))\n  (if (not (positive?\
    \ n)) (error \"fibfib must be called with a positive integer\"))\n  (cond ((=\
    \ n 0) 0)\n        ((= n 1) 0)\n        ((= n 2) 1)\n        (else (+ (fibfib\
    \ (- n 1)) (fibfib (- n 2)) (fibfib (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 1]\n    [else (+ (fibfib (- n 1)) (fibfib (- n\
    \ 2)) (fibfib (- n 3)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n   \
    \     [(= n 2) 1]\n        [else (+ (fibfib (- n 1)) (fibfib (- n 2)) (fibfib\
    \ (- n 3)))]))\n```\n\n```racket\n#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
