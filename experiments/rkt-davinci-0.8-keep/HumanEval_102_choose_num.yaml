name: HumanEval_102_choose_num
language: rkt
prompt: "#lang racket\n\n;; This function takes two positive numbers x and y and returns\
  \ the\n;; biggest even integer number that is in the range [x, y] inclusive. If\
  \ \n;; there's no such number, then the function should return -1.\n;; For example:\n\
  ;; choose_num(12, 15) = 14\n;; choose_num(13, 12) = -1\n(define (choose_num x y)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n\
  \    (check-equal? (candidate 12 15) 14)\n    (check-equal? (candidate 13 12) -1)\n\
  \    (check-equal? (candidate 33 12354) 12354)\n    (check-equal? (candidate 5234\
  \ 5233) -1)\n    (check-equal? (candidate 6 29) 28)\n    (check-equal? (candidate\
  \ 27 10) -1)\n    (check-equal? (candidate 7 7) -1)\n    (check-equal? (candidate\
  \ 546 546) 546)\n))\n\n(test-humaneval)"
completions: ["  (if (&gt; x y) -1\n      (if (even? y) y\n          (choose_num x\
    \ (- y 1)))))\n", "  (cond ((= x y) (- x 1))\n        ((= y (+ x 1)) (- x 2))\n\
    \        ((= y (+ x 2)) (- x 1))\n        ((= y (+ x 3)) y)\n        ((= y (+\
    \ x 4)) (- x 2))\n        ((= y (+ x 5)) (- x 1))\n        ((= y (+ x 6)) y)\n\
    \        ((= y (+ x 7)) (- x 2))\n        ((= y (+ x 8)) (- x 1))\n        ((=\
    \ y (+ x 9)) y)\n        ((= y (+ x 10)) (- x 2))\n        ((= y (+ x 11)) (-\
    \ x 1))\n        ((= y (+ x 12)) y)\n        ((= y (+ x 13)) (- x 2))\n      \
    \  ((= y (+ x 14)) (- x 1))\n        ((= y (+ x 15)) y)\n        ((= y (+ x 16))\
    \ (- x 2))\n        ((= y (+ x 17)) (- x 1))\n        ((= y (+ x 18)) y)\n   \
    \     ((= y (+ x 19)) (- x 2))\n        ((= y (+ x 20)) (- x 1))\n        ((=\
    \ y (+ x 21)) y)\n        ((= y (+ x 22)) (- x 2))\n        ((= y (+ x 23)) (-\
    \ x 1))\n        ((= y (+ x 24)) y)\n        ((= y (+ x 25)) (- x 2))\n      \
    \  ((= y (+ x 26)) (- x 1))\n        ((= y (+ x 27)) y)\n        ((= y (+ x 28))\
    \ (- x 2))\n        ((= y (+ x 29)) (- x 1))\n        ((= y (+ x 30)) y)\n   \
    \     ((= y (+ x 31)) (- x 2))\n        ((= y (+ x 32)) (- x 1))\n        ((=\
    \ y (+ x 33)) y)\n        ((= y (+ x 34)) (- x 2))\n        ((= y (+ x 35)) (-\
    \ x 1))\n        ((= y (+ x 36)) y)\n        ((= y (+ x 37)) (- x 2))\n      \
    \  ((= y (+ x 38)) (- x 1))\n        ((= y (+ x 39)) y)\n        ((= y (+ x 40))\
    \ (- x 2))\n        ((= y", "    (if (and (even? x) (even? y))\n        (if (>\
    \ x y)\n            y\n            x)\n        (if (even? x)\n            x\n\
    \            (if (even? y)\n                y\n                -1))))\n", "  (cond\n\
    \    [(< x y)\n     (if (= 1 (% (- y 1) 2))\n       (choose_num x (- y 1))\n \
    \      (- y 1))]\n    [(= x y) \n     (if (= 1 (% x 2))\n       -1\n       x)]\n\
    \    [else -1]))\n", "  (cond\n    [(= x y) (if (even? x) x -1)]\n    [(&gt; x\
    \ y) -1]\n    [else (max (choose_num x (- y 1))\n               (choose_num (-\
    \ x 1) y))]))\n</code>\nBut according to the code coverage tool, that function\
    \ doesn't cover all of the lines. I don't really understand how this is possible,\
    \ because I entered every possible input number in my unit tests:\n<code>#lang\
    \ racket\n", "    (cond\n        [(= x y) (if (even? x) x -1)]\n        [(> x\
    \ y) -1]\n        [else (if (even? x) (if (even? y) (max x y) x) (choose_num (+\
    \ x 1) y))]))\n", "  (cond\n    [(and (even? x) (even? y)) (if (> x y) x y)]\n\
    \    [(even? x) (if (> x y) x y)]\n    [(even? y) (if (> x y) x y)]\n    [else\
    \ -1]))\n", "  ;; TODO\n  (local [(define (even? n)\n            (and (not (odd?\
    \ n)) (= 0 (remainder n 2))))]\n    (cond [(> x y) -1]\n          [(even? x) (if\
    \ (even? y) y\n                        (choose_num (+ x 1) y))]\n          [else\
    \ (choose_num (+ x 1) y)])))\n", "  (cond\n    [(or (= x y) (= y x)) (if (even?\
    \ x) x -1)]\n    [(or (even? x) (even? y)) (max (if (even? x) x -1) (if (even?\
    \ y) y -1))]\n    [else (choose_num (add1 x) (sub1 y))]))\n", "  (let loop ([n\
    \ (- y 1)])\n    (cond\n      [(even? n) n]\n      [(> n x) (loop (- n 1))]\n\
    \      [else -1])))\n", "  (cond\n    [(>= x y) -1]\n    [(even? y) y]\n    [else\
    \ (choose_num x (- y 1))]))\n", "  (if (equal? (even? x) #f)\n      (choose_num\
    \ (+ x 1) y)\n      (if (&lt; x y)\n          (choose_num x (+ y 1))\n       \
    \   x)))\n", "  (if (and (even? x) (even? y))\n      (if (<= x y)\n          (even\
    \ x y)\n          (even y x))\n      (if (even? x)\n          (even x y)\n   \
    \       (even y x))))\n", "  (if (= x y)\n      x\n      (if (even? x)\n     \
    \     (if (even? y)\n              y\n              (choose_num x (- y 1)))\n\
    \          (choose_num (+ x 1) y))))\n", "  (if (= x y)\n      (if (even? x)\n\
    \          x\n          -1)\n      (if (even? y)\n          (choose_num x (- y\
    \ 1))\n          (choose_num x (- y 2)))))\n</code>\nI have a few questions:\n\
    \nShould I break up the <code>if</code> statement in to two conditions (<code>x\
    \ = y</code> and <code>x != y</code>)?\nHow can I refactor this code to be more\
    \ DRY?\nCan I use <code>abs</code> to make the code more concise?\n\nThis is what\
    \ I have in mind (but it is not working):\n<code>#lang racket\n", "  (cond\n \
    \   [(equal? x y)\n     (if (even? x) x -1)]\n    [(even? x)\n     (max x (choose_num\
    \ (add1 x) y))]\n    [else\n     (choose_num (add1 x) y)]))\n", "    (if (&gt;\
    \ x y)\n        -1\n        (if (even? x)\n            x\n            (choose_num\
    \ (+ x 1) y))))\n</code>\nI'm confused by whether or not I should be placing all\
    \ my functions in one file or making separate files with just one function in\
    \ each file. \nI understand that racket is made so that you can create modules\
    \ that contain the functions and have other modules import those functions, but\
    \ I thought this assignment was supposed to be a simple, one file program.\nAm\
    \ I to assume that all my code should be written in one file (even if it includes\
    \ things like this that are in the assignment: \n<code>#lang racket", "  (if (&gt;=\
    \ x y) -1\n      (if (even? x) x (choose_num (+ x 1) y))))\n</code>\nHowever,\
    \ I am getting a \n<code>application: not a procedure;\n expected a procedure\
    \ that can be applied to arguments\n  given: 4\n  arguments...:\n   6\n   14\n\
    \   15\n</code>\nerror.\nI thought my function should work.\n\n\nA:\n\nYou're\
    \ missing an <code>else</code> in your second conditional (the <code>if</code>\
    \ is complete if it has no <code>else</code>), and you have one extra argument\
    \ in the inner call to <code>choose_num</code>.\n<code>(define (choose_num x y)\n\
    \  (if (&gt;= x y) -1\n      (if (even? x) x (choose_num (+ x 1) y))))\n</code>\n\
    should be\n<code>(define (choose_num x y)\n  (if (&gt;= x y) -1\n      (if (even?\
    \ x) x (else (choose_num (+ x 1) y)))))\n</code>\nor\n<code>(define (choose_num\
    \ x y)\n  (if (&gt;= x y) -1\n      (if (even? x) x (choose_num (+ x 1) y))))\n\
    </code>\n", "   ;; add code here\n   ...)\n</code>\nSo, it seems I'm supposed\
    \ to make a function that takes two numbers and returns the greatest even number\
    \ that is between the two. I'm having a hard time figuring out how to do that\
    \ though, I'd appreciate it if someone could give me a nudge in the right direction.\
    \ This is really confusing to me.\n\n\nA:\n\nYou need to be able to test if numbers\
    \ are even or odd:\n<code>(define (even? n)\n  (= (remainder n 2) 0))\n", "  (if\
    \ (= x y)\n      (if (even? x)\n          x\n          -1)\n      (choose_num\
    \ (+ x 1) y)))\n", "  (if (and (even? x) (&lt;= x y))\n      x\n      (if (even?\
    \ y)\n          y\n          -1)))\n</code>\n", "  (if (= x y) (if (even? x) x\
    \ -1)\n    (if (even? x) (if (even? y) (max x y) x)\n      (if (even? y) y (choose_num\
    \ (+ x 1) y)))))\n</code>\nIt gives the right answer for <code>(choose_num 15\
    \ 10)</code> and all of the others I tried but if I check it in Racket I get the\
    \ wrong answers.\nWhy is that?\nThanks.\n\n\nA:\n\nTry changing the way you compare\
    \ <code>x</code> and <code>y</code> in your code to <code>(&lt;= x y)</code> and\
    \ <code>(&gt;= x y)</code>.\n<code>&lt;=</code> is the \"less than or equal to\"\
    \ operator and <code>&gt;=</code> is the \"greater than or equal to\" operator.\n\
    Also, if you want to check if a number is even, you can use the modulo operator\
    \ <code>%</code> in Racket as follows.\n<code>(define (even? n)\n  (= 0 (modulo\
    \ n 2)))\n</code>\n", "  (if (&gt; x y)\n      -1\n      (if (= 0 (remainder x\
    \ 2))\n          x\n          (choose_num (sub1 x) y))))\n</code>\nNow I need\
    \ to transform this function into a tail-recursive one (I think it is not tail-recursive).\
    \ So, this is what I did:\n<code>#lang racket\n", "  (if (and (even? x) (even?\
    \ y))\n      (if (&gt; x y) -1 (max x y))\n      (if (and (odd? x) (odd? y)) -1\
    \ (if (&gt; x y) -1 (max x y)))))\n</code>\nThis is a test, when I run the below\
    \ code:\n<code>#lang racket\n", "  (cond ((and (even? x) (even? y))\n        \
    \ (if (> x y) y x))\n        ((and (even? x) (odd? y))\n         (choose_num x\
    \ (- y 1)))\n        ((and (odd? x) (even? y))\n         (choose_num (+ x 1) y))\n\
    \        ((and (odd? x) (odd? y))\n         (choose_num (+ x 1) (- y 1)))))\n",
  "  ;; This function tests to see if n is even\n  (define (is_even n)\n    (if (=\
    \ (remainder n 2) 0)\n        true\n        false))\n  ;; This function tests\
    \ to see if n is greater than max\n  (define (is_greater_than_max n max)\n   \
    \ (if (> n max)\n        true\n        false))\n  ;; This function returns the\
    \ largest even number in the range [x, y]\n  (define (loop n max)\n    (if (and\
    \ (is_even n) (is_greater_than_max n max))\n        max\n        (loop (+ n 1)\
    \ n)))\n  ;; x and y are the lower and upper bounds of the range, respectively\n\
    \  (if (is_even x)\n      (loop x 0)\n      (loop (+ x 1) 0)))\n", "  (if (&gt;\
    \ x y)\n      -1\n      (if (even? y)\n          y\n          (choose_num x (-\
    \ y 1)))))\n</code>\nHere is my JavaScript implementation\n<code>function choose_num(x,\
    \ y) {\n    if (x &gt; y)\n        return -1;\n    if (y % 2 == 0)\n        return\
    \ y;\n    return choose_num(x, y - 1);\n}\n</code>\nBut I feel like this is not\
    \ the best way, because of the redundant <code>return</code>s. What is a better\
    \ way to implement this function in JavaScript?\n\n\nA:\n\nUse <code>Math.max</code>\
    \ to easily get the largest value, and then keep subtracting by 2 until it's even.\
    \ This is a bit more explicit than your approach, but it's more concise and it\
    \ avoids recursion:\n<code>function choose_num(x, y) {\n    var max = Math.max(x,\
    \ y);\n    while (max % 2 != 0) max--;\n    return max == Math.min(x, y) ? max\
    \ : -1;\n}\n</code>\n", "  (if (= x y)\n      (- x 1)\n      (choose_num (- x\
    \ 2) y)))", "  (cond\n    [(= x y) y]\n    [(> x y) -1]\n    [(= (remainder x\
    \ 2) 0) (choose_num (+ x 1) y)]\n    [else (choose_num (+ x 1) y)]))\n", "  (cond\n\
    \    [(> x y) -1]\n    [(= x y) (even? x)]\n    [(even? y) y]\n    [else (choose_num\
    \ x (- y 1))]))\n\n", "  (if (= x y)\n      (if (even? x)\n          x\n     \
    \     -1)\n      (if (even? x)\n          (max x (choose_num (+ x 1) y))\n   \
    \       (choose_num (+ x 1) y))))\n</code>\nbut that looks pretty ugly... also\
    \ if I did it with <code>for/fold</code> I could make it much faster (because\
    \ the first example will go through all the numbers even if it finds the biggest\
    \ one before hand).\nAny suggestions?\n\n\nA:\n\nHere's a simple solution using\
    \ <code>for/fold</code>:\n<code>(define (choose-num start end)\n  (for/fold ([max\
    \ -1])\n            ([i (in-range start (add1 end))])\n    (when (even? i)\n \
    \     (max i max))))\n</code>\nIt works because <code>for/fold</code> implicitly\
    \ calls <code>max</code> when the predicate is true, making the <code>when</code>\
    \ unnecessary.\n", "  (cond\n    [(even? x) (if (even? y) (cond [(> x y) x] [else\
    \ y]) x)]\n    [(even? y) y]\n    [else -1]))\n", "  (cond\n    [(>= x y) -1]\n\
    \    [(= 0 (modulo x 2)) x]\n    [else (choose_num (+ x 1) y)]))\n", "  (if (and\
    \ (even? x) (even? y))\n      (if (&gt; x y) y x)\n      (if (even? x) x\n   \
    \       (if (even? y) y -1))))\n", "  (cond\n    ((> x y) -1)\n    ((even? x)\
    \ x)\n    (else (choose_num (+ x 1) y))))\n", "  (cond\n    [(<= x y) (if (even?\
    \ x) x (choose_num (+ x 1) y))]\n    [else -1]))", "  (if (&gt; x y)\n      -1\n\
    \      (if (= 0 (remainder x 2))\n          x\n          (choose_num (+ x 1) y))))\n\
    </code>\nAny tips to make this more Racket-y?\nThanks!\n\n\nA:\n\nLet's start\
    \ with the <code>&gt;</code> and <code>=</code> operators. In Racket we usually\
    \ use <code>zero?</code> for checking if a number is zero, and <code>&gt;</code>\
    \ for checking if a number is positive:\n<code>(if (zero? (remainder x 2))\n \
    \   \u2026)\n</code>\nBut Racket has a nice operator that combines checking if\
    \ a number is even and modulo arithmetic:\n<code>(if (even? x)\n    \u2026)\n\
    </code>\nFor the case where there's no even number, we can use <code>cond</code>\
    \ and take advantage of Racket's eager evaluation:\n<code>(cond [(zero? (remainder\
    \ x 2)) \u2026]\n      [(even? x) \u2026]\n      [else -1])\n</code>\nWe can also\
    \ rewrite <code>x</code> as <code>(+ x 1)</code> using <code>add1</code>:\n<code>(cond\
    \ [(zero? (remainder x 2)) \u2026]\n      [(even? x) \u2026]\n      [else (choose_num\
    \ (add1 x) y)])\n</code>\nThis is starting to look quite readable and Racket-like,\
    \ but it still has a problem: it's making recursive calls in a tail position,\
    \ which causes the stack to grow. Racket is a Scheme implementation, and the Scheme\
    \ standard mandates that in a tail call the implementation should reuse the current\
    \ stack frame, but Racket does not do that (yet).\nTo make sure that it doesn't\
    \ make recursive calls in a tail position, we can wrap the recursive call in an\
    \ extra procedure:\n<code>(define (choose_num x y)\n  (define (helper x)\n   \
    \ (cond [(zero? (remainder x 2)) \u2026]\n          [(even? x) \u2026]\n     \
    \     [else (helper (add1 x))]))\n  (helper x))\n</code", "  (cond\n    [(and\
    \ (even? x) (even? y)) (max x y)]\n    [(not (even? x)) (choose_num (+ x 1) y)]\n\
    \    [(not (even? y)) (choose_num x (- y 1))]))\n", "  ;; TODO: Replace '-1' with\
    \ your implementation.\n  (if (> x y) -1 (-1)))\n", "    (if (and (odd? x) (odd?\
    \ y)) (choose_num (+ x 1) y)\n    (if (and (even? x) (even? y)) (choose_num x\
    \ (- y 1))\n    (if (and (even? x) (odd? y)) y\n    (if (and (odd? x) (even? y))\
    \ -1\n    1))))))\n\n", "  (if (= x y)\n      (if (even? x)\n          x\n   \
    \       -1)\n      (let ([z (add1 x)])\n        (choose_num z y))))\n</code>\n\
    When I run this in DrRacket I see (choose_num 12 15) gives me 14.  When I do (choose_num\
    \ 13 12) it gives me #[compound-procedure 4].  I am not sure why it is not evaluating\
    \ to -1.  If I replace -1 with anything else it also gives me that thing.  Is\
    \ there a reason why it would not reduce to -1?\n\n\nA:\n\nRacket will print a\
    \ procedure with the output <code>#[compound-procedure ...]</code> if it can't\
    \ reduce any more. When you replace <code>-1</code> with a number, it can reduce\
    \ to that value, but otherwise it can't reduce any more.\nYou can see this in\
    \ the intermediate steps.\n<code>(define (choose_num x y)\n  (if (= x y)\n   \
    \   (if (even? x)\n          x\n          -1)\n      (let ([z (add1 x)])\n   \
    \     (choose_num z y))))\n", "  (define (mod-x-2 n)\n    (if (= (modulo n 2)\
    \ 0)\n        1\n        0))\n  (if (&gt; x y)\n      -1\n      (if (= (mod-x-2\
    \ x) 1)\n          (choose_num (+ x 1) y)\n          x)))\n</code>\nIs this the\
    \ most efficient way to implement this function? I feel as though it could be\
    \ done more efficiently, but I'm not sure how. \n\n\nA:\n\nThis is not a terribly\
    \ efficient implementation, but it is correct.  I think you could improve it by\
    \ identifying all of the even numbers that are between <code>x</code> and <code>y</code>,\
    \ and then choosing the largest.\n", "  (if (even? x)\n      (if (even? y)\n \
    \         (if (> x y)\n              y\n              x)\n          (if (> x (-\
    \ y 1))\n              (- y 1)\n              x))\n      (if (even? y)\n     \
    \     (if (> (- x 1) y)\n              y\n              (- x 1))\n          (if\
    \ (> (- x 1) (- y 1))\n              (- y 1)\n              (- x 1)))))\n", " \
    \ (cond ((<= x y) (if (even? x) x (choose_num (+ x 1) y)))\n        (else -1)))\n",
  "  (cond\n    [(= x y) x]\n    [(= x y -1) (- x 1)]\n    [(= x y -2) (- x 2)]\n\
    \    [(< x y) (choose_num (+ x 1) y)]))\n\n", "    (if (= x y)\n        (if (even?\
    \ x)\n            x\n            -1)\n        (if (= (modulo x 2) 0)\n       \
    \     (if (choose_num (add1 x) y)\n                (choose_num (add1 x) y)\n \
    \               x)\n            (choose_num (add1 x) y))))\n", "  (if (and (even?\
    \ x) (even? y))\n      (if (< x y)\n          x\n          y)\n      (if (and\
    \ (even? x) (not (even? y)))\n          x\n          (if (and (not (even? x))\
    \ (even? y))\n              y\n              -1))))\n", "  (cond [(= x y) x]\n\
    \        [(= (modulo x 2) 0) x]\n        [else (choose_num (add1 x) y)]))\n",
  "  (cond\n    [(and (= (remainder x 2) 0) (= (remainder y 2) 0)) (max x y)]\n  \
    \  [(and (= (remainder x 2) 1) (= (remainder y 2) 1)) (if (&gt; x y) x y)]\n \
    \   [(and (= (remainder x 2) 0) (= (remainder y 2) 1)) (max x (- y 1))]\n    [(and\
    \ (= (remainder x 2) 1) (= (remainder y 2) 0)) (max (- x 1) y)]))\n</code>\nBut,\
    \ it's not working as I expected. When I run <code>(choose_num 7 9)</code>, it\
    \ returns <code>6</code> instead of <code>8</code>.\n\n\nA:\n\nThere are several\
    \ mistakes in your code.\n\nThe <code>cond</code>s with the first test <code>(and\
    \ (= (remainder x 2) 0) (= (remainder y 2) 0))</code> and <code>(and (= (remainder\
    \ x 2) 1) (= (remainder y 2) 1))</code> are incorrect. The <code>max</code> function\
    \ does not return the biggest even number between two numbers. It returns the\
    \ biggest one.\nYou don't test for the two numbers being equal, in which case\
    \ you should return it.\nYou didn't test for what happens when the first number\
    \ is bigger than the second.\n\nHere is your code modified so that it works:\n\
    <code>(define (choose_num x y)\n  (cond\n    [(and (= (remainder x 2) 0) (= (remainder\
    \ y 2) 0)) (if (&gt; x y) x y)]\n    [(and (= (remainder x 2) 1) (= (remainder\
    \ y 2) 1)) (if (&gt; x y) (- x 1) (- y 1))]\n    [(and (= (remainder x 2) 0) (=\
    \ (remainder y 2) 1)) (max x (- y 1))]\n    [(and (= (remainder x 2) 1) (= (remainder\
    \ y 2) 0)) (max (- x 1) y)]\n    [(= x y) x]))\n", "  (cond\n    [(= x y) (- x\
    \ 1)]\n    [(and (= x y) (even? x)) (- x 1)]\n    [(and (= x y) (odd? x)) x]\n\
    \    [(and (even? x) (odd? y)) (choose_num (+ x 1) y)]\n    [(and (odd? x) (even?\
    \ y)) (choose_num (+ x 1) y)]\n    [(= y 0) -1]\n    [(odd? x) (- x 1)]\n    [(even?\
    \ x) (- x 2)]))\n</code>\nIf possible it would be nice if you could explain how\
    \ to do this without using the prime cond function, but if that's the only way\
    \ then so be it.\n\n\nA:\n\nI've found a rather simple solution.\n<code>(define\
    \ (choose_num x y)\n  (if (or (= x 0) (= y 0))\n      -1\n      (if (or (even?\
    \ x) (even? y))\n          (if (&lt; x y)\n              (choose_num (+ x 1) y)\n\
    \              (choose_num x (+ y 1)))\n          x)))\n</code>\nI don't think\
    \ it's possible to get a solution without a cond or if statement.\n", "  (if (&gt;\
    \ x y)\n      -1\n      (if (even? x)\n          x\n          (choose_num (add1\
    \ x) y))))\n</code>\nThis is the error I get when I run the code:\n<code>==&gt;\
    \ (choose_num 12 15)\n. . choose_num: bad syntax in: choose_num\n</code>\nCan\
    \ someone help explain to me what's going on here?\n\n\nA:\n\nThis is due to how\
    \ Racket's REPL works.\nWhen you write <code>(choose_num 12 15)</code> in the\
    \ Racket REPL, it will first evaluate the <code>choose_num</code> expression,\
    \ which means that in your case it will expand your definition of <code>choose_num</code>\
    \ before it continues evaluating the arguments.\nThis expansion will result in\
    \ a syntax error because the REPL already expects a number after the function\
    \ name, not another function call.\nIf you want to use the REPL to test your function,\
    \ you can use <code>#lang racket</code> at the beginning of your file to make\
    \ the REPL evaluate your code using the <code>racket</code> language instead of\
    \ the default <code>scheme</code> language.\n", "  (cond\n    [(or (even? x) (even?\
    \ y)) (cond\n                                [(even? x) x]\n                 \
    \               [else y])]\n    [else -1]))\n</code>\nI don't think it's a particularly\
    \ elegant solution, but I don't really see a better way to do it.\n\n\nA:\n\n\
    There are three main things to consider:\nFirst, you can start by splitting the\
    \ problem into two parts: finding the biggest even number in a given range, and\
    \ finding the biggest number in a given range. Try to write a function that finds\
    \ the biggest even number in a range, and then have that function call it.\nSecond,\
    \ you need to eliminate some cases. You do check if both are even, but you can\
    \ actually do better. An easy case is if <code>x</code> is greater than <code>y</code>;\
    \ if this is the case, then there is obviously no biggest number. You can test\
    \ for this by starting off your <code>cond</code> with an expression that checks\
    \ that <code>x</code> is less than or equal to <code>y</code>.\nFinally, you need\
    \ to think about when <code>x</code> and <code>y</code> are both odd. Your solution\
    \ doesn't work here. In general, you want to think of the problem geometrically;\
    \ here, you want to find the biggest number in the range <code>x</code> to <code>y</code>\
    \ such that it is even and greater than or equal to <code>x</code>.\nIf <code>x</code>\
    \ is odd, then the next even number greater than or equal to <code>x</code> is\
    \ <code>x+1</code>. This is true if <code>x</code> is even as well; in this case,\
    \ <code>x+1</code> is always odd. This means that you can always find the next\
    \ even number by adding one to <code>x</code>.\nSo, once you know that <code>x</code>\
    \ is not greater than <code>y</code>, you can test if <code>x</code> is even.\
    \ If it is, then you can return <code>x</code>. If it isn't, then you can return\
    \ the result of calling your function again with the arguments", "  (cond\n  \
    \  [(= y x) (if (even? x) x -1)]\n    [(= (- y x) 1) (if (even? x) x (if (even?\
    \ y) y -1))]\n    [(= (- y x) 2) (if (even? x) x (if (even? y) y (if (even? (+\
    \ x 1)) (+ x 1) -1)))]\n    [(> (- y x) 2) (let ([z (+ x 1)])\n              \
    \       (cond\n                       [(and (even? z) (even? (+ z 1))) (+ z 1)]\n\
    \                       [(and (even? z) (even? (+ z 2))) (+ z 2)]\n          \
    \             [(and (even? z) (even? (+ z 3))) (+ z 3)]\n                    \
    \   [(and (even? z) (even? (+ z 4))) (+ z 4)]\n                       [(and (even?\
    \ z) (even? (+ z 5))) (+ z 5)]\n                       [(and (even? z) (even?\
    \ (+ z 6))) (+ z 6)]\n                       [(and (even? z) (even? (+ z 7)))\
    \ (+ z 7)]\n                       [(and (even? z) (even? (+ z 8))) (+ z 8)]\n\
    \                       [(and (even? z) (even? (+ z 9))) (+ z 9)]\n          \
    \             [(and (even? z) (even? (+ z 10))) (+ z 10)]\n                  \
    \     [(and (even? z) (even? (+ z 11))) (+ z 11)]\n                       [(and\
    \ (even? z) (even? (+ z 12))) (+ z 12)]\n                       [(and (even? z)\
    \ (even? (+ z 13))) (+ z 13)]\n                       [(and (even? z) (even? (+\
    \ z 14))) (+ z 14)]\n                       [(and (even? z) (even? (+ z 15)))\
    \ (+ z 15)]\n                       [(and (even? z) (even? (+ z 16))) (+ z 16)]\n\
    \                       [(and (even? z) (even? (+ z 17))) (+ z 17)]\n        \
    \               [(and (even? z) (even? (+ z 18))) (+ z 18)]\n                \
    \       [(and (even? z) (even? (+ z 19))) (+ z 19)]\n                       [(and\
    \ (even? z) (even? (+ z", "  ;; TODO implement this function\n  )\n", "  (if (and\
    \ (<= x y) (even? x))\n      (if (= x y) x (choose_num (+ x 2) y))\n      -1))\n",
  "  (if (and (= (remainder x 2) 0) (= (remainder y 2) 0))\n      (- y 2)\n      (if\
    \ (and (= (remainder x 2) 1) (= (remainder y 2) 1))\n          (- x 2)\n     \
    \     (if (= (remainder y 2) 0)\n              (- y 2)\n              (- x 2)))))\n",
  "  (if (&gt; x y)\n      -1\n      (cond [(even? x) x]\n            [(even? y) y]\n\
    \            [else (- y 1)])))\n</code>\n", "  (if (= x y)\n      (if (even? x)\n\
    \          x\n          -1)\n      (if (even? x)\n          (if (even? y)\n  \
    \            (max x y)\n              (choose_num (+ x 1) y))\n          (choose_num\
    \ (+ x 1) y))))\n", "  (cond\n    [(and (even? x) (even? y)) (choose_num x y)]\n\
    \    [(and (odd? x) (even? y)) (choose_num (add1 x) y)]\n    [(and (even? x) (odd?\
    \ y)) (choose_num x (sub1 y))]\n    [(= x y) (if (even? x) x -1)]\n    [(< x y)\
    \ -1]))\n", "  (if (> x y)\n      -1\n      (if (even? x)\n          x\n     \
    \     (choose_num (+ x 1) y))))\n", "  (cond [(> x y) -1]\n        [(even? x)\
    \ x]\n        [else (choose_num (sub1 x) y)]))", "  (if (> x y) \n      -1\n \
    \     (if (even? x)\n          x\n          (choose_num (+ x 1) y))))\n", "  ;;\
    \ only solution that works for all cases\n  (define (get_even_num num)\n    (cond\n\
    \      [(zero? (modulo num 2)) num]\n      [else (get_even_num (- num 1))]))\n\
    \  (if (< x y)\n      (get_even_num y)\n      -1))\n", "  (cond\n    [(and (positive?\
    \ x) (positive? y))\n     (cond\n       [(= x y)\n        (cond\n          [(even?\
    \ x) x]\n          [else -1])]\n       [(< x y)\n        (cond\n          [(even?\
    \ y) y]\n          [(even? x) x]\n          [else -1])]\n       [else -1])]\n\
    \    [else -1]))\n", "  (cond ((= x y) y)\n        ((even? x) x)\n        (else\
    \ (choose_num (add1 x) y))))\n", "  (if (or (< x 0) (< y 0)) -1\n      (if (and\
    \ (even? x) (>= x y)) x\n          (if (even? y) y -1))))\n", "    ; My implementation\n\
    \    (if (&gt; x y)\n        -1\n        (if (even? x)\n            x\n      \
    \      (choose_num (+ x 1) y))))\n", "  \n  ;; Check if x and y are in range\n\
    \  (if (and (positive? x) (positive? y))\n      (let loop ((a x) (b y))\n\t;;\
    \ Check if we have reached the end of the range\n\t(if (= a b)\n\t    ;; If we\
    \ did, we can check if a is even.\n\t    (if (even? a)\n\t\ta\n\t\t;; If a is\
    \ not even, return -1\n\t\t-1)\n\t    ;; If we have not reached the end of the\
    \ range,\n\t    ;; check if a is even\n\t    (if (even? a)\n\t\t;; If it is, store\
    \ it in b and move on\n\t\t(loop (+ a 1) a)\n\t\t;; If it isn't, move on\n\t\t\
    (loop (+ a 1) b))))\n      ;; If x or y were negative or zero, return -1\n   \
    \   -1))\n", "  (cond ((> x y) -1)\n        ((= (remainder x 2) 0)\n         (if\
    \ (<= x y)\n             x\n             (choose_num (- x 1) y)))\n        (else\n\
    \         (choose_num (- x 1) y))))\n\n", "  (if (&gt; x y)\n      -1\n      (let\
    \ ([num (- x (% x 2))])\n        (if (&lt;= num y)\n            num\n        \
    \    (- num 2)))))\n</code>\nI do not understand why this solution fails on the\
    \ judge system while it works on the local tests and on another judge system.\n\
    \n\nA:\n\nThe problem was that the function was to be called <code>choose-num</code>\
    \ instead of <code>choose_num</code>.\n", "  (define (biggest-even-in-range x\
    \ y)\n    (if (and (even? x) (even? y)) x\n        (if (and (even? x) (not (even?\
    \ y))) x\n            (if (and (not (even? x)) (even? y)) y\n                (if\
    \ (and (not (even? x)) (not (even? y))) -1\n                    (if (not (even?\
    \ x)) (biggest-even-in-range (+ x 1) y)\n                        (biggest-even-in-range\
    \ x (+ y 1))))))))\n  (if (> x y) (biggest-even-in-range y x) (biggest-even-in-range\
    \ x y)))\n</code>\nAnd the output is:\n<code>&gt; (choose_num 12 15)\n14\n&gt;\
    \ (choose_num 13 12)\n-1\n</code>\nBut, I feel that there should be a better way\
    \ to solve this one.\n\n\nA:\n\nWhat you're doing is basically right, but your\
    \ code is too complex. This is how I would've done it:\n<code>(define (choose-num\
    \ x y)\n  (cond\n    [(zero? (remainder x 2)) x]\n    [(zero? (remainder y 2))\
    \ y]\n    [else (-1)]))\n</code>\n", "  (if (and (even? x) (even? y))\n      (if\
    \ (<= x y) y x)\n      (if (<= x y) (if (even? x) x (choose_num (add1 x) y)) -1)))\n",
  "  (cond\n    [(<= y x) -1]\n    [(= (remainder y 2) 0) y]\n    [else (choose_num\
    \ x (- y 1))]))\n", "  (if (&gt; x y)\n      -1\n      (if (even? x)\n       \
    \   x\n          (choose_num (+ x 1) y))))\n</code>\nTest cases:\n<code>&gt; (choose_num\
    \ 12 15)\n14\n&gt; (choose_num 13 12)\n-1\n&gt; (choose_num 3 3)\n-1\n&gt; (choose_num\
    \ 1 100)\n100\n&gt; (choose_num 1 101)\n100\n&gt; (choose_num 1 102)\n102\n&gt;\
    \ (choose_num 10 100)\n100\n&gt; (choose_num 10 101)\n100\n&gt; (choose_num 10\
    \ 102)\n102\n&gt; (choose_num 9 102)\n102\n&gt; (choose_num 9 103)\n102\n&gt;\
    \ (choose_num 10 103)\n102\n&gt; (choose_num 10 104)\n104\n&gt; (choose_num 9\
    \ 104)\n104\n&gt; (choose_num 9 105)\n104\n&gt; (choose_num 10 105)\n104\n&gt;\
    \ (choose_num 10 106)\n106\n&gt; (choose_num 9 106)\n106\n&gt; (choose_num 9 107)\n\
    106\n&gt; (choose_num 10 107)\n106\n&gt; (choose_num 10 108)\n108\n&gt; (choose_num\
    \ 9 108)\n108\n&gt; (choose_num 9 109)\n108\n&gt; (choose_num 10 109)\n108\n&gt;\
    \ (choose_num 10 110)\n110\n&gt; (choose_num 9 110)\n110\n&gt; (choose_num 9 111)\n\
    110\n&gt; (choose_num 10 111)\n110\n&gt; (choose_num 10 112)\n112\n&gt; (choose_num\
    \ 9 112)\n112\n&gt; (choose_num 9 113)\n112\n&gt; (choose_num 10 113)\n112\n&gt;\
    \ (choose_num 10 114)", "  (cond ((&gt; x y) -1)\n        ((even? x) x)\n    \
    \    (else (choose_num (+ x 1) y))))\n</code>\nChoose a number in range using\
    \ a filter\n<code>#lang racket\n", "  ;; YOUR CODE GOES HERE\n  )\n", "  (cond\n\
    \    [(= x y) (if (even? x) x -1)]\n    [(even? x) (max x (choose_num (+ x 1)\
    \ y))]\n    [else (choose_num (+ x 1) y)]))\n", "  (if (and (even? x) (&lt;= x\
    \ y))\n      x\n      (if (and (even? y) (&lt;= x y))\n          y\n         \
    \ -1)))\n</code>\n", "  ;; @param x - integer number\n  ;; @param y - integer\
    \ number\n  ;; @return - biggest even integer number in the range [x, y] inclusive\n\
    \  (if (= x y)\n      (- x 1)\n      (if (even? x)\n          (choose_num (add1\
    \ x) y)\n          (choose_num (add1 x) y))))\n", "  (cond\n    [(= y x) x]\n\
    \    [(= (remainder y 2) 0) (choose_num x (- y 1))]\n    [else (- y 1)]))", " \
    \ (cond\n    [(= y x) x]\n    [(even? x) (choose_num x (- y 1))]\n    [else (-\
    \ x 1)]))\n</code>\n", "  (if (>= x y)\n      -1\n      (if (even? x)\n      \
    \    x\n          (choose_num (+ x 1) y))))\n", "  (cond\n    [(and (= (modulo\
    \ x 2) 0) (= (modulo y 2) 0)) (- y 2)]\n    [(and (= (modulo x 2) 1) (= (modulo\
    \ y 2) 0)) (- y 1)]\n    [(and (= (modulo x 2) 0) (= (modulo y 2) 1)) (- y 1)]\n\
    \    [(and (= (modulo x 2) 1) (= (modulo y 2) 1)) (- y 2)]\n    [else -1]))\n\
    </code>\nAnd then if you want to make a function that returns a list of all even\
    \ numbers in the range:\n<code>#lang racket\n", "  ;; Your code goes here.\n \
    \ (if (= x y) (if (even? x) x -1)\n    (if (even? y) (choose_num x (- y 1))\n\
    \      (choose_num x (- y 2)))))\n", "  (cond [(= y (+ x 2)) -1]\n        [(even?\
    \ y) y]\n        [else (choose_num x (- y 1))]))\n", "  (if (&gt; x y)\n     \
    \ -1\n      (if (= (modulo x 2) 0)\n          x\n          (choose_num (add1 x)\
    \ y))))\n</code>\n", "  (if (even? (+ x y))\n      (+ x y)\n      (+ x (- y 1))))\n\
    </code>\nAfter I press run, the console gives me\n<code> Standard input: 0\n</code>\n\
    Before I press run, the console gives me\n<code>Interactions disabled\n</code>\n\
    Why is this happening?\n\n\nA:\n\nIt\u2019s because <code>#lang racket</code>\
    \ is for writing programs. When you run such a program, it doesn\u2019t provide\
    \ a REPL. <code>#lang racket</code> is a shortcut for writing <code>#lang racket/base</code>,\
    \ and <code>racket/base</code> just provides the base syntax of the language,\
    \ i.e. the parts that are common between programs and scripts.\nThere are other\
    \ languages you can choose that are suitable for interactive use, such as <code>#lang\
    \ racket/base</code>, <code>#lang racket/load</code>, and <code>#lang racket</code>.\n",
  "  (if (&gt; x y)\n      -1\n      (if (even? x) x (choose_num (+ x 1) y))))\n</code>\n\
    This code is working. But I think it can be refactored to be more concise.\nCan\
    \ this code be re-factored to be more concise?\n\n\nA:\n\nIf you want to be concise,\
    \ I don't think you can get much better than this:\n<code>(define (choose-num\
    \ x y)\n  (when (even? x)\n    (if (&lt;= x y) x -1)))\n</code>\nBut, I think\
    \ it's better to have a function that is clear, and easy to follow, than to have\
    \ a function that is concise. In this case, I think your original version is much\
    \ easier to follow.\n", "  (if (and (integer? x) (integer? y) (> x 0) (> y 0))\n\
    \      (if (>= x y)\n          -1\n          (if (not (even? x))\n           \
    \   (choose_num (+ x 1) y)\n              x))\n      #f))\n\n", "    (cond ((and\
    \ (even? x) (even? y)) (if (> x y) x y))\n          ((even? x) x)\n          ((even?\
    \ y) y)\n          (else -1)))\n</code>\n", "  (if (and (even? x)\n          \
    \ (even? y))\n      (choose_num_helper x y #t)\n      (choose_num_helper (add1\
    \ x) y #f)))\n", "  (cond\n    [(>= x y) -1]\n    [(= x y) (if (even? x) x -1)]\n\
    \    [(even? x) (max x (choose_num (+ x 1) y))]\n    [else (choose_num (+ x 1)\
    \ y)]))\n", "  (cond\n    [(even? x) x]\n    [(even? y) y]\n    [else -1]))\n\
    </code>\n", "  (cond\n    [(> x y) -1]\n    [(even? x) x]\n    [else (choose_num\
    \ (+ x 1) y)]))\n", "  (cond ((= x y)\n         (if (even? x) x -1))\n       \
    \ ((< x y)\n         (if (even? x)\n             (if (> x (- y 1)) x (choose_num\
    \ (+ x 1) y))\n             (choose_num (+ x 1) y)))))\n\n", "  (cond\n    [(even?\
    \ y) y]\n    [(even? (+ x 1)) (+ x 1)]\n    [(even? (+ x 2)) (+ x 2)]\n    [(even?\
    \ (+ x 3)) (+ x 3)]\n    [(even? (+ x 4)) (+ x 4)]\n    [(even? (+ x 5)) (+ x\
    \ 5)]\n    [(even? (+ x 6)) (+ x 6)]\n    [(even? (+ x 7)) (+ x 7)]\n    [(even?\
    \ (+ x 8)) (+ x 8)]\n    [(even? (+ x 9)) (+ x 9)]\n    [(even? (+ x 10)) (+ x\
    \ 10)]\n    [(even? (+ x 11)) (+ x 11)]\n    [(even? (+ x 12)) (+ x 12)]\n   \
    \ [(even? (+ x 13)) (+ x 13)]\n    [(even? (+ x 14)) (+ x 14)]\n    [(even? (+\
    \ x 15)) (+ x 15)]\n    [(even? (+ x 16)) (+ x 16)]\n    [(even? (+ x 17)) (+\
    \ x 17)]\n    [(even? (+ x 18)) (+ x 18)]\n    [(even? (+ x 19)) (+ x 19)]\n \
    \   [(even? (+ x 20)) (+ x 20)]\n    [(even? (+ x 21)) (+ x 21)]\n    [(even?\
    \ (+ x 22)) (+ x 22)]\n    [(even? (+ x 23)) (+ x 23)]\n    [(even? (+ x 24))\
    \ (+ x 24)]\n    [(even? (+ x 25)) (+ x 25)]\n    [(even? (+ x 26)) (+ x 26)]\n\
    \    [(even? (+ x 27)) (+ x 27)]\n    [(even? (+ x 28)) (+ x 28)]\n    [(even?\
    \ (+ x 29)) (+ x 29)]\n    [(even? (+ x 30)) (+ x 30)]\n    [(even? (+ x 31))\
    \ (+ x 31)]\n    [(even? (+ x 32)) (+ x 32)]\n    [(even? (+ x 33)) (+ x 33)]\n\
    \    [(even? (+ x 34)) (+ x 34)]\n    [(even? (+ x 35)) (+ x 35)]\n    [(even?\
    \ (+ x 36)) (+ x 36)]\n    [(even? (+ x 37)) (+ x 37)]\n    [(even? (+ x 38))\
    \ (+ x 38)]\n    [(even?", "  (if (&gt; x y) -1\n      (if (even? x) x (choose_num\
    \ (+ x 1) y))))\n</code>\nThe initial <code>if</code> checks for the two numbers\
    \ being in the right order.  The second <code>if</code> checks whether the first\
    \ number is even.  If so, it's returned; otherwise the function is called again\
    \ with the numbers incremented.\n", "  (cond\n    [(= x y)\n     x]\n    [(even?\
    \ x)\n     (cond\n       [(even? y)\n        (max x y)]\n       [else\n      \
    \  x])]\n    [else\n     (choose_num (+ x 1) y)]))\n\n\n", "  (cond\n    ((> x\
    \ y) -1)\n    ((even? x) (if (= y x) x (choose_num (add1 x) y)))\n    (else (choose_num\
    \ (add1 x) y))))\n", "  (if (&gt;= y x)\n      (cond\n        [(odd? x) (choose_num\
    \ (+ x 1) y)]\n        [(= x y) x]\n        [else (choose_num (+ x 2) y)])\n \
    \     -1))\n</code>\n", "  (if (even? x)\n      (if (even? y)\n          (if (&gt;\
    \ x y)\n              -1\n              x)\n          (if (odd? (+ y 1))\n   \
    \           (+ y 1)\n              -1))\n      (if (even? (+ x 1))\n         \
    \ (+ x 1)\n          (if (even? (+ x 2))\n              (+ x 2)\n            \
    \  -1))))\n", "  (if (and (even? x) (even? y))\n      (if (> x y) x y)\n     \
    \ (if (even? x) x\n          (if (even? y) y -1))))\n", "  ;; TODO your solution\
    \ here\n  )\n```\n\nWrite your code in `choose_num.rkt` and push your code to\
    \ the repo on\nGitHub.\n\n---\n\nIn order to get information about the tests that\
    \ you need to pass,\nyou can execute the tests using the following commands:\n\
    \n```sh\nraco test choose_num.rkt\n```\n\nIn order to get more verbose information\
    \ about what's going on, \nadd the `-v` or `--verbose` flag:\n\n```sh\nraco test\
    \ -v choose_num.rkt\n```\n\n---\n\n## Modular arithmetic\n\nModular arithmetic\
    \ is a system of arithmetic for integers, where numbers \"wrap around\" when reaching\
    \ a certain value, called the modulus.\n\nIn this exercise we will consider the\
    \ modulus to be 10.\n\nWe can do addition, subtraction, multiplication and division\
    \ (except for division by zero) with the modulus.\n\nFor example:\n\n`5 + 5 =\
    \ 0 mod 10`\n\n`10 - 5 = 5 mod 10`\n\n`3 * 3 = 9 mod 10`\n\n`5 / 2 = 5 mod 10`\n\
    \n`10 / 0 = undefined`\n\n`5 / 0 = undefined`\n\nWrite a function that takes three\
    \ numbers, `a`, `b` and `mod` and returns the result of `a/b` in the modular arithmetic\
    \ system with modulus `mod`.\n\nIf `b` is 0 or `a/b` is undefined, return `#f`.\n\
    \nThe function you write should look something like this:\n\n```racket\n#lang\
    \ racket\n", "  (cond ((= x y) -1)\n        ((= x 1) -1)\n        ((even? x) x)\n\
    \        (else (choose_num (- x 1) y))))\n</code>\nIt seems like there should\
    \ be an easier way to do this, without the recursion. I've tried using a <code>while</code>\
    \ loop, but I can't seem to figure out the right way to do it.\nAny suggestions?\n\
    \n\nA:\n\n<code>(define (choose-num x y)\n  (if (&lt; x y)\n      (choose-num\
    \ y x))\n\n  (if (even? x)\n      x\n      (choose-num (- x 1) y)))\n</code>\n\
    This code will switch the <code>x</code> and <code>y</code> values if <code>x</code>\
    \ is less than <code>y</code>, and if <code>x</code> is odd, then it will call\
    \ itself with <code>x - 1</code>.\n", "  (cond\n    [(= x y) x]\n    [(or (= (remainder\
    \ x 2) 1) (= (remainder y 2) 1)) -1]\n    [(= y (+ x 1)) x]\n    [(= y (+ x 2))\
    \ y]\n    [else (+ x 2)]))\n</code>\nI have this working as intended. I was wondering\
    \ if it is possible to complete the same task in a more elegant way. I'm interested\
    \ in other suggestions.\n\n\nA:\n\nHere's another way:\n<code>(define (choose-num\
    \ x y)\n  (define n (if (odd? y) (sub1 y) y))\n  (if (odd? n) (sub1 n) n))\n</code>\n",
  "  (cond\n    [(= x y) x]\n    [(even? x) (choose_num (add1 x) y)]\n    [else (choose_num\
    \ (add1 x) y)]))\n", "  (if (and (even? x) (>= x y))\n      x\n      (choose_num\
    \ (+ x 1) y)))\n```\n\n``` #lang racket\n", "  (if (&gt; x y)\n      -1\n    \
    \  (if (even? x)\n          x\n          (choose_num (+ x 1) y))))\n</code>\n",
  "  (define (choose_num-help n)\n    (if (= 0 (modulo n 2)) n (choose_num-help (-\
    \ n 1))))\n  (cond\n    [(= x y) (choose_num-help x)]\n    [(> x y) -1]\n    [else\
    \ (choose_num-help y)]))\n", "  (cond\n    [(< x y) (if (even? y) y (choose_num\
    \ x (- y 1)))]\n    [(> x y) (if (even? x) x (choose_num (- x 1) y))]\n    [(=\
    \ x y) (if (even? x) x -1)]))\n", "  ;; TODO: put your code here\n)\n```\n\nOnce\
    \ you have implemented your solution, you can test it by executing the following:\n\
    \n```racket", "  (cond\n    [(> x y) -1]\n    [(even? x) x]\n    [else (choose_num\
    \ (sub1 x) y)]))\n", "  (if (equal? (remainder x 2) 0)\n      x\n      (if (equal?\
    \ (remainder (sub1 x) 2) 0)\n          (sub1 x)\n          (if (&lt; x y)\n  \
    \            (choose_num (sub1 x) y)\n              -1))))\n", "  (cond\n    ((<\
    \ x y) x)\n    ((and (= x y) (even? x)) x)\n    ((and (= x y) (odd? x)) -1)\n\
    \    (else (choose_num (+ x 1) y))))\n", "  (if (&gt; x y) \n      -1\n      (if\
    \ (even? x) x (choose_num (+ x 1) y))))\n", "  ;; You have to complete this function.\n\
    \  (if (and (even? x) (> x y))\n      -1\n      (if (even? y)\n          y\n \
    \         (choose_num x (- y 1)))))\n", "  (if (= x y)\n      (if (even? x)\n\
    \          x\n          -1)\n      (if (= x (+ y 1))\n          -1\n         \
    \ (if (even? y)\n              y\n              (choose_num x (- y 1))))))\n",
  "  (define (get_even l)\n    (cond\n      [(empty? l) empty]\n      [(even? (first\
    \ l)) (cons (first l) (get_even (rest l)))]\n      [else (get_even (rest l))]))\n\
    \  (cond\n    [(> x y) -1]\n    [(empty? (get_even (build-list (- y x) (lambda\
    \ (i) (+ x i))))) -1]\n    [else (first (sort (get_even (build-list (- y x) (lambda\
    \ (i) (+ x i)))) <))]))\n", "  (if (or (not (integer? x))\n          (not (integer?\
    \ y))\n          (&lt; x 0)\n          (&lt; y 0)\n          (&lt; x y))\n   \
    \   -1\n      (-&gt; (build-list (- y x) add1)\n          (filter even?)\n   \
    \       (apply max))))\n</code>\nThis works fine, but I have one problem with\
    \ it. <code>build-list</code> is kind of a \"heavy\" function to call and it is\
    \ not really needed in my use case.\nIs there an easier way to do this?\n\n\n\
    A:\n\nOne way you could do it is the following, which should be more efficient\
    \ (no need to build the entire list):\n<code>(define (choose-num x y)\n  (if (or\
    \ (not (integer? x))\n          (not (integer? y))\n          (&lt; x 0)\n   \
    \       (&lt; y 0)\n          (&lt; x y))\n      -1\n      (let loop ([x x])\n\
    \        (if (odd? x)\n            (loop (add1 x))\n            (if (&lt; x y)\n\
    \                (loop (add1 x))\n                x)))))\n</code>\nA few other\
    \ minor suggestions:\n\nUse the <code>define</code> form to assign names to your\
    \ functions (like you do with <code>choose-num</code>), this way it's easier to\
    \ later refer to them.\nThe names of the parameters of a function should not contain\
    \ dashes, you should use underscores instead.\nYour function has a base case,\
    \ so it should end in a <code>recur</code>, not a <code>loop</code>.\n\n", " \
    \ (if (&gt; x y)\n      -1\n      (if (even? y)\n          y\n          (choose_num\
    \ x (- y 1)))))\n</code>\nThe above function works fine in the DrRacket, however,\
    \ when I try to run it in CS61A Homework Checker for the unit tests, it gives\
    \ me a Runtime Error. It might be because the recursion level is too deep, but\
    \ I don't know how to solve it.\n\n\nA:\n\nThe problem is that you are using a\
    \ helper function that is overloading the name. The name of the function should\
    \ be <code>choose-num</code> with a hyphen instead of an underscore. So just change\
    \ the name of the function and you should be fine.\n", "  (if (and (even? x) (even?\
    \ y))\n      (if (even? (/ (- x 1) 2))\n          (if (even? (/ (- y 1) 2))\n\
    \              (/ (+ x y) 2)\n              (- y 1))\n          (if (even? (/\
    \ (- y 1) 2))\n              x\n              (- y 1)))\n      (if (even? x)\n\
    \          (- x 1)\n          (if (even? y)\n              y\n              -1))))\n",
  "  (cond\n    [(= x y) (if (even? x) x -1)]\n    [(< x y) (if (even? y) (choose_num\
    \ x (- y 1)) -1)]\n    [(> x y) (if (even? x) (choose_num (+ x 1) y) -1)]))\n",
  "  (if (&gt; x y)\n      -1\n      (if (even? x)\n          x\n          (choose_num\
    \ (+ x 1) y))))\n", "  (if (&gt; x y)\n      -1\n      (if (even? y)\n       \
    \   y\n          (choose_num x (- y 1)))))\n", "  (if (&gt; x y)\n      -1\n \
    \     (if (even? x) x (choose_num (+ x 1) y))))\n", "  (cond\n    [(>= x 0)\n\
    \     (cond\n       [(= x y) (if (even? x) x -1)]\n       [(even? x) (max x (choose_num\
    \ (+ x 1) y))]\n       [else (choose_num (+ x 1) y)])]\n    [else -1]))", "  (cond\
    \ ((= x y) (- x 1))\n        ((even? x) x)\n        (else (choose_num (+ x 1)\
    \ y))))\n", "  (define min (min x y))\n  (define max (max x y))\n  (define num\
    \ (sub1 (sub1 max)))\n  (if (= min max)\n      (if (even? min)\n          min\n\
    \          -1)\n      (define num (sub1 (sub1 max)))\n      (define search_num\
    \ (lambda (i)\n                           (if (and (>= i min)\n              \
    \                      (even? i))\n                               i\n        \
    \                       (search_num (sub1 i)))))\n      (search_num num)))", " \
    \ (if (or (and (odd? x) (odd? y))\n          (< x y))\n      (- 1)\n      (choose_num\
    \ (sub1 x) (sub1 y))))\n", "  (define (choose_num_helper x y)\n    (cond [(and\
    \ (&lt;= x y) (even? x)) x]\n          [(&lt;= x y) (choose_num_helper (+ x 1)\
    \ y)]\n          [else -1]))\n  (choose_num_helper x y))\n</code>\nNow I have\
    \ to convert this function to Scheme.\nI have tried but it doesn't seem to work,\
    \ here is my converted function:\n<code>(define (choose_num x y)\n  (define (choose_num_helper\
    \ x y)\n    (cond [(and (&lt;= x y) (even? x)) x]\n          [(&lt;= x y) (choose_num_helper\
    \ (+ x 1) y)]\n          [else -1]))\n  (choose_num_helper x y))\n</code>\nI get\
    \ the error \"The object #f is not applicable\".\nIf someone could help me correct\
    \ this problem it would be greatly appreciated.\nThank you.\n\n\nA:\n\nIn Scheme,\
    \ <code>and</code> is a special form, and will not accept <code>#f</code> as an\
    \ argument. Thus, for <code>(and #f 1)</code>, it will complain about being passed\
    \ 1, not being passed #f. Scheme does not have short-circuiting, so all arguments\
    \ to a special form must be able to be evaluated. \nUse <code>cond</code> instead,\
    \ where you can use arbitrary expressions in the first position:\n<code>(cond\
    \ ((and (&lt;= x y) (even? x)) x)\n      ((&lt;= x y) (choose_num_helper (+ x\
    \ 1) y))\n      (else -1))\n</code>\nFor pedantic purposes, using <code>&amp;&amp;</code>\
    \ instead of <code>and</code> will also work, but that is not the idiomatic use.\n",
  "  (if (and (even? x) (<= x y)) x\n      (if (even? y) y\n          -1)))\n", " \
    \ (cond\n    [(< x y) (cond [(even? y) y]\n                   [(even? (- y 1))\
    \ (- y 1)]\n                   [(even? (- y 2)) (- y 2)]\n                   [else\
    \ -1])]\n    [(> x y) (cond [(even? x) x]\n                   [(even? (- x 1))\
    \ (- x 1)]\n                   [(even? (- x 2)) (- x 2)]\n                   [else\
    \ -1])]\n    [else x]))\n", "  (if (= x y)\n      (if (even? x)\n          x\n\
    \          -1)\n      (if (even? x)\n          (choose_num (+ x 1) y)\n      \
    \    (choose_num (+ x 1) y))))\n", "  (if (and (even? x) (even? y))\n      ;;\
    \ BOTH EVEN\n      (if (< x y)\n          ;; X IS LESS THAN Y\n          (if (=\
    \ x y)\n              ;; EQUAL\n              x\n              ;; NOT EQUAL\n\
    \              (if (= (- y 1) x)\n                  ;; 1 NUMBER IN RANGE\n   \
    \               x\n                  ;; MORE THAN 1 NUMBER IN RANGE\n        \
    \          (- y 2)))\n          ;; Y IS LESS THAN X\n          (if (= x y)\n \
    \             ;; EQUAL\n              x\n              ;; NOT EQUAL\n        \
    \      (if (= (- x 1) y)\n                  ;; 1 NUMBER IN RANGE\n           \
    \       x\n                  ;; MORE THAN 1 NUMBER IN RANGE\n                \
    \  (- x 2))))\n      ;; X OR Y OR BOTH ARE ODD\n      (if (and (even? x) (not\
    \ (even? y)))\n          ;; ONLY X IS EVEN\n          (if (= (- y 1) x)\n    \
    \          ;; 1 NUMBER IN RANGE\n              x\n              ;; MORE THAN 1\
    \ NUMBER IN RANGE\n              (- y 2))\n          ;; ONLY Y IS EVEN\n     \
    \     (if (= (- x 1) y)\n              ;; 1 NUMBER IN RANGE\n              y\n\
    \              ;; MORE THAN 1 NUMBER IN RANGE\n              (- x 2)))\n     \
    \ ;; NO EVEN NUMBERS\n      -1))\n\n", "  (if (and (even? x) (even? y))\n    \
    \  (if (> x y) (- x 2) (- y 2))\n      (if (and (even? x) (odd? y)) (- x 2) (if\
    \ (and (odd? x) (even? y)) (- y 2) -1))))\n", "  (if (or (not (number? x)) (not\
    \ (number? y)))\n      -1\n      (if (and (integer? x) (integer? y))\n       \
    \   (if (and (positive? x) (positive? y))\n              (if (>= x y)\n      \
    \            -1\n                  (find_even x y))\n            -1)\n       \
    \ -1)))\n", "  (if (even? x)\n      x\n      (if (even? (sub1 x))\n          (sub1\
    \ x)\n          (if (even? (sub1 (sub1 x)))\n              (sub1 (sub1 x))\n \
    \             -1))))\n", "  (if (> x y)\n      -1\n      (if (even? x)\n     \
    \     x\n          (choose_num (+ x 1) y))))\n", "  (cond ((and (even? x) (even?\
    \ y)) \n         (cond ((> x y) y)\n               ((< x y) x)))\n        ((even?\
    \ x) x)\n        ((even? y) y)\n        (else -1)))\n", "  (cond\n    [(and (even?\
    \ x) (even? y))\n     (if (> x y)\n       x\n       y)]\n    [(even? x)\n    \
    \ x]\n    [(even? y)\n     y]\n    [else\n     -1]))\n</code>\nMy code is working,\
    \ but I am quite sure that this is not the best solution. \nI am using a <code>cond</code>\
    \ statement and nested ifs, which is not very elegant. Do you know a better solution?\n\
    Regards, \nMartin\n\n\nA:\n\nAnother option is to make use of Racket's range procedures.\
    \  In particular you can use <code>range</code> and its cousins <code>range*</code>\
    \ and <code>range*-right</code>.  <code>range</code> returns a generator (which\
    \ is also a sequence), and <code>last</code> can be used to find the last element\
    \ in a sequence.  Thus:\n<code>(last (filter even? (range y x -1)))\n</code>\n\
    will find the last even number in the range <code>[x, y]</code>.  If there is\
    \ no such number, <code>#f</code> will be returned.  You could write:\n<code>(define\
    \ (choose-num x y)\n  (let ([result (last (filter even? (range y x -1)))])\n \
    \   (if result\n        result\n        -1)))\n</code>\n", "  (if (= x y)\n  \
    \    (if (even? x)\n          x\n          -1)\n      (if (even? y)\n        \
    \  (choose_num x (- y 1))\n          (choose_num x (- y 2)))))\n", "  (cond\n\
    \    [(< x y) (if (even? y) y (choose_num x (- y 1)))]\n    [(< y x) (if (even?\
    \ x) x (choose_num (- x 1) y))]\n    [(<= y x) (if (even? x) x -1)]))\n```\n\n\
    ```\n#lang racket\n", "  (if (> x y)\n      -1\n      (if (even? x)\n        \
    \  x\n          (choose_num (+ x 1) y))))\n", "    (if (and (even? x) (even? y))\n\
    \        (if (> x y)\n            (- x 2)\n            y)\n        (if (and (odd?\
    \ x) (odd? y))\n            (if (> x y)\n                (- x 1)\n           \
    \     y)\n            (if (and (even? x) (odd? y))\n                (if (> x y)\n\
    \                    (- x 2)\n                    (- y 1))\n                (if\
    \ (and (odd? x) (even? y))\n                    (if (> x y)\n                \
    \        (- x 1)\n                        y))))))\n", "  (if (and (even? x) (even?\
    \ y))\n      (if (<= x y)\n          x\n          y)\n      (if (and (even? x)\
    \ (not (even? y)))\n          x\n          (if (and (not (even? x)) (even? y))\n\
    \              y\n              -1))))\n", "    ;(if (&lt; x y)\n    ;(+ x 2)\n\
    \    ;(-1))\n    (if (&lt; x y)\n        (if (even? x)\n            x\n      \
    \      (choose_num (+ x 1) y))\n        (-1)))\n</code>\nThe code above doesn't\
    \ work properly. When I run the following test code:\n<code>#lang racket", " \
    \ (letrec ([helper (lambda (x y)\n                     (cond [(= x y) (if (even?\
    \ x) x -1)]\n                           [(even? x) (helper (+ x 1) y)]\n     \
    \                      [else (helper (+ x 1) y)]))])\n    (helper x y)))\n", " \
    \ (if (&gt; x y)\n      -1\n      (if (even? x)\n          x\n          (choose_num\
    \ (+ x 1) y))))\n", "  ;; START YOUR CODE HERE\n  (cond\n    [(= x y) (even x)]\n\
    \    [(even x)\n     (let ([k (choose_num (+ x 1) y)])\n       (if (= k -1)\n\
    \         x\n         (max x k)))]\n    [else\n     (choose_num (+ x 1) y)]))\n\
    \  ;; END YOUR CODE HERE\n</code>\n", "  (if (&gt; x y)\n      -1\n      (if (even?\
    \ y)\n          y\n          (choose_num x (- y 1)))))\n", "  (cond\n    [(= x\
    \ y) (if (even? x) x -1)]\n    [(> x y) -1]\n    [else\n     (let loop ([current\
    \ x])\n       (if (even? current) current\n           (loop (+ current 1))))]))\n",
  "  (cond\n    [(and (even? x) (even? y)) (if (&gt; x y) y x)]\n    [(even? x) x]\n\
    \    [(even? y) y]\n    [else -1]))\n</code>\n", "  ;; write your code here\n\
    \  )\n", "  (cond ((< x y) (and (even? y) y))\n        ((> x y) (and (even? x)\
    \ x))\n        ((= x y) (and (even? x) x))\n        (else (choose_num (add1 x)\
    \ (sub1 y)))))\n", "  (if (= x y)\n      (if (even? x)\n          x\n        \
    \  -1)\n      (choose_num x (- y 1))))\n</code>\nI try to run the test on Dr.\
    \ Racket and it gives me this error:\n<code>Application: choose_num\n   case 1:\
    \ [FAIL]  12 15 -&gt; 14\n   case 2: [FAIL]  13 15 -&gt; 14\n   case 3: [FAIL]\
    \  13 12 -&gt; -1\n</code>\nI'm not sure where I'm going wrong.\n\n\nA:\n\nThe\
    \ issue is with how you are checking the range.\nYou are currently checking that\
    \ <code>x</code> is equal to <code>y</code>, but you need to check that <code>x</code>\
    \ is less than or equal to <code>y</code>.\n<code>(if (&lt;= x y)\n    (if (even?\
    \ x)\n        x\n        -1)\n    (choose_num x (- y 1))))\n</code>\n", "  (if\
    \ (= (modulo y 2) 0) (if (< x y) y -1)\n      (if (< x y) (- y 1) -1)))\n", " \
    \ (if (= x y)\n      (- x 1)\n      (if (and (even? x) (even? y))\n          (max\
    \ x y)\n          (choose_num (add1 x) y))))\n```\n\n```scheme\n#lang racket\n",
  "  (cond ((> x y) -1)\n        ((odd? x) (choose_num (+ x 1) y))\n        (else\
    \ x)))\n```\n\n### [Exercise 5](./ex5.rkt)\n\n```#lang racket\n", "  (if (odd?\
    \ x) (choose_num (add1 x) y)\n      (if (odd? y) (choose_num x (sub1 y))\n   \
    \       (if (eq? x y) x\n              -1))))\n</code>\nI'm new to racket, so\
    \ I wanted to know if there's a more efficient or neater way to solve this problem.\
    \ I basically checked whether <code>x</code> and <code>y</code> were odd, and\
    \ if they were I decremented the larger number and increased the smaller one by\
    \ one. I did that until I found an even number.\n\n\nA:\n\nThere are many ways\
    \ to solve this, but a neat one is to take advantage of the different behavior\
    \ of the <code>even?</code> and <code>odd?</code> predicates when given an argument\
    \ that isn't an integer, and to use the signed remainder operator:\n<code>(define\
    \ (choose-num x y)\n  (cond ((even? x) (if (even? y) y (choose-num x (sub1 y))))\n\
    \        ((even? y) (choose-num (add1 x) y))\n        (else -1)))\n</code>\nYour\
    \ solution is not bad. It can be improved by implementing the three different\
    \ cases with a single <code>cond</code> expression, and also by using <code>sub1</code>\
    \ and <code>add1</code> correctly:\n<code>(define (choose-num x y)\n  (cond ((or\
    \ (even? x) (even? y)) (choose-num (add1 x) (sub1 y)))\n        ((= x y) x)\n\
    \        (else -1)))\n</code>\nI recommend using the functional style, where all\
    \ the variables are assigned once and never changed. Take a look at the first\
    \ solution, it's a better fit for functional programming.\n", "  (cond [(= x y)\
    \ (if (even? x) x -1)]\n        [(< x y) (choose_num x (+ y 1))]\n        [(>\
    \ x y) (choose_num (+ x 1) y)]))\n\n", "  (cond\n    [(and (even? x) (even? y))\n\
    \     (if (> x y)\n         x\n         y)]\n    [(even? x) x]\n    [(even? y)\
    \ y]\n    [else -1]))\n```\n\n```#lang racket\n", "  (if (and (even? x) (even?\
    \ y))\n      (if (> x y)\n          (if (even? (- x 2)) (- x 2) (- x 3))\n   \
    \       x)\n      (if (even? (- x 1)) (- x 1) -1)))\n", "  (if (or (<= y x) (=\
    \ (remainder x 2) 1)) -1\n      (choose_num (sub1 x) y)))\n", "  (if (or (odd?\
    \ x) (odd? y))\n      (if (odd? x)\n          (begin (set! x (+ x 1))\n      \
    \           (choose_num x y))\n          (begin (set! y (- y 1))\n           \
    \      (choose_num x y)))\n      (if (&gt; x y)\n          -1\n          x)))\n\
    </code>\nHowever, I'm receiving the following error: \n<code>set!: function not\
    \ defined in: (set! x (+ x 1))\n</code>\nThe goal of this question is to show\
    \ how to solve this problem recursively, and not functionally.\nWhat is the reason\
    \ of this error, and how can I fix it?\n\n\nA:\n\nThe reason you're getting this\
    \ error is that <code>set!</code> is a special form, not a function. It is not\
    \ a member of the Racket language, but a specific extension of the R5RS language\
    \ that Racket supports. R5RS is a set of mutually-agreed upon standards, and the\
    \ Racket implementation of R5RS (in the <code>r5rs</code> package) does not include\
    \ set!.\nIf you really want to solve the problem in a way that R5RS would recognize,\
    \ here's the solution:\n<code>;;; This procedure takes two positive numbers x\
    \ and y and returns the", "  (if (= x y)\n      (if (even? x)\n          x\n \
    \         -1)\n      (if (even? x)\n          (if (even? y)\n              (max\
    \ x y)\n              (if (even? (- y 1))\n                  y\n             \
    \     (if (even? (- y 2))\n                      (- y 2)\n                   \
    \   -1)))\n          (if (even? y)\n              (if (even? (+ x 1))\n      \
    \            x\n                  (if (even? (+ x 2))\n                      (+\
    \ x 2)\n                      -1))\n              (if (even? (+ x 1))\n      \
    \            x\n                  (if (even? (+ y 1))\n                      y\n\
    \                      -1))))))\n", "  (cond ((= x y) x)\n        ((even? x)\n\
    \         (cond ((even? y)\n                (if (> x y) x y))\n              \
    \ ((even? (- y 1))\n                (- y 1))\n               (else -1)))\n   \
    \     ((even? (- x 1))\n         (cond ((even? y)\n                (if (> (- x\
    \ 1) y) y (- x 1)))\n               ((even? (- y 1))\n                (- y 1))\n\
    \               (else -1)))\n        (else\n         (cond ((even? y)\n      \
    \          y)\n               ((even? (- y 1))\n                (- y 1))\n   \
    \            (else -1)))))\n", "  (cond ((and (= (modulo y 2) 0) (<= x y)) y)\n\
    \        ((and (<= x y) (= (modulo y 2) 1)) (- y 1))\n        ((< x y) (choose_num\
    \ x (- y 1)))))\n", "  (cond\n    [(< x 0) (-1)]\n    [(< y 0) (-1)]\n    [(=\
    \ y x) x]\n    [(< x y) (choose_num (if (= (remainder y 2) 0) y (-1)) (- y 1))]\n\
    \    [(> x y) (choose_num (if (= (remainder x 2) 0) x (-1)) (+ x 1))]))\n```\n\
    \n```#lang racket\n", "  (if (and (even? x) (even? y))\n      (if (&gt; x y)\n\
    \          (if (even? y) y -1)\n          (if (even? x) x -1))\n      (if (even?\
    \ x)\n          (if (even? y)\n              (if (&gt; x y) x y)\n           \
    \   x)\n          (if (even? y) y -1))))\n</code>\nHere's what I have so far.\
    \ It doesn't handle the case where the input is out of order (which is fine) and\
    \ I just want to know if there is a more elegant way to do it.\nAlso, is it possible\
    \ to write this function as a one-liner?\n\n\nA:\n\nIt's not possible to write\
    \ it as a one-liner without using a lot of parenthesis, but it could be written\
    \ in a few lines. Also, you can use <code>and</code> to check if two values are\
    \ true, and <code>or</code> to check if one of them is true.\n<code>(define (choose-num\
    \ x y)\n  (cond [(and (even? x) (even? y)) (max x y)]\n        [(even? x) x]\n\
    \        [(even? y) y]\n        [else -1]))\n</code>\n", "    (cond ((&gt; x y)\
    \ -1)\n          ((= (remainder x 2) 0)\n           (cond ((&gt; y x) x)\n   \
    \              ((&gt; y x) (choose_num (+ x 2) y))))\n          ((&gt; y x) (choose_num\
    \ (+ x 1) y))\n          ((&gt; y x) (choose_num (+ x 2) y))))\n", "  (if (= x\
    \ y)\n      (if (even? x)\n          x\n          -1)\n      (if (even? x)\n \
    \         (if (even? y)\n              (if (> x y)\n                  x\n    \
    \              y)\n              x)\n          (if (even? y)\n              y\n\
    \              -1))))\n</code>\nI think I'm getting the correct answer, but I'm\
    \ not sure if this is the best way to do it.\nI first check if <code>x</code>\
    \ and <code>y</code> are the same and return the biggest even number or -1.\n\
    Then, I check if <code>x</code> and <code>y</code> are different, and that <code>x</code>\
    \ is even, but <code>y</code> is not. If it is, I return <code>x</code>. Otherwise,\
    \ I check if <code>y</code> is even, but <code>x</code> is not. If <code>y</code>\
    \ is even, I return <code>y</code>. Otherwise, I return -1 because there is no\
    \ even number.\nIs this the best way to do it, or is there a better way?\n\n\n\
    A:\n\nThere are probably better ways, but here is one way that is similar to yours.\
    \  Note that I changed the name of the function because <code>choose_num</code>\
    \ is not a good name, and I changed the order of arguments to make it easier to\
    \ use.\n<code>(define (even-number-in-range start end)\n  (if (&lt; start end)\n\
    \      (even-number-in-range-help start (+ start 1) end)\n      -1))\n", "   \
    \ (cond ((= (modulo y 2) 0) y)\n          ((= (modulo x 2) 0) x)\n          (else\
    \ (choose_num (- x 1) (- y 1)))))\n", "  (if (&gt; x y)\n      -1\n      (if (even?\
    \ x)\n          x\n          (choose_num (+ x 1) y))))\n", "  (define (is-even?\
    \ x)\n    (if (= (remainder x 2) 0)\n        #t\n        #f))\n  (define (find_num\
    \ x y)\n    (if (and (is-even? x) (<= x y))\n        x\n        (find_num (- x\
    \ 1) y)))\n  (cond [(< x y) (find_num y x)]\n        [(= x y) (if (is-even? x)\
    \ x -1)]\n        [(> x y) -1]))\n", "  (if (= x y)\n      (if (even? x)\n   \
    \       x\n          -1)\n      (if (even? x)\n          (if (even? y)\n     \
    \         (if (> x y)\n                  y\n                  x)\n           \
    \   (choose_num x (- y 1)))\n          (choose_num (+ x 1) y))))\n", "  (cond\n\
    \    [(>= x y) -1]\n    [(even? x) x]\n    [else (choose_num (+ x 1) y)]))\n",
  "  (cond\n    [(not (integer? x)) -1]\n    [(not (integer? y)) -1]\n    [(= x 0)\
    \ -1]\n    [(= y 0) -1]\n    [(not (< x y)) -1]\n    [(= x y)\n     (if (even?\
    \ x) x -1)]\n    [(even? x) x]\n    [(not (even? x))\n     (choose_num (+ x 1)\
    \ y)]))\n\n", "  (if (even? x) (if (even? y) (if (> x y) -1 x) (if (> y x) -1\
    \ y))\n    (if (even? y) y -1)))\n", "  (if (= x y)\n      (if (even? x)\n   \
    \       x\n          -1)\n      (choose_num (add1 x) y)))\n", "  ;; TODO\n\n \
    \ )\n</code>\nI know that I am trying to find the largest even number in a given\
    \ range, so I can use max and even?. However, I am not sure how to combine these\
    \ two operations.\nI tried the following, but it gave me an error:\n<code>(define\
    \ (choose_num x y)\n  (if (and (&gt; x 0) (&gt; y 0))\n      (max x y))\n  (if\
    \ (even? max)\n      (max)\n      (-1))\n  )\n</code>\nDoes anyone have any suggestions\
    \ for this? Any help would be appreciated.\n\n\nA:\n\n<code>(define (choose_num\
    \ x y)\n  (if (or (not (even? x)) (not (even? y)))\n      -1\n      (max x y)))\n\
    </code>\nor (note the use of <code>let</code> instead of <code>if</code> because\
    \ it's more concise and expressive)\n<code>(define (choose_num x y)\n  (let ([max-even\
    \ (max x y)])\n    (if (even? max-even)\n        max-even\n        -1)))\n</code>\n",
  "  (if (= x y)\n      (if (even? x)\n          x\n          -1)\n      (if (and\
    \ (= x (+ y 1)) (not (even? x)))\n          -1\n          (choose_num x (- y 1)))))\n\
    </code>\nBut I get the following error when trying to run it:\n<code>application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: -1\n  arguments...:\n   3\n</code>\nWhat am I doing wrong? \n\n\nA:\n\
    \nYou're using <code>if</code> with only one branch, while it expects three. You\
    \ could fix it by adding the missing branches, like this:\n<code>(define (choose_num\
    \ x y)\n  (if (= x y)\n      (if (even? x)\n          x\n          -1)\n     \
    \ (if (and (= x (+ y 1)) (not (even? x)))\n          -1\n          (choose_num\
    \ x (- y 1)))))\n</code>\nBut a much simpler solution would be to use <code>cond</code>\
    \ instead:\n<code>(define (choose_num x y)\n  (cond ((= x y)\n         (if (even?\
    \ x)\n             x\n             -1))\n        ((and (= x (+ y 1)) (not (even?\
    \ x)))\n         -1)\n        (else\n         (choose_num x (- y 1)))))\n</code>\n",
  "  (if (and (even? x) (even? y))\n      (if (> x y)\n          y\n          x)\n\
    \      (if (and (odd? x) (odd? y))\n          (if (> x y)\n              x\n \
    \             y)\n          (if (odd? x)\n              (if (even? y)\n      \
    \            y\n                  -1)\n              (if (even? x)\n         \
    \         x\n                  -1)))))\n</code>\nI am not getting why <code>choose_num(13,12)</code>\
    \ is returning <code>-1</code> instead of <code>12</code>. \n\n\nA:\n\nYou forgot\
    \ to check the case where <code>x</code> and <code>y</code> are the same number.\n\
    For <code>x = 13</code> and <code>y = 12</code> or <code>x = 12</code> and <code>y\
    \ = 13</code>, neither of the two conditions in the top-level <code>if</code>\
    \ are satisfied. So the program enters the second branch, which returns <code>-1</code>.\n\
    Here's an alternative implementation:\n<code>(define (choose-num x y)\n  (cond\n\
    \    [(= x y) (if (even? x) x -1)]\n    [(&gt; x y) (choose-num y x)]\n    [(even?\
    \ x) x]\n    [(even? y) y]\n    [else -1]))\n</code>\n", "  (if (&gt;= x y) -1\n\
    \      (choose_num x (even? (+ 1 y)))))\n", "  (letrec ((biggest-even-in-range\
    \ (lambda (x y)\n                                    (cond\n                 \
    \                     ((even? x) x)\n                                      ((even?\
    \ y) y)\n                                      (else (biggest-even-in-range (+\
    \ x 1) (- y 1)))))))\n           (if (<= x y)\n               (biggest-even-in-range\
    \ x y)\n               -1)))\n```", "  (define (helper x y num)\n    (cond\n \
    \     [(> x y) (if (even? num) num -1)]\n      [(even? x) (helper (+ x 1) y x)]\n\
    \      [else (helper (+ x 1) y num)]))\n  (helper x y 0))\n", "  (cond [(even?\
    \ y) y]\n        [(even? x) x]\n        [else -1]))\n", "  (define (numlist z\
    \ z2)\n    (if (&gt; z z2) (list)\n        (cons z (numlist (+ z 1) z2))))\n \
    \ (define (filteredlist z z2)\n    (filter even? (numlist z z2)))\n  (if (empty?\
    \ (filteredlist x y)) -1\n      (apply max (filteredlist x y))))\n</code>\nI know\
    \ it's a dumb way to do it, but I'm trying to learn the language.\nBasically,\
    \ what I'm trying to do is to first get a list of all numbers between x and y.\
    \ \nThen, create a new list with only the even numbers using filter. \nThen check\
    \ whether the list is empty or not. If it's empty, then it's -1. Otherwise, apply\
    \ max on the filtered list. \nNow, when I do this in DrRacket, I got this error:\n\
    <code>new-procedure-for-compiled-closure: expected number of required arguments\
    \ to be 0 but got 1.\n</code>\nAnd I'm not sure what's wrong.\nSo is there a better\
    \ way to achieve what I'm trying to do or is there an error in my code?\n\n\n\
    A:\n\nYou are not using the <code>apply</code> function properly, the first argument\
    \ is a procedure, not a result of a procedure call. You want:\n<code>(apply max\
    \ (filteredlist x y))\n</code>\nBut you don't need <code>apply</code> at all:\n\
    <code>(define (choose_num x y)\n  (define (numlist z z2)\n    (if (&gt; z z2)\
    \ (list)\n        (cons z (numlist (+ z 1) z2))))\n  (define (filteredlist z z2)\n\
    \    (filter even? (numlist z z2)))\n  (if (empty? (filteredlist x y)) -1\n  \
    \    (max (filteredlist x y))))\n</code>\nWhich is equivalent to:\n<code>(define\
    \ (choose_num x y)\n  (define (numlist z z2)\n    (if (&gt; z z2) (list)\n   \
    \     (cons z (numlist (+ z 1) z", "  (if (= x y)\n      (if (even? x)\n     \
    \     x\n          -1)\n      (if (even? y)\n          (choose_num x (- y 1))\n\
    \          (choose_num x (- y 2)))))\n\n", "  (cond\n    [(= x y) (if (even? x)\
    \ x -1)]\n    [(&gt; x y) -1]\n    [else\n     (let ([n (choose_num (+ x 1) y)])\n\
    \       (if (even? x) (max x n) n))]))\n</code>\nExercise 2:\n<code>#lang racket\n",
  "  (cond\n    [(> x y) -1]\n    [(not(even? x))\n     (choose_num (+ x 1) y)]\n\
    \    [else x]))\n", "  (cond [(= x y) x]\n        [(even? x) (choose_num (+ x\
    \ 2) y)]\n        [(even? y) (choose_num x (- y 2))]\n        [else -1]))", " \
    \ (cond\n    [(= x y) (if (even? x) x -1)]\n    [(> x y) -1]\n    [else (max (choose_num\
    \ (+ x 1) y) (if (even? x) x -1))]))\n", "  (if (>= x y)\n      -1\n      (if\
    \ (even? x)\n          x\n          (choose_num (+ x 1) y))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond ((= x y) (if (even? x) x -1))\n        ((even? y) y)\n\
    \        (else (choose_num x (- y 1)))))\n</code>\nI believe I understand this\
    \ problem, but I get an error for the first condition, so it seems that I'm not\
    \ understanding it as well as I thought.\nThe error is \"expects 2 arguments,\
    \ but got 1\". I'm assuming this means that the function requires 2 arguments\
    \ and that it thinks I'm only giving it one, but I don't understand what I'm doing\
    \ wrong. \nI've tried\n<code>(choose_num x y)", "  (if (or (< x 1) (< y 1)) -1\n\
    \    (if (or (not (even? x)) (not (even? y))) (choose_num (+ x 1) y)\n      (if\
    \ (> x y) -1 x))))\n", "  (if (odd? x)\n      (if (= x y)\n          -1\n    \
    \      (choose_num (+ x 1) y))\n      (if (= x y)\n          x\n          (if\
    \ (even? y)\n              (choose_num x (- y 1))\n              (choose_num x\
    \ (- y 2))))))\n", "  (cond\n    [(= x y) x]\n    [(< x y) (choose_num (+ x 1)\
    \ y)]\n    [(> x y) (choose_num (- x 1) y)]))\n", "  (cond\n    [(odd? x) (- x\
    \ 1)]\n    [(even? x) x]\n    [else -1]))\n", "  (if (&gt; x y) -1\n      (if\
    \ (even? x) x\n          (choose_num (+ x 1) y))))\n</code>\nThe code seems to\
    \ work fine. However, when I try to test it with Test-Driven Development, I got\
    \ this error:\n<code>-------------------------------------------------------\n\
    \         choose_num\n         expected: (listof Integer)\n         but got: '-1\n\
    -------------------------------------------------------\n</code>\nWhy is that?\n\
    The code for the test-cases are as follows:\n<code>#lang racket\n", "  (if (>\
    \ x y) -1\n      (if (even? y) y\n          (choose_num x (- y 1)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
