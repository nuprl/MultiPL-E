name: HumanEval_71_triangle_area
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ the area of\n;; the triangle rounded to 2 decimal points if the three sides form\
  \ a valid triangle. \n;; Otherwise return -1\n;; Three sides make a valid triangle\
  \ when the sum of any two sides is greater \n;; than the third side.\n;; Example:\n\
  ;; triangle_area(3, 4, 5) == 6.00\n;; triangle_area(1, 2, 10) == -1\n(define (triangle_area\
  \ a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n\
  \    (check-equal? (candidate 3 4 5) 6.0)\n    (check-equal? (candidate 1 2 10)\
  \ -1)\n    (check-equal? (candidate 4 8 5) 8.18)\n    (check-equal? (candidate 2\
  \ 2 2) 1.73)\n    (check-equal? (candidate 1 2 3) -1)\n    (check-equal? (candidate\
  \ 10 5 7) 16.25)\n    (check-equal? (candidate 2 6 3) -1)\n    (check-equal? (candidate\
  \ 1 1 1) 0.43)\n    (check-equal? (candidate 2 2 10) -1)\n))\n\n(test-humaneval)"
completions: ["  (cond ((and (>= a 0) (>= b 0) (>= c 0))\n         (+ (* (/ a 2) b\
    \ c) (* (/ b 2) a c) (* (/ c 2) a b)))\n        (else -1)))\n", "  (cond\n   \
    \ [(and (> a 0) (> b 0) (> c 0)) (* (/ (sqrt (+ (* (- a (/ b 2)) (- a (/ b 2)))\
    \ (* (- b (/ a 2)) (- b (/ a 2))))) 2) a b)]\n    [else -1]))", "  (cond ((and\
    \ (< a b c) (< b c a) (< c a b))\n         (round (* 0.5 (+ (- a b) (- b c) (-\
    \ c a))) 2))\n        (else -1)))\n```\n\n## [7kyu] Keep Hydrated! ##\n\n```racket\n\
    #lang racket\n", "  (let ((lst (list a b c)))\n    (let ((smallest-side (apply\
    \ min lst))\n          (greatest-side (apply max lst)))\n      (let ((sum 0))\n\
    \        (for ((item lst))\n          (when (not (= item smallest-side))\n   \
    \         (when (not (= item greatest-side))\n              (set! sum (+ sum item)))))\n\
    \        (when (>= sum greatest-side)\n          (define (sides a b c)\n     \
    \       (/ (+ a b c) 2))\n          (define (area s a b c)\n            (sqrt\
    \ (* s (- s a) (- s b) (- s c))))\n          (define (safe-round x)\n        \
    \    (round (* x 100)))\n          (define (unsafe-round x)\n            (/ (round\
    \ (* x 100)) 100.0))\n          (safe-round (area (sides a b c) a b c)))))))\n\
    </code>\nPlease note that this is a coderbyte problem, and the other constraints\
    \ include:\n\nAll inputs are positive integers between 1 and 1000\nDon't include\
    \ sqrt in the count\n\nI tried to use <code>unsafe-round</code> and <code>safe-round</code>\
    \ instead of <code>round</code> to distinguish rounding that took the sqrt into\
    \ account from rounding that did not, but I wasn't sure if this was necessary.\n",
  "  (cond [(and (&gt; (+ a b) c)\n              (&gt; (+ a c) b)\n              (&gt;\
    \ (+ b c) a))\n         (round (* (/ (expt a 2) 4) (sqrt (+ (expt b 2) (expt c\
    \ 2)))))\n         (format \"~a.~a\" (round (* (/ (expt a 2) 4) (sqrt (+ (expt\
    \ b 2) (expt c 2))))) 2)]\n        [else -1]))\n</code>\nMy question is about\
    \ the use of <code>format</code> here. According to the documentation, <code>format</code>\
    \ \"produces a formatted string by applying the format string to each format-item\"\
    . So I guess it should be used in a construct like this:\n<code>(format \"~a ~a\"\
    \ \"Hello\" \"World\")\n</code>\nHowever, in the solution, there are two format\
    \ items, but only one argument provided. Why does it work?\n\n\nA:\n\nThe format\
    \ string is a string with the format items embedded. So in <code>(format \"~a\
    \ ~a\" \"Hello\" \"World\")</code>, the format string is <code>\"~a ~a\"</code>,\
    \ and the first argument is <code>\"Hello\"</code> and the second is <code>\"\
    World\"</code>.\nWhen you have a format string like <code>\"~a.~a\"</code>, the\
    \ <code>~a</code> is a format item, and the <code>.</code> is just regular string.\n\
    So <code>(format \"~a.~a\" (round (* (/ (expt a 2) 4) (sqrt (+ (expt b 2) (expt\
    \ c 2))))) 2)</code> means <code>format</code> will take the first argument and\
    \ put it where the first <code>~a</code> is, and it will ignore the last argument.\
    \ You can add as many arguments as you want and <code>format</code> will ignore\
    \ them.\nThe <code>2</code> at the end is not an argument to <code>format</code>.\
    \ It's the argument to <code>round</code>. <code>round</code> has the following\
    \ syntax:\n<code>(round number [pre", "  (define (triangle-p a b c)\n    (and\
    \ (> (+ a b) c)\n         (> (+ a c) b)\n         (> (+ b c) a)))\n  (define (area\
    \ a b c)\n    (* 1/2 (sqrt (+ (* (- a (/ b 2)) (- a (/ b 2)))\n              \
    \     (* (- b (/ a 2)) (- b (/ a 2)))))))\n  (define (fix n) (* 100 n))\n  (define\
    \ (round n) (/ (round (* 100 n)) 100))\n  (if (triangle-p a b c)\n      (round\
    \ (area a b c))\n      -1))\n", "  (cond\n    [(or (= a 0) (= b 0) (= c 0)) -1]\n\
    \    [(or (< a 0) (< b 0) (< c 0)) -1]\n    [(< a (+ b c)) -1]\n    [(< b (+ a\
    \ c)) -1]\n    [(< c (+ a b)) -1]\n    [else (/ (* a b) 2.0)]))\n", "  (if (and\
    \ (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n      (round (* 0.5 (* a (- b c)))\
    \ 2)\n      -1))\n", "  (cond ((and (>= (+ a b) c)\n              (>= (+ a c)\
    \ b)\n              (>= (+ b c) a))\n         (define (s x y z)\n           (/\
    \ (+ x y z) 2))\n         (define (area-triangle a b c)\n           (sqrt (- (*\
    \ (s a b c)\n                       (- (s a b c) a)\n                       (-\
    \ (s a b c) b)\n                       (- (s a b c) c)))))\n         (define (round-to-2-dec\
    \ x)\n           (* (/ (round (* x 100)) 100.0) 100))\n         (round-to-2-dec\
    \ (area-triangle a b c)))\n        (else -1)))\n", "  (let* ([s (/ (+ a b c) 2.0)]\n\
    \         [area (sqrt (* s (- s a) (- s b) (- s c)))])\n    (if (and (number?\
    \ area)\n             (&gt; area 0))\n        (round area 2)\n        -1)))\n",
  "  (cond [(or (< (+ a b) c) (< (+ a c) b) (< (+ b c) a)) -1]\n        [else (round\
    \ (* (sqrt (- (* (+ a b c) (* (+ a b c)) (* (- a (* b b)) (* (- a (* c c)) (*\
    \ (- b (* c c)))))) 0.5)) 100)]))\n", "  (define (is-triangle? a b c)\n    (let\
    \ ([tri-sum (+ a b c)])\n      (and (&gt; a 0)\n           (&gt; b 0)\n      \
    \     (&gt; c 0)\n           (&gt; tri-sum (- a))\n           (&gt; tri-sum (-\
    \ b))\n           (&gt; tri-sum (- c)))))\n  (cond ((is-triangle? a b c)\n   \
    \      (sqrt (* (- a) (- b) (- c) (* 4 (sqrt 3)))))\n        (else -1)))\n", " \
    \ (if (and (&gt; (+ a b) c)\n           (&gt; (+ a c) b)\n           (&gt; (+\
    \ b c) a))\n      (round (* 0.5 (* (+ (- a) (- b) (- c))\n                   \
    \    (- (+ a b) c)\n                       (- (+ a c) b)\n                   \
    \    (- (+ b c) a)))\n             2)\n      -1))\n</code>\n", "  (if (and (<\
    \ a (+ b c))\n           (< b (+ a c))\n           (< c (+ a b)))\n      (define\
    \ (s)\n        (/ (+ a b c) 2))\n      (define (area)\n        (sqrt (* (s) (-\
    \ (s) a) (- (s) b) (- (s) c))))\n      (define (round n)\n        (round n 2))\n\
    \      (round (area)))\n  -1)\n\n```\n### Spoiler Alert!\n\n[![print solution](/images/printsolution.png)](https://github.com/Coderdotnew/intro_to_ruby_exercises_language_basics/blob/master/solution_files/print_solution.rb)\n\
    \nClick the link above to view the file containing the solution.\n\n## How do\
    \ you run a Ruby file from the Command Line?\nTo run a Ruby file from the command\
    \ line you could type the below into your command-line tool of choice.\n```shell\n\
    ruby file_name.rb\n```\n\n## How do you run an RSpec file from the Command Line?\n\
    To run an RSpec file from the command line you could type the below into your\
    \ command-line tool of choice.\n```shell\nrspec spec_file.rb\n```\n***\nAll content\
    \ is under a creative commons licence [Attribution-NonCommercial-ShareAlike 4.0\
    \ International (CC BY-NC-SA 4.0)](https://creativecommons.org/licenses/by-nc-sa/4.0/)\
    \ 2018\n\nThis exercise was created by [Coderdotnew](https://coderdotnew.github.io/).",
  "  (cond [(< (+ a b) c) -1]\n        [(< (+ a c) b) -1]\n        [(< (+ b c) a)\
    \ -1]\n        [else (/ (* a b c) 4)])\n  )\n", "  (if (and (< (+ a b) c) (< (+\
    \ a c) b) (< (+ b c) a))\n      (display -1)\n      (display (* 1/2 (* a b)))))\n\
    \  ", "  (if (and (>= (+ a b) c)\n           (>= (+ a c) b)\n           (>= (+\
    \ b c) a))\n      (round (* (- (+ a b) c) (- (+ a c) b) (- (+ b c) a) 0.5) 2)\n\
    \      -1))\n", "  (if (&gt; (+ a b) c)\n      (-&gt;double (sqrt (* (- a (/ c\
    \ 2))\n                         (- a (/ c 2))\n                         (- b (/\
    \ c 2))\n                         (- b (/ c 2))\n                         (- c\
    \ (/ a 2))\n                         (- c (/ a 2)))))\n      -1))\n", "  (if (&gt;\
    \ (+ a b) c)\n      (round (* (sqrt (+ (* (- a (/ c 2)) (- a (/ c 2))) (* (- b\
    \ (/ c 2)) (- b (/ c 2))))) c) 2)\n      -1))\n", "  (if (and (< a (+ b c)) (<\
    \ b (+ a c)) (< c (+ a b)))\n      (round (* 0.5 (- (+ a b c) a) (- (+ a b c)\
    \ b) (- (+ a b c) c)) 2)\n      -1))\n```\n\n``` #lang racket", "  (match (list\
    \ a b c)\n    [(list x y z)\n     (cond\n       [(and (< x 0) (< y 0) (< z 0))\
    \ -1]\n       [(and (> (+ x y) z) (> (+ y z) x) (> (+ x z) y))\n        (define\
    \ (area)\n          (/ (* (sqrt (+ (* (* (- x (/ y 2)) (- x (/ y 2))) (* (* (-\
    \ y (/ x 2)) (- y (/ x 2))) (* (* (- z (/ x 2)) (- z (/ x 2))) (* (* (- z (/ y\
    \ 2)) (- z (/ y 2)))\n               (* (+ (* x x) (* y y) (* z z))\n        \
    \          (* (- x (/ y 2)) (- x (/ y 2)))\n                  (* (- y (/ x 2))\
    \ (- y (/ x 2)))\n                  (* (- z (/ x 2)) (- z (/ x 2)))\n        \
    \          (* (- z (/ y 2)) (- z (/ y 2)))))))))) 2)\n      (round area 2)]\n\
    \       [else -1])))\n", "  (define (is_valid a b c)\n    (and (>= a 1) (>= b\
    \ 1) (>= c 1)\n         (> (+ a b) c)\n         (> (+ a c) b)\n         (> (+\
    \ b c) a)))\n  (cond\n    [(is_valid a b c) (* (sqrt (* (- (* a a) (- (* b b)\
    \ (* c c))) (* 2) (- (* b b) (* c c)))) .5)]\n    [else -1]))", "  (cond\n   \
    \ [(< (+ a b) c) -1]\n    [(< (+ a c) b) -1]\n    [(< (+ b c) a) -1]\n    [else\
    \ (round (* (sqrt (- (* a a) (- (* b b) (* c c)))) (/ a 2.0)) 2)]))", "  (define\
    \ (isValid)\n    (and (> (+ a b) c)\n         (> (+ a c) b)\n         (> (+ b\
    \ c) a)))\n  (define (area)\n    (sqrt (* (- (+ a b c) (/ (+ a b c) 2))\n    \
    \        (- (+ a b c) (/ (+ a b c) 2))\n            (- (+ a b c) (/ (+ a b c)\
    \ 2)))))\n  (if (isValid)\n      (round (* (area) 100) #:places 0)\n      -1))\n\
    ```\n\n## Problem 3\n\n### Problem Statement\n\n``` #lang racket", "  (cond [(and\
    \ (<= a (+ b c)) (<= b (+ a c)) (<= c (+ a b))) (round (/ (sqrt (* (+ (* (- a\
    \ b) (- a b)) (* (- b c) (- b c))) (- (* a a) (* c c)))) 2))] [else -1]))\n",
  "  (if (and\n       (<= a 0)\n       (<= b 0)\n       (<= c 0)\n       (<= (+ a\
    \ b) c)\n       (<= (+ a c) b)\n       (<= (+ b c) a))\n      -1\n      (round\
    \ (* 0.5 (abs (- (* a c) (* b c) (* a b) (* a b) (* a b)))) 2)))\n", "  (define\
    \ (valid-triangle)\n    (cond\n      [(>= (+ a b) c) 1]\n      [(>= (+ a c) b)\
    \ 1]\n      [(>= (+ b c) a) 1]\n      [else 0]))\n  (cond\n    [(valid-triangle)\n\
    \     (define p (/ (+ a b c) 2))\n     (sqrt (* p (- p a) (- p b) (- p c)))]\n\
    \    [else -1]))\n", "  (if (&gt; (+ a b) c) \n      (begin \n        (printf\
    \ \"~n ~n The area of the triangle is: ~a\" \n                (/ (* (- a b c)\
    \ (truncate(sqrt (+ (* (- a b c) (- a b c)) \n                               \
    \                  (* (* 4 a a) (* 4 b b)))))) 2))\n        (/ (* (- a b c) (truncate(sqrt\
    \ (+ (* (- a b c) (- a b c)) \n                                          (* (*\
    \ 4 a a) (* 4 b b)))))) 2))\n      (begin \n        (printf \"~n ~n The three\
    \ sides do not form a valid triangle.\"))))\n", "  (if (and (> (+ a b) c) (> (+\
    \ a c) b) (> (+ b c) a))\n      (format \"~a\" (exact->inexact (/ (* a b) 2)))\n\
    \      -1))\n", "  (let ([s (/ (+ a b c) 2)])\n    (cond [(and (> a 0) (> b 0)\
    \ (> c 0))\n           (round (* s (- s a) (- s b) (- s c)) 2)]\n          [else\
    \ -1])))\n", "  (define (isValid a b c)\n    (< (+ a b) c))\n  (cond\n    [(isValid\
    \ a b c) -1]\n    [else (round (* .5 (* (- a b c) (+ a b c))))]))\n", "  (if (and\
    \ (&gt; (+ a b) c)\n           (&gt; (+ a c) b)\n           (&gt; (+ b c) a))\n\
    \      (round (* (/ 1 2.0) a b))\n      -1))\n</code>\nWhat's the most elegant\
    \ way to handle this?\n\n\nA:\n\nThere's nothing wrong with using <code>if</code>\
    \ as you did, but if you want to use <code>cond</code> it should be like this:\n\
    <code>(define (triangle_area a b c)\n  (cond\n    [(and (&gt; (+ a b) c)\n   \
    \       (&gt; (+ a c) b)\n          (&gt; (+ b c) a))\n     (round (* (/ 1 2.0)\
    \ a b))]\n    [else -1]))\n</code>\nThis can be simplified to:\n<code>(define\
    \ (triangle_area a b c)\n  (cond\n    [(and (&gt; (+ a b) c)\n          (&gt;\
    \ (+ a c) b)\n          (&gt; (+ b c) a))\n     (round (* (/ 1 2.0) a b))]\n \
    \   [else -1]))\n</code>\n", "  (cond ((or (< a 0) (< b 0) (< c 0)) -1)\n    \
    \    ((or (< a (+ b c)) (< b (+ a c)) (< c (+ a b))) -1)\n        (else (round\
    \ (* 0.5 (* a b c)) 2))))\n```\n## Solutions\n```racket", "  (cond\n    [(and\
    \ (>= a 0) (>= b 0) (>= c 0))\n     (define s (/ (+ a b c) 2))\n     (sqrt (*\
    \ s (- s a) (- s b) (- s c)))]\n    [else -1]))\n", "  (cond\n    [(< (+ a b)\
    \ c) -1]\n    [(< (+ a c) b) -1]\n    [(< (+ b c) a) -1]\n    [else (round (*\
    \ 0.5 (- (+ a b c) (* (sqrt a) (sqrt b) (sqrt c)))) 2)]))\n", "  (if (&gt; (+\
    \ a b) c)\n      (round (* 0.5 (* a (sqrt (- (* b b) (* (* a c) (* a c)))))))\n\
    \      -1))\n</code>\nEDIT:\nI just found this on the Rosetta Code wiki, if you\
    \ would like to check out another algorithm.\n", "  (define (area a b c)\n   \
    \ (/ (* (sqrt (+ (* (- a b) (- a b)) (* (- b c) (- b c)) (* (- a c) (- a c))))\
    \ a) 2))\n  (cond ((and (> a 0) (> b 0) (> c 0)) (area a b c))\n        (else\
    \ -1)))\n", "  (cond\n    [(< ( + a b) c)  -1]\n    [(< ( + a c) b)  -1]\n   \
    \ [(< ( + b c) a)  -1]\n    [else (/ (* a b) 2) ]\n    )\n  )\n", "  (define (calc-area\
    \ a b c)\n    (/ (* a b) 2))\n  (cond ((and (>= a 0) (>= b 0) (>= c 0))\n    \
    \     (cond ((and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n               \
    \ (display (calc-area a b c)))\n               (else -1)))\n        (else -1)))",
  "  (cond [(or (&lt; a 1) (&lt; b 1) (&lt; c 1)) -1]\n        [(or (&lt;= (+ a b)\
    \ c) (&lt;= (+ a c) b) (&lt;= (+ b c) a)) -1]\n        [else (define p (/ (+ a\
    \ b c) 2))\n               (define triangle (* p (- p a) (- p b) (- p c)))\n \
    \              (define area (sqrt triangle))\n               (round (* area 100.0)\
    \ 2)]))\n</code>\n", "  (cond [(and (<= a b) (<= b c)) (+ a b c)]\n        [(and\
    \ (<= b a) (<= a c)) (+ a b c)]\n        [(and (<= c a) (<= a b)) (+ a b c)]\n\
    \        [else -1]))\n", "  (define (sorter lst)\n    (sort lst <))\n  (define\
    \ (two-side-is-bigger x y z)\n    (and (< x (+ y z))\n         (< y (+ x z))\n\
    \         (< z (+ x y))))\n  (cond\n    [(and (zero? a) (zero? b) (zero? c)) 0]\n\
    \    [(zero? a) -1]\n    [(zero? b) -1]\n    [(zero? c) -1]\n    [(two-side-is-bigger\
    \ a b c)\n     (define (calculate a b c)\n       (define s (/ (+ a b c) 2))\n\
    \       (define area (sqrt (* s (- s a) (- s b) (- s c))))\n       (round (* area\
    \ 100))\n       (/ (round (* area 100)) 100))\n     (calculate a b c)]\n    [else\
    \ -1]))", "  (define p (/ (+ a b c) 2))\n  (define semi-perimeter p)\n  (define\
    \ area (sqrt (* p (- p a) (- p b) (- p c))))\n  (define (print_area)\n    (displayln\
    \ (format \"~.2f\" area)))\n  (define (is-triangle?)\n    (and (> a 0) (> b 0)\
    \ (> c 0)\n         (> (+ a b) c)\n         (> (+ a c) b)\n         (> (+ b c)\
    \ a)))\n  (cond [(is-triangle?) (print_area)]\n        [else (-1)])\n  )\n", " \
    \ (cond [(and (> a 0) (> b 0) (> c 0))\n         (let ([s (/ (+ a b c) 2)])\n\
    \           (sqrt (* s (- s a) (- s b) (- s c))))]\n        [else -1]))\n", " \
    \ (cond\n    [(> (+ a b) c) (+ (* a b) 0.5)]\n    [(> (+ a c) b) (+ (* a c) 0.5)]\n\
    \    [(> (+ b c) a) (+ (* b c) 0.5)]\n    [else -1]))\n", "  (define s (/ (+ a\
    \ b c) 2))\n  (if (&gt; (+ (- s a) (- s b) (- s c)) s)\n      (round (* (sqrt\
    \ (- s (* a a) (* b b) (* c c))) 2))\n      -1))\n</code>\n", "  (if (< a 0) -1\n\
    \    (if (< b 0) -1\n      (if (< c 0) -1\n        (if (> (+ a b) c)\n       \
    \   (if (> (+ a c) b)\n            (if (> (+ b c) a)\n              (* .5 (- a\
    \ c) (- b c))\n              -1)\n            -1)\n          -1)))))\n", "  (cond\
    \ ((or (= a 0) (= b 0) (= c 0)) -1)\n        ((< a (+ b c)) -1)\n        ((< b\
    \ (+ a c)) -1)\n        ((< c (+ a b)) -1)\n        (else (round (* (sqrt (- (*\
    \ (+ a b c) (* a b c)) \n                               (* a (* a a) (+ b (* b\
    \ b)) (+ c (* c c)))) 2)) 2))))", "  (define (valid-triangle? a b c)\n    (and\
    \ (&gt;= (+ a b) c)\n         (&gt;= (+ a c) b)\n         (&gt;= (+ b c) a)))\n\
    \  (cond\n    [(valid-triangle? a b c)\n     (define (sides-to-area s1 s2 s3)\n\
    \       (/ (* s1 s2 s3) 2))\n     (sides-to-area a b c)]\n    [else -1]))\n</code>\n\
    Applying a program transformation to this code results in the following, which\
    \ is equivalent to the original:\n<code>#lang racket\n", "  (match (list a b c)\n\
    \    [(list x y z) (if (and (> (+ x y) z)\n                            (> (+ x\
    \ z) y)\n                            (> (+ y z) x))\n                       (*\
    \ (/ (+ x y z) 2)\n                          (sqrt (- (* (- x y) (- x y))\n  \
    \                                 (* (- x z) (- x z))\n                      \
    \             (* (- y z) (- y z)))))\n                       -1.0)]))\n", "  (define\
    \ (is-valid a b c)\n    (and (>= c (abs (- a b)))\n         (>= b (abs (- a c)))\n\
    \         (>= a (abs (- b c)))))\n  (define (area a b c)\n    (* (/ (sqrt (+ (*\
    \ a a) (* b b) (* c c))) 2)\n       (- a b c)))\n  (cond ((is-valid a b c)\n \
    \        (printf \"~f\" (area a b c)))\n        (else -1)))\n", "  (define (is-valid?\
    \ a b c)\n    (cond ((and (&gt;= a b) (&gt;= a c)) #t)\n          ((and (&gt;=\
    \ b a) (&gt;= b c)) #t)\n          ((and (&gt;= c a) (&gt;= c b)) #t)\n      \
    \    (else #f)))\n  (cond ((is-valid? a b c)\n         (/ (* (sqrt (+ (* (- a\
    \ (/ (+ a b c) 2)) (- a (/ (+ a b c) 2))) (* (- b (/ (+ a b c) 2)) (- b (/ (+\
    \ a b c) 2))) (* (- c (/ (+ a b c) 2)) (- c (/ (+ a b c) 2))))) 4) 2))\n     \
    \   (else -1)))\n", "  (define (is-valid-triangle? a b c)\n    (and (> (+ a b)\
    \ c)\n         (> (+ a c) b)\n         (> (+ b c) a)))\n  (cond [(is-valid-triangle?\
    \ a b c)\n         (round (* (/ (+ a b c) 2) \n                   (sqrt (- (*\
    \ (+ a b c) \n                               (* (+ a b c) \n                 \
    \                 (- a b c)))\n                           (* a a b b c c))))\n\
    \                2)]\n        [else -1]))\n</code>\n", "  (let ((s (+ a b c)))\n\
    \    (cond\n      ((> a s) -1)\n      ((> b s) -1)\n      ((> c s) -1)\n     \
    \ (else (* (/ s 2)\n               (- s a)\n               (- s b)\n         \
    \      (- s c))))))\n", "  (if (and (> a 0) (> b 0) (> c 0))\n      (let ([p (+\
    \ a b c)])\n        (if (> a p)\n            -1\n            (if (> b p)\n   \
    \             -1\n                (if (> c p)\n                    -1\n      \
    \              (* 0.5\n                       (- p a)\n                      \
    \ (- p b)\n                       (- p c))))))\n      -1))\n```\n\n```ruby\n#\
    \ Given the lengths of the three sides of a triangle. Return the area of\n# the\
    \ triangle rounded to 2 decimal points if the three sides form a valid triangle.\
    \ \n# Otherwise return -1\n# Three sides make a valid triangle when the sum of\
    \ any two sides is greater \n# than the third side.\n# Example:\n# triangle_area(3,\
    \ 4, 5) == 6.00\n# triangle_area(1, 2, 10) == -1\ndef triangle_area(a, b, c)\n\
    \  if a > 0 && b > 0 && c > 0\n    p = a + b + c\n    if a > p || b > p || c >\
    \ p\n      -1\n    else\n      0.5 * (p - a) * (p - b) * (p - c)\n    end\n  else\n\
    \    -1\n  end\nend\n```\n\n```javascript\n// Given the lengths of the three sides\
    \ of a triangle. Return the area of\n// the triangle rounded to 2 decimal points\
    \ if the three sides form a valid triangle. \n// Otherwise return -1\n// Three\
    \ sides make a valid triangle when the sum of any two sides is greater \n// than\
    \ the third side.\n// Example:\n// triangle_area(3, 4, 5) == 6.00\n// triangle_area(1,\
    \ 2, 10) == -1\nfunction triangle_area(a, b, c) {\n  if (a > 0 && b > 0 && c >\
    \ 0) {\n    p = a + b + c;\n    if (a > p || b > p || c > p) {\n      return -1;\n\
    \    } else {\n      return 0.5 * (p - a) * (p - b) * (p - c);\n    }\n  } else\
    \ {\n   ", "  (if (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n \
    \     (/ (* a b c) 4)\n      -1))\n", "  (if (and (< (+ a b) c) (< (+ a c) b)\
    \ (< (+ b c) a))\n      -1\n      (round (* (sqrt (- (* (- (+ (* a a) (* b b))\
    \ (* c c)) (* 2 a b))) 2) 2))))\n```\n\n```racket\n#lang racket\n", "  (define\
    \ (is_valid a b c)\n    (> (+ a b) c))\n  (cond ((and (is_valid a b c)\n     \
    \         (is_valid b c a)\n              (is_valid c a b))\n         (define\
    \ (perimeter a b c)\n           (+ a b c))\n         (define (area a b c)\n  \
    \         (sqrt (* (- (perimeter a b c) a)\n                    (- (perimeter\
    \ a b c) b)\n                    (- (perimeter a b c) c))))\n         (round (*\
    \ 100 (area a b c))))\n        (else -1)))\n", "  (if (and (> a 0) (> b 0) (>\
    \ c 0))\n      (if (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n         \
    \ (* .5 (sqrt (+ (* (- a .5) (- a .5)) (* (- b .5) (- b .5)) (* (- c .5) (- c\
    \ .5)) (- (* a a) (* b b)) (- (* a a) (* c c)) (- (* b b) (* c c)))))\n      \
    \    -1)\n      -1))\n", "  (cond\n    [(and (> a 0) (> b 0) (> c 0))\n     (define\
    \ s (/ (+ a b c) 2))\n     (sqrt (* s (- s a) (- s b) (- s c)))]\n    [else -1]))\n\
    ```\n\n```scheme\n#lang racket\n", "  (let ([s (+ a b c)])\n    (cond\n      [(&gt;\
    \ s (* 2 c)) (* 1/2 (- s c) (* (- s a) (- s b)))]\n      [(&gt; s (* 2 b)) (*\
    \ 1/2 (- s b) (* (- s a) (- s c)))]\n      [(&gt; s (* 2 a)) (* 1/2 (- s a) (*\
    \ (- s b) (- s c)))]\n      [else -1])))\n", "  (cond\n    [(not (>= (* (+ a b)\
    \ (- a b)) (* (- c b) (- c a)))) -1]\n    [else (/ (* a b) 2)]))\n", "  (if (&gt;\
    \ a (- b c))\n      -1\n      (round (* .5 (* a (- b c))) 2)))\n</code>\nThe last\
    \ line is a bit tricky. I am trying to calculate the height of the triangle and\
    \ multiply it with half of the base, is there a more elegant way to do this?\n\
    \n\nA:\n\nIf you want to round to 2 decimal points, you should use <code>round/decimal</code>,\
    \ not <code>round</code>. So, you should use:\n<code>(round/decimal (* .5 (* a\
    \ (- b c))) 2)\n</code>\n", "  (define (valid-triangle? a b c)\n    (cond\n  \
    \    [(>= a (+ b c)) #f]\n      [(>= b (+ a c)) #f]\n      [(>= c (+ a b)) #f]\n\
    \      [else #t]))\n  (cond\n    [(not (valid-triangle? a b c)) -1]\n    [else\
    \ (round (* .5 (- a (+ b c))) 2)]))\n</code>\n", "  (if (and\n       (> (+ a b)\
    \ c)\n       (> (+ a c) b)\n       (> (+ b c) a))\n      (round (* 0.5 (- (+ a\
    \ b c) a b c)) 2)\n      -1))\n```\n\n```racket\n#lang racket\n", "  ;; your code\
    \ here\n  )\n</code>\nI have the following code:\n<code>#lang racket\n", "  (define\
    \ (is-valid?)\n    (> (+ a b) c)\n    (> (+ a c) b)\n    (> (+ b c) a))\n  (cond\n\
    \    [(is-valid?)\n     (define p (/ (+ a b c) 2))\n     (define area (sqrt (*\
    \ p (- p a) (- p b) (- p c))))\n     (round (* area 100))\n     (/ (round (* area\
    \ 100)) 100)]\n    [else -1]))\n", "  (let ((sp (/ (+ a b c) 2)))\n    (cond\n\
    \      ((or (< a 0) (< b 0) (< c 0))\n       -1)\n      ((>= a (+ b c))\n    \
    \   -1)\n      ((>= b (+ a c))\n       -1)\n      ((>= c (+ a b))\n       -1)\n\
    \      (else\n       (round (* sp (- sp a) (- sp b) (- sp c)) 2)))))\n", "  (cond\n\
    \    [(or (or (< a 1) (< b 1) (< c 1))\n         (< (- a b) c) (< (- a c) b) (<\
    \ (- b c) a))\n     -1]\n    [else\n     (define s (/ (+ a b c) 2))\n     (define\
    \ area (sqrt (* s (- s a) (- s b) (- s c))))\n     (round (* area 100))]))\n",
  "  (cond\n    [(or (= a 0) (= b 0) (= c 0)) 0]\n    [(and (< (+ a b) c) (< (+ a\
    \ c) b) (< (+ b c) a)) -1]\n    [else (* 0.5 (* a (sqrt (- (* (* a a) (* b b))\
    \ (* (* b b) (* c c))))))]))\n", "  (define s (* 0.5 (+ a b c)))\n  (cond ((or\
    \ (&lt;= a 0)\n             (&lt;= b 0)\n             (&lt;= c 0)\n          \
    \   (&lt;= (* a a) (* b b c))\n             (&lt;= (* b b) (* a a c))\n      \
    \       (&lt;= (* c c) (* a a b)))\n         -1)\n        (else\n         (* s\
    \ (- s a) (- s b) (- s c)))))\n</code>\nMy question is:\nWhat is the simplest\
    \ and most elegant way of solving this problem?\nI don't like the long condition\
    \ checking in the cond statement. \nHere is an example of a solution I came up\
    \ with. It is easier to read, but it is not as efficient in term of computation\
    \ time.\n<code>#lang racket\n", "  (define s (/ (+ a b c) 2))\n  (define area\
    \ (sqrt (* s (- s a) (- s b) (- s c))))\n  (cond ((<= area 0) -1)\n        (else\
    \ (round (* area 100) 2))))\n```\n\n```\n#lang racket\n", "  (cond [(and (>= a\
    \ 0) (>= b 0) (>= c 0))\n         (let* ([p (/ (+ a b c) 2)]\n               \
    \ [result (* p (- p a) (- p b) (- p c))])\n           (cond [(> result 0) (/ result\
    \ 0.5)]\n                 [else -1]))]\n        [else -1]))\n", "  (letrec ([is-valid?\
    \ (lambda (sides)\n                         (and (not (apply < sides))\n     \
    \                         (apply < (append sides (list (+ (apply + sides)))))))])\n\
    \    (if (is-valid? (list a b c))\n        (sqrt (* (- (* a a) (* b b) (* c c))\
    \ (* 4 b c)))\n        -1)))", "  (cond\n    [(> (+ a b) c) (floor (* 0.5 (* (+\
    \ a b) (- c (sqrt (- (* c c) (* (+ a b) (+ a b) (/ (- (* a a) (* b b)) (- c c)))))))))\n\
    \     (> (+ a c) b) (floor (* 0.5 (* (+ a c) (- b (sqrt (- (* b b) (* (+ a c)\
    \ (+ a c) (/ (- (* a a) (* c c)) (- b b)))))))))\n     (> (+ b c) a) (floor (*\
    \ 0.5 (* (+ b c) (- a (sqrt (- (* a a) (* (+ b c) (+ b c) (/ (- (* b b) (* c c))\
    \ (- a a)))))))))\n     (else -1)]))\n```\n\n```racket\n#lang racket\n", "  (let*\
    \ ((s (apply + (list a b c)))\n         (area (sqrt (* (- s a) (- s b) (- s c)))))\n\
    \    (cond\n      ((not (and (< a b) (< b c))) -1)\n      ((<= s 0) -1)\n    \
    \  (else (exact->inexact (/ area 2))))))\n", "  (if (and (&gt;= a b) (&gt;= a\
    \ c))\n      (-&gt;&gt; a\n           (* b c)\n           (* (/ 0.5 1.0))\n  \
    \         (number-&gt;string)\n           substring\n           (string-take 2)\n\
    \           (string-&gt;number)\n           (exact-&gt;inexact)\n           (round\
    \ (* 100 2)))\n      -1))\n</code>\nIs there a way to simplify this code?\n\n\n\
    A:\n\nHere's a refactoring of your code, using some standard procedures:\n<code>(define\
    \ (triangle_area a b c)\n  (if (and (&gt;= a b) (&gt;= a c))\n      (round (*\
    \ 100 (/ 0.5 (* a b c))))\n      -1))\n</code>\n", "  (cond [(and (< a (+ b c))\n\
    \              (< b (+ a c))\n              (< c (+ a b)))\n         (round (*\
    \ 0.5 (- (+ a b c) (- a (abs (- b c)))) (- (+ a b c) (- b (abs (- a c)))) (- (+\
    \ a b c) (- c (abs (- a b))))))]\n        [else -1]))\n", "  (if (and (<= a 0)\
    \ (<= b 0) (<= c 0))\n      -1\n      (let ([s (/ (+ a b c) 2)])\n        (sqrt\
    \ (* s (- s a) (- s b) (- s c))))))\n", "  (if (>= a b c)\n      -1\n      (round\
    \ (* 0.5 (* (+ a b c) (- (+ a b c) a) (- (+ a b c) b) (- (+ a b c) c))) 2)))\n",
  "  (if (and\n       (>= a 1)\n       (>= b 1)\n       (>= c 1)\n       (> (+ a b)\
    \ c)\n       (> (+ a c) b)\n       (> (+ b c) a))\n      (string-&gt;number\n\
    \       (substring\n        (number-&gt;string (* 0.5 (- (* a b) (* a c) (* b\
    \ c))))\n        2))\n      -1))\n</code>\n", "  (if (and (&gt; (+ a b) c) (&gt;\
    \ (+ a c) b) (&gt; (+ b c) a))\n      (-&gt;&gt; (list a b c)\n           (apply\
    \ * (list 2))\n           sqrt\n           (* 2)\n           (sprintf \"%.2f\"\
    )\n           string-&gt;number)\n      -1))\n</code>\n", "  (let ([s (/ (+ a\
    \ b c) 2)])\n    (if (and (>= a s) (>= b s) (>= c s))\n        (* (/ s (- s a))\
    \ (/ s (- s b)) (/ s (- s c)))\n        -1)))\n</code>\n", "  (cond ((or (< a\
    \ 0) (< b 0) (< c 0)) -1)\n        ((and (>= (+ a b) c) (>= (+ a c) b) (>= (+\
    \ b c) a))\n         (round (* (/ (+ a b c) 2)\n                   (sqrt (- (*\
    \ (- (+ a b c) a)\n                              (- (+ a b c) b)\n           \
    \                   (- (+ a b c) c))))\n                   2))))\n", "  (cond\
    \ [(and (> a 0) (> b 0) (> c 0))\n         (define perimeter (/ (+ a b c) 2))\n\
    \         (define areafloat (* perimeter (- perimeter a) (- perimeter b) (- perimeter\
    \ c)))\n         (define area (sqrt areafloat))\n         (* 100 (round (* area\
    \ 2)))\n         ]\n        [else -1]))\n", "  (cond [(and (< a (+ b c)) (< b\
    \ (+ a c)) (< c (+ a b)))\n         (round (* (/ (+ a b c) 2)\n              \
    \     (sqrt (- (expt a 2)\n                            (/ (- (expt (+ a b) 2)\
    \ (expt c 2)) 2))\n                          (- (expt b 2)\n                 \
    \            (/ (- (expt (+ a c) 2) (expt a 2)) 2))\n                        \
    \  (- (expt c 2)\n                             (/ (- (expt (+ b c) 2) (expt b\
    \ 2)) 2))))\n                 2)]\n        [else -1]))\n", "  (cond\n    [(or\
    \ (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)) \n     (round (* (sqrt (* (- (* (+\
    \ a b) (+ a c) (+ b c)) 2) (- (* (+ a b) (+ a c) (+ b c)) 2))) .5) 2)]\n    [else\
    \ -1]))", "  (if (and (> (+ a b) c)\n           (> (+ a c) b)\n           (> (+\
    \ b c) a))\n      (define s (/ (+ a b c) 2))\n      (-s (sqrt (* s (- s a) (-\
    \ s b) (- s c)))))\n  (round (/ triangle_area 2) 2))\n", "  (let ((s (/ (+ a b\
    \ c) 2)))\n    (if (&gt; a b c)\n        (/ (* s (- s a) (- s b) (- s c)) 2)\n\
    \        -1)))\n", "  (cond [(>= a b c) (-1)]\n        [(>= b a c) (-1)]\n   \
    \     [(>= c a b) (-1)]\n        [else (define (h a b c)\n                (sqrt\
    \ (+ (* (- c a) (- c a))\n                        (* (- b a) (- b a)))))\n   \
    \           (define s (/ (+ a b c) 2))\n              (* s (- s a) (- s b) (-\
    \ s c))]))", "  (cond\n    [(or (< a 0) (< b 0) (< c 0)) -1]\n    [(and (<= a\
    \ (+ b c)) (<= b (+ a c)) (<= c (+ a b)))\n     (round (* .5 (- (+ a b c) a) (-\
    \ (+ a b c) b) (- (+ a b c) c)) 2)]\n    [else -1]))\n", "  (define s (/ (+ a\
    \ b c) 2))\n  (define (norm a) (* -1 a))\n  (if (< s (- a))\n      -1\n      (define\
    \ sides (list a b c))\n      (cond\n        [(>= s (- a))\n         (/ (* s (-\
    \ s a)) 2)]\n        [(>= s (- b))\n         (/ (* s (- s b)) 2)]\n        [(>=\
    \ s (- c))\n         (/ (* s (- s c)) 2)])))\n", "  (if (or (< a 0) (< b 0) (<\
    \ c 0))\n      -1\n      (let ([p (/ (+ a b c) 2)])\n        (cond\n         [(or\
    \ (< a (+ b c)) (< b (+ a c)) (< c (+ a b))) -1]\n         [else (/ (* p (- p\
    \ a) (- p b) (- p c)) 2.0)]))))\n", "  (cond\n    [(and\n      (> a 0)\n     \
    \ (> b 0)\n      (> c 0)\n      (> (+ a b) c)\n      (> (+ a c) b)\n      (> (+\
    \ b c) a))\n     (round (* 0.5 (- (+ a b) c) (- (+ a c) b) (- (+ b c) a)) 2)]\n\
    \    [else -1]))\n", "  (define s (+ (/ (+ a b c) 2) -1))\n  (if (and (&gt; a\
    \ 0) (&gt; b 0) (&gt; c 0)\n          (&gt; (+ a b) c)\n          (&gt; (+ a c)\
    \ b)\n          (&gt; (+ b c) a))\n      (sqrt (* s (- s a) (- s b) (- s c)))\n\
    \      -1))\n</code>\n", "  (define s (/ (+ a b c) 2))\n  (define max (max a (max\
    \ b c)))\n  (if (&gt; max (- s max))\n      -1\n      (round (* (sqrt (- s (*\
    \ max (sqrt (- max (* max max)))))) s) 2)))\n</code>\nTo check for a valid triangle,\
    \ you only need to check one side against the other two.  Any side that is longer\
    \ than the sum of the other two will result in an invalid triangle.  The <code>max</code>\
    \ function will return the length of the longest side, so you can subtract that\
    \ from the sum of the other two.  If that is less than or equal to the longest\
    \ side, then you have an invalid triangle.\nThe area of a triangle is:\n<code>sqrt(s(s-a)(s-b)(s-c))\n\
    </code>\nWhere <code>s</code> is half the perimeter of the triangle.  The code\
    \ above will calculate the area of the triangle (if it is valid), and then round\
    \ it to 2 decimal places.\n", "  (define (is-valid a b c)\n    (let loop ((a a)\
    \ (b b) (c c))\n      (cond ((and (&gt;= a b) (&gt;= b c)) (not (&gt;= (+ a b)\
    \ c)))\n            ((and (&gt;= a c) (&gt;= c b)) (not (&gt;= (+ a c) b)))\n\
    \            ((and (&gt;= b a) (&gt;= a c)) (not (&gt;= (+ b a) c)))\n       \
    \     ((and (&gt;= b c) (&gt;= c a)) (not (&gt;= (+ b c) a)))\n            ((and\
    \ (&gt;= c a) (&gt;= a b)) (not (&gt;= (+ c a) b)))\n            ((and (&gt;=\
    \ c b) (&gt;= b a)) (not (&gt;= (+ c b) a))))))\n  (if (is-valid a b c)\n    \
    \  (let ((s (/ (+ a b c) 2)))\n        (* s (- s a) (- s b) (- s c)))\n      -1))\n\
    </code>\nNote that I also fixed your <code>is-valid</code> predicate to be a little\
    \ more efficient.\n", "  (if (> (+ a b) c)\n      (let ([p (+ a b c)])\n     \
    \   (sqrt (* p (- p a) (- p b) (- p c))))\n      -1))\n", "  (define (area a b\
    \ c)\n    (/ (* a b (sqrt (+ (* b b) (* c c)))) 2))\n  (if (or (= a 0) (= b 0)\
    \ (= c 0))\n      -1\n      (if (or (< a (- b c))\n              (< b (- c a))\n\
    \              (< c (- a b)))\n          -1\n          (round (area a b c) 2))))\n",
  "  (cond ((< a 0) -1)\n        ((< b 0) -1)\n        ((< c 0) -1)\n        ((and\
    \ (< (+ a b) c) (< (+ a c) b) (< (+ b c) a)) -1)\n        (else (* 0.5 ( + a b\
    \ c)))))", "  (let* ([s (/ (+ a b c) 2)]\n         [area (sqrt (* s (- s a) (-\
    \ s b) (- s c)))])\n    (cond\n      [(> area 0) (round (* area 100) 2)]\n   \
    \   [else -1])))\n", "  (define semi-perimeter (/ (+ a b c) 2))\n  (define area\
    \ (* semi-perimeter (- semi-perimeter a) (- semi-perimeter b) (- semi-perimeter\
    \ c)))\n  (if (&lt; area 0) -1 (round (* (sqrt area) 100) 0.01)))\n</code>\nI\
    \ don't get why it is not accepted.\n\n\nA:\n\nIt is interesting that the algorithm\
    \ you use is Heron's formula. There is no need to compute all three differences\
    \ of the semi-perimeter and each of the sides, as you also could compute area\
    \ as the square root of the product of the semi-perimeter and the three differences\
    \ of the semi-perimeter and each of the sides. That would be more efficient, because\
    \ it saves one multiplication and two divisions, but would not change the running\
    \ time of the algorithm by much.\n", "  (let ((s (/ (+ a b c) 2)))\n    (cond\
    \ ((>= a (+ b c)) -1)\n          ((>= b (+ a c)) -1)\n          ((>= c (+ a b))\
    \ -1)\n          (else (* s (- s a) (- s b) (- s c))))))\n", "  (if (&gt;= (+\
    \ a b) c)\n      (define (s) (/ (+ a b c) 2))\n      (define (s) (/ (+ a b c)\
    \ 2))\n      (* s (- s a) (- s b) (- s c))\n      (-1)))\n", "  (cond\n    ((=\
    \ 0 (side-sum a b c)) -1)\n    (else (triangle-area a b c))))\n", "  (cond [(>=\
    \ (+ a b) c) (cond [(>= (+ a c) b) (cond [(>= (+ b c) a) (list-ref (list (sqrt\
    \ (* a a b b c c))\n                                                         \
    \                       (sqrt (* a a b b c c))\n                             \
    \                                                   (sqrt (* a a b b c c)))\n\
    \                                                                       1)]\n\
    \                                                 [else -1])]\n              \
    \               [else -1])]\n        [else -1]))\n", "  (define sides (list a\
    \ b c))\n  (define ordered-sides (sort sides <))\n  (define (smallest-side lst)\n\
    \    (define (smallest-side-iter small-side rest-of-lst)\n      (cond [(empty?\
    \ rest-of-lst) small-side]\n            [(< (first rest-of-lst) small-side)\n\
    \             (smallest-side-iter (first rest-of-lst) (rest rest-of-lst))]\n \
    \           [else (smallest-side-iter small-side (rest rest-of-lst))]))\n    (smallest-side-iter\
    \ (first lst) (rest lst)))\n  (define largest-side (apply max sides))\n  (define\
    \ (triangle-area-iter remaining-sides)\n    (cond [(empty? remaining-sides)\n\
    \           (printf \"Invalid triangle.\")]\n          [(> (+ (first remaining-sides)\
    \ (second remaining-sides)) largest-side)\n           (printf \"Area of the triangle:\
    \ ~a\"\n                   (sqrt (* (- (* largest-side largest-side)\n       \
    \                        (* (smallest-side sides) (smallest-side sides)))\n  \
    \                         (/ (- (+ largest-side (smallest-side sides))\n     \
    \                            (second remaining-sides)) 2))))]\n          [else\
    \ (triangle-area-iter (rest remaining-sides))]))\n  (triangle-area-iter (rest\
    \ (rest ordered-sides))))", "  (cond\n    [(and (> (+ a b) c) (> (+ a c) b) (>\
    \ (+ b c) a))\n     (round (* 0.5 (- (+ a b c) a b c)) 2)]\n    [else -1]))\n",
  "  (define s (/ (+ a b c) 2))\n  (sqrt (- (* s (- s a)) (* s (- s b)) (* s (- s\
    \ c)))))", "  (if (and (> a (- b c)) (> b (- a c)) (> c (- a b)))\n      (display\
    \ (round (* .5 (* (+ a b c) (- a (- b c)) (- b (- a c)) (- c (- a b))))))\n  \
    \    (display -1)))\n", "  (cond ((not (valid-triangle? a b c)) -1)\n        (else\
    \ (round (* (sqrt (make-p a b c)) 2) 2))))\n", "  (define (triangle_area_helper\
    \ a b c)\n    (* (/ (+ a b c) 2) (- (/ (+ a b c) 2) a) (- (/ (+ a b c) 2) b) (-\
    \ (/ (+ a b c) 2) c)))\n  (define (valid_triangle a b c)\n    (if (and (<= (+\
    \ a b) c) (<= (+ a c) b) (<= (+ b c) a)) #f #t))\n  (if (valid_triangle a b c)\
    \ (round (triangle_area_helper a b c) 2) -1))\n```\n\n##6.\n```\n#lang racket\n",
  "  (if (and (>= a 0) (>= b 0) (>= c 0))\n      (cond\n       ((and (>= (+ a b) c)\
    \ (>= (+ a c) b) (>= (+ b c) a))\n        (round (* (sqrt (+ (* (- a (/ b 2))\
    \ (- a (/ b 2))) (* (* c c) (/ 1 4)))) 2)))\n       (else -1))))\n", "  (cond\
    \ [(and (< a 0) (< b 0) (< c 0)) -1]\n        [(or (> (+ a b) c) (> (+ a c) b)\
    \ (> (+ b c) a)) -1]\n        [else (/ (* a b) 2)]))\n", "  (cond ((< (+ a b)\
    \ c) -1)\n        ((< (+ a c) b) -1)\n        ((< (+ b c) a) -1)\n        (else\
    \ (/ (* a b) 2))))", "  (define (is_valid_triangle a b c)\n    (and (>= a b) (>=\
    \ b c) (>= a (+ b c))))\n  (cond ((is_valid_triangle a b c)\n         (define\
    \ (sides_sum a b c)\n           (+ a b c))\n         (define (semiperimeter a\
    \ b c)\n           (/ (sides_sum a b c) 2))\n         (define (heron a b c)\n\
    \           (sqrt (semiperimeter a b c) (* (semiperimeter a b c) (- (semiperimeter\
    \ a b c) a) (- (semiperimeter a b c) b) (- (semiperimeter a b c) c))))\n     \
    \    (round (* 100 (heron a b c))))\n        (else -1)))\n", "  (if (and (and\
    \ (&gt;= a 1) (&gt;= b 1) (&gt;= c 1))\n           (and (&gt;= (+ a b) c)\n  \
    \              (&gt;= (+ a c) b)\n                (&gt;= (+ b c) a)))\n      (round\
    \ (* (sqrt (* (- (* a a) (* b b) (* c c)) (* a b c)) 2)) 2)\n      -1))\n</code>\n\
    The problem I have is the following:\n<code>-1</code> gets returned even when\
    \ the parameters form a valid triangle. When I remove the comment marks in the\
    \ <code>if</code> clause, the program works as expected.\nI have this <code>if</code>\
    \ clause in my code:\n<code>(if (and (and (&gt;= a 1) (&gt;= b 1) (&gt;= c 1))\n\
    \         (and (&gt;= (+ a b) c)\n              (&gt;= (+ a c) b)\n          \
    \    (&gt;= (+ b c) a)))\n</code>\nThe first <code>and</code> clause inside the\
    \ <code>if</code> clause checks if <code>a</code>, <code>b</code> and <code>c</code>\
    \ are all greater than or equal to 1. The second <code>and</code> clause checks\
    \ if the sum of any two sides is greater than the third side.\nThe two <code>and</code>\
    \ clauses are needed to be in the <code>if</code> clause like this in order for\
    \ it to work.\nWhen I only have one <code>and</code> clause, like so,\n<code>(if\
    \ (and (&gt;= a 1) (&gt;= b 1) (&gt;= c 1))\n</code>\nit works fine, but when\
    \ the expression is changed to,\n<code>(if (and (&gt;= (+ a b) c)\n         (&gt;=\
    \ (+ a c) b)\n         (&gt;= (+ b c) a))\n</code>\nit fails to return the correct\
    \ value.\nWhy is this?\nIf I replace the first <code>and</code> clause in the\
    \ <code>if</code> clause with the second <code>", "  (define (is-valid a b c)\n\
    \    (and (<= a (+ b c))\n         (<= b (+ a c))\n         (<= c (+ a b))))\n\
    \  (cond ((and (= a 0) (= b 0) (= c 0))\n         -1)\n        ((is-valid a b\
    \ c)\n         (inexact->exact\n          (round (* (exact->inexact (/ (* a b)\
    \ 2)) 100))))\n        (else\n         -1)))", "  (cond [(and (> (+ a b) c)\n\
    \              (> (+ a c) b)\n              (> (+ b c) a))\n         (round (*\
    \ .5\n                  (- (+ a b c)\n                     a\n               \
    \      b\n                     c))\n                2)]\n        [else -1]))\n",
  "  (cond\n    [(>= (+ a b) c) (* (/ (+ a b) 2) (sqrt (- (* (- a (/ (+ a b) 2)) (-\
    \ a (/ (+ a b) 2))) (- (* c c) (/ (* (+ a b) (+ a b)) 4))))) 0.01]\n    [else\
    \ -1]))\n", "  (define (helper a b c)\n    (cond [(> (+ a b) c) (* 0.5 (- b c))]\n\
    \          [(> (+ a c) b) (* 0.5 (- a c))]\n          [(> (+ b c) a) (* 0.5 (-\
    \ a b))]\n          [else #f]))\n  (cond [(and (<= a 0) (<= b 0) (<= c 0)) -1]\n\
    \        [(and (<= a 0) (<= b 0)) -1]\n        [(and (<= a 0) (<= c 0)) -1]\n\
    \        [(and (<= b 0) (<= c 0)) -1]\n        [(<= a 0) -1]\n        [(<= b 0)\
    \ -1]\n        [(<= c 0) -1]\n        [else (helper a b c)]))\n", "  (define (is-valid-triangle?\
    \ a b c)\n    (or (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n        (and\
    \ (= (+ a b) c) (= a b) (= b c))\n        (and (= (+ a c) b) (= a c) (= b c))\n\
    \        (and (= (+ b c) a) (= a b) (= b c))))\n  (if (is-valid-triangle? a b\
    \ c)\n      (define s (/ (+ a b c) 2))\n      (define area (sqrt (* s (- s a)\
    \ (- s b) (- s c))))\n      (round (* area 100)))\n      -1))\n", "  (define s\
    \ (* 0.5 (+ a b c)))\n  (define area (sqrt (- (* s (- s a)) (* s (- s b)) (* s\
    \ (- s c)))))\n  (cond ((> a 0)\n         (cond ((> b 0)\n                (cond\
    \ ((> c 0)\n                       (if (> s 0)\n                           (round\
    \ (* 100 area))\n                           -1))\n                      0))\n\
    \               0))\n        0))\n", "  (if (and (> (+ a b) c)\n           (>\
    \ (+ a c) b)\n           (> (+ b c) a))\n      (* 0.5 (- (+ a b c) a b c))\n \
    \     -1))\n", "  (cond [(> (+ a b) c)\n         (round (* 0.5 (* a (sqrt (- (*\
    \ b b) (* a a)))) 2))]\n        [else -1]))\n", "  (let ((s (/ (+ a b c) 2)))\n\
    \    (cond [(> a b c) (/ (* s (- s a) (- s b) (- s c)) (sqrt s))]\n          [else\
    \ -1])))\n", "  (let ([p (/ (+ a b c) 2)])\n    (if (&gt;= (+ a b) c)\n      \
    \  (* p (- p a) (- p b) (- p c))\n        -1)))\n", "  (let loop ([a a] [b b]\
    \ [c c])\n    (if (< a 0)\n        '-1\n        (if (or (> (+ a b) c) (> (+ a\
    \ c) b) (> (+ b c) a))\n            (round (* (/ (+ a b) 2) (sqrt (- (* b b) (/\
    \ (* (- a b) (- a b)) 4)))) 2)\n            '-1))))\n", "  (cond\n    [(or (<\
    \ a 1) (< b 1) (< c 1)) -1]\n    [(or (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\
    \ -1]\n    [else (round (* 0.5 (- (+ a b c) (- a b c))))]))", "  (define (area\
    \ s)\n    (* 0.5 s (/ (expt (- (* s (- s a)) (* s (- s b)) (* s (- s c))) 2) s)))\n\
    \  (cond ((or (< a 0) (< b 0) (< c 0)) -1)\n        ((or (> a (+ b c)) (> b (+\
    \ a c)) (> c (+ a b))) -1)\n        (else (round (area (+ a b c)) 2))))\n", " \
    \ (cond [(and (>= c (+ a b))\n              (>= b (+ a c))\n              (>=\
    \ a (+ b c)))\n         -1]\n        [else\n         (round (* 0.5 (expt a 2)\n\
    \                      (sqrt (+ (expt b 2)\n                               (expt\
    \ c 2))))\n                2)]))\n", "  (define (equilateral a b c)\n    (and\
    \ (= a b) (= b c)))\n  (define (isosceles a b c)\n    (or (= a b) (= b c) (= a\
    \ c)))\n  (define (valid a b c)\n    (and (&gt;= a b)\n         (&gt;= b c)\n\
    \         (&gt;= a c)\n         (&gt; (+ a b) c)\n         (&gt; (+ b c) a)\n\
    \         (&gt; (+ a c) b)))\n  (define (area a b c)\n    (sqrt\n     (+ (* (-\
    \ (* a a) (* b b)) (* c c))\n        (* (* 2 a b) (* 2 a c))\n        (* (* 2\
    \ b c) (* 2 b a)))))\n  (cond\n    [(equilateral a b c) (area a b c)]\n    [(and\
    \ (isosceles a b c) (valid a b c)) (area a b c)]\n    [else -1]))\n</code>\nHow\
    \ do I improve it?\nI don't like the repetition in <code>valid</code> function.\n\
    \n\nA:\n\nSome general comments:\n\nUse <code>format</code> to round the result:\n\
    <code>(define (triangle-area a b c)\n  (let* ([s (/ (+ a b c) 2)]\n         [area\
    \ (sqrt (* s (- s a) (- s b) (- s c)))])\n    (if (&lt; area 0) -1 (format \"\
    ~0,2f\" area))))\n</code>\nNaming: <code>triangle-area</code> is a bit long, maybe\
    \ <code>triangle-area!</code> is better?\nTests are needed (and I didn't add them\
    \ to my code).\n\nNow the less general comments:\n\nI don't see why you would\
    \ have a single helper function to check each kind of triangle...\nI find your\
    \ <code>valid</code> function a bit complex to understand. I would have written\
    \ it as a series of <code>and</code> calls, with each <code>when</code> clause\
    \ containing a single check:\n<code>(define (valid? a b c)\n  (and", "  (cond\n\
    \    [(and (>= a 1) (>= b 1) (>= c 1))\n     (cond\n       [(and (> (+ a b) c)\
    \ (> (+ a c) b) (> (+ b c) a))\n        (define s (/ (+ a b c) 2))\n        (exact->inexact\
    \ (sqrt (* s (- s a) (- s b) (- s c)))))\n       [else -1]])\n    [else -1]))\n",
  "  (if (&gt; (+ a b) c)\n      (-&gt;&gt; (list a b c)\n           (sort &lt;)\n\
    \           (apply * 0.5))\n      -1))\n</code>\n", "  (cond\n    [(> a b c) -1]\n\
    \    [(> b a c) -1]\n    [(> c a b) -1]\n    [else (+ (/ (* a b) 2) (round (/\
    \ (* a b) 2)))]))\n", "  (if (and (< a (+ b c)) (< b (+ a c)) (< c (+ a b)))\n\
    \      (* (/ (+ a b c) 2) (sqrt (- (* (+ a b c) (* (+ a b c)) (* (+ a b c)) )\n\
    \                                 (+ (* a a) (* b b) (* c c)) )))\n      -1))\n",
  "  (cond\n    [(and (> a 0) (> b 0) (> c 0)) (sqrt (+ (* (/ (- (+ a b) c) 2)\n \
    \                                           (- (+ a b) c)\n                  \
    \                          (- (+ a b) c))\n                                  \
    \        (* (/ (- (+ a c) b) 2)\n                                            (-\
    \ (+ a c) b)\n                                            (- (+ a c) b))\n   \
    \                                       (* (/ (- (+ b c) a) 2)\n             \
    \                               (- (+ b c) a)\n                              \
    \              (- (+ b c) a))))]\n    [else -1]))\n", "  (cond [(and (&gt;= (+\
    \ a b) c)\n              (&gt;= (+ a c) b)\n              (&gt;= (+ b c) a))\n\
    \         (round (* 0.5 (* (+ a b) (- c (/ (+ a b) 2)))) 2)]\n        [else -1]))\n",
  "  (let* ([s (/ (+ a b c) 2.0)]\n         [area (sqrt (* s (- s a) (- s b) (- s\
    \ c)))])\n    (if (&lt;= a 0 b 0 c)\n        -1\n        (round area 2))))\n</code>\n\
    But I guess there is a better way to do it in Racket. \n\n\nA:\n\nYour solution\
    \ looks pretty good. I would just change the <code>let*</code> binding to be more\
    \ clear:\n<code>(define (triangle_area a b c)\n  (let* ([s (/ (+ a b c) 2.0)]\n\
    \         [area (* s (- s a) (- s b) (- s c))])\n    (if (&lt;= a 0 b 0 c)\n \
    \       -1\n        (round area 2))))\n</code>\nOr you could use <code>cond</code>\
    \ instead of <code>if</code>:\n<code>(define (triangle_area a b c)\n  (let* ([s\
    \ (/ (+ a b c) 2.0)]\n         [area (* s (- s a) (- s b) (- s c))])\n    (cond\n\
    \      [(&lt;= a 0 b 0 c) -1]\n      [else (round area 2)])))\n</code>\n", " \
    \ (let ([s (/ (+ a b c) 2)])\n    (if (or (< a 0) (< b 0) (< c 0)\n          \
    \  (>= a s) (>= b s) (>= c s))\n        -1\n        (round (* s (- s a) (- s b)\
    \ (- s c)) 2))))\n", "  (if (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n      (let\
    \ ([s (/ (+ a b c) 2)])\n        (sqrt (* s (- s a) (- s b) (- s c))))\n     \
    \ -1))\n", "  (define (is_triangle a b c)\n    (cond\n      [(or (< a 1) (< b\
    \ 1) (< c 1)) #f]\n      [(and (>= a (+ b c)) (>= b (+ a c)) (>= c (+ a b))) #t]\n\
    \      [else #f]))\n  (cond \n    [(not (is_triangle a b c)) -1]\n    [else (round\
    \ (* (sqrt (* (- (* a a) (* b b) (* c c)) 4)) 2) 2)]))\n", "  (cond ((&gt;= (+\
    \ a b) c) (* 0.5 (* a b (sin (acos (/ (- (* a a) (* b b) (* c c)) (* 2 a b)))))))\n\
    \        (else -1)))\n</code>\nBut this seems to be too complex and would be really\
    \ slow. Any better suggestions?\n\n\nA:\n\nA couple of tips:\n\nIt's better to\
    \ have meaningful function names. <code>&gt;=</code> is pronounced as \"greater\
    \ than or equal\".\n<code>area_triangle</code> is a lot more meaningful than <code>triangle_area</code>.\n\
    \nYou can use <code>let</code> to calculate the area of the triangle and the name\
    \ of the variable <code>area</code> is a lot more meaningful than <code>0.5 (*\
    \ a b (sin (acos (/ (- (* a a) (* b b) (* c c)) (* 2 a b))))))</code>.\n\nUse\
    \ <code>map</code> to rewrite the <code>*</code> in the area calculation.\n\n\
    Since the <code>acos</code> function returns a result in the range of <code>[0,\
    \ pi]</code>, you can just use <code>cos</code> instead of <code>acos</code>.\n\
    \nYou can use <code>define</code> to define named constants, such as <code>2</code>\
    \ and <code>pi</code>\n\n\n<code>#lang racket\n", "  (if (&gt;= a b c)\n     \
    \ -1\n      (round (* 0.5 (+ a b c)) 2)))\n</code>\nThis seems to work well enough.\
    \ However, it isn't nearly as expressive or neat as my Haskell solution:\n<code>module\
    \ TriangleArea where\n\n-- Given the lengths of the three sides of a triangle.\
    \ Return the area of\n-- the triangle rounded to 2 decimal points if the three\
    \ sides form a valid triangle. \n-- Otherwise return -1\n-- Three sides make a\
    \ valid triangle when the sum of any two sides is greater \n-- than the third\
    \ side.\n-- Example:\n-- triangle_area(3, 4, 5) == 6.00\n-- triangle_area(1, 2,\
    \ 10) == -1\ntriangle_area :: Integer -&gt; Integer -&gt; Integer -&gt; Integer\n\
    triangle_area a b c = round $ 0.5 * (fromIntegral a + fromIntegral b + fromIntegral\
    \ c)\n</code>\nI can't get the same effect with this function. Is there a different\
    \ way to write this function in Racket?\n\n\nA:\n\nRacket has a strong preference\
    \ for explicit expression of units. This means that the result of arithmetic operations\
    \ have to have a type that contains enough information to determine whether they\
    \ make sense or not. Your Racket example is not type-correct, because there is\
    \ no way to determine whether <code>0.5</code> has the right type to make the\
    \ multiplication make sense. An equivalent solution would be:\n<code>(require\
    \ math/float)\n", "  (cond\n    [(<= (+ a b) c) -1]\n    [(<= (+ a c) b) -1]\n\
    \    [(<= (+ b c) a) -1]\n    [else (round (* 0.5 (* a (sqrt (- (* b b) (* c c))))))]))\n",
  "  (let* ([s (/ (+ a b c) 2)]\n         [area (sqrt (* s (- s a) (- s b) (- s c)))])\n\
    \    (cond [(< a 0) -1]\n          [(< b 0) -1]\n          [(< c 0) -1]\n    \
    \      [(+ a b) (< c)]\n          [(+ a c) (< b)]\n          [(+ b c) (< a)]\n\
    \          [else (round (* 100 area))])))", "  (if (or (< a (+ b c))\n       \
    \   (< b (+ a c))\n          (< c (+ a b)))\n      -1\n      (define (half_perimeter)\n\
    \        (/ (+ a b c) 2))\n  (* (sqrt (- (half_perimeter) (* a (half_perimeter))))\n\
    \     (sqrt (- (half_perimeter) (* b (half_perimeter))))\n     (sqrt (- (half_perimeter)\
    \ (* c (half_perimeter)))))))\n", "  (cond\n    [(and (< a (+ b c)) (< b (+ a\
    \ c)) (< c (+ a b)))\n     (let* ((s (/ (+ a b c) 2))\n            (area (sqrt\
    \ (* s (- s a) (- s b) (- s c)))))\n       (cond\n         [(= (remainder area\
    \ 1) 0) (inexact->exact (round (* area 100)))]\n         [else (round (* area\
    \ 100))]))]\n    [else -1]))", "  (cond [(>= (+ a b) c) (define (area a b c) (*\
    \ 1/2 a b (sin c))) (* (area a b c) 100) (round (/ (area a b c) 100) 2)]\n   \
    \     [else -1]))\n", "  (if (< (+ a b) c) -1\n      (round (* 0.5 (* a (sin (acos\
    \ (/ (- (* b b) (* a a) (* c c)) (* 2 a b)))))) 2)))\n", "  (cond\n    [(or (and\
    \ (&lt; a 0) (&lt; b 0) (&lt; c 0))\n         (&lt; (+ a b) c)\n         (&lt;\
    \ (+ a c) b)\n         (&lt; (+ b c) a)) -1]\n    [else (round (* 0.5 (* (+ a\
    \ b) c)) 2)]))\n", "  (define (area a b c)\n    (/ (* a b (sqrt (+ (* a a) (*\
    \ b b) (* c c)))) 4))\n  (cond ((and (>= a (+ b c))\n              (>= b (+ a\
    \ c))\n              (>= c (+ a b)))\n         -1)\n        (else (round (* 100\
    \ (area a b c))))))\n", "  (cond [(and (< a (+ b c)) (< b (+ a c)) (< c (+ a b)))\n\
    \t (round (* .5 (- (+ a b c) (/ a b c))) 2)]\n\t[else -1]))\n", "  (define s (/\
    \ (+ a b c) 2))\n  (cond [(or (> a (+ b c)) (> b (+ a c)) (> c (+ a b))) -1]\n\
    \        [else (exact->inexact (* s (- s a) (- s b) (- s c)))]))\n", "  (if (>\
    \ (+ a b) c)\n      (if (> (+ a c) b)\n          (if (> (+ b c) a)\n         \
    \     (round (* 0.5 (+ a b c)) 2)\n              -1)\n          -1)\n      -1))\n\
    ```\n\nWrite a function `triangle_area` that takes three arguments, the lengths\
    \ of the\nthree sides of a triangle, `a`, `b`, and `c`, and returns the area of\
    \ the\ntriangle rounded to 2 decimal points if the three sides form a valid triangle.\n\
    Otherwise return -1.\n\nThe function should return:\n\n```", "  (cond [(and (>\
    \ (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n         (round (* 0.5 (* (+ a b c)\n\
    \                          (- (+ a b c) a)\n                          (- (+ a\
    \ b c) b)\n                          (- (+ a b c) c))))]\n        [else -1]))\n",
  "  (define s (/ (+ a b c) 2))\n  (define (get-area v)\n    (sqrt (- (* s (- s v)))))\n\
    \  (cond [(or (< a 1) (< b 1) (< c 1)) -1]\n        [(or (< (- a b) c) (< (- a\
    \ c) b) (< (- b c) a)) -1]\n        [else (round (* (get-area a) 100) 2)]))",
  "  (define (is-valid a b c)\n    (and (< a (+ b c))\n         (< b (+ a c))\n  \
    \       (< c (+ a b))))\n  (define (area a b c)\n    (/ (* a b) 2))\n  (if (is-valid\
    \ a b c)\n      (area a b c)\n      -1))\n", "  (if (< (+ a b) c)\n      -1\n\
    \      (round (* (/ (sqrt (+ (* (- a (/ a 2)) (- a (/ a 2)))\n               \
    \        (* (- b (/ b 2)) (- b (/ b 2)))\n                       (* (- c (/ c\
    \ 2)) (- c (/ c 2)))))\n                  2)\n              2))))\n", "  (cond\n\
    \    [(and (< a (+ b c)) (< b (+ a c)) (< c (+ a b))) (* 0.5 (+ (- b) (- c)) a)]\n\
    \    [else -1]))", "  (define (isValidTriangle)\n    (and (>= a b c)\n       \
    \  (>= b c a)\n         (>= c a b)))\n  (if (isValidTriangle)\n      (* (/ (+\
    \ a b c) 2)\n         (sqrt (- (square a)\n                  (* b b)\n       \
    \           (* c c)\n                  (* 2 b c)\n                  (* 2 a c)\n\
    \                  (* 2 a b))))\n      -1))\n", "  (define (calc-area a b c)\n\
    \    (sqrt (* (* (- a b) (- a c) (- b c))\n            (/ 4\n               (cond\n\
    \                 [(and (> a 0) (> b 0) (> c 0))\n                  (+ (/ a b)\
    \ (/ b c) (/ c a))]\n                 [else 0])))))\n  (cond\n    [(< (- (+ a\
    \ b) c) 0) -1]\n    [(< (- (+ a c) b) 0) -1]\n    [(< (- (+ b c) a) 0) -1]\n \
    \   [else\n     (round (* (calc-area a b c) 100) 2)]))\n", "  (if (and (&gt; (+\
    \ a b) c)\n           (&gt; (+ a c) b)\n           (&gt; (+ b c) a))\n      (*\
    \ (/ 1 2.0) a b (sin (acos (/ (- (+ (* a a) (* b b)) (* c c)) (* 2 a b))))))\n\
    \      -1)\n", "  (cond [(and (<= (+ a b) c) (<= (+ a c) b) (<= (+ b c) a)) -1]\n\
    \        [else (round (* (sqrt (* (* (- a (/ b 2)) (- a (/ b 2))) (* (- b (/ a\
    \ 2)) (- b (/ a 2))))) 2))]))\n", "  (let ((area (sqrt (+ (* (- (+ a b) c) (-\
    \ (+ a b) c))\n                      (* (- (+ a c) b) (- (+ a c) b))\n       \
    \               (* (- (+ b c) a) (- (+ b c) a))))))\n    (if (&lt; 0 area) (round\
    \ (* area 100) 2) -1)))\n</code>\n", "  (define (is-valid-triangle a b c)\n  \
    \  (or (and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n        #f))\n  (define\
    \ (heron s1 s2 s3)\n    (/ (* (+ s1 s2 s3) (- s1 s2 s3) (- s2 s3) (- s3 s1)) 4))\n\
    \  (if (is-valid-triangle a b c)\n      (heron a b c)\n      -1))\n", "  (define\
    \ area\n    (cond\n      [(and (> a 0) (> b 0) (> c 0))\n       (/ (sqrt (* (+\
    \ (* a a) (* b b)) (* (- (* a a) (* b b)) (* c c)))) 4)]\n      [else -1]))\n\
    \  (string-append (number->string area) \".00\"))\n</code>\nAnd, my Test Case:\n\
    <code>#lang racket\n", "  (let ([s (* 0.5 (+ a b c))])\n    (if (and (> a 0) (>\
    \ b 0) (> c 0) (>= (- s a) a) (>= (- s b) b) (>= (- s c) c))\n        (format\
    \ \"~[~.2f~]\" (* s (* (- s a) (- s b) (- s c))))\n        -1)))\n", "  (define\
    \ (sum2 a b) (+ a b))\n  (define (sum3 a b c) (+ a b c))\n  (define (area a b\
    \ c)\n    (sqrt (+ (* (- a (/ (sum2 a b) 2)) (- a (/ (sum2 a b) 2)))\n       \
    \     (* (- b (/ (sum2 a b) 2)) (- b (/ (sum2 a b) 2))))))\n  (cond ((>= a 0)\
    \ (cond ((>= b 0) (cond ((>= c 0) (cond\n                                    \
    \            ((> a (+ b c)) -1)\n                                            \
    \    ((> b (+ a c)) -1)\n                                                ((> c\
    \ (+ a b)) -1)\n                                                (else (round (*\
    \ 100 (area a b c))))))\n                                     (else -1)))\n  \
    \                       (else -1)))\n        (else -1)))", "  (if (and (> a 0)\
    \ (> b 0) (> c 0))\n      (if (and (> a (+ b c)) (> b (+ a c)) (> c (+ a b)))\n\
    \          (round (exact->inexact (/ (* a b) 2.0)))\n          -1)\n      -1))\n",
  "  (define (isvalid a b c)\n    (cond\n      [(> (+ a b) c) #t]\n      [(> (+ a\
    \ c) b) #t]\n      [(> (+ b c) a) #t]\n      [else #f]))\n  (cond\n    [(isvalid\
    \ a b c)\n     (round (* 0.5 (- (* a a)\n                      (* b b)\n     \
    \                 (* c c))\n                    100))]\n    [else -1]))\n", " \
    \ (cond\n    ((and (< (- a b) c) (< (- b c) a) (< (- c a) b)) (+ (* a b) (* b\
    \ c) (* c a)))\n    (else -1)))\n", "  (cond [(and (> (+ a b) c)\n           \
    \   (> (+ a c) b)\n              (> (+ b c) a))\n         (* (/ (+ a b) 2)\n \
    \           (sqrt (- (* (- a (/ (+ a b) 2))\n                        (- a (/ (+\
    \ a b) 2)))\n                   (+ (* (- b (/ (+ a b) 2))\n                  \
    \      (- b (/ (+ a b) 2)))\n                      (* (- c (/ (+ a b) 2))\n  \
    \                       (- c (/ (+ a b) 2)))))))]\n        [else -1]))\n", " \
    \ (define (heron)\n    (sqrt (+ (* (- (+ a b) c) (- (+ a c) b) (- (+ b c) a))\
    \ a b c)))\n  (define (is-triangle)\n    (and (&gt;= a 0) (&gt;= b 0) (&gt;= c\
    \ 0)\n         (&gt;= a (- (+ b c))) (&gt;= b (- (+ a c))) (&gt;= c (- (+ a b)))))\n\
    \  (cond ((is-triangle) (* .5 (heron)))\n        (else -1)))\n", "  (define s\
    \ (* 0.5 (+ a b c)))\n  (define area (sqrt (- s a) (* (- s b) (- s c))))\n  (if\
    \ (or (not (number? area)) (negative? area))\n      -1\n      (round (* area 100)\
    \ 2)))\n</code>\n", "  (cond\n    [(and (>= a b) (>= a c))\n     (- a (/ (abs\
    \ (- a b)) 2))]\n    [(and (>= b a) (>= b c))\n     (- b (/ (abs (- b a)) 2))]\n\
    \    [(and (>= c a) (>= c b))\n     (- c (/ (abs (- c a)) 2))]\n    [else\n  \
    \   -1]))\n", "  (cond\n    [(or (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))\n\
    \     (round (* (sqrt (+ (* (- a (/ a 2)) (- a (/ a 2)))\n                   \
    \    (* (- b (/ b 2)) (- b (/ b 2)))\n                       (* (- c (/ c 2))\
    \ (- c (/ c 2)))))\n                2))]\n    [else -1]))\n", "  (if (and (>=\
    \ (+ a b) c) (>= (+ a c) b) (>= (+ b c) a))\n      (round (* (sqrt (+ (* (- a\
    \ (/ a 2)) (- a (/ a 2))) (* (- b (/ b 2)) (- b (/ b 2))) (* (- c (/ c 2)) (-\
    \ c (/ c 2))))) 2))\n      -1))", "  (if (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n\
    \      (if (and (&gt; (+ a b) c) (&gt; (+ a c) b) (&gt; (+ b c) a))\n        \
    \  (round (* 0.5 (sqrt (- (* (+ a b c) (* (+ a b c)) (* (- a b c) (- a b c)))))\
    \ 2))\n          -1)\n      -1))\n</code>\nI have this test case. (test-case (triangle_area\
    \ 3 4 5) 6.00) \nHowever, the result is incorrect. \nSo, what's wrong with my\
    \ code?\nThanks.\n\n\nA:\n\nYour code seems to be correct but the test case is\
    \ wrong.  It returns the correct result but it must return <code>6.00</code> instead\
    \ of <code>6</code>.\nI was able to confirm this by changing the test case:\n\
    <code>(test-case (triangle_area 3 4 5) 6.00)", "  (cond ((and (< (+ a b) c) (<\
    \ (+ a c) b) (< (+ b c) a)) -1)\n        (else (/ (+ (* a c) (* b c) (* a b))\
    \ 2.0))))\n", "  (define (is-valid? a b c)\n    (or (and (&gt;= a b) (&gt;= b\
    \ c))\n        (and (&gt;= a c) (&gt;= c b))\n        (and (&gt;= b a) (&gt;=\
    \ a c))))\n  (define (area a b c)\n    (* .5 (- a b c)))\n  (cond ((not (is-valid?\
    \ a b c)) -1)\n        (else (truncate (* 100 (area a b c))))))\n</code>\nI wonder\
    \ if I am over-thinking this. I'd appreciate any feedback.\nWhat can I do to improve\
    \ this code?\n\n\nA:\n\nEverything looks great!\nMy only two cents:\n\n<code>triangle_area</code>\
    \ could be rewritten as an <code>and</code> expression.\nThe <code>and</code>\
    \ expression is probably more readable because it's easier to quickly see that\
    \ it is a boolean expression that evaluates all its arguments.\nIt's usually best\
    \ to handle the \"the most typical case\" first in a <code>cond</code> expression.\
    \ In this case, that means the case where the three sides form a valid triangle.\
    \ \nYou might have seen <code>cond</code> expressions where the \"default\" case\
    \ is handled last. \nIn a language like Scheme, there's really no difference between\
    \ the \"default\" case and the \"falsey\" case. It's just that having the \"true\"\
    \ case first in a <code>cond</code> expression is cleaner because it doesn't require\
    \ the use of an <code>else</code> clause.\n\n", "  (define (positive? x) (and\
    \ (> x 0) #t))\n  (cond\n    [(not (and (positive? a) (positive? b) (positive?\
    \ c))) -1]\n    [(not (or (> (+ a b) c) (> (+ a c) b) (> (+ b c) a))) -1]\n  \
    \  [else (round (* 0.5 (- (* a a) (- (* b b) (* c c)))) 2)]))\n", "  (cond [(and\
    \ (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)) (round (* 0.5 (+ a b c)) 2)] [else\
    \ -1]))\n", "  (cond [(and (> a 0) (> b 0) (> c 0)) (cond [(and (> (+ a b) c)\
    \ (> (+ a c) b) (> (+ b c) a)) (round (* (/ (+ a b c) 2) (sqrt (- (* (- (+ a b\
    \ c) a) (* (- (+ a b c) b) (* (- (+ a b c) c) (- (+ a b c) 4))))))) 2)] [else\
    \ -1])] [else -1]))\n", "  (cond ((and (< (+ a b) c) (< (+ a c) b) (< (+ b c)\
    \ a)) -1)\n        (else (* 0.5 (* a (sqrt (- (* b b) (* (* a a) (/ (- c c) (-\
    \ b b))))))))))\n", "  (cond\n    [(> (+ a b) c) (define s (/ (+ a b c) 2))\n\
    \                          (* (/ s (- s a)) (/ s (- s b)) (/ s (- s c)) (sqrt))]\n\
    \    [else -1]))\n", "  (if (and (> (+ a b) c)\n           (> (+ a c) b)\n   \
    \        (> (+ b c) a))\n      (round (* 0.5 (* a b)))\n      -1))\n", "  (cond\n\
    \    [(and (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)) (* 0.5 (- a (* b c)))]\n\
    \    [else -1]))\n", "  (let ([s (+ a b c)])\n    (/ (* s (- s a) (- s b) (- s\
    \ c)) 16.0)))\n\n", "  (if (and (&gt;= a b) (&gt;= a c))\n      (-&gt;&gt;\n \
    \      (list a b c)\n       (apply (-&gt;&gt; sigma))\n       (/ 2.0))\n     \
    \ -1))\n", "  (if (and (and (&gt; a 0) (&gt; b 0) (&gt; c 0))\n           (and\
    \ (&gt; (+ a b) c)\n                (&gt; (+ a c) b)\n                (&gt; (+\
    \ b c) a)))\n      (round (* (sqrt (+ (* (- a (/ a 2)) (- a (/ a 2))) (* (- b\
    \ (/ b 2)) (- b (/ b 2))) (* (- c (/ c 2)) (- c (/ c 2))))) 2))\n      -1))\n\
    </code>\nI think my code is correct. However when I submit it I get following\
    \ error:\n<code>Error: Test 2 asserts &lt;'10.03&gt;, not &lt;'10.0299&gt;\n</code>\n\
    Why is that? I'm rounding it to 2 decimals.\n\n\nA:\n\nThe answer should be <code>10.03</code>\
    \ and not <code>10.0299</code> because the area is just the result of the <code>sqrt</code>\
    \ function multiplied by 2. So, you need to round the value before multiplying\
    \ it by 2.\n<code>(define (triangle_area a b c)\n  (if (and (and (&gt; a 0) (&gt;\
    \ b 0) (&gt; c 0))\n           (and (&gt; (+ a b) c)\n                (&gt; (+\
    \ a c) b)\n                (&gt; (+ b c) a)))\n      (round (* 2 (sqrt (+ (* (-\
    \ a (/ a 2)) (- a (/ a 2)))\n                           (* (- b (/ b 2)) (- b\
    \ (/ b 2)))\n                           (* (- c (/ c 2)) (- c (/ c 2)))))\n  \
    \                2))\n      -1))\n</code>\n", "  (let* ([p (/ (+ a b c) 2)]\n\
    \         [s (sqrt (- (* p (- p a))\n                     (* p (- p b))\n    \
    \                 (* p (- p c))))])\n    (cond [(not (and (positive? a)\n    \
    \                 (positive? b)\n                     (positive? c))) -1]\n  \
    \        [(or (< a (+ b c))\n               (< b (+ a c))\n               (< c\
    \ (+ a b))) -1]\n          [else (round (* 100 s) 2)])))\n", "  (cond\n    ((and\
    \ (&gt;= a 0) (&gt;= b 0) (&gt;= c 0))\n     (let ((s (/ (+ a b c) 2)))\n    \
    \   (* (- s a) (- s b) (- s c))))\n    (else -1)))\n", "  (define (find-area a\
    \ b c)\n    (if (and (not (<= b c)) (<= a (+ b c)))\n        (round (* 0.5 (*\
    \ a (- c b))))\n        -1))\n  (define (is-triangle? a b c)\n    (cond\n    \
    \  ((and (not (<= b c)) (<= a (+ b c))) #t)\n      ((and (not (<= a c)) (<= b\
    \ (+ a c))) #t)\n      ((and (not (<= a b)) (<= c (+ a b))) #t)\n      (else #f)))\n\
    \  (find-area a b c))\n", "  (define (is-valid-triangle a b c)\n    (and (> a\
    \ 0) (> b 0) (> c 0) (> (+ a b) c) (> (+ a c) b) (> (+ b c) a)))\n  (define (heron\
    \ a b c)\n    (let* ([s (/ (+ a b c) 2)]\n           [area (sqrt (* s (- s a)\
    \ (- s b) (- s c)))])\n      (* 0.5 area)))\n  (if (is-valid-triangle a b c)\n\
    \      (format \"~0,2f\" (heron a b c))\n      -1))\n", "  (if (and (> a 0) (>\
    \ b 0) (> c 0))\n      (if (<= (+ a b) c)\n          -1\n          (define (mid\
    \ a b c)\n            (/ (+ a b c) 3))\n          (define (s a b c)\n        \
    \    (* (- (+ a b c) a) (- (+ a b c) b) (- (+ a b c) c)))\n          (define (area\
    \ a b c)\n            (* (sqrt (s a b c)) (mid a b c)))\n          (round (area\
    \ a b c) 2))\n      -1))\n", "  (cond [(< a 0) -1]\n        [(< b 0) -1]\n   \
    \     [(< c 0) -1]\n        [(<= (+ a b) c) -1]\n        [(<= (+ a c) b) -1]\n\
    \        [(<= (+ b c) a) -1]\n        [else (apply + (map sqrt (list a b c)))]))\n",
  "  (cond\n    [(> a b) \n     (cond\n       [(> b c) (cond [(> (+ b c) a) (* (/\
    \ (+ a b c) 2) (- (/ (+ a b c) 2) c)) -1])]\n       [(> c b) (cond [(> (+ c b)\
    \ a) (* (/ (+ a b c) 2) (- (/ (+ a b c) 2) b)) -1])])]\n    [(> b a) \n     (cond\n\
    \       [(> a c) (cond [(> (+ a c) b) (* (/ (+ a b c) 2) (- (/ (+ a b c) 2) c))\
    \ -1])]\n       [(> c a) (cond [(> (+ c a) b) (* (/ (+ a b c) 2) (- (/ (+ a b\
    \ c) 2) a)) -1])])]))\n", "  (cond\n    [(<= a b c) -1]\n    [(<= b a c) -1]\n\
    \    [(<= c a b) -1]\n    [else (define p (/ (+ a b c) 2))\n          (sqrt (*\
    \ p (- p a) (- p b) (- p c)))]))", "  (cond ((&gt; a 0) (cond ((&gt; b 0) (cond\
    \ ((&gt; c 0)\n        (+ (* (- a c) (- b c)) (/ (* (- a b) (- a c)) 2)))\n  \
    \      (-1))\n      (-1))\n    (-1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
