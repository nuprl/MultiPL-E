name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  ;; >>> is_bored(\"Hello world\")\n;; 0\n;; >>> is_bored(\"The sky is blue. The sun\
  \ is shining. I love this weather\")\n;; 1\n(define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (count-matches \"I\" (split (regexp-split #rx\"[.!?]\" S) \" \")))\n",
  "  (define (sum L)\n    (if (empty? L)\n        0\n        (+ (first L) (sum (rest\
    \ L)))))\n  (sum (map (lambda (p) (if (regexp-match #rx\"^I \" p) 1 0))\n    \
    \        (regexp-split #rx\"[.?!]\" S))))\n", "  (if (string-empty? S)\n     \
    \ 0\n      (if (string-prefix? \"I\" S)\n          (+ 1 (is_bored (substring S\
    \ (+ 1 (string-index S #\\.)))))\n          (is_bored (substring S (+ 1 (string-index\
    \ S #\\.)))))))\n", "  (count (lambda (s) (string=? (string-take s 1) \"I\"))\n\
    \         (regexp-split #rx\"\\.|\\!|\\?\" S)))", "  (cond\n    [(empty? S) 0]\n\
    \    [(empty? (string-trim S)) 0]\n    [(string=? (string-take S (string-length\
    \ \"I\")) \"I\") 1]\n    [else (is_bored (string-drop S 1))]))\n```\n\n### Return\
    \ a string with words in reverse order\n\n```racket\n#lang racket\n", "  (define\
    \ (is_bored-rec S acc)\n    (cond [(empty? S) acc]\n          [(eq? (string-ref\
    \ S 0) #\\I) (is_bored-rec (rest S) (+ acc 1))]\n          [else (is_bored-rec\
    \ (rest S) acc)]))\n  (define (clean-string S)\n    (cond [(empty? S) empty]\n\
    \          [(or (eq? (string-ref S 0) #\\.)\n               (eq? (string-ref S\
    \ 0) #\\?)\n               (eq? (string-ref S 0) #\\!)) (rest S)]\n          [else\
    \ (cons (string-ref S 0) (clean-string (rest S)))]))\n  (is_bored-rec (clean-string\
    \ S) 0))\n", "  (define (myreverse L)\n    (let loop ([L L] [out '()])\n     \
    \ (if (null? L)\n          out\n          (loop (cdr L) (cons (car L) out)))))\n\
    \  (define (split x L)\n    (if (null? L)\n        (list '())\n        (let ([h\
    \ (car L)] [t (cdr L)])\n          (if (equal? x h)\n              (list '())\n\
    \              (let ([r (split x t)])\n                (cons (cons h (car r))\
    \ (cdr r)))))))\n  (for/sum ([x (in-list (myreverse (split #\\! (string->list\
    \ S))))])\n    (local [(define (findword str)\n              (cond\n         \
    \       [(empty? str) #f]\n                [(char=? (string-ref str 0) #\\I) #t]\n\
    \                [else (findword (substring str 1))]))]\n      (if (findword (string-copy\
    \ x))\n          1\n          0))))\n", "  (define (is-first-word-I s)\n    (string=?\
    \ (substring s 0 1) \"I\"))\n  (define (delimiter? c)\n    (or (char=? c #\\.)\
    \ (char=? c #\\?) (char=? c #\\!)))\n  (define (count-boredoms words)\n    (if\
    \ (null? words)\n        0\n        (+ (if (is-first-word-I (car words)) 1 0)\n\
    \           (count-boredoms (cdr words)))))\n  (count-boredoms (regexp-split #rx\"\
    [\\.\\?!]\" S)))\n", "  (count (lambda (W)\n           (and (= (string-length\
    \ W) 1)\n                (string=? \"I\" W)))\n         (split (regexp #rx\"[.?!]\"\
    ) S)))\n", "  (if (string=? S \"\")\n      0\n      (if (string-match \"I\" S)\n\
    \          (+ 1 (is_bored (substring S (string-index \"I\" S) (string-length S))))\n\
    \          (is_bored (substring S 1 (string-length S))))))\n", "  (cond ((string=?\
    \ S \"\") 0)\n        ((string-match-ci \"^I\" S) 1)\n        (else (is_bored\
    \ (string-trim-both S #\\space)))))\n", "  (cond\n    [(string-empty? S) 0]\n\
    \    [(string-prefix? \"I\" S) (+ 1 (is_bored (string-drop S (string-length \"\
    I\"))))]\n    [else (is_bored (string-drop S 1))]))\n", "  (count-matches-from-regex\
    \ (regexp \"I\") S))\n```\n\nThe Ruby example is exactly the same.\n\n```ruby\n\
    # You'll be given a string of words, and your task is to count the number\n# of\
    \ boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
    \ are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored(\"Hello world\"\
    )\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
    )\n# 1\ndef is_bored(s)\n  s.scan(/I/).count\nend\n```\n\nThe Python example is\
    \ exactly the same.\n\n```python\n# You'll be given a string of words, and your\
    \ task is to count the number\n# of boredoms. A boredom is a sentence that starts\
    \ with the word \"I\".\n# Sentences are delimited by '.', '?' or '!'.\n# For example:\n\
    # >>> is_bored(\"Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun\
    \ is shining. I love this weather\")\n# 1\nimport re\ndef is_bored(s):\n  return\
    \ len(re.findall(r'I', s))\n```\n\nThe Rust example is exactly the same.\n\n```rust\n\
    // You'll be given a string of words, and your task is to count the number\n//\
    \ of boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences\
    \ are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello\
    \ world\")\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love\
    \ this weather\")\n// 1\nuse regex::Regex;\nfn is_bored(s: &str) -> usize {\n\
    \  let re = Regex::new(r\"I\").unwrap();\n  re.find_iter(s).count()\n}\n```\n\n\
    To solve this problem you will learn all the basic building blocks of\nregular\
    \ expressions, and get a good idea of the amazing power that\n", "  (if (string-null?\
    \ S)\n      0\n      (if (eq? (string-ref S 0) #\\I)\n          (+ 1 (is_bored\
    \ (substring S (string-index S #\\.) 1)))\n          (is_bored (substring S (string-index\
    \ S #\\.) 1)))))\n```\n\nNow, if I run this, it just goes boom:\n\n```\n$ racket\
    \ is_bored.rkt\nobject: string\n  expected: number\n```\n\nHow many boredoms are\
    \ there in that string? Seems like something a computer\ncould figure out...\n\
    \n```racket\n#lang racket\n", "  (define (len-sb S)\n    (cond ((null? S) 0)\n\
    \          ((and (string=? (substring S 0 1) \"I\")\n                (or (string=?\
    \ (substring S 1 2) \" \")\n                    (string=? (substring S 1 2) \"\
    !\")\n                    (string=? (substring S 1 2) \"?\")\n               \
    \     (string=? (substring S 1 2) \".\")))\n           1)\n          (else 0)))\n\
    \  (cond ((string=? S \"\") 0)\n        ((string=? S \" \") 0)\n        ((string=?\
    \ S \"  \") 0)\n        ((string=? S \"   \") 0)\n        ((string=? S \"    \"\
    ) 0)\n        ((string=? S \"     \") 0)\n        ((string=? S \"      \") 0)\n\
    \        ((string=? S \"       \") 0)\n        ((string=? S \"        \") 0)\n\
    \        ((string=? S \"         \") 0)\n        ((string=? S \"          \")\
    \ 0)\n        ((string=? S \"           \") 0)\n        ((string=? S \"      \
    \      \") 0)\n        ((string=? S \"             \") 0)\n        ((string=?\
    \ S \"              \") 0)\n        ((string=? S \"               \") 0)\n   \
    \     ((string=? S \"                \") 0)\n        ((string=? S \"         \
    \        \") 0)\n        ((string=? S \"                  \") 0)\n        ((string=?\
    \ S \"                   \") 0)\n        ((string=? S \"                    \"\
    ) 0)\n        ((string=? S \"                     \") 0)\n        ((string=? S\
    \ \"                      \") 0)\n        ((string=? S \"                    \
    \   \") 0)\n        ((string=? S \"                        \") 0)\n        ((string=?\
    \ S \"                         \") 0)\n        ((string=? S \"               \
    \           \") 0)\n        ((string=? S \"                           \") 0)\n\
    \        ((string=? S \"                            \") 0)\n        ((string=?\
    \ S \"                             \") 0)\n        ((string", "  (equal? (substring\
    \ S 0 1) \"I\"))\n", "  (cond\n    [(string=? S \"\") 0]\n    [(string=? (string-take\
    \ S 1) \"I\") (+ 1 (is_bored (string-drop S 1)))]\n    [else (is_bored (string-drop\
    \ S 1))]))\n</code>\n", "  (let loop ([s (string-&gt;list S)]\n             [boredoms\
    \ 0])\n    (cond [(empty? s) boredoms]\n          [(equal? (car s) #\\I) (loop\
    \ (cdr s) (+ boredoms 1))]\n          [else (loop (cdr s) boredoms)])))\n</code>\n",
  "  (let loop ([bored 0] [i 0])\n    (cond [(empty? S) bored]\n          [(string=?\
    \ (get-token S i) \"I\") (loop (+ bored 1) (+ i 1))]\n          [else (loop bored\
    \ (+ i 1))])))\n", "  (define (is_bored-inner cur-count S)\n    (if (empty? S)\n\
    \        cur-count\n        (if (and (equal? (first S) #\\I)\n               \
    \  (or (equal? (second S) #\\ )\n                     (equal? (second S) #\\.)\n\
    \                     (equal? (second S) #\\!)\n                     (equal? (second\
    \ S) #\\?)))\n            (is_bored-inner (+ cur-count 1) (rest (rest S)))\n \
    \           (is_bored-inner cur-count (rest S)))))\n  (is_bored-inner 0 S))\n",
  "  (define (trimmed-string S)\n    (substring S (string-index S \"I\") (+ 1 (string-index\
    \ S \"I\"))))\n  (define (is-cap I)\n    (eq? (string-upcase I) I))\n  (define\
    \ (first-word S)\n    (substring S 0 (string-index S \" \")))\n  (cond\n    [(null?\
    \ S) 0]\n    [(and (not (string-empty? S))\n          (string=? (first-word S)\
    \ \"I\")\n          (is-cap (first-word S))) 1]\n    [else 0]))", "  (cond\n \
    \   [(empty? S) 0]\n    [(regexp-match #rx\"^I\" S) (+ 1 (is_bored (regexp-replace\
    \ #rx\"^I[^.]*\\.\" \"\" S)))]\n    [else (is_bored (regexp-replace #rx\"[^I]*[.?!]\"\
    \ \"\" S))]))\n", "  (let* ([A (string-split S)]\n         [B (map (lambda (W)\
    \ (regexp-match #rx\"^I\" W)) A)])\n    (count B)))\n", "  (define (is-start-with-I?\
    \ x)\n    (string=? \"I\" (substring x 0 1)))\n  (define (string-to-sentences\
    \ x)\n    (regexp-split #rx\"[.?!]\" x))\n  (length (filter is-start-with-I? (string-to-sentences\
    \ S))))", "  (cond\n    [(string=? (string-trim S) \"\") 0]\n    [(string=? (string-trim\
    \ S) \"I\") 1]\n    [else (is_bored (string-append (string-trim S) \" I\"))]))\n",
  "  (count (lambda (w) (string=? w \"I\")) (string-split S \"[.?!]\")))\n", "  (count\
    \ (string-split S) #:on #\\space \"I\" #:before #\\.))\n", "  (cond [(empty? S)\
    \ 0]\n        [(string=? (string-trim (string-split (string-trim S) \".\") 0)\
    \ \"I\")\n         (add1 (is_bored (string-join (cdr (string-split (string-trim\
    \ S) \".\")) \".\")))]\n        [else (is_bored (string-join (cdr (string-split\
    \ (string-trim S) \".\")) \".\"))]))\n", "  (cond\n    [(empty? S) 0]\n    [(and\
    \ (equal? (first S) #\\I)\n          (char-whitespace? (second S))) +1]\n    [else\
    \ (is_bored (rest S))]))\n", "  ;; The first step is to split the string into\
    \ words\n  (let ([W (string-split S #\\space)])\n    ;; Then check each word to\
    \ see if it starts with I\n    (for/sum ([W W])\n      (if (string-prefix? \"\
    I\" W)\n          1\n          0))))\n", "  (regexp-match #rx\"I[^?.!]*[.?!]\"\
    \ S))\n```\n\n### Run tests\n\n```bash\n$ pytest test_is_bored.py\n```\n\n###\
    \ Run tests with doctest\n\n```bash\n$ python test_is_bored.py -v\n```\n\n###\
    \ Run tests with pytest, using command line parameters\n\n```bash\n$ pytest test_is_bored.py\
    \ -s -k \"test_is_bored_6\"\n```\n\n### Run tests with pytest, using Tox\n\n```bash\n\
    $ tox\n```\n\n### Run tests with Pytest, using multiple Python versions\n\n```bash\n\
    $ pipenv run tox\n```\n\n### Run tests with Pytest, using tox, with coverage report\n\
    \n```bash\n$ pipenv run tox -e py37-pytest-cov\n```\n\n### Run tests with Pytest,\
    \ using tox, with coverage report, and open coverage report in browser\n\n```bash\n\
    $ pipenv run tox -e py37-pytest-cov -- --cov-report html --cov-report term-missing\
    \ --cov=. && open htmlcov/index.html\n```\n\n## Documentation\n\n### Run documentation\
    \ tests\n\n```bash\n$ python test_is_bored.py -v\n```\n\n### Run documentation\
    \ tests, using Tox\n\n```bash\n$ tox -e docs\n```\n\n### Run documentation tests,\
    \ using Pytest, using Tox\n\n```bash\n$ pipenv run tox -e docs\n```\n\n## Code\
    \ style\n\n### Lint code style\n\n```bash\n$ pycodestyle is_bored.py\n```\n\n\
    ### Auto fix code style\n\n```bash\n$ autopep8 --in-place --aggressive --aggressive\
    \ is_bored.py\n```\n\n### Test code style\n\n```bash\n$ tox -e pycodestyle\n```\n\
    \n## Code formatting\n\n### Lint code formatting\n\n```bash\n$ python -m black\
    \ --check is_bored.py\n```\n\n### Format code formatting\n\n```bash\n$", "  (define\
    \ (is_bored-iter l c)\n    (if (empty? l)\n        c\n        (if (and (equal?\
    \ (first l) \"I\")\n                 (not (null? (second l))))\n            (is_bored-iter\
    \ (rest l) (+ c 1))\n            (is_bored-iter (rest l) c))))\n  (is_bored-iter\
    \ (string-tokenize S) 0))\n</code>\n<code>racket</code> has a function that split\
    \ strings into a list of words, so the solution above is similar to the Haskell's\
    \ version.\n\nPlease note that in my solutions, the counts are accumulated from\
    \ the end of the sentence to the beginning. This is because I need to check if\
    \ the sentence starts with \"I\" and it's not the first sentence in the string.\n\
    So for example:\n<code>&gt;&gt;&gt; is_bored(\"I love this weather\")\n1\n&gt;&gt;&gt;\
    \ is_bored(\"I love this weather. The sky is blue\")\n2\n&gt;&gt;&gt; is_bored(\"\
    I love this weather. The sky is blue. I love this weather\")\n3\n</code>\n", " \
    \ (if (string-empty? S)\n      0\n      (if (string-prefix? \"I\" S)\n       \
    \   (+ 1 (is_bored (string-trim-both (substring S 1))))\n          (is_bored (string-trim-both\
    \ (substring S 1))))))\n", "  (define (count-boredoms S S')\n    (if (equal? \"\
    \" S)\n        (if (equal? \"I\" (string-trim S'))\n            1\n          \
    \  0)\n        (if (equal? (substring S 0 1) \"I\")\n            (count-boredoms\
    \ (substring S 1) (string-append S' (substring S 0 1)))\n            (count-boredoms\
    \ (substring S 1) S'))))\n  (count-boredoms S \"\"))\n", "  (for/fold ([bored\
    \ 0]) ([i (in-string S)])\n    (if (and (char=? (string-ref S i) #\\I)\n     \
    \        (or (char=? (string-ref S (- i 1)) #\\.)\n                 (char=? (string-ref\
    \ S (- i 1)) #\\!)\n                 (char=? (string-ref S (- i 1)) #\\?)))\n\
    \        (+ bored 1)\n        bored)))\n", "  (regexp-match* #rx\"I[a-zA-Z\\s]*[.!?]\"\
    \ S))\n", "  (count (regexp-match #rx\"^I\" S)))\n</code>\nIs there a better way\
    \ to do it using only a single <code>regexp-match</code> call?\n", "  (cond\n\
    \    [(empty? S)\n     0]\n    [(string=? (substring S 0 1) \"I\")\n     (+ 1\
    \ (is_bored (substring S 1 (- (string-length S) 1))))]\n    [else\n     (is_bored\
    \ (substring S 1 (- (string-length S) 1)))]))\n", "  (cond [(empty? S) 0]\n  \
    \      [(regexp-match? #rx\"^I\" S) (+ 1 (is_bored (second (regexp-match #rx\"\
    ^I[.?!].*\" S))))]\n        [else (is_bored (second (regexp-match #rx\"[.?!].*\"\
    \ S)))]))\n", "  (length (filter (lambda (x) (equal? (substring x 0 1) \"I\"))\n\
    \                  (regexp-split #rx\"[?!.]\" S))))\n", "  (letrec ([rs (split-string\
    \ S \"\\.\" \"\\?\" \"\\!\")]\n           [bored 0])\n    (for ([s rs])\n    \
    \  (if (string-contains s \"I\")\n          (set! bored (+ bored 1))))\n    bored))\n",
  "  (length (filter (lambda (s) (string=? (car (string-split s)) \"I\"))\n      \
    \            (string-split S \"\\\\.|!|\\\\?\"))))", "  (cond\n    [(null? S)\
    \ 0]\n    [(or (equal? (substring S 0 3) \"The\")\n         (equal? (substring\
    \ S 0 5) \"Hello\"))\n     (is_bored (substring S (add1 (string-length (car (regexp-match\
    \ #rx\"^The|^Hello\" S))))))]\n    [(equal? (substring S 0 1) \"I\") (add1 (is_bored\
    \ (substring S (add1 (string-length (car (regexp-match #rx\"^I\" S)))))))]\n \
    \   [else (is_bored (substring S (add1 (string-length (car (regexp-match #rx\"\
    ^[^I]*\" S))))))]))\n```\n\n```python\ndef is_bored(S):\n    if len(S) == 0:\n\
    \        return 0\n    elif S[:3] == \"The\" or S[:5] == \"Hello\":\n        return\
    \ is_bored(S[S.find(\" \") + 1:])\n    elif S[0] == \"I\":\n        return 1 +\
    \ is_bored(S[S.find(\" \") + 1:])\n    else:\n        return is_bored(S[S.find(\"\
    \ \") + 1:])\n```\n\n```ruby\ndef is_bored(s)\n  return 0 if s.length == 0\n \
    \ s = s[s.index(\" \") + 1..-1] if s[0..2] == \"The\" || s[0..4] == \"Hello\"\n\
    \  s = s[s.index(\" \") + 1..-1] if s[0] == \"I\"\n  s = s[s.index(\" \") + 1..-1]\n\
    \  is_bored(s)\nend\n```\n\n```java\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\
    \npublic class IsBored {\n  public static int isBored(String sentence) {\n   \
    \ Pattern p = Pattern.compile(\"(\\\\bI\\\\b|\\\\bThe\\\\b|\\\\bHello", "  (cond\
    \ [(string=? S \"\") 0]\n        [(regexp-match? #rx\"^I\" S)\n         (+ 1 (is_bored\
    \ (regexp-replace #rx\"^I[^.?!]+\" S \"\")))]\n        [else (is_bored (regexp-replace\
    \ #rx\"^[^.?!]+\" S \"\"))]))\n", "  (count (lambda (word) (string=? word \"I\"\
    )) (string-split S \"\\\\.\")))\n", "  (define (counter s count)\n    (cond ((string=?\
    \ (string-append (list (string-ref s 0))\n                                   \
    \ (list (string-ref s 1)))\n                    \"I \")\n           (counter (substring\
    \ s 1) (+ count 1)))\n          ((string=? (string-ref s 0) #\\.)\n          \
    \ (counter (substring s 1) count))\n          ((string=? (string-ref s 0) #\\\
    ?)\n           (counter (substring s 1) count))\n          ((string=? (string-ref\
    \ s 0) #\\!)\n           (counter (substring s 1) count))\n          ((string=?\
    \ (string-length s) 0)\n           count)\n          (else (counter (substring\
    \ s 1) count))))\n  (counter S 0))", "  (match S\n    [\"\" 0]\n    [(struct String\
    \ (fst snd))\n     (if (equal? (string-upcase fst) \"I\")\n         (+ 1 (is_bored\
    \ snd))\n         (is_bored snd))]))\n```\n\n## Scratchpad\n\n```racket\n#lang\
    \ racket\n", "  (count (lambda (word)\n           (equal? \"I\" word))\n     \
    \    (split (lambda (c)\n                  (or (equal? c #\\!)\n             \
    \         (equal? c #\\.)\n                      (equal? c #\\?)))\n         \
    \       S)))\n", "  (let* ([S (substring/match S #rx\"I[^.]*\")]\n         [S\
    \ (substring/match S #rx\"[?.!]\")])\n    (substring-count S \"!\")))\n", "  (add1\
    \ (string-length (filter\n                        (lambda (x) (and (not (null?\
    \ x)) (equal? (car x) \"I\")))\n                        (split (format \"~~~%s~\"\
    \ S) \"[.!?]\")))))\n", "  (define (split S)\n    (regexp-split #rx\"[.?!]\" S))\n\
    \  (define (sentence-split L)\n    (map (lambda (x) (regexp-split #rx\" \" x))\
    \ L))\n  (define (word-split L)\n    (map (lambda (x) (regexp-split #rx\"\\s+\"\
    \ x)) L))\n  (define (count-sentence L)\n    (foldr + 0 (map (lambda (sentence)\n\
    \                      (if (string=? (car sentence) \"I\")\n                 \
    \         1\n                          0))\n                    L)))\n  (count-sentence\
    \ (word-split (sentence-split (split S)))))\n", "  (count (lambda (x)\n      \
    \     (and\n            (equal? (substring x 0 1) \"I\")\n            (or\n  \
    \           (equal? (substring x (- (string-length x) 1) (string-length x)) \"\
    .\")\n             (equal? (substring x (- (string-length x) 1) (string-length\
    \ x)) \"?\")\n             (equal? (substring x (- (string-length x) 1) (string-length\
    \ x)) \"!\"))\n             )\n           )\n         (string-split S #\\Space)\n\
    \         )\n  )", "  ;; Count the number of boredoms in a string S.\n\n  ;; Split\
    \ the string on '.', '?', or '!'\n  (define (split S)\n    (regexp-split #rx\"\
    \\\\.|\\\\?|\\\\!\" S))\n\n  ;; Check if a string contains the word \"I\"\n  (define\
    \ (is_bored_string S)\n    (regexp-match #rx\"\\\\bI\\\\b\" S))\n\n  ;; Count\
    \ the boredoms in a list of strings\n  (define (count_boredoms ss)\n    (foldl\
    \ + 0 (map is_bored_string ss)))\n\n  (count_boredoms (split S)))\n</code>\nI\
    \ feel I am using too many intermediate definitions. There must be a way to do\
    \ this with lambdas and higher-order functions.\n\n\nA:\n\nFirstly, you could\
    \ skip the <code>split</code> function by using a more refined regexp that also\
    \ captures the delimiters, e.g. <code>#rx\"\\\\.|\\\\?|\\\\!(?= |$)\"</code>.\
    \ In this case, we'll take advantage of the fact that <code>regexp-match</code>\
    \ returns the matched portion of the input and use it to determine which delimiter\
    \ is being used for the particular sentence, then we can simply concatenate all\
    \ sentences with a <code>.</code> to be matched by <code>is_bored_string</code>.\n\
    In the <code>is_bored_string</code> function you could use a more efficient regexp\
    \ that uses lookaround assertions, for example <code>#rx\"\\\\bI\\\\b\"</code>\
    \ can be replaced with <code>#rx\"(?&lt;!\\\\b\\\\w)I(?!\\\\w\\\\b)\"</code>.\n\
    So the complete solution would be something like this:\n<code>(define (is_bored\
    \ S)\n  (foldl + 0\n         (for/list ([s (regexp-match #rx\"\\\\.|\\\\?|\\\\\
    !(?= |$)\" S)])\n           (is_bored_string (string-join (map (lambda (s) (car\
    \ s))\n                                               (cdr s))\n             \
    \                            \".\"))", "  (define (f (L R))\n    (if (empty? L)\n\
    \        R\n        (let* ([T (first L)]\n               [N (second L)]\n    \
    \           [R (if (equal? T \"I\")\n                      (+ 1 R)\n         \
    \             R)])\n          (f N R))))\n  (f (split-at S))\n  )\n", "  (cond\n\
    \    ((= (length S) 0) 0)\n    ((equal? (take (list->string (list-ref S 0)) 2)\
    \ \"I \") 1)\n    (else (is_bored (cdr S)))))\n", "  (if (string=? \"\" S)\n \
    \     0\n      (if (string=? \"I\" (car (string-split S \"[.?!]\")))\n       \
    \   (+ 1 (is_bored (cdr (string-split S \"[.?!]\"))))\n          (is_bored (cdr\
    \ (string-split S \"[.?!]\"))))))\n```\n\nThe above method is one of the many\
    \ solutions that the user gave to this\nproblem, which can be found on the following\
    \ link:\n[https://www.codewars.com/kata/57e20e32b46aae6b030006ad/train/racket](https://www.codewars.com/kata/57e20e32b46aae6b030006ad/train/racket)\n\
    \nThe test cases were:\n\n```", "  (if (string-empty? S)\n      0\n      (if (string-prefix?\
    \ \"I\" S)\n          (+ 1 (is_bored (string-drop S 1)))\n          (is_bored\
    \ (string-drop S 1)))))\n", "  (if (or (string=? S \"\") (not (string-prefix?\
    \ \"I\" S)))\n      0\n      (if (string-contains S #\\.)\n          (+ 1 (is_bored\
    \ (string-trim (string-after S #\\.))))\n          (+ 1 (is_bored (string-trim\
    \ (string-after S #\\!))))\n          (+ 1 (is_bored (string-trim (string-after\
    \ S #\\?))))\n          )\n      )\n  )\n", "  (andmap (lambda (x) (equal? (substring\
    \ x 0 1) \"I\"))\n          (regexp-split S #rx\"[.?!]\")))\n", "  (cond [(empty?\
    \ S) 0]\n        [(string=? (first S) \"I\")\n         (+ 1 (is_bored (rest S)))]\n\
    \        [else (is_bored (rest S))]))\n", "  (if (string-empty? S)\n      0\n\
    \      (if (string-contains S \".\")\n          (+ (is_bored (string-split S \"\
    .\"))\n             (if (string-contains (string-split S \".\") \"I\") 1 0))\n\
    \          (if (string-contains S \"?\")\n              (+ (is_bored (string-split\
    \ S \"?\"))\n                 (if (string-contains (string-split S \"?\") \"I\"\
    ) 1 0))\n              (if (string-contains S \"!\")\n                  (+ (is_bored\
    \ (string-split S \"!\"))\n                     (if (string-contains (string-split\
    \ S \"!\") \"I\") 1 0))\n                  (is_bored (string-rest S))\n      \
    \            )))))\n", "  (let ((n 0))\n    (cond\n      [(null? S) n]\n     \
    \ [(equal? (car S) \"I\") (is_bored (cdr S))]\n      [else (is_bored (cdr S))])))",
  "  (length (filter (lambda (str)\n                    (equal? \"I\" (car (string-split\
    \ str))))\n                  (string-split S))))", "  (string-length (regexp-replace*\
    \ #rx\"^I\" S \"\")))\n", "  (count\n   (lambda (word) (equal? word \"I\"))\n\
    \   (split-by-regexp S #rx\"[?!.]\")))\n", "  (for/fold ([bored 0]) ([s (string-split\
    \ S #\\.)])\n    (match s\n      [\"I\" (add1 bored)]\n      [_ bored])))\n```\n\
    \n```haskell\n\n```\n\n```python\n\n```\n\n```ruby\n\n```\n\n```rust\n\n```\n\n\
    ```swift\n\n```\n\n```typescript\n\n```\n\n```sml\n\n```\n\n```kotlin\n\n```\n\
    \n```scala\n\n```\n\n```scala\n\n```\n\n```fsharp\n\n```\n\n```dart\n\n```\n\n\
    ```elixir\n\n```\n\n```erlang\n\n```\n\n```elm\n\n```\n\n```ceylon\n\n```\n\n\
    ```crystal\n\n```\n\n```d\n\n```\n\n```nim\n\n```\n\n```nix\n\n```\n\n```go\n\n\
    ```\n\n```dart\n\n```\n\n```objective-c\n\n```\n\n```swift\n\n```\n\n```groovy\n\
    \n```\n\n```java\n\n```\n\n```r\n\n```\n\n```csharp\n\n```\n\n```c\n\n```\n\n\
    ```sh\n\n```\n\n```bash\n\n```\n\n```powershell\n\n```\n\n```c++\n\n```\n\n```php\n\
    \n```\n\n```elisp\n\n```\n\n```clojure\n\n```\n\n```clojure-script\n\n```\n\n\
    ```typescript\n\n```\n\n```scala\n\n```\n\n```typescript\n\n```\n\n```racket\n\
    \n```\n\n```rust\n\n```\n\n```haskell\n\n```\n\n```python\n\n```\n\n```ruby\n\n\
    ```\n\n```lua\n\n```\n\n```dart\n\n```\n\n", "  (define (is-bored-help str count)\n\
    \    (cond\n      [(string=? \"\" str) count]\n      [(string=? (substring str\
    \ 0 1) \"I\")\n       (is-bored-help (substring str 1) (+ count 1))]\n      [else\
    \ (is-bored-help (substring str 1) count)]))\n  (is-bored-help S 0))\n", "  (if\
    \ (string=? S \"\")\n      0\n      (if (or (string=? S \".\")\n             \
    \ (string=? S \"?\")\n              (string=? S \"!\"))\n          0\n       \
    \   (if (string=? (substring S 0 1) \"I\")\n              (+ 1 (is_bored (substring\
    \ S 1)))\n              (is_bored (substring S 1))))))\n", "  (if (string=? S\
    \ \"\")\n      0\n      (if (string-contains S \"I\")\n          (+ 1 (is_bored\
    \ (substring S 1)))\n          (is_bored (substring S 1)))))\n", "  (for/fold\
    \ ([bored 0]) ([s (string-split S #rx\"[!.? ]\")])\n    (cond [(string=? \"I\"\
    \ (string-upcase s)) (+ bored 1)]\n          [else bored])))\n", "  ;; You'll\
    \ need to write this function.\n  )", "  (length (filter\n           (lambda (x)\n\
    \             (and (> (length x) 1)\n                  (string=? (substring x\
    \ 0 1) \"I\")))\n           (regexp-split #rx\"\\\\.|\\\\?|!\" S))))\n", "  (cond\n\
    \    [(empty? S) 0]\n    [(equal? (first S) \"I\") (+ 1 (is_bored (rest S)))]\n\
    \    [else (is_bored (rest S))]))\n", "  ;; ...\n  )\n", "  (let ([s (string-split\
    \ S)])\n    (length (filter (lambda (e)\n                      (and (string=?\
    \ \"I\" (car e))\n                           (member (car (cdr e)) (list #\\!\
    \ #\\? #\\.))))\n                    (partition 2 s)))))\n", "  (cond\n    ((string=?\
    \ S \"\") 0)\n    ((string-prefix? (substring S 0 2) \"I \")\n     (+ 1 (is_bored\
    \ (substring S 1))))\n    ((char-ci=? (string-ref S 0) #\\.)\n     (is_bored (substring\
    \ S 1)))\n    ((char-ci=? (string-ref S 0) #\\?)\n     (is_bored (substring S\
    \ 1)))\n    ((char-ci=? (string-ref S 0) #\\!)\n     (is_bored (substring S 1)))\n\
    \    (else (is_bored (substring S 1)))))\n", "  (if (empty? S)\n      0\n    \
    \  (if (string=? (car (split S)) \"I\")\n          (+ 1 (is_bored (cdr (split\
    \ S))))\n          (is_bored (cdr (split S))))))", "  (let loop ([L (string-split\
    \ S)])\n    (cond\n      [(empty? L) 0]\n      [(string=? (first L) \"I\") (+\
    \ 1 (loop (rest L)))]\n      [else (loop (rest L))])))\n```\n\n```\n#lang racket\n",
  "  (define (aux input acc)\n    (if (empty? input)\n        acc\n        (if (string=?\
    \ (first input) \"I\")\n            (aux (rest input) (+ acc 1))\n           \
    \ (aux (rest input) acc))))\n  (aux (split S #\\.) 0))\n", "  (cond [(empty? S)\
    \ 0]\n        [(string=? (substring S 0 1) \"I\") (+ 1 (is_bored (substring S\
    \ 1)))]\n        [else (is_bored (substring S 1))]))\n", "  (reduce + 0 (map (lambda\
    \ (X) (if (regexp-match #rx\"^I\" X) 1 0))\n                   (string-split S\
    \ #rx\"\\\\.\"))))\n```\n\n## Day 6: Strings, lists, & dicts\n\n```racket\n#lang\
    \ racket\n", "  (match S\n    [('! . rest) (is_bored rest)]\n    [('? . rest)\
    \ (is_bored rest)]\n    [('.' . rest) (is_bored rest)]\n    [('I' . rest) (+ 1\
    \ (is_bored rest))]\n    [() 0]))\n", "  (cond\n    [(empty? S) 0]\n    [(number?\
    \ (string-index (regexp #rx\"I\") S)) (+ 1 (is_bored (substring S (+ 1 (string-index\
    \ (regexp #rx\"I\") S)) (string-length S))))]\n    [else (is_bored (substring\
    \ S (+ 1 (string-index (regexp #rx\"[!?.]\") S)) (string-length S)))]))\n", " \
    \ (local [(define (boredoms S)\n            (if (empty? S)\n                0\n\
    \                (if (string=? (car S) \"I\")\n                    (+ 1 (boredoms\
    \ (cdr S)))\n                    (boredoms (cdr S)))))\n          (define (split-sentences\
    \ S)\n            (local [(define (dot? ch)\n                      (char=? ch\
    \ #\\.))\n                    (define (bang? ch)\n                      (char=?\
    \ ch #\\!))\n                    (define (qmark? ch)\n                      (char=?\
    \ ch #\\?))\n                    (define (delim? ch)\n                      (or\
    \ (dot? ch) (bang? ch) (qmark? ch)))]\n              (cond [(empty? S) empty]\n\
    \                    [(delim? (car S)) (cons empty (split-sentences (cdr S)))]\n\
    \                    [else (let ([ss (split-sentences (cdr S))])\n           \
    \                 (cons (cons (car S) (car ss)) (cdr ss)))])))\n          (define\
    \ (clean-sentences S)\n            (map (lambda (S)\n                   (string-trim\
    \ S))\n                 S))]\n    (boredoms (clean-sentences (split-sentences\
    \ S)))))\n", "  (match S\n    ('\"Hello world\" 0)\n    ('\"The sky is blue. The\
    \ sun is shining. I love this weather\" 1)))\n", "  (cond\n    [(string=? S \"\
    \") 0]\n    [(string=? (substring S 0 2) \"I \")\n     (+ 1 (is_bored (substring\
    \ S 2 (string-length S))))]\n    [else (is_bored (substring S 1 (string-length\
    \ S)))]))\n", "  (define (is_bored' S i nb)\n    (if (= i (string-length S))\n\
    \        nb\n        (if (string=? (substring S i (+ i 2)) \"I \")\n         \
    \   (is_bored' S (+ i 1) (+ nb 1))\n            (is_bored' S (+ i 1) nb))))\n\
    \  (is_bored' S 0 0))\n", "  (count-boredoms (string-split S #\\.) 0))\n", " \
    \ (if (equal? S \"\")\n      0\n      (if (equal? (substring S 0 1) \"I\")\n \
    \         (+ 1 (is_bored (substring S (find S \" \"))))\n          (is_bored (substring\
    \ S (find S \" \"))))))\n", "  (define count 0)\n  (define (is-prefix? pre lst)\n\
    \    (or (null? lst)\n        (and (char=? (car lst) (car pre))\n            \
    \ (is-prefix? (cdr pre) (cdr lst)))))\n  (define (get-next-sentence lst)\n   \
    \ (if (or (char=? (car lst) #\\.)\n            (char=? (car lst) #\\?)\n     \
    \       (char=? (car lst) #\\!))\n        (list (list->string (cdr lst)) '())))\n\
    \  (define (get-sentences lst)\n    (if (or (char=? (car lst) #\\.)\n        \
    \    (char=? (car lst) #\\?)\n            (char=? (car lst) #\\!))\n        (list\
    \ (list->string (cdr lst)) '())\n        (get-sentences (cdr lst))))\n  (define\
    \ (is-bored? lst)\n    (is-prefix? \"I\" lst))\n  (if (null? S)\n      0\n   \
    \   (cond\n       ((is-bored? S)\n        (add1 count))\n       (else\n      \
    \  (is_bored (cdr S))))))\n", "  (count (\u03BB (x) (string=? \"I\" (substring\
    \ x 0 1)))\n         (string-split S #rx\"[.!?]\")))\n", "  (count-sentences #\"\
    I\" S))\n", "  ;; your code here\n  )\n```\n\n```scheme\n#lang racket\n", "  (regexp-match?\
    \ \"^I\" S))\n", "  (define (helper S)\n    (cond [(empty? S) empty]\n       \
    \   [(string=? (first S) \".\") (rest S)]\n          [(string=? (first S) \"?\"\
    ) (rest S)]\n          [(string=? (first S) \"!\") (rest S)]\n          [else\
    \ (cons (first S) (helper (rest S)))]))\n  (cond [(empty? S) 0]\n        [(string=?\
    \ (string-upcase (first S)) \"I\") (+ 1 (is_bored (helper (rest S)) ))]\n    \
    \    [else (is_bored (helper (rest S)))]))\n", "  (count 'I (split-string (first\
    \ (split-string S \"[.?!]\")) \" \")))\n", "  (define L (string-split S #\\.)\n\
    \    (define (iter S count)\n      (cond ((null? S) count)\n        ((regexp-match\
    \ #rx\"I\" (car S)) (iter (cdr S) (+ count 1)))\n        (else (iter (cdr S) count))))\n\
    \    (iter L 0)))\n\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(equal?\
    \ S \"\") 0]\n    [(string-index S \"!\") (string-index S \"!\")]\n    [(string-index\
    \ S \"?\") (string-index S \"?\")]\n    [(string-index S \".\") (string-index\
    \ S \".\")]\n    [else (is_bored (string-tail S 1))]))\n", "  (count (lambda (c)\n\
    \           (and (equal? c \"I\")\n                (member (char-upcase (char-downcase\
    \ (string-ref S 0)))\n                        '(#\\A #\\E #\\I #\\O #\\U))))\n\
    \         (split-string S (regexp \"[.?!]\"))))\n", "  (if (empty? S)\n      0\n\
    \      (if (equal? (car S) \"I\")\n          (+ 1 (is_bored (cdr S)))\n      \
    \    (is_bored (cdr S)))))\n", "  (define (count acc)\n    (define (is-I? s)\n\
    \      (equal? s \"I\"))\n    (if (equal? acc '())\n        0\n        (if (is-I?\
    \ (car acc))\n            (+ 1 (count (cdr acc)))\n            (count (cdr acc)))))\n\
    \  (count (string-tokenize S \"[.?!]\\\\s*\")))\n", "  (cond [(or (string=? (substring\
    \ S 0 2) \"I \")\n             (string=? (substring S 0 1) \"I\")) 1]\n      \
    \  [else 0]))\n", "  (cond [(empty? S) 0]\n        [(regexp-match #rx\"^I\" S)\
    \ (+ 1 (is_bored (rest (regexp-split #rx\"\\.\" S))))]\n        [else (is_bored\
    \ (rest (regexp-split #rx\"\\.\" S)))]))", "  (match (string-split S \"\\\\.\"\
    )\n         [(list before 'I' _)\n          (cond\n            [(empty? before)\
    \ 1]\n            [(string-empty? before) 1]\n            [else 0])]\n       \
    \  [_ 0]))\n", "  (length (filter (lambda (W) (equal? (substring W 0 1) \"I\"\
    ))\n                  (split S \"[!?.]\"))))", "  (error \"Unimplemented\"))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    ((null? S) 0)\n    ((and (equal?\
    \ (substring S 0 2) \"I \")\n          (member (substring S -1) '(#\\! #\\? #\\\
    .))) 1)\n    (else (is_bored (substring S 1)))))\n", "  (let ([tokens (string-tokenize\
    \ S (regexp \"\\\\b[.?!]\"))])\n    (length (filter (lambda (token) (string-starts-with?\
    \ token \"I\")) tokens))))\n", "  (cond\n    [(empty? S) 0]\n    [(string=? (string-take\
    \ S 1) \"I\") (+ 1 (is_bored (string-drop S 1)))]\n    [else (is_bored (string-drop\
    \ S 1))]))\n", "  (cond [(string=? S \"\") 0]\n        [(and (string=? (string-take\
    \ S 1) \"I\")\n              (member (string-take S 2) '(\". !\" ?\\s)))\n   \
    \      (+ 1 (is_bored (string-drop S 1)))]\n        [else (is_bored (string-drop\
    \ S 1))]))\n", "  (cond\n    [(and (not (string-empty? S))\n          (string=?\
    \ (substring S 0 1) \"I\"))\n     (+ 1 (is_bored (substring S 1)))]\n    [(and\
    \ (not (string-empty? S))\n          (string=? (substring S 0 1) \" \"))\n   \
    \  (is_bored (substring S 1))]\n    [(not (string-empty? S))\n     (is_bored (substring\
    \ S 1))]\n    [else 0]))\n", "  (length (filter (lambda (S) (equal? (first (string-split\
    \ S)) \"I\"))\n                  (string-split S #\\.))))\n\n```\n\n## [Is Ollie\
    \ Ollie in Come Free?](https://www.codewars.com/kata/5c3e3dcfdfa06a7e9b000123)\n\
    \n*PreRequisite: Regular Expressions - Part 1, Regular Expressions - Part 2*\n\
    \n```racket\n#lang racket\n", "  (define (letter? c)\n    (char-lower-case? c))\n\
    \  (define (word? c)\n    (char-whitespace? c))\n  (define (end? c)\n    (or (equal?\
    \ c #\\.) (equal? c #\\?) (equal? c #\\!)))\n  (define (sentence? c)\n    (or\
    \ (letter? c) (word? c) (end? c)))\n  (define (skip-sentence S)\n    (cond\n \
    \     [(empty? S) empty]\n      [(end? (first S)) S]\n      [else (skip-sentence\
    \ (rest S))]))\n  (define (sentence-length S)\n    (if (empty? S)\n        0\n\
    \        (+ 1 (sentence-length (rest S)))))\n  (define (num-boredoms S)\n    (if\
    \ (empty? S)\n        0\n        (if (equal? \"I\" (first (regexp-match #rx\"\\\
    w+\" S)))\n            (+ 1 (num-boredoms (skip-sentence S)))\n            (num-boredoms\
    \ (skip-sentence S)))))\n  (if (string-contains S #\\.)\n      (num-boredoms S)\n\
    \      0))\n", "  (let ([L (string-split S)])\n    (if (string=? (car L) \"I\"\
    )\n        1\n        0)))\n", "  (error \"TODO\"))\n", "  (cond\n    [(string=?\
    \ S \"\") 0]\n    [(and (string=? (substring S 0 1) \"I\")\n          (memq (substring\
    \ S 1 2) '(\". !\"))) 1]\n    [else (is_bored (substring S 1))]))\n", "  (define\
    \ (go index count)\n    (if (= index (string-length S))\n        count\n     \
    \   (cond\n         [(equal? (substring S index (+ index 1)) \"I\")\n        \
    \  (go (+ index 1) (+ count 1))]\n         [else\n          (go (+ index 1) count)])))\n\
    \  (go 0 0))\n", "  ;; Fill in your code here.\n  )\n```\n\n## Hints\n\n- You\
    \ may want to look at the [`string-tokenize`](https://docs.racket-lang.org/reference/strings.html#%28def._%28%28lib._racket%2Fstring..rkt%29._string-tokenize%29%29)\
    \ function.", "  (define (is-I? word)\n    (string=? word \"I\"))\n  (define (is-sentence?\
    \ word)\n    (string=? word \".\"))\n  (define (is-boredom? sentence)\n    (is-I?\
    \ (first sentence)))\n  (let* ([words (map string-trim (string-split S \"[?!.]\"\
    ))]\n         [sentences (map string-split words)])\n    (length (filter is-boredom?\
    \ sentences))))\n", "  (cond\n    [(string=? S \"\") 0]\n    [(string=? (substring\
    \ S 0 1) \"I\") (+ 1 (is_bored (substring S 1)))]\n    [else (is_bored (substring\
    \ S 1))]))", "  (local [(define (count-sentence acc)\n            (cond [(string=?\
    \ (substring (string-trim S) 0 1) \"I\") (+ acc 1)]\n                  [else acc]))]\n\
    \    (count-sentence 0)))\n", "  (length (string-match #rx\"I[^I]*[!.?]\" S)))\n",
  "  (count (string-split (regexp-replace #rx\"^I \" S \"\") #rx\"[.?!] \") \"I \"\
    ))\n", "  (string-match #rx\"^I\" S))\n", "  (length (regexp-match* #rx\"I\" S)))\n",
  "  (define (impl S ans result)\n    (if (= (string-length S) 0)\n        result\n\
    \        (let ([c (string-ref S 0)])\n          (cond\n            [(or (= c #\\\
    !) (= c #\\?) (= c #\\.))\n             (impl (substring S 1 (string-length S))\
    \ #f result)]\n            [(or (= c #\\I) (= c #\\i))\n             (impl (substring\
    \ S 1 (string-length S)) #t result)]\n            [else\n             (impl (substring\
    \ S 1 (string-length S)) ans result)]))))\n  (impl S #f 0))\n", "  (count-if (\u03BB\
    \ (e) (regexp-match? #rx\"^I \" e))\n            (regexp-split #rx\"[.?!]\" S)))\n",
  "  (cond [(empty? S) 0]\n        [(regexp-match #rx\"^I\" S) (+ 1 (is_bored (string-drop\
    \ S (+ 1 (string-length (car (regexp-match #rx\"^I\" S)))))))]\n        [else\
    \ (is_bored (string-drop S (+ 1 (string-length (car (regexp-match #rx\"^.\" S))))))]))\n",
  "  (if (empty? S)\n      0\n      (if (and (equal? \"I\" (first S))\n          \
    \     (empty? (regexp-match #rx\"^[.?!]\" (string-append (string-join S \" \"\
    ) \" \"))))\n          (+ 1 (is_bored (rest S)))\n          (is_bored (rest S)))))\n\
    ```\n\n```scheme\n#lang racket\n", "  (define (head S) (string-take S 1))\n  (define\
    \ (tail S) (string-drop S 1))\n  (define (split S) (cond [(string=? S \"\") (list)]\n\
    \                          [(string=? S \" \") (list)]\n                     \
    \     [(string=? (head S) \"!\") (list (list (head S)) (tail S))]\n          \
    \                [(string=? (head S) \".\") (list (list (head S)) (tail S))]\n\
    \                          [(string=? (head S) \"?\") (list (list (head S)) (tail\
    \ S))]\n                          [else (cons (head S) (split (tail S)))]))\n\
    \  (define (accu s)\n    (cond [(string=? (head s) \"I\") (+ 1 (accu (tail s)))]\n\
    \          [else (accu (tail s))]))\n  (define (is_bored1 l)\n    (cond [(null?\
    \ l) 0]\n          [(list? (car l)) (is_bored1 (cdr l))]\n          [else (accu\
    \ (string-join l))]))\n  (is_bored1 (split S)))\n", "  (sentence-count (string->list\
    \ S)))\n", "  (define (is-start-with-i? S)\n    (and (equal? (string-ref S 0)\
    \ #\\I) (equal? (string-ref S 1) #\\ )))\n  (define (sentence-counter s)\n   \
    \ (if (string-empty? s)\n        0\n        (if (or (equal? (string-ref s 0) #\\\
    .)\n                (equal? (string-ref s 0) #\\?)\n                (equal? (string-ref\
    \ s 0) #\\!))\n            (if (is-start-with-i? (substring s 1 (string-length\
    \ s)))\n                (+ 1 (sentence-counter (substring s 1 (string-length s))))\n\
    \                (sentence-counter (substring s 1 (string-length s))))\n     \
    \       (sentence-counter (substring s 1 (string-length s))))))\n  (sentence-counter\
    \ S))\n```\n\n## Solution using Regexp\n\n```racket\n#lang racket\n", "  (cond\
    \ ((equal? S \"\") 0)\n        ((and (equal? (substring S 0 1) \"I\")\n      \
    \        (or (equal? (substring S 1 1) \" \")\n                  (equal? (substring\
    \ S 1 1) \".\")\n                  (equal? (substring S 1 1) \"?\")\n        \
    \          (equal? (substring S 1 1) \"!\"))) (+ 1 (is_bored (substring S 1))))\n\
    \        (else (is_bored (substring S 1)))))\n", "  (string-count S #rx\"^I[a-zA-Z0-9\
    \ ]*[.?!]\"))\n", "  (cond\n    [(empty? S) 0]\n    [(string=? (take S 1) \"I\"\
    ) (+ 1 (is_bored (drop S 1)))]\n    [else (is_bored (drop S 1))]))\n", "  (count\
    \ (split-string S) \n         (lambda (x) (equal? \"I\" (car (split-string x))))))\n",
  "  (let ([sentences (regexp-split #rx\"\\\\.|\\\\?|!\" S)])\n    (for/fold ([n 0])\
    \ ([sentence sentences])\n      (if (regexp-match #rx\"^I \" sentence)\n     \
    \     (+ n 1)\n          n))))\n", "  (define L (string-split S \"[.?!]\"))\n\
    \  (count-boredoms L))\n", "  (count (lambda (s)\n           (and (string=? (substring\
    \ s 0 1) \"I\")\n                (regexp-match #rx\"^I\" s)))\n         (string-split\
    \ S #rx\"[.?!]\")))\n", "  (let* ([word-boundary \"[\\\\.\\\\?!]\"]\n        \
    \ [matches (regexp-match* #rx(rx bos \"I\" (* word-boundary)) S)])\n    (length\
    \ matches)))\n", "  (let* ([sentences (string-split S #rx\"\\.\")]\n         [result\
    \ (for/sum ([s sentences])\n                    (if (string-match #rx\"^I\" s)\
    \ 1 0))])\n    result))\n", "  (if (string=? \"\" S)\n      0\n      (if (string=?\
    \ \"I\" (first (string-split S)))\n          (+ 1 (is_bored (last (string-split\
    \ S))))\n          (is_bored (last (string-split S))))))\n", "  (let ((I 0)\n\
    \        (count 0))\n    (for ((x (in-string S)))\n      (cond ((char=? x #\\\
    \ )\n             (set! I 0))\n            ((char=? x #\\.)\n             (set!\
    \ I 0))\n            ((char=? x #\\?)\n             (set! I 0))\n            ((char=?\
    \ x #\\!)\n             (set! I 0))\n            ((char=? x #\\I)\n          \
    \   (set! I 1))\n            ((char=? x #\\w)\n             (if (= I 1)\n    \
    \             (set! count (+ count 1))\n                 (set! I 0)))))\n    count))\n",
  "  (cond\n    [(empty? S) 0]\n    [(is_sentence S)\n     (cond\n       [(find_head\
    \ S) (add1 (is_bored (remove_head S)))]\n       [else (is_bored (remove_head S))])]\n\
    \    [else (is_bored (remove_head S))]))\n", "  (if (empty? S)\n      0\n    \
    \  (if (string=? (regexp-match #rx\"I\" S) #f)\n          (is_bored (rest S))\n\
    \          (+ 1 (is_bored (rest S))))))\n", "  (count (\u03BB (x) (equal? \"I\"\
    \ (substring x 0 1)))\n         (split-string S \"[.?!]\")))", "  (let ([sentences\
    \ (string-split S #\"[.?!]\")])\n    (length (filter (\u03BB (s) (string-prefix?\
    \ \"I\" s)) sentences))))\n", "  (define (is-bored-helper S Accum)\n    (if (empty?\
    \ S)\n        Accum\n        (if (string=? (word S 0) \"I\")\n            (is-bored-helper\
    \ (next-word S) (+ Accum 1))\n            (is-bored-helper (next-word S) Accum))))\n\
    \  (is-bored-helper S 0))\n```\n\n```racket\n#lang racket\n", "  ;; split the\
    \ string by '.', '?', '!'\n  (cond\n    [(regexp-match #rx\"^I \" S) 1]\n    [else\
    \ 0]))\n", "  (let ((count 0))\n    (for/fold ([count 0]) ([i (in-string S)])\n\
    \      (cond\n        [(char=? i #\\.) count]\n        [(char=? i #\\?) count]\n\
    \        [(char=? i #\\!) count]\n        [(char=? i #\\I) (add1 count)]\n   \
    \     [else count]))))\n", "  (define (is-bored-helper s)\n    (match s\n    \
    \  [(_) 0]\n      [(list b (list 'I _)) (+ 1 (is-bored-helper (cdr s)))]\n   \
    \   [else (is-bored-helper (cdr s))]))\n  (is-bored-helper (string-split S)))\n",
  "  (for/fold ([boredom 0]) ([S (in-string (regexp \"([Ii]\\\\s+.*?[.?!])\"))])\n\
    \    (if (regexp-match #rx\"^[Ii]\" S)\n        (+ boredom 1)\n        boredom)))\n",
  "  (length (filter (lambda (s) (string=? (substring s 0 1) \"I\"))\n           \
    \       (regexp-split #rx\"[.?!]\" S))))\n", "  (length (filter\n           (lambda\
    \ (P) (string=? \"I\" (car P)))\n           (sentences (tokenize S)))))\n", " \
    \ (string-tokenize (string-upcase S) #\\.)\n  (local\n   ((define sentences\n\
    \      (string-tokenize (string-upcase S) #\\.))\n    (define (is-bored-sentence\
    \ sentence)\n      (and (string? sentence)\n           (= 1 (string-length sentence))\n\
    \           (char=? #\\I (string-ref sentence 0)))))\n   (length (filter is-bored-sentence\
    \ sentences))))\n", "  ; YOUR CODE HERE\n  )\n", "  (length (regexp-match* #rx\"\
    I\" S)))\n", "  (string-index S \"I\"))\n```\n\n``` #lang racket", "  (map (lambda\
    \ (n) (if (equal? (substring (string-append \" \" S) n (+ n 1)) \"I\") 1 0)) (range\
    \ 0 (- (string-length S) 1))))\n", "  (cond [(null? S) 0]\n        [(and (string=?\
    \ (substring S 0 1) \"I\")\n              (not (char-ci=? (string-ref S 1) #\\\
    space))) 1]\n        [else (is_bored (substring S 1))]))\n", "  ;; split S by\
    \ either . or ? or !\n  (length (regexp-match* #rx\"I\" S))\n  )\n", "  (accumulate\
    \ + 0 (map (lambda (x) (if (string=? (substring x 0 1) \"I\") 1 0)) (string-split\
    \ S \".\"))))\n", "  (define (is_bored-loop curr count)\n    (cond\n      ((null?\
    \ curr) count)\n      ((and (string=? (car curr) \"I\")\n            (not (member\
    \ (car (cdr curr)) '(\".!?\"))))\n       (is_bored-loop (cdr curr) (+ count 1)))\n\
    \      (else (is_bored-loop (cdr curr) count))))\n  (is_bored-loop (string-split\
    \ S) 0))\n", "  (count (lambda (s) (equal? \"I\" (string-trim s)))\n         (for/list\
    \ ([s (in-string S)])\n           (string-trim s)\n           #:when (not (empty?\
    \ s)))))\n```\n\n```racket\n#lang racket\n", "  (count (string-split (string-append\
    \ S \".\") #\\.)\n         (lambda (S)\n           (if (string=? (string-take\
    \ S 2) \"I \") 1 0))))\n", "  (let ((sentences (string-split S #\\.)))\n    (for/fold\
    \ ([result 0]) ([s sentences])\n      (if (and (string-contains? s \"I\")\n  \
    \             (string-trim (string-trim s #\\!) #\\?))\n          (add1 result)\n\
    \          result))))\n", "  (cond\n    [(equal? S \"\") 0]\n    [(equal? (substring\
    \ S 0 1) \"I\") (+ 1 (is_bored (substring S 1 (string-length S))))]\n    [else\
    \ (is_bored (substring S 1 (string-length S)))]))\n```\n\n```racket\n#lang racket\n",
  "  (for/fold ([s 0]) ([s (in-string S)] #:break (= s 0))\n    (match (regexp #rx\"\
    ^I\") s)\n    [#f s]\n    [#t (add1 s)]))", "  (define (is_bored-sentence S)\n\
    \    (cond\n      [(null? S) 0]\n      [(and (string=? (substring S 0 1) \"I\"\
    )\n            (or (string=? (substring S 1 1) \" \")\n                (string=?\
    \ (substring S 1 1) \".\"))) 1]\n      [else (is_bored-sentence (substring S 1))]))\n\
    \  (let ([a (string-index S #\\!)])\n    (if (not a) (let ([b (string-index S\
    \ #\\?)])\n                 (if (not b) (let ([c (string-index S #\\.)])\n   \
    \                           (if (not c) (is_bored-sentence S)\n              \
    \                (is_bored-sentence (substring S 0 c))\n                     \
    \         (+ (is_bored-sentence (substring S 0 c))\n                         \
    \        (is_bored (substring S (+ c 1)))))\n                              (is_bored-sentence\
    \ S)))\n                 (is_bored-sentence (substring S 0 b))\n             \
    \    (+ (is_bored-sentence (substring S 0 b))\n                    (is_bored (substring\
    \ S (+ b 1)))))\n    (is_bored-sentence (substring S 0 a))\n    (+ (is_bored-sentence\
    \ (substring S 0 a))\n       (is_bored (substring S (+ a 1))))))\n", "  (define\
    \ (loop S i result)\n    (cond ((not (string-length S)) result)\n          ((string=?\
    \ (substring S 0 i) \"I\")\n           (loop (substring S (add1 i)) 0 (add1 result)))\n\
    \          (else (loop S (add1 i) result))))\n  (loop S 0 0))\n", "  (length (filter\
    \ (lambda (x) (string=? \"I\" (car (string-split x \" \"))))\n               \
    \   (string-split S \".\"))))\n", "  (cond [(empty? S) 0]\n        [(and (equal?\
    \ (first S) \"I\")\n              (member (second S) '(#\\Space #\\Newline #\\\
    Tab #\\.))) 1]\n        [else (is_bored (rest S))]))", "  ; Your code here\n \
    \ )\n", "  (length (string-match \"I\" S))\n  )", "  (let ([words (string-split\
    \ S #\\Space)])\n    (length (filter (\u03BB (X) (equal? (string-&gt;list X) '(I)))\
    \ words))))\n</code>\nThat's a <code>O(n)</code> solution, but I'm looking for\
    \ a \"cooler\" solution, one that's not <code>O(n)</code>.\n\n\nA:\n\nWith the\
    \ help of @Vladimir Matveev, I came up with the following:\n<code>#lang racket\n",
  "  (define is-cap-i?\n    (lambda (c)\n      (and (char=? (char-upcase c) #\\I)\n\
    \           (char=? (char-upcase c) c))))\n  (define next-sentence-end\n    (lambda\
    \ (s)\n      (string-index (string-drop s 1) #\\.)))\n  (let next-sentence-start\n\
    \    (lambda (s)\n      (cond ((string-match \"^I\" s) 0)\n            ((string-match\
    \ \"^[A-Z]\" s)\n             (begin\n               (let ((e (next-sentence-end\
    \ s)))\n                 (if (negative? e) e\n                     (+ 1 (next-sentence-start\
    \ (string-drop s (next-sentence-end s))))))))\n            (else (next-sentence-end\
    \ s))))))\n  (let loop\n    (lambda (str)\n      (cond ((string=? str \"\") 0)\n\
    \            ((not (string-match \"^I\" str))\n             (loop (string-drop\
    \ str (next-sentence-start str))))\n            (else (+ 1 (loop (string-drop\
    \ str (next-sentence-end str)))))))))\n", "  (if (empty? S)\n      0\n      (if\
    \ (regexp-match #rx\"I[^a-z]*[.?!]\" S)\n          (+ 1 (is_bored (regexp-replace\
    \ #rx\"I[^a-z]*[.?!]\" S \"\")))\n          (is_bored (regexp-replace #rx\"[^I]*[.?!]\"\
    \ S \"\")))))", "  (let ([words (string-split S #\\space)])\n    (and (and (equal?\
    \ (first words) \"I\")\n              (not (string-contains? (second words) #\\\
    .)))\n         (equal? (last words) \"bored.\"))))\n", "  (if (empty? S)\n   \
    \   0\n      (if (symbol=? (substring (car S) 0 1) \"I\")\n          (+ 1 (is_bored\
    \ (cdr S)))\n          (is_bored (cdr S)))))\n", "  (match S\n    [('I ' '? '!\
    \ '.) 1]\n    [('I ' ' ' ' ' ' ' ' ' ' ' ' ') 1]\n    [('I ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\
    \ '", "  (cond\n    [(empty? S) 0]\n    [(equal? (string-upcase (list-ref S 0))\
    \ #\\I) (+ 1 (is_bored (string-drop S 1)))]\n    [else (is_bored (string-drop\
    \ S 1))]))\n", "  ;; here you have to check S starting from the 2nd element of\
    \ it\n  ;; because the first element is the special delimiter\n  (define (helper\
    \ s n)\n    (if (null? s)\n        n\n        (if (string=? (car s) \"I\")\n \
    \           (helper (cdr s) (+ n 1))\n            (helper (cdr s) n))))\n  (helper\
    \ (string-split S) 0))\n", "  (if (string=? (substring S 0 1) \"I\")\n      1\n\
    \      0))", "  (if (string-empty? S)\n      0\n      (is_bored_work S 0)))\n",
  "  (string-length (regexp-match #rx\"^I\" S)))\n", "  ;; Your code here\n  )\n```\n\
    \nHint: You can use the `string-split` procedure to turn the string into a list.\n\
    You can use the `for/list` macro to create a list of sentences, and then\nfilter\
    \ them to get the boredoms.\n\n## Test your code\n\nCheck your code by running\
    \ the following command from the terminal\nin the same directory where you saved\
    \ the file:\n\n```bash\n$ racket str-split.rkt\n```\n\n## Submit your code\n\n\
    The due date for this assignment is 11:59pm on Sunday, March 1.\n\nBefore submitting,\
    \ be sure to run the following command from the terminal\nin the same directory\
    \ where you saved the file.\n\n```bash\n$ racket submit.rkt str-split\n```\n\n\
    Your username and password will be the same as the ones you use to log into\n\
    the department servers. You can ignore the warning that the CA certificate\nisn't\
    \ trusted.", "  (count \"I\" (string-split S #\\.)))\n", "  ;; I'm just not sure\
    \ what to do. Am I not supposed to split the string?\n  (count(split S )))\n\n",
  "  ;;;;;;; REFERENCE SOLUTION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\
    \  (cond\n    [(empty? S) 0]\n    [(string=? \"I\" (first (string-split S #\\\
    )))\n     (+ 1 (is_bored (first (string-split S #\\.))))]\n    [else (is_bored\
    \ (first (string-split S #\\.)))]))\n\n  ;;;; ALTERNATIVE SOLUTION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\
    \  ;;;; uses one more function, but no string-split, which may be more idiomatic\n\
    \  ;;;; and therefore better\n  ;(let loop ([S S] [count 0])\n  ;  (cond\n  ;\
    \    [(empty? S) count]\n  ;    [(char=? #\\I (first S))\n  ;     (loop (rest\
    \ S) (+ 1 count))]\n  ;    [else (loop (rest S) count)]))\n  )\n", "  (count-matches?\
    \ (string-split S \"\\\\.|\\\\?|!\")\n                  (lambda (x)\n        \
    \            (and (string-contains x \"I\")\n                         (not (string-contains\
    \ x \"i\"))\n                         ))))\n", "  (cond\n    [(string=? S \"\"\
    ) 0]\n    [(string=? (substring S 0 2) \"I \")\n     (+ 1 (is_bored (substring\
    \ S (string-index S \".\") 1)))]\n    [else (is_bored (substring S (string-index\
    \ S \".\") 1))]))\n```\n\nWhich also works.\n\n```racket\n#lang racket\n", " \
    \ (check-expect (is_bored \"Hello world\") 0)\n  (check-expect (is_bored \"The\
    \ sky is blue. The sun is shining. I love this weather\") 1)\n  (define (total_boreds\
    \ S)\n    (cond\n      [(empty? S) 0]\n      [(char=? (first S) #\\I) (+ 1 (total_boreds\
    \ (rest S)))]\n      [else (total_boreds (rest S))]))\n  (cond\n    [(empty? S)\
    \ 0]\n    [(string=? (first S) \"I\") (+ 1 (total_boreds (rest S)))]\n    [else\
    \ (total_boreds (rest S))]))\n", "  (regexp-match #rx\"^I\" S))\n", "  (cond\n\
    \    [(empty? S) 0]\n    [(string=? (substring S 0 2) \"I \")\n     (+ 1 (is_bored\
    \ (substring S (+ 2 (string-index S #\\.)))))]\n    [else (is_bored (substring\
    \ S (+ 1 (string-index S #\\.))))]))\n", "  (define (sentences S)\n    (cond\n\
    \      [(empty? S) empty]\n      [(eq? (first S) #\\!\n            (first S) #\\\
    ?\n            (first S) #\\.) (cons (string->list (string-before S (position\
    \ (first S) S)))\n                                 (sentences (string-after S\
    \ (position (first S) S))))]\n      [else (cons (string->list (string-before S\
    \ (first (position #\\! S))))\n                  (sentences (string-after S (first\
    \ (position #\\! S)))))]))\n  (define (is_bored? S)\n    (cond\n      [(empty?\
    \ S) 0]\n      [(eq? (first S) #\\I) 1]\n      [else 0]))\n  (accumulate + 0 (map\
    \ is_bored? (sentences S))))\n", "  (length (filter (lambda (S) (regexp-match\
    \ #rx\"^I\" S))\n                  (string-split S #rx\"[.?!]\"))))\n", "  (length\
    \ (filter (\u03BB (S) (regexp-match #rx\"^I\" S))\n                  (regexp-split\
    \ #rx\"\\.\" S))))\n", "  (length (filter (\u03BB (x) (= \"I\" (car x))) (split-string\
    \ S #\\space))))\n", "  (if (equal? (car (string-split S)) \"I\")\n      1\n \
    \     0))\n", "  (define (get-sentences S)\n    (let loop ([i 0] [ss '()])\n \
    \     (cond\n        [(>= i (string-length S)) (reverse ss)]\n        [(char=?\
    \ (string-ref S i) #\\.) (loop (+ i 1) (cons (substring S (+ i 1)) ss))]\n   \
    \     [(char=? (string-ref S i) #\\?) (loop (+ i 1) (cons (substring S (+ i 1))\
    \ ss))]\n        [(char=? (string-ref S i) #\\!) (loop (+ i 1) (cons (substring\
    \ S (+ i 1)) ss))]\n        [else (loop (+ i 1) ss)])))\n  (define (get-boredom\
    \ ss)\n    (let loop ([n 0] [ss ss])\n      (cond\n        [(null? ss) n]\n  \
    \      [(string-prefix? \"I\" (car ss)) (loop (+ n 1) (cdr ss))]\n        [else\
    \ (loop n (cdr ss))])))\n  (get-boredom (get-sentences S)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
