name: HumanEval_161_solve
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n;; otherwise keep it as it is.\n\
  ;; If the string contains no letters, reverse the string.\n;; The function should\
  \ return the resulted string.\n;; Examples\n;; solve(\"1234\") = \"4321\"\n;; solve(\"\
  ab\") = \"AB\"\n;; solve(\"#a@C\") = \"#A@c\"\n(define (solve s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
  \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
  \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"\
  #aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
  \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\"\
  )\n))\n\n(test-humaneval)"
completions: ["  (for/fold ([ss \"\"]) ([i (in-list s)])\n    (cond\n      [(or (char-numeric?\
    \ i) (char-upper-case? i)) (string-append ss (string i))]\n      [(char-lower-case?\
    \ i) (string-append ss (string (char-upcase i)))]\n      [else (string-append\
    \ ss (string (char-downcase i)))])))\n", "  (string-&gt;list s))\n</code>\nI wanted\
    \ to test it with the following code.\n<code>#lang racket\n", "  (cond [(string=?\
    \ s \"\") s]\n        [(string-foldr string-ci=? s #f)\n         (string-join\
    \ (reverse (string-split s)))]\n        [else (string-join (reverse (string-split\
    \ s)))]))\n", "  (cond\n    [(empty? s)\n     \"\"\n     ]\n    [(and (char-alphabetic?\
    \ (first s)) (char-lower-case? (first s)))\n     (string-append (string-upcase\
    \ (string (first s))) (solve (rest s)))\n     ]\n    [(and (char-alphabetic? (first\
    \ s)) (char-upper-case? (first s)))\n     (string-append (string-downcase (string\
    \ (first s))) (solve (rest s)))\n     ]\n    [else\n     (string-append (string\
    \ (first s)) (solve (rest s)))\n     ]\n    )\n  )\n", "  (if (string-contains-letter?\
    \ s)\n      (solve-1 s)\n      (reverse s)))\n", "  (if (null? s)\n      \"\"\n\
    \      (if (char-alphabetic? (string-ref s 0))\n          (string-append\n   \
    \        (string-downcase (string (string-ref s 0)))\n           (solve (substring\
    \ s 1 (string-length s))))\n          (string-append\n           (string (string-ref\
    \ s 0))\n           (solve (substring s 1 (string-length s)))))))\n", "  (string-join\n\
    \   (reverse\n    (map\n     (lambda (c)\n       (if (char-numeric? c) c\n   \
    \        (char-upcase c)))\n     (string->list s)))))\n", "  (if (string-contains?\
    \ (regexp \"[a-zA-Z]\") s)\n      (string-map string-upcase s)\n      (reverse\
    \ s)))\n</code>\nIs there any way to improve the performance of this program?\n\
    \n\nA:\n\nYou do not need to go the regexp way to check if a string has a letter\
    \ in it. You can simply use <code>string-any</code> with a predicate that checks\
    \ if a character is lower or upper case.\n<code>(string-any char-letter? s)\n\
    </code>\nIt is possible to do a single loop over the string. It would be better\
    \ to skip the non-letter characters in the first loop, and then just print the\
    \ reversed string.\nYou may want to use <code>list-ref</code> instead of <code>string-ref</code>\
    \ because the latter copies the string in order to return a character. This is\
    \ what makes <code>string-map</code> quadratic.\n<code>(define (solve s)\n  (if\
    \ (string-any char-letter? s)\n      (string-map string-upcase s)\n      (reverse\
    \ s)))\n</code>\n", "  (string-reverse (for/fold ([ret \"\"]\n               \
    \              [i (string-length s)])\n                    ([c (in-string s)])\n\
    \                    (cond [ (char-alphabetic? c)\n                          \
    \  (string-append ret (string-downcase c)) ]\n                          [ (char-numeric?\
    \ c)\n                            (string-append ret (string->number (string c)))\
    \ ]\n                          [ else\n                            (string-append\
    \ ret (string c)) ]))))", "  (define (rev-case c)\n    (let ([dec (char->integer\
    \ c)])\n      (if (and (>= dec 97) (<= dec 122))\n          (integer->char (-\
    \ dec 32))\n          (if (and (>= dec 65) (<= dec 90))\n              (integer->char\
    \ (+ dec 32))\n              c))))\n  (if (string-contains? s (regexp \"[a-zA-Z]\"\
    ))\n      (string-reverse (string-map rev-case (string-reverse s)))\n      (string-reverse\
    \ s)))\n", "  (string-join\n   (reverse\n    (map\n     (lambda (c)\n       (if\
    \ (char-alphabetic? c)\n           (if (char-lower-case? c)\n               (char-upcase\
    \ c)\n               (char-downcase c))\n           c))\n     (string->list s)))))",
  "  (solve-helper (string->list s) '()))\n", "  (displayln s)\n  (string-upcase s))",
  "  (string-join (string-split s #\\|) \"\"))\n</code>\nThen I try to test using\
    \ this (should always pass):\n<code>#lang racket\n", "  (if (regexp-match? #rx\"\
    [a-zA-Z]\" s)\n      (string-join\n       (map (lambda (ch)\n              (if\
    \ (char-alphabetic? ch)\n                  (if (char-lower-case? ch)\n       \
    \               (char-upcase ch)\n                      (char-downcase ch))\n\
    \                  ch))\n            (string->list s)))\n      (reverse s)))\n",
  "  (if (= 0 (count s))\n      (reverse s)\n      (string-join (map (lambda (c) (if\
    \ (char-alphabetic? c)\n                                        (if (char-lower-case?\
    \ c)\n                                            (char-upcase c)\n          \
    \                                  (char-downcase c))\n                      \
    \                  c))\n                        (string->list s)))))", "  (string-upcase\
    \ s))\n", "  (define non-letter-regexp (regexp \"[^a-zA-Z]\"))\n  (define upper-case-letter-regexp\
    \ (regexp \"[A-Z]\"))\n  (define lower-case-letter-regexp (regexp \"[a-z]\"))\n\
    \  (if (regexp-match s non-letter-regexp)\n      (string-reverse s)\n      (string-copy-and-transform\
    \ s\n                                 (lambda (c)\n                          \
    \         (if (regexp-match (string c) upper-case-letter-regexp)\n           \
    \                            (string-downcase (string c))\n                  \
    \                     (string-upcase (string c)))))))\n", "  (letrec ([reverse-case\
    \ (lambda (s)\n                           (if (= s \"\")\n                   \
    \            \"\"\n                               (string-append (if (char-numeric?\
    \ (string-ref s 0))\n                                                  (char->string\
    \ (string-ref s 0))\n                                                  (if (char-upper-case?\
    \ (string-ref s 0))\n                                                      (char->string\
    \ (char-downcase (string-ref s 0)))\n                                        \
    \              (char->string (char-upcase (string-ref s 0)))))\n             \
    \                                 (reverse-case (substring s 1)))))]\n       \
    \  [has-letter? (lambda (s)\n                        (if (= s \"\")\n        \
    \                    #f\n                            (if (char-alphabetic? (string-ref\
    \ s 0))\n                                #t\n                                (has-letter?\
    \ (substring s 1)))))]\n         [handle-str (lambda (s)\n                   \
    \    (if (has-letter? s)\n                           (reverse-case s)\n      \
    \                     (reverse s)))])\n    (handle-str s)))", "  (cond [(ormap\
    \ (\u03BB (c) (char-alpha? c)) (string->list s))\n         (if (ormap (\u03BB\
    \ (c) (char-upper-case? c)) (string->list s))\n             (string-upcase s)\n\
    \             (string-downcase s))]\n        [else (reverse s)]))\n```\n\n```racket\n\
    #lang racket\n", "  (cond\n    [(empty? s) \"\" ]\n    [(letter? (first s))\n\
    \      (cons (reverse-case (first s)) (solve (rest s)))]\n    [else\n      (cons\
    \ (first s) (solve (rest s)))]))\n", "  (define (reverse ch)\n    (if (char-numeric?\
    \ ch)\n        ch\n        (if (char-upcase? ch)\n            (char-downcase ch)\n\
    \            (char-upcase ch))))\n  (if (string-empty? s)\n      \"\"\n      (reverse\
    \ (string-ref s 0))\n      (solve (substring s 1))))\n</code>\nThis code is not\
    \ working as it should. I am getting <code>#A@c</code> instead of <code>#A@C</code>.\n\
    I am using the Standard ML language, if that matters.\nI can't understand what\
    \ I am doing wrong here.\n\n\nA:\n\nIf you want the reversed string, you need\
    \ to start with the last character, not the first. \n<code>(define (solve s)\n\
    \  (if (string-empty? s)\n      \"\"\n      (let ((ch (string-ref s (sub1 (string-length\
    \ s)))))\n        (string-append (reverse ch) (solve (substring s 0 -1))))))\n\
    </code>\n", "  (regexp-replace* #rx\"[a-z]\"\n                   s\n         \
    \          (\u03BB (word)\n                     (if (string-contains-ci? \"a\"\
    \ word)\n                         (string-downcase word)\n                   \
    \      (string-upcase word)))))\n</code>\n", "  (cond [(empty? s) \"\"]\n    \
    \    [(alphabetic? (first s)) (string-append (if (char-upper-case? (first s))\n\
    \                                                   (string-append (string-downcase\
    \ (first s)) \"\")\n                                                   (string-append\
    \ (string-upcase (first s)) \"\")) (solve (rest s)))]\n        [else (string-append\
    \ (first s) (solve (rest s)))]))", "  (string-reverse s))\n</code>\nThe last three\
    \ tests are failing because the function is being executed after the last test\
    \ which should not be the case.\nAny help would be appreciated.\n\n\nA:\n\nIt's\
    \ probably because you're not using the expected API for <code>check-expect</code>.\
    \ Instead of using <code>check-expect</code> like a function, use it as a special\
    \ form:\n<code>(check-expect (solve \"\") \"\")\n</code>\n", "  (cond\n    [(empty?\
    \ s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n     (if (char-lower-case?\
    \ (string-ref s 0))\n         (string-upcase s)\n         (string-downcase s))]\n\
    \    [else (string-append (string-ref s 0) (solve (substring s 1)))]))\n</code>\n\
    My solution is pretty good. But I'm having some issues with the notation.\n1)\
    \ I don't understand how to write the base case. \n2) I don't understand what\
    \ is this substring notation. It seems that substring is a function that takes\
    \ a string and 2 indexes and returns a substring between these indexes. But the\
    \ notation in this case is different than the notation of a function call.\n\n\
    \nA:\n\n<code>string-append</code> simply appends two strings. In your case, you\
    \ want to append the first character to the string returned by <code>solve</code>\
    \ on the remaining characters. So, you can just do this:\n<code>(string-append\
    \ (string-ref s 0) (solve (substring s 1)))\n</code>\nAs for the base case, if\
    \ you run out of characters in the string, then the string is empty:\n<code>(empty?\
    \ s)\n</code>\n", "  (if (and (empty? s)\n           (zero? (string-length s)))\n\
    \      \"\"\n      (string-join\n       (reverse (map (\u03BB (c)\n          \
    \             (if (or (char-alphabetic? c)\n                               (char-ci-alphabetic?\
    \ c))\n                           (char-upcase c)\n                          \
    \ (char-downcase c)))\n                     (string->list s)))\n       \"\")))\n",
  "  (if (regexp-match #rx\"[a-zA-Z]\" s)\n      (apply string-append (map (\u03BB\
    \ (x)\n                                  (if (regexp-match #rx\"[a-zA-Z]\" (string\
    \ x))\n                                      (string (char-downcase x))\n    \
    \                                  (string (char-upcase x))))\n              \
    \                  s))\n      (string-reverse s)))\n", "  (define (is-letter?\
    \ c)\n    (and (<= #\\a c) (<= c #\\z))\n    (and (<= #\\A c) (<= c #\\Z)))\n\
    \  (string-map\n   (lambda (c)\n     (if (is-letter? c)\n         (if (char-lower-case?\
    \ c)\n             (char-upcase c)\n             (char-lower-case c))\n      \
    \   c))\n   s))\n```\n\n### Coffee - Get the Middle Character\n\n- [CodeWars](https://www.codewars.com/kata/56747fd5cb988479af000028/train/coffeescript)\n\
    \n```coffeescript\n# You are going to be given a word. Your job is to return the\
    \ middle character of the word.\n# If the word's length is odd, return the middle\
    \ character.\n# If the word's length is even, return the middle 2 characters.\n\
    #\n# #Examples:\n#\n# Kata.getMiddle(\"test\") should return \"es\"\n#\n# Kata.getMiddle(\"\
    testing\") should return \"t\"\n#\n# Kata.getMiddle(\"middle\") should return\
    \ \"dd\"\n#\n# Kata.getMiddle(\"A\") should return \"A\"\n# #Input\n#\n# A word\
    \ (string) of length 0 < str < 1000 (In javascript you may get slightly more than\
    \ 1000 in some test cases due to an error in the test cases). You do not need\
    \ to test for this. This is only here to tell you that you do not need to worry\
    \ about your solution timing out.\n#\n# #Output\n#\n# The middle character(s)\
    \ of the word represented as a string.\n\ngetMiddle = (s) ->\n  if s.length %\
    \ 2 == 0\n    s[(s.length / 2 - 1)..(s.length / 2)]\n  else\n    s[Math.floor(s.length\
    \ / 2)]\n```\n\n### Haskell - Get the Middle Character\n\n- [CodeWars](https://www.codewars.com/kata/56747fd5cb988479af000028/train/haskell)\n\
    \n```haskell\n-- You", "  (cond\n    [(and (not (number? s)) (not (integer? s)))\n\
    \     (define (upper-char? c) (contains (char-upcase c) s))\n     (define (lower-char?\
    \ c) (contains (char-downcase c) s))\n     (if (or (upper-char? #\\a) (lower-char?\
    \ #\\a))\n         (for/string ([c s])\n           (if (or (upper-char? c) (lower-char?\
    \ c))\n               (if (upper-char? c) (char-downcase c) (char-upcase c))\n\
    \               c))\n         (reverse s))]\n    [else (reverse s)]))", "  (if\
    \ (empty? s) \"\"\n      (if (string-contains-ci? (list->string (list (string-ref\
    \ s 0))) \"abcdefghijklmnopqrstuvwxyz\")\n        (string-append (string (char-upcase\
    \ (string-ref s 0)))\n                       (solve (substring s 1)))\n      \
    \  (string-append (string (char-downcase (string-ref s 0)))\n                \
    \       (solve (substring s 1))))))\n</code>\nThe version I've found that includes\
    \ string-any, but it does not work.\n<code>#lang racket\n", "  (if (string-contains\
    \ s #\\a)\n      (if (string-contains s #\\A)\n          (map char-upcase s)\n\
    \          (map char-downcase s))\n      (string-reverse s)))\n</code>\n", " \
    \ (if (string-null? s)\n      \"\"\n      (if (char-lower-case? (string-ref s\
    \ 0))\n          (string-append (string-upper-case (substring s 0 1))\n      \
    \                   (solve (substring s 1)))\n          (if (char-upper-case?\
    \ (string-ref s 0))\n              (string-append (string-lower-case (substring\
    \ s 0 1))\n                             (solve (substring s 1)))\n           \
    \   (string-append (substring s 0 1)\n                             (solve (substring\
    \ s 1)))))))\n", "  (if (null? s)\n      (string)\n      (if (char-alpha? (string-ref\
    \ s 0))\n          (if (char-lower-case? (string-ref s 0))\n              (string-append\
    \ (list (char-upcase (string-ref s 0)))\n                             (solve (substring\
    \ s 1)))\n              (string-append (list (char-downcase (string-ref s 0)))\n\
    \                             (solve (substring s 1))))\n          (string-append\
    \ (list (string-ref s 0))\n                         (solve (substring s 1))))))\n",
  "  (cond [(no-letter? s) (reverse s)]\n        [else (build-string (length s)\n\
    \                            (lambda (i) (let ([ch (string-ref s i)])\n      \
    \                                    (if (letter? ch)\n                      \
    \                        (if (upper-case? ch)\n                              \
    \                    (char-downcase ch)\n                                    \
    \              (char-upcase ch))\n                                           \
    \   ch))))]))\n", "  (let ([s (string-&gt;list s)])\n    (if (andmap char-alphabetic?\
    \ s)\n        (map (curry char-upcase (char-downcase #\\a)) s)\n        (reverse\
    \ s))))\n</code>\n", "  (apply string (map (lambda (c) (if (char-alphabetic? c)\
    \ (char-upcase c) (char-downcase c))) s)))\n", "  (if (empty? s)\n      s\n  \
    \    (string-append\n       (if (char-alphabetic? (string-ref s 0))\n        \
    \   (string-titlecase s)\n           (string-reverse s))\n       (solve (substring\
    \ s 1)))))\n", "  (if (equal? s \"\") \"\"\n      (string-join (reverse (map (lambda\
    \ (c) (if (char-alphabetic? c) (string-upcase c) (string-downcase c))) (string->list\
    \ s))) \"\")))\n", "  (cond ((null? s) \"\")\n        ((char-alphabetic? (string-ref\
    \ s 0))\n         (string-append (string-downcase (string (string-ref s 0)))\n\
    \                        (solve (substring s 1))))\n        ((char-numeric? (string-ref\
    \ s 0))\n         (string-append (string (string-ref s 0))\n                 \
    \       (solve (substring s 1))))\n        (else (string-append (string-upcase\
    \ (string (string-ref s 0)))\n                             (solve (substring s\
    \ 1))))))\n", "  (if (string-empty? s)\n      s\n      (string-reverse\n     \
    \  (string-map (lambda (c)\n                     (if (char-alphabetic? c)\n  \
    \                       (char-downcase c)\n                         (char-upcase\
    \ c)))\n                   s))))\n", "  (regexp-replace* #rx\".\" s\n        \
    \           (lambda (m)\n                     (if (regexp-match? #rx\"[A-Za-z]\"\
    \ (match:substring m))\n                         (case-fold (match:substring m))\n\
    \                         (string-reverse s)))))\n</code>\n", "  (cond ((not (member\
    \ s '(\"\"))) (string-&gt;list s))\n        ((member s '(\"\")) \"\")\n      \
    \  (else (string-reverse s))))\n</code>\nAs you can see, I tried to use the <code>cond</code>\
    \ expression, but I don't know how to use the rest of the <code>if</code> statement,\
    \ because I don't know what arguments I should put in it.\nI also tried to use\
    \ <code>if</code>, but I get an error that I can't use <code>if</code> as a function.\n\
    \n\nA:\n\nYou can use <code>cond</code> like this:\n<code>(define (solve s)\n\
    \  (cond ((string=? s \"\") s)\n        ((string-empty? s) s)\n        (else\n\
    \         (string-reverse s))))\n</code>\nAnd here is a function that solves the\
    \ original problem and works as specified by you. I'm using <code>string-upcase</code>\
    \ and <code>string-downcase</code>, which are provided by <code>racket/string</code>\
    \ or <code>racket</code> (it contains all the other libraries by default).\n<code>(define\
    \ (solve s)\n  (string-join\n   (map\n    (lambda (c)\n      (cond ((char-alphabetic?\
    \ c)\n             (if (char-upper-case? c)\n                 (string-downcase\
    \ (string c))\n                 (string-upcase (string c))))\n            (else\
    \ (string c))))\n    (string-&gt;list s))))\n</code>\n", "  (regexp-replace* #rx\"\
    ([a-z])([A-Z])\" s\n                   (lambda (m) (string-append (caddr m) (cadr\
    \ m)))))\n", '  (define (i', "  (apply string (reverse (map (\u03BB (x) (cond\
    \ [(letter? x) (char-upcase (char-downcase x))] [else x])) (string->list s)))))\n\
    ```", "  (cond\n    [(or (string=? s \"\") (string=? s (string-upcase s))) (string-reverse\
    \ s)]\n    [else (string-upcase s)]))", "  (display s)\n  (newline)\n  (string-map\n\
    \   (lambda (c)\n     (if (and (&gt;= c #\\a) (&lt;= c #\\z))\n         (char-upcase\
    \ c)\n         (if (and (&gt;= c #\\A) (&lt;= c #\\Z))\n             (char-downcase\
    \ c)\n             c)))\n   s))\n", "  (string-replace (reverse (string-replace\
    \ s\n                                          #rx\"[a-zA-Z]\"\n             \
    \                             (lambda (x)\n                                  \
    \          (string-upcase x))))\n                  #rx\"[a-zA-Z]\"\n         \
    \         (lambda (x)\n                    (string-downcase x))))\n</code>\n",
  "  (if (string-contains? s #\\letter)\n      (string-fold\n       (lambda (letter\
    \ acc)\n         (cond\n           [(char-lower-case? letter) (string-append acc\
    \ (string-upcase letter))]\n           [(char-upper-case? letter) (string-append\
    \ acc (string-downcase letter))]\n           [else (string-append acc (string\
    \ letter))]))\n       \"\"\n       s)\n      (string-reverse s)))", "  (string-&gt;list\
    \ s))\n", "  (if (or (string-contains? s #\\A) (string-contains? s #\\a))\n  \
    \    (for/fold ([ret \"\"] ([ch (in-string s)]) #:when (char-alphabetic? ch))\n\
    \               (string-append ret (swap-case ch)))\n      (reverse s)))\n</code>\n\
    This is more clear but less concise:\n<code>#lang racket\n", "  (if (regexp-match\
    \ #rx\"[a-zA-Z]\" s)\n      (string-downcase s)\n      (string-upcase s)))\n",
  "  (let loop ([i 0] [s (string->list s)])\n    (if (= i (length s))\n        (list->string\
    \ s)\n        (if (char-alphabetic? (list-ref s i))\n            (loop (+ i 1)\n\
    \                  (list-replace s i (char-upcase (list-ref s i))))\n        \
    \    (loop (+ i 1)\n                  (list-replace s i (char-downcase (list-ref\
    \ s i))))))))", "  (define (reverse-case c)\n    (cond\n      ((and (char-upper-case?\
    \ c) (char-lower-case? c)) c)\n      ((char-upper-case? c) (char-downcase c))\n\
    \      ((char-lower-case? c) (char-upcase c))\n      (else c)))\n  (if (not (string-contains\
    \ s char-set:letter)) (string-reverse s)\n    (string-map reverse-case s)))",
  "  (reverse s))\n</code>\nTest case:\n<code>#lang racket", "  (string-join (map\
    \ (lambda (x) (if (string-alphabetic? x) (string-downcase x) (string-upcase x)))\
    \ (string->list s)) \"\"))\n", "  (match s\n    [() s]\n    [(_) (list->string\
    \ (reverse (string->list s)))]))", "  (cond\n    [(empty? s) \"\" ]\n    [(string-contains?\
    \ s #\\letter) \n     (string-append (solve (rest s)) (string-upcase (string-downcase\
    \ (string-ref s 0))))]\n    [else (string-append (solve (rest s)) (string-ref\
    \ s 0))]))\n\n", "  (define (is-letter? ch)\n    (regexp-match #rx\"[a-zA-Z]\"\
    \ ch))\n  (define (is-upcase? ch)\n    (regexp-match #rx\"[A-Z]\" ch))\n  (define\
    \ (reverse-case-1 ch)\n    (if (is-upcase? ch)\n        (string-downcase ch)\n\
    \        (string-upcase ch)))\n  (define (reverse-case-all s)\n    (apply string-append\
    \ (map reverse-case-1 s)))\n  (define (has-letter? s)\n    (regexp-match #rx\"\
    .\" s))\n  (define (reverse-string s)\n    (apply string-append (reverse (string->list\
    \ s))))\n  (if (has-letter? s)\n      (reverse-case-all s)\n      (reverse-string\
    \ s)))\n", "  (cond\n    [(equal? s \"\") s]\n    [(string-ref s 0)\n     (define\
    \ a (build-string (string-length s) \"\"))\n     (for/fold ([s1 a]) ([i (in-range\
    \ (string-length s))])\n       (cond\n         [(char-numeric? (string-ref s i))\n\
    \          (string-set! s1 i (string-ref s i))]\n         [(char-lower-case? (string-ref\
    \ s i))\n          (string-set! s1 i (char-upcase (string-ref s i)))]\n      \
    \   [(char-upper-case? (string-ref s i))\n          (string-set! s1 i (char-downcase\
    \ (string-ref s i))))])\n     (reverse s1)]\n    [else (reverse s)]))", "  (let\
    \ ((s-length (string-length s)))\n    (if (= s-length 0)\n        \"\"\n     \
    \   (let loop ((s s)\n                   (s-rev \"\"))\n          (if (zero? (string-length\
    \ s))\n              s-rev\n              (loop (substring s 1)\n            \
    \        (if (char-alphabetic? (string-ref s 0))\n                        (string-append\
    \ s-rev\n                                       (string-fold (lambda (c1 c2)\n\
    \                                                      (if (char-alphabetic? c1)\n\
    \                                                          (if (char-upper-case?\
    \ c1)\n                                                              (char-downcase\
    \ c1)\n                                                              (char-upcase\
    \ c1))\n                                                          c1))\n     \
    \                                               \"\"\n                       \
    \                             (substring s 0 1)))\n                        (string-append\
    \ s-rev (substring s 0 1))))))))\n</code>\nThe code works. But I am not sure how\
    \ to make it more idiomatic. So I would like some feedback on:\n\ncode style and\
    \ readability\nefficiency (I do not really care about the efficiency for this\
    \ case, but for the sake of learning, I would like to understand how I can write\
    \ more efficient code).\nhow to make it more idiomatic\n\n\n\nA:\n\nThere are\
    \ two steps:\n\nReversing the string\nChanging the case of the letters\n\nThe\
    \ second step can be done by folding over the string. The first step can be done\
    \ by folding over the string too, but it's simpler to just use the <code>string-&gt;list</code>\
    \ and <code>list-&gt;string</code> functions:\n<code>(define (solve s)\n  (if\
    \ (string-empty? s)\n      \"\"\n      (list-&gt;string\n       (map (lambda (c)\n\
    \              (if (char-alphabetic? c)\n                  (if (char-upper-case?\
    \ c)\n                      (char-downcase c)\n                      (char-upcase\
    \ c))\n                  c))\n            (string-&gt;list s)))))\n</code>\n",
  "  (define pattern \"^[a-zA-Z]$\")\n  (string-join (reverse (map (lambda (x)\n \
    \                              (if (regexp-match pattern x)\n                \
    \                   (if (string-ci=? x (string-downcase x))\n                \
    \                       (string-upcase x)\n                                  \
    \     (string-downcase x))\n                                   x)) (string->list\
    \ s))) \"\"))", "  (define (help s i acc)\n    (cond\n      [(= i 0) (string-append\
    \ acc (string (integer->char (char->integer (string-ref s i)))))]\n      [(char-alphabetic?\
    \ (string-ref s i)) (help s (- i 1) (string-append acc (string (integer->char\
    \ (+ (char->integer (string-ref s i)) (* (char->integer #\\a) (- #\\a #\\A)))))))]\n\
    \      [else (help s (- i 1) (string-append acc (string (char->integer (string-ref\
    \ s i)))))]))\n  (if (string-alphabetic? s)\n      (help s (- (string-length s)\
    \ 1) \"\")\n      (reverse s)))\n", "  (cond\n    [(string=? s \"\") \"\"]\n \
    \   [(string=? s (string-upcase s)) (string-downcase s)]\n    [(string=? s (string-downcase\
    \ s)) (string-upcase s)]\n    [else\n     (apply string (reverse (map char-upcase\
    \ (string->list s))))]))\n", "  (if (string-contains? s #\\a) \n      (string-reverse\
    \ (map (\u03BB (c) (if (char-alphabetic? c) \n                               \
    \         (char-upcase c) \n                                        (char-downcase\
    \ c)))\n                           s))\n      (string-reverse s)))\n", "  (letrec\
    \ ([char-letters? (lambda (c) (char-alphabetic? c))]\n           [char-lower?\
    \ (lambda (c) (char-lower-case? c))]\n           [char-upper? (lambda (c) (char-upper-case?\
    \ c))]\n           [char-flip-case (lambda (c)\n                             (if\
    \ (char-letters? c)\n                                 (if (char-lower? c)\n  \
    \                                   (char-upcase c)\n                        \
    \             (char-downcase c))\n                                 c))]\n    \
    \       [string-flip-case (lambda (s)\n                               (string-join\
    \ (map char-flip-case (string->list s))))])\n    (string-flip-case s)))", "  (apply\
    \ string\n         (map (lambda (x)\n                (if (or (char-alphabetic?\
    \ x)\n                        (char-numeric? x))\n                    (if (char-alphabetic?\
    \ x)\n                        (char-downcase x)\n                        (char-upcase\
    \ x))\n                    x))\n              (string->list s))))\n```\n\n## [Make\
    \ a list of the first n Fibonacci numbers](https://www.codewars.com/kata/522551eee9abb932420004a0)\n\
    \nThis is almost too easy using Racket's `fib` and `build-list` functions. I just\
    \ modified the `fib` function to handle negative numbers.\n\n```scheme\n#lang\
    \ racket\n", "  (if (empty? s)\n      s\n      (if (char-alphabetic? (string-ref\
    \ s 0))\n          (string-append (string-upcase (string-ref s 0))\n         \
    \                (solve (substring s 1 (string-length s))))\n          (string-append\
    \ (string-downcase (string-ref s 0))\n                         (solve (substring\
    \ s 1 (string-length s)))))))\n", "  (cond [(null? s)\n         s]\n        [(char-alphabetic?\
    \ (string-ref s 0))\n         (string-append (string-downcase (string (string-ref\
    \ s 0)))\n                        (solve (substring s 1)))]\n        [else\n \
    \        (string-append (string-upcase (string (string-ref s 0)))\n          \
    \              (solve (substring s 1)))]))\n", "  (for/fold ([sol \"\"] #:when\
    \ (char-alphabetic? (first c)))\n    ([c (in-string s)])\n    (string-append sol\n\
    \                   (if (char-alphabetic? c)\n                       (char-upcase\
    \ c)\n                       (char-downcase c)))))\n", "  (apply string (map \n\
    \                 (lambda (x)\n                   (if (char-alphabetic? x)\n \
    \                      (if (char-lower-case? x)\n                           (char-upcase\
    \ x)\n                           (char-downcase x))\n                       x))\n\
    \                 s)))\n```\n\n#### Reverse Polish Notation Calculator\n```#lang\
    \ racket\n", "  (string-reverse (string-map (lambda (char)\n                 \
    \             (if (and (char-upper-case? char) (char-lower-case? char))\n    \
    \                            (char-downcase char)\n                          \
    \      (char-upcase char)))\n                            s)))\n", "  (if (string-contains\
    \ s #\\a #\\z)\n      (string-map (lambda (c) (if (char-alphabetic? c) (char-upcase\
    \ c) (char-downcase c))) s)\n      (string-reverse s)))\n</code>\nI am trying\
    \ to translate this to Clojure:\n<code>(defn solve [s]\n  (if (or (.contains s\
    \ \"a\") (.contains s \"z\"))\n      (clojure.string/replace s #(if (char-alphabetic?\
    \ %) (char-upcase %) (char-downcase %)))\n      (clojure.string/reverse s)))\n\
    </code>\nThis does not work however.\nAny ideas?\n\n\nA:\n\nYou have a few problems:\n\
    \nThe <code>if</code> doesn't return anything in the case where there are letters\
    \ in the string.\nThe second argument to <code>clojure.string/replace</code> should\
    \ be a regex character class, not a predicate function.\n<code>string-map</code>\
    \ returns a string, but <code>clojure.string/replace</code> returns a sequence\
    \ of strings.\n\nHere's a version that works:\n<code>(defn solve [s]\n  (if (or\
    \ (.contains s \"a\") (.contains s \"z\"))\n      (-&gt;&gt; (clojure.string/replace\
    \ s #\"[a-z]\" #(if (char-alphabetic? %)\n                                   \
    \                  (char-upcase %)\n                                         \
    \            (char-downcase %)))\n           (apply str))\n      (clojure.string/reverse\
    \ s)))\n</code>\nIt's almost a one-to-one rewrite of the Racket code, but I'm\
    \ not sure if that's a good thing.\n", "  (string-upcase (string-downcase s)))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(or (= (char-upcase (string-ref s 0)) (string-ref\
    \ s 0))\n         (= (char-downcase (string-ref s 0)) (string-ref s 0)))\n   \
    \  (string-append (solve (substring s 1)) (string (string-ref s 0)))]\n    [else\
    \ (string-append (solve (substring s 1)) (string (char-upcase (string-ref s 0))))]))\n",
  "  (if (empty? s) \"\"\n      (if (regexp-match #rx\"[A-Za-z]\" s)\n          (string-join\
    \ (list (char-upcase (string-ref s 0)) (char-downcase (string-ref s 1))) \"\"\
    )\n          (string-reverse s))))\n", "  (cond\n    [(empty? s) (string)]\n \
    \   [(letter? (car s))\n     (cons (or (char-downcase (car s)) (char-upcase (car\
    \ s)))\n           (solve (cdr s)))]\n    [else (cons (car s) (solve (cdr s)))]))\n",
  "  (cond [(empty? s) \"\"]\n        [(string-upcase? (substring s 0 1)) (string-append\
    \ (substring s 0 1) (solve (substring s 1)))]\n        [(string-downcase? (substring\
    \ s 0 1)) (string-append (substring s 0 1) (solve (substring s 1)))]\n       \
    \ [else (string-append (substring s 1) (string-downcase (substring s 0 1)))]))\n",
  "  (string-join (map\n                (lambda (c)\n                  (if (char-alphabetic?\
    \ c)\n                      (char-upcase c)\n                      (char-downcase\
    \ c)))\n                (reverse (string->list s)))))\n", "  (define (helper s\
    \ result)\n    (cond [(empty? s) result]\n          [(char-numeric? (first s))\
    \ (helper (rest s) (string-append result (string (first s))))]\n          [(char-alphabetic?\
    \ (first s)) (cond [(char-upper-case? (first s)) (helper (rest s) (string-append\
    \ result (string (char-downcase (first s)))))]\n                             \
    \                 [else (helper (rest s) (string-append result (string (char-upcase\
    \ (first s)))))]\n                                              )]\n         \
    \ [else (helper (rest s) (string-append result (string (first s))))]))\n  (if\
    \ (empty? s) s (helper s \"\")))\n", "  (string-map\n   (lambda (ch)\n     (cond\n\
    \       ((char-alphabetic? ch)\n        (char-upcase ch))\n       (else\n    \
    \    (char-downcase ch))))\n   s))\n```\n\n```racket\n#lang racket\n", "  (if\n\
    \      (equal?\n       (string-contains s (regexp \"[A-Za-z]\"))\n       #f)\n\
    \      (string-reverse s)\n      (string-map\n       (lambda (x)\n         (if\n\
    \             (char-alphabetic? x)\n             (if\n                 (char-upper-case?\
    \ x)\n                 (char-downcase x)\n                 (char-upcase x))\n\
    \             x))\n       s)))", "  (if (string-contains? s #\\a #\\z)\n     \
    \ (map (lambda (x) (if (or (char-alphabetic? x)\n                            \
    \   (char-alphabetic? (+ x #\\A #\\a)))\n                           (char-upcase\
    \ x)\n                           (char-downcase x)))\n           s)\n      (reverse\
    \ s)))\n", "  (define (is-letter? x) (and (char? x) (or (char-alphabetic? x) (char-numeric?\
    \ x))))\n  (string-join (reverse (map (\u03BB (x) (if (is-letter? x) (char-upcase\
    \ x) (char-downcase x))) s))))\n", "  (if (string-any (\u03BB (c) (char-alphabetic?\
    \ c)) s)\n      (string-map (\u03BB (c) (if (char-alphabetic? c)\n           \
    \                  (if (char-lower-case? c)\n                                \
    \ (char-upcase c)\n                                 (char-downcase c))\n     \
    \                        c)) s)\n      (reverse s)))\n", "  (if (string-empty?\
    \ s)\n      \"\"\n      (let ([ch (string-ref s 0)])\n        (if (string-every\
    \ char-alphabetic? s)\n            (string-join (reverse (string->list s)))\n\
    \            (if (char-alphabetic? ch)\n                (string-append (string-append\
    \ (string-downcase ch) (solve (substring s 1))) \"\")\n                (string-append\
    \ (string-append ch (solve (substring s 1))) \"\"))))))\n", "  (if (string-contains?\
    \ s #\\@)\n      (regexp-replace #rx\"[a-zA-Z]\" s string-upcase)\n      (regexp-replace\
    \ #rx\"[a-zA-Z]\" s string-downcase)))\n", "  (if (string-contains s #\\a)\n \
    \     (string-map (lambda (x) (if (char-alphabetic? x)\n                     \
    \             (if (char-lower-case? x)\n                                     \
    \ (char-upcase x)\n                                      (char-downcase x))\n\
    \                                  x)) s)\n      (string-reverse s)))\n", "  (regexp-replace*\
    \ #rx\"[A-Z]\" s (lambda (s) (string-downcase s)))\n  (regexp-replace* #rx\"[a-z]\"\
    \ s (lambda (s) (string-upcase s)))\n  (regexp-replace* #rx\"[^A-Za-z]\" s (lambda\
    \ (s) s))\n  )\n</code>\nWhen I run this, it returns the same string with no changes.\n\
    I'm using this to call the function:\n<code>(solve \"AaBb\")</code>\nI'm expecting\
    \ it to return <code>\"aAbB\"</code>\nWhy is that I get no changes in the string?\n\
    \n\nA:\n\nThe function <code>regexp-replace*</code> does not modify its first\
    \ argument. It returns a new string, the result of the replacement:\n<code>(regexp-replace*\
    \ #rx\"[A-Z]\" s (lambda (s) (string-downcase s)))\n</code>\nYou should use it\
    \ in a <code>let</code> binding to assign the new value back to <code>s</code>:\n\
    <code>(define (solve s)\n  (let ((s (regexp-replace* #rx\"[A-Z]\" s (lambda (s)\
    \ (string-downcase s)))))\n    (let ((s (regexp-replace* #rx\"[a-z]\" s (lambda\
    \ (s) (string-upcase s)))))\n      (regexp-replace* #rx\"[^A-Za-z]\" s (lambda\
    \ (s) s)))))\n</code>\nOr use <code>let*</code> to bind them together:\n<code>(define\
    \ (solve s)\n  (let* ((s (regexp-replace* #rx\"[A-Z]\" s (lambda (s) (string-downcase\
    \ s))))\n         (s (regexp-replace* #rx\"[a-z]\" s (lambda (s) (string-upcase\
    \ s)))))\n    (regexp-replace* #rx\"[^A-Za-z]\" s (lambda (s) s))))\n</code>\n",
  "  (cond ((not (string-contains? s #\\a))\n         (reverse s))\n        (else\n\
    \         (let loop ([i 0] [acc (make-string (string-length s))])\n          \
    \ (if (= i (string-length s))\n               acc\n               (let ([ch (string-ref\
    \ s i)])\n                 (string-set! acc i\n                              (if\
    \ (char-alphabetic? ch)\n                                  (if (char-lower-case?\
    \ ch)\n                                      (char-upcase ch)\n              \
    \                        (char-downcase ch))\n                               \
    \   ch))\n                 (loop (+ i 1) acc)))))))\n", "  (string-reverse s))\n",
  "  (if (= 0 (count s #\\a))\n      (reverse s)\n      (string-map (lambda (c)\n\
    \                    (if (char-alphabetic? c)\n                        (if (char-lower-case?\
    \ c)\n                            (char-upcase c)\n                          \
    \  (char-downcase c))\n                        c))\n                  s)))\n",
  "  (cond [(zero? (length s)) \"\"]\n        [(char-alphabetic? (string-ref s 0))\n\
    \         (build-string (length s)\n          (lambda (i)\n            (cond [(char-alphabetic?\
    \ (string-ref s i))\n                   (char-downcase (string-ref s i))]\n  \
    \                [else (string-ref s i)])))]\n        [else (build-string (length\
    \ s)\n          (lambda (i)\n            (cond [(char-alphabetic? (string-ref\
    \ s i))\n                   (char-upcase (string-ref s i))]\n                \
    \  [else (string-ref s i)])))]))\n", "  (reverse s))\n", "  (cond [(empty? s)\
    \ s]\n        [(char-alphabetic? (string-ref s 0))\n         (string-append (string-downcase\
    \ (string-ref s 0)) (solve (substring s 1)))]\n        [(char-numeric? (string-ref\
    \ s 0))\n         (string-append (string-ref s 0) (solve (substring s 1)))]\n\
    \        [else\n         (string-append (string-upcase (string-ref s 0)) (solve\
    \ (substring s 1)))]))\n</code>\n", "  (if (not (string-contains-ci? s \"[a-zA-Z]\"\
    ))\n      (string-reverse s)\n      (string-flatten\n       (map (lambda (c)\n\
    \               (if (char-ci=? c (char-upcase c))\n                   (char-downcase\
    \ c)\n                   (char-upcase c)))\n            s))))\n", "  (if (string-contains-char?\
    \ s #\\a #\\z)\n      (string-map (lambda (c) (if (char-alphabetic? c)\n     \
    \                             (if (char-lower-case? c)\n                     \
    \                 (char-upcase c)\n                                      (char-downcase\
    \ c))\n                                  c))\n                  s)\n      (string-reverse\
    \ s)))\n</code>\nI would like to improve the code. Any suggestion?\n\n\nA:\n\n\
    <code>#lang racket\n", "  (string-reverse (apply string (map reverse-case (string->list\
    \ s)))))\n", "  (define (invert-case ch)\n    (let ((c (integer->char (char->integer\
    \ ch))))\n      (if (char-ci=? c ch)\n          (char-upcase c)\n          (char-downcase\
    \ c))))\n  (if (string-contains s #\\a)\n      (string-map invert-case s)\n  \
    \    (string-reverse s)))\n", "  (let ([t (string->list s)])\n    (cond [(string=?\
    \ s \"\") s]\n          [(ormap char-numeric? t) (reverse s)]\n          [else\
    \ (list->string (map\n                                (lambda (char)\n       \
    \                           (cond [(char-lower-case? char) (char-upcase char)]\n\
    \                                        [(char-upper-case? char) (char-downcase\
    \ char)]\n                                        [else char]))\n            \
    \                    t))])))\n", "  (cond ((string-index s #\\a) (string-reverse\
    \ (string-upcase s)))\n        ((string-index s #\\A) (string-reverse (string-downcase\
    \ s)))\n        (else (string-reverse s))))\n", "  (cond [(empty? s) s]\n    \
    \    [(letter? (car s)) (append (char-downcase (car s)) (solve (cdr s)))]\n  \
    \      [(letter? (cdr s)) (append (char-upcase (car s)) (solve (cdr s)))]\n  \
    \      [else (append (char-upcase (car s)) (solve (cdr s)))]))\n", "  (define\
    \ (rev-ch c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case? c)\n\
    \            (char-downcase c)\n            (char-upcase c))\n        c))\n  (if\
    \ (string-ref s 0)\n      (list->string (reverse (map rev-ch (string->list s))))\n\
    \      (reverse s)))\n", "  (define (is-letter? a)\n    (or (char-lower-case?\
    \ a) (char-upper-case? a)))\n  (define (flip c)\n    (if (char-lower-case? c)\n\
    \        (char-upcase c)\n        (char-downcase c)))\n  (define (rev-case-string\
    \ s)\n    (cond\n      [(null? s) '()]\n      [(is-letter? (car s)) (cons (flip\
    \ (car s)) (rev-case-string (cdr s)))]\n      [else (cons (car s) (rev-case-string\
    \ (cdr s)))]))\n  (define (has-letter? s)\n    (cond\n      [(null? s) #f]\n \
    \     [(is-letter? (car s)) #t]\n      [else (has-letter? (cdr s))]))\n  (if (has-letter?\
    \ s)\n      (rev-case-string s)\n      (string-reverse s)))", "  (cond\n    [(equal?\
    \ (string-length s) 0) \"\"]\n    [(char-alphabetic? (string-ref s 0)) (string-append\
    \ (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n    [(char-numeric?\
    \ (string-ref s 0)) (string-append (string-ref s 0) (solve (substring s 1)))]\n\
    \    [(char-ci=? (string-ref s 0) #\\@) (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [(char-ci=? (string-ref s 0) #\\#) (string-append (string-ref\
    \ s 0) (solve (substring s 1)))]\n    [else (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))", "  (if (string-contains-predicate (\u03BB\
    \ (c) (char-alphabetic? c)) s)\n      (string-map\n       (\u03BB (c)\n      \
    \   (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n        \
    \         (char-upcase c)\n               (char-downcase c))\n             c))\n\
    \       s)\n      (string-reverse s)))", "  (if (string-empty? s) \"\"\n     \
    \ (if (or (char-lower-case? (string-ref s 0)) (char-upper-case? (string-ref s\
    \ 0)))\n          (if (char-lower-case? (string-ref s 0)) (string-upper-case (string-ref\
    \ s 0)) (string-lower-case (string-ref s 0)))\n          (string-ref s 0))))\n",
  "  (if (string-contains-ci? s #\\a)\n      (string-upcase s)\n      (string-reverse\
    \ s)))", "  (define (invert-case c)\n    (if (char-alphabetic? c)\n        (if\
    \ (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (if (string-contains s #\\a)\n      (string-map invert-case\
    \ s)\n      (string-reverse s)))\n", "  (define (flip-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-upper-case? c)\n            (char-downcase c)\n      \
    \      (char-upcase c))\n        c))\n  (string-join\n   (list->vector\n    (map\
    \ flip-case (string->list s)))))\n", "  (cond\n    [(string=? \"\" s) \"\" ]\n\
    \    [(string-contains? \"abcdefghijklmnopqrstuvwxyz\" (string-ref s 0))\n   \
    \   (string-append (string-reverse (string-upcase s)))]\n    [(string-contains?\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" (string-ref s 0))\n      (string-append (string-reverse\
    \ (string-downcase s)))]\n    [else\n      (string-append (string-reverse s))]))\n",
  "  (if (string-contains? (string-upcase s) #\\a)\n      (string-map\n       (lambda\
    \ (c)\n         (if (char-alphabetic? c)\n             (char-upcase c)\n     \
    \        (char-downcase c)))\n       s)\n      (reverse s)))\n", "  (apply string\
    \ (reverse (map (\u03BB (c) (cond ((char-alphabetic? c) (char-downcase c))\n \
    \                                           ((char-numeric? c) (digit->char (sub1\
    \ (char->digit c))))\n                                            (else c)))\n\
    \                               (string->list s)))))\n", "  (define (iter i)\n\
    \    (cond\n      [(< i (string-length s))\n       (if (char-alphabetic? (string-ref\
    \ s i))\n           (string-append (iter (+ i 1)) (string-downcase (string-ref\
    \ s i)))\n           (string-append (iter (+ i 1)) (string-ref s i)))]\n     \
    \ [else \"\"]))\n  (if (string-any char-alphabetic? s)\n      (iter 0)\n     \
    \ (string-reverse s)))\n", "  (if (not (string-contains-pred s char-letter?))\n\
    \      (string-reverse s)\n      (define (inner s i acc)\n        (cond\n    \
    \      [(< i (string-length s)) (inner s (+ i 1) (string-append acc (if (char-letter?\
    \ (string-ref s i)) (string-downcase (string-ref s i)) (string-upcase (string-ref\
    \ s i)))))]\n          [else acc]))\n      (inner s 0 \"\")))\n", "  (string-map\
    \ (\u03BB (x)\n                (if (char-alphabetic? x)\n                    (if\
    \ (char-ci=? x (char-downcase x))\n                        (char-upcase x)\n \
    \                       (char-downcase x))\n                    x))\n        \
    \      s))\n</code>\nLike I said, this takes a string, iterates through it, checking\
    \ each character is a letter using <code>char-alphabetic?</code>. If it is, it\
    \ checks if it's uppercase or lowercase using <code>char-ci=?</code> which compares\
    \ a character to an equivalent lowercase or uppercase. If it's lowercase, it returns\
    \ the uppercase equivalent, otherwise it returns the lowercase equivalent.\nCould\
    \ it be done better?\n\n\nA:\n\nThis is a pretty good solution. For a beginner,\
    \ I would say it's excellent. (In fact, if you read the discussion of the case-sensitivity\
    \ of <code>char-ci=?</code> in the comments of the question, it shows that it's\
    \ not the easiest thing in the world to come up with the correct solution.) The\
    \ only thing I would change is to replace <code>char-alphabetic?</code> with <code>char-alphabetic-or-numeric?</code>\
    \ (which also includes digits), so it will work on both letters and digits. \n\
    Just out of curiosity, I would like to mention that there is also a library solution\
    \ to this problem, which you might have discovered on your own. In the standard\
    \ <code>racket/base</code> library there is a function called <code>char-titlecase</code>\
    \ which converts a lowercase letter to its uppercase equivalent, and converts\
    \ an uppercase letter to its lowercase equivalent. Since you only want to change\
    \ the case of alphabetic characters and keep the others as is, you can achieve\
    \ the same result with:\n<code>(string-map char-titlecase s)\n</code>\n", "  (if\
    \ (string-empty? s) s\n      (solve (string-append (char-upcase (string-ref s\
    \ 0))\n                            (string-tail s 1)))))", "  (if (string-empty?\
    \ s)\n      \"\"\n      (if (regexp-match? #rx\"[A-Za-z]\" s)\n          (reverse-string\
    \ (map (lambda (c)\n                                  (if (regexp-match? #rx\"\
    [A-Za-z]\" (string c))\n                                      (if (regexp-match?\
    \ #rx\"[A-Z]\" (string c))\n                                          (char-downcase\
    \ c)\n                                          (char-upcase c))\n           \
    \                           c))\n                                s))\n       \
    \   (reverse-string s))))\n", "  (define (helper s accum)\n    (if (null? s)\n\
    \        accum\n        (let ([c (string-ref s 0)])\n          (if (or (char-numeric?\
    \ c) (char-whitespace? c))\n              (helper (substring s 1) (string-append\
    \ accum (string c)))\n              (helper (substring s 1) (string-append accum\
    \ (string (char-upcase c))))))))\n  (let ([c (string-ref s 0)])\n    (if (or (char-numeric?\
    \ c) (char-whitespace? c))\n        (helper (substring s 1) (string c))\n    \
    \    (helper (substring s 1) (string (char-upcase c))))))\n", "  (define (reversify\
    \ c)\n    (cond\n      [(string=? (string-downcase c) c) (string-upcase c)]\n\
    \      [(string=? (string-upcase c) c) (string-downcase c)]\n      [else c]))\n\
    \  (if (string-contains? (string-downcase s) \"a\")\n      (string-map reversify\
    \ s)\n      (string-reverse s)))\n", "  (if (string-contains s #\\a)\n      (string-map\
    \ (\u03BB (x) (if (char-lower-case? x)\n                             (char-upcase\
    \ x)\n                             (char-downcase x))) s)\n      (string-reverse\
    \ s)))\n", "  (let ([s (string-upcase s)])\n    (regexp-replace* #rx\"[a-z]\"\
    \ s\n      (lambda (m) (string-downcase (substring m 0))))))\n</code>\nNote that\
    \ I used Racket's <code>string-upcase</code> function, because it works for Unicode\
    \ letters (as opposed to ASCII) as well, as well as the <code>regexp-replace*</code>\
    \ function, which is part of a library by the same name.\n", "  (cond [(empty?\
    \ s) \"\"]\n        [(not (or (char-alphabetic? (string-ref s 0))\n          \
    \        (char-alphabetic? (string-ref s (- (string-length s) 1)))))\n       \
    \  (reverse s)]\n        [else (append (reverse (string-upcase s))\n         \
    \             (string-drop s (string-length s)))]))", "  (reverse (map (lambda\
    \ (c) (if (char-alphabetic? c)\n                                (char-upcase c)\n\
    \                                (char-downcase c)))\n                s)))\n",
  "  (if (string-ci=? s \"\")\n      s\n      (for/fold ([acc (list)]) ([ch (in-string\
    \ s)])\n        (cond\n          [(char-ci=? ch #\\A) (cons #\\a acc)]\n     \
    \     [(char-ci=? ch #\\a) (cons #\\A acc)]\n          [(char-ci=? ch #\\B) (cons\
    \ #\\b acc)]\n          [(char-ci=? ch #\\b) (cons #\\B acc)]\n          [(char-ci=?\
    \ ch #\\C) (cons #\\c acc)]\n          [(char-ci=? ch #\\c) (cons #\\C acc)]\n\
    \          [(char-ci=? ch #\\D) (cons #\\d acc)]\n          [(char-ci=? ch #\\\
    d) (cons #\\D acc)]\n          [(char-ci=? ch #\\E) (cons #\\e acc)]\n       \
    \   [(char-ci=? ch #\\e) (cons #\\E acc)]\n          [(char-ci=? ch #\\F) (cons\
    \ #\\f acc)]\n          [(char-ci=? ch #\\f) (cons #\\F acc)]\n          [(char-ci=?\
    \ ch #\\G) (cons #\\g acc)]\n          [(char-ci=? ch #\\g) (cons #\\G acc)]\n\
    \          [(char-ci=? ch #\\H) (cons #\\h acc)]\n          [(char-ci=? ch #\\\
    h) (cons #\\H acc)]\n          [(char-ci=? ch #\\I) (cons #\\i acc)]\n       \
    \   [(char-ci=? ch #\\i) (cons #\\I acc)]\n          [(char-ci=? ch #\\J) (cons\
    \ #\\j acc)]\n          [(char-ci=? ch #\\j) (cons #\\J acc)]\n          [(char-ci=?\
    \ ch #\\K) (cons #\\k acc)]\n          [(char-ci=? ch #\\k) (cons #\\K acc)]\n\
    \          [(char-ci=? ch #\\L) (cons #\\l acc)]\n          [(char-ci=? ch #\\",
  "  (if (empty? s)\n      \"\"\n      (if (string-titlecase? (substring s 0 1))\n\
    \          (string-downcase (substring s 0 1))\n          (string-upcase (substring\
    \ s 0 1)))\n      (solve (substring s 1 (- (string-length s) 1)))))\n</code>\n\
    I am getting the following error:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: #&lt;bytecode:solve&gt;\n\
    \  arguments...:\n   \"R\"\n  context...:\n   /home/runner/advanced-racket-tasks/solve.rkt:6:0:\
    \ solve\n   /home/runner/advanced-racket-tasks/solve.rkt:6:1: car\n   /home/runner/advanced-racket-tasks/solve.rkt:6:1:\
    \ substring\n   /home/runner/advanced-racket-tasks/solve.rkt:6:18: solve\n   /home/runner/advanced-racket-tasks/solve.rkt:6:22:\
    \ substring\n   /home/runner/advanced-racket-tasks/solve.rkt:6:42: solve\n   /home/runner/advanced-racket-tasks/solve.rkt:6:46:\
    \ substring\n   /home/runner/advanced-racket-tasks/solve.rkt:6:66: solve\n   /home/runner/advanced-racket-tasks/solve.rkt:6:70:\
    \ substring\n   /home/runner/advanced-racket-tasks/solve.rkt:6:90: solve\n   /home/runner/advanced-racket-tasks/solve.rkt:6:94:\
    \ substring\n   /home/runner/advanced-racket-tasks/solve.rkt:6:114: solve\n  \
    \ /home/runner/advanced-racket-tasks/solve.rkt:6:118: substring\n   /home/runner/advanced-racket-tasks",
  "  (if (empty? s)\n      \"\"\n      (if (letter? (string-ref s 0))\n          (string-append\
    \ (char-swap (string-ref s 0)) (solve (substring s 1)))\n          (string-append\
    \ (string-ref s 0) (solve (substring s 1))))))\n", "  (cond [(string=? s \"\"\
    ) \"\"]\n        [(string=? s (string-upcase s)) (string-downcase s)]\n      \
    \  [(string=? s (string-downcase s)) (string-upcase s)]\n        [else (string-reverse\
    \ s)]))", "  (define (f lst)\n    (match lst\n      ('() '())\n      ([h ...t]\n\
    \       (cons\n        (if (char-alphabetic? h)\n            (char-upcase h)\n\
    \            (char-downcase h))\n        (f t)))))\n  (if (regexp-match #rx\"\
    [a-zA-Z]\" s)\n      (string-&gt;list s)\n      (f (string-&gt;list s))))\n</code>\n\
    The output is as follows:\n<code>(solve \"1234\")", "  (cond\n    [(number? (string->number\
    \ s)) (number->string (reverse-digits (string->number s)))]\n    [(letter? (string-ref\
    \ s 0)) (string-map reverse-case s)]\n    [else (string-reverse s)]))\n", "  (string-reverse\
    \ (for/fold ([retval (make-string (string-length s))])\n                   ([c\
    \ (in-string s)])\n                   (begin\n                     (string-set!\
    \ retval (sub1 (string-length s))\n                                  (if (char-alphabetic?\
    \ c)\n                                      (if (char-lower-case? c)\n       \
    \                                   (char-upcase c)\n                        \
    \                  (char-downcase c))\n                                      c))\n\
    \                     (sub1 s)))))\n</code>\nTest cases\n<code>;; (require \"\
    solve.rkt\")\n", "  (if (string-empty? s)\n      \"\"\n      (let* ([c (string-ref\
    \ s 0)]\n             [case-changed\n              (if (letter? c)\n         \
    \         (if (char-upper-case? c)\n                      (char-downcase c)\n\
    \                      (char-upcase c))\n                  c)])\n        (string-append\n\
    \         (string case-changed)\n         (solve (substring s 1))))))\n</code>\n",
  "  (letrec ([s (string-upcase s)]\n           [reverse (lambda (s)\n           \
    \           (if (string-empty? s)\n                          s\n             \
    \             (string-append (string-join (reverse (string-drop-right s 1)) (string-take-right\
    \ s 1)))))])\n    (if (regexp-match? #rx\"[a-zA-Z]\" s)\n        (reverse s)\n\
    \        s)))\n", "  (if (= (string-length s) 0)\n      (string-reverse s)\n \
    \     (list->string\n       (reverse\n        (map (lambda (x) (if (char-alphabetic?\
    \ x) (string-downcase (string-upcase x)) x))\n             (string->list s))))))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(and (char-alphabetic? (string-ref s 0))\n\
    \          (char-lower-case? (string-ref s 0)))\n     (string-append (string-upcase\
    \ (string-ref s 0))\n                    (solve (substring s 1)))]\n    [(and\
    \ (char-alphabetic? (string-ref s 0))\n          (char-upper-case? (string-ref\
    \ s 0)))\n     (string-append (string-downcase (string-ref s 0))\n           \
    \         (solve (substring s 1)))]\n    [else (string-append (string-ref s 0)\n\
    \                         (solve (substring s 1)))]))\n", "  (if (or (contains?\
    \ s #\\a) (contains? s #\\A))\n      (for/string ([c s])\n        (if (char-alphabetic?\
    \ c)\n            (char-upcase c)\n            (char-downcase c)))\n      (string-reverse\
    \ s)))\n</code>\n", "  (let loop ([i 0] [res '()])\n    (if (and (string-ref s\
    \ i) (char-alphabetic? (string-ref s i)))\n        (loop (+ i 1) (cons (char-upcase\
    \ (string-ref s i)) res))\n        (if (string-ref s i)\n            (loop (+\
    \ i 1) (cons (string-ref s i) res))\n            (string-join (reverse res))))))\n\
    </code>\nThe problem is in the two line below:\n<code>(if (and (string-ref s i)\
    \ (char-alphabetic? (string-ref s i)))\n    (loop (+ i 1) (cons (char-upcase (string-ref\
    \ s i)) res))\n</code>\nI used <code>if</code> and <code>and</code> to check if\
    \ <code>i</code> is <code>'()</code> or not. But it seems that racket doesn't\
    \ support <code>string-ref</code> and <code>char-alphabetic?</code> together.\
    \ So I was wondering if there is another way to do this.\nThank you so much for\
    \ your help.\n\n\nA:\n\nIt is not an error, you are just not using <code>string-ref</code>\
    \ and <code>char-alphabetic?</code> correctly.\n<code>char-alphabetic?</code>\
    \ expects a <code>char</code> as its argument. <code>string-ref</code> expects\
    \ a <code>string</code> and a <code>number</code> as its arguments. A <code>string</code>\
    \ is not a <code>char</code>. If a <code>string</code> contains one and only one\
    \ <code>char</code>, then <code>string-ref</code> can be used to get this <code>char</code>.\n\
    You can look at the documentation of these functions here: string-ref, char-alphabetic?.\n",
  "  (for/fold ([acc \"\" ])\n            ([c (in-string s)])\n    (cond\n      [(char-alpha?\
    \ c)\n       (string-append acc (string-join (list (c:to-upper c)) \"\"))]\n \
    \     [(not (char-alpha? c))\n       (string-append acc (string-join (list (c:to-lower\
    \ c)) \"\"))]\n      [else acc])))\n", "  (cond\n    [(null? s) \"\"]\n    [(and\
    \ (char-alphabetic? (string-ref s 0))\n          (char-lower-case? (string-ref\
    \ s 0)))\n     (string-append\n      (string-upcase (string-ref s 0))\n      (solve\
    \ (substring s 1)))]\n    [(and (char-alphabetic? (string-ref s 0))\n        \
    \  (char-upper-case? (string-ref s 0)))\n     (string-append\n      (string-downcase\
    \ (string-ref s 0))\n      (solve (substring s 1)))]\n    [else\n     (string-append\n\
    \      (string-ref s 0)\n      (solve (substring s 1)))]))\n", "  (define (rev-case\
    \ c)\n    (cond\n      [(letter? c) (if (lower-case? c) (upcase c) (downcase c))]\n\
    \      [else c]))\n  (string-map rev-case (if (string-contains? s \"a-zA-Z\")\
    \ s (string-reverse s))))\n", "  (cond\n    [(empty? s)\n     \"\"]\n    [(regexp-match\
    \ #rx\"\\w\" (string (first s)))\n     (string-append\n      (if (string-upcase?\
    \ (string (first s)))\n          (string-downcase (string (first s)))\n      \
    \    (string-upcase (string (first s))))\n      (solve (rest s)))]\n    [else\n\
    \     (string-append (string (first s)) (solve (rest s)))]))\n</code>\nI'm wondering\
    \ how to write a string that has #\\w in it. I've tried\n<code>#\"\\w\"</code>\n\
    <code>#\"\\\\w\"</code>\n<code>#\"\\u0057\"</code>\n<code>#\"\\115\"</code>\n\
    <code>#\"77\"</code>\nand they didn't work.\n\n\nA:\n\nYou need to use the <code>#px\"\
    ...\"</code> syntax for string literals, and escape the backslash:\n<code>#px\"\
    \\\\w\"\n</code>\n", "  (for/fold ([output \"\"]) ([s s])\n            (cond\n\
    \              [(char-letter? s) (string-append output (if (char-upper-case? s)\
    \ (string-downcase s) (string-upcase s)))]\n              [else (string-append\
    \ output s)])))\n", "  (define (all-chars-upper? s)\n    (for/and ([c (in-string\
    \ s)])\n      (char-upper-case? c)))\n  (define (all-chars-lower? s)\n    (for/and\
    \ ([c (in-string s)])\n      (char-lower-case? c)))\n  (define (reverse-case c)\n\
    \    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (reverse-case-string s)\n    (string-map reverse-case s))\n\
    \  (if (and (all-chars-upper? s)\n           (all-chars-lower? s))\n      (reverse\
    \ s)\n      (reverse-case-string s)))\n</code>\n", "  (if (string-contains s #\\\
    a #\\z)\n      (string-upcase (string-foldr (lambda (chr acc) (if (char-alphabetic?\
    \ chr) (string-append (string-downcase (string chr)) acc) (string-append (string\
    \ chr) acc))) \"\" s))\n      (string-reverse s)))", "  (if (or (string-contains?\
    \ s #\\A) (string-contains? s #\\a))\n      (string-map (lambda (x) (if (or (char=?\
    \ x #\\A) (char=? x #\\a)) \n                                 (char-downcase x)\
    \ \n                                 (char-upcase x)))\n                  s)\n\
    \      (string-reverse s)))\n", "  (cond\n    [(empty? s) empty]\n    [(letter?\
    \ (first s)) (cons (flip-case (first s)) (solve (rest s)))]\n    [else (cons (first\
    \ s) (solve (rest s)))]))\n", "  (string-join (reverse (build-list (string-length\
    \ s) (lambda (x) (cond ((regexp-match? \"[a-zA-Z]\" (string-ref s x)) (string-downcase\
    \ (string-upcase (string-ref s x)))) (else (string-ref s x)))))))\n)\n</code>\n\
    However, I cannot understand why is this failing only 1 test case (out of 8) which\
    \ is:\n<code>solve(\"\")\n\"\", expected \"\".\n</code>\nHow can I fix this?\n\
    \n\nA:\n\nThe problem is because if the string is empty it returns this <code>string-join</code>:\n\
    <code>(string-join (reverse '()))\n</code>\nSo, you need to test for the empty\
    \ string.\nFor example:\n<code>(define (solve s)\n  (cond ((empty? s) \"\")\n\
    \        (else\n         (string-join (reverse (build-list (string-length s) (lambda\
    \ (x) (cond ((regexp-match? \"[a-zA-Z]\" (string-ref s x)) (string-downcase (string-upcase\
    \ (string-ref s x)))) (else (string-ref s x))))))))))\n</code>\n", "  (if (string-contains-letter?\
    \ s)\n      (if (empty? (string-filter (lambda (c) (char-upper-case? c)) s))\n\
    \          (string-map char-downcase s)\n          (string-map char-upcase s))\n\
    \      (string-reverse s)))\n", "  (if (not (string-contains? s #\\letter))\n\
    \      (reverse s)\n      (string-map \n       (lambda (c)\n         (cond \n\
    \           [(and (char-lower-case? c) (char-alphabetic? c)) (char-upcase c)]\n\
    \           [(and (char-upper-case? c) (char-alphabetic? c)) (char-downcase c)]\n\
    \           [else c]))\n       s)))\n", "  (cond\n    [(empty? s) empty]\n   \
    \ [(letter? (first s))\n     (string-append (char-upcase (first s))\n        \
    \            (solve (rest s)))]\n    [(letter? (first s))\n     (string-append\
    \ (char-downcase (first s))\n                    (solve (rest s)))]\n    [else\n\
    \     (string-append (first s)\n                    (solve (rest s)))]))\n```\n\
    \n```racket\n#lang racket\n", "  (let ((result (copy s)))\n    (for ([i (in-range\
    \ (string-length s))])\n      (cond\n        [(and (&lt;= #\\a (string-ref s i))\
    \ (&lt;= (string-ref s i) #\\z))\n         (string-set! result i (char-upcase\
    \ (string-ref s i)))]\n        [(and (&lt;= #\\A (string-ref s i)) (&lt;= (string-ref\
    \ s i) #\\Z))\n         (string-set! result i (char-downcase (string-ref s i)))]))\n\
    \    result))\n", "  (if (regexp-match #rx\"[a-zA-Z]\" s)\n      (define (reverse-case\
    \ s)\n        (string-map (\u03BB (x)\n                      (if (char-alphabetic?\
    \ x)\n                          (if (char-uppercase? x)\n                    \
    \          (char-downcase x)\n                              (char-upcase x))\n\
    \                          x))\n                    s))\n      (reverse s)))\n",
  "  (if (zero? (string-length s))\n      \"\"\n      (let [(first (string-ref s 0))]\n\
    \        (string-append (reverse-it first) (solve (substring s 1))))))\n", " \
    \ (string-join (map reverse-case (string-&gt;list s))))\n", "  (cond\n    [(empty?\
    \ s) s]\n    [(char-numeric? (string-ref s 0)) (string-reverse s)]\n    [else\
    \ (substring (string-reverse (string-replace s (char-downcase (string-ref s 0))\
    \ (char-upcase (string-ref s 0)))) 1 (sub1 (string-length s)))]))\n", "  (string-reverse\
    \ (map car\n    (foldl\n      (lambda (c acc)\n        (cond\n          [(member\
    \ (string-downcase c) (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\"))\n    \
    \       (cons (if (equal? (string-downcase c) c)\n                   (string-upcase\
    \ c)\n                   (string-downcase c))\n                 acc)]\n      \
    \    [else (cons c acc)]))\n      (list)\n      (string-&gt;list s)))))\n</code>\n\
    The code runs, but it is not according to the rules of the challenge, since it\
    \ uses string-reverse, which is prohibited.\nI don't see how to solve this without\
    \ using string-reverse or indexing the string, which is also prohibited.\nWhat\
    \ am I missing?\n\n\nA:\n\nWhy not use built-in functionality? \n<code>(define\
    \ (solve s)\n  (string-join (reverse (string-split s))))\n</code>\n", "  (cond\n\
    \    [(string=? s \"\") \"\"]\n    [(and (char-lower-case? (string-ref s 0))\n\
    \          (not (string-any char-lower-case? (substring s 1))))\n     (string-append\
    \ (list (char-upcase (string-ref s 0))) (substring s 1))]\n    [(string-any char-lower-case?\
    \ s)\n     (string-append (list (char-upcase (string-ref s 0)))\n            \
    \        (string-append (substring s 1 (sub1 (string-length s)))\n           \
    \                        (list (char-lower-case (string-ref s (- (string-length\
    \ s) 1))))))]\n    [else (string-reverse s)]))\n", "  (cond ((string-empty? s)\
    \ \"\")\n        ((char-numeric? (string-ref s 0)) (string-reverse s))\n     \
    \   ((char-lower-case? (string-ref s 0))\n         (string-append (string-upcase\
    \ (string-ref s 0)) (solve (string-tail s))))\n        ((char-upper-case? (string-ref\
    \ s 0))\n         (string-append (string-downcase (string-ref s 0)) (solve (string-tail\
    \ s))))\n        (else (string-append (string-ref s 0) (solve (string-tail s))))))",
  "  (cond ((empty? s) (string))\n        ((equal? (string-length s) 1) s)\n     \
    \   ((= (car s) (ascii-&gt;char (add1 (char-&gt;ascii (car s)) 32)))\n       \
    \  (cons (ascii-&gt;char (add1 (char-&gt;ascii (car s)) -32))\n              \
    \ (solve (cdr s))))\n        ((= (car s) (ascii-&gt;char (add1 (char-&gt;ascii\
    \ (car s)) -32)))\n         (cons (ascii-&gt;char (add1 (char-&gt;ascii (car s))\
    \ 32))\n               (solve (cdr s))))\n        (else (cons (car s) (solve (cdr\
    \ s))))))\n</code>", "  (apply string (reverse (string-map\n                 \
    \         (lambda (x) (if (and (char-alphabetic? x)\n                        \
    \                        (> (char-downcase x) 96))\n                         \
    \                  (char-upcase x)\n                                         \
    \  (char-downcase x)))\n                          s))))\n", "  (reverse (map (\u03BB\
    \ (c)\n                  (if (letter? c)\n                      (if (char-numeric?\
    \ c)\n                          (char-&gt;integer c)\n                       \
    \   (integer-&gt;char c))\n                      c)) s)))\n</code>\nThis is an\
    \ error from the DrRacket window:\n<code>car: expects argument of type &lt;pair&gt;;\
    \ given '(#\\# #\\a #\\@ #\\C)\n</code>\nThis is another error, more detailed:\n\
    <code>char: expects argument of type &lt;character&gt;; given '(#\\# #\\a #\\\
    @ #\\C)\n</code>\nThis is the user input:\n<code>#a@C\n</code>\nThis is the result:\n\
    <code>4321\n</code>\nI'm trying to figure out why this is happening...\nThanks!\n\
    \n\nA:\n\nYou cannot solve this problem simply by calling <code>reverse</code>\
    \ on a list.\nA better solution is to apply a function to the string, like so:\n\
    <code>(define (solve str)\n  (define (map-case f str)\n    (string-&gt;list (string-map\
    \ f str)))\n  (define (toggle-case c)\n    (if (char-alphabetic? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (if (string-any char-alphabetic? str)\n   \
    \   (string-&gt;list (string-map toggle-case str))\n      (string-&gt;list (string-reverse\
    \ str))))\n</code>\nTest:\n<code>(solve \"1234\")\n=&gt; (4 3 2 1)\n", "  (cond\
    \ [(or (string=? s \"\") (not (string-contains-character? s #\\a #\\z #\\A #\\\
    Z))) (reverse s)]\n        [else (reverse-string-case s)]))\n", "  (cond\n   \
    \ [(empty? s) (string)]\n    [(char-alphabetic? (string-ref s 0))\n     (string-append\n\
    \      (if (char-lower-case? (string-ref s 0))\n          (string-upcase (string-ref\
    \ s 0))\n          (string-downcase (string-ref s 0)))\n      (solve (substring\
    \ s 1 (string-length s))))]\n    [else (string-append (string-ref s 0) (solve\
    \ (substring s 1 (string-length s))))]))\n", "  (if (string-fold (\u03BB (c s)\
    \ (if (char-alphabetic? c) (+ s 1) s)) 0 s)\n      (string-map\n       (\u03BB\
    \ (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case? c)\
    \ (char-upcase c) (char-downcase c))\n           c))\n       s)\n      (string-reverse\
    \ s)))", "  (string-map\n   (lambda (c)\n     (if (char-alphabetic? c)\n     \
    \    (if (char-lower-case? c)\n             (char-upcase c)\n             (char-downcase\
    \ c))\n         c))\n   s))\n", "  (define (rev-case c)\n    (if (or (char=? c\
    \ #\\A) (char=? c #\\a))\n        (if (char=? c #\\A)\n            #\\a\n    \
    \        #\\A)\n        c))\n  (if (empty? s)\n      \"\"\n      (string-append\n\
    \       (if (char-alphabetic? (string-ref s 0))\n           (string (rev-case\
    \ (string-ref s 0)))\n           (string (string-ref s 0)))\n       (solve (substring\
    \ s 1 (string-length s))))))\n", "  (cond [(empty? s) (reverse s)]\n        [(char-alpha?\
    \ (string-ref s 0))\n         (reversify s)]\n        [else\n         (solve (string-append\
    \ (string-ref s 0) (solve (string-tail s 1))))]))\n", "  (let* ([s' (string-&gt;list\
    \ s)]\n         [s'' (map (lambda (x) (if (char-alphabetic? x)\n             \
    \                    (char-upcase x)\n                                 (char-downcase\
    \ x)))\n                   s')])\n    (if (empty? s'')\n        (reverse s')\n\
    \        (list-&gt;string s''))))\n", "  (if (string-contains-no-letters? s)\n\
    \      (reverse s)\n      (reverse-cases s)))\n", "  (if (string-empty? s)\n \
    \     s\n      (let ([first (string-ref s 0)])\n        (cond [(char-alphabetic?\
    \ first)\n               (string-append\n                (string first)\n    \
    \            (solve (string-drop s 1)))]\n              [else\n              \
    \ (string-append\n                (solve (string-drop s 1))\n                (string\
    \ first))]))))\n", "  (cond\n    [(not (string? s)) \"\"]\n    [(regexp-match\
    \ #rx\"\\W\" s) (reverse s)]\n    [else (string-join\n            (reverse\n \
    \            (map\n              (lambda (x)\n                (cond\n        \
    \          [(char-lower-case? x) (char-upcase x)]\n                  [(char-upper-case?\
    \ x) (char-lower-case x)]\n                  [else x]))\n              (string->list\
    \ s))) \"\")]))\n", "  (if (string-empty? s)\n      \"\"\n      (string-append\n\
    \       (if (char-alphabetic? (string-ref s 0))\n           (string-capitalize\
    \ (string-downcase (string s)))\n           (string s))\n       (solve (substring\
    \ s 1)))))\n", "  (cond ((not (string-contains? s #\\a)) (reverse s))\n      \
    \  (else (reverse (string-map (lambda (c)\n                                  \
    \   (cond ((letter? c) (if (upper-case? c) (downcase c) (upcase c)))\n       \
    \                                    (else c)))\n                            \
    \       s)))))\n</code>\n", "  (if (string-contains-letter? s)\n      (reverse-case\
    \ s)\n      (string-reverse s)))\n", "  (regexp-replace* #rx\"^$\" s s)\n  (regexp-replace*\
    \ #rx\"\\d\" s s)\n  (regexp-replace* #rx\"[a-z]\" s (\u03BB (x) (string-upcase\
    \ x)))\n  (regexp-replace* #rx\"[A-Z]\" s (\u03BB (x) (string-downcase x)))\n\
    \  (string-reverse s))\n", "  (if (empty? s) \"\"\n      (if (string-ci=? (string-ref\
    \ s 0) (string-downcase (string-ref s 0)))\n          (string-append (string-upcase\
    \ (string-ref s 0)) (solve (substring s 1)))\n          (string-append (string-downcase\
    \ (string-ref s 0)) (solve (substring s 1))))))\n", "  (if (string-all string-ci-letter?\
    \ s)\n      (string-upcase s)\n      (string-upcase s)))\n</code>\nActually, it\
    \ does not perform the task, but I could not find a way to make the check described\
    \ in the comment within the <code>if</code> statement. So, I decided to write\
    \ it using <code>cond</code>. Is it doable using <code>if</code>?\n\n\nA:\n\n\
    Use <code>string-map</code>:\n<code>(define (solve s)\n  (string-map\n   (lambda\
    \ (ch)\n     (if (char-alphabetic? ch)\n         (if (char-lower-case? ch)\n \
    \            (char-upcase ch)\n             (char-downcase ch))\n         ch))\n\
    \   s))\n</code>\n", "  (define (rev-case c)\n    (if (char-alphabetic? c)\n \
    \       (if (char-ci=? c (char-upcase c))\n            (char-downcase c)\n   \
    \         (char-upcase c))\n        c))\n  (if (string-any char-alphabetic? s)\n\
    \      (apply string (map rev-case (string->list s)))\n      (string-reverse s)))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n    \
    \ (string-append (string-upcase (string-ref s 0)) (solve (substring s 1)))]\n\
    \    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref s 0) (solve\
    \ (substring s 1)))]\n    [else\n     (string-append (string-downcase (string-ref\
    \ s 0)) (solve (substring s 1)))]))\n</code>\nI would appreciate any help, review,\
    \ advice and criticism.\n\n\nA:\n\nThere are several problems here:\n\nyou don't\
    \ need to check if the input is <code>\"\"</code>, you can use <code>null?</code>\
    \ instead\nyou're using the wrong <code>string-ref</code> function, it should\
    \ be <code>substring</code>\nyou're missing the case of an uppercase letter\n\
    you're not calling <code>solve</code> when it's a letter\nyou're not handling\
    \ the empty string case\n\nHere's a corrected version:\n<code>(define (solve s)\n\
    \  (cond\n    [(null? s) \"\"]\n    [(char-alphabetic? (string-ref s 0))\n   \
    \  (string-append (if (char-upper-case? (string-ref s 0))\n                  \
    \     (string-downcase (string-ref s 0))\n                       (string-upcase\
    \ (string-ref s 0)))\n                   (solve (substring s 1)))]\n    [else\n\
    \     (string-append (string-ref s 0) (solve (substring s 1)))]))\n</code>\nAn\
    \ alternative implementation:\n<code>(define (solve s)\n  (cond\n    [(null? s)\
    \ \"\"]\n    [(char-numeric? (string-ref s 0))\n     (string-append (string-ref\
    \ s 0) (solve (substring s 1)))]\n    [else\n     (string-append (if (char-upper-case?\
    \ (string-ref s 0))\n                       (string-downcase (string-ref s 0))\n\
    \                       (string-upcase (string-ref s", "  (cond [(empty? s) \"\
    \"]\n        [(char-alphabetic? (string-ref s 0))\n         (string-append (string-upcase\
    \ (substring s 0 1)) (substring s 1))]\n        [(char-numeric? (string-ref s\
    \ 0))\n         (string-append (substring s 1) (substring s 0 1))]\n        [else\
    \ (string-append (substring s 1) (substring s 0 1))]))\n", "  (string-join (reverse\
    \ (list->string (map (\u03BB (c)\n                                           \
    \  (if (and (char-alphabetic? c)\n                                           \
    \           (char-lower-case? c))\n                                          \
    \       (char-upcase c)\n                                                 (char-lower-case\
    \ c)))\n                                         (string->list s))))))", "  (cond\n\
    \    [(string=? \"\" s) \"\"]\n    [(string-contains? s \"[a-zA-Z]\")\n     (for/string\
    \ ([ch (in-string s)])\n       (cond\n         [(char-alphabetic? ch) (string-downcase\
    \ ch)]\n         [else (string-upcase ch)]))]\n    [else (string-reverse s)]))\n",
  '  (string-downcase (string-upcase s)))', "  (define (solve-rec s)\n    (cond\n\
    \      [(empty? s) s]\n      [(char-alphabetic? (first s))\n       (cons (if (char-upper-case?\
    \ (first s))\n                 (char-downcase (first s))\n                 (char-upcase\
    \ (first s)))\n             (solve-rec (rest s)))]\n      [else (cons (first s)\
    \ (solve-rec (rest s)))]))\n  (regexp-replace* #rx\"^$\" \"\" (string-join (reverse\
    \ (solve-rec (string->list s))) \"\")))", "  (cond\n    [(empty? s) \"\"]\n  \
    \  [(char-alphabetic? (first s)) (string-upcase (first s))]\n    [(char-numeric?\
    \ (first s)) (first s)]\n    [else (string-downcase (first s))]))\n</code>\nExample\
    \ input:\n<code>&gt; (solve \"1234\")\n", "  (if (string-has-letter? s)\n    \
    \  (string-for/fold ([i 0] [j (string-length s)])\n        ([ss (string-append\
    \ (string-ref s i) (string-ref s (- j 1)))])\n        (string-append ss (string-map\n\
    \                            (lambda (char)\n                              (if\
    \ (char-alphabetic? char)\n                                  (if (char-lower-case?\
    \ char)\n                                      (char-upcase char)\n          \
    \                            (char-downcase char))\n                         \
    \         char)) s)))\n      (string-reverse s)))\n", "  (cond [(empty? s) \"\"\
    ]\n        [(char-alphabetic? (first s))\n         (string-append (string-upcase\
    \ (first s))\n                        (solve (rest s)))]\n        [(char-lower-case?\
    \ (first s))\n         (string-append (string-upcase (first s))\n            \
    \            (solve (rest s)))]\n        [(char-upper-case? (first s))\n     \
    \    (string-append (string-downcase (first s))\n                        (solve\
    \ (rest s)))]\n        [else (string-append (first s)\n                      \
    \       (solve (rest s)))]))\n</code>\n", "  (cond\n    [(empty? s) s]\n    [(and\
    \ (= (char-upcase (car s)) (car s))\n          (= (char-downcase (car s)) (car\
    \ s)))\n     (cons (car s) (solve (cdr s)))]\n    [else\n     (cons (char-upcase\
    \ (car s)) (solve (cdr s)))]))\n</code>\n", "  (if (empty? s)\n      \"\"\n  \
    \    (if (isLetter (string-ref s 0))\n          (if (char-is-lower-case? (string-ref\
    \ s 0))\n              (string-upcase s)\n              (string-downcase s))\n\
    \          (solve (substring s 1)))))\n", "  (cond [(not (regexp-match #rx\"[A-Za-z]\"\
    \ s)) \n         (string-reverse s)]\n        [else \n         (string-map\n \
    \         (lambda (char)\n            (cond [(char-alphabetic? char) \n      \
    \             (char-downcase char)]\n                  [else\n               \
    \    (char-upcase char)]))\n          s)]))\n", "  (if (string-empty? s)\n   \
    \   \"\"\n      (if (char-alphabetic? (string-ref s 0))\n          (string-append\n\
    \           (string-append (string (flip-case (string-ref s 0))) (substring s\
    \ 1))\n           (solve (substring s 1)))\n          (string-append (string (string-ref\
    \ s 0)) (solve (substring s 1))))))\n", "  (cond\n    ((string-empty? s) \"\"\
    )\n    ((char-alphabetic? (string-ref s 0))\n     (string-append (string-upcase\
    \ (string-ref s 0)) (solve (substring s 1))))\n    ((char-numeric? (string-ref\
    \ s 0))\n     (string-append (string-ref s 0) (solve (substring s 1))))\n    (else\
    \ (string-append (string-downcase (string-ref s 0)) (solve (substring s 1))))))\n",
  "  (define (is-letter? c)\n    (and (>= c 65) (<= c 90)))\n  (define (invert-case\
    \ c)\n    (cond ((is-letter? c) (+ 32 c))\n          ((is-letter? (- c 32)) (-\
    \ c 32))\n          (else c)))\n  (for/fold ([acc (string->list s)]) ([_ (in-list\
    \ s)])\n    (reverse (map invert-case acc))))\n", "  (reverse s))\n", "  (regexp-replace*\
    \ #rx\"[a-zA-Z]\" s (\u03BB (x) (string-downcase (string-upcase x)))))\n</code>\n\
    How can I improve it?\nAlso, how can I do it without regex?\n\n\nA:\n\nI think\
    \ your code is already pretty good.\nHowever, I think that the signature of <code>regexp-replace*</code>\
    \ takes a procedure for the replacement rather than a string, so you should write:\n\
    <code>(define (solve s)\n  (regexp-replace* #rx\"[a-zA-Z]\" s (\u03BB (x) (string-downcase\
    \ (string-upcase x)))))\n</code>\nwhere you have a procedure <code>(\u03BB (x)\
    \ (string-downcase (string-upcase x)))</code> rather than just a string <code>\"\
    YYY\"</code>.\n<code>string-downcase</code> and <code>string-upcase</code> are\
    \ fine, but if you are using Racket, you might as well use <code>string-ci=?</code>\
    \ and <code>string-ci&lt;=?</code>.\n<code>string-ci=?</code> checks to see if\
    \ two strings are case-insensitively the same.  In your code, you are checking\
    \ to see if a string is upper case or lower case, but you don't want to use <code>string-upcase</code>\
    \ because that would make the string upper case.  A function like <code>string-ci=?</code>\
    \ would be good for this.\n<code>string-ci&lt;=?</code> would be useful in your\
    \ procedure because if you have a string <code>x</code> and you don't know if\
    \ it is upper case or lower case, then you can turn it into a <code>string-ci&lt;=?</code>\
    \ just by changing <code>&lt;=</code> to <code>&lt;</code> and you would have\
    \ a <code>string-ci&lt;?</code> that is an ordering of strings that is case-insensitive.\n",
  "  (if (= (string-length s) 0)\n      \"\"\n      (reverse (string-map (lambda (x)\n\
    \                             (if (char-alphabetic? x)\n                     \
    \            (if (char-upper-case? x)\n                                     (char-downcase\
    \ x)\n                                     (char-upcase x))\n                \
    \                 x)) s))))", "  (if (not (string-contains? s #\\a))\n      (reverse\
    \ s)\n      (string-join (map\n                    (lambda (x)\n             \
    \         (if (char-alphabetic? x)\n                          (if (char-lower-case?\
    \ x)\n                              (char-upcase x)\n                        \
    \      (char-downcase x))\n                          x))\n                   \
    \ (string->list s)))))\n", "  (define (has-letters s)\n    (ormap char-alphabetic?\
    \ (string->list s)))\n  (define (reverse-case c)\n    (if (char-alphabetic? c)\n\
    \        (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (rev s)\n    (reversed (string->list s)))\n  (define\
    \ (check s)\n    (if (has-letters s)\n        (string-join (map reverse-case (string->list\
    \ s)))\n        (string-join (rev s))))\n  (check s))", "  (string-upcase s))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
