name: HumanEval_29_filter_by_prefix
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that start\
  \ with a given prefix.\n;; >>> filter_by_prefix([], 'a')\n;; []\n;; >>> filter_by_prefix(['abc',\
  \ 'bcd', 'cde', 'array'], 'a')\n;; ['abc', 'array']\n(define (filter_by_prefix strings\
  \ prefix)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n))\n\n(test-humaneval)"
completions: ["  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter\
    \ (lambda (x) (string-prefix? prefix x)) strings))\n", "  (cond [(null? strings)\
    \ '()]\n        [(string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n        [else (filter_by_prefix (cdr\
    \ strings) prefix)]))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n\
    ```\n\n##### Factorial\n\n```racket\n#lang racket\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (cond [(empty? strings) '()]\n        [(string-prefix? prefix (first strings))\n\
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n \
    \       [else (filter_by_prefix (rest strings) prefix)]))\n```\n\n```#lang racket\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (equal?\
    \ (substring s 0 1) prefix)) strings))\n", "  (for/list ([string strings]\n  \
    \           #:when (string-prefix? prefix string))\n    string))\n", "  (filter\
    \ (lambda (x) (string-prefix? prefix x)) strings))\n```\n\n## Partitioning with\
    \ `match-define`\n\n`match-define` is useful to reduce matching a data structure\
    \ to a bunch of destructuring and a series of tests/bindings:\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? strings) empty]\n    [(string-prefix? prefix\
    \ (first strings))\n     (cons (first strings) (filter_by_prefix (rest strings)\
    \ prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n", "  (filter\
    \ (\u03BB (string) (string-prefix? prefix string)) strings))\n", "  (for/list\
    \ ([s strings]\n             #:when (string-prefix? prefix s))\n    s))\n", " \
    \ (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (for/list ([word strings]\n             #:when (string-prefix?\
    \ prefix word))\n    word))\n", "  (filter (\u03BB (x) (string-prefix? prefix\
    \ x)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (startswith? s prefix)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n```\n\n```\n#lang racket\n", " \
    \ (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (s)\
    \ (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (let ([filtered '()])\n    (for ([s strings])\n\
    \      (if (string-prefix? prefix s)\n          (set! filtered (cons s filtered))))\n\
    \    filtered))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (cond [(empty?\
    \ strings) '()]\n        [(string-prefix? prefix (first strings))\n         (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (filter (lambda (str) (string-prefix? prefix\
    \ str)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (string) (string-prefix?\
    \ prefix string)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix\
    \ s)) strings))\n```", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (cond [(empty? strings) empty]\n        [(string-prefix? prefix (first strings))\n\
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n \
    \       [else (filter_by_prefix (rest strings) prefix)]))\n", "  (cond ((null?\
    \ strings) '())\n        ((string-prefix? prefix (car strings))\n         (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n", "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB\
    \ (s) (string-prefix? prefix s)) strings))\n```\n\n```#lang racket\n", "  (for/list\
    \ ([s strings] #:when (string-prefix? prefix s))\n    s))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (cond\n    [(empty? strings)\
    \ empty]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n```\n\n```\n#lang racket\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (\u03BB (item) (string-prefix?\
    \ prefix item)) strings))\n", "  (filter (\u03BB (str) (string-prefix? prefix\
    \ str)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (cond [(empty?\
    \ strings) empty]\n        [(string-prefix? prefix (first strings))\n        \
    \ (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n        [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda (x) (string-prefix?\
    \ prefix x)) strings))\n```\n\n## 6: \u6570\u7EC4\uFF08Array\uFF09\n\n```racket\n\
    #lang racket\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (x) (string-prefix? prefix x)) strings))\n```\n\n## Description\n\n\
    ```racket", "  (filter (lambda (str) (and (string? str) (string-prefix? prefix\
    \ str))) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n```\n\n**However**,\
    \ the `string-prefix?` function is **broken**!\n\nWhat you are expected to do\
    \ is to *repair* the `string-prefix?` function.\n\nHint: Feel free to copy the\
    \ code from `string-prefix?` and paste it into your `world.rkt` file (available\
    \ as an [attachment](/attachments/5555098/world.rkt) to this page). Then, edit\
    \ the code as needed to repair the `string-prefix?` function.\n\n### Part 2: Discussion\n\
    \nOnce you have completed the exercise, please answer the following questions:\n\
    \n1. What did you have to change in the code to repair the `string-prefix?` function?\
    \ Why did you have to make this change?\n2. How does the repaired `string-prefix?`\
    \ function behave differently from the broken `string-prefix?` function?\n3. Some\
    \ other function might be broken instead of `string-prefix?`. What other function\
    \ might be broken, and how might you repair it?\n\n### Part 3: Submission\n\n\
    Submit your `world.rkt` file to Blackboard.", "  (cond ((null? strings) '())\n\
    \        ((string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix (cdr\
    \ strings) prefix))))\n", "  (filter (lambda (str) (startswith? str prefix)) strings))\n",
  "  (cond\n    [(empty? strings) empty]\n    [(empty? prefix) strings]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (define (startswith s)\n    (string-prefix? prefix s))\n  (filter startswith\
    \ strings))\n", "  (cond [(empty? strings) '()]\n        [(string-prefix? prefix\
    \ (first strings))\n         (cons (first strings) (filter_by_prefix (rest strings)\
    \ prefix))]\n        [else (filter_by_prefix (rest strings) prefix)]))\n", " \
    \ (for/list ([word strings]\n             #:when (string-prefix? prefix word))\n\
    \    word))\n", "  (match strings\n        ['() '()]\n        [(cons current rest)\n\
    \         (if (string-prefix? prefix current)\n             (cons current (filter_by_prefix\
    \ rest prefix))\n             (filter_by_prefix rest prefix))]))\n```\n\nThis\
    \ is a nice concise solution, but it still suffers from the mutual\nrecursion\
    \ problem of `filter_by_prefix` and `filter_by_prefix_impl`.  That\nproblem can\
    \ be fixed by _unrolling_ the loop:\n\n```racket\n#lang racket\n", "  (for/list\
    \ ([str strings]\n             #:when (string-prefix? prefix str))\n    str))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (starts-with?\
    \ s prefix)) strings))\n", "  (define (prefix? word prefix)\n    (and (>= (string-length\
    \ word) (string-length prefix))\n         (string=? (substring word 0 (string-length\
    \ prefix)) prefix)))\n  (filter (lambda (word) (prefix? word prefix)) strings))\n",
  "  (filter (\u03BB (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (\u03BB (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (lambda (string) (string-prefix?\
    \ prefix string)) strings))\n", "  (cond [(string=? prefix \"\") strings]\n  \
    \      [else (filter (lambda (s) (string-prefix? prefix s)) strings)]))\n", " \
    \ (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (equal?\
    \ (string-prefix prefix s) prefix)) strings))\n", "  (filter (lambda (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (filter (\u03BB (x) (string-prefix?\
    \ prefix x)) strings))\n```\n\n```racket\n#lang racket\n", "  (cond [(null? strings)\
    \ '()]\n        [(string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n        [else (filter_by_prefix (cdr\
    \ strings) prefix)]))\n", "  (filter (lambda (string) (string-prefix? prefix string))\
    \ strings))\n```\n\n```\n#lang racket\n", "  (let loop ([ss strings] [ans '()])\n\
    \    (cond [(empty? ss) (reverse ans)]\n          [(string-prefix? prefix (first\
    \ ss))\n           (loop (rest ss) (cons (first ss) ans))]\n          [else (loop\
    \ (rest ss) ans)])))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (\u03BB (str) (starts-with? str prefix)) strings))\n", "  (filter (\u03BB (string)\
    \ (string-prefix? prefix string)) strings))\n", "  (cond [(empty? strings) '()]\n\
    \        [(symbol=? (first strings) prefix)\n         (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n        [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (\u03BB (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n```\n\n## Previous\n\n* [Test Strings](test-strings.md)\n* [String\
    \ Length](string-length.md)\n* [String Prefix?](string-prefix.md)\n* [String Suffix?](string-suffix.md)\n\
    * [String Substring](string-substring.md)\n* [Split String](split-string.md)\n\
    * [Split String by Regex](split-string-by-regex.md)\n* [String Join](string-join.md)\n\
    * [String to List](string-to-list.md)\n* [List to String](list-to-string.md)\n\
    * [String to Number](string-to-number.md)\n* [Number to String](number-to-string.md)\n\
    * [String to Symbol](string-to-symbol.md)\n* [Symbol to String](symbol-to-string.md)\n\
    * [String Normalize](string-normalize.md)\n* [String Map](string-map.md)\n* [String\
    \ Replace](string-replace.md)\n* [String Reverse](string-reverse.md)\n* [String\
    \ Trim](string-trim.md)\n* [String Trim Left](string-trim-left.md)\n* [String\
    \ Trim Right](string-trim-right.md)\n* [String Pad Left](string-pad-left.md)\n\
    * [String Pad Right](string-pad-right.md)\n* [String to Upper Case](string-to-upper-case.md)\n\
    * [String to Lower Case](string-to-lower-case.md)\n* [String to Camel Case](string-to-camel-case.md)\n\
    * [String to Kebab Case](string-to-kebab-case.md)\n* [String to Snake Case](string-to-snake-case.md)\n\
    * [String Compare](string-compare.md)\n* [String Split](string-split.md)\n* [String\
    \ Concat](string-concat.md)\n* [String Replace All](string-replace-all.md)\n*",
  "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n\
    ```\n\n<a id=\"org3bd3a3d\"></a>\n\n### 4.10. Recursive Example: Filter\n\n```racket\n\
    #lang racket\n", "  (filter (lambda (x) (starts-with? x prefix)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (for/list ([s\
    \ strings]\n             #:when (string-prefix? prefix s))\n    s))\n", "  (cond\
    \ [(empty? strings) '()]\n        [(string-prefix? prefix (first strings))\n \
    \        (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n  \
    \      [else (filter_by_prefix (rest strings) prefix)]))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (if (empty? strings)\n     \
    \ empty\n      (if (string-prefix? prefix (first strings))\n          (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))\n          (filter_by_prefix\
    \ (rest strings) prefix))))\n", "  (filter (lambda (s) (string-prefix? prefix\
    \ s)) strings))\n```\n\n```\n#lang racket\n", "  (define (should_filter? s)\n\
    \    (string-prefix? prefix s))\n  (filter should_filter? strings))\n", "  (filter\
    \ (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (string)\
    \ (regexp-match? (regexp (string-append \"^\" prefix)) string)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (\u03BB\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (if (empty? strings)\n      '()\n      (let* ([head\
    \ (first strings)]\n             [rest (rest strings)])\n        (if (string-prefix?\
    \ prefix head)\n            (cons head (filter_by_prefix rest prefix))\n     \
    \       (filter_by_prefix rest prefix)))))\n", "  (filter (\u03BB (x) (and (>=\
    \ (string-length x) (string-length prefix))\n                       (string=?\
    \ (substring x 0 (string-length prefix)) prefix)))\n          strings))\n", " \
    \ (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (cond [(empty?\
    \ strings) '()]\n        [(string-prefix? prefix (first strings))\n         (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (cond\n    [(empty? strings) empty]\n    [(string-prefix?\
    \ prefix (first strings))\n     (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (match strings\n    ['() '()]\n    [(cons string rest)\n     (if (string-prefix?\
    \ prefix string)\n         (cons string (filter_by_prefix rest prefix))\n    \
    \     (filter_by_prefix rest prefix))]))\n", "  (filter (curryr starts-with? prefix)\
    \ strings))\n```\n\n```racket\n#lang racket\n", "  (cond ((null? strings) '())\n\
    \        ((string-prefix? prefix (car strings))\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))\n        (else (filter_by_prefix (cdr\
    \ strings) prefix))))\n", "  (define (starts-with-prefix string)\n    (string-prefix?\
    \ prefix string))\n  (filter starts-with-prefix strings))\n```\n\nThe code then\
    \ shows how to use this function:\n\n```#lang racket", "  (filter (lambda (string)\
    \ (equal? (string-prefix? string prefix) #t)) strings))\n```\n\n```racket\n#lang\
    \ racket\n", "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n```", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n```\n\n`string-prefix?` is the\
    \ \"Racket-flavored\" take on Python's `.startswith` method. This function determines\
    \ whether a given string is a prefix of another string.\n\nWe can also use `filter`\
    \ to create a function that removes a given item from a list:\n\n```racket\n#lang\
    \ racket\n", "  (filter (lambda (x) (prefix? prefix x)) strings))\n", "  (for/list\
    \ ([s strings] #:when (string-prefix? prefix s))\n    s))\n", "  (filter (\u03BB\
    \ (x) (eq? (substring x 0 1) prefix)) strings))\n", "  (define (f s p)\n    (if\
    \ (string-prefix? p s)\n        (list s)\n        '()))\n  (flatten (map (lambda\
    \ (s) (f s prefix)) strings)))\n", "  (define (helper strings prefix result)\n\
    \    (cond\n      [(empty? strings)\n       (reverse result)]\n      [(string-prefix?\
    \ prefix (first strings))\n       (helper (rest strings) prefix (cons (first strings)\
    \ result))]\n      [else\n       (helper (rest strings) prefix result)]))\n  (helper\
    \ strings prefix '()))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n```\n\n[Post on my blog](http://www.eli.sdsu.edu/index.php/blog/show/racket-pyret-filter-by-prefix)",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB (s) (equal?\
    \ (substring s 0 1) prefix)) strings))\n", "  (cond\n    [(empty? strings) empty]\n\
    \    [(string-prefix? prefix (first strings))\n     (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (filter (\u03BB (str) (string-prefix? prefix str)) strings))\n```\n\n``` #lang\
    \ racket\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", " \
    \ (cond\n    [(null? strings) '()]\n    [(string-prefix? prefix (car strings))\n\
    \     (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n    [else\
    \ (filter_by_prefix (cdr strings) prefix)]))\n", "  (filter (\u03BB (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (lambda (x) (regexp-match? (regexp (\"^\"\
    \ prefix)) x)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (cond [(empty? strings) empty]\n\
    \        [(string-prefix? prefix (first strings))\n         (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n```\n\n```racket\n#lang racket\n", "  (filter (lambda\
    \ (str) (string-prefix? prefix str)) strings))\n```\n\n```racket\n#lang racket\n",
  "  (filter (lambda (s) (and (string? s) (equal? (substring s 0 1) prefix))) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (for/list\
    \ ([string strings]\n             #:when (string-prefix? prefix string))\n   \
    \ string))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (cond\n    [(empty?\
    \ strings) '()]\n    [(string-prefix? prefix (first strings))\n     (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (filter (lambda (s) (and (string? s) (string-prefix?\
    \ prefix s))) strings))\n", "  (filter (lambda (s) (string-prefix? prefix s))\
    \ strings))\n", "  (filter (lambda (s) (string-prefix? prefix s)) strings))\n",
  "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter\
    \ (\u03BB (s) (starts-with? s prefix)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (for/list ([s strings]\n             #:when (string-prefix?\
    \ prefix s))\n    s))\n", "  (for/list ([string strings]\n             #:when\
    \ (string-prefix? prefix string))\n    string))\n", "  (filter (lambda (s) (regexp-match?\
    \ (regexp prefix) s)) strings))\n", "  (filter (lambda (s) (string-prefix? prefix\
    \ s)) strings))\n", "  (define (starts-with str p)\n    (and (&gt;= (string-length\
    \ str) (string-length p))\n         (string=? (substring str 0 (string-length\
    \ p)) p)))\n  (filter (lambda (str) (starts-with str prefix)) strings))\n", " \
    \ (filter (lambda (s) (equal? (substring s 0 1) prefix)) strings))\n", "  (filter\
    \ (\u03BB (x) (regexp-match? (regexp (string-append \"^\" prefix)) x)) strings))\n",
  "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n", "  (filter (\u03BB\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (cond\n    [(empty? strings)\
    \ '()]\n    [(string-prefix? prefix (first strings))\n     (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (filter (\u03BB (s) (string-prefix? prefix s)) strings))\n\
    ```\n### `(filter_by_regex regexp strings)`\n```racket\n#lang racket\n", "  (cond\
    \ ((empty? strings) (list))\n        ((string-prefix? prefix (first strings))\n\
    \         (cons (first strings) (filter_by_prefix (rest strings) prefix)))\n \
    \       (else (filter_by_prefix (rest strings) prefix))))\n", "  (filter (\u03BB\
    \ (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n</code>\nI got an error:\n<code>&gt; (filter_by_prefix\
    \ [\"abc\" \"bcd\" \"cde\" \"array\"] \"a\")\nfilter_by_prefix: expects argument\
    \ of type &lt;procedure&gt;; given: #f\n</code>\nWhat's wrong?\nUPDATE:\nI changed\
    \ the code as suggested by @Matthew Flatt:\n<code>#lang racket\n", "  (filter\
    \ (\u03BB (str) (string-prefix? prefix str)) strings))\n", "  (cond [(empty? strings)\
    \ empty]\n        [(string-prefix? prefix (first strings))\n         (cons (first\
    \ strings) (filter_by_prefix (rest strings) prefix))]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n```\n\n#### Namespace\n\nI have not found a way to\
    \ do Racket-like modules in Typed Racket. The approach I take is to just define\
    \ a `racket-ns` namespace and put the definitions in there.\n\n```lisp", "  (filter\
    \ (lambda (str) (string-prefix? prefix str)) strings))\n", "  (filter (lambda\
    \ (x) (string-prefix? prefix x)) strings))\n```\n\n### String Prefix?\n```#lang\
    \ racket\n", "  (filter (\u03BB (str) (string-prefix? prefix str)) strings))\n",
  "  (filter (lambda (str) (equal? (substring str 0 1) prefix)) strings))\n", "  (filter\
    \ (lambda (string) (string-prefix? prefix string)) strings))\n", "  (filter (lambda\
    \ (string) (string-starts-with? string prefix)) strings))\n", "  (filter (\u03BB\
    \ (s) (string-prefix? prefix s)) strings))\n", "  (filter (lambda (s) (string-prefix?\
    \ prefix s)) strings))\n", "  (filter (curry string-prefix? prefix) strings))\n",
  "  (filter (lambda (x) (string-prefix? prefix x)) strings))\n", "  (filter (lambda\
    \ (s) (and (= (string-length s) (string-length prefix))\n                    \
    \       (string=? (substring s 0 (string-length prefix)) prefix)))\n         \
    \ strings))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n\
    ```\n\n```#lang racket\n", "  (filter (lambda (string) (string-prefix? prefix\
    \ string)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str))\
    \ strings))\n", "  (filter (lambda (string) (string-prefix? prefix string)) strings))\n\
    ```\n\n```racket\n#lang racket\n", "  (filter (lambda (str) (string-prefix? prefix\
    \ str)) strings))\n", "  (filter (lambda (str) (string-prefix? prefix str)) strings))\n",
  "  (if (empty? strings)\n      '()\n      (let* ([str (first strings)]\n       \
    \      [str-first (first str)]\n             [str-rest (rest str)])\n        (if\
    \ (string=? prefix str-first)\n            (cons str (filter_by_prefix (rest strings)\
    \ prefix))\n            (filter_by_prefix (rest strings) prefix)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
