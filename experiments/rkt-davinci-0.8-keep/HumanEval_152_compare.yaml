name: HumanEval_152_compare
language: rkt
prompt: "#lang racket\n\n;; I think we all remember that feeling when the result of\
  \ some long-awaited\n;; event is finally known. The feelings and thoughts you have\
  \ at that moment are\n;; definitely worth noting down and comparing.\n;; Your task\
  \ is to determine if a person correctly guessed the results of a number of matches.\n\
  ;; You are given two arrays of scores and guesses of equal length, where each index\
  \ shows a match. \n;; Return an array of the same length denoting how far off each\
  \ guess was. If they have guessed correctly,\n;; the value is 0, and if not, the\
  \ value is the absolute difference between the guess and the score.\n;; example:\n\
  ;; compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n;; compare([0,5,0,0,0,4],[4,1,1,0,0,-2])\
  \ -> [4,4,1,0,0,6]\n(define (compare game guess)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate compare))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5 1) (list 1 2 3 4 2 -2)) (list 0 0\
  \ 0 0 3 3))\n    (check-equal? (candidate (list 0 0 0 0 0 0) (list 0 0 0 0 0 0))\
  \ (list 0 0 0 0 0 0))\n    (check-equal? (candidate (list 1 2 3) (list -1 -2 -3))\
  \ (list 2 4 6))\n    (check-equal? (candidate (list 1 2 3 5) (list -1 2 3 4)) (list\
  \ 2 0 0 1))\n))\n\n(test-humaneval)"
completions: ['  (map abs (map - game guess)))', "  (for/list ([x (in-list game)]\
    \ [y (in-list guess)])\n    (cond\n      [(= x y) 0]\n      [else (abs (- x y))])))\n",
  "  (for/list ((g game) (h guess))\n    (cond [(> g h) (- g h)]\n          [(< g\
    \ h) (- h g)]\n          [else 0])))\n", '  (for/list ([s game] [g guess]) (if
    (= s g) 0 (abs (- s g)))))', "  (map abs (map - game guess)))\n", "  (map (lambda\
    \ (x y)\n         (if (= x y)\n             0\n             (abs (- x y))))\n\
    \       game guess))\n", "  (map (lambda (x y)\n         (if (= x y) 0 (abs (-\
    \ x y))))\n       game guess))\n", "  (map (lambda (x y) (if (= x y) 0 (abs (-\
    \ x y)))) game guess))\n</code>\n", "  (map (lambda (x y)\n         (if (= x y)\n\
    \             0\n             (abs (- x y))))\n       game guess))\n", "  (map\
    \ (\u03BB (scr gus)\n         (cond\n           ((= scr gus) 0)\n           (else\
    \ (abs (- scr gus)))))\n       game guess))", "  (map-indexed (lambda (i g) (if\
    \ (= g (vector-ref game i)) 0 (abs (- g (vector-ref game i))))) guess))\n", " \
    \ (map (lambda (game guess)\n         (cond\n           [(> game guess) (- game\
    \ guess)]\n           [(< game guess) (- guess game)]\n           [else 0]))\n\
    \       game guess))\n", "  (for/list ([i (in-range (length game))])\n    (if\
    \ (= (list-ref game i) (list-ref guess i))\n        0\n        (abs (- (list-ref\
    \ game i) (list-ref guess i))))))", "  (for/list ([n (- (length game) 1)])\n \
    \           (cond\n              [(zero? (abs (- (list-ref game n) (list-ref guess\
    \ n)))) 0]\n              [else (abs (- (list-ref game n) (list-ref guess n)))])))\n",
  "  (map (lambda (x y) (abs (- x y))) game guess))\n", '  (map abs (map - game guess)))',
  "  (for/list ([g game] [q guess])\n    (cond [(= g q) 0]\n          [else (abs (-\
    \ g q))])))\n", "  (let loop ((game game)\n             (guess guess)\n      \
    \       (result '()))\n    (if (and (pair? game) (pair? guess))\n        (loop\
    \ (cdr game)\n              (cdr guess)\n              (cons (if (= (car game)\
    \ (car guess))\n                      0\n                      (abs (- (car game)\
    \ (car guess))))\n                    result))\n        (reverse result))))\n\
    </code>\nThanks @jvg \n<code>#lang racket\n", "  (map abs (for/list ([a (in-list\
    \ game)]\n                      [b (in-list guess)])\n                (- a b))))",
  "  (map abs (map - game guess)))\n", "  (for/list ([x game] [y guess])\n    (cond\n\
    \      [(= x y) 0]\n      [else (abs (- x y))])))\n", "  (map abs (map - game\
    \ guess)))\n", "  (for/list ([g (in-list game)]\n             [h (in-list guess)])\n\
    \    (cond\n      [(equal? g h) 0]\n      [else (abs (- g h))])))\n```\n\n```\n\
    #lang racket\n", "  (map abs (map - game guess)))\n", "  (map (lambda (x y)\n\
    \         (if (= x y)\n             0\n             (abs (- x y))))\n       game\
    \ guess))", '  (map abs (map - game guess)))', "  (for/list ([i game]\n      \
    \       [j guess])\n    (abs (- i j))))\n", "  (for/list ([x game]\n         \
    \    [y guess])\n    (if (= x y)\n        0\n        (abs (- x y)))))\n", "  (define\
    \ (helper lst1 lst2)\n    (cond [(and (null? lst1) (null? lst2)) empty]\n    \
    \      [(and (null? lst1) (not (null? lst2))) (helper empty lst2)]\n         \
    \ [(and (not (null? lst1)) (null? lst2)) (helper lst1 empty)]\n          [else\
    \ (cons (if (= (car lst1) (car lst2)) 0 (abs (- (car lst1) (car lst2))))\n   \
    \                   (helper (cdr lst1) (cdr lst2)))]))\n  (helper game guess))\n",
  "  (for/list ([g (in-list game)]\n             [q (in-list guess)])\n    (cond [(=\
    \ g q) 0]\n          [else (abs (- g q))])))", "    (map abs (map - game guess)))\n",
  '  (map abs (map - game guess)))', "  (for/list ([i (in-range (length game))])\n\
    \    (abs (- (vector-ref game i) (vector-ref guess i)))))\n", "  (map (lambda\
    \ (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n", "  (for/list ([g game]\
    \ [s guess])\n    (let ([d (- g s)])\n      (cond [(> 0 d) (- d)]\n          \
    \  [(< 0 d) d]\n            [else 0]))))\n", "  (for/list ([g game] [g2 guess])\n\
    \    (if (= g g2)\n        0\n        (abs (- g g2)))))\n", "  (map (\u03BB (pair)\
    \ (abs (- (car pair) (cadr pair))))\n       (zip game guess)))\n", "  (for/list\
    \ ([g game] [g2 guess])\n    (if (= g g2)\n        0\n        (abs (- g g2)))))",
  '  (map abs (map - game guess)))', "  (for/list ([i (in-range (length game))])\n\
    \            (abs (- (list-ref game i) (list-ref guess i)))))", "  (map abs (map\
    \ - game guess)))\n", "  (map (lambda (game guess) (if (equal? game guess) 0 (abs\
    \ (- game guess)))) game guess))\n", "  (for/list ([g (in-list game)]\n      \
    \       [q (in-list guess)])\n    (abs (- g q))))\n\n", "  (map (lambda (game-guess)\n\
    \         (let ((game-score (car game-guess))\n               (guess-score (cdr\
    \ game-guess)))\n           (abs (- game-score guess-score))))\n       (zip game\
    \ guess)))\n</code>\nI'd like to highlight the <code>define</code> part - I've\
    \ been trying to define a function, which will be comparing 2 lists (game and\
    \ guess), to be usable in the first line of code, and it doesn't work. It keeps\
    \ saying \"compare: unbound identifier in module in: compare\"\n\n\nA:\n\nYou\
    \ need to put your definitions inside a module. You can do this by creating a\
    \ file with a module declaration:\n<code>#lang racket\n", "  (for/list ([score\
    \ game]\n             [gess guess])\n    (abs (- score gess))))\n", "  (map (lambda\
    \ (g q)\n         (if (= g q)\n             0\n             (abs (- g q))))\n\
    \       game guess))\n", "  (for/list ([s game] [g guess])\n    (if (= s g)\n\
    \        0\n        (abs (- s g)))))\n", "  (for/list ([g game] [p guess])\n \
    \   (if (= g p)\n        0\n        (abs (- g p)))))\n```\n\n## 4. Even Numbers\n\
    ```#lang racket\n", "  (let* ([len (vector-length game)]\n         [res (make-vector\
    \ len)])\n    (for ([i (in-range len)])\n      (vector-set! res i (abs (- (vector-ref\
    \ game i) (vector-ref guess i)))))\n    res))\n", "  (map (lambda (n)\n      \
    \   (if (equal? (first n) (second n))\n             0\n             (abs (- (first\
    \ n) (second n)))))\n       (zip game guess)))\n", "  (for/list ([a (in-list game)]\n\
    \             [b (in-list guess)])\n    (if (= a b)\n        0\n        (abs (-\
    \ a b)))))\n", '  (map abs (map - game guess)))', "  (if (null? game) '()\n  \
    \    (cons (abs (- (car game) (car guess))) (compare (cdr game) (cdr guess)))))\n",
  "  (for/list ([i (in-range (length game))])\n    (if (= (list-ref game i) (list-ref\
    \ guess i))\n        0\n        (abs (- (list-ref game i) (list-ref guess i))))))",
  "  (define abs-diff (lambda (x y) (if (&lt; x y) (- y x) (- x y))))\n  (map (lambda\
    \ (x y) (if (= x y) 0 (abs-diff x y))) game guess))\n</code>\nI took the first\
    \ three tests and passed them. I was wondering if this is something that is considered\
    \ good practice in a Racket interview. Should I have made the function one-line?\
    \ What other things could I have done better?\n\n\nA:\n\nI think this is really\
    \ bad programming style. You've got just 3 test cases and if I were the interviewer\
    \ I would reject this immediately.\nFirst, you've got two functions embedded in\
    \ the one. Why not just two separate functions? And why use <code>map</code>?\
    \ How about something like this?\n<code>(define (compare game guess)\n  (map score-compare\
    \ game guess))\n", "  (for/list ([i (in-range (length game))])\n            (abs\
    \ (- (vector-ref game i) (vector-ref guess i)))))", "  (map (lambda (g u)\n  \
    \       (if (= g u)\n             0\n             (abs (- g u))))\n       game\
    \ guess))\n", "  (for/list ([g game] [q guess])\n            (abs (- g q))))\n",
  "  (for/list ([(list g gs) (zip game guess)])\n    (abs (- g gs))))\n", '  (map
    abs (map - game guess)))', "  (map (lambda (n) (if (positive? (sub1 n)) n 0))\n\
    \       (map abs (map - game guess))))\n</code>\n", '  (map abs (map - game guess)))',
  "  (map (lambda (couple)\n         (cond [(equal? (car couple) (cadr couple)) 0]\n\
    \               [else (abs (- (car couple) (cadr couple)))]))\n       (map list\
    \ game guess)))\n", "  (for/list ([score game]\n             [g guess])\n    (abs\
    \ (- score g))))\n</code>\nTests:\n<code>(define (test name expected-result received-result)\n\
    \  (if (equal? expected-result received-result)\n      (displayln (string-append\
    \ \"Test passed: \" name))\n      (displayln (string-append \"Test failed: \"\
    \ name))\n      (displayln (string-append \"Expected: \" (show expected-result)))\n\
    \      (displayln (string-append \"Received: \" (show received-result)))))\n",
  "  (map (\u03BB (g r) (abs (- g r))) game guess))\n```\n\n### The Last\n\n```#lang\
    \ racket\n", "  (map\n   (lambda (g p)\n     (cond\n       [(eq? g p) 0]\n   \
    \    [else (abs (- g p))]))\n   game guess))\n", "  (map abs (map - game guess)))\n",
  "  (for/list ([i (in-range (length game))])\n            (if (= (list-ref game i)\
    \ (list-ref guess i))\n                0\n                (abs (- (list-ref game\
    \ i) (list-ref guess i))))))\n", "  (for/list ([g (in-list game)]\n          \
    \   [q (in-list guess)])\n    (abs (- g q))))\n</code>\n\n<code>#lang racket\n",
  "  (for/list ([g game] [g2 guess])\n    (if (= g g2)\n        0\n        (abs (-\
    \ g g2)))))\n", "  (map abs (map - game guess)))\n", "  (for/list ([x game]\n\
    \             [y guess])\n    (if (= x y)\n        0\n        (abs (- x y)))))\n",
  "  (map abs (map - game guess)))\n", "  (map (\u03BB (x y) (cond [(or (= x y) (=\
    \ x (- y))) 0] [else (abs (- x y))])) game guess))\n", "  (for/list ([g game]\
    \ [q guess])\n    (abs (- g q))))\n", "  (for/list ([g game] [h guess])\n    (cond\n\
    \      [(zero? (abs (- g h))) 0]\n      [else (abs (- g h))])))\n", "  (for/list\
    \ ([s game] [g guess])\n    (if (= s g)\n        0\n        (abs (- s g)))))\n",
  "  (cond [(empty? game) empty]\n        [else (cons (abs (- (first game) (first\
    \ guess))) (compare (rest game) (rest guess)))]))\n", "  (for/list ([i (in-range\
    \ (length game))])\n    (abs (- (list-ref game i) (list-ref guess i)))))\n", " \
    \ (for/list ([g game] [g2 guess])\n    (abs (- g g2))))\n", "  (map (lambda (pair)\n\
    \         (let ((g (car pair))\n               (s (cadr pair)))\n           (if\
    \ (= g s)\n               0\n               (abs (- g s)))))\n       (zip game\
    \ guess)))\n", '  (map abs (map - game guess)))', "  (map abs (- game guess)))\n",
  "  (for/list ([g game] [u guess])\n    (cond\n      [(= g u) 0]\n      [else (abs\
    \ (- g u))])))\n", "  (for/list ([a game] [b guess])\n    (if (= a b)\n      \
    \  0\n        (abs (- a b)))))\n```\n\n```\n#lang racket\n", '  (map abs (map
    - game guess)))', "  (map (lambda (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n",
  "  (map (\u03BB (game guess)\n         (if (= game guess)\n             0\n    \
    \         (abs (- game guess))))\n       game guess))\n", "  (map abs (map - game\
    \ guess)))\n", "  (map (lambda (game guess)\n         (if (= game guess)\n   \
    \          0\n             (abs (- game guess))))\n       game guess))\n", " \
    \ (map abs (map - game guess)))\n</code>\nI get this error:\n<code>map: expects\
    \ type &lt;number number -&gt; number&gt; as 1st argument, given: #&lt;function\
    \ -&gt;;\nother arguments were: '(1 2 3 4 5 1) '(1 2 3 4 2 -2)\n</code>\nWhat\
    \ do I do wrong?\n\n\nA:\n\nYour code is fine, it will work if you run it in DrRacket\
    \ or something similar.  The problem is the site itself, it doesn't seem to understand\
    \ how to handle your code.  There are several ways to solve this problem.\nThe\
    \ easiest one is to remove the comment on the first line.  The reason is that\
    \ the site interprets the comment as part of the program.  In Racket, <code>#lang</code>\
    \ is a comment, and while you're at it, you can also remove the space before the\
    \ first parenthesis.\nThe second way is to use <code>#reader</code> instead of\
    \ <code>#lang</code> and to make sure that it is the first word of the first line:\n\
    <code>#reader racket\n</code>\nAnd the third way is to use <code>#lang racket</code>\
    \ but put it on the same line as the first parenthesis:\n<code>#lang racket (require\
    \ rackunit)\n</code>\n", "  (for/list ([pair (in-zip game guess)])\n    (define\
    \ (out-of-bounds? guess)\n      (or (< (car pair) (car guess)) (> (car pair) (cdr\
    \ guess))))\n    (cond\n      [(or (out-of-bounds? guess) (equal? (car pair) (cdr\
    \ pair))) 0]\n      [else (abs (- (car pair) (cdr pair)))])))\n", "  (map (\u03BB\
    \ (x y)\n         (if (= x y)\n             0\n             (abs (- x y))))\n\
    \       game guess))", "  (for/list ([i (in-range (length game))])\n    (cond\
    \ [(equal? (vector-ref game i) (vector-ref guess i)) 0]\n          [else (abs\
    \ (- (vector-ref game i) (vector-ref guess i)))])))", "  (for/list ([s (in-list\
    \ game)]\n             [g (in-list guess)])\n    (abs (- s g))))\n", "  (map (lambda\
    \ (gameguess)\n         (let ((g (car gameguess))\n               (gu (cadr gameguess)))\n\
    \           (cond [(zero? g)\n                  (abs (- g gu))]\n            \
    \     [(zero? gu)\n                  (abs (- g gu))]\n                 [else\n\
    \                  (abs (- g gu))])))\n       (zip game guess)))\n", "  (for/list\
    \ ([i (in-range (length game))])\n    (abs (- (list-ref game i) (list-ref guess\
    \ i)))))\n", "  (map (lambda (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n",
  "  (for/list ([(list r g) (in-list (zip game guess))])\n    (if (= r g)\n      \
    \  0\n        (abs (- r g)))))\n", "  (if (null? game)\n      (list)\n      (cons\
    \ (if (= (car game) (car guess))\n                0\n                (abs (- (car\
    \ game) (car guess))))\n            (compare (cdr game) (cdr guess)))))\n", " \
    \ (for/list ([score game]\n             [guess guess])\n    (abs (- score guess))))\n",
  "  (map (lambda (x y) (abs (- x y))) game guess))\n```", "  (map (\u03BB (x y) (if\
    \ (= x y) 0 (abs (- x y)))) game guess))\n", "  (for/list ([(list score guess)\
    \ (zip game guess)])\n    (abs (- score guess))))", '  (map (lambda (x y) (if
    (= x y) 0 (abs (- x y)))) game guess))', "  (for/list ([x (in-list game)]\n  \
    \           [y (in-list guess)])\n    (if (= x y)\n        0\n        (abs (-\
    \ x y)))))\n", "  (map abs (map-match game guess -)))\n", "  (map abs (map - game\
    \ guess)))\n", "  (for/list ([i (in-range (length game))])\n    (abs (- (list-ref\
    \ game i) (list-ref guess i)))))\n", "    (for/list ([index (in-range (length\
    \ game))])\n        (let ([i (list-ref game index)]\n              [j (list-ref\
    \ guess index)])\n            (cond\n             [(equal? i j) 0]\n         \
    \    [else (abs (- i j))]))))", "  (for/list ([x (in-range (length game))])\n\
    \    (if (= (vector-ref game x) (vector-ref guess x))\n        0\n        (abs\
    \ (- (vector-ref game x) (vector-ref guess x))))))\n", "  (for/list ([i game]\n\
    \             [j guess])\n    (if (= i j)\n        0\n        (abs (- i j)))))\n",
  "  (for/list ([i (in-range (length game))])\n    (if (= (vector-ref game i) (vector-ref\
    \ guess i))\n        0\n        (abs (- (vector-ref game i) (vector-ref guess\
    \ i))))))\n", "  (for/list ([x game]\n             [y guess])\n    (abs (- x y))))\n",
  "  (map abs (map - game guess)))\n", "  (for/list ([point (in-list game)]\n    \
    \         [guess-point (in-list guess)])\n    (cond\n      [(= point guess-point)\
    \ 0]\n      [else (abs (- point guess-point))])))\n```\n\n```scheme\n#lang racket\n",
  "  (map (lambda (cur)\n         (if (= cur 0)\n             0\n             (abs\
    \ (- cur guess))))\n       game))\n", "  (for/list ([g game] [q guess])\n    (abs\
    \ (- g q))))\n", "  (for/list ([g game] [g2 guess])\n    (if (= g g2)\n      \
    \  0\n        (abs (- g g2)))))\n```\n\n### Caesar Cipher Encryptor\n\n```racket\n\
    #lang racket\n", "\t(for/list ([i (in-range (length game))])\n\t\t(if (= (list-ref\
    \ game i) (list-ref guess i))\n\t\t\t0\n\t\t\t(abs (- (list-ref game i) (list-ref\
    \ guess i))))))\n```", "  (map (\u03BB (pair)\n         (let ([g (car pair)]\n\
    \               [p (cadr pair)])\n           (cond\n             [(= g p) 0]\n\
    \             [else (abs (- g p))])))\n       (zip game guess)))\n", "  (for/list\
    \ ([i (in-naturals)]\n             #:when (< i (length game)))\n    (cond\n  \
    \    [(= (list-ref game i) (list-ref guess i)) 0]\n      [else (abs (- (list-ref\
    \ game i) (list-ref guess i)))])))\n", "  (map \n   (lambda (g gs) (if (= g gs)\
    \ 0 (- g gs)))\n   game guess))\n```\n\n```python\ndef compare(game, guess):\n\
    \    return [abs(g - gs) if g != gs else 0 for g, gs in zip(game, guess)]\n```\n\
    \n```coffeescript\ndef compare(game, guess)\n    [abs(g - gs) for g, gs in zip(game,\
    \ guess) if g != gs]\n```\n\n## How to run it\n\n### 1. Run it on the terminal:\n\
    \n```\nracket <filename>.rkt\n```\n\n### 2. Run it on the Dr. Racket:\n\n## Sample\
    \ Output\n\n```\n> (compare [1,2,3,4,5,1] [1,2,3,4,2,-2])\n'(0 0 0 0 3 3)\n> (compare\
    \ [0,5,0,0,0,4] [4,1,1,0,0,-2])\n'(4 4 1 0 0 6)\n```", "  (map (lambda (g gs)\n\
    \         (abs (- g gs)))\n       game guess))\n</code>\n", "  (map (lambda (game-score\
    \ guess-score)\n         (if (= game-score guess-score)\n             0\n    \
    \         (abs (- game-score guess-score))))\n       game\n       guess))", " \
    \ (for/list ([(list score guess) (zip game guess)])\n    (abs (- score guess))))\n",
  "  (map (\u03BB (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n", "  (map (\u03BB\
    \ (p)\n         (let* ((game-number (car p))\n                (guess-number (cadr\
    \ p)))\n           (if (= game-number guess-number)\n               0\n      \
    \         (abs (- game-number guess-number)))))\n       (map list game guess)))\n",
  "  (map abs (map - game guess)))\n", "  (map (lambda (g gm) (abs (- g gm))) game\
    \ guess))\n", "  (map (\u03BB (g r) (cond [(= g r) 0]\n                      \
    \ [else (- (abs g) (abs r))]))\n       game guess))\n", '  (map abs (map - game
    guess)))', "  (map abs (- game guess)))\n", "  (map (\u03BB (g r) (abs (- g r)))\
    \ game guess))\n", "  (map (lambda (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n\
    </code>\n", "  (for/list ([g game] [h guess])\n    (if (= g h)\n        0\n  \
    \      (abs (- g h)))))", "  (for/list ([x (in-list game)]\n             [y (in-list\
    \ guess)])\n    (if (= x y)\n        0\n        (abs (- x y)))))\n", "  (map abs\
    \ (map - game guess)))\n", "  (for/list ([g game] [x guess])\n            (cond\
    \ [(= g x) 0]\n                  [else (abs (- g x))])))\n", "  (for/list ([g\
    \ game] [q guess])\n    (if (= g q)\n        0\n        (abs (- g q)))))\n```\n\
    ##### Input: \n```", "  (map abs (map - game guess)))\n", "  (map (lambda (x y)\n\
    \t (if (= x y)\n\t     0\n\t     (abs (- x y))))\n       game guess))", "  (map\
    \ (lambda (game guess)\n         (if (= game guess)\n             0\n        \
    \     (abs (- game guess))))\n       game guess))\n", "  (map abs (map - game\
    \ guess)))\n", "  (map (lambda (g)\n         (if (= g (car game))\n          \
    \   0\n             (abs (- g (car game)))))\n       guess))\n", "  (map (lambda\
    \ (g)\n\t (if (= g 0)\n\t     0\n\t     (abs (- g (car guess)))))\n       game))\n",
  "  (map (lambda (g r) (if (= g r) 0 (abs (- g r)))) guess game))\n</code>\nCompare\
    \ is supposed to take two lists and return the difference between each guess and\
    \ game result. If the guess is correct, then the difference is 0. If not, then\
    \ it's the absolute difference between the guess and the game result.\nI'm not\
    \ sure what is wrong with the code above, but it is running into an error:\n<code>compare:\
    \ contract violation\n  expected: (and/c list? list?)\n  given: '(2)\n</code>\n\
    What is wrong with the code?\n\n\nA:\n\nAs the error tells you, you passed a single\
    \ list instead of two. When you look at your code, you'll notice that you pass\
    \ the literal <code>'(2)</code> to <code>compare</code>, instead of passing <code>'(2)</code>\
    \ to <code>map</code> as the second argument, as you intended.\n<code>(define\
    \ (compare game guess)\n  (map (lambda (g r) (if (= g r) 0 (abs (- g r)))) guess\
    \ game))\n</code>\nHere is a fix (using a different <code>map</code> to avoid\
    \ confusion):\n<code>(define (compare game guess)\n  (for/list ([g guess] [r game])\n\
    \    (if (= g r) 0 (abs (- g r)))))\n</code>\n", "  (map (\u03BB (a b)\n     \
    \    (if (= a b)\n             0\n             (abs (- a b))))\n       game guess))\n\
    ```", "  (map (\u03BB (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n", " \
    \ (for/list ([a game] [b guess])\n    (cond [(= a b) 0]\n          [else (abs\
    \ (- a b))])))", '  (map abs (map - game guess)))', "  (for/list ([g game] [h\
    \ guess])\n    (abs (- g h))))\n", "  (for/list ([i (in-range (length game))])\n\
    \    (abs (- (list-ref game i) (list-ref guess i)))))\n", "  (for/list ([g (in-list\
    \ game)]\n             [q (in-list guess)])\n    (if (= g q)\n        0\n    \
    \    (abs (- g q)))))\n", "  (let* ([sum (map + game guess)])\n    (map (lambda\
    \ (num)\n           (if (= num 0) 0 (- (abs num))))\n         sum)))", "  (build-list\
    \ (length game)\n              (lambda (i)\n                (if (= (list-ref game\
    \ i) (list-ref guess i))\n                    0\n                    (abs (- (list-ref\
    \ game i) (list-ref guess i)))))))", "  (map (lambda (a b)\n         (cond ((=\
    \ a b) 0)\n               (else (abs (- a b)))))\n       game guess))\n", "  (for/list\
    \ ([x (in-naturals)])\n    (abs (- (list-ref game x) (list-ref guess x)))))\n",
  "  (map (lambda (a b) (cond ((= a b) 0)\n                           (else (abs (-\
    \ a b)))))\n       game guess))\n", "  (map abs (map - game guess)))\n", "  (map\
    \ (lambda (g u)\n         (if (= g u)\n             0\n             (abs (- g\
    \ u))))\n       game guess))", "  (map abs (map - game guess)))\n", "  (map (\u03BB\
    \ (x y)\n         (cond [(= x y) 0]\n               [else (abs (- x y))]))\n \
    \      game guess))\n", "  (for/list ([g (in-list game)]\n             [q (in-list\
    \ guess)])\n    (abs (- g q))))\n", "  (map abs (map - game guess)))\n", "  (map\
    \ (\u03BB (x y) (if (= x y) 0 (abs (- x y)))) game guess))\n", "  (for/list ([g\
    \ game] [h guess])\n    (if (= g h)\n        0\n        (abs (- g h)))))\n", " \
    \ (for/list ([scr (in-list game)]\n             [gss (in-list guess)])\n    (cond\
    \ [(= scr gss) 0]\n          [else (abs (- scr gss))])))\n", "    (for/list ([a\
    \ (in-list game)]\n               [b (in-list guess)])\n      (if (= a b) 0 (abs\
    \ (- a b)))))\n", "  (map (\u03BB (e) (if (equal? (list-ref game e) (list-ref\
    \ guess e)) 0 (abs (- (list-ref game e) (list-ref guess e))))) (build-list (length\
    \ game) id)))\n```\n## Averages of numbers\n```racket\n#lang racket\n", "  (map\
    \ (\u03BB (game guess) (abs (- game guess))) game guess))\n", "  (map abs (map\
    \ - game guess)))\n", "  (for/list ([i (in-range (length game))])\n    (if (=\
    \ (list-ref game i) (list-ref guess i))\n        0\n        (abs (- (list-ref\
    \ game i) (list-ref guess i))))))\n", "  (map abs (map - game guess)))\n", " \
    \ (mapv abs (mapv - game guess)))\n</code>\nThis is how I did it, but I need it\
    \ to be one line.\n\n\nA:\n\nThere are a few ways you can do this, but I'll show\
    \ you one:\n<code>(define (compare game guess)\n  (for/list ([x (in-list game)]\n\
    \             [y (in-list guess)])\n    (abs (- x y))))\n</code>\nThere are many\
    \ shorter ways to write this, but I think this is the most readable.\n", "\t(map\
    \ abs (map - game guess)))\n", "  (map abs (map - game guess)))\n```\n\n[Back\
    \ to top](#top)", "  (for/list ([g game] [w guess])\n            (if (= g w)\n\
    \                0\n                (abs (- g w)))))\n", "  (map (lambda (x y)\n\
    \         (if (= x y)\n             0\n             (abs (- x y))))\n       game\
    \ guess))\n", "  (map (lambda (game guess)\n         (if (= game guess)\n    \
    \         0\n             (abs (- game guess))))\n       game guess))\n", "  (map\
    \ (\u03BB (n) (abs (- n (car guess)))) game))\n", "  (cond\n    [(null? game)\
    \ '()]\n    [else (cons (abs (- (car game) (car guess))) (compare (cdr game) (cdr\
    \ guess)))]))\n", "  (for/list ([game-score (in-list game)]\n             [guess-score\
    \ (in-list guess)])\n    (abs (- game-score guess-score))))\n", "  (map abs (map\
    \ - game guess)))\n</code>\nI tested it in DrRacket using <code>(require rackunit)</code>\
    \ and this tests:\n<code>(check-equal? (compare '(1 2 3 4 5 1) '(1 2 3 4 2 -2))\
    \ '(0 0 0 0 3 3))", '  (map (lambda (x y) (if (= x y) 0 (abs (- x y)))) game guess))',
  "  (for/list ([i (in-range (length game))])\n    (if (= (vector-ref game i) (vector-ref\
    \ guess i))\n        0\n        (abs (- (vector-ref game i) (vector-ref guess\
    \ i))))))\n", "  (for/list ([g game] [s guess]) (if (= g s) 0 (abs (- g s)))))\n",
  "  (map abs (map - game guess)))\n", "  (map (lambda (score guess)\n         (cond\
    \ [(= score guess) 0]\n               [else (abs (- score guess))]))\n       game\
    \ guess))\n", "  (map (lambda (pair)\n         (if (equal? (car pair) (cadr pair))\n\
    \             0\n             (abs (- (car pair) (cadr pair)))))\n       (zip\
    \ game guess)))", "  (map (\u03BB (score guess)\n         (if (= score guess)\n\
    \             0\n             (abs (- score guess))))\n       game guess))\n",
  "  (for/list ([score game]\n             [g guess])\n    (if (= score g)\n     \
    \   0\n        (abs (- score g)))))", "  (map (\u03BB (x y) (if (= x y) 0 (abs\
    \ (- x y)))) game guess))\n", "  (map abs (map - game guess)))\n", "  (for/list\
    \ ([g game] [g2 guess])\n    (cond\n      [(and (= g g2) (= g 0)) 0]\n      [(=\
    \ g g2) 0]\n      [else (abs (- g g2))])))\n", "  (if (= 0 (length game)) '()\n\
    \      (cons (if (= (first game) (first guess)) 0\n              (abs (- (first\
    \ game) (first guess))))\n            (compare (rest game) (rest guess)))))\n",
  "  (map abs (map - game guess)))\n", "  (if (null? game)\n      '()\n      (cons\
    \ (if (= (car game) (car guess)) 0 (- (car game) (car guess)))\n            (compare\
    \ (cdr game) (cdr guess)))))\n", "    (for/list ([x (in-list game)]\n        \
    \       [y (in-list guess)])\n     (cond [(zero? (- x y)) 0]\n           [else\
    \ (abs (- x y))])))\n```\n\n```racket\n#lang racket\n", "  (map abs (map - game\
    \ guess)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
