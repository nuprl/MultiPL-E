name: HumanEval_27_flip_case
language: rkt
prompt: "#lang racket\n\n;; For a given string, flip lowercase characters to uppercase\
  \ and uppercase to lowercase.\n;; >>> flip_case('Hello')\n;; 'hELLO'\n(define (flip_case\
  \ string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate flip_case))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"Hello!\"\
  ) \"hELLO!\")\n    (check-equal? (candidate \"These violent delights have violent\
  \ ends\") \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n))\n\n(test-humaneval)"
completions: ["  (map string\n       (lambda (ch)\n         (if (char-alphabetic?\
    \ ch)\n             (if (char-lower-case? ch)\n                 (char-upcase ch)\n\
    \                 (char-downcase ch))\n             ch))))\n```\n\n```racket\n\
    #lang racket\n", "  (string-map \n   (lambda (char) \n     (cond \n       [(char-lower-case?\
    \ char) (char-upcase char)]\n       [(char-upper-case? char) (char-downcase char)]\n\
    \       [else char]))\n   string))\n", "  (letrec ([chars (string->list string)]\n\
    \           [flip (lambda (char)\n                   (cond [(char-upper-case?\
    \ char) (char-downcase char)]\n                         [(char-lower-case? char)\
    \ (char-upcase char)]\n                         [else char]))])\n    (list->string\
    \ (map flip chars))))\n", "  (string-append (map (\u03BB (x) (if (char-lower-case?\
    \ x) (char-upcase x) (char-downcase x))) string)))\n", "  (string-append\n   (map\n\
    \    (\u03BB (x)\n      (cond\n        [(char-lower-case? x) (char-upcase x)]\n\
    \        [(char-upper-case? x) (char-downcase x)]\n        [else x]))\n    string)))\n",
  "  (map (\u03BB (x)\n         (cond [(char-lower-case? x) (char-upcase x)]\n   \
    \            [(char-upper-case? x) (char-downcase x)]\n               [else x]))\n\
    \       string))\n", "  (regexp-replace* #rx\"[a-z]\" string\n               \
    \    (lambda (s i)\n                     (string-upcase (string-downcase s)))))\n",
  "  (string-append (string-map (lambda (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) string)))\n", "  (map (\u03BB (c) (if (char-lower-case?\
    \ c) (char-upcase c) (char-downcase c))) string))\n", "  (string-map (\u03BB (c)\n\
    \                (if (char-lower-case? c)\n                    (char-upcase c)\n\
    \                    (char-downcase c)))\n              string))\n```\n\n```racket\n\
    #lang racket\n", "  (string-upcase (string-downcase string)))\n", "  (map (lambda\
    \ (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n",
  "  (string-join\n   (map\n    (\u03BB (c)\n      (if (char-ci&lt;=? #\\a c #\\z)\n\
    \          (char-upcase c)\n          (char-downcase c)))\n    (string-&gt;list\
    \ string))))\n", "  (apply string-append\n         (map (lambda (char)\n     \
    \           (cond\n                  [(char-lower-case? char) (char-upcase char)]\n\
    \                  [(char-upper-case? char) (char-downcase char)]\n          \
    \        [else                     char]))\n              string)))\n", "  (string-map\
    \ (lambda (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (match)\n  \
    \                   (string-upcase (string-downcase match)))))\n", "  (string-upcase/downcase\
    \ string))\n", "  (string-map (lambda (x)\n                (if (char-ci&gt;=?\
    \ x #\\a)\n                    (char-upcase x)\n                    (char-downcase\
    \ x)))\n              string))\n</code>\n<code>#lang racket\n", "  (define (flip-char\
    \ char)\n    (if (char-lower-case? char)\n        (char-upcase char)\n       \
    \ (char-downcase char)))\n  (map flip-char string))\n", "  (string-map (\u03BB\
    \ (c) (cond\n                      [(char-lower-case? c) (char-upcase c)]\n  \
    \                    [(char-upper-case? c) (char-downcase c)]\n              \
    \        [else c]))\n              string))\n", "  (for/list ([c (in-string string)])\n\
    \    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c))))", "  (map (lambda (x) (if (char-alphabetic? x)\n                     \
    \  (char-downcase x)\n                       (char-upcase x)))\n       string))\n",
  "  (for/list ([i (in-list string)])\n    (cond ((char-alphabetic? i)\n         \
    \  (cond [(char-lower-case? i) (char-upcase i)]\n                 [(char-upper-case?\
    \ i) (char-downcase i)]))\n          (else i))))\n", "  (apply string-append\n\
    \         (map (lambda (c)\n                (if (char-alphabetic? c)\n       \
    \             (if (char-lower-case? c)\n                        (char-upcase c)\n\
    \                        (char-downcase c))\n                    c))\n       \
    \       string)))\n", "  (define (flip-char c)\n    (cond [(char-numeric? c) c]\n\
    \          [(char-alphabetic? c) (char-upcase c)]\n          [else (char-downcase\
    \ c)]))\n  (list->string (map flip-char (string->list string))))\n", "  (string-map\
    \ (lambda (char) (if (char-upper-case? char) (char-downcase char) (char-upcase\
    \ char))) string))\n", "  (string-upcase (string-downcase string)))\n", "  (string-map\
    \ (lambda (c)\n                (if (char-lower-case? c)\n                    (char-upcase\
    \ c)\n                    (char-downcase c)))\n              string))\n", "  (string-upper-case\
    \ (string-lower-case string)))\n</code>\nError:\n<code>flip_case.rkt:5:10: string-upper-case:\
    \ expects argument of type &lt;string&gt;; given #&lt;string-ci&gt;\n</code>\n\
    What does this error message mean?\n\n\nA:\n\n<code>string-lower-case</code> returns\
    \ a case-insensitive string.  So it's not a string, and can't be passed to <code>string-upper-case</code>.\n\
    You need to convert it back to a string with <code>string-ci-&gt;string</code>.\n\
    There's not enough context to say why <code>string-lower-case</code> is returning\
    \ case-insensitive strings instead of the normal strings.  However, if you're\
    \ working with strings in a case-insensitive manner, you may want to consider\
    \ working with case-insensitive strings throughout, in which case you would just\
    \ use <code>string-upcase</code> instead of <code>string-upper-case</code>.\n",
  "  (string-map #(\\string char-downcase (char-upcase char)) string))\n", "  (define\
    \ (helper string result)\n    (if (= 0 (string-length string))\n        result\n\
    \        (if (char-ci=? (string-ref string 0) (string-ref string 0))\n       \
    \     (helper (substring string 1) (string-append result (string-downcase (string-ref\
    \ string 0))))\n            (helper (substring string 1) (string-append result\
    \ (string-upcase (string-ref string 0)))))))\n  (helper string \"\"))\n", "  (string-translate\
    \ string #\\a #\\A)\n  (string-translate string #\\A #\\a))\n", "  (string-map\
    \ (lambda (x) (if (char-numeric? x) x (if (char-lower-case? x) (char-upcase x)\
    \ (char-downcase x)))) string))\n", "  (string-map (lambda (c) (if (char-ci&gt;=?\
    \ c #\\a) (char-upcase c) (char-downcase c))) string))\n", "  (let loop ([str\
    \ (string->list string)]\n             [result '()])\n    (cond [(empty? str)\
    \ (list->string (reverse result))]\n          [(char-lower-case? (car str))\n\
    \           (loop (cdr str) (cons (char-upcase (car str)) result))]\n        \
    \  [(char-upper-case? (car str))\n           (loop (cdr str) (cons (char-downcase\
    \ (car str)) result))]\n          [else (loop (cdr str) (cons (car str) result))])))\n",
  "  (map (lambda (char)\n\t (cond [(char-alphabetic? char)\n\t\t(cond [(char-lower-case?\
    \ char)\n\t\t       (char-upcase char)]\n\t\t      [(char-upper-case? char)\n\t\
    \t       (char-downcase char)])]\n\t       [else char]))\n       string))\n",
  "  (string-map\n   (lambda (c)\n     (cond\n       [(char-lower-case? c) (char-upcase\
    \ c)]\n       [(char-upper-case? c) (char-downcase c)]\n       [else c]))\n  \
    \ string))\n", "  (string-map (\u03BB (s) (if (char-upcase? s) (char-downcase\
    \ s) (char-upcase s))) string))\n", "  (for/list ([char (in-string string)])\n\
    \    (if (char-numeric? char)\n        char\n        (if (char-lower-case? char)\n\
    \            (char-upcase char)\n            (char-downcase char)))))\n", "  (string-join\n\
    \   (map (lambda (x)\n          (if (char-lower-case? x)\n              (char-upcase\
    \ x)\n              (char-downcase x)))\n        string)))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-alphabetic? char)\n         (if (char-lower-case?\
    \ char)\n             (char-upcase char)\n             (char-downcase char))\n\
    \         char))\n   string))\n", "  (string-map (curryr string-downcase string-upcase)\
    \ string))\n", "  (string-upcase (string-downcase string)))\n", "  (string-map\n\
    \   (lambda (char)\n     (if (char-upcase? char)\n         (char-downcase char)\n\
    \         (char-upcase char)))\n   string))\n", "  (let ([f (flipcase-proc)])\n\
    \    (for/list ([c (in-string string)])\n      (f c))))\n", "  (apply string-append\n\
    \         (map (lambda (char)\n                (if (char-alphabetic? char)\n \
    \                   (if (char-ci&lt;=? char #\\a)\n                        (char-upcase\
    \ char)\n                        (char-downcase char))\n                    char))\n\
    \              string)))\n", "  (string-map (lambda (char)\n                (if\
    \ (char-lower-case? char)\n                    (char-upcase char)\n          \
    \          (char-downcase char)))\n              string))\n", "  (string-map (lambda\
    \ (x)\n                (or (char-downcase x)\n                    (char-upcase\
    \ x)))\n              string))\n\n", "  (define new-string \"\")\n  (for ([char\
    \ (in-string string)])\n    (cond\n      [(char-lower-case? char) (string-append\
    \ new-string (string-upcase (string char)))]\n      [(char-upper-case? char) (string-append\
    \ new-string (string-downcase (string char)))]\n      [else (string-append new-string\
    \ (string char))]))\n  new-string)\n", "  (map (compose string-upcase string-downcase)\
    \ string))\n", "  (let ([str-vec (string->vector string)])\n    (vector-map\n\
    \     (lambda (x)\n       (if (char-alphabetic? x)\n           (if (char-lower-case?\
    \ x)\n               (char-upcase x)\n               (char-downcase x))\n    \
    \       x))\n     str-vec)))\n", "  (string-map\n   (\u03BB (c)\n     (cond\n\
    \       [(char-lower-case? c) (char-upcase c)]\n       [(char-upper-case? c) (char-downcase\
    \ c)]\n       [else c]))\n   string))\n", "  (string-map (lambda (c) (if (char-lower-case?\
    \ c) (char-upcase c) (char-downcase c))) string))\n", "  (string-append\n   (map\n\
    \    (lambda (ch)\n      (if (char-ci&gt;=? ch #\\a)\n          (char-upcase ch)\n\
    \          (char-downcase ch)))\n    string)))\n", "  (string-append \n   (string-map\n\
    \    (lambda (c)\n      (if (char-upcase? c)\n          (char-downcase c)\n  \
    \        (char-upcase c)))\n    string)))\n", "  (map\n   (lambda (char)\n   \
    \  (if (char-lower-case? char)\n         (char-upcase char)\n         (char-downcase\
    \ char)))\n   string))\n", "  (cond\n    [(empty? string) string]\n    [(char-alphabetic?\
    \ (first string))\n     (if (char-lower-case? (first string))\n         (cons\
    \ (char-upcase (first string)) (flip_case (rest string)))\n         (cons (char-downcase\
    \ (first string)) (flip_case (rest string))))]\n    [else (cons (first string)\
    \ (flip_case (rest string)))]))\n", "  (string-map char-upcase string))\n", " \
    \ (map char-upcase/downcase string))\n```\n\n```racket\n#lang racket\n", "  (string-map\n\
    \   (lambda (character)\n     (if (char-upcase? character)\n         (char-downcase\
    \ character)\n         (char-upcase character)))\n   string))\n", "  (build-string\
    \ (string-length string) (lambda (i)\n                                       \
    \  (if (or (char-alphabetic? (string-ref string i))\n                        \
    \                         (char-numeric? (string-ref string i)))\n           \
    \                                  (if (char-lower-case? (string-ref string i))\n\
    \                                                 (char-upcase (string-ref string\
    \ i))\n                                                 (char-downcase (string-ref\
    \ string i)))\n                                             (string-ref string\
    \ i)))))\n", "  (apply string-append (map (lambda (char)\n                   \
    \           (cond\n                                [(char-downcase? char) (char-upcase\
    \ char)]\n                                [(char-upcase? char) (char-downcase\
    \ char)]\n                                [else char]))\n                    \
    \        string)))\n", "  (build-string (string-length string)\n    (lambda (i)\n\
    \      (if (char-lower-case? (string-ref string i))\n          (char-upcase (string-ref\
    \ string i))\n          (char-downcase (string-ref string i))))))\n", "  (string-map\
    \ (\u03BB (c)\n                (if (char-lower-case? c)\n                    (char-upcase\
    \ c)\n                    (char-downcase c)))\n              string))\n", "  (string-map\
    \ (lambda (ch)\n                (cond [(char-lower-case? ch) (char-upcase ch)]\n\
    \                      [(char-upper-case? ch) (char-downcase ch)]\n          \
    \            [else (char-downcase ch)]))\n              string))\n", "  (string-map\
    \ (lambda (char)\n                (if (char-alphabetic? char)\n              \
    \      (if (char-lower-case? char)\n                        (char-upcase char)\n\
    \                        (char-downcase char))\n                    char))\n \
    \             string))\n", "  (string-join\n   (map (lambda (c)\n          (if\
    \ (char-downcase? c)\n              (char-upcase c)\n              (char-downcase\
    \ c)))\n        string)))\n", "  (string-map (\u03BB (c) (if (char-upcase? c)\
    \ (char-downcase c) (char-upcase c))) string))\n", "  (let loop ([string string]\n\
    \             [currpos 0]\n             [result '()])\n    (if (eq? currpos (string-length\
    \ string))\n        (list->string (reverse result))\n        (loop (string-drop\
    \ string (add1 currpos))\n              (add1 currpos)\n              (cons (if\
    \ (char-lower-case? (string-ref string currpos))\n                      (char-upcase\
    \ (string-ref string currpos))\n                      (char-downcase (string-ref\
    \ string currpos)))\n                    result)))))\n", "  (let ([len (string-length\
    \ string)])\n    (for/list ([i (in-range len)])\n      (let ([char (string-ref\
    \ string i)])\n        (cond\n          [(char-alphabetic? char)\n           (if\
    \ (char-lower-case? char)\n               (char-upcase char)\n               (char-downcase\
    \ char))]\n          [else char])))))\n", "  (apply string-append (map (lambda\
    \ (c) (if (char-upcase? c) (char-downcase c) (char-upcase c))) string)))\n", " \
    \ (map (lambda (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case?\
    \ c)\n                 (char-upcase c)\n                 (char-downcase c))\n\
    \             c))\n       string))\n", "  (string-join\n   (map\n    (\u03BB (s)\n\
    \      (cond\n        [(string-foldcase (string-downcase s)) (string-upcase s)]\n\
    \        [(string-foldcase (string-upcase s)) (string-downcase s)]\n        [else\
    \ s]))\n    (string-split string)) \"\"))\n", "  (string-join (map (\u03BB (c)\n\
    \                      (if (char-upper-case? c)\n                          (char-downcase\
    \ c)\n                          (char-upcase c)))\n                    (string->list\
    \ string))))\n", "  (string-map (lambda (c) (if (char-upcase? c) (char-downcase\
    \ c) (char-upcase c))) string))\n", '  (string-map char-upcase string))', "  (string-map\
    \ (lambda (c)\n                (if (char-upper-case? c)\n                    (char-downcase\
    \ c)\n                    (char-upcase c)))\n              string))\n", "  (string-map\n\
    \   (lambda (ch)\n     (if (char-ci&gt;=? ch #\\a)\n         (char-upcase ch)\n\
    \         (char-downcase ch)))\n   string))\n", "  (define (u_to_l char)\n   \
    \ (integer->char (- (char-&gt;integer char) 32)))\n  (define (l_to_u char)\n \
    \   (integer-&gt;char (+ (char-&gt;integer char) 32)))\n  (map (lambda (char)\n\
    \         (if (char-upcase? char)\n             (u_to_l char)\n             (l_to_u\
    \ char)))\n       string))\n", "  (string-map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (map (\u03BB (x) (if (char-alphabetic? x)\n                  (if (char-uppercase?\
    \ x)\n                      (char-downcase x)\n                      (char-upcase\
    \ x))\n                  x))\n       string))\n", "  (let loop ([i 0] [result\
    \ ''])\n    (if (= i (string-length string))\n        (list->string result)\n\
    \        (let ([c (string-ref string i)])\n          (loop (+ i 1)\n         \
    \       (append result\n                        (if (char-lower-case? c)\n   \
    \                         (string-upcase (string c))\n                       \
    \     (string-downcase (string c)))))))))\n```\n\n---\n\n## `insert_dashes`\n\n\
    ```racket\n#lang racket\n", "  (string-map (\u03BB (c) (if (char-ci&gt;=? c #\\\
    a) (char-upcase c) (char-downcase c))) string))\n</code>\n", "  (for/list ([ch\
    \ (in-string string)])\n    (cond\n      [(char-lower-case? ch) (char-upcase ch)]\n\
    \      [(char-upper-case? ch) (char-downcase ch)]\n      [else ch])))\n", "  (cond\
    \ [(string=? string \"\") \"\"]\n        [(char-lower-case? (string-ref string\
    \ 0)) (string-append (string-upper-case (string-ref string 0)) (flip_case (substring\
    \ string 1)))]\n        [(char-upper-case? (string-ref string 0)) (string-append\
    \ (string-lower-case (string-ref string 0)) (flip_case (substring string 1)))]\n\
    \        [else (string-append (string-ref string 0) (flip_case (substring string\
    \ 1)))]))\n", "  (for/list ([char (in-string string)])\n    (if (char-alphabetic?\
    \ char)\n        (if (char-lower-case? char)\n            (char-upcase char)\n\
    \            (char-downcase char))\n        char)))\n", "  (let loop ([i 0] [new-string\
    \ (make-string (string-length string))])\n    (if (= i (string-length string))\n\
    \        new-string\n        (let ([c (string-ref string i)])\n          (cond\
    \ [(char-upper-case? c)\n                 (string-set! new-string i (char-downcase\
    \ c))]\n                [(char-lower-case? c)\n                 (string-set! new-string\
    \ i (char-upcase c))])\n          (loop (+ i 1) new-string)))))", "  (string-upper-case\
    \ (string-lower-case string)))\n", "  (define (flip-char c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (string-&gt;list (string-map flip-char\
    \ string)))\n</code>\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-upcase?\
    \ c) (char-downcase c)]\n       [(char-downcase? c) (char-upcase c)]\n       [else\
    \ c]))\n   string))\n", "  (string-upcase (string-downcase string)))\n", "  (for/string\
    \ ([ch (in-string string)])\n    (cond\n      [(char-lower-case? ch) (char-upcase\
    \ ch)]\n      [(char-upper-case? ch) (char-downcase ch)]\n      [else ch])))\n",
  "  (string-flip-case string))\n", "  (flip_case' string))\n", "  (string-map\n \
    \  (lambda (char)\n     (cond\n       [(char-lower-case? char) (char-upcase char)]\n\
    \       [(char-upper-case? char) (char-downcase char)]\n       [else char]))\n\
    \   string))\n", "  (map (\u03BB (char)\n         (if (char-lower-case? char)\n\
    \             (char-upcase char)\n             (char-downcase char)))\n      \
    \ string))\n", "  (string-downcase string))\n", "  (string-map (lambda (char)\n\
    \                (cond ((char-lower-case? char) (char-upcase char))\n        \
    \              ((char-upper-case? char) (char-downcase char))\n              \
    \        (else char)))\n              string))\n", "  (string-map\n   (\u03BB\
    \ (c)\n     (if (char-lower-case? c)\n         (char-upcase c)\n         (char-downcase\
    \ c)))\n   string))\n\n", "  (define (flip_case-iter flipped-string s)\n    (cond\
    \ ((null? s) flipped-string)\n          ((char-lower-case? (car s))\n        \
    \   (flip_case-iter (string-append flipped-string (string-upcase (car s))) (cdr\
    \ s)))\n          ((char-upper-case? (car s))\n           (flip_case-iter (string-append\
    \ flipped-string (string-downcase (car s))) (cdr s)))\n          (else (flip_case-iter\
    \ (string-append flipped-string (car s)) (cdr s)))))\n  (flip_case-iter \"\" string))\n",
  "  (let loop ([string string]\n             [output '()])\n    (if (empty? string)\n\
    \        (reverse output)\n        (let ([first (first string)])\n          (if\
    \ (char-alphabetic? first)\n              (if (char-upper-case? first)\n     \
    \             (loop (rest string) (cons (char-downcase first) output))\n     \
    \             (loop (rest string) (cons (char-upcase first) output)))\n      \
    \        (loop (rest string) (cons first output)))))))\n", "  (string-fold (\u03BB\
    \ (char case)\n                 (cond ((eq? case 'up) (string-downcase char))\n\
    \                       ((eq? case 'down) (string-upcase char))\n            \
    \           (else char)))\n               \"\"\n               string\n      \
    \         'up))\n", "  (map\n   (lambda (ch)\n     (cond ((char-lower-case? ch)\
    \ (char-upcase ch))\n           ((char-upper-case? ch) (char-downcase ch))\n \
    \          (else ch)))\n   string))\n</code>\n", "  (string-map (compose symbol->string\
    \ string-downcase) string))\n", "  (string-&gt;list string))\n", "  (regexp-replace*\
    \ #rx\"[a-z]\" (lambda (match) (string-upcase match)) string))\n", "  (if (eq?\
    \ (string-length string) 0)\n      \"\"\n      (string-append (if (char-lower-case?\
    \ (string-ref string 0))\n                        (string-upcase (string-ref string\
    \ 0))\n                        (string-downcase (string-ref string 0)))\n    \
    \                 (flip_case (substring string 1 (string-length string))))))",
  "  (for/list ([ch (in-string string)])\n    (if (char-upper-case? ch)\n        (char-downcase\
    \ ch)\n        (char-upcase ch))))\n", "  (map string (lambda (char)\n       \
    \         (if (char-lower-case? char)\n                    (char-upcase char)\n\
    \                    (char-downcase char)))))\n", "  (string-map\n   (\u03BB (ch)\n\
    \     (if (char-lower-case? ch)\n         (char-upcase ch)\n         (char-downcase\
    \ ch)))\n   string))\n", "  (string-join\n   (map\n    (lambda (char)\n      (cond\n\
    \        [(char-lower-case? char) (char-upcase char)]\n        [(char-upper-case?\
    \ char) (char-downcase char)]\n        [else char]))\n    (string->list string))))\n",
  "  (apply string-append (map (lambda (character)\n                             \
    \ (cond\n                                [(char-downcase? character) (char-upcase\
    \ character)]\n                                [(char-upcase? character) (char-downcase\
    \ character)]\n                                [else character]))\n          \
    \                  (string->list string))))\n", "  (string-append (map (lambda\
    \ (char)\n                        (if (char-lower-case? char)\n              \
    \              (char-upcase char)\n                            (char-downcase\
    \ char)))\n                      string)))\n", "  (string-map\n   (lambda (char)\n\
    \     (cond\n       ((char-lower-case? char) (char-upcase char))\n       ((char-upper-case?\
    \ char) (char-downcase char))\n       (else char)))\n   string))\n", "  (string-map\
    \ (lambda (x)\n                (if (char-numeric? x)\n                    x\n\
    \                    (if (char-upcase? x)\n                        (char-downcase\
    \ x)\n                        (char-upcase x))))\n              string))\n```\n\
    \n```\n#lang racket\n", "  (map char-upcase (regexp-replace* #rx\".\" string (\u03BB\
    \ (str) (if (char-lower-case? (string-ref str 0)) (char-upcase (string-ref str\
    \ 0)) (char-downcase (string-ref str 0)))))))\n```\n\n```racket\n#lang racket\n",
  "  (string-join\n   (map\n    (\u03BB (char)\n      (cond\n        [(char-lower-case?\
    \ char) (char-upcase char)]\n        [(char-upper-case? char) (char-downcase char)]\n\
    \        [else (error 'flip_case \"Unexpected character: \" char)]))\n    (string->list\
    \ string))))\n", "  (string-map (lambda (c) (if (char-lower-case? c) (char-upcase\
    \ c) (char-downcase c))) string))\n", "  (define char-in-range (lambda (char start\
    \ end)\n                          (and (&gt;= char start)\n                  \
    \             (&lt;= char end))))\n  (define (flip-char char)\n    (cond ((char-in-range\
    \ char #\\a #\\z) (- char #\\a #\\A))\n          ((char-in-range char #\\A #\\\
    Z) (+ char #\\a #\\A))\n          (else char)))\n  (string-&gt;list (apply string\
    \ (map flip-char (string-&gt;list string)))))\n</code>\nI did try using <code>char-upcase</code>\
    \ and <code>char-downcase</code> (is this not correct?):\n<code>#lang racket\n",
  "  (string-upcase (string-downcase string)))\n", "  (string-map\n   (lambda (c)\n\
    \     (cond\n       [(char-lower-case? c) (char-upcase c)]\n       [(char-upper-case?\
    \ c) (char-downcase c)]\n       [else c]))\n   string))\n", "  (for/list ([ch\
    \ (in-string string)])\n    (if (char-alphabetic? ch)\n        (if (char-uppercase?\
    \ ch)\n            (char-downcase ch)\n            (char-upcase ch))\n       \
    \ ch)))\n", "  (string-map (lambda (ch) (if (char-lower-case? ch) (char-upcase\
    \ ch) (char-downcase ch))) string))\n", "  (map (curry string-upcase string-downcase)\
    \ string))\n", "  (for/list ([c (in-string string)])\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c))))\n", "  (let ([new-string\
    \ \"\"])\n    (for ([char (in-string string)])\n      (cond\n        [(char-upcase?\
    \ char) (string-append new-string (string-downcase char))]\n        [(char-lowercase?\
    \ char) (string-append new-string (string-upcase char))]\n        [else (string-append\
    \ new-string char)]))\n    new-string))\n", "  (for/string ([c (in-string string)])\n\
    \    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c))))\n", "  (regexp-replace* #rx\"[a-z]\" string (\u03BB (x) (string-upcase\
    \ x))))\n", "  (string-map #(if (char-lower-case? %) (char-upcase %) (char-downcase\
    \ %)) string))\n", "  (string-map (\u03BB (char)\n                (cond\n    \
    \              [(char-lower-case? char) (char-upcase char)]\n                \
    \  [(char-upper-case? char) (char-downcase char)]\n                  [else char]))\n\
    \              string))\n", "  (define (flip-char ch)\n    (if (char-lower-case?\
    \ ch)\n        (char-upcase ch)\n        (char-downcase ch)))\n  (define (flip-chars\
    \ str)\n    (if (empty? str)\n        \"\"\n        (string-append (flip-char\
    \ (first str)) (flip-chars (rest str)))))\n  (flip-chars string))\n", "  (regexp-replace*\
    \ #rx\"[a-z]\" string\n                   (lambda (m) (string-upcase (string-downcase\
    \ (car m))))))\n", "  (string-map #(if (char-lower-case? %) (char-upcase %) (char-downcase\
    \ %)) string))\n", "  (regexp-replace* #rx\"[a-z]\" string (\u03BB (s) (string-upcase\
    \ s))))\n", "  (define (swap-char c)\n    (if (char-upcase? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (string-map swap-char string))\n", "  (apply\
    \ string-append (map (lambda (char)\n                              (cond ((char-alphabetic?\
    \ char)\n                                     (if (char-ci&gt;=? char #\\a)\n\
    \                                         (char-downcase char)\n             \
    \                            (char-upcase char)))\n                          \
    \          (else char)))\n                            string)))\n", "  (cond [(empty?\
    \ string) '()]\n        [else (cons (if (char-lower-case? (first string))\n  \
    \                      (char-upcase (first string))\n                        (char-downcase\
    \ (first string)))\n                    (flip_case (rest string)))]))\n", "  (string-fold\
    \ (\u03BB (char acc) (string-append acc (if (char-lower-case? char) (char-upcase\
    \ char) (char-downcase char)))) \"\" string))\n", "  (string-upcase (string-downcase\
    \ string)))\n```\n\n<br />\n\n###### `middle_chars`\n\n###### `#lang racket`\n\
    \n```racket\n#lang racket\n", "  (map (lambda (x) (if (char-upper-case? x) (char-downcase\
    \ x) (char-upcase x))) string))\n", "  (string-map (lambda (c) (if (char-alphabetic?\
    \ c)\n                              (if (char-lower-case? c)\n               \
    \                   (char-upcase c)\n                                  (char-downcase\
    \ c))\n                              c))\n              string))\n</code>\n",
  "  (for/string ([x (in-string string)])\n    (match (char-upcase x)\n      [(char-upcase\
    \ x) (char-downcase x)]\n      [(char-downcase x) (char-upcase x)])))\n", "  (string-map\n\
    \   (lambda (char)\n     (cond ((char-lower-case? char) (char-upcase char))\n\
    \           ((char-upper-case? char) (char-downcase char))\n           (else char)))\n\
    \   string))\n", "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda\
    \ (match)\n                     (string-upcase (string-downcase match)))))\n",
  "  (string-map\n   (lambda (x)\n     (if (char-lower-case? x)\n         (char-upcase\
    \ x)\n         (char-downcase x)))\n   string))\n", "  (regexp-replace* #rx\"\
    [a-z]\" string\n                   (lambda (match)\n                     (string-upcase\
    \ (regexp-match-substring match 0)))))", "  (string-map (lambda (char)\n     \
    \           (if (char-lower-case? char)\n                    (char-upcase char)\n\
    \                    (char-downcase char)))\n              string))\n", "  (if\
    \ (empty? string)\n      empty\n      (string-append (if (char-lower-case? (first\
    \ string))\n                        (string-upcase (string (first string)))\n\
    \                        (string-downcase (string (first string))))\n        \
    \            (flip_case (rest string)))))\n```\n\n### Test Cases\n\n```racket\n\
    #lang racket\n", "  (for/list ([c (in-string string)])\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c))))\n", "  (cond [(string-empty?\
    \ string) string]\n        [else (let ([char (string-ref string 0)])\n       \
    \          (string (if (char-alphabetic? char)\n                             (char-flip-case\
    \ char)\n                             char)\n                         (flip_case\
    \ (string-drop string 1))))]))\n", "  (define (flip-case-helper string new-string)\n\
    \    (if (empty? string)\n        new-string\n        (begin\n          (if (or\
    \ (char-alphabetic? (first string)) (char-numeric? (first string)))\n        \
    \      (if (char-upper-case? (first string))\n                  (flip-case-helper\
    \ (rest string) (string-append new-string (string-append (string-downcase (first\
    \ string)) \"\")))\n                  (flip-case-helper (rest string) (string-append\
    \ new-string (string-append (string-upcase (first string)) \"\"))))\n        \
    \      (flip-case-helper (rest string) (string-append new-string (string-append\
    \ (first string) \"\")))))))\n  (flip-case-helper string \"\"))\n", "  (string-upcase\
    \ (string-downcase string)))\n", "  (define (is_lower char)\n    (and (<= #\\\
    a char) (<= char #\\z)))\n  (define (flip_case char)\n    (cond ((is_lower char)\
    \ (- char #\\a #\\A))\n          (((is_lower (- char #\\a #\\A)) #t) (+ char #\\\
    a #\\A))\n          (else char)))\n  (apply string-append (map flip_case (string->list\
    \ string))))\n", "  (string-map (\u03BB (x)\n                (if (char-ci&gt;=?\
    \ x #\\a)\n                    (char-upcase x)\n                    (char-downcase\
    \ x)))\n              string))\n</code>\nCan anyone tell me how I can use <code>characterp</code>\
    \ to replace <code>char-ci&gt;=?</code> ?\n", "  (string-map\n   (lambda (c)\n\
    \     (if (char-upcase? c)\n         (char-downcase c)\n         (char-upcase\
    \ c)))\n   string))\n", "  (map\n   (lambda (char)\n     (if (char-lower-case?\
    \ char)\n         (char-upcase char)\n         (char-downcase char)))\n   string))\n",
  "  (string-map (lambda (c) (if (char-lower-case? c) (char-upcase c) (char-downcase\
    \ c))) string))\n", "  (string-map (lambda (char)\n                (if (char-lower-case?\
    \ char)\n                    (char-upcase char)\n                    (char-downcase\
    \ char)))\n              string))\n", "  (apply string-append (map (lambda (character)\n\
    \                              (if (char-lower-case? character)\n            \
    \                      (char-upcase character)\n                             \
    \     (char-downcase character)))\n                            string)))\n", " \
    \ (string-map\n   (lambda (ch)\n     (if (char-alphabetic? ch)\n         (if (char-lower-case?\
    \ ch)\n             (char-upcase ch)\n             (char-downcase ch))\n     \
    \    ch))\n   string))\n\n\n", "  (string-upcase (string-downcase string)))\n\
    ```\n\n```racket\n#lang racket\n", "  (string-translate string \n            \
    \        (string-&gt;list \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n                  \
    \  (string-&gt;list \"abcdefghijklmnopqrstuvwxyz\")))\n", "  (regexp-replace*\
    \ #rx\"[a-z]\" (lambda (match) (string-upcase match)) string))\n", "  (for/list\
    \ ([char (in-string string)])\n    (if (char-lower-case? char)\n        (char-upcase\
    \ char)\n        (char-downcase char))))\n", "  (let loop ([index 0] [result '()])\n\
    \    (if (equal? index (string-length string))\n        (list->string (reverse\
    \ result))\n        (if (char-lower-case? (string-ref string index))\n       \
    \     (loop (+ index 1) (cons (char-upcase (string-ref string index)) result))\n\
    \            (loop (+ index 1) (cons (char-lower-case (string-ref string index))\
    \ result))))))\n", "  (map char-upcase? string))\n", "  (string-map (\u03BB (c)\
    \ (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n", " \
    \ (string-map\n   (lambda (c)\n     (cond\n       [(char-lower-case? c) (char-upcase\
    \ c)]\n       [(char-upper-case? c) (char-downcase c)]\n       [else c]))\n  \
    \ string))\n```\n\n- **Challenge 5**: Count the number of lowercase, uppercase,\
    \ and other characters in a string.\n\n```#lang racket\n", "  (string-map (lambda\
    \ (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c))) string))\n",
  "  (regexp-replace* #rx\"[a-z]\" string\n                   (lambda (s) (string-upcase\
    \ s))\n                   #:replace-global? #t))\n", "  (for/list ([c (in-string\
    \ string)])\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [else\
    \ c])))\n```\n\n```\n>>> (flip_case \"Hello\")\n'hELLO'\n```\n\n### is_palindrome\n\
    ```racket\n#lang racket\n", "  (define length (string-length string))\n  (define\
    \ output (make-string length))\n  (for ([i (in-range length)])\n    (if (char-lower-case?\
    \ (string-ref string i))\n        (string-set! output i (char-upcase (string-ref\
    \ string i)))\n        (string-set! output i (char-downcase (string-ref string\
    \ i)))))\n  output)\n", "  (let ([result (string-map (lambda (x)\n           \
    \                   (if (char-lower-case? x)\n                               \
    \   (char-upcase x)\n                                  (char-downcase x)))\n \
    \                           string)])\n    result))\n", "  (string-join (map (lambda\
    \ (char)\n                      (if (char-upper-case? char)\n                \
    \          (char-downcase char)\n                          (char-upcase char)))\
    \ string)))\n", "  (string-map (lambda (c)\n                (if (char-lower-case?\
    \ c)\n                    (char-upcase c)\n                    (char-downcase\
    \ c)))\n              string))\n```\n\n```#lang racket\n", "  (apply string-append\
    \ (map (lambda (c)\n                              (cond\n                    \
    \            [(char-downcase? c) (char-upcase c)]\n                          \
    \      [(char-upcase? c) (char-downcase c)]\n                                [else\
    \ c]))\n                            (string->list string))))\n", "  (string-append\
    \ (map (\u03BB (c) (if (char-lower-case? c) (char-upcase c) (char-downcase c)))\
    \ string)))\n```\n\n## Environment Setup\n\nSee [here](../../README.md) for instructions\
    \ on how to setup an Racket environment on your local machine.\n\n## Run Tests\n\
    \n```\nraco test flip-case.rkt\n```", "  (let ((result (string-new (string-length\
    \ string))))\n    (for ([i (in-range (string-length string))])\n      (string-set!\
    \ result i\n                   (if (char-alphabetic? (string-ref string i))\n\
    \                       (if (char-upper-case? (string-ref string i))\n       \
    \                    (char-downcase (string-ref string i))\n                 \
    \          (char-upcase (string-ref string i)))\n                       (string-ref\
    \ string i))))\n    result))\n", "  (for/list ([c (in-string string)])\n    (if\
    \ (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c))))\n",
  "  (string-upcase (string-downcase string)))\n", "  (map\n   (lambda (character)\n\
    \     (if (char-lower-case? character)\n         (char-upcase character)\n   \
    \      (char-downcase character)))\n   string))\n</code>\n", "  (string-map\n\
    \   (lambda (c)\n     (if (or (= c #\\A) (= c #\\a))\n         (if (char-ci=?\
    \ c #\\A) #\\a #\\A)\n         c))\n   string))\n", "  (string-map (\u03BB (ch)\n\
    \                (if (char-lower-case? ch)\n                    (char-upcase ch)\n\
    \                    (char-downcase ch)))\n              string))\n", "  (string-map\
    \ (lambda (c)\n                (if (char-lower-case? c)\n                    (char-upcase\
    \ c)\n                    (char-downcase c)))\n              string))\n", "  (string-map\
    \ (lambda (char)\n                (if (char-lower-case? char)\n              \
    \      (char-upcase char)\n                    (char-downcase char)))\n      \
    \        string))\n", "  (string-map (lambda (x)\n                (cond [(char-lower-case?\
    \ x) (char-upcase x)]\n                      [(char-upper-case? x) (char-downcase\
    \ x)]\n                      [else x]))\n              string))\n", "  (let loop\
    \ ([lst (string->list string)]\n             [flipped (list)])\n    (if (null?\
    \ lst)\n        (list->string flipped)\n        (loop (cdr lst)\n            \
    \  (cons (if (char-upcase? (car lst))\n                        (char-downcase\
    \ (car lst))\n                        (char-upcase (car lst)))\n             \
    \       flipped)))))\n```\n\n```racket\n#lang racket\n", "  (define (flip char)\n\
    \    (if (char-numeric? char)\n        char\n        (if (char-alphabetic? char)\n\
    \            (if (char-lower-case? char)\n                (char-upcase char)\n\
    \                (char-downcase char))\n            char)))\n  (string-&gt;list\
    \ string))\n", "  (let* ([choices '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\\
    i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\\
    y #\\z)]\n         [map-table (make-hash)])\n    (for ([i choices])\n      (hash-set!\
    \ map-table i (char-upcase i))\n      (hash-set! map-table (char-upcase i) i))\n\
    \    (string-map\n     (lambda (c)\n       (hash-ref map-table c #f))\n     string)))\n",
  "  (string-upcase string))\n", "  (string-upcase (string-downcase string)))\n",
  "  (map symbol->string\n       (map char-upcase/downcase\n            (string->list\
    \ string))))\n", "  (list->string (map (\u03BB (c)\n                       (if\
    \ (char-lower-case? c)\n                           (char-upcase c)\n         \
    \                  (char-downcase c)))\n                     (string->list string))))\n",
  "  (string-map char-upcase/downcase string))\n", "  (apply string-append (map (lambda\
    \ (char) (if (char-lower-case? char) (char-upcase char) (char-downcase char)))\
    \ string)))\n", "  (for/list ([x (in-string string)])\n    (if (char-alphabetic?\
    \ x)\n        (if (char-lower-case? x)\n            (char-upcase x)\n        \
    \    (char-downcase x))\n        x)))\n```\n\n```racket\n#lang racket\n", "  (string-upcase/ci\
    \ string))\n", "  (let ([s (string->list string)])\n    (map (\u03BB (x) (if (char-numeric?\
    \ x) x\n                   (if (char-numeric? (char-downcase x))\n           \
    \            (char-upcase x)\n                       (char-downcase x))))\n  \
    \       s)))\n", "  (if (= (string-length string) 0)\n      \"\"\n      (begin\
    \ (if (char-alphabetic? (string-ref string 0))\n               (if (char-lower-case?\
    \ (string-ref string 0))\n                   (make-string 1 (char-upcase (string-ref\
    \ string 0)))\n                   (make-string 1 (char-downcase (string-ref string\
    \ 0))))\n               (string-ref string 0))\n             (flip_case (substring\
    \ string 1)))))\n", "  (string-map\n   (lambda (c)\n     (if (char-lower-case?\
    \ c)\n         (char-upcase c)\n         (char-downcase c)))\n   string))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
