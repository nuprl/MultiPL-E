name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n;; >>> circular_shift(12, 1)\n;; \"21\"\n\
  ;; >>> circular_shift(12, 2)\n;; \"12\"\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (define (rotate digits)\n    (define (helper lst)\n      (cond ((null?\
    \ lst) null)\n            ((= (length lst) 1) lst)\n            (else (cons (last\
    \ lst) (helper (butlast lst))))))\n    (let ([lst (string->list digits)])\n  \
    \    (string-join (reverse (helper lst)))))\n  (define (reverse digits)\n    (string-join\
    \ (reverse (string->list digits))))\n  (define (shift digits)\n    (cond ((<=\
    \ (length digits) shift) (reverse digits))\n          (else (string-append (substring\
    \ digits shift)\n                               (substring digits 0 shift)))))\n\
    \  (shift (rotate (number->string x))))\n", "  (define (circ_shift_help x shift\
    \ result)\n    (cond\n      ((= shift 0) result)\n      ((= x 0) (circ_shift_help\
    \ (quotient x 10) (- shift 1) (string-append (list (modulo x 10)) result)))\n\
    \      (else (circ_shift_help (quotient x 10) (- shift 1) (string-append (list\
    \ (modulo x 10)) result)))))\n  (circ_shift_help x shift \"\"))\n", "  (define\
    \ (helper acc x shift)\n    (if (= 0 x)\n        (number->string acc)\n      \
    \  (helper\n         (+ (* acc 10) (modulo (quotient x (expt 10 shift)) 10))\n\
    \         (quotient x 10)\n         shift)))\n  (helper 0 x shift))\n", "  (define\
    \ s (number->string x))\n  (if (> shift (string-length s))\n      (string-reverse\
    \ s)\n      (string-append (substring s shift) (substring s 0 shift))))\n", " \
    \ (cond\n    [(< shift 1) (string->number (string-reverse (number->string x)))]\n\
    \    [else (string->number (string-append (substring (number->string x) shift)\n\
    \                                         (substring (number->string x) 0 shift)))]))\n",
  "  (define digits\n    (number->string x))\n  (define digits-length\n    (string-length\
    \ digits))\n  (if (> shift digits-length)\n      (string-reverse digits)\n   \
    \   (string-append (substring digits shift)\n                     (substring digits\
    \ 0 shift))))\n", "  (define n (number->string x))\n  (define m (string-length\
    \ n))\n  (string-append (substring n shift m) (substring n 0 shift)))\n", "  (let\
    \ ((shift-count (modulo shift (number->string x))))\n    (if (> shift-count 0)\n\
    \        (circular_shift (string->number (string-append (substring (number->string\
    \ x) shift-count) (substring (number->string x) 0 shift-count))) shift)\n    \
    \    (number->string x))))\n", "  (define (circular_shift_helper lst)\n    (if\
    \ (empty? lst)\n        \"\"\n        (string-append (circular_shift_helper (cdr\
    \ lst)) (string (car lst)))))\n  (define (reverse_helper lst)\n    (if (empty?\
    \ lst)\n        \"\"\n        (string-append (string (car lst)) (reverse_helper\
    \ (cdr lst)))))\n  (if (> shift (number->string x (length (number->string x))))\n\
    \      (reverse_helper (string->list (number->string x)))\n      (circular_shift_helper\
    \ (string->list (number->string x)))))\n\n", "  (define (helper num shift digs)\n\
    \    (if (zero? shift)\n        digs\n        (if (zero? num)\n            (helper\
    \ x shift (string-append (number->string (remainder num 10)) digs))\n        \
    \    (helper (quotient num 10) (sub1 shift) (string-append (number->string (remainder\
    \ num 10)) digs)))))\n  (helper x shift \"\"))\n", "  (let* ([d-str (number->string\
    \ x)]\n         [d-str-l (string-length d-str)]\n         [s-str (number->string\
    \ shift)]\n         [s-str-l (string-length s-str)]\n         [f-str (string-append\
    \ (substring d-str s-str-l d-str-l)\n                               (substring\
    \ d-str 0 s-str-l))])\n    (if (<= d-str-l s-str-l)\n        (reverse f-str)\n\
    \        f-str)))\n", "  (define (helper x shift acc)\n    (if (zero? x) acc\n\
    \        (if (= shift 0)\n            (helper (truncate (/ x 10)) 1 (cons (modulo\
    \ x 10) acc))\n            (helper (truncate (/ x 10)) (- shift 1) (cons (modulo\
    \ x 10) acc)))))\n  (integer->string (apply (lambda (digits . more) (apply string->number\
    \ digits))\n                          (reverse (helper x shift '())))))\n", " \
    \ (define len (number->string x length))\n  (cond [(> shift len) (reverse (number->string\
    \ x))]\n        [else (reverse (number->string x))]))\n", "  (define (reverse-digits\
    \ n)\n    (local ((define (helper n result)\n              (if (zero? n)\n   \
    \               result\n                  (helper (quotient n 10)\n          \
    \                (string-append (integer->string (remainder n 10))\n         \
    \                                result)))))\n      (helper n \"\")))\n  (define\
    \ (length n)\n    (local ((define (helper n len)\n              (if (zero? n)\n\
    \                  len\n                  (helper (quotient n 10) (+ len 1)))))\n\
    \      (helper n 0)))\n  (define (shift-digits n shift)\n    (let ((length (length\
    \ n)))\n      (string-append (substring (reverse-digits n)\n                 \
    \               (- length shift)\n                                length)\n  \
    \                   (substring (reverse-digits n)\n                          \
    \      0\n                                (- length shift)))))\n  (if (< shift\
    \ (length x))\n      (shift-digits x shift)\n      (reverse-digits x)))\n", " \
    \ (cond\n    ((> shift (string-length (number->string x)))\n     (string-reverse\
    \ (number->string x)))\n    (else\n     (string-append (substring (number->string\
    \ x) shift)\n                    (substring (number->string x) 0 shift)))))\n",
  "  (define (digits x)\n    (if (zero? x)\n        (list)\n        (cons (remainder\
    \ x 10) (digits (quotient x 10)))))\n  (define (reversed-digits x)\n    (if (null?\
    \ x)\n        (list)\n        (append (reversed-digits (cdr x)) (list (car x)))))\n\
    \  (define (to-string ds)\n    (if (null? ds)\n        (string)\n        (string-append\
    \ (to-string (cdr ds)) (string (car ds)))))\n  (define (shifted-digits x)\n  \
    \  (if (> shift (length x))\n        (reversed-digits x)\n        (append (cdr\
    \ x) (list (car x)))))\n  (to-string (shifted-digits (digits x))))\n", "  (define\
    \ x-string (number->string x))\n  (cond ((<= shift (string-length x-string))\n\
    \         (string-append (substring x-string shift)\n                        (substring\
    \ x-string 0 shift)))\n        (else (string-reverse x-string))))\n", "  (number->string\
    \ (number->string x) shift))\n", "  (let ((s (number->string x)))\n    (if (&gt;\
    \ shift (string-length s))\n        (string-reverse s)\n        (string-append\
    \ (substring s (- shift))\n                       (substring s 0 (- shift))))))\n",
  "  (number->string\n   (string->number\n    (string-concatenate\n     (list\n  \
    \    (string-right (number->string x)\n                    (remainder shift (string-length\
    \ (number->string x))))\n      (string-left (number->string x)\n             \
    \      (remainder shift (string-length (number->string x)))))))))\n", "  (define\
    \ (shift-right x)\n    (string-append (substring x 1 (string-length x)) (substring\
    \ x 0 1)))\n  (define (shift-left x)\n    (string-append (substring x (subtract\
    \ (string-length x) 1) (string-length x))\n                   (substring x 0 (subtract\
    \ (string-length x) 1))))\n  (define (shift-right-left x shift)\n    (cond ((zero?\
    \ shift) x)\n          ((< shift 0) (shift-right-left (shift-left x) (add shift\
    \ 1)))\n          ((> shift 0) (shift-right-left (shift-right x) (subtract shift\
    \ 1)))))\n  (shift-right-left (number->string x) shift))\n", "  (define (circular_shift_r\
    \ x shift digits)\n    (cond\n      [(zero? shift)\n       (number->string digits)]\n\
    \      [(< shift (exact-floor (log10 digits)))\n       (circular_shift_r (quotient\
    \ digits 10)\n                         (- shift 1)\n                         (+\
    \ (* (remainder digits 10)\n                               (expt 10 shift))\n\
    \                            x))]\n      [else\n       (number->string (reverse-digits\
    \ digits))]))\n  (circular_shift_r x shift x))\n", "  (apply string\n    (if (<=\
    \ shift (string-length (number->string x)))\n      (reverse (string-&gt;list (string-append\
    \ (substring (number->string x) shift)\n                                     \
    \        (substring (number->string x) 0 shift))))\n      (reverse (string-&gt;list\
    \ (number->string x))))))\n", "  (if (zero? shift)\n      (number->string x)\n\
    \      (let* ([digits_str (number->string x)]\n             [digits_str_len (string-length\
    \ digits_str)]\n             [digits_str_shift (modulo shift digits_str_len)])\n\
    \        (if (= digits_str_shift 0)\n            digits_str\n            (string-append\
    \ (substring digits_str digits_str_shift)\n                           (substring\
    \ digits_str 0 digits_str_shift))))))\n", "  (number->string (number->list x shift)\n\
    \                  (if (> shift (length (number->string x)))\n               \
    \       #t\n                      #f)))", "  (define d (length (string->list (number->string\
    \ x))))\n  (cond ((> shift d) (reverse-list (string->list (number->string x))))\n\
    \        (else (append (substring (number->string x) shift)\n                \
    \      (substring (number->string x) 0 shift)))))\n", "  (displayln x)\n  (displayln\
    \ shift)\n  (displayln (number->string x))\n  (displayln (number->string shift))\n\
    \  (displayln (string-length (number->string x)))\n  (displayln (string-length\
    \ (number->string shift)))\n  (if (string-length (number->string x)) < (string-length\
    \ (number->string shift))\n      (reverse (number->string x))\n      (string-append\
    \ (substring (number->string x) 0 (- (string-length (number->string x)) shift))\n\
    \                     (substring (number->string x) (- (string-length (number->string\
    \ x)) shift) (string-length (number->string x))))))\n  ", "  (define (split-digits\
    \ n)\n    (let loop ([n n] [digits '()])\n      (cond [(zero? n) (reverse digits)]\n\
    \            [else (loop (quotient n 10) (cons (remainder n 10) digits))])))\n\
    \  (define (join-digits digits)\n    (let loop ([digits digits] [n 0])\n     \
    \ (cond [(empty? digits) n]\n            [else (loop (rest digits) (+ (* n 10)\
    \ (first digits)))])))\n  (define (split-and-rotate n)\n    (let ([digits (split-digits\
    \ n)])\n      (append (drop shift digits) (take shift digits))))\n  (number->string\
    \ (join-digits (split-and-rotate x))))\n", "  (number->string (reverse-number\
    \ x)))\n", "  (define (rotate xs k)\n    (if (= k 0)\n        xs\n        (rotate\
    \ (append (rest xs) (list (first xs))) (- k 1))))\n  (define (reversed-digits\
    \ x)\n    (if (&lt; x 10)\n        (list x)\n        (append (reversed-digits\
    \ (/ x 10)) (list (modulo x 10)))))\n  (define xs (reversed-digits x))\n  (define\
    \ xs_rotated (rotate xs shift))\n  (define xs_digit (list-&gt;string xs_rotated))\n\
    \  (define xs_number (string-&gt;number xs_digit))\n  (number-&gt;string xs_number))\n",
  "  (if (> shift (number->string x))\n      (string-reverse (number->string x))\n\
    \      (let ((digits (number->string x)))\n        (string-append (substring digits\
    \ shift (string-length digits))\n                       (substring digits 0 shift)))))\n",
  "  (define digit-count\n    (let loop ([n x] [count 0])\n      (if (= n 0)\n   \
    \       count\n          (loop (quotient n 10) (+ count 1)))))\n  (define (rotate\
    \ x)\n    (define (rotate-iter new-x old-x)\n      (if (= old-x 0)\n         \
    \ new-x\n          (rotate-iter (+ (* new-x 10) (remainder old-x 10))\n      \
    \                  (quotient old-x 10))))\n    (rotate-iter 0 x))\n  (define (reverse\
    \ x)\n    (define (reverse-iter new-x old-x)\n      (if (= old-x 0)\n        \
    \  new-x\n          (reverse-iter (+ (* new-x 10) (remainder old-x 10))\n    \
    \                    (quotient old-x 10))))\n    (reverse-iter 0 x))\n  (if (>\
    \ shift digit-count)\n      (number->string (reverse x))\n      (number->string\
    \ (rotate (quotient x (expt 10 shift))))))\n", "  (if (equal? (remainder shift\
    \ (number->string x) 1)\n              (number->string x))\n      (number->string\
    \ x)\n      (string-append (string-drop (number->string x) shift)\n          \
    \           (string-take (number->string x) shift))))\n", "  (define (helper x\
    \ res i d)\n    (cond ((&gt; d 0) (helper (/ x 10) (string-append (string (+ (*\
    \ d res) (% x d))) res) (+ i 1) (* d 10)))\n          ((= i shift) res)\n    \
    \      (else (reverse res))))\n  (helper x 0 0 1))\n", "  (cond\n    [(< shift\
    \ 0) (circular_shift x (+ shift (string-length (number->string x))))]\n    [(>\
    \ shift (string-length (number->string x))) (string-reverse (number->string x))]\n\
    \    [else (string-append (substring (number->string x) shift) (substring (number->string\
    \ x) 0 shift))]))\n", "  (number->string (circular_shift_int x shift)))\n", " \
    \ (let ([x (number->string x)])\n    (if (> shift (string-length x))\n       \
    \ (string-reverse x)\n        (string-append (substring x shift) (substring x\
    \ 0 shift)))))\n", "  (integer->string (reverse (cdr (reverse (append (integer->list\
    \ x) (make-list shift 0)))))))\n", "  (define digit-shift\n    (lambda (x)\n \
    \     (if (zero? x) '()\n          (cons (% x 10) (digit-shift (quotient x 10))))))\n\
    \  (define digit-to-string\n    (lambda (x)\n      (if (empty? x) \"\"\n     \
    \     (string-append (number->string (car x)) (digit-to-string (cdr x))))))\n\
    \  (define digit-from-string\n    (lambda (x)\n      (if (empty? x) '()\n    \
    \      (cons (string->number (string (car x))) (digit-from-string (cdr x))))))\n\
    \  (digit-to-string (append (digit-shift x) (reverse (digit-shift x)))))\n", " \
    \ (define shift-x (- x (* shift (quotient x shift))))\n  (string->number (string-reverse\
    \ (number->string shift-x))))\n", "  (if (= shift (number->string x))\n      (number->string\
    \ x)\n      (if (< shift (string-length (number->string x)))\n          (string-append\
    \ (substring (number->string x) shift)\n                         (substring (number->string\
    \ x) 0 shift))\n          (string-reverse (number->string x)))))\n", "  (define\
    \ (circular_shift_iter digits shift)\n    (if (zero? shift)\n        digits\n\
    \        (circular_shift_iter (string-append (substring digits 1) (substring digits\
    \ 0 1)) (- shift 1))))\n  (circular_shift_iter (number->string x) shift))\n",
  "  (string->number (apply string-append (append (reverse (remainder (integer->list\
    \ x) shift)) (reverse (take (integer->list x) shift))))))\n", "  (define (reverse\
    \ lst)\n    (if (null? lst) '()\n        (append (reverse (cdr lst)) (list (car\
    \ lst)))))\n  (define (to-string lst)\n    (define (helper lst acc)\n      (if\
    \ (null? lst) acc\n          (helper (cdr lst) (string-append (number->string\
    \ (car lst)) acc))))\n    (helper lst \"\"))\n  (to-string (reverse (append (drop\
    \ x shift) (take x shift)))))\n", "  (letrec ([digits (string->list (number->string\
    \ x))]\n           [digits-reversed (reverse digits)]\n           [shift-abs (abs\
    \ shift)])\n    (if (>= shift-abs (length digits))\n        (list->string digits-reversed)\n\
    \        (list->string (append (reverse (drop shift-abs digits-reversed))\n  \
    \                            (take shift-abs digits-reversed))))))\n", "  (string->number\n\
    \   (string-join\n    (list->string\n     (reverse\n      (list->string\n    \
    \   (number->string x)))))))\n", "  (regexp-replace*\n   (number->string x)\n\
    \   (regexp (string-append\n            \"^((?:.{0,\" (number->string shift) \"\
    })\"\n            \"(.{1,\" (number->string shift) \"}))$\"))\n   \"$2$1\"))\n",
  "  (define (shift-helper curr-x shift)\n    (if (= 0 curr-x) (list curr-x)\n   \
    \     (cons (modulo curr-x 10) (shift-helper (quotient curr-x 10) (- shift 1)))))\n\
    \  (define (shift-helper2 digits)\n    (if (empty? digits) empty\n        (cons\
    \ (car (reverse digits)) (shift-helper2 (cdr (reverse digits))))))\n  (define\
    \ (digits x)\n    (shift-helper x shift))\n  (define (shift-right digits)\n  \
    \  (if (empty? digits) empty\n        (cons (car (reverse digits)) (shift-right\
    \ (cdr (reverse digits))))))\n  (define (shift-left digits)\n    (if (empty? digits)\
    \ empty\n        (cons (car digits) (shift-left (cdr digits)))))\n  (define (to-string\
    \ digits)\n    (if (empty? digits) \"\"\n        (string-append (number->string\
    \ (car digits)) (to-string (cdr digits)))))\n  (to-string (shift-right (shift-helper2\
    \ (digits x)))))\n", "  (number->string (circular_shift_i x shift)))\n", "  (let*\
    \ ([str (number->string x)]\n         [shift (modulo shift (string-length str))]\n\
    \         [reversed (reverse str)]\n         [substr (substring reversed shift)])\n\
    \    (string-append substr (substring reversed 0 shift))))\n", "  (define (reverse-string\
    \ str)\n    (regexp-replace* #rx\"\" str \"\" #:backrefs #rx[(all)]))\n  (if (>\
    \ shift (number->string x))\n      (reverse-string (number->string x))\n     \
    \ (regexp-replace* #rx\"\" (number->string x) \"\" #:backrefs #rx[(all)])))\n",
  "  (define digits (number->string x))\n  (define L (string-length digits))\n  (cond\n\
    \    ((<= shift L)\n     (string-append (substring digits shift L)\n         \
    \           (substring digits 0 shift)))\n    (else\n     (string-reverse digits))))\n",
  "  (define (reversed-string s)\n    (cond\n      [(empty? s) \"\" ]\n      [else\
    \ (string-append (reversed-string (rest s)) (string (first s)))]))\n  (define\
    \ (concat-string a b)\n    (string-append a b))\n  (define (accumulate combiner\
    \ null-value term a next b)\n    (if (> a b)\n        null-value\n        (combiner\
    \ (term a)\n                  (accumulate combiner null-value term (next a) next\
    \ b))))\n  (define (add1 n) (+ n 1))\n  (define (id n) n)\n  (define n-digits\
    \ (accumulate + 0 id 1 add1 x))\n  (define (shift-right str length)\n    (if (=\
    \ length shift)\n        str\n        (shift-right (string-append (rest str) (string\
    \ (first str)))\n                     (- length 1))))\n  (if (> n-digits shift)\n\
    \      (string-append (shift-right (number->string x) n-digits)\n            \
    \         (reversed-string (shift-right (number->string x) n-digits)))\n     \
    \ (reversed-string (number->string x))))\n", "  (define x-str (number->string\
    \ x))\n  (define x-len (string-length x-str))\n  (if (> shift x-len)\n      (string-reverse\
    \ x-str)\n      (string-append (substring x-str shift x-len)\n               \
    \      (substring x-str 0 shift))))\n", "  (match (circular_shift-helper x shift)\n\
    \    ['() \"\"]\n    [x (number->string x)]))\n", "  (define (reverse ls acc)\n\
    \    (if (null? ls)\n        acc\n        (reverse (cdr ls) (cons (car ls) acc))))\n\
    \  (define (split-num n)\n    (let loop ([n n] [acc '()])\n      (if (zero? n)\n\
    \          (reverse acc '())\n          (loop (quotient n 10) (cons (remainder\
    \ n 10) acc)))))\n  (define (join-num ls)\n    (if (null? ls)\n        0\n   \
    \     (+ (* (car ls) (expt 10 (sub1 (length ls)))) (join-num (cdr ls)))))\n  (string->number\
    \ (number->string (join-num (reverse (cdr (reverse (append (split-num x) (split-num\
    \ x)))))))))\n", "  (string->number (circular_shift' (number->string x) shift\
    \ \"\")))\n", "  (define (rec n)\n    (cond\n      [(< n 10) (list n)]\n     \
    \ [else (cons (modulo n 10) (rec (quotient n 10)))]))\n  (define (stringify lst)\n\
    \    (cond\n      [(empty? lst) '()]\n      [else (cons (number->string (first\
    \ lst)) (stringify (rest lst)))]))\n  (string-join (stringify (nth-cycle (rec\
    \ x) shift)) \"\"))\n", "  (string->number (string-reverse (string-append (substring\
    \ (number->string x) 0 (- shift))\n                                          \
    \        (substring (number->string x) shift)))))\n", "  (string->number (rotate-string\
    \ (number->string x) shift)))\n", "  (number->string\n   (string->number\n   \
    \ (let ([s (number->string x)])\n      (cond\n        [(> shift (string-length\
    \ s))\n         (string-reverse s)]\n        [else\n         (string-append (substring\
    \ s shift)\n                        (substring s 0 shift))])))))\n\n", "  (if\
    \ (> (number->string x) (number->string shift))\n      (apply string (reverse\
    \ (string->list (number->string x))))\n      (apply string (append (cdr (string->list\
    \ (number->string x))) (string->list (substring (number->string x) 0 1))))))\n\
    \n", "  (number->string (string->number (reverse (number->string x)))))\n", " \
    \ (define (digit-list x)\n    (define (lst x)\n      (if (&lt; x 10)\n       \
    \   (list x)\n          (cons (modulo x 10) (lst (quotient x 10)))))\n    (lst\
    \ x))\n  (define (list-digit lst)\n    (define (dec-list lst)\n      (define (deci\
    \ lst)\n        (if (null? lst)\n            0\n            (+ (* (car lst) (expt\
    \ 10 (length lst))) (deci (cdr lst)))))\n      (deci lst))\n    (dec-list lst))\n\
    \  (define (shift-list lst shift)\n    (if (= shift 0)\n        lst\n        (shift-list\
    \ (cons (car (last lst)) (butlast lst)) (- shift 1))))\n  (define (reverse-list\
    \ lst)\n    (define (rev lst)\n      (if (null? lst)\n          lst\n        \
    \  (append (rev (cdr lst)) (list (car lst)))))\n    (rev lst))\n  (list-digit\
    \ (if (&gt; shift (length (digit-list x)))\n                  (reverse-list (digit-list\
    \ x))\n                  (shift-list (digit-list x) shift))))\n", "  (define xstr\
    \ (number->string x))\n  (define shift (modulo shift (string-length xstr)))\n\
    \  (regexp-replace* #rx\"\" (string-append (substring xstr shift) (substring xstr\
    \ 0 shift)) #:replaces-all? #t))\n", "  (define (rotate x digits)\n    (if (=\
    \ digits 0)\n        \"\"\n        (rotate (quotient x 10) (- digits 1))))\n \
    \ (define (shift x digits shift)\n    (if (= digits 0)\n        (rotate x shift)\n\
    \        (cons (modulo x 10) (shift (quotient x 10) (- digits 1) shift))))\n \
    \ (string-append (shift x (number->string x) shift)\n                 (rotate\
    \ x (- shift (number->string x)))))\n", "  (define (str_reverser s)\n    (define\
    \ (str_reverser-help s i rtn)\n      (if (= i (- (string-length s) 1))\n     \
    \     (string-append rtn (string (string-ref s i)))\n          (str_reverser-help\
    \ s (+ i 1) (string-append rtn (string (string-ref s i))))))\n    (str_reverser-help\
    \ s 0 \"\"))\n  (define (shift_digits x shift)\n    (if (= shift 0)\n        x\n\
    \        (shift_digits (quotient x 10) (- shift 1))))\n  (define (shift_tens x\
    \ shift)\n    (if (= shift 0)\n        x\n        (shift_tens (* x 10) (- shift\
    \ 1))))\n  (define (make_string x shift)\n    (define (make_string-help x i rtn)\n\
    \      (if (= i (- (string-length (number->string x)) 1))\n          (string-append\
    \ rtn (string (string-ref (number->string x) i)))\n          (make_string-help\
    \ x (+ i 1) (string-append rtn (string (string-ref (number->string x) i))))))\n\
    \    (make_string-help x 0 \"\"))\n  (if (> shift (string-length (number->string\
    \ x)))\n      (str_reverser (number->string x))\n      (make_string (+ (shift_digits\
    \ x shift) (shift_tens (modulo x 10) shift)) shift)))\n", "  (reverse (string->list\
    \ (number->string x))))\n", "  (define (shift-digits-to-string x)\n    (if (&lt;\
    \ x 10)\n        (number-&gt;string x)\n        (string-append (shift-digits-to-string\
    \ (quotient x 10))\n                       (number-&gt;string (remainder x 10)))))\n\
    \  (define (reversed-string str)\n    (if (string-null? str)\n        str\n  \
    \      (string-append (reversed-string (substring str 1))\n                  \
    \     (substring str 0 1))))\n  (define (extract-substring s)\n    (substring\
    \ s 1))\n  (define (shift-digit-string x shift)\n    (if (= shift 0)\n       \
    \ x\n        (shift-digit-string (extract-substring x) (- shift 1))))\n  (if (&lt;\
    \ shift (string-length (shift-digits-to-string x)))\n      (shift-digit-string\
    \ (shift-digits-to-string x) shift)\n      (reversed-string (shift-digits-to-string\
    \ x))))\n", "  (define digits (string->list (number->string x)))\n  (if (> shift\
    \ (length digits))\n      (list->string (reverse digits))\n      (list->string\
    \ (append (list-tail digits shift) (list-head digits shift)))))\n", "  (define\
    \ (pow x y)\n    (if (= y 0)\n        1\n        (* x (pow x (- y 1)))))\n  (define\
    \ (num_digits x)\n    (cond ((< x 10) 1)\n          (else (+ 1 (num_digits (/\
    \ x 10))))))\n  (define (shifted_digit x shift)\n    (cond ((= (modulo x 10) shift)\n\
    \           (string-append (number->string shift)\n                          (number->string\
    \ shift)))\n          (else (number->string (modulo x 10)))))\n  (define (shift_digit\
    \ x shift)\n    (cond ((= shift 0) x)\n          (else (shift_digit (/ x 10) (-\
    \ shift 1)))))\n  (cond ((< shift (num_digits x))\n         (string-append (shifted_digit\
    \ x shift)\n                        (number->string (shift_digit x shift))))\n\
    \        (else (number->string (reverse x)))))\n", "  (display (number->string\
    \ x))\n  (display \" \")\n  (display shift)\n  (display \"\\n\")\n  (number->string\
    \ x))\n", "  (define (rotate digits amount)\n    (if (= amount 0)\n        digits\n\
    \        (rotate (cons (last digits) (butlast digits)) (- amount 1))))\n  (define\
    \ (digits-to-int digits)\n    (if (null? digits)\n        0\n        (+ (* (digits-to-int\
    \ (butlast digits)) 10) (last digits))))\n  (define (int-to-digits x)\n    (if\
    \ (= x 0)\n        (list)\n        (cons (modulo x 10) (int-to-digits (quotient\
    \ x 10)))))\n  (define (reverse-int x)\n    (define (reverse digits)\n      (if\
    \ (null? digits)\n          (list)\n          (cons (last digits) (reverse (butlast\
    \ digits)))))\n  (define (digits-to-int digits)\n    (if (null? digits)\n    \
    \    0\n        (+ (* (digits-to-int (butlast digits)) 10) (last digits))))\n\
    \  (digits-to-int (reverse-int (digits-to-int (rotate (int-to-digits x) shift)))))\n\
    \n", "  (number->string\n   (string->number\n    (reverse\n     (string-append\n\
    \      (substring (number->string x) shift)\n      (substring (number->string\
    \ x) 0 shift))))))\n", "  (integer->string (digits->integer (cdr (rotate x shift)))))\n",
  "  (define (int->list x)\n    (local ((define (loop x result)\n              (if\
    \ (zero? x)\n                  result\n                  (loop (quotient x 10)\
    \ (cons (remainder x 10) result)))))\n      (loop x '())))\n  (define (list->int\
    \ x)\n    (local ((define (loop x result)\n              (if (null? x)\n     \
    \             result\n                  (loop (cdr x) (+ (* result 10) (car x))))))\n\
    \      (loop x 0)))\n  (define (reverse-list lst)\n    (local ((define (loop lst\
    \ result)\n              (if (null? lst)\n                  result\n         \
    \         (loop (cdr lst) (cons (car lst) result)))))\n      (loop lst '())))\n\
    \  (list->int (reverse-list (reverse-list (append (list->int (reverse-list (int->list\
    \ x))) (int->list x)) shift))))\n", "  (let ([digits (number->string x)])\n  \
    \  (if (< shift (string-length digits))\n        (string-append (substring digits\
    \ shift)\n                       (substring digits 0 shift))\n        (string-reverse\
    \ digits))))\n", "  (define (right-shift x)\n    (let loop ([i 1] [a x])\n   \
    \   (if (< i shift)\n          (loop (+ i 1) (quotient a 10))\n          a)))\n\
    \  (define (reverse-shift a)\n    (number->string (right-shift (string->number\
    \ (string-reverse (number->string a))))))\n  (if (> shift (string-length (number->string\
    \ x)))\n      (reverse-shift x)\n      (number->string (right-shift x))))\n```\n\
    \n### exercise 3.2\n```scheme\n#lang racket\n", "  (define (reverse-all-but-first\
    \ lst)\n    (define (reverse-all-but-first-iter reversed rest)\n      (cond ((null?\
    \ rest) reversed)\n            (else (reverse-all-but-first-iter (cons (car rest)\
    \ reversed) (cdr rest)))))\n    (reverse-all-but-first-iter '(car lst) (cdr lst)))\n\
    \  (define (pad-with-zeros n i)\n    (if (> n i)\n        (cons 0 (pad-with-zeros\
    \ n (+ i 1)))\n        '()))\n  (if (= shift 0)\n      (number->string x)\n  \
    \    (let ((str (number->string x))\n            (digits (string->list str)))\n\
    \        (string-append (reverse-all-but-first digits)\n                     \
    \  (string-append (pad-with-zeros shift 0)\n                                 \
    \     (list (car digits)))))))\n", "  (define (digit-list x)\n    (if (= x 0)\n\
    \        empty\n        (cons (remainder x 10) (digit-list (quotient x 10)))))\n\
    \  (define (string-of-list lst)\n    (cond\n      [(empty? lst) empty]\n     \
    \ [(= (length lst) 1) (number->string (car lst))]\n      [else (string-append\
    \ (number->string (car lst)) (string-of-list (cdr lst)))]))\n  (define (reverse-string\
    \ str)\n    (define (reverse-string-helper rev-str str)\n      (if (empty? str)\n\
    \          rev-str\n          (reverse-string-helper (string-append (substring\
    \ str 0 1) rev-str) (substring str 1))))\n    (reverse-string-helper empty str))\n\
    \  (define (circular-shift-helper x shift)\n    (cond\n      [(empty? x) empty]\n\
    \      [(= (length x) 1) x]\n      [(= shift 0) x]\n      [else (circular-shift-helper\
    \ (cons (car (cdr x)) (cons (car x) (cdr (cdr x)))) (- shift 1))]))\n  (if (<\
    \ shift (length (digit-list x)))\n      (string-of-list (circular-shift-helper\
    \ (digit-list x) shift))\n      (reverse-string (string-of-list (digit-list x)))))\n",
  "  (define num-digits (count-digits x))\n  (if (> shift num-digits)\n      (reverse-digits\
    \ x)\n      (let ([x (modulo (expt 10 shift) x)])\n        (number->string x))))\n",
  "  (regexp-replace* #rx\"\" (number->string x) shift))\n", "  (string->number\n\
    \   (string-join\n    (reverse\n     (append\n      (drop (reverse (integer->list\
    \ x)) shift)\n      (take (reverse (integer->list x)) shift)))\n    \"\")))\n",
  "  (if (> shift (length (number->string x)))\n      (string-reverse (number->string\
    \ x))\n      (string-append (substring (number->string x) shift)\n           \
    \          (substring (number->string x) 0 shift))))\n\n", "  (define digits (string->list\
    \ (number->string x)))\n  (cond\n    [(empty? digits) \"\"]\n    [(= shift 0)\
    \ (list->string digits)]\n    [(= shift (length digits)) (list->string (reverse\
    \ digits))]\n    [else (list->string (append (reverse (cdr (reverse digits)))\
    \ (list (car (reverse digits)))))]))\n", "  (string->number\n   (regexp-replace\n\
    \    #rx\"^(.{1,(sub1 (string-length (number->string x))),})(.*)$\"\n    (number->string\
    \ x)\n    (lambda (whole parts)\n      (apply string\n             (append (reverse\
    \ (cdr parts))\n                     (list (car parts))))))))\n", "  (cond\n \
    \   [(< shift 0) (error \"shift must be >= 0\")]\n    [(not (integer? x)) (error\
    \ \"x must be an integer\")]\n    [(= shift 0) (number->string x)]\n    [(= shift\
    \ (string-length (number->string x))) (string-reverse (number->string x))]\n \
    \   [else (string-append (substring (number->string x) shift) (substring (number->string\
    \ x) 0 shift))]))\n```\n### Test cases\n\n```", "  (define n-digits (string-length\
    \ (number->string x)))\n  (define (shift-helper i)\n    (if (= i n-digits) \"\"\
    \n        (string-append (substring (number->string x) i (+ i 1))\n          \
    \             (shift-helper (+ i 1)))))\n  (if (> shift n-digits) (reverse (shift-helper\
    \ 0))\n      (define (shift-helper-2 i)\n        (if (= i shift) \"\"\n      \
    \      (string-append (substring (number->string x) (- n-digits i) (- n-digits\
    \ i 1))\n                           (shift-helper-2 (+ i 1)))))\n      (string-append\
    \ (shift-helper-2 0) (shift-helper shift))))\n", "  (define (cshift n)\n    (cond\n\
    \      [(zero? n) x]\n      [else (cshift (quotient n 10))]))\n  (number->string\
    \ (cshift x)))\n", "  (string->number (integer->string (if (> shift (length (integer->string\
    \ x)))\n                                       (reverse (integer->string x))\n\
    \                                       (let* ([digits (string->list (integer->string\
    \ x))]\n                                              [first (reverse (take shift\
    \ digits))]\n                                              [second (drop shift\
    \ digits)])\n                                         (list->string (append second\
    \ first)))))))\n", "  (define (reverse-str s)\n    (apply string (reverse (string->list\
    \ s))))\n  (define (shift-str s)\n    (apply string (append (reverse (cdr (string->list\
    \ s))) (list (car (string->list s))))))\n  (if (= shift 0)\n      (number->string\
    \ x)\n      (if (= shift (string-length (number->string x)))\n          (reverse-str\
    \ (number->string x))\n          (if (> shift (string-length (number->string x)))\n\
    \              (reverse-str (number->string x))\n              (shift-str (number->string\
    \ x))))))\n", "  (number->string\n   (string->number\n    (reverse\n     (substring\n\
    \      (substring\n       (number->string\n        (string->number\n         (reverse\n\
    \          (number->string x))))\n       0 shift)\n      shift)))))\n", "  (let\
    \ ([str (number->string x)])\n    (cond\n      [(> shift (string-length str))\n\
    \       (string-reverse str)]\n      [else\n       (string-append (substring str\
    \ shift)\n                      (substring str 0 shift))])))\n", "  (if (< shift\
    \ (string-length (number->string x)))\n      (string-append (substring (number->string\
    \ x) shift)\n                     (substring (number->string x) 0 shift))\n  \
    \    (string-reverse (number->string x))))\n", "  (define (shift-digits x shift)\n\
    \    (cond\n      [(empty? x) x]\n      [(= 0 shift) x]\n      [else (append (rest\
    \ x) (list (first x)))]))\n  (define (reversed-digits x)\n    (cond\n      [(empty?\
    \ x) x]\n      [else (append (reversed-digits (rest x)) (list (first x)))]))\n\
    \  (cond\n    [(= 1 (length x)) x]\n    [(= shift (length x)) (reversed-digits\
    \ x)]\n    [else (shift-digits x shift)]))\n", "  (define-values (num-digits digits)\
    \ (digits-of x))\n  (string-append (reverse digits)\n                 (string-append\
    \ (make-string\n                                 (- shift num-digits)\n      \
    \                           #\\0)\n                                (reverse digits))))",
  "  (string->number\n   (string-join\n    (map number->string\n         (reverse\n\
    \          (append (reverse (rest (string->list (number->string x))))\n      \
    \            (list (string->number (car (string->list (number->string x)))))))))))\n",
  "  (if (string? x)\n      (circular_shift (string->number x) shift)\n      (let\
    \ ([x (number->string x)])\n        (let ([n (length x)])\n          (if (< shift\
    \ n)\n              (string-append (substring x shift n) (substring x 0 shift))\n\
    \              (string-reverse x))))))\n", "  (if (< shift (length (number->string\
    \ x)))\n      (string-append (substring (number->string x) shift)\n          \
    \           (substring (number->string x) 0 shift))\n      (string-reverse (number->string\
    \ x))))\n", "  (define (num_digits x)\n    (if (< x 10)\n        1\n        (+\
    \ 1 (num_digits (/ x 10)))))\n  (define (get_digit x i)\n    (if (= i 0)\n   \
    \     (modulo x 10)\n        (get_digit (/ x 10) (- i 1))))\n  (define (set_digit\
    \ x i d)\n    (if (= i 0)\n        (if (zero? (modulo x 10))\n            (modulo\
    \ (+ x d) 10)\n            (+ (- (* (/ x 10) 10) (modulo x 10)) d))\n        (modulo\
    \ (+ (* (/ x 10) 10) (set_digit (modulo x 10) (- i 1) d)) 10)))\n  (define (swap\
    \ x i1 i2)\n    (set_digit (set_digit x i1 (get_digit x i2)) i2 (get_digit x i1)))\n\
    \  (define (shift x shift)\n    (define (shift-iter x shift i)\n      (if (= i\
    \ (- (num_digits x) 1))\n          x\n          (shift-iter (swap x i (+ i shift))\
    \ shift (+ i 1))))\n    (if (<= shift (num_digits x))\n        (shift-iter x shift\
    \ 0)\n        (shift-iter x (- (num_digits x) shift) 0)))\n  (define (show x)\n\
    \    (if (= x 0)\n        \"\"\n        (string-append (show (/ x 10)) (number->string\
    \ (modulo x 10)))))\n  (show (shift x shift)))", "  (define n (integer->string\
    \ x))\n  (if (> shift (string-length n))\n      (reverse n)\n      (string-append\
    \ (substring n shift) (substring n 0 shift))))\n", "  (define (helper x shift)\n\
    \    (if (&lt; shift 0)\n        (error \"shift should be positive\")\n      \
    \  (if (= shift 0)\n            x\n            (let* ([xstr (number-&gt;string\
    \ x)]\n                   [fst (first xstr)]\n                   [rst (rest xstr)])\n\
    \              (helper (string-&gt;number (string-append rst fst))\n         \
    \             (- shift 1))))))\n  (number-&gt;string (helper x shift)))\n", " \
    \ (let ((shift (modulo shift (number->string x))))\n    (string-append (substring\
    \ (number->string x) shift)\n                   (substring (number->string x)\
    \ 0 shift))))\n", "  (define digits (regexp-split #rx\"0*\" (number->string x)))\n\
    \  (define len (length digits))\n  (cond [(< shift len) (string-join (append (drop-right\
    \ shift digits) (take shift digits)) \"\")]\n        [else (string-join (reverse\
    \ digits) \"\")]))\n", "  (cond\n    [(<= x 0) \"\"]\n    [(= shift 0) (number->string\
    \ x)]\n    [else (string-append (number->string (modulo x 10))\n             \
    \            (circular_shift (quotient x 10) (- shift 1)))]))\n", "  (if (zero?\
    \ shift)\n      (number->string x)\n      (number->string (modulo (* x (expt 10\
    \ shift)) (expt 10 (number->string x |> string-length))))))\n", "  (define x-str\
    \ (number->string x))\n  (define x-str-len (string-length x-str))\n  (define shift-str\
    \ (if (<= shift x-str-len)\n                        (string-append (substring\
    \ x-str shift x-str-len)\n                                       (substring x-str\
    \ 0 shift))\n                        (string-reverse x-str)))\n  shift-str)\n",
  "  (if (= shift 0)\n      (number->string x)\n      (let* ([str (number->string\
    \ x)]\n             [len (string-length str)]\n             [circ (string-append\
    \ (substring str shift len)\n                                  (substring str\
    \ 0 shift))])\n        (if (= len (string-length circ))\n            circ\n  \
    \          (string-reverse circ)))))\n", "  (number->string (circular_shift_intermediate\
    \ x shift)))\n", "  (define (circular_shift_helper x shift s)\n    (define (reverse\
    \ s)\n      (define (reverse_helper s acc)\n        (if (empty? s)\n         \
    \   acc\n            (reverse_helper (rest s) (cons (first s) acc))))\n      (reverse_helper\
    \ s (string)))\n    (if (&lt;= shift (string-length s))\n        (substring s\
    \ shift)\n        (reverse s)))\n  (circular_shift_helper x shift (number-&gt;string\
    \ x)))\n", "  (define (reverse-string str)\n    (apply string (reverse (string->list\
    \ str))))\n  (define (shift-string str)\n    (define (shift n)\n      (cond ((=\
    \ n 0) str)\n            (else (shift (- n 1)))))\n    (shift (string-length str)))\n\
    \  (define (reverse-shift-string str)\n    (reverse-string (shift-string str)))\n\
    \  (string->number (reverse-shift-string (number->string x))))\n", "  (define\
    \ (loop x res)\n    (cond [(zero? x) (number->string res)]\n          [else (loop\
    \ (quotient x 10) (+ (* 10 (remainder x 10)) res))]))\n  (define (reverse n)\n\
    \    (define (loop n rev)\n      (cond [(zero? n) rev]\n            [else (loop\
    \ (quotient n 10) (+ (* 10 (remainder n 10)) rev))]))\n    (loop n 0))\n  (if\
    \ (> shift (loop x 0))\n      (reverse x)\n      (define (add n s)\n        (define\
    \ (loop n s r)\n          (cond [(zero? n) r]\n                [else (loop (quotient\
    \ n 10) (quotient s 10) (+ (* s (remainder n 10)) r))]))\n        (loop n s 0))\n\
    \      (number->string (add x (expt 10 shift)))))\n", "  (define (digits n)\n\
    \    (if (<= n 0) '()\n        (cons (% n 10) (digits (quotient n 10)))))\n  (let\
    \ ([digits (digits x)])\n    (string-append\n     (apply string (map char->integer\n\
    \                        (reverse (drop shift digits))))\n     (apply string (map\
    \ char->integer\n                        (take shift digits))))))\n", "  (regexp-replace*\
    \ #rx#\"^(.{#,shift})(.*)\"\n                   (number->string x)\n         \
    \          (lambda (m) (string-append (caddr m) (cadr m)))))\n", "  (number->string\
    \ (modulo (for/fold ([sum 0]) ([digit (string->number/base x 10)])\n         \
    \                  (+ (expt 10 shift) sum (* 10 digit)))\n                   \
    \       (expt 10 shift))))\n", "  (let ((xstr (number->string x)))\n    (if (<\
    \ shift (string-length xstr))\n        (string-append (substring xstr shift)\n\
    \                       (substring xstr 0 shift))\n        (string-reverse xstr))))\n",
  "  (define (circular_shift-aux x shift len digits reversed)\n    (cond ((= shift\
    \ 0) (string-append (reverse reversed) digits))\n          ((< shift 0) (circular_shift-aux\
    \ x (+ shift len) len digits reversed))\n          ((= (string-length digits)\
    \ 0)\n           (circular_shift-aux x (- shift 1) len reversed (string-append\
    \ reversed (list (string-ref digits 0)))))\n          (else (circular_shift-aux\
    \ x (- shift 1) len (substring digits 1) (string-append reversed (list (string-ref\
    \ digits 0)))))))\n  (circular_shift-aux x shift (string-length (number->string\
    \ x)) (number->string x) \"\"))\n", "  (define (length-of-integer x)\n    (if\
    \ (= x 0)\n        0\n        (+ 1 (length-of-integer (quotient x 10)))))\n  (define\
    \ (left-shift n x)\n    (if (or (= n 0) (= x 0))\n        x\n        (left-shift\
    \ (- n 1) (* 10 x))))\n  (define (right-shift n x)\n    (if (or (= n 0) (= x 0))\n\
    \        x\n        (right-shift (- n 1) (quotient x 10))))\n  (define (reverse-integer\
    \ x)\n    (define (r x rev)\n      (if (= x 0)\n          rev\n          (r (quotient\
    \ x 10) (+ (* 10 rev) (remainder x 10)))))\n    (r x 0))\n  (define (integer->string\
    \ x)\n    (if (= x 0)\n        (string #\\0)\n        (string (+ #\\0 (remainder\
    \ x 10))\n                (integer->string (quotient x 10)))))\n  (define (helper\
    \ x n)\n    (if (= x 0)\n        #f\n        (cond ((= n 0)\n               (integer->string\
    \ x))\n              ((< n (length-of-integer x))\n               (helper (right-shift\
    \ n (left-shift n x)) n))\n              (else\n               (integer->string\
    \ (reverse-integer x))))))\n  (helper x shift))\n", "  (define (shift-right input\
    \ shift)\n    (list-ref (append (list-tail input (- shift))\n                \
    \      (list-take input (- shift)))\n              0))\n  (define (reversed input)\n\
    \    (list->string (reverse (string->list input))))\n  (define (input-len input)\n\
    \    (string-length input))\n  (define (result input shift)\n    (if (> shift\
    \ (input-len input))\n        (reversed input)\n        (number->string (shift-right\
    \ (string->number input) shift))))\n  (result (number->string x) shift))\n", " \
    \ (define (loop x shift result)\n    (if (zero? x)\n        result\n        (loop\
    \ (quotient x 10)\n              (- shift 1)\n              (if (zero? shift)\n\
    \                  (string-append (number->string (remainder x 10)) result)\n\
    \                  (string-append result (number->string (remainder x 10)))))))\n\
    \  (loop x shift \"\"))\n", "  (let ([digits (number->string x)])\n    (if (>\
    \ shift (string-length digits))\n        (string-reverse digits)\n        (substring\
    \ digits shift)\n        (substring digits 0 shift))))\n", "  (define (shift left)\n\
    \    (cond\n      [(= left 1) (string-append (string (remainder x 10))\n     \
    \                            (string (quotient x 10)))]\n      [else (string-append\
    \ (string (remainder x 10))\n                           (shift (- left 1)))]))\n\
    \  (define (reverse str)\n    (string-append (substring str 1 (string-length str))\n\
    \                   (substring str 0 1)))\n  (define str\n    (cond\n      [(<\
    \ shift (string-length (number->string x))) (shift shift)]\n      [else (reverse\
    \ (number->string x))]))\n  str)\n", "  (define (shifted_digits x shift len)\n\
    \    (if (= shift 0)\n        (number->string x)\n        (if (> shift len)\n\
    \            (string-reverse (number->string x))\n            (let* ([div (/ x\
    \ (expt 10 shift))]\n                   [mod (modulo x (expt 10 shift))])\n  \
    \            (number->string (+ (* mod (expt 10 len)) div))))))\n  (let* ([len\
    \ (length (number->string x))])\n    (shifted_digits x shift len)))\n", "  (string->number\n\
    \   (string-join\n    (reverse\n     (append\n      (reverse (string->list (number->string\
    \ x)))\n      (make-list (- shift (string-length (number->string x)))\n      \
    \           (string-ref (number->string x) 0)))))))\n", "  (define (circ-shift-helper\
    \ x shift count)\n    (cond\n      [(zero? x) \"\"]\n      [(zero? shift) (number->string\
    \ x)]\n      [(= count shift) (number->string x)]\n      [else (circ-shift-helper\
    \ (quotient x 10) shift (+ count 1))]))\n  (define n (integer-length x))\n  (define\
    \ shifted-x (if (> n shift)\n                        (modulo x (expt 10 shift))\n\
    \                        (circ-shift-helper x shift 0)))\n  (if (> n shift)\n\
    \      (string-append shifted-x (substring (number->string x) 0 (- n shift)))\n\
    \      shifted-x))\n", "  (integer->string\n   (reverse\n    (cdr\n     (append\n\
    \      (reverse (take (digits x) (modulo shift (length (digits x)))))\n      (reverse\
    \ (drop (digits x) (modulo shift (length (digits x))))))))))\n", "  (define (aux\
    \ shift x)\n    (if (&lt;= x 0)\n        (number-&gt;string 0)\n        (let*\
    \ ([x-digits (number-&gt;string x)]\n               [digits (string-&gt;list x-digits)]\n\
    \               [len (length digits)]\n               [shift (modulo shift len)])\n\
    \          (if (= shift 0)\n              x-digits\n              (apply string\
    \ (reverse (rest (last digits len)))))\n          )))\n  (aux shift x))\n", " \
    \ (define digits (string->list (number->string x)))\n  (define (shift-digits d\
    \ shift)\n    (if (zero? shift)\n        d\n        (append (shift-digits (reverse\
    \ d) (- shift 1)))))\n  (list->string (shift-digits digits shift)))\n", "  (string->number\
    \ (string-append (reverse (string-tail (number->string x) shift))\n          \
    \                       (string-take (number->string x) shift))))\n", "  (string->number\n\
    \   (if (< shift (string-length (number->string x)))\n       (string-append (substring\
    \ (number->string x) shift)\n                       (substring (number->string\
    \ x) 0 shift))\n       (apply string (reverse (string->list (number->string x)))))))\n",
  "  (define (cs x shift)\n    (if (= shift 0)\n        (number->string x)\n     \
    \   (let ((ds (string->number (number->string x))))\n          (if (> shift (quotient\
    \ (number->string (number->string x)) 10))\n              (number->string (reverse\
    \ ds))\n              (number->string (append (reverse (remainder ds)) (reverse\
    \ (quotient ds))))))))\n  (if (< shift 0)\n      (error \"Shift must be non-negative\"\
    )))\n", "  (define (helper x shift str)\n    (cond\n      [(< shift 0) (reversed\
    \ str)]\n      [(zero? x) (string (modulo shift 10) str)]\n      [else (helper\
    \ (quotient x 10) (sub1 shift) (string (modulo x 10) str))]))\n  (helper x shift\
    \ \"\"))\n", "  (let ([str (number->string x)])\n    (if (< shift (string-length\
    \ str))\n        (string-append (substring str shift) (substring str 0 shift))\n\
    \        (apply string (reverse (string->list str))))))\n", "  (cond [(<= x 0)\n\
    \         (number->string x)]\n        [(<= shift 0)\n         (number->string\
    \ x)]\n        [else\n         (let ([pivot (quotient x (expt 10 shift))]\n  \
    \             [rest (modulo x (expt 10 shift))])\n           (string-append (number->string\
    \ rest)\n                          (number->string pivot)))]))\n", "  (if (> shift\
    \ (string-length (number->string x)))\n      (string-reverse (number->string x))\n\
    \      (begin\n        (let ((pre (substring (number->string x) 0 (- shift)))\n\
    \              (post (substring (number->string x) (- shift))))\n          (if\
    \ (string=? pre \"\")\n              post\n              (string-append post pre))))))\n",
  "  (cond\n    [(> shift (string-length (number->string x)))\n     (reverse (number->string\
    \ x))]\n    [else\n     (string-append (substring (number->string x) (- shift))\n\
    \                    (substring (number->string x) 0 (- shift)))]))\n", "  (apply\
    \ string (append (reverse (flatten (list-tail (list->list-of-lists (string->list\
    \ (number->string x))) shift))) (reverse (flatten (list-head (list->list-of-lists\
    \ (string->list (number->string x))) shift))))))\n", "  (let\n    ([x-string (number->string\
    \ x)]\n     [x-length (string-length x-string)])\n    (cond\n      [(< shift x-length)\n\
    \       (string-append (substring x-string shift x-length)\n                 \
    \     (substring x-string 0 shift))]\n      [else\n       (reverse x-string)])))\n",
  "  (define x-str (number->string x))\n  (define digits-reversed (reverse x-str))\n\
    \  (define shift-str (number->string shift))\n  (define shift-str-reversed (reverse\
    \ shift-str))\n  (if (> (string-length x-str) shift)\n      (apply string (append\
    \ (list #\\-)\n                            (list-rest (list-rest (list-rest digits-reversed)))\n\
    \                            (take (list-rest digits-reversed) shift))))\n  (if\
    \ (> (string-length shift-str) (string-length x-str))\n      shift-str-reversed)\n\
    \  (if (< (string-length shift-str) (string-length x-str))\n      (apply string\
    \ (append (list #\\-)\n                            (list-rest (list-rest (list-rest\
    \ digits-reversed)))\n                            (take (list-rest digits-reversed)\
    \ shift))))\n  )\n\n", "  (define (get-digit x n)\n    (cond\n      [(zero? n)\
    \ (remainder x 10)]\n      [else (get-digit (quotient x 10) (- n 1))]))\n  (define\
    \ (reverse x)\n    (if (zero? x)\n        0\n        (+ (* 10 (reverse (quotient\
    \ x 10))) (remainder x 10))))\n  (define (len x)\n    (if (zero? x)\n        0\n\
    \        (+ 1 (len (quotient x 10)))))\n  (define (shift x shift)\n    (define\
    \ (rotate-right x shift)\n      (define (reverse-len x shift)\n        (if (zero?\
    \ shift)\n            0\n            (+ (* 10 (reverse-len (quotient x 10) (-\
    \ shift 1))) (remainder x 10))))\n      (define (rotate-left x x-len)\n      \
    \  (define (reverse-len x x-len shift)\n          (if (zero? shift)\n        \
    \      0\n              (+ (* 10 (reverse-len (quotient x 10) (- x-len 1) (- shift\
    \ 1))) (remainder x 10))))\n        (reverse-len (reverse x) x-len shift))\n \
    \     (rotate-left x x-len))\n    (define (rotate-left x shift)\n      (define\
    \ (reverse-len x shift)\n        (if (zero? shift)\n            0\n          \
    \  (+ (* 10 (reverse-len (quotient x 10) (- shift 1))) (remainder x 10))))\n \
    \     (reverse-len (reverse x) shift))\n    (if (< shift 0)\n        (rotate-right\
    \ x (- shift))\n        (rotate-left x shift)))\n  (define (pad x x-len)\n   \
    \ (if (zero? x-len)\n        (string-append \"0\" (number->string x))\n      \
    \  (string-append (make-string (- shift x-len) #\\0) (number->string x))))\n \
    \ (define x-len (len x))\n  (define shift (modulo shift x-len))\n  (pad (shift\
    \ x shift) x-len))", "  (define (digits x)\n    (if (zero? x) '()\n        (cons\
    \ (remainder x 10) (digits (quotient x 10)))))\n  (define (reverse lst)\n    (if\
    \ (null? lst) '()\n        (append (reverse (cdr lst)) (list (car lst)))))\n \
    \ (define (shifted_digits x shift)\n    (define (rotate ls n)\n      (if (= n\
    \ 0) ls\n          (rotate (cons (last ls) (butlast ls)) (- n 1))))\n    (rotate\
    \ (digits x) shift))\n  (define (str_of_int n)\n    (if (zero? n) \"\"\n     \
    \   (string-append (str_of_int (quotient n 10)) (string (remainder n 10)))))\n\
    \  (define (to_string ls)\n    (if (null? ls) \"\"\n        (string-append (to_string\
    \ (cdr ls)) (string (car ls)))))\n  (if (> shift (length (digits x)))\n      (to_string\
    \ (reverse (digits x)))\n      (to_string (shifted_digits x shift))))\n", "  (define\
    \ (count-digits x)\n    (if (= x 0)\n        0\n        (+ 1 (count-digits (/\
    \ x 10)))))\n  (define (shift-digits x shift)\n    (if (= shift 0)\n        x\n\
    \        (let* ([first-digit (/ x (expt 10 (count-digits x)))]\n             \
    \  [shifted-x (+ (- x first-digit) (* first-digit (expt 10 shift)))]\n       \
    \        [next-shift (- shift 1)])\n          (shift-digits shifted-x next-shift))))\n\
    \  (number->string (shift-digits x shift)))\n", "  (define (char-&gt;int c)\n\
    \    (- (char-&gt;integer c) (char-&gt;integer #\\0)))\n  (define (int-&gt;char\
    \ c)\n    (integer-&gt;char (+ c (char-&gt;integer #\\0))))\n  (define (circular_shift-1\
    \ x shift d)\n    (cond ((= shift 0) (string d))\n          ((= shift d) (string-&gt;list\
    \ (number-&gt;string x)))\n          (else (circular_shift-1 (quotient x 10) (-\
    \ shift 1) (+ (* d 10) (remainder x 10))))))\n  (define (string&lt; s1 s2)\n \
    \   (cond ((string=? s1 s2) #f)\n          ((string&lt;? s1 s2) #t)\n        \
    \  (else #f)))\n  (define (circular_shift-2 x shift)\n    (cond ((string&lt; (number-&gt;string\
    \ x) (circular_shift-1 x shift 0)) #f)\n          ((string=? (number-&gt;string\
    \ x) (circular_shift-1 x shift 0)) #t)\n          (else (circular_shift-2 x (+\
    \ shift 1)))))\n  (if (circular_shift-2 x 0) (number-&gt;string x) (circular_shift-1\
    \ x 0 0)))\n</code>\nAnd here's the same code in Python for reference (I'd also\
    \ love to see a Pythonic version of this, with lazy evaluation and such):\n<code>#!/usr/bin/env\
    \ python3\n\nimport sys\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n\
    \        lines.append(line.rstrip('\\n'))\n    for line in lines:\n        print(circular_shift(int(line)))\n\
    \ndef circular_shift(x):\n    circular_shift_2 = lambda x, shift: (\n        (x\
    \ == circular_shift_1(x, shift, 0))\n        or (circular_shift_2(x, shift + 1))\n\
    \    )\n    circular_shift_1 = lambda", "  (define (rec x s)\n    (cond [(< s\
    \ 0) (reverse (number->string x))]\n          [(zero? s) (number->string x)]\n\
    \          [else (rec (quotient x 10) (- s 1))]))\n  (rec x shift))\n", "  (define\
    \ (reverse-string str)\n    (apply string (reverse (string->list str))))\n  (define\
    \ (digits-x digits)\n    (let* ([digits (string->list (number->string x))]\n \
    \          [digits-length (length digits)])\n      (if (> shift digits-length)\n\
    \          (reverse-string (number->string x))\n          (apply string (append\
    \ (reverse (take digits (- digits-length shift)))\n                          \
    \      (reverse (drop digits (- digits-length shift))))))))\n  (digits-x x))\n",
  "  (define digits (string->list (number->string x)))\n  (define shifted (append\
    \ (drop shift digits) (take shift digits)))\n  (list->string shifted))\n", " \
    \ (define (reverse-digits-of x rev-x)\n    (if (= x 0)\n        rev-x\n      \
    \  (reverse-digits-of (quotient x 10)\n                           (+ (* (remainder\
    \ x 10)\n                                 (expt 10 (- (length (number->string\
    \ x)) 1)))\n                              rev-x))))\n  (define (circular-shift-rec\
    \ x shift x-rev rev-x-rev)\n    (if (> shift (length (number->string x)))\n  \
    \      (number->string rev-x-rev)\n        (circular-shift-rec x\n           \
    \                 (- shift 1)\n                            (+ (* x-rev (expt 10\
    \ 1))\n                               (quotient x-rev 10))\n                 \
    \           (+ (* rev-x-rev (expt 10 1))\n                               (quotient\
    \ rev-x-rev 10)))))\n  (circular-shift-rec x shift (reverse-digits-of x 0) 0))\n",
  "  (define (helper x shift)\n    (if (<= shift 0)\n        (number->string x)\n\
    \        (let ([d (modulo x 10)])\n          (helper (truncate (/ x 10)) (sub1\
    \ shift))\n          (number->string d))))\n  (define (reverse str)\n    (apply\
    \ string (reverse (string->list str))))\n  (if (> shift (string-length (number->string\
    \ x)))\n      (reverse (helper x shift))\n      (helper x shift)))\n", "  (display\
    \ x)\n  (display \" \")\n  (display shift)\n  (display \"  =>  \")\n  (define\
    \ digitcount (count_digits x))\n  (display digitcount)\n  (display \"  =>  \"\
    )\n  (if (> shift digitcount)\n      (display (reverse_digits x))\n      (define\
    \ end (firstn x shift))\n      (define result (lastn x shift))\n      (concat\
    \ result end)\n      (display result)\n      )\n  (newline)\n  )\n", "  (define\
    \ (reverse digits)\n    (if (null? digits)\n        '()\n        (append (reverse\
    \ (cdr digits)) (list (car digits)))))\n  (define (circular-shift-helper digits\
    \ shift)\n    (if (> shift (length digits))\n        (reverse digits)\n      \
    \  (append (circular-shift-helper (cdr digits) (+ shift 1)) (list (car digits)))))\n\
    \  (string-join (circular-shift-helper (string->list (number->string x)) 0) \"\
    \"))\n", "  (if (< x 0)\n      (error \"x must be non-negative\")\n      (if (number?\
    \ x)\n          (number->string\n           (string->number\n            (string-append\n\
    \             (substring (number->string x) shift)\n             (substring (number->string\
    \ x) 0 shift))))\n          (error \"x must be a number\"))))\n", "  (if (< shift\
    \ 0)\n      (displayln \"shift must be non-negative\")\n      (let ([num-digits\
    \ (number->string x)])\n        (if (< shift (string-length num-digits))\n   \
    \         (let ([n (number->string x)])\n              (string-append (substring\
    \ n shift) (substring n 0 shift)))\n            (reverse num-digits)))))\n```\n\
    \n```racket\n#lang racket\n", "  (reverse (string->list (number->string (if (>\
    \ shift (length (number->string x)))\n                                       \
    \      (string->number (string-reverse (number->string x)))\n                \
    \                             (let loop ([x x] [shift shift])\n              \
    \                                 (cond [(zero? shift) (list->string (reverse\
    \ (list->string (number->string x))))]\n                                     \
    \                [else (loop (integer-parse (string-append (string-drop (number->string\
    \ x) 1)\n                                                                    \
    \                            (string-take (number->string x) 1)))\n          \
    \                                                (- shift 1))])))))))\n", "  (define\
    \ (loop x res acc)\n    (if (zero? x)\n        (number->string res)\n        (let*\
    \ ([d (remainder x 10)]\n               [x (quotient x 10)]\n               [res\
    \ (+ (* d (expt 10 acc)) res)])\n          (loop x res (+ acc 1)))))\n  (define\
    \ (reverse x)\n    (define (loop x res)\n      (if (zero? x)\n          (number->string\
    \ res)\n          (let* ([d (remainder x 10)]\n                 [x (quotient x\
    \ 10)]\n                 [res (+ (* d (expt 10 (sub1 shift))) res)])\n       \
    \     (loop x res))))\n    (if (>= shift (length (number->string x)))\n      \
    \  (loop x 0)\n        (let* ([n (loop x 0)]\n               [x (string->number\
    \ n)])\n          (loop x 0))))\n  (if (>= shift (length (number->string x)))\n\
    \      (reverse x)\n      (let* ([n (reverse x)]\n             [x (string->number\
    \ n)])\n        (loop x 0 shift))))\n", "  (let ([n (number->string x)])\n   \
    \ (if (> (string-length n) shift)\n        (string-append (substring n shift)\
    \ (substring n 0 shift))\n        (reverse n))))\n", "  (string->number (string-append\
    \ (reverse (number->string x)))))\n", "  (define digits (string->list (number->string\
    \ x)))\n  (define n-digits (length digits))\n  (define remainder (modulo shift\
    \ n-digits))\n  (define (shift-digits digits x)\n    (if (= x 0)\n        digits\n\
    \        (shift-digits (append (list (list-ref digits 0)) (sublist digits 1))\
    \ (- x 1))))\n  (define shifted-digits (shift-digits digits remainder))\n  (string-append\
    \ (sublist shifted-digits 0 n-digits) (sublist shifted-digits n-digits remainder)))\n",
  "  (number->string (reverse (number->string x))))\n", "  (regexp-replace* #rx\"\"\
    \n                   (number->string x)\n                   (\u03BB (digits)\n\
    \                     (if (> shift (string-length digits))\n                 \
    \        (string-reverse digits)\n                         (string-append (substring\
    \ digits shift)\n                                        (substring digits 0 shift))))))\n",
  "  (define (cs x shift s i)\n    (cond ((= i shift) (string-append s (number->string\
    \ x)))\n          ((= i 0) (cs (/ x 10) shift s (+ i 1)))\n          (else (cs\
    \ (/ x 10) shift (string-append s (substring (number->string x) (- i 1) i)) (+\
    \ i 1)))))\n  (cs x shift \"\" 0))\n", "  (define (rotate-numbers numbers i)\n\
    \    (append (reverse (sublist numbers 0 i))\n            (reverse (sublist numbers\
    \ i (length numbers)))))\n  (define (int->digits number)\n    (map (\u03BB (x)\
    \ (string->number (string x)))\n         (list->string (number->string number))))\n\
    \  (define (digits->int numbers)\n    (string->number (number->string numbers)))\n\
    \  (number->string (digits->int (rotate-numbers (int->digits x) shift))))\n\n",
  "  (regexp-replace* #rx\"\" (number->string x)\n                   (list #rx\"(?&lt;=(\\\
    d+))\" (number->string shift))))\n", "  (string->number (circular_shift-string\
    \ (number->string x) shift)))\n", "  (let* ([len (length (number->string x))]\n\
    \         [shift (if (> shift len)\n                    (- len shift)\n      \
    \              shift)])\n    (string-append (substring (number->string x) shift)\n\
    \                   (substring (number->string x) 0 shift))))\n", "  (number->string\n\
    \   (number->string x\n                   10\n                   #:base #t)\n\
    \   10\n   #:base #t\n   #:precision shift))\n", "  (define (rec n r rs)\n   \
    \ (if (= n 0)\n        rs\n        (rec (quotient n 10)\n             (+ (* 10\
    \ (remainder n 10)) r)\n             (string-append (number->string (remainder\
    \ n 10)) rs))))\n  (define digs (rec x 0 \"\"))\n  (if (> (string-length digs)\
    \ shift)\n      (string-append (substring digs shift) (substring digs 0 shift))\n\
    \      (reverse digs)))\n", "  (let ([shift (modulo shift (number->string x length))])\n\
    \    (number->string (modulo (string->number (reverse (cdr (string-split (number->string\
    \ x) \"\"))))\n                            (expt 10 shift)))))\n", "  (define\
    \ (int-to-list x)\n    (if (= x 0)\n        (list 0)\n        (reverse (int-to-list-aux\
    \ x))))\n  (define (int-to-list-aux x)\n    (if (= x 0)\n        empty\n     \
    \   (cons (% x 10) (int-to-list-aux (/ x 10)))))\n  (define (list-to-int lst)\n\
    \    (reverse lst))\n  (define (list-remove i lst)\n    (if (= i 0)\n        (cdr\
    \ lst)\n        (cons (car lst) (list-remove (- i 1) (cdr lst)))))\n  (define\
    \ (list-add i x lst)\n    (if (= i 0)\n        (cons x lst)\n        (cons (car\
    \ lst) (list-add (- i 1) x (cdr lst)))))\n  (define (reverse-list lst)\n    (reverse\
    \ lst))\n  (let ([lst (int-to-list x)])\n    (if (> shift (length lst))\n    \
    \    (list->string (reverse-list lst))\n        (let ([lst-start (list-remove\
    \ shift lst)]\n              [lst-end (reverse-list (sublist lst 0 shift))])\n\
    \          (list->string (append lst-start lst-end))))))\n", "  (define count\
    \ 0)\n  (define shifted '())\n  (define x-len 0)\n  (define x-str (string->list\
    \ (number->string x)))\n  (define x-str-len (length x-str))\n  (cond ((<= shift\
    \ x-str-len)\n         (let ((n (- x-str-len shift)))\n           (append (take\
    \ x-str n) (drop x-str shift))))\n        (else (reverse x-str))))", "  (if (<\
    \ shift 1)\n      (show x)\n      (show (reversed-integer (modulo x (expt 10 shift))\
    \ (quotient x (expt 10 shift))))))\n", "  (let* ([digits (string->list (number->string\
    \ x))]\n         [digits-rev (reverse digits)])\n    (list->string\n     (if (>\
    \ shift (length digits))\n         digits-rev\n         (append (drop shift digits-rev)\n\
    \                 (take shift digits-rev))))))\n", "  (define digits (string->list\
    \ (number->string x)))\n  (if (> shift (length digits))\n      (list->string (reverse\
    \ digits))\n      (append (drop digits shift) (take digits shift))))\n", "  (displayln\
    \ \"DEBUG: x = \" x)\n  (displayln \"DEBUG: shift = \" shift)\n  (string->number\
    \ (string-join (list-tail (append (string->list (number->string x)) (string->list\
    \ (number->string x))) shift) \"\")))\n", "  (define digit-list (list->string\
    \ (reverse (list->string x))))\n  (define num-digits (string-length digit-list))\n\
    \  (define shift-less (modulo shift num-digits))\n  (string-append (substring\
    \ digit-list shift-less num-digits)\n                 (substring digit-list 0\
    \ shift-less)))\n", "  (define (digits x)\n    (cond\n      [(zero? x) '()]\n\
    \      [else (cons (remainder x 10) (digits (quotient x 10)))]))\n  (define (reverse-digits\
    \ x)\n    (if (zero? x)\n        '()\n        (append (reverse-digits (quotient\
    \ x 10)) (list (remainder x 10)))))\n  (define (shift-digits x shift)\n    (if\
    \ (zero? shift)\n        (list->string (reverse-digits x))\n        (append (reverse-digits\
    \ (quotient x 10)) (list (remainder x 10)))))\n  (shift-digits x shift))\n", " \
    \ (if (zero? x) \"\"\n      (if (> shift (number->string x).length)\n        (reverse\
    \ (number->string x))\n        (let* ([d (string->number (string-ref (number->string\
    \ x) shift))]\n               [ds (string-append (number->string d)\n        \
    \                          (circular_shift (exact-floor (quotient x (expt 10 shift)))\n\
    \                                                  (+ shift 1)))]\n          \
    \     [s (string-append (string-drop (number->string x) (add1 shift))\n      \
    \                           (string-take (number->string x) (add1 shift)))])\n\
    \          (string-append ds s)))))\n", "  (define digits (number->string x))\n\
    \  (let ([len (string-length digits)])\n    (if (< shift len)\n        (let ([r\
    \ (substring digits shift len)])\n          (string-append r (substring digits\
    \ 0 shift)))\n        (reverse digits))))\n", "  (define (shifted-digits x shift)\n\
    \    (let ((digits (list->string (number->list x 10)))\n          (shift (modulo\
    \ shift (number->string x 10))))\n      (string-append (substring digits shift)\n\
    \                     (substring digits 0 shift))))\n  (string->number (shifted-digits\
    \ x shift) 10))\n", "  (define (concat-reverse-int x y)\n    (define (concat-reverse-int-helper\
    \ x y s)\n      (if (zero? x) s\n        (concat-reverse-int-helper (quotient\
    \ x 10) (modulo x 10)\n                                   (string-append s (number->string\
    \ y)))))\n    (concat-reverse-int-helper x y \"\"))\n  (define (concat-reverse-int-truncate\
    \ x y len)\n    (if (>= len 0)\n        (concat-reverse-int-truncate (quotient\
    \ x 10) (modulo x 10) (- len 1))\n        (concat-reverse-int-int x y)))\n  (if\
    \ (> shift 0)\n      (define reverse-int (concat-reverse-int x (quotient x (expt\
    \ 10 shift))))\n      (define reverse-int (concat-reverse-int-truncate x (quotient\
    \ x (expt 10 shift)) (- shift))))\n  (define (concat-shift-int x y s)\n    (if\
    \ (zero? y) s\n      (concat-shift-int (quotient y 10) (modulo y 10)\n       \
    \                 (string-append s (number->string x)))))\n  (concat-shift-int\
    \ (quotient x (expt 10 shift)) (modulo x (expt 10 shift)) \"\"))\n", "  (if (zero?\
    \ shift)\n      (number->string x)\n      (let* ([digits (string->list (number->string\
    \ x))]\n             [last-index (sub1 (length digits))]\n             [first-index\
    \ (if (< shift last-index) last-index shift)])\n        (list->string (list-tail\
    \ digits first-index) digits first-index))))\n", "  (define (helper dig lst)\n\
    \    (if (null? lst)\n        dig\n        (helper (string-append dig (list (car\
    \ lst))) (cdr lst))))\n  (define (helper2 lst1 lst2)\n    (if (null? lst1)\n \
    \       lst2\n        (helper2 (cdr lst1) (cons (car lst1) lst2))))\n  (define\
    \ (digit_length x)\n    (if (= x 0)\n        0\n        (+ 1 (digit_length (/\
    \ x 10)))))\n  (define (circular_shift_helper x shift rest)\n    (if (= rest 0)\n\
    \        (helper (list (modulo x 10)) (circular_shift_helper (/ x 10) shift (-\
    \ rest 1)))\n        (if (= shift 0)\n            (list (modulo x 10))\n     \
    \       (circular_shift_helper (/ x 10) (- shift 1) (- rest 1)))))\n  (if (= x\
    \ 0)\n      (string-append (list (modulo x 10)))\n      (if (> shift (digit_length\
    \ x))\n          (helper (list (modulo x 10)) (helper2 (circular_shift_helper\
    \ (/ x 10) 0 (- (digit_length x) 1)) '()))\n          (helper (list (modulo x\
    \ 10)) (circular_shift_helper (/ x 10) (- shift 1) (- (digit_length x) 1))))))\n",
  "  (define (digits x)\n    (if (= x 0) '()\n        (cons (remainder x 10) (digits\
    \ (quotient x 10)))))\n  (define (reversed-digits x)\n    (reverse (digits x)))\n\
    \  (define (shift-rec lst shift)\n    (cond\n      ((zero? shift) lst)\n     \
    \ ((null? lst) '())\n      (else (shift-rec (append (rest lst) (list (first lst)))\
    \ (- shift 1)))))\n  (list->string (shift-rec (reversed-digits x) shift)))\n\n",
  "  (if (equal? shift 0)\n      (number->string x)\n      (begin\n        (define\
    \ y (string->number (string-append (substring (number->string x) (- shift)) (substring\
    \ (number->string x) 0 (- shift)))))\n        (string-append (substring (number->string\
    \ y) 0 (- shift)) (substring (number->string y) (- shift)))\n      )\n  )\n)\n",
  "  (define digits (string->list (number->string x)))\n  (define num_digits (length\
    \ digits))\n  (cond ((<= shift num_digits)\n         (list->string (append (drop\
    \ shift digits) (take shift digits))))\n        (else (reverse digits))))\n",
  "  (number->string (modulo (expt 10 shift) (expt 10 (+ 1 (number->string x).length)))))\n",
  "  (if (zero? x)\n      \"0\"\n      (let loop ([x x] [shift shift] [str \"\"])\n\
    \        (if (zero? x)\n            str\n            (loop (quotient x 10) (quotient\
    \ shift 10) (string-append (number->string (remainder x 10)) str))))))\n", " \
    \ (define (circular_shift_iter x shift result)\n    (if (= shift 0)\n        result\n\
    \        (circular_shift_iter\n         (floor (/ x 10))\n         (- shift 1)\n\
    \         (format \"~a~a\" (remainder x 10) result))))\n  (define (num_digits\
    \ x)\n    (define (num_digits_iter n x)\n      (if (= x 0)\n          n\n    \
    \      (num_digits_iter (+ n 1) (floor (/ x 10)))))\n    (num_digits_iter 0 x))\n\
    \  (let ((n (num_digits x)))\n    (if (> shift n)\n        (string-reverse (number->string\
    \ x))\n        (circular_shift_iter x shift \"\"))))\n", "  (define (shift-r n\
    \ shift)\n    (number->string\n     (if (>= shift (string-length (number->string\
    \ n)))\n         (integer-invert n)\n         (integer-invert (modulo (shift-digits\
    \ n shift) (expt 10 (string-length (number->string n))))))))\n  (shift-r x shift))\n",
  "  (define (rev-last-n x n)\n    (if (= n 0)\n        (list->string (reverse x))\n\
    \        (rev-last-n (cons (last x) (butlast x)) (- n 1))))\n  (define (rev-first-n\
    \ x n)\n    (reverse (rev-last-n (reverse x) n)))\n  (let ([str-x (number->string\
    \ x)])\n    (if (> shift (string-length str-x))\n        (reverse str-x)\n   \
    \     (string-append (rev-first-n str-x shift) (rev-last-n str-x shift)))))\n",
  "  (define digits (integer->string x))\n  (define len (string-length digits))\n\
    \  (cond ((> shift len)\n         (reverse digits))\n        (else\n         (string-append\
    \ (substring digits shift len)\n                        (substring digits 0 shift)))))\n",
  "  (if (= shift 0)\n      (number->string x)\n      (string-reverse\n       (regexp-replace*\
    \ #rx(^.*?(.))\n                       (number->string x)\n                  \
    \     #:replace (lambda (m)\n                                   (regexp-replace*\
    \ #rx(.*)\n                                                   (string-append (regexp-match*\
    \ #rx(.) (cdr m))\n                                                          \
    \        (car m))\n                                                   #:replace\
    \ (lambda (m2)\n                                                             \
    \  (string-append (regexp-match* #rx(.*) (cdr m2))\n                         \
    \                                                     (regexp-match* #rx(.) (cdr\
    \ m2)))))\n                                   )))\n       )))\n", "  (define (shift-digit-recur\
    \ x shift digits)\n    (if (&lt; x 10)\n        (string-append digits (number-&gt;string\
    \ x))\n        (shift-digit-recur (/ x 10) shift (string-append digits (number-&gt;string\
    \ (modulo x 10))))))\n  (let ([s (shift-digit-recur x shift \"\")])\n    (if (&lt;\
    \ shift (string-length s))\n        (string-append (substring s shift) (substring\
    \ s 0 shift))\n        (string-reverse s))))\n", "  (cond ((> shift (number->string\
    \ x) (length (number->string x))))\n        (display (number->string (reverse\
    \ (number->string x))))\n        (newline)\n        (display (number->string (shift-right\
    \ (number->string x) shift))))\n      (else (display (number->string (shift-right\
    \ (number->string x) shift))))))\n", "  (define (reverse s)\n    (cond\n     \
    \ [(empty? s) empty]\n      [else (append (reverse (rest s)) (list (first s)))]))\n\
    \  (define (shift s)\n    (cond\n      [(< shift (length s)) (append (drop s shift)\
    \ (take s shift))]\n      [else (reverse s)]))\n  (shift (string->list (number->string\
    \ x))))\n", "  (define x-s (number->string x))\n  (if (< shift (string-length\
    \ x-s))\n      (apply string (substring x-s shift) (substring x-s 0 shift))\n\
    \      (string-reverse x-s)))\n", "  (let* ([digs (string->list (number->string\
    \ x))]\n         [digs-len (length digs)])\n    (if (> shift digs-len)\n     \
    \   (apply string (reverse digs))\n        (apply string (append (drop shift digs)\
    \ (take shift digs))))))\n", "  (define (split x shift)\n    (let\n      ((str\
    \ (number->string x))\n       (len (string-length str)))\n      (values (substring\
    \ str 0 (- len shift))\n              (substring str (- len shift)))))\n  (define\
    \ (join a b)\n    (string-append b a))\n  (define (reversed-split x)\n    (let\n\
    \      ((str (number->string x)))\n      (values (substring str 0 -1)\n      \
    \        (substring str -1))))\n  (if (< shift (string-length (number->string\
    \ x)))\n      (apply join (split x shift))\n      (apply join (reversed-split\
    \ x))))\n", "  (string->number\n   (string-append\n    (substring (number->string\
    \ x) shift)\n    (substring (number->string x) 0 shift))))\n", "  (string->number\n\
    \   (string-append\n    (substring (number->string x) shift)\n    (substring (number->string\
    \ x) 0 shift))))\n", "  (string->number (substring (integer->string x) shift)\n\
    \                  (substring (integer->string x) 0 shift)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
