name: HumanEval_40_triples_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; triples_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns True if there are three distinct elements in the list that\n;; sum\
  \ to zero, and False otherwise.\n;; >>> triples_sum_to_zero([1, 3, 5, 0])\n;; False\n\
  ;; >>> triples_sum_to_zero([1, 3, -2, 1])\n;; True\n;; >>> triples_sum_to_zero([1,\
  \ 2, 3, 7])\n;; False\n;; >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n;; True\n\
  ;; >>> triples_sum_to_zero([1])\n;; False\n(define (triples_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 5 -1)) #f)\n    (check-equal? (candidate (list 1 3 -2 1)) #t)\n    (check-equal?\
  \ (candidate (list 1 2 3 7)) #f)\n    (check-equal? (candidate (list 1 2 5 7)) #f)\n\
  \    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)\n    (check-equal? (candidate\
  \ (list 1)) #f)\n    (check-equal? (candidate (list 1 3 5 -100)) #f)\n    (check-equal?\
  \ (candidate (list 100 3 5 -100)) #f)\n))\n\n(test-humaneval)"
completions: ["  (define (helper l-aux)\n    (if (or (= (length l-aux) 1)\n      \
    \      (= (length l-aux) 2))\n        #f\n        (if (= (+ (list-ref l-aux 0)\
    \ (list-ref l-aux 1) (list-ref l-aux 2)) 0)\n            #t\n            (helper\
    \ (cdr l-aux)))))\n  (helper l))\n", "  (cond [(null? l) #f]\n        [(and (member\
    \ 0 l) (member -1 l) (member 1 l)) #t]\n        [else (triples_sum_to_zero (cdr\
    \ l))]))\n", "  (check-expect (triples_sum_to_zero '()) false)\n  (check-expect\
    \ (triples_sum_to_zero '(1 3 5 0)) false)\n  (check-expect (triples_sum_to_zero\
    \ '(1 3 -2 1)) true)\n  (check-expect (triples_sum_to_zero '(1 2 3 7)) false)\n\
    \  (check-expect (triples_sum_to_zero '(2 4 -5 3 9 7)) true)\n  (check-expect\
    \ (triples_sum_to_zero '(1)) false)\n  (define (sort l)\n    (cond\n      [(empty?\
    \ l) empty]\n      [else\n        (define x (first l))\n        (define rest (sort\
    \ (rest l)))\n        (cond\n          [(empty? rest) (cons x empty)]\n      \
    \    [(< x (first rest)) (cons x rest)]\n          [else (cons (first rest) (cons\
    \ x (rest rest)))]\n        )\n      ]\n    )\n  )\n  (define (sum-to-zero? a\
    \ b c)\n    (= (+ a b c) 0)\n  )\n  (define (triples-helper l)\n    (cond\n  \
    \    [(or (empty? l) (empty? (rest l)) (empty? (rest (rest l)))) false]\n    \
    \  [(sum-to-zero? (first l) (first (rest l)) (first (rest (rest l)))) true]\n\
    \      [else (triples-helper (rest l))]\n    )\n  )\n  (triples-helper (sort l))\n\
    )\n", "  (for/or ([a l]\n           [b l]\n           [c l])\n    (not (= a b\
    \ c))\n    (= 0 (+ a b c))))\n", "  (let loop ([l l] [i 0])\n    (cond [(and (not\
    \ (empty? l)) (< i (sub1 (length l))))\n           (if (or (and (= (first l) (second\
    \ l)) (= (second l) (third l)))\n                   (and (= (first l) (second\
    \ l)) (= (second l) (fourth l)))\n                   (and (= (first l) (third\
    \ l)) (= (third l) (fourth l)))\n                   (and (= (second l) (third\
    \ l)) (= (third l) (fourth l))))\n               (loop (rest l) (add1 i))\n  \
    \             (or (or (or (or (and (= (first l) (second l)) (= (third l) 0))\n\
    \                               (and (= (first l) (third l)) (= (second l) 0)))\n\
    \                           (and (= (first l) (fourth l)) (= (third l) 0)))\n\
    \                       (and (= (second l) (third l)) (= (fourth l) 0)))\n   \
    \                (and (= (second l) (fourth l)) (= (third l) 0)))))]\n       \
    \   [else #f])))\n", "    (define (sum3 l)\n        (cond [(empty? l) #f]\n  \
    \            [(empty? (rest l)) #f]\n              [(empty? (rest (rest l))) #f]\n\
    \              [(= (apply + (take 3 l)) 0) #t]\n              [else (sum3 (rest\
    \ l))]))\n    (define (helper l)\n        (cond [(empty? l) #f]\n            \
    \  [(sum3 l) #t]\n              [else (helper (rest l))]))\n    (helper l))\n",
  "  (let ([list-size (list-length l)])\n    (and\n     (not (= list-size 1))\n  \
    \   (and\n      (and\n       (not (= list-size 2))\n       (and\n        (and\n\
    \         (not (= list-size 3))\n         (and\n          (and\n           (not\
    \ (= list-size 4))\n           (and\n            (and\n             (not (= list-size\
    \ 5))\n             (and\n              (and\n               (not (= list-size\
    \ 6))\n               (and\n                (and\n                 (not (= list-size\
    \ 7))\n                 (and\n                  (and\n                   (not\
    \ (= list-size 8))\n                   (and\n                    (and\n      \
    \               (not (= list-size 9))\n                     (and\n           \
    \           (and\n                       (not (= list-size 10))\n            \
    \           (and\n                        (and\n                         (not\
    \ (= list-size 11))\n                         (and\n                         \
    \ (and\n                           (not (= list-size 12))\n                  \
    \         (and\n                            (and\n                           \
    \  (not (= list-size 13))\n                             (and\n               \
    \               (and\n                               (not (= list-size 14))\n\
    \                               (and\n                                (and\n \
    \                                (not (= list-size 15))\n                    \
    \             (and\n                                  (and\n                 \
    \                  (not (= list-size 16))\n                                  \
    \ (and\n                                    (and\n                           \
    \          (not (= list-size 17))\n                                     (and\n\
    \                                      (and\n                                \
    \       (not (= list-size 18))\n                                       (and\n\
    \                                        (and\n                              \
    \           (not (= list-size 19))\n                                         (and\n\
    \                                          (and\n                            \
    \               (not (= list-size 20))\n                                     \
    \      (and\n                                            (and\n              \
    \                               (not (= list-size 21))\n                     \
    \                        (and\n                                              (and\n\
    \                                               (not (= list-size 22))\n     \
    \                                          (and\n                            \
    \                    (and\n                                                 (not\
    \ (= list-size 23))\n                                                 (and\n \
    \                                                 (and\n                     \
    \                              (not (= list-size 24))\n                      \
    \                             (and\n                                         \
    \           (and\n                                                     (", " \
    \ (define (helper l)\n    (if (empty? l)\n        #f\n        (or (list? (member\
    \ (sub1 (first l)) l))\n            (list? (member (sub1 (first l)) (rest l)))\n\
    \            (list? (member (sub1 (first l)) (rest (rest l))))\n            (helper\
    \ (rest l)))))\n  (helper l))\n", "  (cond\n    [(empty? l) #f]\n    [(length\
    \ l) 1]\n    [(length l) 2]\n    [else (sum_to_zero? l)]))\n", "  (if (< (length\
    \ l) 3)\n      #f\n      (or (member 0 l)\n          (let* ((negatives (filter\
    \ (lambda (a) (< a 0)) l))\n                 (positives (filter (lambda (a) (>\
    \ a 0)) l))\n                 (neg-sets (all-sets-of-len-n negatives 2))\n   \
    \              (pos-sets (all-sets-of-len-n positives 2)))\n            (any (lambda\
    \ (pair)\n                   (member (apply + pair) positives))\n            \
    \     neg-sets)))))\n", "  ;; find all possible triples\n  (define (triples l)\n\
    \    (if (= 1 (length l))\n        (list (list (car l)))\n        (map (lambda\
    \ (t) (cons (car l) t)) (triples (cdr l)))))\n  ;; make all triples distinct\n\
    \  (define (distinct_triples triples)\n    (filter (lambda (t) (distinct? t))\
    \ triples))\n  ;; check if any triple sums to zero\n  (define (triple_sum_to_zero?\
    \ triples)\n    (if (null? triples)\n        #f\n        (if (= 0 (apply + (car\
    \ triples)))\n            #t\n            (triple_sum_to_zero? (cdr triples)))))\n\
    \  (triple_sum_to_zero? (distinct_triples (triples l))))\n", "  ;; Write your\
    \ code here.\n  )\n", "  (cond\n    [(empty? l) false]\n    [(= (length l) 1)\
    \ false]\n    [(= (length l) 2) (= (first l) (last l))]\n    [else\n     (or\n\
    \      (and (= (first l) -(+ (second l) (third l))) true)\n      (triples_sum_to_zero\
    \ (rest l)))]))\n```\n\n- [`triples_sum_to_zero.rkt`][rkt]\n\n### Design\n\nThere\
    \ are a couple of basic design decisions to consider when defining\n`triples_sum_to_zero`.\n\
    \n1.  *How do we check for a triplet?* The most obvious approach is to\n    iterate\
    \ over the elements and check every combination of three\n    elements. However,\
    \ this is an \\( O(n^3) \\) operation, and it does\n    not make use of the fact\
    \ that the elements of the list are\n    integers.\n\n2.  *How do we deal with\
    \ the empty list?* There are multiple ways to\n    handle this situation:\n\n\
    \    -   We could return `false`. This is the approach that makes the\n      \
    \  most sense to me, because it doesn\u2019t matter whether the list is\n    \
    \    empty or not: no triplet is ever possible in this case.\n\n    -   We could\
    \ return `true`. This would make sense if we thought of\n        the empty list\
    \ as a \u201Ctrivial triplet\u201D.\n\n    -   We could raise an error, because\
    \ the empty list is not a valid\n        input.\n\n3.  *How do we deal with lists\
    \ of length 1 or 2?* We could assume\n    that the input will always be a list\
    \ of length at least 3, and\n    raise an error otherwise. This would be one more\
    \ check for the\n    caller to make.\n\n4.  *Do we need to check for duplicates?*\
    \ In Python, duplicates are\n    removed from lists, so there is no need to check\
    \ for duplicates\n    here. In Racket, lists are [sets][racket-set], so duplicates\
    \ are\n    automatically removed.\n\n5.  *How do we check for a triplet?* One\
    \ approach would be to iterate\n    over the elements and check", "  (if (empty?\
    \ l)\n      #f\n      (if (empty? (rest l))\n          #f\n          (if (empty?\
    \ (rest (rest l)))\n              #f\n              (let ((sum (+ (first l) (first\
    \ (rest l)) (first (rest (rest l))))))\n                (if (= sum 0)\n      \
    \              #t\n                    (triples_sum_to_zero (rest l))))))))\n",
  "  ;; check if the list is long enough to begin with\n  (if (>= (length l) 3)\n\
    \      ;; check if any three elements sum to zero\n      (if (or (and (= (first\
    \ l) 0) (= (second l) 0) (= (third l) 0))\n              (and (= (first l) 0)\
    \ (= (second l) (third l)) (= (third l) 0))\n              (and (= (first l) (second\
    \ l)) (= (second l) (third l)) (= (third l) 0))\n              (and (= (first\
    \ l) (second l)) (= (second l) 0) (= (third l) 0))\n              (and (= (first\
    \ l) 0) (= (second l) (third l)) (= (third l) 0))\n              (and (= (first\
    \ l) (second l)) (= (second l) 0) (= (third l) 0))\n              (and (= (first\
    \ l) 0) (= (second l) 0) (= (third l) 0))\n              (and (= (first l) 0)\
    \ (= (second l) 0) (= (third l) 0))\n              (and (= (first l) 0) (= (second\
    \ l) 0) (= (third l) 0))\n              (and (= (first l) 0) (= (second l) 0)\
    \ (= (third l) 0))\n              (and (= (first l) 0) (= (second l) 0) (= (third\
    \ l) 0))\n              (and (= (first l) 0) (= (second l) 0) (= (third l) 0))\n\
    \              (and (= (first l) 0) (= (second l) 0) (= (third l) 0))\n      \
    \        (and (= (first l) 0) (= (second l) 0) (= (third l) 0))\n            \
    \  (and (= (first l) 0) (= (second l) 0) (= (third l) 0))\n              (and\
    \ (= (first l) 0) (= (second l) 0) (= (third l) 0))\n              (and (= (first\
    \ l) 0) (= (second l) 0) (= (third l) 0))\n              (and (= (first l) 0)\
    \ (= (second l) 0) (= (third l) 0))\n              (and (= (first l) 0", "  (if\
    \ (= (length l) 3)\n      (let ((a (car l))\n            (b (cadr l))\n      \
    \      (c (caddr l)))\n        (= (+ a b c) 0))\n      (or (triples_sum_to_zero\
    \ (list (car l) (cadr l) (caddr l)))\n          (triples_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [(empty? l)\n     false]\n    [(empty? (cdr l))\n     false]\n   \
    \ [(empty? (cddr l))\n     false]\n    [else\n     (local\n       ((define (sum\
    \ x y z)\n          (+ x y z))\n        (define (triple l)\n          (and\n \
    \           (equal?\n              0\n              (sum (car l) (cadr l) (caddr\
    \ l)))\n            (and\n              (not (equal? (car l) (cadr l)))\n    \
    \          (not (equal? (car l) (caddr l)))\n              (not (equal? (cadr\
    \ l) (caddr l)))))))\n       (cond\n         [(triple l)\n          true]\n  \
    \       [else\n          (triples_sum_to_zero (cdr l))]))]))\n", "  ;; no triple\
    \ sums to zero in an empty list or a list with one element\n  (if (or (null? l)\
    \ (null? (cdr l)))\n      #f\n      ;; if there is a pair that sums to zero, then\
    \ there is a triple that\n      ;; sums to zero, so just check for pairs that\
    \ sum to zero\n      (or (has_pair_sum_to_zero l)\n          ;; the list has at\
    \ least two elements,\n          ;; so we can check for pairs that sum to zero\n\
    \          ;; in the list without the first element,\n          ;; and then in\
    \ the list without the last element\n          (triples_sum_to_zero (cdr l))\n\
    \          (triples_sum_to_zero (butlast l))))))\n", "  (define (sum l)\n    (cond\n\
    \      [(empty? l) 0]\n      [else (+ (first l) (sum (rest l)))]))\n  (cond\n\
    \    [(empty? l) (error \"the list is empty!\")]\n    [(< (length l) 3) (error\
    \ \"the list is too short!\")]\n    [(sum l) false]\n    [else true]))\n", " \
    \ (define (triples l n m)\n    (if (or (= n m) (= n (+ m 1)))\n        #f\n  \
    \      (if (= 0 (+ (list-ref l n) (list-ref l m)))\n            #t\n         \
    \   (triples l n (+ m 1)))))\n  (define (all_pairs l n)\n    (if (= n (- (length\
    \ l) 1))\n        #f\n        (or (triples l n (+ n 1))\n            (all_pairs\
    \ l (+ n 1)))))\n  (if (= 0 (length l))\n      #f\n      (all_pairs l 0)))\n",
  "  (if (or (&lt; (length l) 3) (not (distinct? l)))\n      #f\n      (find_sum_to_zero\
    \ 0 (length l) l)))\n", "  (cond ((null? l) false)\n        ((< (length l) 3)\
    \ false)\n        ((= (length l) 3)\n         (or (and (equal? (car l) 0) (equal?\
    \ (cadr l) 0) (equal? (caddr l) 0))\n             (and (equal? (car l) 0) (equal?\
    \ (cadr l) (caddr l)) (not (equal? (cadr l) 0)))\n             (and (equal? (car\
    \ l) (cadr l)) (equal? (cadr l) (caddr l)) (not (equal? (car l) 0)))))\n     \
    \   (else (and (not (null? (combinations l 3)))\n                   (not (null?\
    \ (filter (lambda (y) (equal? (sum y) 0)) (combinations l 3))))))))\n", "  (cond\n\
    \    [(empty? l) false]\n    [(empty? (rest l)) false]\n    [(empty? (rest (rest\
    \ l))) false]\n    [else\n     (cond\n       [(zero? (+ (first l) (first (rest\
    \ l)) (first (rest (rest l))))) true]\n       [else (triples_sum_to_zero (rest\
    \ l))])]))\n", "  (if (or (empty? l) (empty? (cdr l)) (empty? (cddr l)))\n   \
    \   #f\n      (if (and (zero? (+ (car l) (cadr l) (caddr l)))\n              \
    \ (not (and (equal? (car l) (cadr l))\n                        (equal? (car l)\
    \ (caddr l)))))\n          #t\n          (triples_sum_to_zero (cdr l)))))\n",
  "  (cond\n    [(and (equal? (length l) 1) (not (member 0 l)))\n     false]\n   \
    \ [(and (equal? (length l) 2) (not (member 0 l)))\n     false]\n    [(and (equal?\
    \ (length l) 3) (not (member 0 l)))\n     false]\n    [(and (member 0 l) (not\
    \ (equal? (length l) 3)))\n     false]\n    [(and (member 0 l) (equal? (length\
    \ l) 3))\n     true]\n    [(= (length l) 3)\n     (let ([a (car l)]\n        \
    \   [b (cadr l)]\n           [c (caddr l)])\n       (if (and (equal? (+ a b c)\
    \ 0) (not (equal? a b)) (not (equal? a c)) (not (equal? b c)))\n           true\n\
    \           false))]\n    [else\n     (or (triples_sum_to_zero (cdr l))\n    \
    \     (triples_sum_to_zero (cdr (cdr l)))\n         (triples_sum_to_zero (cdr\
    \ (cdr (cdr l)))))\n     ]))\n", "  (cond ((not (pair? l)) False)\n        ((and\
    \ (member? (car l) (cdr l)) (member? (car l) (cddr l))) True)\n        (else (triples_sum_to_zero\
    \ (cdr l)))))\n", "  (cond\n    [(empty? l) false]\n    [(< (length l) 3) false]\n\
    \    [else\n     (and\n      (member 0 (lst-sum (take l 3)))\n      (triples_sum_to_zero\
    \ (rest l)))]))\n", "  (cond [(empty? l) false]\n        [(and (equal? (length\
    \ l) 3) (equal? (apply + l) 0)) true]\n        [else (or (triples_sum_to_zero\
    \ (cdr l))\n                  (triples_sum_to_zero (append (list (car l)) (cddr\
    \ l))))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (cdr l)) #f]\n    [(empty?\
    \ (cddr l)) #f]\n    [(= (list-ref l 0)\n        (+ (list-ref l 1)\n         \
    \  (list-ref l 2)))\n     #t]\n    [else (triples_sum_to_zero (cdr l))]))\n```\n\
    \n```racket\n#lang racket\n", "  (define (check_two_nums n l)\n    (if (empty?\
    \ l)\n        #f\n        (if (= (- n (first l)) 0)\n            #t\n        \
    \    (check_two_nums n (rest l)))))\n  (if (empty? l)\n      #f\n      (if (check_two_nums\
    \ (first l) (rest l))\n          #t\n          (triples_sum_to_zero (rest l)))))\n",
  "  (if (= 3 (length l))\n      (if (= (sum l) 0)\n          #t\n          #f)\n\
    \      (if (= 0 (length l))\n          #f\n          (or (triples_sum_to_zero\
    \ (cons (first l) (rest (rest l))))\n              (triples_sum_to_zero (rest\
    \ l))))))\n", "  (cond [(= (length l) 1) False]\n        [(= (length l) 2) False]\n\
    \        [(= (length l) 3)\n         (if (= (+ (car l) (cadr l) (caddr l)) 0)\
    \ True False)]\n        [else (or (triples_sum_to_zero (cdr l))\n            \
    \      (triples_sum_to_zero (list (car l) (cadr l) (caddr l))))]))\n", "  (define\
    \ (helper l1 l2)\n    (cond\n      [(or (null? l1) (null? l2)) false]\n      [(=\
    \ 0 (+ (car l1) (car l2))) (or (helper (cdr l1) (cdr l2))\n                  \
    \                     (helper (cdr l1) l2)\n                                 \
    \      (helper l1 (cdr l2)))]\n      [else (or (helper (cdr l1) (cdr l2))\n  \
    \              (helper (cdr l1) l2)\n                (helper l1 (cdr l2)))]))\n\
    \  (helper l l))\n", "  (cond\n    [(empty? l) false]\n    [(and (and (= (first\
    \ l) (second l)) (not (empty? (cddr l)))) (= (first l) (third l)))\n     true]\n\
    \    [(or (or (= (first l) (second l)) (not (empty? (cddr l)))) (= (first l) (third\
    \ l)))\n     (triples_sum_to_zero (rest l))]\n    [(or (or (= (second l) (third\
    \ l)) (not (empty? (cddr l)))) (= (first l) (third l)))\n     (triples_sum_to_zero\
    \ (rest l))]\n    [else\n     (if (and (not (empty? (cddr l))) (= (first l) (third\
    \ l)))\n       (triples_sum_to_zero (rest l))\n       (if (and (not (empty? (cddr\
    \ l))) (= (second l) (third l)))\n         (triples_sum_to_zero (rest l))\n  \
    \       (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and", "  (or (and (not (null? l)) (triples_sum_to_zero\
    \ (cdr l)))\n      (and (not (null? (cdr l)))\n           (and (not (null? (cddr\
    \ l)))\n                (zero? (+ (car l) (cadr l) (caddr l)))))))\n", "  (cond\n\
    \    [(empty? l) false]\n    [(= 3 (length l)) (zero? (apply + l))]\n    [else\
    \ (or (triples_sum_to_zero (cdr l))\n              (triples_sum_to_zero (map (lambda\
    \ (x) (+ x (car l)))\n                                        (cdr l))))]))\n",
  "  (and (not (= (length l) 1))\n       (flatten (map (lambda (x)\n             \
    \          (map (lambda (y)\n                              (map (lambda (z)\n\
    \                                     (= (+ x y z) 0))\n                     \
    \              l))\n                            l))\n                     l))))\n",
  "  (local [(define (triples_sum_to_zero_helper l)\n           (cond [(null? l) #f]\n\
    \                 [(and (in-list? (car l) (cdr l))\n                       (in-list?\
    \ (- (car l)) (cdr l))) #t]\n                 [else (triples_sum_to_zero_helper\
    \ (cdr l))]))]\n    (triples_sum_to_zero_helper l)))\n", "  (let ([n (length l)])\n\
    \    (cond\n      [(>= n 3)\n       (or\n         (and (member 0 l)\n        \
    \      (let ([pos-l (filter (lambda (x) (> x 0)) l)]\n                    [neg-l\
    \ (filter (lambda (x) (< x 0)) l)])\n                (and (member (car pos-l)\
    \ neg-l)\n                     (member (- (car pos-l) (car neg-l)) pos-l))))\n\
    \         (and (let ([s (sum l)])\n                 (member s l))\n          \
    \    (let ([s2 (/ s 2)])\n                (and (member s2 l)\n               \
    \      (member (if (= (remainder s 2) 0) (- s2) (- s2)) l)))))]\n      [else\n\
    \       #f])))\n", "  (local [(define (iter l)\n            (if (null? l)\n  \
    \              false\n                (if (null? (cdr l))\n                  \
    \  false\n                    (if (null? (cddr l))\n                        false\n\
    \                        (let ((a (car l))\n                              (b (cadr\
    \ l))\n                              (c (caddr l)))\n                        \
    \  (if (= (+ a b c) 0)\n                              true\n                 \
    \             (iter (cdr l))))))))]\n    (iter l)))\n", "  (letrec ([helper (lambda\
    \ (a b c)\n                     (cond [(or (not (pair? a)) (not (pair? b)) (not\
    \ (pair? c))) #f]\n                           [(zero? (+ (car a) (car b) (car\
    \ c))) #t]\n                           [else (or (helper (cdr a) b c)\n      \
    \                               (helper a (cdr b) c)\n                       \
    \              (helper a b (cdr c)))]))])\n    (helper l l l)))\n\n", "  ;; i,\
    \ j, k are three indices, i < j < k < length l\n  ;; l[i] + l[j] + l[k] = 0\n\
    \  ;; if l[i] + l[j] + l[k] != 0 for i in 0..length l, j in i..length l, k in\
    \ j..length l:\n  ;;     l[i] + l[j] + l[k] != 0\n  ;; elif l[i] + l[j] + l[k]\
    \ == 0 for i in 0..length l, j in i..length l, k in j..length l:\n  ;;     l[i]\
    \ + l[j] + l[k] == 0\n  ;; if there is no i in 0..length l, j in i..length l,\
    \ k in j..length l such that l[i] + l[j] + l[k] == 0:\n  ;;     l[i] + l[j] +\
    \ l[k] != 0\n  ;; elif there is at least one i in 0..length l, j in i..length\
    \ l, k in j..length l such that l[i] + l[j] + l[k] == 0:\n  ;;     l[i] + l[j]\
    \ + l[k] == 0\n  ;; l[i] + l[j] + l[k] != 0 for i in 0..length l, j in i..length\
    \ l, k in j..length l\n  ;; it is not true that l[i] + l[j] + l[k] == 0 for i\
    \ in 0..length l, j in i..length l, k in j..length l\n  ;; \xAC(l[i] + l[j] +\
    \ l[k] == 0 for i in 0..length l, j in i..length l, k in j..length l)\n  ;; not\
    \ any?(\u03BBx.(x == 0), map(\u03BBi.(\u03BBj.(\u03BBk.(l[i] + l[j] + l[k]))),\
    \ range(0, length l), range(0, length l), range(0, length l)))\n  (not (any? (\u03BB\
    \ (x) (= x 0)) (map (\u03BB (i", "  (and (not (eq? (length l) 3))\n       (or\n\
    \        (and (equal? (last l) (last (butlast l)))\n             (triples_sum_to_zero\
    \ (butlast l)))\n        (and (equal? (+ (car l) (car (cdr l)) (car (cddr l)))\
    \ 0)\n             #t)\n        (triples_sum_to_zero (cdr l)))))\n", "  (check-expect\
    \ (triples_sum_to_zero '(1 3 5 0)) #f)\n  (check-expect (triples_sum_to_zero '(1\
    \ 3 -2 1)) #t)\n  (check-expect (triples_sum_to_zero '(1 2 3 7)) #f)\n  (check-expect\
    \ (triples_sum_to_zero '(2 4 -5 3 9 7)) #t)\n  (check-expect (triples_sum_to_zero\
    \ '(1)) #f)\n  (let loop ((lst l) (found #f))\n    (cond\n      [(null? lst) found]\n\
    \      [(zero? (add3 (car lst) (cadr lst) (caddr lst))) (loop (cdr lst) #t)]\n\
    \      [else (loop (cdr lst) found)])))\n", "  (check-expect (triples_sum_to_zero\
    \ (list 1 3 5 0)) #f)\n  (check-expect (triples_sum_to_zero (list 1 3 -2 1)) #t)\n\
    \  (check-expect (triples_sum_to_zero (list 1 2 3 7)) #f)\n  (check-expect (triples_sum_to_zero\
    \ (list 2 4 -5 3 9 7)) #t)\n  (check-expect (triples_sum_to_zero (list 1)) #f)\n\
    \  (or (null? l)\n      (and (find3 0 l) #t)\n      (triples_sum_to_zero (rest\
    \ l))))\n", "  (let ([length (length l)])\n    (cond\n      [(<= length 2) false]\n\
    \      [(and (= (modulo length 3) 0) (every (lambda (i) (= 0 i)) l)) true]\n \
    \     [else (let ([l (map (lambda (i) (if (= 0 i) 1 0)) l)])\n              (letrec\
    \ ([sum-to-zero? (lambda (a b)\n                                       (if (and\
    \ (not (member a l)) (not (member b l)))\n                                   \
    \        true\n                                           (cond\n            \
    \                                 [(member a l) (sum-to-zero? (+ a b) b)]\n  \
    \                                           [(member b l) (sum-to-zero? a (+ a\
    \ b))]\n                                             [else (or (sum-to-zero? (+\
    \ a b) b)\n                                                       (sum-to-zero?\
    \ a (+ a b)))])))]\n                         [sum-to-zero?-iter (lambda (i j)\n\
    \                                              (if (= j length)\n            \
    \                                      false\n                               \
    \                   (or (sum-to-zero? (list-ref l i) (list-ref l j))\n       \
    \                                               (sum-to-zero?-iter i (+ j 1)))))]\n\
    \                         [sum-to-zero?-iter-start (lambda (i)\n             \
    \                                       (if (= i (- length 2))\n             \
    \                                           false\n                          \
    \                              (or (sum-to-zero?-iter i (+ i 1))\n           \
    \                                                 (sum-to-zero?-iter-start (+\
    \ i 1))))])\n                (sum-to-zero?-iter-start 0))))])))\n", "  (and (pair?\
    \ l) (pair? (cdr l)) (pair? (cddr l))\n       (or (and (= (car l) 0)\n       \
    \         (or (= (car (cdr l)) 0) (= (car (cddr l)) 0)))\n           (and (= (car\
    \ (cdr l)) 0) (= (car (cddr l)) 0))\n           (and (not (= (car l) 0))\n   \
    \             (not (= (car (cdr l)) 0))\n                (not (= (car (cddr l))\
    \ 0))\n                (= (+ (car l) (car (cdr l)) (car (cddr l))) 0)))))", " \
    \ (define s (sort l &lt;))\n  (or (and (or (= (length s) 3) (= (length s) 4))\n\
    \           (= (add3 (car s) (car (cdr s)) (car (cdr (cdr s)))) 0))\n      (triples_sum_to_zero\
    \ (cdr s))))\n", "  (define (help l)\n    (if (empty? l)\n        (values #f #f)\n\
    \        (let ((a (first l))\n              (b (second l))\n              (c (third\
    \ l)))\n          (if (and (member* -a l)\n                   (member* (- a b)\
    \ l))\n              (values #t #t)\n              (help (rest l))))))\n  (define\
    \ (rest l)\n    (if (empty? l)\n        (values #f #f)\n        (let ((a (first\
    \ l))\n              (b (second l))\n              (c (third l)))\n          (if\
    \ (and (member* -a l)\n                   (member* (- a b) l))\n             \
    \ (values #t #t)\n              (rest (rest l))))))\n  (values (help l) (rest\
    \ l)))\n", "  (cond ((null? l) #f)\n        ((= 3 (length l)) (or (= 0 (apply\
    \ + l)) (triples_sum_to_zero (cdr l))))\n        (else (triples_sum_to_zero (cdr\
    \ l)))))\n", "  (if (empty? l)\n      #f\n      (let ((last_pair (last-pair l)))\n\
    \        (if (empty? (cdr last_pair))\n            #f\n            (or (sum-of-first-two-equal-third\
    \ (car l)\n                                              (cadr l)\n          \
    \                                    (caddr l))\n                (triples_sum_to_zero\
    \ (cdr l)))))))\n", "  (cond\n    [(empty? l) false]\n    [(and (equal? 0 (first\
    \ l))\n          (not (empty? (rest l)))\n          (equal? 0 (second l))\n  \
    \        (not (empty? (rest (rest l))))\n          (equal? 0 (third l)))\n   \
    \  true]\n    [else (triples_sum_to_zero (rest l))]))\n", "  (if (< (length l)\
    \ 3)\n      #f\n      (define (sum-to-zero? l)\n        (if (null? l)\n      \
    \      #f\n            (if (and (member 0 l)\n                     (not (null?\
    \ (cdr l))))\n                #t\n                (sum-to-zero? (cdr l)))))\n\
    \      (if (sum-to-zero? l)\n          #t\n          (triples_sum_to_zero (cdr\
    \ l)))))\n```\n\n```racket\n#lang racket\n", "  (and (member 0 l) (not (null?\
    \ l))))\n", "  (cond\n    [(null? l) #f]\n    [(not (list? l)) (error \"must be\
    \ a list!\")]\n    [(list? l)\n     (define triplets (for/list ((a l) (b l) (c\
    \ l))\n                        (if (and (not (eq? a b)) (not (eq? a c)) (not (eq?\
    \ b c)))\n                            (list a b c))))\n     (define target-triplet\
    \ (filter (lambda (x) (= (apply + x) 0)) triplets))\n     (if (null? target-triplet)\
    \ #f #t)]))\n", "  (cond\n    [(empty? l) false]\n    [(>= (length l) 3) (or (sum-of-three?\
    \ (first l) (second l) (third l))\n                           (triples_sum_to_zero\
    \ (rest l)))]\n    [else false]))\n", "  (if (length l) < 3\n      False\n   \
    \   (define (triples_sum_to_zero_helper l f s t)\n        (if (and (empty? l)\
    \ (zero? (+ f s t)))\n            True\n            (if (and (empty? l) (not (zero?\
    \ (+ f s t))))\n                False\n                (triples_sum_to_zero_helper\
    \ (rest l) (first l) s t)))))\n  (triples_sum_to_zero_helper (rest (rest l)) (first\
    \ l) (second l) (third l)))", "  (cond\n    [(null? l) #f]\n    [(zero? (sum (take\
    \ l 3))) #t]\n    [else (triples_sum_to_zero (cdr l))]))", "  (define (triples_sum_to_zero_helper\
    \ l f)\n    (cond\n      [(empty? l) #f]\n      [(empty? (rest l)) #f]\n     \
    \ [(empty? (rest (rest l))) #f]\n      [(and (not (eq? (first l) (first (rest\
    \ l))))\n            (not (eq? (first l) (first (rest (rest l)))))\n         \
    \   (not (eq? (first (rest l)) (first (rest (rest l)))))\n            (eq? (first\
    \ l) (f (first (rest l)) (first (rest (rest l)))))\n            (eq? (first l)\
    \ 0))\n       #t]\n      [else (triples_sum_to_zero_helper (rest l) f)]))\n  (triples_sum_to_zero_helper\
    \ l -))\n", "  (define (sum-to-zero? sub-l)\n    (cond [(empty? sub-l) #f]\n \
    \         [(= (sum sub-l) 0) #t]\n          [else (sum-to-zero? (rest sub-l))]))\n\
    \  (cond [(empty? l) #f]\n        [(sum-to-zero? (rest l)) #t]\n        [else\
    \ (triples_sum_to_zero (rest l))]))\n", "  (if (<= (length l) 2)\n      (begin\
    \ (display \"False\")\n             (newline))\n      (cond ((list-of-three-distinct-sum-to-zero\
    \ l)\n             (begin (display \"True\")\n                    (newline)))\n\
    \            (else (begin (display \"False\")\n                       (newline))))))\n",
  "  (cond [(empty? l) false]\n        [(and (member (list-ref l 0) (rest l))\n  \
    \            (member (list-ref l 0) (rest (rest l))))\n         (or (triples_sum_to_zero\
    \ (rest l)) true)]\n        [(and (member (list-ref l 0) (rest l))\n         \
    \     (member (- (list-ref l 0) (list-ref l 1)) (rest (rest l))))\n         (or\
    \ (triples_sum_to_zero (rest l)) true)]\n        [else (triples_sum_to_zero (rest\
    \ l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(and (empty? (rest l)) (empty?\
    \ (rest (rest l)))) #f]\n    [(or\n       (and (= (apply + (first l) (first (rest\
    \ l)) (first (rest (rest l)))) 0)\n            (not (= (first l) (first (rest\
    \ l)) (first (rest (rest l)))))\n            (not (= (first l) (first (rest (rest\
    \ l)))))\n            (not (= (first (rest l)) (first (rest (rest l)))))\n   \
    \         )\n       (triples_sum_to_zero (rest l))\n       (triples_sum_to_zero\
    \ (rest (rest l)))\n       (triples_sum_to_zero (rest (rest (rest l))))\n    \
    \   )\n     #t]\n    [else #f]\n    )\n  )\n", "  (if (zero? (length l))\n   \
    \   #f\n      (triples_sum_to_zero-helper (list (list (car l)) (list)) (cdr l))))\n",
  "  ;; ...\n  )\n", "  (cond\n    [(or (null? l) (< (length l) 3)) #f]\n    [(and\
    \ (member (first l) (rest l)) (member (- (first l)) (rest l))) #t]\n    [else\
    \ (triples_sum_to_zero (rest l))]))\n", "  (define (helper l ijk)\n    (cond [(null?\
    \ l) #f]\n          [(zero? (apply + ijk)) #t]\n          [(positive? (apply +\
    \ ijk)) (helper (cdr l) (cdr ijk))]\n          [else (helper (cdr l) (cons (car\
    \ l) ijk))]))\n  (helper l (list 0 0 0)))\n```\n\n```lisp", "  (if (< (length\
    \ l) 3)\n      (error \"list too short\")\n      (define (triples-sum-to-zero-helper\
    \ l-helper)\n        (if (null? l-helper)\n            #f\n            (let ([num1\
    \ (car l-helper)]\n                  [num2 (cadr l-helper)]\n                \
    \  [num3 (caddr l-helper)])\n              (or (= (+ num1 num2 num3) 0)\n    \
    \              (triples-sum-to-zero-helper (cdr l-helper))))))\n      (triples-sum-to-zero-helper\
    \ l)))\n", "  (cond [(empty? l) false]\n        [(or (or (and (member (car l)\
    \ (cdr l))\n                      (member (- (car l)) (cdr l)))\n            \
    \     (and (member (car l) (cdr l))\n                      (member (- (car l))\
    \ (cdr l))))\n             (triples_sum_to_zero (cdr l)))\n         true]\n  \
    \      [else false]))\n", "  (cond\n    [(empty? l) #f]\n    [(<= (length l) 2)\
    \ #f]\n    [(zero? (apply + (subset l 3))) #t]\n    [else (triples_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(triples_sum_to_zero? l)\
    \ #t]\n    [else (triples_sum_to_zero (rest l))]))\n", "  (or (and (member 0 l)\
    \ (member 0 l) (member 0 l))\n      (and (member -1 l) (member 1 l) (member 0\
    \ l))\n      (and (member -2 l) (member 2 l) (member 0 l))\n      (and (member\
    \ -3 l) (member 3 l) (member 0 l))\n      (and (member -4 l) (member 4 l) (member\
    \ 0 l))\n      (and (member -5 l) (member 5 l) (member 0 l))\n      (and (member\
    \ -6 l) (member 6 l) (member 0 l))\n      (and (member -7 l) (member 7 l) (member\
    \ 0 l))\n      (and (member -8 l) (member 8 l) (member 0 l))\n      (and (member\
    \ -9 l) (member 9 l) (member 0 l))\n      (and (member -2 l) (member 1 l) (member\
    \ 1 l))\n      (and (member -3 l) (member 2 l) (member 1 l))\n      (and (member\
    \ -4 l) (member 3 l) (member 1 l))\n      (and (member -5 l) (member 4 l) (member\
    \ 1 l))\n      (and (member -6 l) (member 5 l) (member 1 l))\n      (and (member\
    \ -7 l) (member 6 l) (member 1 l))\n      (and (member -8 l) (member 7 l) (member\
    \ 1 l))\n      (and (member -9 l) (member 8 l) (member 1 l))\n      (and (member\
    \ -3 l) (member 2 l) (member 2 l))\n      (and (member -4 l) (member 3 l) (member\
    \ 2 l))\n      (and (member -5 l) (member 4 l) (member 2 l))\n      (and (member\
    \ -6 l) (member 5 l) (member 2 l))\n      (and (member -7 l) (member 6 l) (member\
    \ 2 l))\n      (and (member -8 l) (member 7 l) (member 2 l))\n      (and (member\
    \ -9 l) (member 8 l) (member 2 l))\n      (and (member -4 l) (", "  ;; your code\
    \ here\n  #f)\n```\n\n## Art\n\n```\n#lang racket", "  (define (has_triple lst)\n\
    \    (cond\n      [(null? lst) #f]\n      [(and (mem (car lst) (cdr lst)) (mem\
    \ (- (car lst)) (cdr lst))) #t]\n      [else (has_triple (cdr lst))]))\n  (cond\n\
    \    [(null? l) #f]\n    [(has_triple l) #t]\n    [else (triples_sum_to_zero (cdr\
    \ l))]))\n", "  (if (null? l)\n      #f\n      (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or (or\
    \ (or (or (or (or (or (or (or (or (or (or (or (or (", "  (cond\n    [(empty? l)\
    \ false]\n    [(or (= (length l) 1) (= (length l) 2)) false]\n    [else\n    \
    \ (cond\n       [(= (length l) 3)\n        (if (and (>= (car l) 0) (>= (cadr l)\
    \ 0) (>= (caddr l) 0))\n            (or (= (car l) 0) (= (cadr l) 0) (= (caddr\
    \ l) 0))\n            (or (<= (car l) 0) (<= (cadr l) 0) (<= (caddr l) 0)))]\n\
    \       [else\n        (let ([fst (car l)]\n              [snd (cadr l)]\n   \
    \           [trd (caddr l)])\n          (cond\n            [(>= fst 0) (triples_sum_to_zero\
    \ (list snd trd (apply + (cdddr l))))]\n            [(<= fst 0) (triples_sum_to_zero\
    \ (list snd trd (apply - (cdddr l))))]))])]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(empty? (rest (rest l))) #f]\n    [(zero? (+\
    \ (first l) (first (rest l)) (first (rest (rest l))))) #t]\n    [else (triples_sum_to_zero\
    \ (rest l))]))\n\n", "  (define (helper subl)\n    (if (empty? subl)\n       \
    \ false\n        (define (helper2 subl2)\n          (if (empty? subl2)\n     \
    \         false\n              (define (helper3 subl3)\n                (if (empty?\
    \ subl3)\n                    false\n                    (or (and (= (+ (first\
    \ subl) (first subl2) (first subl3)) 0)\n                             (or (and\
    \ (first subl) (first subl2) (first subl3)) true))\n                        (helper3\
    \ (rest subl3)))))\n              (or (helper3 (rest subl2))\n               \
    \   (helper2 (rest subl2)))))\n        (or (helper2 (rest subl))\n           \
    \ (helper (rest subl)))))\n  (helper l))\n```\n\n```\n#lang racket\n", "  (cond\
    \ ((null? l) false)\n        ((member 0 (intersection2 l l)) true)\n        (else\
    \ (triples_sum_to_zero (cdr l)))))\n", "  (triples_sum_to_zero_inner l 0))\n",
  "  (define (helper lista)\n    (cond\n      [(null? lista) #f]\n      [(= (apply\
    \ + (take 3 lista)) 0) #t]\n      [else (helper (rest lista))]))\n  (cond\n  \
    \  [(> (length l) 2) (helper l)]\n    [else #f]))\n", "  (cond ((or (not (list?\
    \ l))\n             (= (length l) 0))\n         #f)\n        ((= (length l) 1)\n\
    \         #f)\n        ((= (length l) 2)\n         #f)\n        ((= (length l)\
    \ 3)\n         (and (not (= (car l) (cadr l)))\n              (not (= (car l)\
    \ (caddr l)))\n              (not (= (cadr l) (caddr l)))\n              (= (+\
    \ (car l) (cadr l) (caddr l)) 0)))\n        (else\n         (or (triples_sum_to_zero\
    \ (cdr l))\n             (triples_sum_to_zero (cddr l))))))\n\n", "  (define (iter\
    \ l c)\n    (if (empty? l) #f\n        (define (helper r_l)\n          (if (empty?\
    \ r_l) #f\n              (let ([a (first l)]\n                    [b (first r_l)])\n\
    \                (if (or (= a b) (= a (* -1 b))) #f\n                    (if (=\
    \ (+ a b) 0) #t\n                        (helper (rest r_l)))))))\n      (or (helper\
    \ (rest l)) (iter (rest l) (+ c 1)))))\n  (iter l 0))\n", "  (define (run l)\n\
    \    (cond\n      [(null? l) #f]\n      [(member* (sub1 (car l)) (sub1 (cdr l)))\
    \ #t]\n      [else (run (cdr l))]))\n  (if (run l)\n      #t\n      #f))\n", " \
    \ (define (triples_sum_to_zero_rec l)\n    (if (empty? l)\n        #f\n      \
    \  (or (zero? (+ (first l) (second l) (third l)))\n            (triples_sum_to_zero_rec\
    \ (rest l)))))\n  (if (&lt; (length l) 3)\n      #f\n      (triples_sum_to_zero_rec\
    \ l)))\n", "  (if (empty? l)\n      #f\n      (if (empty? (cdr l))\n         \
    \ #f\n          (if (empty? (cddr l))\n              #f\n              (let ([x\
    \ (car l)]\n                    [y (cadr l)]\n                    [z (caddr l)])\n\
    \                (if (and (not (= x y))\n                         (not (= x z))\n\
    \                         (not (= y z)))\n                    (if (= (+ x y z)\
    \ 0)\n                        #t\n                        (triples_sum_to_zero\
    \ (cdr l)))\n                    (triples_sum_to_zero (cdr l))))))))\n\n", " \
    \ (let loop ([l l] [h (hash)])\n    (cond [(empty? l) #f]\n          [(zero? (hash-ref\
    \ h (car l) (lambda () 0)))\n           (let ([prev (loop (cdr l) (hash-set h\
    \ (car l) (add1 (hash-ref h (car l) (lambda () 0)))))]\n                 [curr\
    \ (hash-ref h (car l) (lambda () 0))])\n             (if (and (equal? curr 2)\
    \ (not (empty? (cdr l))))\n                 (loop (cdr l) (hash-set h (car l)\
    \ (add1 (hash-ref h (car l) (lambda () 0)))))\n                 prev))]\n    \
    \      [else (loop (cdr l) (hash-set h (car l) (add1 (hash-ref h (car l) (lambda\
    \ () 0)))))])))\n", "  (define (triples l n)\n    (cond ((< n 2) l)\n        \
    \  ((null? l) empty)\n          (else (append (append (map (lambda (x) (cons (car\
    \ l) x))\n                                      (triples (cdr l) (- n 1)))\n \
    \                               (triples (cdr l) n))\n                       \
    \   (triples (cdr l) (- n 2))))))\n  (not (null? (filter (lambda (l) (= (apply\
    \ + l) 0))\n                      (triples l 3)))))\n", "  (cond [(null? l) #f]\n\
    \        [(and (not (null? (cdr l))) (not (null? (cddr l))))\n         (cond [(=\
    \ 0 (+ (car l) (cadr l) (caddr l))) #t]\n               [else (triples_sum_to_zero\
    \ (cdr l))])]\n        [else (triples_sum_to_zero (cdr l))]))\n", "  (if (null?\
    \ l) #f\n      (if (= 3 (length l)) (equal? 0 (apply + l))\n          (triples_sum_to_zero\
    \ (list (car l) (cadr l) (caddr l))))))\n", "  (define (sums_to_zero x y)\n  \
    \  (= (+ x y) 0))\n  (define (member? item l)\n    (cond ((null? l) #f)\n    \
    \      ((equal? item (car l)) #t)\n          (else (member? item (cdr l)))))\n\
    \  (if (< (length l) 3)\n      #f\n      (let* ((first-elem (car l))\n       \
    \      (rest-elems (cdr l))\n             (second-elem (car rest-elems))\n   \
    \          (other-elems (cdr rest-elems)))\n        (if (member? (* -1 first-elem)\
    \ other-elems)\n            #t\n            (triples_sum_to_zero rest-elems)))))\n",
  "  (cond [(empty? l) #f]\n        [(empty? (rest l)) #f]\n        [(empty? (rest\
    \ (rest l))) #f]\n        [(and (number? (first l))\n              (number? (second\
    \ l))\n              (number? (third l))\n              (zero? (+ (first l) (second\
    \ l) (third l)))) #t]\n        [else (triples_sum_to_zero (rest l))]))\n", " \
    \ (cond ((= (length l) 1) #f)\n        ((zero? (length l)) #f)\n        ((= (length\
    \ l) 2) #f)\n        ((= (length l) 3)\n         (or (= (first l) (second l))\n\
    \             (= (second l) (third l))\n             (= (first l) (third l))))\n\
    \        (else (or (triples_sum_to_zero (rest l))\n                  (triples_sum_to_zero\
    \ (rest (rest l)))\n                  (triples_sum_to_zero (rest (rest (rest l))))))))\n",
  "  (cond\n    [(or (= (length l) 0) (= (length l) 1) (= (length l) 2)) False]\n\
    \    [(or (= (length l) 3) (> (length l) 3))\n     (let ((a (list-ref l 0))\n\
    \           (b (list-ref l 1))\n           (c (list-ref l 2)))\n       (and (not\
    \ (= a b))\n            (not (= a c))\n            (not (= b c))\n           \
    \ (or (= (+ a b c) 0)\n                (triples_sum_to_zero (cdr l)))))\n    \
    \ ]))\n", "  (cond [(or (empty? l) (empty? (rest l)) (empty? (rest (rest l))))\
    \ #f]\n        [(zero? (+ (car l) (car (rest l)) (car (rest (rest l))))) #t]\n\
    \        [else (triples_sum_to_zero (rest l))]))\n", "  (define (inner l)\n  \
    \  (cond [(empty? l) false]\n          [(= (length l) 1) false]\n          [(=\
    \ (length l) 2) false]\n          [(= (length l) 3) (or (= (sum (car l) (cadr\
    \ l) (caddr l)) 0) false)]\n          [else (or (sum (car l) (cadr l) (caddr l))\
    \ (inner (cdr l)))]))\n  (inner l))\n", "  (define (triples_sum_to_zero_helper\
    \ l s)\n    (cond ((null? l) #f)\n          ((null? (cdr l)) #f)\n          ((null?\
    \ (cddr l)) #f)\n          ((and (= (- (car l) (cadr l)) (car s))\n          \
    \      (= (car s) (- (caddr l) (cadr l))))\n           #t)\n          (else (triples_sum_to_zero_helper\
    \ (cdr l) s))))\n  (triples_sum_to_zero_helper l (map (lambda (x) (- 0 x)) l)))\n",
  "  (cond [(empty? l) False]\n        [(empty? (cdr l)) False]\n        [(empty?\
    \ (cddr l)) False]\n        [(and (not (empty? (cdddr l))) (equal? (sum3 l) 0))\
    \ True]\n        [else (triples_sum_to_zero (cdr l))]))\n", "  (if (null? l)\n\
    \      #f\n      (triples_sum_to_zero_helper l (cdr l) (cddr l))))\n", "  (define\
    \ (walk l p1)\n    (cond [(null? l) false]\n          [(and (number? p1) (number?\
    \ (car l)) (number? (cadr l)))\n           (or (= (+ p1 (car l) (cadr l)) 0)\n\
    \               (walk (cdr l) p1))]\n          [else (walk (cdr l) (car l))]))\n\
    \  (walk l #f))\n```\n\n```racket\n#lang racket\n", "  (define (aux l)\n    (cond\
    \ ((null? l) #f)\n          ((and (member (sum (car l)) (cdr l))\n           \
    \     (member (- (sum (car l))) (cdr l)))\n           #t)\n          (else (aux\
    \ (cdr l)))))\n  (and (list? l) (aux l)))\n", "  ;; 2 cases\n  ;; 1. three distinct\
    \ elements in the list sum to zero\n  ;; 2. no such three elements\n  ;; if a\
    \ list has less than 3 elements, return false\n  (if (<= (length l) 2)\n     \
    \ #f\n      ;; else use helper function to find if 3 elements in the list sum\
    \ to zero\n      (let loop ([sorted l])\n        (cond\n          [(= (length\
    \ sorted) 3) (triples_sum_to_zero_helper sorted)]\n          [else (loop (cdr\
    \ sorted))]))))\n", "  (let ([n (length l)])\n    (and (or (= n 0) (= n 1) (=\
    \ n 2))\n         (let loop ([i 0])\n           (cond\n             [(= i (- n\
    \ 3)) #f]\n             [(let* ([i1 (+ i 1)]\n                     [i2 (+ i 1)])\n\
    \                (and (not (member (+ (list-ref l i) (list-ref l i1) (list-ref\
    \ l i2)) l))\n                     (loop (+ i 1))))]\n             [else #t])))))\n",
  "  (cond\n    [(null? l) false]\n    [(null? (cdr l)) false]\n    [(null? (cddr\
    \ l)) false]\n    [(and (zero? (+ (car l) (cadr l) (caddr l)))\n          (= 3\
    \ (length l)))\n     true]\n    [else (triples_sum_to_zero (cdr l))]))\n", " \
    \ (cond\n    [(empty? l) false]\n    [(and (empty? (rest l)) (empty? (rest (rest\
    \ l)))) false]\n    [(and (empty? (rest l)) (empty? (rest (rest (rest l))))) false]\n\
    \    [(+ (list-ref l 0) (list-ref l 1) (list-ref l 2)) true]\n    [else (triples_sum_to_zero\
    \ (rest l))]))\n", "  (cond [(empty? l) false]\n        [(and (in? (car l) (cdr\
    \ l))\n              (in? (- (car l)) (cdr l)))\n         true]\n        [else\
    \ (triples_sum_to_zero (cdr l))]))\n", "  (define (tr3sum l sum)\n    (cond ((empty?\
    \ l) false)\n          ((= sum 0) true)\n          (else (tr3sum (rest l) (+ sum\
    \ (first l))))))\n  (cond ((< (length l) 3) false)\n        ((tr3sum (rest l)\
    \ (first l)) true)\n        (else (triples_sum_to_zero (rest l)))))\n", "  (let\
    \ ([min-value (apply min l)]\n        [max-value (apply max l)])\n    (cond\n\
    \      [(or (empty? l) (= (length l) 1)) #f]\n      [(> min-value -1) #f]\n  \
    \    [(< max-value 1) #f]\n      [else (for/or ([i (in-range (- (length l) 2))]\n\
    \                     [j (in-range (+ i 1) (length l))]\n                    \
    \ [k (in-range (+ j 1) (length l))])\n              (and (not (equal? (list-ref\
    \ l i) (list-ref l j)))\n                   (not (equal? (list-ref l i) (list-ref\
    \ l k)))\n                   (not (equal? (list-ref l j) (list-ref l k)))\n  \
    \                 (= (+ (list-ref l i) (list-ref l j) (list-ref l k)) 0)))])))\n",
  "  (define (helper l)\n    (if (null? l)\n        #f\n        (let* ((el (car l))\n\
    \               (ll (cdr l))\n               (zl (append l (list el))))\n    \
    \      (if (null? ll)\n              #f\n              (let* ((el2 (car ll))\n\
    \                     (ll2 (cdr ll))\n                     (zl2 (append ll (list\
    \ el2))))\n                (if (null? ll2)\n                    #f\n         \
    \           (let* ((el3 (car ll2))\n                           (ll3 (cdr ll2))\n\
    \                           (zl3 (append ll2 (list el3))))\n                 \
    \     (cond ((= (+ el el2 el3) 0)\n                             #t)\n        \
    \                    ((null? ll3)\n                             #f)\n        \
    \                    (else\n                             (or (helper zl2)\n  \
    \                               (helper zl3)))))))))))\n  (helper l))\n", "  (equal?\
    \ (count (lambda (x) (equal? x 0))\n                (map + l l l))\n         \
    \ 3))\n```\n\n```\n#lang racket\n", "    (local [(define (subsets l acc)\n\t \
    \    (if (null? l)\n\t\t acc\n\t\t (subsets (cdr l)\n\t\t\t  (append (map (lambda\
    \ (x) (cons (car l) x)) acc)\n\t\t\t\t  (map (lambda (x) (cons (car l) x))\n\t\
    \t\t\t       (subsets (cdr l) acc))))))]\n\t    (cond [(null? l) false]\n\t\t\
    \  [(= (length l) 1) false]\n\t\t  [(= (length l) 2) false]\n\t\t  [else (ormap\
    \ (lambda (x) (and (member (car x) (cdr x))\n\t\t\t\t\t\t(member (cadr x) (cddr\
    \ x))))\n\t\t\t       (subsets l (list (list))))])))\n", "  (cond [(< (length\
    \ l) 3) #f]\n        [(zero? (+ (car l) (cadr l) (caddr l))) #t]\n        [else\
    \ (triples_sum_to_zero (cdr l))]))\n\n", "  (cond\n    [(null? l) #f]\n    [(equal?\
    \ 3 (length l)) (equal? 0 (+ (car l) (cadr l) (caddr l)))]\n    [else (or (triples_sum_to_zero\
    \ (cdr l))\n              (triples_sum_to_zero (cons (car l) (cddr l))))]))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (sum lst)\n    (cond\n      [(null?\
    \ lst) 0]\n      [else (+ (car lst) (sum (cdr lst)))]))\n  (define (is_empty?\
    \ lst)\n    (cond\n      [(null? lst) true]\n      [else false]))\n  (define (next\
    \ lst)\n    (cond\n      [(null? lst) #f]\n      [else (cons (cadr lst) (cddr\
    \ lst))]))\n  (define (inner lst)\n    (cond\n      [(null? lst) #f]\n      [(zero?\
    \ (sum lst)) #t]\n      [else (inner (next lst))]))\n  (define (outer lst)\n \
    \   (cond\n      [(null? lst) #f]\n      [(inner (cdr lst)) #t]\n      [else (outer\
    \ (cdr lst))]))\n  (cond\n    [(is_empty? l) #f]\n    [(= (length l) 1) #f]\n\
    \    [(outer l) #t]\n    [else #f]))\n", "  ;; remove this line\n  #f)\n", " \
    \ (cond [(empty? l) false]\n        [(= 3 (length l)) (= 0 (apply + l))]\n   \
    \     [else (or (triples_sum_to_zero (cons (first l) (cdr l)))\n             \
    \     (triples_sum_to_zero (cdr l)))]))\n\n", "  ;; `l' must be a list.  Its elements\
    \ may be numbers.\n  (if (zero? (length l))\n      false\n      (or (triples_sum_to_zero_aux\
    \ l)\n          (triples_sum_to_zero (cdr l)))))\n", "  ;; first, sort the list\n\
    \  (define (sort_list l)\n    (sort l <))\n  ;; then, for all elements in the\
    \ list, check the sublists to find their negatives\n  (define (check_sublists\
    \ l s)\n    (if (null? l)\n        false\n        (if (member ( + (car l) (car\
    \ s)) s)\n            true\n            (check_sublists (cdr l) s))))\n  (check_sublists\
    \ (sort_list l) (sort_list l)))\n", "  (cond\n    [(or (not (list? l)) (null?\
    \ l) (null? (cdr l)) (null? (cddr l))) #f]\n    [(sum3? (car l) (cadr l) (caddr\
    \ l)) #t]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  ;; add code here\n\
    \  (cond [(null? l) 'False]\n        [(and (not (null? (cdr l))) (not (null? (cddr\
    \ l))))\n         (if (zero? (+ (car l) (cadr l) (caddr l))) 'True 'False)]\n\
    \        [else (triples_sum_to_zero (cdr l))]))\n", "  (define (helper l)\n  \
    \  (if (null? l)\n        #f\n        (or (and (member (car l) (cdr l)) (member\
    \ (car l) (cddr l)))\n            (helper (cdr l)))))\n  (define (member x l)\n\
    \    (cond\n      [(null? l) #f]\n      [(= (car l) x) #t]\n      [else (member\
    \ x (cdr l))]))\n  (define (sum_to_zero x y z)\n    (= (car x) (car y) (car z)))\n\
    \  (and (and (and (<= (length l) 3) (not (equal? l '(1)))) #f)\n       (helper\
    \ l)))\n", "  (cond ((not (list? l)) #f)\n        ((and (= (length l) 3)\n   \
    \           (= (sum l) 0)) #t)\n        (else (or (triples_sum_to_zero (rest l))\n\
    \                  (triples_sum_to_zero (append (list (first l)) (rest (rest l))))))))\n",
  "  (cond\n    [(or (empty? l) (empty? (rest l)) (empty? (rest (rest l)))) #f]\n\
    \    [(= (sum (first l) (first (rest l)) (first (rest (rest l)))) 0) #t]\n   \
    \ [else (triples_sum_to_zero (rest l))]))\n", "  (define (sum3 l)\n    (if (<\
    \ (length l) 3)\n        #f\n        (if (= (apply + l) 0)\n            #t\n \
    \           (sum3 (cdr l)))))\n  (if (null? l)\n      #f\n      (or (sum3 l)\n\
    \          (triples_sum_to_zero (cdr l)))))\n", "  (cond\n    [(= (length l) 3)\n\
    \     (and\n       (not (= 0 (+ (car l) (cadr l) (caddr l))))\n       (not (=\
    \ (car l) (cadr l)))\n       (not (= (car l) (caddr l)))\n       (not (= (cadr\
    \ l) (caddr l))))]\n    [else\n     (or\n       (triples_sum_to_zero (cdr l))\n\
    \       (triples_sum_to_zero (list (car l) (cadr l) (caddr l))))]))\n", "  (cond\n\
    \    [(empty? l) false]\n    [(= (length l) 1) false]\n    [(= (length l) 2) false]\n\
    \    [else\n     (let ([num0 (first l)]\n           [num1 (second l)]\n      \
    \     [num2 (third l)])\n       (cond\n         [(= (+ num0 num1 num2) 0) true]\n\
    \         [else (triples_sum_to_zero (rest l))]))]))\n", "  (cond ((null? l) #f)\n\
    \        ((= 3 (length l)) (zero? (apply + l)))\n        (else (any? (lambda (e)\n\
    \                      (triples_sum_to_zero (remq e l)))\n                   \
    \ l))))\n", "  (define (rec l)\n    (define (triples l acc)\n      (cond\n   \
    \     [(empty? l)\n         acc]\n        [(empty? (rest l))\n         (rec (rest\
    \ (rest l)) (cons (cons (first l) (rest l)) acc))]\n        [(empty? (rest (rest\
    \ l)))\n         (rec (rest (rest (rest l))) (cons (cons (first l) (rest l)) acc))]\n\
    \        [else\n         (rec (rest (rest (rest l))) (cons (cons (first l) (rest\
    \ l)) acc))]))\n    (define (triples_sum_to_zero_rec lst)\n      (cond\n     \
    \   [(empty? lst)\n         false]\n        [(empty? (rest lst))\n         false]\n\
    \        [(empty? (rest (rest lst)))\n         false]\n        [(+ (first (first\
    \ lst)) (first (second lst)) (first (third lst)))\n         0]\n        [else\n\
    \         (triples_sum_to_zero_rec (rest lst))]))\n    (triples_sum_to_zero_rec\
    \ (triples l '())))\n  (rec l))", "  (define (zeros lst)\n    (andmap zero? lst))\n\
    \  (define (head-and-tail lst)\n    (cond\n      [(null? lst)\n       (error \"\
    List is empty\")]\n      [(null? (cdr lst))\n       (values (car lst) (cdr lst))]\n\
    \      [else\n       (values (car lst) (cdr lst))]))\n  (define (perms lst)\n\
    \    (cond\n      [(null? lst)\n       (error \"List is empty\")]\n      [(null?\
    \ (cdr lst))\n       (list lst)]\n      [else\n       (foldl (lambda (x y)\n \
    \               (append (map (lambda (l) (cons x l)) y) y))\n              (list\
    \ (list (car lst)))\n              (perms (cdr lst)))]))\n  (define (sum lst)\n\
    \    (apply + lst))\n  (ormap zeros (map sum (perms l))))\n", "  (cond ((null?\
    \ l) #f)\n        ((null? (cdr l)) #f)\n        ((null? (cddr l)) #f)\n      \
    \  ((and (= 0 (+ (car l) (cadr l) (caddr l)))\n              (not (equal? (car\
    \ l) (cadr l)))\n              (not (equal? (car l) (caddr l)))\n            \
    \  (not (equal? (cadr l) (caddr l))))\n         #t)\n        (else (triples_sum_to_zero\
    \ (cdr l)))))\n", "  (cond [(null? l) #f]\n        [(= 3 (length l))\n       \
    \  (if (= 0 (+ (car l) (cadr l) (caddr l)))\n             #t\n             #f)]\n\
    \        [else (or (triples_sum_to_zero (cdr l))\n                  (triples_sum_to_zero\
    \ (cddr l)))]))\n", "  (and (not (null? l))\n       (or (triples_sum_to_zero_addends\
    \ l)\n           (triples_sum_to_zero (cdr l)))))\n", "  (cond\n    [(empty? l)\
    \ #f]\n    [(three_sum_to_zero? l) #t]\n    [else (triples_sum_to_zero (rest l))]))\n",
  "  (and (> (length l) 2)\n       (let ([d (sort l <)])\n         (or (and (equal?\
    \ (+ (car d) (cadr d) (caddr d)) 0)\n                  #t)\n             (triples_sum_to_zero\
    \ (cdr d))))))\n\n", "  (cond\n    [(= (length l) 3) (zero? (+ (car l) (cadr l)\
    \ (caddr l)))]\n    [(= (length l) 2) #f]\n    [(= (length l) 1) #f]\n    [else\
    \ (or (triples_sum_to_zero (cons (car l) (cdr l)))\n              (triples_sum_to_zero\
    \ (cdr l)))]))\n", "  (letrec ([check-triple (lambda (i1 i2 i3) (= (+ i1 i2 i3)\
    \ 0))]\n           [check-triples (lambda (l1 l2 l3)\n                       \
    \     (cond [(empty? l1) #f]\n                                  [(check-triple\
    \ (first l1) (first l2) (first l3)) #t]\n                                  [else\
    \ (check-triples (rest l1) (rest l2) (rest l3))]))])\n    (cond [(empty? l) #f]\n\
    \          [(not (empty? (rest l))) (check-triples l (rest l) (rest (rest l)))]\n\
    \          [else #f])))\n", "  (cond [(empty? l)\n         false]\n        [(and\
    \ (list? l)\n              (equal? 3 (length l)))\n         (zero? (+ (first l)\
    \ (second l) (third l)))]\n        [else\n         (triples_sum_to_zero (rest\
    \ l))]))\n\n", "  (local [(define (helper lst)\n            (cond\n          \
    \    [(or (empty? lst) (null? lst)) #f]\n              [(and (member (list (car\
    \ lst) (cadr lst) (caddr lst))\n                            '((1 2 -3) (-2 3 1)\
    \ (-3 1 2)))\n                    (= (+ (car lst) (cadr lst) (caddr lst)) 0))\n\
    \               #t]\n              [else (helper (cdr lst))]))]\n    (helper l)))\n",
  "  (define (helper l1 l2)\n    (cond\n      [(empty? l1) #f]\n      [(empty? l2)\
    \ (helper (rest l1) (rest l1))]\n      [(zero? (+ (first l1) (first l2))) #t]\n\
    \      [else (helper l1 (rest l2))]))\n  (helper l l))\n", "  (foldl (lambda (acc\
    \ x)\n           (if (zero? (remainder (length (filter (lambda (n) (zero? (+ x\
    \ n))) l)) 2))\n               #t\n               acc))\n         #f\n       \
    \  l))\n```\n\n### Problem 3:\n\n```racket\n#lang racket\n", "  ;; Build set of\
    \ all pairs\n  (define pairs\n    (for/set ([i l]\n              [j l])\n    \
    \  (list i j)))\n  ;; We have a triple summing to zero if there is a pair that\
    \ sums to zero\n  ;; and a third element in the list to make the triple.\n  (define\
    \ has-pair-summing-to-zero?\n    (lambda (l)\n      (define (helper l i)\n   \
    \     (if (null? l)\n            #f\n            (if (= (car l) (- i))\n     \
    \           #t\n                (helper (cdr l) i))))\n      (helper l (- (car\
    \ l) (cadr l)))))\n  (for/or ([i l]\n           [j l]\n           [k l])\n   \
    \ (and (member (list i j) pairs)\n         (has-pair-summing-to-zero? (list i\
    \ j k)))))\n", "  (define (rec l)\n    (cond ((null? l) #f)\n          ((and (and\
    \ (member (car l) (cdr l))\n                     (member (- (car l)) (cdr l)))\n\
    \                (not (member (car l) (member (- (car l)) (cdr l)))))\n      \
    \     #t)\n          (else (rec (cdr l)))))\n  (rec l))\n", "  (define (helper\
    \ l)\n    (cond [(empty? l) (list)]\n          [(empty? (rest l)) (list)]\n  \
    \        [(empty? (rest (rest l))) (list)]\n          [else (append (list (list\
    \ (first l) (second l) (third l)))\n                        (helper (rest l)))]))\n\
    \  (if (zero? (apply + (filter (lambda (x) (not (empty? x))) (helper l))))\n \
    \     #t\n      #f))\n", "  (local [(define (triples_sum_to_zero-iter l s v)\n\
    \            (if (or (null? l) (null? (cdr l)) (null? (cdr (cdr l))))\n      \
    \          #f\n                (if (and (member (list (car l) (cadr l) (caddr\
    \ l)) s)\n                         (list (car l) (cadr l) (caddr l)))\n      \
    \              #t\n                    (triples_sum_to_zero-iter (cdr l) (cons\
    \ (list (car l) (cadr l) (caddr l)) s) (cons (list (car l) (cadr l) (caddr l))\
    \ v)))))\n          (define (sum l)\n            (if (null? l)\n             \
    \   0\n                (+ (car l) (sum (cdr l)))))\n          (define (member\
    \ x l)\n            (if (null? l)\n                #f\n                (if (equal?\
    \ x (car l))\n                    #t\n                    (member x (cdr l)))))\n\
    \          (define (equal? l1 l2)\n            (if (or (null? l1) (null? l2))\n\
    \                (and (null? l1) (null? l2))\n                (and (equal? (car\
    \ l1) (car l2)) (equal? (cdr l1) (cdr l2)))))\n          (define (length l)\n\
    \            (if (null? l)\n                0\n                (+ 1 (length (cdr\
    \ l)))))\n          (define (get-all-triples l s)\n            (if (or (null?\
    \ l) (null? (cdr l)) (null? (cdr (cdr l))))\n                s\n             \
    \   (get-all-triples (cdr l) (cons (list (car l) (cadr l) (caddr l)) s))))]\n\
    \    (cond\n      [(= (length l) 3) (if (= (sum l) 0) #t #f)]\n      [else (triples_sum_to_zero-iter\
    \ l (get-all-triples l '()) '())])))\n", "  (cond\n    [(empty? l) false]\n  \
    \  [(zero? (length l)) false]\n    [(zero? (length (cdr l))) false]\n    [(zero?\
    \ (length (cddr l))) false]\n    [else (triples_sum_to_zero_helper l)]))\n", " \
    \ (let recur ([l l] [r (in-list [])])\n    (cond [(and (= 3 (length l))\n    \
    \            (andmap number? l))\n           (let ([v (apply + l)])\n        \
    \     (if (= 0 v)\n                 #t\n                 (recur (rest l) (cons\
    \ v r))))]\n          [(not (empty? l))\n           (recur (rest l) r)]\n    \
    \      [else\n           #f])))\n", "  (cond [(empty? l) false]\n        [(= (length\
    \ l) 1) false]\n        [(= (length l) 2) false]\n        [else\n         (let\
    \ ([a (first l)]\n               [b (second l)]\n               [c (third l)])\n\
    \           (cond [(and (zero? (+ a b c)) (unique? (list a b c))) true]\n    \
    \             [else (triples_sum_to_zero (rest l))]))]))\n", "  (cond\n    [(null?\
    \ l) #f]\n    [(and (list? l) (not (null? (cdr l))))\n     (\n      (if \n   \
    \     (or\n          (member (car l) (cdr l))\n          (member (- (car l)) (cdr\
    \ l))\n        )\n        #t\n        (triples_sum_to_zero (cdr l))\n      )\n\
    \     )\n    ]\n    [else #f]\n  )\n)\n\n", "  (cond\n    [(or (null? l)\n   \
    \      (null? (cdr l))\n         (null? (cddr l)))\n     #f]\n    [(or (= (sum3\
    \ l) 0)\n         (triples_sum_to_zero (cdr l)))\n     #t]\n    [else\n     (triples_sum_to_zero\
    \ (cdr l))]))\n", "  (cond ((not (equal? (length l) 3)) false)\n        ((equal?\
    \ (apply + l) 0) true)\n        (else false)))\n", "  (or (and (equal? (list-ref\
    \ l 0) 0)\n           (equal? (list-ref l 1) 0)\n           (equal? (list-ref\
    \ l 2) 0))\n      (and (not (equal? (list-ref l 0) 0))\n           (not (equal?\
    \ (list-ref l 1) 0))\n           (not (equal? (list-ref l 2) 0))\n           (equal?\
    \ (+ (list-ref l 0) (list-ref l 1) (list-ref l 2)) 0))))\n", "  (cond ((empty?\
    \ l) #f)\n        ((= (length l) 1) #f)\n        ((= (length l) 2) #f)\n     \
    \   ((= (length l) 3) (or (zero? (+ (first l) (second l) (third l))) #f))\n  \
    \      (else (or (triples_sum_to_zero (rest l))\n                  (zero? (+ (first\
    \ l) (second l) (third l)))\n                  #f))))\n```\n\n```\n#lang racket\n",
  "  (cond ((and (and (and (and (= (length l) 3)\n                               (=\
    \ (length (remove-duplicates l)) 3))\n                          (not (zero? (car\
    \ l))))\n                     (not (zero? (cadr l))))\n                (not (zero?\
    \ (caddr l))))\n         (if (or (and (= (car l) (cadr l))\n                 \
    \      (= (cadr l) (caddr l)))\n                 (and (= (car l) (caddr l))\n\
    \                       (= (cadr l) (caddr l))))\n             #f\n          \
    \   (let ((sum (apply + l)))\n               (if (= sum 0)\n                 \
    \  #t\n                   #f))))\n        ((= (length l) 3)\n         (if (zero?\
    \ (car l))\n             #t\n             #f))\n        (else\n         (triples_sum_to_zero\
    \ (cdr l)))))\n", "  (cond\n    [(empty? l) false]\n    [(and (not (empty? (cdr\
    \ l))) (and (not (empty? (cddr l)))) (list-member-of-list? (add1 (car l) (cadr\
    \ l)) (cddr l))) true]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (cond\
    \ [(empty? l) false]\n        [(empty? (cdr l)) false]\n        [(empty? (cddr\
    \ l)) false]\n        [else (or (and (= (+ (car l) (cadr l) (caddr l)) 0) true)\n\
    \                  (triples_sum_to_zero (cdr l)))]))\n", "  ;; Helper functions\n\
    \  ;; remove_two_zeros returns a list of two-combinations of its input\n  ;; that\
    \ do not contain two zeros.\n  ;; >>> remove_two_zeros([1, 2, 3, 0, 5, 0])\n \
    \ ;; ((1 2) (1 3) (1 5) (2 3) (2 5) (3 5))\n  (define (remove_two_zeros l)\n \
    \   (cond\n      [(null? l) '()]\n      [(zero? (car l)) (remove_two_zeros (cdr\
    \ l))]\n      [else (append (keep (lambda (x) (not (zero? x)))\n             \
    \           (combinations 2 (append (cdr l) (list (car l)))))\n              \
    \      (remove_two_zeros (cdr l)))]))\n  ;; check_for_two_sum takes a list of\
    \ integers and a number.\n  ;; It returns True if there is a pair of numbers in\
    \ the list that sum to\n  ;; the specified number, and False otherwise.\n  ;;\
    \ >>> check_for_two_sum([1, 2, 3, 5], 4)\n  ;; True\n  ;; >>> check_for_two_sum([1,\
    \ 2, 3, 5], 0)\n  ;; False\n  ;; >>> check_for_two_sum([1, 2, 3, 5], 7)\n  ;;\
    \ True\n  ;; >>> check_for_two_sum([], 0)\n  ;; False\n  (define (check_for_two_sum\
    \ l n)\n    (cond\n      [(null? l) #f]\n      [(member (- n (car l)) (cdr l))\
    \ #t]\n      [else (check_for_two_sum (cdr l) n)]))\n  ;; Main code\n  (check_for_two_sum\
    \ (remove_two_zeros l) 0))", "  (define (triples_sum_to_zero_helper l1 l2)\n \
    \   (define (addLists list1 list2)\n      (cond [(empty? list1) empty]\n     \
    \       [(empty? list2) empty]\n            [else (cons (+ (first list1) (first\
    \ list2)) (addLists (rest list1) (rest list2)))]))\n    (define (is-zero? lst)\n\
    \      (if (empty? lst) false\n          (or (= (first lst) 0) (is-zero? (rest\
    \ lst)))))\n    (cond [(empty? l1) false]\n          [(empty? l2) (triples_sum_to_zero_helper\
    \ (rest l1) l)]\n          [(empty? (rest l2)) (triples_sum_to_zero_helper l1\
    \ (rest l))]\n          [(is-zero? (addLists l1 l2)) true]\n          [else (triples_sum_to_zero_helper\
    \ l1 (rest l2))]))\n  (if (empty? l) false\n      (triples_sum_to_zero_helper\
    \ l l)))\n", "  (let loop ([l l] [r (list)])\n    (cond [(empty? l) #f]\n    \
    \      [(and (member (list-ref l 0) r)\n                (member (list-ref l 1)\
    \ r)\n                (member (list-ref l 2) r))\n           #t]\n          [else\
    \ (loop (cdr l) (cons (list-ref l 0) r))])))\n", "  (define (helper l)\n    (cond\n\
    \      [(null? l) False]\n      [(and (member (- (car l) (cadr l)) (cddr l))\n\
    \            (member (- (car l) (caddr l)) (cddr l))) True]\n      [else (helper\
    \ (cdr l))]))\n  (if (> (length l) 2)\n      (helper (sort < l))\n      False))\n",
  "  (and (not (null? l))\n       (or\n        (apply + (take l 3))\n        (triples_sum_to_zero\
    \ (cdr l)))))\n", "    ;; if length of list is less than 3, return false\n   \
    \ (if (< (length l) 3) #f\n        ;; otherwise, call helper function with the\
    \ list, the first element,\n        ;; and the rest of the list\n        (triples_sum_to_zero_helper\
    \ l (car l) (cdr l))))\n", "  (cond\n    [(empty? l) false]\n    [(and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and\
    \ (and (and (and (and (and (", "  (or\n   (and (list? l) (number? (car l)) (number?\
    \ (cadr l)) (number? (caddr l)) (= 0 (+ (car l) (cadr l) (caddr l))))\n   (and\
    \ (list? l) (triples_sum_to_zero (cdr l)))))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(< (length l) 3) #f]\n    [(zero? (+ (first l) (second l) (third l))) #t]\n\
    \    [else (triples_sum_to_zero (rest l))]))\n", "  (define (helper lst acc)\n\
    \    (if (empty? lst)\n        #f\n        (cond [(and (member (car lst) acc)\
    \ (member (- (car lst)) acc))\n               #t]\n              [else\n     \
    \          (helper (cdr lst) (cons (car lst) acc))])))\n  (helper l null))\n\n",
  "  (cond\n    [(= (length l) 1) false]\n    [(exists?\n      (lambda (x)\n     \
    \   (and (not (eq? x (car l)))\n             (member? (- 0 x) (cdr l))))\n   \
    \   (cdr l))\n     true]\n    [else (triples_sum_to_zero (cdr l))]))\n```\n\n\
    Note that **triples_sum_to_zero** is not a tail recursive function. Here is the\
    \ same solution using helper functions.\n\n```scheme", "  ;; if given a list of\
    \ numbers, it will check if there are any three\n  ;; numbers in the list that\
    \ sum to zero.\n  (or\n   ;; if there are less than three items in the list, we\
    \ return false\n   ;; immediately.\n   (empty? l)\n   (empty? (cdr l))\n   (empty?\
    \ (cddr l))\n   ;; we can't use `and` here because then it would stop after the\
    \ first\n   ;; condition returns false.\n   (or\n    ;; so we can check if 0 is\
    \ in the list\n    (member 0 l)\n    ;; or else we loop through the list and check\
    \ the second and third\n    ;; elements to see if they sum to the first.\n   \
    \ (let lp ([l l])\n      (if (empty? l)\n          #f\n          (or\n       \
    \    (let ([a (car l)])\n             (any\n              (\u03BB (b)\n      \
    \          (any\n                 (\u03BB (c)\n                   (= (+ a b c)\
    \ 0))\n                 (cdr l)))\n              (cdr l)))\n           (lp (cdr\
    \ l))))))))\n", "  (cond\n    [(empty? l) false]\n    [(= (length l) 1) false]\n\
    \    [(= (length l) 2) false]\n    [else (let ((fir (first l))\n             \
    \   (sec (second l))\n                (rest (rest (rest l))))\n            (cond\n\
    \              [(member (- (+ fir sec)) rest) true]\n              [else (triples_sum_to_zero\
    \ (cons sec rest))]))]))\n", "  (let loop ([i 0] [j 1] [k 2])\n    (if (= i (-\
    \ (length l) 3))\n        #f\n        (if (and (not (equal? (list-ref l i) (list-ref\
    \ l j)))\n                 (not (equal? (list-ref l i) (list-ref l k)))\n    \
    \             (not (equal? (list-ref l j) (list-ref l k)))\n                 (=\
    \ 0 (+ (list-ref l i) (list-ref l j) (list-ref l k))))\n            #t\n     \
    \       (if (= k (- (length l) 1))\n                (if (= j (- (length l) 2))\n\
    \                    (loop (+ i 1) (+ i 2) (+ i 3))\n                    (loop\
    \ i (+ j 1) (+ j 2)))\n                (loop i j (+ k 1)))))))\n", "  (if (&lt;\
    \ (length l) 3) #f\n      (or (and (equal? 0 (apply + (take 3 l))) #t)\n     \
    \     (triples_sum_to_zero (cdr l)))))\n", "  (define (f l r)\n    (if (empty?\
    \ r)\n        #f\n        (if (and (member (vector-ref l 0) (cdr r))\n       \
    \          (member (vector-ref l 1) (cdr r))\n                 (member (vector-ref\
    \ l 2) (cdr r)))\n            #t\n            (f l (cdr r)))))\n  (for/or ([r\
    \ (in-vector l)]\n           [s (in-vector l)]\n           [t (in-vector l)])\n\
    \    (if (or (empty? l) (= r s) (= r t) (= s t))\n        #f\n        (if (= (+\
    \ r s t) 0)\n            (if (f (vector r s t) (cdr l))\n                #f\n\
    \                #t)\n            #f))))\n", "  (and (pair? l)\n       (let ((len\
    \ (length l)))\n         (cond ((> len 2)\n                (or (and (eq? (list-ref\
    \ l 0) 0)\n                         (eq? (list-ref l 1) 0)\n                 \
    \        (eq? (list-ref l 2) 0))\n                    (triples_sum_to_zero (list-tail\
    \ l))))\n               (else #f)))))\n```\n\n```scheme\n#lang racket\n", "  (define\
    \ (sum_to_zero? l)\n    (cond\n      [(empty? l) false]\n      [(empty? (rest\
    \ l)) false]\n      [(zero? (+ (first l) (first (rest l)))) true]\n      [else\
    \ (sum_to_zero? (rest l))]))\n  (cond\n    [(empty? l) false]\n    [(sum_to_zero?\
    \ l) true]\n    [else (triples_sum_to_zero (rest l))]))\n", "  (let ([l (sort\
    \ < l)])\n    (and (not (zero? (length l)))\n         (or (and (= (length l) 1)\
    \ (zero? (car l)))\n             (and (= (length l) 2) (and (zero? (- (car l)\
    \ (cadr l))) (zero? (car l))))\n             (zero? (- (car l) (cadr l) (caddr\
    \ l)))))))\n", "  (if (or (empty? l)\n          (empty? (cdr l))\n          (empty?\
    \ (cddr l)))\n      false\n      (let ((curr (car l))\n            (cdr-l (cdr\
    \ l)))\n        (or (memq 0\n                  (map (lambda (i)\n            \
    \             (+ curr i))\n                       cdr-l))\n            (triples_sum_to_zero\
    \ cdr-l)))))\n\n", "  (define (has_triple l)\n    (if (< (length l) 3) false\n\
    \        (if (zero? (+ (car l) (cadr l) (caddr l)))\n            true\n      \
    \      (has_triple (cdr l)))))\n  (if (empty? l) false\n      (has_triple l)))\n",
  "  (letrec ([sums l] [next_sum (lambda (n) (if (empty? n) empty (cons (car n) (next_sum\
    \ (cdr n)))))] [sum_to_zero? (lambda (a b c) (and (not (equal? a b)) (not (equal?\
    \ a c)) (not (equal? b c)) (= (+ a b c) 0)))] [triple (lambda (a b c) (and (not\
    \ (equal? a b)) (not (equal? a c)) (not (equal? b c))))])\n    (cond [(empty?\
    \ l) false]\n          [(empty? (cdr l)) false]\n          [(empty? (cddr l))\
    \ false]\n          [(triple (car l) (cadr l) (caddr l)) (cond [(sum_to_zero?\
    \ (car l) (cadr l) (caddr l)) true] [else (triples_sum_to_zero (cdr l))])]\n \
    \         [else (triples_sum_to_zero (cdr l))])))\n", "  (cond\n    [(null? l)\
    \ false]\n    [(null? (cdr l)) false]\n    [(null? (cddr l)) false]\n    [(= 0\
    \ (apply + (take l 3))) true]\n    [else (triples_sum_to_zero (cdr l))]))\n",
  "  (define (all_three a b l)\n    (cond\n      [(empty? l) #f]\n      [(= (- (car\
    \ l) a b) 0) #t]\n      [else (all_three a b (cdr l))]))\n  (cond\n    [(empty?\
    \ l) #f]\n    [(all_three (car l) (cadr l) (cddr l)) #t]\n    [else (triples_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n\
    \    [(empty? (rest (rest l))) false]\n    [else (or (sum-to-zero? (list (list\
    \ (list (first l) (second l) (third l)))))\n              (triples_sum_to_zero\
    \ (rest l)))]))\n", "  (cond\n    [(null? l) #f]\n    [(number? (car l)) (cond\n\
    \                          [(null? (cdr l)) #f]\n                          [(number?\
    \ (cadr l)) (cond\n                                                 [(null? (cddr\
    \ l)) #f]\n                                                 [(number? (caddr l))\
    \ #t]\n                                                 [else (triples_sum_to_zero\
    \ (cdr l))])]\n                          [else (triples_sum_to_zero (cdr l))])]\n\
    \    [else (triples_sum_to_zero (cdr l))]))\n", "  (define (triples l)\n    (if\
    \ (= (length l) 3)\n        (if (= (sum l) 0)\n            (list l)\n        \
    \    '())\n        (filter\n         (lambda (y)\n           (if (= (sum y) 0)\n\
    \               (list y)\n               '()))\n         (map (lambda (x) (cons\
    \ x (cdr l))) l))))\n  (define (sum l)\n    (if (null? l)\n        0\n       \
    \ (+ (car l) (sum (cdr l)))))\n  (if (= (length l) 3)\n      (not (null? (triples\
    \ l)))\n      (not (null? (filter\n                   (lambda (y)\n          \
    \           (not (null? (triples y))))\n                   (map (lambda (x) (cons\
    \ x (cdr l))) l))))))\n", "  (cond ((< (length l) 3)\n         #f)\n        ((and\
    \ (member (car l) (cdr l))\n              (member (car l) (cddr l)))\n       \
    \  #t)\n        (else\n         (triples_sum_to_zero (cdr l)))))\n", "  (cond\n\
    \    [(empty? l) false]\n    [(empty? (cdr l)) false]\n    [(empty? (cddr l))\
    \ false]\n    [(and\n       (zero? (+ (car l) (cadr l) (caddr l)))\n       (not\
    \ (equal? (car l) (cadr l)))\n       (not (equal? (car l) (caddr l)))\n      \
    \ (not (equal? (cadr l) (caddr l)))) true]\n    [else (triples_sum_to_zero (cdr\
    \ l))]))\n", "  (cond\n    [(empty? l) false]\n    [(empty? (rest l)) false]\n\
    \    [(empty? (rest (rest l))) false]\n    [else\n     (or (or (or (= (sum (first\
    \ l) (second l) (third l)) 0)\n                (= (sum (first l) (second l) (fourth\
    \ l)) 0)\n                (= (sum (first l) (second l) (fifth l)) 0)\n       \
    \         (= (sum (first l) (second l) (sixth l)) 0)\n                (= (sum\
    \ (first l) (second l) (seventh l)) 0)\n                (= (sum (first l) (second\
    \ l) (eighth l)) 0)\n                (= (sum (first l) (second l) (ninth l)) 0)\n\
    \                (= (sum (first l) (second l) (tenth l)) 0)\n                (=\
    \ (sum (first l) (second l) (eleventh l)) 0)\n                (= (sum (first l)\
    \ (second l) (twelfth l)) 0)\n                (= (sum (first l) (second l) (thirteenth\
    \ l)) 0)\n                (= (sum (first l) (second l) (fourteenth l)) 0)\n  \
    \              (= (sum (first l) (second l) (fifteenth l)) 0)\n              \
    \  (= (sum (first l) (second l) (sixteenth l)) 0)\n                (= (sum (first\
    \ l) (second l) (seventeenth l)) 0)\n                (= (sum (first l) (second\
    \ l) (eighteenth l)) 0)\n                (= (sum (first l) (second l) (nineteenth\
    \ l)) 0)\n                (= (sum (first l) (second l) (twentieth l)) 0)\n   \
    \             (= (sum (first l) (second l) (twentyfirst l)) 0)\n             \
    \   (= (sum (first l) (second l) (twentysecond l)) 0)\n                (= (sum\
    \ (first l) (second l) (twentythird l)) 0)\n                (= (sum (first l)\
    \ (second l) (twentyfourth l)) 0)\n                (= (sum (first l) (second l)\
    \ (twentyfifth l)) 0)", "  (let* ([l (sort (remove 0 l) <)]\n         [len (length\
    \ l)])\n    (cond\n      [(= len 1) #f]\n      [(= len 2) (= (+ (first l) (second\
    \ l)) 0)]\n      [else (let loop ([i 0] [j 1] [k 2])\n              (or (and (not\
    \ (or (negative? (first l))\n                                (positive? (first\
    \ l))))\n                       (= 0 (+ (list-ref l i) (list-ref l j) (list-ref\
    \ l k))))\n                  (cond\n                    [(= k len) (if (= j (-\
    \ len 2)) #f (loop i (+ j 1) (+ j 2)))]\n                    [else (loop i j (+\
    \ k 1))])))])))\n", "  (cond\n    [(not (list? l)) #f]\n    [(null? l) #f]\n \
    \   [(= (length l) 1) #f]\n    [(= (length l) 2) #f]\n    [(member 0 (map (lambda\
    \ (x) (- 0 x)) l)) #t]\n    [(= (length l) 3)\n     (cond\n       [(member (list-ref\
    \ l 0) (map (lambda (x) (- (list-ref l 0) x)) (list-tail l))) #t]\n       [(member\
    \ (list-ref l 1) (map (lambda (x) (- (list-ref l 1) x)) (list-tail l))) #t]\n\
    \       [(member (list-ref l 2) (map (lambda (x) (- (list-ref l 2) x)) (list-tail\
    \ l))) #t]\n       [else #f])]\n    [else\n     (or (triples_sum_to_zero (list-tail\
    \ l))\n         (triples_sum_to_zero (list-tail (list-tail l)))\n         (triples_sum_to_zero\
    \ (list-tail (list-tail (list-tail l)))))]))\n", "  (cond ((null? l) #f)\n   \
    \     ((and (member (list-ref l 0) l) (member (list-ref l 1) l) (member (list-ref\
    \ l 2) l)) #t)\n        (else (triples_sum_to_zero (rest l)))))\n", '  (list-summary-function
    l (lambda (x) (member (abs x) l))))', "  (or\n   (and (member 0 l) (member (-\
    \ 0 0) l) (member (- 0 0 0) l))\n   (let loop ([l l])\n     (cond [(empty? l)\
    \ #f]\n           [(and (member 0 l) (member (- 0 0) l)) #t]\n           [else\
    \ (loop (rest l))]))))\n", "  (define (helper left right sum)\n    (if (&lt; left\
    \ (- (length l) 2))\n        (if (and (not (equal? sum 0)) (&lt; left (- (length\
    \ l) 2)))\n            (helper (+ left 1) (+ right 1) (+ (list-ref l left) (list-ref\
    \ l right) (list-ref l (+ left 2))))\n            (if (equal? sum 0)\n       \
    \         #t\n                (helper (+ left 1) (+ right 1) (+ (list-ref l left)\
    \ (list-ref l right) (list-ref l (+ left 2))))))\n        #f))\n  (helper 0 1\
    \ 0))\n", "  (cond [(= (length l) 3)\n         (or (= (sum l) 0) (= (- (sum l)\
    \ (car l)) 0))]\n        [else (cond [(= (length l) 2)\n                     false]\n\
    \                    [else (or (triples_sum_to_zero (append (cdr l) (list (car\
    \ l))))\n                              (triples_sum_to_zero (cdr l)))]\n     \
    \               )]\n        )\n  )\n", "  (define (sub-helper n l)\n    (if (null?\
    \ l) #f\n      (or (sub-helper n (cdr l))\n          (if (zero? (+ (car l) n))\
    \ #t\n            #f))))\n  (if (<= (length l) 2) #f\n    (if (sub-helper (car\
    \ l) (cdr l)) #t\n      (triples_sum_to_zero (cdr l)))))\n", "  (if (empty? l)\
    \ false\n      (let ((l2 (rest l)))\n        (if (empty? l2) false\n         \
    \   (let ((l3 (rest l2)))\n              (if (empty? l3) false\n             \
    \     (or (and (= (abs (car l)) (+ (abs (car l2)) (abs (car l3))))\n         \
    \                  (car l) (= (car l) 0))\n                      (triples_sum_to_zero\
    \ l2))))))))\n", "  (cond\n    [(empty? l) false]\n    [(and (member 0 l)\n  \
    \        (member (quotient (car l) -2) l)\n          (member (quotient (- (car\
    \ l)) 2) l))\n     true]\n    [else (triples_sum_to_zero (cdr l))]))\n", "  (if\
    \ (null? l)\n      #f\n      (cond ((and (number? (car l)) (number? (cadr l))\
    \ (number? (caddr l)))\n             (if (= (+ (car l) (cadr l) (caddr l)) 0)\n\
    \                 #t\n                 (triples_sum_to_zero (cdr l))))\n     \
    \       (else (triples_sum_to_zero (cdr l))))))\n", "  (cond\n    [(null? l) False]\n\
    \    [(and (member (car l) (cdr l))\n          (member (- (car l)) (cdr l))) True]\n\
    \    [else (triples_sum_to_zero (cdr l))]))\n", "  (letrec ([triples (compose\
    \ (compose map (lambda (a) (filter (lambda (b) (equal? (sum b) 0)) (map (lambda\
    \ (c) (list a c)) l)))) l)])\n    (not (equal? triples '()))))", "  (cond\n  \
    \  [(empty? l) #f]\n    [(<= (length l) 2) #f]\n    [(zero? (apply + (take l 3)))\
    \ #t]\n    [else (triples_sum_to_zero (rest l))]))\n```\n\n```scheme\n#lang racket\n",
  "  (define (aux l)\n    (cond [(null? l) #f]\n          [(and (= (list-ref l 0)\
    \ (list-ref l 1))\n                (= (list-ref l 0) (list-ref l 2)))\n      \
    \     (aux (rest (rest (rest l))))]\n          [(and (list-ref l 0) (list-ref\
    \ l 1) (list-ref l 2))\n           (if (= (+ (list-ref l 0) (list-ref l 1) (list-ref\
    \ l 2)) 0)\n               #t\n               (aux (rest (rest (rest l)))))]\n\
    \          [else (aux (rest l))]))\n  (aux l))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
