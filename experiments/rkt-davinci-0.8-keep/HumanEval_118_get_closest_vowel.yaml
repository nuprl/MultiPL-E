name: HumanEval_118_get_closest_vowel
language: rkt
prompt: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
  \ vowel that stands between \n;; two consonants from the right side of the word\
  \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
  \ empty string if you didn't\n;; find any vowel met the above condition. \n;; You\
  \ may assume that the given string contains English letter only.\n;; Example:\n\
  ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==> \"\
  U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\") ==>\
  \ \"\"\n(define (get_closest_vowel word)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
  \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"\
  full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
  \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
  \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n  \
  \  (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\")\
  \ \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
  \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
  \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
completions: ["  (let ([len (string-length word)])\n    (cond\n      [(zero? len)\
    \ \"\"]\n      [(and (char-alphabetic? (string-ref word 0))\n            (char-alphabetic?\
    \ (string-ref word (- len 1))))\n       (get-closest-vowel-helper (substring word\
    \ 1 (- len 1)))]\n      [else \"\"])))\n", "  (cond ((or (string=? \"\" word)\
    \ (string=? \"a\" word) (string=? \"e\" word) (string=? \"i\" word) (string=?\
    \ \"o\" word) (string=? \"u\" word)) \"\")\n        ((or (string=? \"ab\" word)\
    \ (string=? \"bc\" word) (string=? \"cd\" word) (string=? \"de\" word) (string=?\
    \ \"ef\" word) (string=? \"fg\" word) (string=? \"gh\" word) (string=? \"hi\"\
    \ word) (string=? \"ij\" word) (string=? \"jk\" word) (string=? \"kl\" word) (string=?\
    \ \"lm\" word) (string=? \"mn\" word) (string=? \"no\" word) (string=? \"op\"\
    \ word) (string=? \"pq\" word) (string=? \"qr\" word) (string=? \"rs\" word) (string=?\
    \ \"st\" word) (string=? \"tu\" word) (string=? \"uv\" word) (string=? \"vw\"\
    \ word) (string=? \"wx\" word) (string=? \"xy\" word) (string=? \"yz\" word))\
    \ \"\")\n        ((string=? \"c\" (substring word -1)) (get_closest_vowel (substring\
    \ word 0 -1)))\n        ((or (string=? \"b\" (substring word -1)) (string=? \"\
    d\" (substring word -1)) (string=? \"f\" (substring word -1)) (string=? \"g\"\
    \ (substring word -1)) (string=? \"h\" (substring word -1)) (string=? \"j\" (substring\
    \ word -1)) (string=? \"k\" (substring word -1)) (string=? \"l\" (substring word\
    \ -1)) (string=? \"m\" (substring word -1)) (string=? \"n\" (substring word -1))\
    \ (string=? \"p\" (substring word -1)) (string=? \"q\" (substring word -1)) (string=?\
    \ \"r\" (substring", "  (cond\n    [(empty? word) \"\"]\n    [(member? (char-downcase\
    \ (last word)) '(#\\a #\\e #\\i #\\o #\\u)) (string (last word))]\n    [else (get_closest_vowel\
    \ (substring word 0 (- (string-length word) 1)))]))\n", "  (let* ((vowels '(#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n         (max-index (- (string-length\
    \ word) 1))\n         (word-chars (string->list word))\n         (vowel-index\
    \ (binary-search-right-closest vowels word-chars max-index))\n         (left-index\
    \ (binary-search-left-closest (complement char-alphabetic?) word-chars vowel-index))\n\
    \         (right-index (binary-search-right-closest (complement char-alphabetic?)\
    \ word-chars vowel-index)))\n    (cond ((or (not left-index) (not right-index))\
    \ \"\")\n          ((= left-index (sub1 right-index)) \"\")\n          (else (list->string\
    \ (sublist word-chars vowel-index (add1 vowel-index)))))))\n", "  (define vo \"\
    aeiou\")\n  (define (is-vowel char)\n    (if (string-contains vo char)\n     \
    \   #t\n        #f))\n  (define (is-con char)\n    (if (string-contains vo char)\n\
    \        #f\n        #t))\n  (define (get-all-vowels word)\n    (cond\n      [(empty?\
    \ word) '()]\n      [(is-vowel (first word)) (cons (first word) (get-all-vowels\
    \ (rest word)))]\n      [else (get-all-vowels (rest word))]))\n  (define (get-all-cons\
    \ word)\n    (cond\n      [(empty? word) '()]\n      [(is-con (first word)) (cons\
    \ (first word) (get-all-cons (rest word)))]\n      [else (get-all-cons (rest word))]))\n\
    \  (define (find-match vowels cons)\n    (cond\n      [(empty? vowels) \"\"]\n\
    \      [(empty? cons) \"\"]\n      [(string=? (first vowels) (first cons)) (first\
    \ vowels)]\n      [else (find-match (rest vowels) (rest cons))]))\n  (find-match\
    \ (get-all-vowels word) (get-all-cons word)))\n</code>\nThis produces the following\
    \ results:\n<code>&gt; (get_closest_vowel \"yogurt\")\n\"u\"\n&gt; (get_closest_vowel\
    \ \"FULL\")\n\"U\"\n&gt; (get_closest_vowel \"quick\")\n\"\"\n&gt; (get_closest_vowel\
    \ \"ab\")\n\"\"\n</code>\nWhat I am wondering is whether there are any design\
    \ patterns or better ways to write this code? I'm new to Racket and don't know\
    \ how to make it more efficient or readable.\n\n\nA:\n\nI don't think you need\
    \ the <code>get-all-vowels</code> and <code>get-all-cons</code> functions. You\
    \ can simplify your code using functions like <code>string-filter", "  (if (empty?\
    \ word)\n      \"\"\n      (if (list? word)\n          (get_closest_vowel_rec\
    \ (reverse word) '())\n          (get_closest_vowel_rec (string->list (reverse\
    \ word)) '()))))\n", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U))\n  (define (is-vowel? letter)\n    (and (member letter vowels) true))\n\
    \  (define (is-consonant? letter)\n    (and (not (is-vowel? letter)) true))\n\
    \  (define (next-vowel last current)\n    (if (and (is-consonant? last) (is-vowel?\
    \ current))\n        current\n        \"\"))\n  (define (get-closest-vowel-help\
    \ word last result)\n    (if (empty? word)\n        result\n        (get-closest-vowel-help\
    \ (rest word) (first word) (next-vowel last (first word)))))\n  (get-closest-vowel-help\
    \ (rest (reverse word)) (first (reverse word)) \"\"))\n", "  (cond\n    [(empty?\
    \ word) \"\"]\n    [(empty? (rest word)) \"\"]\n    [(empty? (rest (rest word)))\
    \ \"\"]\n    [(vowel? (first word)) (get_closest_vowel (rest word))]\n    [(and\
    \ (vowel? (first (rest word))) (consonant? (first (rest (rest word))))) (get_closest_vowel\
    \ (rest word))]\n    [else (get_closest_vowel (rest word))]))", "  (match word\n\
    \    [('#\\A) \"\"]\n    [('#\\e) \"\"]\n    [('#\\i) \"\"]\n    [('#\\o) \"\"\
    ]\n    [('#\\u) \"\"]\n    [('#\\y) \"\"]\n    [('#\\E) \"\"]\n    [('#\\I) \"\
    \"]\n    [('#\\O) \"\"]\n    [('#\\U) \"\"]\n    [('#\\Y) \"\"]\n    [('#\\A .\
    \ rest) (get_closest_vowel rest)]\n    [('#\\e . rest) (get_closest_vowel rest)]\n\
    \    [('#\\i . rest) (get_closest_vowel rest)]\n    [('#\\o . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\u . rest) (get_closest_vowel rest)]\n    [('#\\y . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\E . rest) (get_closest_vowel rest)]\n    [('#\\I . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\O . rest) (get_closest_vowel rest)]\n    [('#\\U . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\Y . rest) (get_closest_vowel rest)]\n    [('#\\q . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\w . rest) (get_closest_vowel rest)]\n    [('#\\r . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\t . rest) (get_closest_vowel rest)]\n    [('#\\p . rest) (get_closest_vowel\
    \ rest)]\n    [('#\\s . rest) (get_closest_vowel rest)]\n    [('#\\d . rest) (get_closest_vowel\
    \ rest)]\n", "  (let ([reversed-word (string-reverse word)])\n    (or (get-vowel-from-right\
    \ (cddr reversed-word))\n        \"\")))\n", "  (cond\n    [(empty? word) \"\"\
    \ ]\n    [(member (first word) \"aeiouAEIOU\") (first word)]\n    [else (get_closest_vowel\
    \ (rest word))]))\n", "  (reverse (map (\u03BB (x) (if (or (char=? x #\\a) (char=?\
    \ x #\\e) (char=? x #\\i) (char=? x #\\o) (char=? x #\\u))\n                 \
    \         x\n                          #\\.)\n                  (string->list\
    \ word))))\n</code>\nThe above code gets the list of the word with dots replacing\
    \ the non-vowels, reverses the list, and then maps it to a character, but instead\
    \ of getting the character I need to get the position of the character.\nI also\
    \ tried doing it with <code>find</code> and <code>find-last</code>, but I couldn't\
    \ figure it out.\n\n\nA:\n\nSince the task asks for the closest vowel from the\
    \ right, we can just go backwards, and stop the moment we hit a vowel:\n<code>(define\
    \ (get-closest-vowel str)\n  (let loop ([i (sub1 (string-length str))])\n    (if\
    \ (vowel? (string-ref str i))\n        (string (string-ref str i))\n        (if\
    \ (zero? i)\n            \"\"\n            (loop (sub1 i))))))\n</code>\nWhere\
    \ the <code>vowel?</code> function returns <code>#t</code> if its argument is\
    \ a vowel, and <code>#f</code> otherwise:\n<code>(define (vowel? c)\n  (member\
    \ c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n</code>\n",
  "  (define (is_vowel? letter)\n    (member letter '(\"a\" \"e\" \"i\" \"o\" \"u\"\
    \ \"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define (find-next-vowel word)\n    (cond\n\
    \      [(null? word) \"\" ]\n      [(is_vowel? (car word)) (car word)]\n     \
    \ [else (find-next-vowel (cdr word))]))\n  (define (find-previous-vowel word)\n\
    \    (cond\n      [(null? word) \"\" ]\n      [(is_vowel? (car word)) (car word)]\n\
    \      [else (find-previous-vowel (cdr word))]))\n  (define (find-closest-vowel\
    \ word)\n    (define (find-closest-vowel-from-right remaining left-vowel)\n  \
    \    (define (find-closest-vowel-from-left remaining right-vowel)\n        (cond\n\
    \          [(null? remaining) (if (and (not (equal? left-vowel \"\")) (not (equal?\
    \ right-vowel \"\")))\n                                 (string-append (list left-vowel)\
    \ right-vowel)\n                                 \"\")]\n          [(is_vowel?\
    \ (car remaining)) (if (and (not (equal? left-vowel \"\")) (not (equal? right-vowel\
    \ \"\")))\n                                           (string-append (list left-vowel)\
    \ right-vowel)\n                                           (if (not (equal? left-vowel\
    \ \"\")) left-vowel right-vowel))]\n          [else (find-closest-vowel-from-left\
    \ (cdr remaining) right-vowel)]))\n      (cond\n        [(null? remaining) \"\"\
    \ ]\n        [(is_vowel? (car remaining)) (find-closest-vowel-from-left (cdr remaining)\
    \ (car remaining))]\n        [else (find-closest-vowel-from-right (cdr remaining)\
    \ left-vowel)]", "  (cond [(empty? word) empty]\n        [(vowel? (last word))\
    \ get_closest_vowel (butlast word)]\n        [(empty? (list-tail word 1)) empty]\n\
    \        [(vowel? (list-ref word 1)) (string (list-ref word 1)))\n        [else\
    \ get_closest_vowel (butlast word)]))", "  (cond\n    [(empty? word) empty]\n\
    \    [(regexp-match* #rx\"[aeiou]\" (string-reverse word))\n     (cond\n     \
    \  [(regexp-match* #rx\"[aeiou]\" (string-trim-right word)) empty]\n       [else\
    \ (match:substring (regexp-match* #rx\"[aeiou]\" (string-reverse word)) 1)])]\n\
    \    [else empty]))\n", "  (match word\n    [(list (? vowel?) (? vowel?) rest\
    \ ...) \"\" ]\n    [(list (? vowel?) (? vowel?) (? vowel?) rest ...) \"\" ]\n\
    \    [(list (? vowel?) (? vowel?) (? vowel?) (? vowel?) rest ...) \"\" ]\n   \
    \ [(list (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) rest ...) \"\"\
    \ ]\n    [(list (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ rest ...) \"\" ]\n    [(list rest ... (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)\
    \ (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?) (? vowel?)", "  (define\
    \ (fst c) (char-upcase (string-ref c 0)))\n  (define (is_vowel c) (memq (fst c)\
    \ (list #\\A #\\E #\\I #\\O #\\U)))\n  (define (search word)\n    (let ((n (string-length\
    \ word)))\n      (cond\n        [(= n 1) #f]\n        [(and (is_vowel (string-ref\
    \ word 1))\n              (not (is_vowel (string-ref word 0))))\n         (string-ref\
    \ word 1)]\n        [else (search (substring word 1))])))\n  (or (search word)\
    \ \"\"))\n</code>\n", "  (cond\n    [(empty? word) \"\"]\n    [(vowel? (last word))\
    \ \"\"]\n    [(consonant? (last word)) (get_closest_vowel (butlast word))]\n \
    \   [else (last word)]))\n", "  (let ([segments (string-split word #\\_)])\n \
    \   (for/list ([segment segments])\n      (let ([rsegment (reverse segment)])\n\
    \        (list-ref segment (for/last ([i (in-range (string-length segment))])\n\
    \                           (or (match (string-ref rsegment i)\n             \
    \                  [(#\\a) i]\n                               [(#\\e) i]\n   \
    \                            [(#\\i) i]\n                               [(#\\\
    o) i]\n                               [(#\\u) i]\n                           \
    \    [_ null])\n                               (and (char-alphabetic? (string-ref\
    \ rsegment i))\n                                #f)))))))\n  \"\")\n", "  (define\
    \ (helper curr-vowel curr-idx str)\n    (cond\n      [(null? str) curr-vowel]\n\
    \      [(string-contains? \"aeiou\" (car str))\n       (if (&gt; (- (length str)\
    \ curr-idx) 2)\n           (helper (car str) (length str) (cdr str))\n       \
    \    curr-vowel)]\n      [else (helper curr-vowel curr-idx (cdr str))]))\n  (if\
    \ (&lt;= (length word) 2)\n      \"\"\n      (helper \"\" 0 word)))\n", "  (define\
    \ (consonant? c)\n    (or (equal? c \"b\") (equal? c \"c\") (equal? c \"d\") (equal?\
    \ c \"f\") (equal? c \"g\") (equal? c \"h\") (equal? c \"j\") (equal? c \"k\"\
    ) (equal? c \"l\") (equal? c \"m\") (equal? c \"n\") (equal? c \"p\") (equal?\
    \ c \"q\") (equal? c \"r\") (equal? c \"s\") (equal? c \"t\") (equal? c \"v\"\
    ) (equal? c \"w\") (equal? c \"x\") (equal? c \"y\") (equal? c \"z\")))\n  (define\
    \ (vowel? c)\n    (or (equal? c \"a\") (equal? c \"e\") (equal? c \"i\") (equal?\
    \ c \"o\") (equal? c \"u\")))\n  (define (get-closest-vowel word)\n    (if (or\
    \ (equal? (string-length word) 0) (equal? (string-length word) 1))\n      \"\"\
    \n      (let* ([c (string-ref word (sub1 (string-length word)))]\n           \
    \  [closest-vowel (get-closest-vowel (substring word 0 (sub1 (string-length word))))])\n\
    \        (if (and (vowel? c) (consonant? (string-ref word (sub1 (string-length\
    \ word)))))\n          c\n          closest-vowel))))\n  (get-closest-vowel word))\n",
  "  (define (vowel? c)\n    (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\"\
    \ \"I\" \"O\" \"U\")))\n  (define (count-vowels word)\n    (length (filter vowel?\
    \ word)))\n  (define (do-recurse n)\n    (if (vowel? (string-ref word n))\n  \
    \      (string-ref word n)\n        (do-recurse (- n 1))))\n  (if (&gt; (count-vowels\
    \ word) 0)\n      (do-recurse (- (length word) 1))\n      \"\"))\n</code>\n",
  "  (define (is_vowel? ch)\n    (define vowel \"aeiou\")\n    (member ch vowel))\n\
    \  (define (is_consonant? ch)\n    (not (is_vowel? ch)))\n  (define (get-closest-vowel-by-index\
    \ word start-index)\n    (if (&lt; start-index 0) \"\"\n      (let ((prev-char\
    \ (string-ref word (- start-index 1)))\n            (next-char (string-ref word\
    \ start-index)))\n        (if (and (is_consonant? prev-char)\n               \
    \  (is_consonant? next-char))\n            (string-ref word start-index)\n   \
    \         (get-closest-vowel-by-index word (- start-index 1))))))\n  (get-closest-vowel-by-index\
    \ word (- (string-length word) 1)))\n", "  (if (or (empty? word) (equal? (count\
    \ (regexp #rx\"[aieou]\") word) 0))\n      \"\"\n      (let* ([consonants #rx\"\
    [^aieou]\"]\n             [vowels #rx\"[aieou]\"]\n             [first-vowel (regexp-match*\
    \ #rx\"[aieou]+\" word)]\n             [first-consonant (regexp-match* consonants\
    \ word)])\n        (if (equal? first-vowel first-consonant)\n            (string-ref\
    \ word (- (length first-vowel) 1))\n            (string-ref word 0)))))\n", " \
    \ (find-closest-vowel word (consonants? word)))\n", "  (regexp-replace* #rx\"\
    [^aeiou]\" word \"\"))\n", "  (cond\n    [(empty? word) \"\"]\n    [(member (last\
    \ word) '(#\\a #\\e #\\i #\\o #\\u)) (get_closest_vowel (butlast word))]\n   \
    \ [(member (last word) '(#\\A #\\E #\\I #\\O #\\U)) (get_closest_vowel (butlast\
    \ word))]\n    [(member (last word) '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k\
    \ #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)) (get_closest_vowel\
    \ (butlast word))]\n    [(member (last word) '(#\\B #\\C #\\D #\\F #\\G #\\H #\\\
    J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\Z)) (get_closest_vowel\
    \ (butlast word))]\n    [else (string (last word))]))\n</code>\nThe idea is to\
    \ take the last character from the string, check if it is a vowel, and check if\
    \ it is a consonant. Then, if the vowel is followed by a consonant, we return\
    \ that vowel. Otherwise, we iterate through the string recursively. \nIf the string\
    \ is only one character long and the word is empty, we return the empty string.\
    \ If the string is only one character long and the word is a vowel, we return\
    \ the empty string. If the string is only one character long and the word is a\
    \ consonant, we return the empty string. \nHere are the tests that I am running\
    \ to test the code:\n<code>(get_closest_vowel \"yogurt\")", "  (let ((vowels (list\
    \ #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n    (cond\n      [(string-empty?\
    \ word) \"\" ]\n      [(not (member (string-ref word 0) vowels)) (get_closest_vowel\
    \ (substring word 1))]\n      [(string-length word &lt;= 2) \"\"]\n      [(and\
    \ (member (string-ref word 1) vowels)\n            (not (member (string-ref word\
    \ 2) vowels)))\n        (string-ref word 1)]\n      [else (get_closest_vowel (substring\
    \ word 1))])))\n", "  (regexp-replace* #rx\"[^aeiouAEIOU]\" word))\n</code>\n\
    It works as expected but I'm not sure this is the best way to go.\n\n\nA:\n\n\
    There's no way to do this in one regex replacement pass. Consider the input <code>\"\
    yyyyy\"</code>. In the first pass, you'd have the regex <code>[^aeiouAEIOU]</code>\
    \ match <code>\"yyyyy\"</code> and replace it with the empty string, so you'd\
    \ end up with the string <code>\"\"</code>. The regex won't match again, so your\
    \ function would incorrectly return the empty string.\nInstead, I think it's better\
    \ to use a string to build up the result. After you match a vowel, find the index\
    \ of the next match. Copy the characters from the current match position to the\
    \ next match position into the result string. Repeat until you've reached the\
    \ end of the input string:\n<code>(define (get-closest-vowel word)\n  (let loop\
    \ ([start 0] [result \"\"])\n    (regexp-match* #rx\"[aeiouAEIOU]\" word start)\n\
    \    (let* ([match (regexp-match* #rx\"[aeiouAEIOU]\" word start)]\n         \
    \  [_ (printf \"~a\\n\" match)]\n           [start (add1 (cdr match))])\n    \
    \  (if (= start (string-length word))\n          result\n          (let ([result\
    \ (string-append result (substring word (car match) start))])\n            (loop\
    \ start result))))))\n</code>\n", "  (if (= (string-length word) 1)\n      \"\"\
    \n      (let ([chars (string->list word)])\n        (if (not (or (regexp-match?\
    \ #rx\"[aeiou]\" (list-ref chars (- (string-length word) 1)))\n              \
    \       (regexp-match? #rx\"[aeiou]\" (list-ref chars (- (string-length word)\
    \ 2)))))\n            (get_closest_vowel (substring word 0 (- (string-length word)\
    \ 1)))\n            (string-copy (list-ref chars (- (string-length word) 1)))))))\n",
  "  (local [\n          (define (is-a-vowel? c)\n            (string-contains \"\
    aeiouAEIOU\" c))\n          (define (is-a-consonant? c)\n            (not (is-a-vowel?\
    \ c)))\n          (define (find-vowel? word)\n            (let loop ([i (sub1\
    \ (string-length word))])\n              (if (negative? i)\n                 \
    \ \"\"\n                  (let ([word-char (string-ref word i)])\n           \
    \         (if (and (is-a-vowel? word-char)\n                             (and\
    \ (not (negative? (sub1 i)))\n                                  (is-a-consonant?\
    \ (string-ref word (sub1 i))))\n                             (and (not (zero?\
    \ i))\n                                  (is-a-consonant? (string-ref word (add1\
    \ i)))))\n                        (string word-char)\n                       \
    \ (loop (sub1 i)))))))\n          ])\n  (find-vowel? word))\n", "  (cond\n   \
    \ [(empty? word) \"\"]\n    [(find (find-consonant (flatten word)) word)\n   \
    \  (find-vowel (flatten word))]\n    [else \"\" ]))\n", "  (letrec\n      ((find-next-consonant\n\
    \        (lambda (pos)\n          (cond\n            [(string-index \"aeiou\"\
    \ (string-ref word pos))\n             pos]\n            [else\n             (find-next-consonant\
    \ (+ pos 1))])))\n       (find-next-vowel\n        (lambda (pos)\n          (cond\n\
    \            [(string-index \"aeiou\" (string-ref word pos))\n             (+\
    \ pos 1)]\n            [else\n             (find-next-vowel (+ pos 1))]))))\n\
    \    (cond\n      [(&gt;= (string-length word) 2)\n       (let ((next-consonant\
    \ (find-next-consonant (- (string-length word) 2))))\n         (cond\n       \
    \    [(or (= next-consonant (string-length word)) (= 0 next-consonant))\n    \
    \        \"\"]\n           [else\n            (string-ref word (find-next-vowel\
    \ (find-next-consonant (- (string-length word) 2))))]))]\n      [else\n      \
    \ \"\"])))\n</code>\nIs this code idiomatic Racket?\n\n\nA:\n\nComments\nThe comment\
    \ at the top of the file seems to describe something completely different from\
    \ the code that follows. I'd also like to see comments throughout the code describing\
    \ what it's doing. For example, I found <code>find-next-consonant</code> and <code>find-next-vowel</code>\
    \ hard to understand, but it was easy to add comments to them to explain what\
    \ they do:\n<code>;; Find the next vowel to the right", "  (regexp-match* #rx\"\
    [^AEIOUaeiou]*([AEIOUaeiou]).*\" word 'x))\n", "  (if (not (string-contains? word\
    \ #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n      \"\"\n      (letrec\
    \ ([first-vowel (find-last-index (lambda (c) (member c '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))) word)]\n               [second-vowel\
    \ (find-last-index (lambda (c) (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\"\
    \ \"E\" \"I\" \"O\" \"U\"))) (substring word (+ first-vowel 1)))])\n        (if\
    \ (and (not (= second-vowel #f)) \n                 (not (string-contains? (substring\
    \ word (- second-vowel 1) second-vowel) #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U)))\n            (string-ref word second-vowel)\n            \"\"))))\n",
  "  (let* ([curr-vowel-distance -1]\n         [curr-vowel #\\ ]\n         [vowels\
    \ #(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)]\n         [consonants\
    \ #(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\\
    s #\\t #\\v #\\w #\\x #\\y #\\z #\\B #\\C #\\D #\\F #\\G #\\H #\\J #\\K #\\L #\\\
    M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\Z)])\n    (for ([i (in-range\
    \ (string-length word))])\n      (let* ([current-char (string-ref word i)]\n \
    \            [current-char-idx (list-index current-char consonants)]\n       \
    \      [current-char-is-consonant (and current-char-idx (> current-char-idx -1))])\n\
    \        (cond\n          [(and current-char-is-consonant (and (> i 0) (< i (-\
    \ (string-length word) 1))))\n           (for ([j (in-range (string-length word))])\n\
    \             (let* ([next-char (string-ref word (+ i 1))]\n                 \
    \   [next-char-idx (list-index next-char consonants)]\n                    [next-char-is-consonant\
    \ (and next-char-idx (> next-char-idx -1))])\n               (cond\n         \
    \        [(and next-char-is-consonant (and (> (+ i 1) 0) (< (+ i 1) (- (string-length\
    \ word) 1))))\n                  (for ([k (in-range (string-length word))])\n\
    \                    (let* ([curr-char (string-ref word k)]\n                \
    \           [curr-char-idx (list-index curr-char vowels)]\n                  \
    \         [curr-char-", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u #\\A #\\\
    E #\\I #\\O #\\U))\n  (define i 1)\n  (for/or ([cons (in-list (rest (reverse word)))])\n\
    \    (and (find cons vowels) (find (string-ref word (- (string-length word) i))\
    \ vowels) (string (list cons))))\n  (set! i (+ i 1)))", "  (define (closest-vowel?\
    \ ch)\n    (member ch '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\"\
    \ \"U\")))\n  (define (next-vowel? ch)\n    (and (equal? (substring word (sub1\
    \ (string-length word)) (string-length word)) ch)\n         (closest-vowel? ch)))\n\
    \  (define (first-vowel? ch)\n    (and (equal? (substring word 0 1) ch)\n    \
    \     (closest-vowel? ch)))\n  (define (consonant? ch)\n    (not (closest-vowel?\
    \ ch)))\n  (define (inside-word? ch)\n    (let ((str-len (string-length word)))\n\
    \      (and (> str-len 2)\n           (equal? ch (substring word (sub1 str-len)\
    \ str-len))\n           (consonant? (substring word (sub1 (sub1 str-len)) (sub1\
    \ str-len)))\n           (closest-vowel? (substring word 0 1)))))\n  (define (last-vowel?\
    \ ch)\n    (and (equal? (substring word (sub1 (string-length word)) (string-length\
    \ word)) ch)\n         (consonant? (substring word (sub1 (sub1 (string-length\
    \ word))) (sub1 (string-length word))))\n         (closest-vowel? ch)))\n  (cond\n\
    \    [(first-vowel? \"A\") \"\" ]\n    [(first-vowel? \"a\") \"\" ]\n    [(next-vowel?\
    \ \"a\") \"a\" ]\n    [(next-vowel? \"A\") \"A\" ]\n    [(next-vowel? \"e\") \"\
    e\" ]\n    [(next-vowel? \"E\") \"E\" ]\n    [(next-vowel? \"i\") \"i\" ]\n  \
    \  [(next-vowel? \"I\") \"I\" ]\n    [(next-vowel? \"o\") \"o\" ]\n    [(next-",
  "  (let ([vowels \"aeiou\"])\n    (andmap (lambda (c) (member c vowels))\n     \
    \       (cddr (reverse word)))))\n", "  (regexp-match #rx\"^([^AEIOU]*?)([AEIOU])([^AEIOU]*?)$\"\
    \ word)\n  (cond\n    [(not (= '#f (regexp-match #rx\"^([^AEIOU]*?)([AEIOU])([^AEIOU]*?)$\"\
    \ word)))\n     (list-ref (regexp-match #rx\"^([^AEIOU]*?)([AEIOU])([^AEIOU]*?)$\"\
    \ word) 2)]\n    [else\n     \"\"]))\n", "  (define vowels '(#\\a #\\e #\\i #\\\
    o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (get-element-index lst element)\n\
    \    (define (helper lst i)\n      (cond [(null? lst) -1]\n            [(equal?\
    \ (car lst) element) i]\n            [else (helper (cdr lst) (+ i 1))]))\n   \
    \ (helper lst 0))\n  (define (get-consonant-positions lst)\n    (define (helper\
    \ lst lst-consonants)\n      (cond [(null? lst) (reverse lst-consonants)]\n  \
    \          [(member (car lst) vowels) (helper (cdr lst) lst-consonants)]\n   \
    \         [else (helper (cdr lst) (cons (car lst) lst-consonants))]))\n    (helper\
    \ lst (list)))\n  (define (get-consonant-indices lst)\n    (define (helper lst\
    \ lst-consonant-indices)\n      (cond [(null? lst) (reverse lst-consonant-indices)]\n\
    \            [(member (car lst) vowels) (helper (cdr lst) lst-consonant-indices)]\n\
    \            [else (helper (cdr lst) (cons (get-element-index lst (car lst)) lst-consonant-indices))]))\n\
    \    (helper lst (list)))\n  (define (find-consonant-distances lst-consonant-indices)\n\
    \    (cond [(null? lst-consonant-indices) -1]\n          [(equal? (length lst-consonant-indices)\
    \ 1) -1]\n          [else (- (list-ref lst-consonant-indices 1) (list-ref lst-consonant-indices\
    \ 0))]))\n  (define (get-closest-vowel-aux lst)\n    (define (helper lst vowel-index)\n\
    \      (cond", "  (cond\n    [(empty? word) \"\"]\n    [(vowel? (first word))\
    \ (get_closest_vowel (rest word))]\n    [(and (not (empty? (rest word)))\n   \
    \       (vowel? (first (rest word)))) (first (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n", "  (cond [(empty? word) \"\"]\n        [(or (char=? #\\\
    a (first word))\n             (char=? #\\e (first word))\n             (char=?\
    \ #\\i (first word))\n             (char=? #\\o (first word))\n             (char=?\
    \ #\\u (first word)))\n         (get_closest_vowel (rest word))]\n        [(get_closest_vowel_aux\
    \ (rest word))\n         (get_closest_vowel_aux (rest word))]\n        [else\n\
    \         (get_closest_vowel (rest word))]))\n", "  (letrec ([r-vowels (list #\\\
    a #\\e #\\i #\\o #\\u)]\n           [r-consonants (list #\\b #\\c #\\d #\\f #\\\
    g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\\
    z)]\n           [consonant? (lambda (x) (memq x r-consonants))]\n           [vowel?\
    \ (lambda (x) (memq x r-vowels))]\n           [vowel-consonant-vowel? (lambda\
    \ (w) (and (consonant? (last (butlast w))) (vowel? (last (butlast w))) (consonant?\
    \ (last w))))]\n           [get-prev-char (lambda (word pos) (string-ref word\
    \ (sub1 pos)))]\n           [get-next-char (lambda (word pos) (string-ref word\
    \ (add1 pos)))]\n           [get-closest-vowel (lambda (word pos)\n          \
    \                      (cond\n                                  [(vowel-consonant-vowel?\
    \ word) (last (butlast word))]\n                                  [(and (consonant?\
    \ (get-prev-char word pos)) (consonant? (get-next-char word pos))) (get-closest-vowel\
    \ word (sub1 pos))]\n                                  [else #f]))])\n    (get-closest-vowel\
    \ (string->list word) (sub1 (string-length word)))))\n```\n\n```lisp", "  (define\
    \ vowels '(a e i o u))\n  (define (is-vowel? c)\n    (member c vowels))\n  (define\
    \ (has-vowel? str)\n    (regexp-match* #rx\"[aeiou]\" str))\n  (define (vowel-at-regexp\
    \ str)\n    (regexp-match* #rx\"[aeiou]\" str))\n  (cond [(not (has-vowel? word))\
    \ (printf \"\")]\n        [(not (has-vowel? (string-drop-right word 1))) (printf\
    \ \"\")]\n        [(not (has-vowel? (string-drop-right word 2))) (printf \"\"\
    )]\n        [else (vowel-at-regexp (string-drop-right word 2))]))", "  (cond [(empty?\
    \ word) \"\"]\n        [(member (last word) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\
    \ (get_closest_vowel (butlast word))]\n        [(and (member (last word) '(\"\
    b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"\
    r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\"))\n              (member (last (butlast\
    \ word)) '(\"a\" \"e\" \"i\" \"o\" \"u\"))) (last (butlast word))]\n        [else\
    \ (get_closest_vowel (butlast word))]))\n", "  (if (string-contains? word \"a\"\
    \ \"e\" \"i\" \"o\" \"u\")\n      (substring word (find-index-right word))\n \
    \     \"\"))\n", "    (let loop ([word (string-&gt;list word)] [result \"\"])\n\
    \        (cond [(and (&gt; (length word) 1) (string-contains \"aeiouAEIOU\" (list-ref\
    \ word 0)) (not (string-contains \"aeiouAEIOU\" (list-ref word 1))))\n       \
    \        (string (list-ref word 0))]\n              [(&gt; (length word) 1) (loop\
    \ (rest word) result)]\n              [else result])))\n", "  (cond\n    [(empty?\
    \ word) empty]\n    [(and (not (is-vowel? (last word))) (not (is-vowel? (second\
    \ (reverse word))))) empty]\n    [(is-vowel? (last word)) (string-&gt;symbol (string-append\
    \ (list (last word)) \"1\"))]\n    [(is-vowel? (second (reverse word))) (string-&gt;symbol\
    \ (string-append (list (second (reverse word))) \"2\"))]\n    [else empty]))\n",
  "  (match word\n    [(list) \"\"]\n    [(list c) \"\"]\n    [(list c d) \"\"]\n\
    \    [(list c d e) \"\"]\n    [(list c d e f ... )\n     (if (member c \"aeiou\"\
    )\n         c\n         (get_closest_vowel (list d e f ... )))]))\n", "  (define\
    \ (between-consonants? v)\n    (and (vowel? (substring word (- v 1) v))\n    \
    \     (consonant? (substring word v (+ v 1)))))\n  (define (iter i)\n    (cond\
    \ [(>= i (string-length word)) \"\"]\n          [(vowel? (substring word i (+\
    \ i 1)))\n           (cond [(between-consonants? i) (substring word i (+ i 1))]\n\
    \                 [else (iter (+ i 1))])]\n          [else (iter (+ i 1))]))\n\
    \  (iter 0))\n", "  (if (= \"\" word) \"\"\n      (let ([word-reversed (string-reverse\
    \ word)])\n        (let loop ([current-letter (string-ref word-reversed 0)] [index\
    \ 0])\n          (if (and (vowel? current-letter) (not (vowel? (string-ref word-reversed\
    \ (+ index 1)))))\n              (string-ref word (- (string-length word) index))\n\
    \              (loop (string-ref word-reversed (+ index 1)) (+ index 1)))))))\n",
  "  (if (string-index word (regexp \"[aeiou]\"))\n      (string-ref word (string-index\
    \ word (regexp \"[aeiou]\")))\n      \"\"))\n</code>\n", "  (let loop ([i (sub1\
    \ (string-length word))]\n             [res #f])\n    (cond\n      [(= i 0)\n\
    \       (if res\n           (string-ref word res)\n           \"\")]\n      [(member\
    \ (string-ref word i) (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n\
    \       (loop (- i 1) i)]\n      [else\n       (loop (- i 1) res)])))\n</code>\n",
  "  (define (is-vowel? letter)\n    (or (equal? letter \"a\")\n        (equal? letter\
    \ \"e\")\n        (equal? letter \"i\")\n        (equal? letter \"o\")\n     \
    \   (equal? letter \"u\")))\n  (define (is-consonant? letter)\n    (not (is-vowel?\
    \ letter)))\n  (define (is-middle-vowel? letter)\n    (is-vowel? letter)\n   \
    \ (let ((previous-letter (string-ref word (- (string-length word) 2)))\n     \
    \     (next-letter (string-ref word (- (string-length word) 1))))\n      (and\
    \ (is-consonant? previous-letter)\n           (is-consonant? next-letter))))\n\
    \  (define (iter counter)\n    (cond ((<= counter (string-length word)) \"\")\n\
    \          ((is-middle-vowel? (string-ref word (- (string-length word) counter)))\n\
    \           (string-ref word (- (string-length word) counter)))\n          (else\
    \ (iter (+ counter 1)))))\n  (iter 1))", "  (cond [(string=? word \"\") \"\"]\n\
    \        [(string=? word \"a\") \"\"]\n        [(string=? word \"e\") \"\"]\n\
    \        [(string=? word \"i\") \"\"]\n        [(string=? word \"o\") \"\"]\n\
    \        [(string=? word \"u\") \"\"]\n        [(string=? word \"A\") \"\"]\n\
    \        [(string=? word \"E\") \"\"]\n        [(string=? word \"I\") \"\"]\n\
    \        [(string=? word \"O\") \"\"]\n        [(string=? word \"U\") \"\"]\n\
    \        [else (cond [(and (char-vowel? (string-ref word (sub1 (string-length\
    \ word))))\n                          (char-vowel? (string-ref word (sub1 (sub1\
    \ (string-length word))))))\n                     (get_closest_vowel (substring\
    \ word 0 (sub1 (string-length word))))]\n                    [(and (char-vowel?\
    \ (string-ref word (sub1 (string-length word))))\n                          (char-consonant?\
    \ (string-ref word (sub1 (sub1 (string-length word))))))\n                   \
    \  (string-ref word (sub1 (string-length word)))]\n                    [else (get_closest_vowel\
    \ (substring word 0 (sub1 (string-length word))))])])\n        \n)\n", "  (define\
    \ (get-closest-vowel lst)\n    (letrec ([lst-len (length lst)]\n             [cons-lst\
    \ (find-cons lst)])\n      (if (= 1 (length cons-lst))\n          \"\"\n     \
    \     (let* ([first-cons (first cons-lst)]\n                 [next-cons (second\
    \ cons-lst)]\n                 [vowel-lst (find-vowel-between first-cons next-cons\
    \ lst)])\n            (if (and (not (empty? vowel-lst))\n                    \
    \ (= 1 (length vowel-lst)))\n                (string-upcase (string (first vowel-lst)))\n\
    \                \"\")))))\n  (get-closest-vowel (string->list word)))\n", " \
    \ (cond\n    [(string-empty? word) \"\"]\n    [(memq (string-ref word (- (string-length\
    \ word) 1))\n            '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n\
    \     (string-ref word (- (string-length word) 1))]\n    [else (get_closest_vowel\
    \ (substring word 0 (- (string-length word) 1)))]))\n", "  (for/first ([_ (in-range\
    \ (add1 (string-length word)))]\n              [ch (in-list (string->list word))])\n\
    \    (if (and (not (string-contains \"aeiou\" (string ch)))\n             (string-contains\
    \ \"aeiou\" (string (string-ref word (sub1 _)))))\n        (string ch))))\n</code>\n",
  "  (cond [(empty? word)\n         \"\"]\n        [(and (consonant? (last word))\n\
    \              (vowel? (first word)))\n         (get_closest_vowel (rest word))]\n\
    \        [(and (consonant? (last word))\n              (consonant? (first word)))\n\
    \         (vowel-between-consonants word)]\n        [else (vowel-between-consonants\
    \ word)]))\n", "  (define (get-vowel index)\n    (cond\n      [(equal? index -1)\
    \ \"\"]\n      [(or (equal? (string-ref word index) #\\a)\n           (equal?\
    \ (string-ref word index) #\\e)\n           (equal? (string-ref word index) #\\\
    i)\n           (equal? (string-ref word index) #\\o)\n           (equal? (string-ref\
    \ word index) #\\u)) (string-ref word index)]\n      [else (get-vowel (- index\
    \ 1))]))\n  (define (get-consonant index)\n    (cond\n      [(equal? index -1)\
    \ \"\"]\n      [(or (equal? (string-ref word index) #\\a)\n           (equal?\
    \ (string-ref word index) #\\e)\n           (equal? (string-ref word index) #\\\
    i)\n           (equal? (string-ref word index) #\\o)\n           (equal? (string-ref\
    \ word index) #\\u)) (get-consonant (- index 1))]\n      [else (string-ref word\
    \ index)]))\n  (define (is-consonant? index)\n    (cond\n      [(equal? index\
    \ -1) #f]\n      [(or (equal? (string-ref word index) #\\a)\n           (equal?\
    \ (string-ref word index) #\\e)\n           (equal? (string-ref word index) #\\\
    i)\n           (equal? (string-ref word index) #\\o)\n           (equal? (string-ref\
    \ word index) #\\u)) #f]\n      [else #t]))\n  (define (find-vowel index)\n  \
    \  (cond\n      [(equal? index -1) \"\"]\n      [(is-consonant? (- index 1)) (get-vowel\
    \ index)]\n      [else (find-vowel (- index 1))]))\n  (find-vowel (- (string-length\
    \ word) 1)))\n", "  (local [(define (reverse-word word)\n            (local [(define\
    \ (helper1 word new-word)\n                      (if (string-empty? word)\n  \
    \                        new-word\n                          (helper1 (substring\
    \ word 1 (sub1 (string-length word)))\n                                   (string-append\
    \ (substring word 0 1) new-word))))\n                    (define (helper2 word\
    \ new-word)\n                      (if (or (not (member (substring word 0 1) '(\"\
    a\" \"e\" \"i\" \"o\" \"u\")))\n                              (not (member (substring\
    \ new-word 0 1) '(\"a\" \"e\" \"i\" \"o\" \"u\"))))\n                        \
    \  (helper2 (substring word 1 (sub1 (string-length word)))\n                 \
    \                  (string-append (substring word 0 1) new-word))\n          \
    \                new-word))]\n              (if (string-empty? word)\n       \
    \           word\n                  (helper2 (helper1 word \"\") \"\"))))]\n \
    \   (reverse-word (reverse-word word))))", "  (local [(define (get-vowel word\
    \ idx vidx)\n            (cond [(not (string-ref word idx))\n                \
    \   (cond [(not (string-ref word vidx)) \"\"]\n                         [else\
    \ (string-ref word vidx)])]\n                  [(or (equal? #\\a (string-ref word\
    \ idx))\n                       (equal? #\\e (string-ref word idx))\n        \
    \               (equal? #\\i (string-ref word idx))\n                       (equal?\
    \ #\\o (string-ref word idx))\n                       (equal? #\\u (string-ref\
    \ word idx)))\n                   (get-vowel word (add1 idx) idx)]\n         \
    \         [else (get-vowel word (add1 idx) vidx)]))]\n    (get-vowel word (sub1\
    \ (string-length word)) (string-length word))))\n", "  (local ((define (is-vowel?\
    \ c)\n            (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\"\
    \ \"O\" \"U\"))))\n    (cond ((< (string-length word) 3) \"\")\n          ((is-vowel?\
    \ (string-ref word (- (string-length word) 2)))\n           (string-ref word (-\
    \ (string-length word) 2)))\n          ((is-vowel? (string-ref word (- (string-length\
    \ word) 3)))\n           (string-ref word (- (string-length word) 3)))\n     \
    \     (else \"\"))))\n", "  (define (vowel? x)\n    (member x '(#\\a #\\e #\\\
    i #\\o #\\u)))\n  (define (helper w)\n    (define (iter w so-far)\n      (if (and\
    \ (not (empty? w)) (vowel? (first w)))\n          (list (first w) so-far)\n  \
    \        (iter (rest w) (+ so-far 1))))\n    (iter w 0))\n  (let loop ((w word)\
    \ (vowels '(#\\a #\\e #\\i #\\o #\\u)))\n    (if (or (empty? w) (vowel? (first\
    \ w)))\n        \"\"\n        (let ((n (helper w)))\n          (if (positive?\
    \ (second n))\n              (loop (rest w) vowels)\n              (first n))))))\n",
  "  (cond\n    [(string-empty? word) \"\"]\n    [(regexp-match #rx\"[aeiou]\" word)\n\
    \     (get_closest_vowel (regexp-replace #rx\"[aeiou]\" word \"\"))]\n    [else\
    \ word]))", "  (cond [(empty? word) empty]\n        [(and (in-list? (string-ref\
    \ word -1) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n              (in-list? (string-ref\
    \ word -2) '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n         (get_closest_vowel (substring\
    \ word 0 -1))]\n        [(in-list? (string-ref word -1) '(\"a\" \"e\" \"i\" \"\
    o\" \"u\"))\n         (string-ref word -1)]\n        [else empty]))\n", "  (let*\
    \ ([letters (string->list word)]\n         [length (length letters)]\n       \
    \  [indices (for/list ([i (in-range length)]) i)])\n    (for/first ([i (in-list\
    \ indices)]\n                #:when (and (not (char-vowel? (list-ref letters i)))\n\
    \                            (or (char-vowel? (list-ref letters (- i 1)))\n  \
    \                              (char-vowel? (list-ref letters (+ i 1))))))\n \
    \     (if (char-vowel? (list-ref letters (- i 1)))\n          (list-ref letters\
    \ (- i 1))\n          (list-ref letters (+ i 1))))))\n", "  (define (valid? c)\n\
    \    (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \  (cond\n    [(empty? word) \"\"]\n    [(or (valid? (first word)) (valid? (last\
    \ word))) (get_closest_vowel (butlast (rest word)))]\n    [(not (valid? (first\
    \ word))) (get_closest_vowel (rest word))]\n    [else (first word)]))\n</code>\n\
    I am very new to Racket, and I was wondering how I can make this code more elegant?\
    \ In Python I would use a list comprehension, but I'm not sure how to do that\
    \ in Racket. I would also use a generator function, but I am not sure how to write\
    \ a Racket generator function. Can I also please get a description of what I am\
    \ doing wrong in each of my code? That's the only way I will learn. Thanks in\
    \ advance!\n\n\nA:\n\nYour code is hard to follow and doesn't work properly, but\
    \ here's a fix:\n<code>(define (get-closest-vowel word)\n  (define (valid? c)\n\
    \    (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \  (define (not-valid? c)\n    (not (valid? c)))\n  (cond\n    [(empty? word)\
    \ \"\"]\n    [(valid? (first word)) (get-closest-vowel (rest word))]\n    [(not-valid?\
    \ (first word))\n     (cond\n       [(and (empty? (rest word)) \"\")]\n      \
    \ [(not-valid? (second word)) (get-closest-vowel (rest word))]\n       [else (first\
    \ word)])]))\n</code>\nThe second condition of <code>cond</code> was wrong. You\
    \ wanted to check that the first letter of the word was a vowel, not that it was\
    \ not a vowel. Also, you needed a third condition that checked that the second\
    \ letter was a vowel.\n", "  (local [(define (solve word v)\n            (cond\n\
    \              [(string=? (string-ref word 0) v) v]\n              [(string=?\
    \ \"\" word) \"\"]\n              [else (solve (substring word 1) v)]))]\n   \
    \ (let-values ([(c f r) (string-split word (string-append (regexp \"[aeiou]\"\
    ) \"+\"))])\n      (cond\n        [(string=? c \"\") \"\"]\n        [(string=?\
    \ f \"\")\n         (solve (string-append (substring r 0 (string-length r)) c)\
    \ \"a\")]\n        [(string=? r \"\") \"\"]\n        [else (solve (string-append\
    \ (substring r 0 (string-length r)) c) f)]))))\n", "  (define (cons? c) (member\
    \ c \"bcdfghjklmnpqrstvwxyz\"))\n  (define (vowel? c) (member c \"aeiou\"))\n\
    \  (let ([n (string-length word)])\n    (let loop ([i (- n 1)])\n      (if (&lt;\
    \ i 0)\n          \"\"\n          (let ([p (string-ref word i)])\n           \
    \ (if (and (cons? p) (vowel? (string-ref word (- i 1))))\n                (string-ref\
    \ word (- i 1))\n                (loop (- i 1))))))))\n</code>\n", "  (define\
    \ (get-closest-vowel-helper word)\n    (cond\n      [(empty? word) empty]\n  \
    \    [(or (string=? \"a\" (car word)) (string=? \"e\" (car word))\n          \
    \ (string=? \"i\" (car word)) (string=? \"o\" (car word))\n           (string=?\
    \ \"u\" (car word)) (string=? \"A\" (car word))\n           (string=? \"E\" (car\
    \ word)) (string=? \"I\" (car word))\n           (string=? \"O\" (car word)) (string=?\
    \ \"U\" (car word)))\n       (car word)]\n      [else (get-closest-vowel-helper\
    \ (cdr word))]))\n  (define (first-is-vowel? word)\n    (or (string=? \"a\" (car\
    \ word)) (string=? \"e\" (car word))\n           (string=? \"i\" (car word)) (string=?\
    \ \"o\" (car word))\n           (string=? \"u\" (car word)) (string=? \"A\" (car\
    \ word))\n           (string=? \"E\" (car word)) (string=? \"I\" (car word))\n\
    \           (string=? \"O\" (car word)) (string=? \"U\" (car word))))\n  (define\
    \ (last-is-vowel? word)\n    (or (string=? \"a\" (last word)) (string=? \"e\"\
    \ (last word))\n           (string=? \"i\" (last word)) (string=? \"o\" (last\
    \ word))\n           (string=? \"u\" (last word)) (string=? \"A\" (last word))\n\
    \           (string=? \"E\" (last word)) (string=? \"I\" (last word))\n      \
    \     (string=? \"O\" (last word)) (string=? \"U\" (last word))))\n  (define (last-is-consonant?\
    \ word)\n    (not (last-is-vowel? word)))\n  (cond\n    [(string=? word \"\")\
    \ empty]\n    [(and (first-is-", "  (cond\n    [(or (= \"\" word) (member (string-ref\
    \ word 0) \"AEIOUaeiou\")) \"\"]\n    [(member (string-ref word 1) \"AEIOUaeiou\"\
    ) (string-ref word 1)]\n    [(member (string-ref word 2) \"AEIOUaeiou\") (string-ref\
    \ word 2)]\n    [(member (string-ref word 3) \"AEIOUaeiou\") (string-ref word\
    \ 3)]\n    [(member (string-ref word 4) \"AEIOUaeiou\") (string-ref word 4)]\n\
    \    [(member (string-ref word 5) \"AEIOUaeiou\") (string-ref word 5)]\n    [(member\
    \ (string-ref word 6) \"AEIOUaeiou\") (string-ref word 6)]\n    [(member (string-ref\
    \ word 7) \"AEIOUaeiou\") (string-ref word 7)]\n    [(member (string-ref word\
    \ 8) \"AEIOUaeiou\") (string-ref word 8)]\n    [(member (string-ref word 9) \"\
    AEIOUaeiou\") (string-ref word 9)]\n    [(member (string-ref word 10) \"AEIOUaeiou\"\
    ) (string-ref word 10)]\n    [(member (string-ref word 11) \"AEIOUaeiou\") (string-ref\
    \ word 11)]\n    [(member (string-ref word 12) \"AEIOUaeiou\") (string-ref word\
    \ 12)]\n    [(member (string-ref word 13) \"AEIOUaeiou\") (string-ref word 13)]\n\
    \    [(member (string-ref word 14) \"AEIOUaeiou\") (string-ref word 14)]\n   \
    \ [(member (string-ref word 15) \"AEIOUaeiou\") (string-ref word 15)]\n    [(member\
    \ (string-ref word 16) \"AEIOUaeiou\") (string-ref word 16)]\n    [(member (string-ref\
    \ word 17) \"AEIOUaeiou\") (string-ref word 17)]\n    [(member (string-ref word\
    \ 18) \"AEIOUaeiou\") (string-ref word 18)]\n    [(member (string-ref word 19)\
    \ \"AE", "  (cond ((empty? word) \"\")\n        ((regexp-match #rx\"[aeiou]\"\
    \ (reverse word)) => (\u03BB (x) (substring (reverse word) (regexp-match-end 0\
    \ x) (regexp-match-end 0 x))))\n        (else \"\")))\n", "  (cond [(equal? \"\
    \" word) \"\"]\n        [(or (or (or (equal? \"a\" (substring word -1))\n    \
    \                (equal? \"e\" (substring word -1)))\n                (equal?\
    \ \"i\" (substring word -1)))\n            (equal? \"o\" (substring word -1)))\n\
    \         (substring word -1)]\n        [(or (or (or (equal? \"a\" (substring\
    \ word -2 -1))\n                    (equal? \"e\" (substring word -2 -1)))\n \
    \               (equal? \"i\" (substring word -2 -1)))\n            (equal? \"\
    o\" (substring word -2 -1)))\n         (substring word -2 -1)]\n        [(or (or\
    \ (or (equal? \"a\" (substring word -3 -2))\n                    (equal? \"e\"\
    \ (substring word -3 -2)))\n                (equal? \"i\" (substring word -3 -2)))\n\
    \            (equal? \"o\" (substring word -3 -2)))\n         (substring word\
    \ -3 -2)]\n        [(or (or (or (equal? \"a\" (substring word -4 -3))\n      \
    \              (equal? \"e\" (substring word -4 -3)))\n                (equal?\
    \ \"i\" (substring word -4 -3)))\n            (equal? \"o\" (substring word -4\
    \ -3)))\n         (substring word -4 -3)]\n        [(or (or (or (equal? \"a\"\
    \ (substring word -5 -4))\n                    (equal? \"e\" (substring word -5\
    \ -4)))\n                (equal? \"i\" (substring word -5 -4)))\n            (equal?\
    \ \"o\" (substring word -5 -4)))\n         (substring word -5 -4)]\n        [(or\
    \ (or (or (equal? \"a\" (substring word -6 -5))\n                    (equal? \"\
    e\" (substring word -6 -5)))\n                (equal? \"i\" (substring word -6\
    \ -5)))\n            (equal? \"o\" (substring word -6 -5)))\n         (substring\
    \ word -6 -5)]", "  (letrec\n      ((closest-vowel\n        (lambda (word)\n \
    \         (letrec\n              ((get-closest-vowel-helper\n                (lambda\
    \ (word)\n                  (cond\n                    [(string-empty? word) \"\
    \"]\n                    [(memq (string-ref word (sub1 (string-length word)))\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n                     (get-closest-vowel-helper\
    \ (substring word 0 (sub1 (string-length word))))]\n                    [(memq\
    \ (string-ref word 0) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n                    \
    \ (string-ref word 0)]\n                    [else\n                     (get-closest-vowel-helper\
    \ (substring word 1 (string-length word)))]))))\n            (get-closest-vowel-helper\
    \ word))))\n    (closest-vowel word)))\n</code>\n", "  (for ([i (in-range (sub1\
    \ (string-length word)))])\n    (let ([char (string-ref word i)])\n      (if (and\
    \ (not (is-vowel? char))\n               (is-vowel? (string-ref word (add1 i))))\n\
    \          (return (string-ref word (add1 i)))))))\n", "    (cond ((member (string-ref\
    \ word (sub1 (string-length word))) \"AEIOUaeiou\") \"\")\n          ((member\
    \ (string-ref word (sub1 (string-length word))) \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    )\n           (get_closest_vowel (substring word 0 (sub1 (string-length word)))))\n\
    \          (else (string-ref word (sub1 (string-length word))))))\n</code>\nI'd\
    \ like to have a more concise way to write the first line of the 'cond' expression.\n\
    The rest two lines are to make sure that the 'word' has two or more letters.\n\
    I wonder if there's a better way to do this as well.\nThanks!\n\n\nA:\n\nI'd write\
    \ this in two steps: first, find the first vowel that's between two consonants.\
    \  (I'll call this <code>find-closest-vowel</code>.)  Then, for <code>get-closest-vowel</code>,\
    \ find the last such vowel.\n<code>(define (find-closest-vowel word)\n  (let f\
    \ ([i 0] [prev #\\not-a-letter])\n    (let ([char (string-ref word i)])\n    \
    \  (cond\n        [(member char \"AEIOUaeiou\") (if (member prev \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    ) char #\\not-a-letter)]\n        [(and (&lt; i (sub1 (string-length word)))\n\
    \              (member char \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\")) (f\
    \ (add1 i) char)]\n        [else #\\not-a-letter]))))\n", "  (get-closest-vowel-helper\
    \ word (string-length word) #f #f))\n", "  (cond\n    [(and (char-vowel? (string-ref\
    \ word (sub1 (string-length word))))\n          (char-vowel? (string-ref word\
    \ (sub1 (sub1 (string-length word))))))\n     (string-ref word (sub1 (string-length\
    \ word)))]\n    [(char-vowel? (string-ref word (sub1 (string-length word))))\n\
    \     (string-ref word (sub1 (string-length word)))]\n    [(and (char-vowel? (string-ref\
    \ word (sub1 (sub1 (string-length word)))))\n          (char-vowel? (string-ref\
    \ word (sub1 (sub1 (sub1 (string-length word)))))))\n     (string-ref word (sub1\
    \ (sub1 (string-length word))))]\n    [(char-vowel? (string-ref word (sub1 (sub1\
    \ (string-length word)))))\n     (string-ref word (sub1 (sub1 (string-length word))))]\n\
    \    [(and (char-vowel? (string-ref word (sub1 (sub1 (sub1 (string-length word))))))\n\
    \          (char-vowel? (string-ref word (sub1 (sub1 (sub1 (sub1 (string-length\
    \ word))))))))\n     (string-ref word (sub1 (sub1 (sub1 (string-length word)))))]\n\
    \    [(char-vowel? (string-ref word (sub1 (sub1 (sub1 (string-length word))))))\n\
    \     (string-ref word (sub1 (sub1 (sub1 (string-length word)))))]\n    [(and\
    \ (char-vowel? (string-ref word (sub1 (sub1 (sub1 (sub1 (string-length word)))))))\n\
    \          (char-vowel? (string-ref word (sub1 (sub1 (sub1 (sub1 (sub1 (string-length\
    \ word)))))))))\n     (string-ref word (sub1 (sub1 (sub1 (sub1 (string-length\
    \ word))))))]\n    [(char-vowel? (string-ref word (sub1 (sub1 (sub1 (sub1 (string-length\
    \ word)))))))", "  (define vowels (list #\\a #\\e #\\i #\\o #\\u))\n  (define\
    \ (is-vowel? char)\n    (member char vowels))\n  (define (find-vowel? word i)\n\
    \    (cond [(> i (string-length word)) false]\n          [(is-vowel? (string-ref\
    \ word i)) true]\n          [else (find-vowel? word (+ i 1))]))\n  (define (find-closest-vowel\
    \ word i)\n    (cond [(> i (string-length word)) \"\"]\n          [(find-vowel?\
    \ word (+ i 1)) (string-ref word (+ i 1))]\n          [else (find-closest-vowel\
    \ word (+ i 1))]))\n  (cond [(<= (string-length word) 1) \"\"]\n        [(is-vowel?\
    \ (string-ref word 0)) (find-closest-vowel word 1)]\n        [(is-vowel? (string-ref\
    \ word 1)) (find-closest-vowel word 1)]\n        [else (find-closest-vowel word\
    \ 2)]))\n", "  (local [(define vowels '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U))\n          (define pos 0)]\n    (for/or ([c (in-string word)])\n\
    \      (if (member c vowels)\n          (if (and (&gt; (add1 pos) 1)\n       \
    \            (member (string-ref word (- pos 1)) vowels))\n              (if (and\
    \ (&gt; (add1 pos) 2)\n                       (member (string-ref word (- pos\
    \ 2)) vowels))\n                  #f\n                  c)\n              c)\n\
    \          (set! pos (add1 pos))\n          #f))))\n</code>\n", "  (letrec ([is-vowel?\
    \ (lambda (char)\n                        (member char '(\"a\" \"e\" \"i\" \"\
    o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))]\n           [closest-vowel-from-right\
    \ (lambda (str)\n                                       (for/first ([char (in-list\
    \ (string->list str))]\n                                                   #:when\
    \ (is-vowel? char))\n                                         char))])\n    (closest-vowel-from-right\
    \ word)))\n", "  (cond\n    [(string-empty? word) \"\"]\n    [(string-ci=? (substring\
    \ word -1) \"a\") \"a\"]\n    [(string-ci=? (substring word -1) \"e\") \"e\"]\n\
    \    [(string-ci=? (substring word -1) \"i\") \"i\"]\n    [(string-ci=? (substring\
    \ word -1) \"o\") \"o\"]\n    [(string-ci=? (substring word -1) \"u\") \"u\"]\n\
    \    [else (get_closest_vowel (substring word 0 -1))]))", "  (let ((vowels '(\"\
    a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n        (closest-vowel\
    \ \"\"))\n    (for ([ch (in-list (string->list word))])\n      (cond\n       \
    \ [(member ch vowels)\n         (let ([next-ch (list-ref (string->list word) (+\
    \ 1 (list-position (string->list word) ch)))])\n           (if (member next-ch\
    \ vowels)\n               (set! closest-vowel (string ch))\n               (set!\
    \ closest-vowel \"\")))]\n        [else (set! closest-vowel \"\")]))\n    closest-vowel))\n",
  "  (cond ((null? word) \"\")\n        ((vowel? (last word)) (get_closest_vowel (butlast\
    \ word)))\n        ((vowel? (first word)) \"\")\n        (else (get_closest_vowel\
    \ (rest word)))))\n", "  (match word\n    [(cons current-char '()) \"\" ]\n  \
    \  [(cons current-char (cons next-char '()))\n     (match current-char\n     \
    \  [\"A\" \"A\"]\n       [\"E\" \"E\"]\n       [\"I\" \"I\"]\n       [\"O\" \"\
    O\"]\n       [\"U\" \"U\"]\n       [_ \"\" ] ) ]\n    [(cons current-char (cons\
    \ next-char rest))\n     (match current-char\n       [\"A\" \"A\"]\n       [\"\
    E\" \"E\"]\n       [\"I\" \"I\"]\n       [\"O\" \"O\"]\n       [\"U\" \"U\"]\n\
    \       [_ (get_closest_vowel (cons next-char rest))] ) ] ) )\n", "  (define vowels\
    \ '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (is-vowel?\
    \ c)\n    (member c vowels))\n  (define (find-vowel word)\n    (cond\n      [(empty?\
    \ word) empty]\n      [(is-vowel? (first word)) (first word)]\n      [else (find-vowel\
    \ (rest word))]))\n  (define (find-consonant word)\n    (cond\n      [(empty?\
    \ word) empty]\n      [(is-vowel? (first word)) (find-consonant (rest word))]\n\
    \      [else (first word)]))\n  (define (find-closest word)\n    (cond\n     \
    \ [(empty? word) empty]\n      [(is-vowel? (first word)) (first word)]\n     \
    \ [else (find-closest (rest word))]))\n  (define (find-result word)\n    (define\
    \ consonant (find-consonant word))\n    (define vowel (find-vowel (rest (reverse\
    \ word))))\n    (cond\n      [(empty? consonant) empty]\n      [(empty? vowel)\
    \ empty]\n      [else (find-closest (reverse (rest (reverse word))))]))\n  (find-result\
    \ word))\n", "  (cond [(empty? word) empty]\n        [(and (consonant? (first\
    \ word))\n              (consonant? (second word)))\n         (get_closest_vowel\
    \ (rest word))]\n        [(vowel? (first word)) (first word)]\n        [else (get_closest_vowel\
    \ (rest word))]))\n", "  (regexp-match* #rx\"[^aieou]*([aieou])[^aieou]*\" word))\n",
  "  (let ([string->list (string->list word)]\n        [length (length string->list)]\n\
    \        [new-length (- length 1)])\n    (for ([i (in-range 0 new-length)])\n\
    \      (if (and (char-alphabetic? (list-ref string->list i))\n               (char-alphabetic?\
    \ (list-ref string->list (- length i 1))))\n          (cond [(memv (list-ref string->list\
    \ (- length i 1))\n                       '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n\
    \                 (string (list-ref string->list (- length i 1)))]\n         \
    \       [else \"\" ])))))\n", "  (cond\n    ((< (string-length word) 3) \"\")\n\
    \    ((member (string-ref word (- (string-length word) 1)) '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\")) \"\")\n    ((member (string-ref word (- (string-length word) 2))\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\")) \"\")\n    ((member (string-ref word (- (string-length\
    \ word) 3)) '(\"a\" \"e\" \"i\" \"o\" \"u\")) \n     (string-ref word (- (string-length\
    \ word) 3)))\n    (else (get_closest_vowel (substring word 0 (- (string-length\
    \ word) 1))))))", "  (or (any-vowel-right? (reverse word)) \"\"))\n", "  (let\
    \ loop ([str (list->string (reverse (string->list word)))])\n    (cond\n     \
    \ [(string=? str \"\") \"\"]\n      [(member (string-first str) '(#\\a #\\e #\\\
    i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n       (string-first str)]\n      [else\
    \ (loop (string-tail str))])))", "  (cond\n    [(empty? word) (list)]\n    [(char-alphabetic?\
    \ (first word))\n     (cons (first word) (get_closest_vowel (rest word)))]\n \
    \   [else (get_closest_vowel (rest word))]))\n", "  (let* ([word (string->list\
    \ word)]\n         [word (reverse word)]\n         [vowels '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")]\n         [closest-vowel \"\"])\n\
    \    (let find-closest-vowel ([word word])\n      (if (and (not (null? word))\
    \ (member (list-ref word 0) vowels))\n          (begin\n            (set! closest-vowel\
    \ (list-ref word 0))\n            (if (or (equal? (list-ref word 0) \"a\") (equal?\
    \ (list-ref word 0) \"A\"))\n                (set! closest-vowel \"a\")\n    \
    \            (if (or (equal? (list-ref word 0) \"e\") (equal? (list-ref word 0)\
    \ \"E\"))\n                    (set! closest-vowel \"e\")\n                  \
    \  (if (or (equal? (list-ref word 0) \"i\") (equal? (list-ref word 0) \"I\"))\n\
    \                        (set! closest-vowel \"i\")\n                        (if\
    \ (or (equal? (list-ref word 0) \"o\") (equal? (list-ref word 0) \"O\"))\n   \
    \                         (set! closest-vowel \"o\")\n                       \
    \     (if (or (equal? (list-ref word 0) \"u\") (equal? (list-ref word 0) \"U\"\
    ))\n                                (set! closest-vowel \"u\")))))))\n       \
    \     (find-closest-vowel (cdr word)))\n          (if (and (not (null? word))\
    \ (not (member (list-ref word 0) vowels)))\n              (find-closest-vowel\
    \ (cdr word))\n              closest-vowel))))))\n```\n\n**Sample Test(s)**\n\n\
    ```racket", "  (let ([vowels \"aeiou\"])\n    (cond [(empty? word) \"\"]\n   \
    \       [(vowel? (first word)) (get_closest_vowel (rest word))]\n          [(member?\
    \ (first word) vowels) (cons (first word) (get_closest_vowel (rest word)))]\n\
    \          [else (get_closest_vowel (rest word))])))\n", "  (let ([vowels '(a\
    \ e i o u)]\n        [word-reverse (reverse word)])\n    (let loop ([i (sub1 (string-length\
    \ word))]\n               [previous-char #\\ ]\n               [next-char #\\\
    \ ])\n      (if (and (= i 0) (member previous-char vowels))\n          \"\"\n\
    \          (cond [(member next-char vowels) (substring word (- i) i)]\n      \
    \          [(> i 0) (loop (sub1 i) next-char (string-ref word-reverse i))]\n \
    \               [else \"\" ])))))\n", "  (let ([word (string->list word)])\n \
    \   (let loop ([start #f] [end #f] [i 0])\n      (if (and start end) end\n   \
    \       (if (and (not (vowel? (list-ref word i)))\n                   (not (vowel?\
    \ (list-ref word (- (length word) i 1)))))\n              (loop start start (+\
    \ i 1))\n              (if (vowel? (list-ref word i))\n                  (loop\
    \ i end (+ i 1))\n                  (loop start end (+ i 1))))))))", "  (cond\n\
    \    [(string-empty? word) \"\"]\n    [(char-alphabetic? (string-ref word (- (string-length\
    \ word) 1)))\n     (get_closest_vowel (substring word 0 (- (string-length word)\
    \ 1)))]\n    [(char-alphabetic? (string-ref word 0))\n     (get_closest_vowel\
    \ (substring word 1 (string-length word)))]\n    [else\n     (get_closest_vowel-helper\
    \ word (- (string-length word) 1))]))\n", "  (define chars (string->list word))\n\
    \  (define vowels '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define\
    \ (has-vowel? word)\n    (andmap (\u03BB (char) (member char vowels)) word))\n\
    \  (define (has-consonant? word)\n    (andmap (\u03BB (char) (not (member char\
    \ vowels))) word))\n  (define (get-closest-vowel-index word)\n    (let* ([rev-word\
    \ (reverse word)]\n           [has-vowel? (has-vowel? rev-word)]\n           [has-consonant?\
    \ (has-consonant? rev-word)])\n      (if (and has-vowel? has-consonant?)\n   \
    \       (list-ref rev-word 1)\n          \"\")))\n  (define (index-to-char index)\n\
    \    (string-ref word index))\n  (index-to-char (get-closest-vowel-index chars)))\n",
  "  (string-ref word (for/first ([i (in-range (sub1 (string-length word)))])\n  \
    \                   (and \n                      (char-set=? (char-set-contains?\
    \ (char-set '#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U) (string-ref word\
    \ i)) #t)\n                      (char-set=? (char-set-contains? (char-set '#\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U) (string-ref word (- i 1))) #f)\n\
    \                      (char-set=? (char-set-contains? (char-set '#\\a #\\e #\\\
    i #\\o #\\u #\\A #\\E #\\I #\\O #\\U) (string-ref word (+ i 1))) #f)\n       \
    \               i))))", "  (for/first ([chars (in-list (string->list word))]\n\
    \              [i (in-range (add1 (string-length word)))])\n    (if (and (regexp-match?\
    \ \"[aeiou]\" (string chars))\n             (regexp-match? \"[^aeiou]\" (string\
    \ (list-ref (string->list word) (sub1 i))))\n             (regexp-match? \"[^aeiou]\"\
    \ (string (list-ref (string->list word) (add1 i)))))\n        (string chars)\n\
    \        \"\")))\n", "  (cond\n    [(regexp-match #rx\"^[^aeiou]*[aeiou][^aeiou]*$\"\
    \ word)\n     (regexp-match #rx\"[aeiou][^aeiou]*$\" word) (first (regexp-match\
    \ #rx\"[aeiou]\" (regexp-match #rx\"[aeiou][^aeiou]*$\" word)))]\n    [else \"\
    \"]))\n</code>\n", "  (define (get-vowel word)\n    (if (empty? word)\n      \
    \  \"\"\n        (if (char-vowel? (first word))\n            (first word)\n  \
    \          (get-vowel (rest word)))))\n  (define (char-vowel? c)\n    (define\
    \ (check-vowel c vw)\n      (if (empty? vw)\n          #f\n          (if (equal?\
    \ c (first vw))\n              #t\n              (check-vowel c (rest vw)))))\n\
    \    (check-vowel c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"\
    U\")))\n  (define (get-vowel-between-consonants c word)\n    (if (empty? word)\n\
    \        \"\"\n        (if (char-vowel? (first word))\n            c\n       \
    \     (get-vowel-between-consonants c (rest word)))))\n  (get-vowel-between-consonants\
    \ (get-vowel word) word))\n", "  (cond\n    [(empty? word) \"\"]\n    [(and (regexp-match?\
    \ #rx\"[AEIOUaeiou]\" (string-ref word (sub1 (string-length word))))\n       \
    \   (regexp-match? #rx\"[^AEIOUaeiou]\" (string-ref word (sub1 (string-length\
    \ word)))))\n     (string-ref word (sub1 (string-length word)))]\n    [else (get_closest_vowel\
    \ (substring word 0 (sub1 (string-length word))))]))\n", "  (let ([length (string-length\
    \ word)])\n    (define (consonant-at? pos)\n      (regexp-match #rx\"[^aeiou]\"\
    \ (substring word pos (+ pos 1))))\n    (define (vowel-at? pos)\n      (regexp-match\
    \ #rx\"[aeiou]\" (substring word pos (+ pos 1))))\n    (define (get-closest-vowel\
    \ length)\n      (define (get-closest-vowel-h index)\n        (cond [(eq? index\
    \ length) \"\"]\n              [(consonant-at? index) (if (consonant-at? (- index\
    \ 1)) \"\")\n                                        (get-closest-vowel-h (- index\
    \ 1))]\n              [(vowel-at? index) (substring word index (+ index 1))]\n\
    \              [else (get-closest-vowel-h (- index 1))]))\n      (get-closest-vowel-h\
    \ (- length 1)))\n    (if (or (eq? 0 length)\n            (vowel-at? 0))\n   \
    \     \"\"\n        (get-closest-vowel length))))\n", "  (let loop ([word (string-&gt;list\
    \ word)]\n             [result (list)]\n             [prev #\\consonant]\n   \
    \          [current #\\consonant])\n    (if (or (null? word) (and (string-ci=?\
    \ prev #\\consonant) (string-ci=? current #\\consonant)))\n        (if (null?\
    \ result)\n            \"\"\n            (list-&gt;string result))\n        (loop\
    \ (cdr word)\n              (if (string-ci=? current #\\consonant)\n         \
    \         result\n                  (cons current result))\n              current\n\
    \              (string-downcase (list-ref word 0)))))\n  )\n", "  (let ([closest\
    \ '()])\n    (for ([c (in-list (string->list word))])\n      (cond\n        [(vowel?\
    \ c) (set! closest (cons c closest))]\n        [(and (not (empty? closest)) (consonant?\
    \ c)) (printf \"~a~n\" (list->string (reverse closest)))]\n        [else '()]))\n\
    \    (list->string (reverse closest))))\n", "  (define vowels \"aeiouAEIOU\")\n\
    \  (define cntr 0)\n  (define wordlen (string-length word))\n  (define result\
    \ \"\")\n  (define (is-consonant ch)\n    (not (contains? vowels ch)))\n  (define\
    \ (get-closest-vowel)\n    (let loop ([i (- wordlen 1)])\n      (let* ([char (string-ref\
    \ word i)]\n             [prev (string-ref word (- i 1))])\n        (if (and (is-consonant\
    \ char) (is-consonant prev))\n            (if (contains? vowels prev)\n      \
    \          (set! result prev)\n                (loop (- i 1)))\n            (if\
    \ (contains? vowels char)\n                (set! result char)\n              \
    \  (loop (- i 1)))))))\n  (get-closest-vowel)\n  result)\n</code>\nI think the\
    \ logic is simple enough to follow, but the performance is poor. \nIt seems that\
    \ <code>string-ref</code> is very expensive. \nFirst I tried to <code>set!</code>\
    \ to various local variables in the <code>get-closest-vowel</code> procedure,\
    \ but that didn't work.\nI think the problem with the <code>set!</code> is that\
    \ the local variables in the <code>get-closest-vowel</code> scope go out of scope\
    \ immediately after the procedure finishes.\nI think that the <code>loop</code>\
    \ is there just for convenience, but if I remove it, I need to introduce another\
    \ local variable for the <code>result</code> and <code>i</code>.\nIs it really\
    \ the <code>set!</code> and the procedures that make the program run slow? Or\
    \ I'm just not approaching the problem properly?\n\n\nA:\n\nI'm not sure if I\
    \ should put this as an answer or not, but it's too big for a comment so I'll\
    \ throw it in.\nYour solution is good in terms of the algorithm and efficiency,\
    \ but I think what you're missing is the use of <code>strings</code> in Racket\
    \ - they're not just single characters.\nIn Racket,", "  (define vowels '(\"a\"\
    \ \"e\" \"i\" \"o\" \"u\"))\n  (define (vowel? c)\n    (member c vowels))\n  (define\
    \ (consonant? c)\n    (not (vowel? c)))\n  (let loop ([word (string->list word)]\n\
    \             [closest-vowel #f])\n    (cond\n      [(empty? word)\n       (if\
    \ closest-vowel\n           (list->string (reverse closest-vowel))\n         \
    \  \"\")]\n      [(and (consonant? (first word))\n            (consonant? (second\
    \ word))\n            (vowel? (third word)))\n       (loop (rest word) (cons (third\
    \ word) closest-vowel))]\n      [else\n       (loop (rest word) closest-vowel)])))\n\
    </code>\n", "  (if (empty? word)\n      \"\"\n      (if (regexp-match \"[aeiou]\"\
    \ (string-take word 1))\n          (get_closest_vowel (string-drop word 1))\n\
    \          (if (regexp-match \"[^aeiou]\" (string-take word 1))\n            \
    \  (get_closest_vowel (string-drop word 1))\n              (get_closest_vowel\
    \ (string-drop word 1))))))\n", "  (if (empty? word)\n      \"\"\n      (let*\
    \ ([chars (string->list word)]\n             [len (length chars)]\n          \
    \   [i (dec len)])\n        (while (not (or (and (not (vowel? (list-ref chars\
    \ i)))\n                             (vowel? (list-ref chars (dec i))))\n    \
    \                    (zero? i)))\n          (set! i (dec i)))\n        (if (vowel?\
    \ (list-ref chars i))\n            (char->string (list-ref chars i))\n       \
    \     \"\"))))\n", "  (cond\n    [(string-contains? word \"a\") \"a\"]\n    [(string-contains?\
    \ word \"e\") \"e\"]\n    [(string-contains? word \"i\") \"i\"]\n    [(string-contains?\
    \ word \"o\") \"o\"]\n    [(string-contains? word \"u\") \"u\"]\n    [else \"\"\
    ]))\n", "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\\
    U)]\n        [answer #f])\n    (for ([i (in-range (sub1 (string-length word)))])\n\
    \      (let ([char (string-ref word i)])\n        (when (member char vowels)\n\
    \          (let ([prev (string-ref word (sub1 i))]\n                [next (string-ref\
    \ word (add1 i))])\n            (when (and (member prev vowels) (member next vowels))\n\
    \              (set! answer char))))))\n    (or answer \"\")))\n```\n\n```racket\n\
    #lang racket\n", "  (define (is_cons? c)\n    (member c '(\"B\" \"C\" \"D\" \"\
    F\" \"G\" \"H\" \"J\" \"K\" \"L\" \"M\" \"N\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"\
    V\" \"W\" \"X\" \"Y\" \"Z\")))\n  (define (is_vowel? c)\n    (member c '(\"A\"\
    \ \"E\" \"I\" \"O\" \"U\")))\n  (define (get-vowel word)\n    (cond\n      [(empty?\
    \ word) \"\"]\n      [(is_vowel? (first word)) (first word)]\n      [else (get-vowel\
    \ (rest word))]))\n  (define (get-the-closest-vowel word)\n    (cond\n      [(empty?\
    \ word) \"\"]\n      [(is_cons? (first word))\n       (get-vowel (rest word))]\n\
    \      [else (get-the-closest-vowel (rest word))]))\n  (if (is_cons? (first word))\n\
    \      (get-the-closest-vowel word)\n      (get-vowel word)))\n", "  (cond\n \
    \   ((string-length word) 1)\n    (else \"too short\")))\n</code>\nI think I need\
    \ to use string-contains or string-index, but I am not sure.\nI am not sure if\
    \ I can use the same method to get the closest vowel from the left side. If I\
    \ can, could you please give me some hint?\nI also have a harder part. If I am\
    \ given a word and a letter (vowel or consonant), how can I find out the closest\
    \ letter that stands between two vowels or two consonants from the right side\
    \ of the word?\n\n\nA:\n\nYou can use the built-in <code>vowel?</code> and <code>consonant?</code>\
    \ procedures (check Racket's docs for more info):\n<code>(define (get-closest-vowel\
    \ word)\n  (cond\n    ((empty? word)\n     (error \"The given word is empty\"\
    ))\n    ((or (vowel? (string-ref word 0))\n         (vowel? (string-ref word 1)))\n\
    \     (error \"The given word doesn't contain any consonant\"))\n    (else\n \
    \    (get-closest-vowel/aux word (substring word 2)))))\n", "  (define vowels\
    \ \"aeiou\")\n  (define (is_vowel x) (string-index vowels x))\n  (define (is_consonant\
    \ x) (not (is_vowel x)))\n  (define (next xs) (cdr xs))\n  (define (first xs)\
    \ (car xs))\n  (define (loop xs out)\n    (if (null? xs)\n        (if (null? out)\n\
    \            \"\"\n            (string (first out)))\n        (if (is_vowel (first\
    \ xs))\n            (loop (next xs) (cons (first xs) out))\n            (if (is_consonant\
    \ (first xs))\n                (if (is_consonant (first out))\n              \
    \      (loop (next xs) out)\n                    (string (first out)))\n     \
    \           (loop (next xs) out)))))\n  (loop (string->list word) '()))\n", " \
    \ (let* ((word (string->list word))\n         (vowels (list #\\a #\\e #\\i #\\\
    o #\\u #\\A #\\E #\\I #\\O #\\U))\n         (consonants (list-difference word\
    \ vowels))\n         (consonants-r (reverse consonants))\n         (vowels-r (reverse\
    \ vowels))\n         (vowel-before-consonant? (lambda (vowel consonant)\n    \
    \                                (if (empty? vowel)\n                        \
    \                #f\n                                        (if (member (car\
    \ vowel) consonants)\n                                            #t\n       \
    \                                     (vowel-before-consonant? (cdr vowel) consonant)))))\n\
    \         (vowel-before-consonant?2 (lambda (vowel consonant)\n              \
    \                       (if (empty? vowel)\n                                 \
    \        #f\n                                         (if (member (car consonant)\
    \ vowels)\n                                             #t\n                 \
    \                            (vowel-before-consonant?2 vowel (cdr consonant))))))\n\
    \         (pos-list (list))\n         (pos (lambda (vowel consonant)\n       \
    \         (if (empty? vowel)\n                    pos-list\n                 \
    \   (if (vowel-before-consonant?2 (cdr vowel) consonant)\n                   \
    \     (cons (length vowel) pos-list)\n                        (pos (cdr vowel)\
    \ consonant))))))\n    (string (car (map (lambda (vowel-r)\n                 \
    \       (if (empty? (pos vowel-r consonants-r))\n                            \"\
    \"\n                            (list-ref word (if (zero? (car (pos vowel-r consonants-r)))\n\
    \                                               0\n                          \
    \                     (- (car (pos vowel-r consonants-r)) 1)))))\n           \
    \           vowels-r)))))\n", "  (list-ref\n   (list->vector\n    (filter (lambda\
    \ (x) (string-contains \"aeiou\" x))\n            (string-split (string-reverse\
    \ word) \"\")))\n   0))\n", "  (cond\n    [(empty? word) \"\"]\n    [(not (regexp-match\
    \ #rx\"[aeiou]\" word)) \"\"]\n    [(not (regexp-match #rx\"[^aeiou]\" (string-append\
    \ (rest word) (string-take word 1)))) \"\"]\n    [(not (regexp-match #rx\"[^aeiou]\"\
    \ (string-take word 1))) (get_closest_vowel (rest word))]\n    [else (get_closest_vowel\
    \ (rest word))]))\n", "  (regexp-match #rx\"([^aeiouAEIOU]*([aeiouAEIOU]).*)\"\
    \ word)\n  (match:submatch word 2))\n", "  (if (empty? word)\n      \"\"\n   \
    \   (cond\n        ((member (string-ref word (sub1 (string-length word))) '(\"\
    a\" \"e\" \"i\" \"o\" \"u\")) (string-ref word (sub1 (string-length word))))\n\
    \        ((member (string-ref word (sub1 (string-length word))) '(\"A\" \"E\"\
    \ \"I\" \"O\" \"U\")) (string-ref word (sub1 (string-length word))))\n       \
    \ (else (get_closest_vowel (substring word 0 (sub1 (string-length word))))))))\n",
  "  (define (is-vowel? ch)\n    (member ch '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U)))\n  (define (is-consonant? ch)\n    (not (is-vowel? ch)))\n  (define\
    \ (look-right side middle lst)\n    (cond\n      [(null? lst) \"\"]\n      [(and\
    \ (is-vowel? middle) (is-consonant? side)) middle]\n      [(is-vowel? (car lst))\n\
    \       (look-right middle (car lst) (cdr lst))]\n      [else\n       (look-right\
    \ middle (car lst) (cdr lst))]))\n  (look-right (string-ref word 0) (string-ref\
    \ word 1) (rest (rest (string->list word)))))", "  (cond [(empty? word) \"\"]\n\
    \        [(find (find-last-vowel (string->list word)) (string->list word)) (find-last-vowel\
    \ (string->list word))]\n        [else \"\" ]))\n", "  (define (vowel? c)\n  \
    \  (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (first-vowel? c)\n    (and (vowel? c)\n         (not (vowel? (string-ref word\
    \ 1)))))\n  (define (consonant? c)\n    (not (vowel? c)))\n  (define (vowel-between-consonants?\
    \ pos)\n    (and (vowel? (string-ref word pos))\n         (consonant? (string-ref\
    \ word (sub1 pos)))\n         (consonant? (string-ref word (add1 pos)))))\n  (define\
    \ (get-vowel-position pos)\n    (if (and (consonant? (string-ref word pos))\n\
    \             (vowel-between-consonants? (sub1 pos)))\n        (sub1 pos)\n  \
    \      (get-vowel-position (sub1 pos))))\n  (define (get-vowel-from-pos pos)\n\
    \    (substring word pos (add1 pos)))\n  (define (is-all-consonants?)\n    (for/and\
    \ ([ch (in-string word)])\n      (consonant? ch)))\n  (cond [(eq? (string-length\
    \ word) 1) #f]\n        [(first-vowel? (string-ref word 0)) #f]\n        [(is-all-consonants?)\
    \ #f]\n        [else (get-vowel-from-pos (get-vowel-position (sub1 (string-length\
    \ word))))]))\n", "  (cond\n    [(empty? word) empty]\n    [(empty? (rest word))\
    \ empty]\n    [(and (or (equal? (first word) #\\a)\n              (equal? (first\
    \ word) #\\e)\n              (equal? (first word) #\\i)\n              (equal?\
    \ (first word) #\\o)\n              (equal? (first word) #\\u))\n          (and\
    \ (not (or (equal? (second word) #\\a)\n                        (equal? (second\
    \ word) #\\e)\n                        (equal? (second word) #\\i)\n         \
    \               (equal? (second word) #\\o)\n                        (equal? (second\
    \ word) #\\u)))\n               (not (or (equal? (first word) #\\a)\n        \
    \                (equal? (first word) #\\e)\n                        (equal? (first\
    \ word) #\\i)\n                        (equal? (first word) #\\o)\n          \
    \              (equal? (first word) #\\u)))))\n          (first word)]\n    [else\
    \ (get_closest_vowel (rest word))]))\n```\n\n```racket\n#lang racket\n", "  (if\
    \ (regexp-match #rx\"^[^aeiouAEIOU]+$\" word)\n      \"\"\n      (if (regexp-match\
    \ #rx\"[aeiouAEIOU]$\" word)\n          (regexp-match #rx\"[aeiouAEIOU]\" word)\n\
    \          (if (regexp-match #rx\"[aeiouAEIOU]\" word)\n              (regexp-match\
    \ #rx\"[aeiouAEIOU]\" word)\n              \"\"))))\n", "  (match word\n    [(and/c\
    \ (cons v (cons _ w))\n            (cons _ (cons v (cons _ w))))\n     (regexp-match\
    \ #rx\"y\" v)]\n    [(and/c (cons (not/c (in-set \"aeiou\")) (cons v _))\n   \
    \         (cons _ (cons v (cons _ _))))\n     v]\n    [_ \"\" ]))\n", "  (if (null?\
    \ word)\n      \"\"\n      (if (string-ci=? (substring word 0 1) \"a\")\n    \
    \      \"a\"\n          (if (string-ci=? (substring word 0 1) \"e\")\n       \
    \       \"e\"\n              (if (string-ci=? (substring word 0 1) \"i\")\n  \
    \                \"i\"\n                  (if (string-ci=? (substring word 0 1)\
    \ \"o\")\n                      \"o\"\n                      (if (string-ci=?\
    \ (substring word 0 1) \"u\")\n                          \"u\"\n             \
    \             (get_closest_vowel (substring word 1)))))))))", "  (match word\n\
    \    [(or \"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\") empty]\n\
    \    [(string-append [_ v] rest)\n     (define (find-first-cons consonants)\n\
    \       (if (empty? consonants)\n           empty\n           (if (char-consonant?\
    \ (first consonants))\n               (first consonants)\n               (find-first-cons\
    \ (rest consonants)))))\n     (cond\n       [(char-consonant? v) empty]\n    \
    \   [(empty? rest) empty]\n       [else\n        (define first-cons (find-first-cons\
    \ rest))\n        (if (empty? first-cons)\n            empty\n            (if\
    \ (char-consonant? (string-ref rest (- (string-length rest) 1)))\n           \
    \     (string v)\n                empty))]\n       )]))\n", "  (define consonants\
    \ \"bcdfghjklmnpqrstvwxyz\")\n  (define vowels \"aeiou\")\n  (define (is-consonant?\
    \ c)\n    (string-contains? consonants c))\n  (define (is-vowel? c)\n    (string-contains?\
    \ vowels c))\n  (define (find-with-consonants? i word f)\n    (and (and (&gt;\
    \ i 0) (&lt; i (string-length word)))\n         (and (f (string-ref word (- i\
    \ 1)))\n              (f (string-ref word i)))))\n  (define (find-vowel word i)\n\
    \    (cond\n      [(string-contains? vowels (string-ref word i)) i]\n      [else\
    \ (find-vowel word (+ i 1))]))\n  (define (find-consonant word i)\n    (cond\n\
    \      [(string-contains? consonants (string-ref word i)) i]\n      [else (find-consonant\
    \ word (+ i 1))]))\n  (define (find-with-consonants i word f1 f2)\n    (cond\n\
    \      [(find-with-consonants? i word f1)\n       (find-with-consonants? i word\
    \ f2)]\n      [else (find-with-consonants i word f1 f2)]))\n  (define (find-closest-vowel-with-consonants\
    \ word i)\n    (cond\n      [(find-with-consonants? i word is-consonant?)\n  \
    \     (find-vowel word i)]\n      [else (find-closest-vowel-with-consonants word\
    \ (+ i 1))]))\n  (let*\n    [(l (string-length word))\n     (r (- l 1))]\n   \
    \ (cond\n      [(equal? l 0) \"\"]\n      [(equal? l 1) \"\"]\n      [(is-vowel?\
    \ (string-ref word 0))\n       (cond\n         [(is-vowel? (string-ref word 1))\
    \ \"\"]\n         [else (string-ref word 0)])", "  (cond\n    [(empty? word) empty]\n\
    \    [(string-ci-contains? \"aeiou\" (car word))\n     (get_closest_vowel (cdr\
    \ word))]\n    [(string-ci-contains? \"aeiou\" (cdr word))\n     (get_closest_vowel\
    \ (cdr word))]\n    [else (string-ci-contains? \"aeiou\" (cadr word))\n     (get_closest_vowel\
    \ (cddr word))]))\n", "  (let ((vowels \"aeiouAEIOU\"))\n    (define (helper w)\n\
    \      (if (not (string-contains w (substring w (sub1 (string-length w)))))\n\
    \          (substring w (sub1 (string-length w)))\n          (helper (substring\
    \ w 0 (sub1 (string-length w))))))\n    (cond ((and (string-contains? vowels (substring\
    \ word 0 1)) (string-contains? vowels (substring word 1 2))) word)\n         \
    \ ((string-contains? vowels (substring word 0 1)) (substring word 1 2))\n    \
    \      ((string-contains? vowels (substring word (sub1 (string-length word))))\
    \ (substring word (sub1 (string-length word))))\n          ((helper word) (helper\
    \ word))\n          (else \"\"))))\n", "  (if (&gt; (string-length word) 2)\n\
    \      (get-closest-vowel-internal (string-&gt;list word) '())\n      \"\"))\n",
  "  (define (is-consonant? ch)\n    (not (member ch '(\"a\" \"e\" \"i\" \"o\" \"\
    u\"))))\n  (define (find-vowel)\n    (if (empty? word)\n        \"\"\n       \
    \ (if (equal? (last word) \"a\")\n            \"a\"\n            (if (is-consonant?\
    \ (last word))\n                (find-vowel)\n                (if (is-consonant?\
    \ (last (rest word)))\n                    (last word)\n                    (find-vowel)\n\
    \                    )))))\n  (find-vowel))", "  (cond\n    [(empty? word) \"\"\
    ]\n    [(empty? (rest word)) \"\"]\n    [(and (vowel? (car word)) (consonant?\
    \ (cadr word))) \"\"]\n    [(and (consonant? (car word)) (vowel? (cadr word)))\
    \ (cadr word)]\n    [else (get_closest_vowel (rest word))]))\n", "  (cond\n  \
    \  [(empty? word) \"\" ]\n    [(empty? (rest word)) \"\" ]\n    [(and (char-alphabetic?\
    \ (first word)) (char-vowel? (first word))) (get_closest_vowel (rest word)) ]\n\
    \    [(and (char-alphabetic? (first word)) (char-vowel? (rest word))) (first word)\
    \ ]\n    [else (get_closest_vowel (rest word)) ]))\n</code>\nThanks for your help.\n\
    \n\nA:\n\nYou could just use a <code>regexp</code>:\n<code>(regexp-match* #rx\"\
    [^aeiou][aeiou][^aeiou]\" \"FULL\")", "    (let* ([word (string->list word)]\n\
    \           [vowels (list #\\a #\\e #\\i #\\o #\\u)]\n           [valid? (lambda\
    \ (c) (member c vowels))]\n           [rev (reverse word)]\n           [result\
    \ (for/first ([c1 (in-list rev) c2 (in-list rev) c3 (in-list rev)])\n        \
    \             (and (not (valid? c1))\n                          (valid? c2)\n\
    \                          (not (valid? c3))))])\n        (if result\n       \
    \     (list->string (list result))\n            \"\")))", "  (define vowels '(\"\
    a\" \"e\" \"i\" \"o\" \"u\"))\n  (define (find-vowel-index word)\n    (define\
    \ (find-vowel-index-iter word i)\n      (if (= i (string-length word)) \"\"\n\
    \          (if (member (substring word i (add1 i)) vowels)\n              (substring\
    \ word i (add1 i))\n              (find-vowel-index-iter word (add1 i)))))\n \
    \   (find-vowel-index-iter word (sub1 (string-length word))))\n  (define (find-consonant-index\
    \ word vowel-index)\n    (define (find-consonant-index-iter word vowel-index i)\n\
    \      (if (= i 0) \"\"\n          (if (member (substring word (sub1 i) i) vowels)\n\
    \              (if (= (sub1 i) vowel-index)\n                  (find-consonant-index-iter\
    \ word vowel-index (sub1 i))\n                  (substring word (sub1 i) i))\n\
    \              (find-consonant-index-iter word vowel-index (sub1 i)))))\n    (find-consonant-index-iter\
    \ word vowel-index (sub1 (string-length word))))\n  (define (find-vowel-consonant-vowel\
    \ word)\n    (define vowel-index (string-index (find-vowel-index word) word))\n\
    \    (define cons-index (string-index (find-consonant-index word vowel-index)\
    \ word))\n    (string-append (substring word 0 cons-index) (find-vowel-index word)\
    \ (substring word (add1 cons-index) (string-length word))))\n  (define (find-vowel-vowel-consonant\
    \ word)\n    (define vowel-index (string-index (find-vowel-index word) word))\n\
    \    (define cons-index (string-index (find-consonant-index word vowel-index)\
    \ word))\n    (string-append (substring word 0 (sub1 vowel-index)) (find-vowel-index\
    \ word) (substring word cons", "  (local [(define (is-consonant? c)\n        \
    \    (not (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))))\n          (define (finder\
    \ i word)\n            (cond [(string=? word \"\")\n                   \"\"]\n\
    \                  [(and (not (is-consonant? (string-ref word (- (string-length\
    \ word) i))))\n                        (is-consonant? (string-ref word (- (string-length\
    \ word) (+ i 1)))))\n                   (string-ref word (- (string-length word)\
    \ i))]\n                  [else\n                   (finder (+ i 1) word)]))]\n\
    \    (finder 1 word)))\n", "  (let* ((vowels \"aeiouAEIOU\")\n         (consonants\
    \ (string-filter (lambda (c) (not (member c vowels))) word))\n         (consonants\
    \ (string-split (string-join consonants) \"\")))\n    (cond\n      [(zero? (length\
    \ word)) \"\" ]\n      [(member (string-ref word 0) vowels) \"\" ]\n      [(member\
    \ (string-ref word (sub1 (string-length word))) vowels) \"\" ]\n      [(not (consonants))\
    \ \"\" ]\n      [else\n       (let loop ([i 1])\n         (if (member (string-ref\
    \ word i) vowels)\n             (if (and (member (string-ref word (sub1 i)) consonants)\n\
    \                      (member (string-ref word (add1 i)) consonants))\n     \
    \            (string-ref word i)\n                 (loop (add1 i)))\n        \
    \     (loop (add1 i))))])))\n", "  (define (closest-vowel str)\n    (let ((vowels\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n      (define\
    \ (is-consonant? str)\n        (not (member str vowels)))\n      (define (consonant-characters-on-right?\
    \ str)\n        (and (not (null? str))\n             (consonant-characters-on-right?\
    \ (cdr str))\n             (is-consonant? (car str))))\n      (define (find-vowel-on-right\
    \ word)\n        (if (and (not (null? word))\n                 (is-consonant?\
    \ (car word))\n                 (is-consonant? (cadr word))\n                \
    \ (member (caddr word) vowels))\n            (caddr word)\n            (find-vowel-on-right\
    \ (cdr word))))\n      (if (consonant-characters-on-right? str)\n          (find-vowel-on-right\
    \ str)\n          \"\")))\n  (closest-vowel word))\n", "    (let loop ([i (sub1\
    \ (string-length word))] [first-c \"\"] [second-c \"\"] [vowel \"\"])\n      \
    \  (cond [(= i 0) vowel]\n              [(string-contains \"AEIOUaeiou\" (string-ref\
    \ word i))\n               (loop (- i 1) (string-ref word i) first-c (string-ref\
    \ word i))]\n              [(string-contains \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \ (string-ref word i))\n               (if (and (not (string=? first-c \"\"))\
    \ (not (string=? second-c \"\")))\n                   vowel\n                \
    \   (loop (- i 1) (string-ref word i) (string-ref word i) vowel))]\n         \
    \     [else (loop (- i 1) first-c second-c vowel)])))\n", "  (let ([l (string-length\
    \ word)])\n    (if (= l 0) \"\"\n        (let ([c (string-ref word (- l 1))])\n\
    \          (cond ((or (eq? c #\\a) (eq? c #\\e) (eq? c #\\i) (eq? c #\\o) (eq?\
    \ c #\\u)) (string c))\n                ((or (eq? c #\\A) (eq? c #\\E) (eq? c\
    \ #\\I) (eq? c #\\O) (eq? c #\\U)) (string c))\n                (else (get_closest_vowel\
    \ (substring word 0 (- l 1))))))))))\n", "  (let* ([l word]\n         [r (reverse\
    \ word)]\n         [vowels (string-&gt;list \"aeiouAEIOU\")]\n         [lv (closest-to-right-from-list\
    \ l vowels)]\n         [rv (closest-to-right-from-list r vowels)])\n    (if (=\
    \ lv #f) (if (= rv #f) \"\" (reverse rv)) lv)))\n", "  (cond\n    [(empty? word)\
    \ \"\"]\n    [(or (equal? (first word) \"a\")\n         (equal? (first word) \"\
    e\")\n         (equal? (first word) \"i\")\n         (equal? (first word) \"o\"\
    )\n         (equal? (first word) \"u\"))\n     (list->string (list (first word)))]\n\
    \    [else (get_closest_vowel (rest word))]))\n", "  (local [(define vowels \"\
    aeiou\")\n          (define cons \"bcdfghjklmnpqrstvwxyz\")]\n    (let loop ((start\
    \ (string-length word) -1)\n               (end (string-length word) -1))\n  \
    \    (if (or (= start -1) (= end -1))\n          \"\"\n          (let ((start-char\
    \ (string-ref word start))\n                (end-char (string-ref word end)))\n\
    \            (cond ((and (member start-char vowels)\n                        (member\
    \ end-char cons))\n                   (string-ref word start))\n             \
    \     ((and (member start-char cons)\n                        (member end-char\
    \ vowels))\n                   (string-ref word end))\n                  (else\
    \ (loop (- start 1) (- end 1)))))))))\n</code>\n", "  (let*\n      ((lowercase_word\
    \ (string-downcase word))\n       (right_consonants (string-contains lowercase_word\
    \ (regexp #rx\"[aeiou]\")))\n       (right_consonants_index (string-index right_consonants))\n\
    \       (index (or right_consonants_index #f)))\n    (if index\n        (string-ref\
    \ word index)\n        \"\")))\n", "  (let ((vowels '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n        (chars (string->list word))\n\
    \        (first-char #f)\n        (second-char #f)\n        (result \"\"))\n \
    \   (for/fold ([count 0])\n              ([char (in-list chars)])\n      (cond\n\
    \        [(and (= count 0) (member char vowels)) (set! first-char char) 0]\n \
    \       [(and (= count 1) (member char vowels)) (set! second-char char) 0]\n \
    \       [(and (not (member char vowels)) (= count 0)) (set! first-char char) (+\
    \ count 1)]\n        [(and (not (member char vowels)) (= count 1)) (set! second-char\
    \ char) (+ count 1)]\n        [else count]))\n    (cond\n      [(and first-char\
    \ second-char) (if (< (char->integer (string-ref word (string-length word)))\n\
    \                                          (char->integer first-char))\n     \
    \                                   first-char\n                             \
    \           second-char)]\n      [else result])))\n", "  (match word\n    [(cons\
    \ _ '()) \"\"]\n    [(cons (? (in-range #\\a #\\z)) (cons _ (cons (? (in-range\
    \ #\\a #\\z)) _)))\n     (if (char-vowel? (car word))\n         (char-upcase (car\
    \ word))\n         (get_closest_vowel (cdr word)))]\n    [_ (get_closest_vowel\
    \ (cdr word))]))\n", "  (let ([word-length (string-length word)])\n    (if (or\
    \ (= word-length 1) (= word-length 2))\n        \"\"\n        (let loop ([i word-length])\n\
    \          (if (= i 0)\n              \"\"\n              (if (or (char-lower-case?\
    \ (string-ref word i)) (char-upper-case? (string-ref word i)))\n             \
    \     (if (or (char-lower-case? (string-ref word (- i 1))) (char-upper-case? (string-ref\
    \ word (- i 1))))\n                      (if (char-vowel? (string-ref word (-\
    \ i 1)))\n                          (string-ref word (- i 1))\n              \
    \            (loop (- i 1)))\n                      (loop (- i 1)))\n        \
    \          (loop (- i 1))))))))\n</code>\nI'm stuck with racket for loop. What\
    \ is the best way to write this for loop? Thanks in advance.\n\n\nA:\n\nYour code\
    \ is really convoluted, here's a rewrite using Racket idioms:\n<code>(define (get-closest-vowel\
    \ w)\n  (let loop ([i (sub1 (string-length w))])\n    (cond [(char-vowel? (string-ref\
    \ w i))\n           (if (or (= i 0) (char-vowel? (string-ref w (sub1 i))))\n \
    \              \"\"\n               (string-ref w i))]\n          [(= i 0) \"\"\
    ]\n          [else (loop (sub1 i))])))\n</code>\nSome notes:\n\nIn Racket there\
    \ are no <code>_</code> in identifier names, use <code>-</code> instead\nRacket\
    \ is case-sensitive, using <code>lower-case</code> to denote functions\nRacket\
    \ is a functional language, so you don't need to use loops that often, usually\
    \ you can use recursion for iteration\nRacket uses prefix notation for arithmetic\
    \ operations, like <code>+</code>, <code>-</code>, <code>*</code>, etc.\nIt's\
    \ best to avoid <code>let</code> if you can, and use <code>let*</code> instead,\
    \ since it's more idiomatic\nIn Racket you can use", "  (cond [(empty? word) empty]\n\
    \        [(char-vowel? (last word)) (get_closest_vowel (butlast word))]\n    \
    \    [(empty? (butlast word)) empty]\n        [(char-vowel? (second-to-last word))\
    \ (string (second-to-last word))]\n        [else (get_closest_vowel (butlast word))]))\n",
  "  (define (start-of-word? n) (= n 1))\n  (define (end-of-word? n word-length) (=\
    \ n word-length))\n  (define (is-consonant? c) (not (is-vowel? c)))\n  (define\
    \ (is-vowel? c) (member c '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U)))\n\
    \  (define (next-vowel word index)\n    (if (start-of-word? index)\n        \"\
    \"\n        (if (end-of-word? index (string-length word))\n            \"\"\n\
    \            (if (is-vowel? (string-ref word index))\n                (string-ref\
    \ word index)\n                (next-vowel word (- index 1))))))\n  (define (prev-consonant\
    \ word index)\n    (if (end-of-word? index (string-length word))\n        \"\"\
    \n        (if (start-of-word? index)\n            \"\"\n            (if (is-consonant?\
    \ (string-ref word (- index 1)))\n                (string-ref word (- index 1))\n\
    \                (prev-consonant word (- index 1))))))\n  (define (concat-vowel\
    \ word)\n    (define (find-vowel word index)\n      (if (is-vowel? (string-ref\
    \ word index))\n          (string-ref word index)\n          (find-vowel word\
    \ (+ index 1))))\n    (if (is-vowel? (string-ref word 1))\n        (string-ref\
    \ word 1)\n        (find-vowel word 2)))\n  (if (or (is-vowel? (string-ref word\
    \ 1))\n          (is-vowel? (string-ref word 2)))\n      (string-ref word 2)\n\
    \      (if (and (not (is-vowel? (string-ref word (- (string-length word) 1))))\n\
    \               (not (is-vowel? (string-ref word (- (string-length word) 2)))))\n\
    \          (concat-vowel word)", "  (cond [(or (empty? word) (and (= 1 (length\
    \ word)) (memq (first word) (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\\
    O #\\U)) (memq (first word) (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\\
    O #\\U)))) \"\"]\n        [(or (and (= 1 (length word)) (not (memq (first word)\
    \ (list #\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))))\n             (and\
    \ (= 2 (length word)) (not (memq (first word) (list #\\a #\\e #\\i #\\o #\\u #\\\
    A #\\E #\\I #\\O #\\U)))\n                  (not (memq (second word) (list #\\\
    a #\\e #\\i #\\o #\\u #\\A #\\E #\\I #\\O #\\U))))) \"\"]\n        [else (find-consonant-and-vowel\
    \ word)]))\n", "  (match word\n    [(string-append (not (vowel? (in-range c)))\
    \ vowel (not (vowel? (in-range x)))) c]\n    [\"\"]))\n", "  (let ([word (string-&gt;list\
    \ word)])\n    (if (null? word) \"\"\n        (if (regexp-match? #rx\"[AEIOU]\"\
    \ (list-ref word (sub1 (length word))))\n            (string (list-ref word (sub1\
    \ (length word))))\n            (get_closest_vowel (list-&gt;string (reverse (cdr\
    \ (reverse word)))))))))\n</code>\nMy solution is kinda quirky. I do a reverse\
    \ traverse and get the last vowel from the RHS. \nThen I convert it back to string\
    \ to return. \nHow can I make this better?\n\n\nA:\n\nThere are several issues\
    \ here:\n\nUsing <code>string-&gt;list</code> and <code>list-&gt;string</code>\
    \ on strings of characters is very slow, use <code>string-&gt;list/c</code> and\
    \ <code>list-&gt;string/c</code> instead.\nYour solution is almost correct, but\
    \ there's a bug, consider the test case: <code>(get-closest-vowel \"sdap\")</code>\
    \ it will return <code>\"\"</code> when it should return <code>\"a\"</code>. Your\
    \ code is almost correct but for a small detail: when the first character is a\
    \ vowel you should return <code>string (car word)</code> instead of the empty\
    \ string. This can be easily fixed.\nUsing regular expressions is not strictly\
    \ necessary, you could use <code>member</code> instead.\nWhen you reverse a list\
    \ you're creating an intermediate list, but there's no need for that, since you\
    \ only need to reverse it until you find a vowel. Also, you're doing two reverse\
    \ operations, but that's not needed, you could use an accumulator parameter instead,\
    \ to keep track of the word, and once you found the vowel, get the length of the\
    \ accumulator and use it to extract the matching character.\n\nThis version fixes\
    \ those issues and it's roughly twice as fast, but you could still make it faster\
    \ by using a <code>for/fold</code> loop, instead of recursion:\n<code>(define\
    \ (get-closest-vowel word)\n  (let loop ([word (string-&gt;list", "  (define (is-vowel\
    \ x)\n    (regexp-match #rx\"[aeiou]\" x))\n  (define (vowels str)\n    (regexp-match*\
    \ #rx\"([aeiou])\" str))\n  (define (last-vowel str)\n    (car (vowels str)))\n\
    \  (define (regex-match-all str)\n    (regexp-match* #rx\"([^aeiou])([aeiou])([^aeiou])\"\
    \ str))\n  (define (find-match str)\n    (for/first ([(list _ l _)] (regex-match-all\
    \ str))\n      l))\n  (or (find-match word) \"\"))\n", "  (define (between-consonants?\
    \ left-consonant? right-consonant?)\n    (and left-consonant? (not right-consonant?)))\n\
    \  (define (iter word left-consonant? right-consonant? closest-vowel-index)\n\
    \    (if (empty? word)\n        (substring word closest-vowel-index (add1 closest-vowel-index))\n\
    \        (let ([c (string-upcase (first word))])\n          (cond [(equal? c \"\
    A\")\n                 (iter (rest word)\n                       left-consonant?\n\
    \                       right-consonant?\n                       (and (between-consonants?\
    \ left-consonant? right-consonant?)\n                            (add1 closest-vowel-index)))\n\
    \                 ]\n                [(equal? c \"E\")\n                 (iter\
    \ (rest word)\n                       left-consonant?\n                      \
    \ right-consonant?\n                       (and (between-consonants? left-consonant?\
    \ right-consonant?)\n                            (add1 closest-vowel-index)))\n\
    \                 ]\n                [(equal? c \"I\")\n                 (iter\
    \ (rest word)\n                       left-consonant?\n                      \
    \ right-consonant?\n                       (and (between-consonants? left-consonant?\
    \ right-consonant?)\n                            (add1 closest-vowel-index)))\n\
    \                 ]\n                [(equal? c \"O\")\n                 (iter\
    \ (rest word)\n                       left-consonant?\n                      \
    \ right-consonant?\n                       (and (between-consonants? left-consonant?\
    \ right-consonant?)\n                            (add1 closest-vowel-index)))\n\
    \                 ]\n                [(equal? c \"U\")\n                 (iter\
    \ (rest word)\n                       left-consonant?\n                      \
    \ right-consonant?\n                       (and (between-consonants? left-consonant?\
    \ right-consonant?)\n                            (add1 closest-vowel-index)))\n\
    \                 ]\n                [else\n                 (iter (rest word)\n\
    \                       right-consonant?\n                       right-consonant",
  "  (cond\n    [(or (= (string-length word) 1)\n         (= (string-length word)\
    \ 2)) \"\"]\n    [else\n     (let ([chars (string->list word)])\n       (define\
    \ (next-vowel? start)\n         (if (= start (string-length word))\n         \
    \    #f\n             (if (string-member (string (list-ref chars start)) \"aeiou\"\
    )\n                 (if (and (not (string-member (string (list-ref chars (- start\
    \ 1))) \"aeiou\"))\n                          (not (string-member (string (list-ref\
    \ chars (+ start 1))) \"aeiou\")))\n                     #t\n                \
    \     (next-vowel? (+ start 1)))\n                 (next-vowel? (+ start 1)))))\n\
    \       (define (find-next-vowel start)\n         (if (= start (string-length\
    \ word))\n             \"\"\n             (if (string-member (string (list-ref\
    \ chars start)) \"aeiou\")\n                 (if (and (not (string-member (string\
    \ (list-ref chars (- start 1))) \"aeiou\"))\n                          (not (string-member\
    \ (string (list-ref chars (+ start 1))) \"aeiou\")))\n                     (string\
    \ (list-ref chars start))\n                     (find-next-vowel (+ start 1)))\n\
    \                 (find-next-vowel (+ start 1)))))\n       (if (next-vowel? 0)\n\
    \           (find-next-vowel 0)\n           \"\"))]))\n", "  (cond [(empty? word)\
    \ \"\"]\n        [(empty? (rest word)) \"\"]\n        [(empty? (rest (rest word)))\
    \ \"\"]\n        [(not (consonant? (first word))) \n         (cond [(consonant?\
    \ (first (rest word))) (first word)]\n               [(consonant? (first (rest\
    \ (rest word)))) (first (rest word))]\n               [else \"\"])]\n        [else\
    \ (get_closest_vowel (rest word))]))\n", "  (define vowels '(#\\a #\\e #\\i #\\\
    o #\\u #\\A #\\E #\\I #\\O #\\U))\n  (define (inner word index result)\n    (if\
    \ (= index -1)\n        result\n        (if (and (member (string-ref word index)\
    \ vowels)\n                 (not (member (string-ref word (+ index 1)) vowels))\n\
    \                 (not (member (string-ref word (- index 1)) vowels)))\n     \
    \       (inner word (- index 1) (string-ref word index))\n            (inner word\
    \ (- index 1) result))))\n  (inner word (- (string-length word) 1) \"\"))\n</code>\n",
  "  (cond [(string=? word \"\") \"\"]\n        [(< (string-length word) 3) \"\"]\n\
    \        [else (let [(current-letter (string-ref word 1))\n                  \
    \ (previous-letter (string-ref word 0))\n                   (next-letter (string-ref\
    \ word 2))]\n                (if (and (or (vowel? current-letter) (vowel? next-letter))\n\
    \                         (consonant? previous-letter)\n                     \
    \    (consonant? next-letter))\n                    (let [(closest-vowel (cond\
    \ [(vowel? current-letter) current-letter]\n                                 \
    \              [(vowel? next-letter) next-letter]))]\n                      (if\
    \ (not (string=? closest-vowel \"\"))\n                          (string-append\
    \ (string closest-vowel)\n                                         (get_closest_vowel\
    \ (substring word 2)))\n                          \"\"))\n                   \
    \ (get_closest_vowel (substring word 1)))))]))\n", "  (string-index (string-reverse\
    \ word) #\\aeiou))\n```\n\n```\n#lang racket\n", "  (cond [(zero? (string-length\
    \ word)) \"\"]\n        [(zero? (string-length (rest word))) \"\"]\n        [(vowel?\
    \ (string-ref word -1)) \"\"]\n        [(vowel? (string-ref word -2)) \n     \
    \    (if (vowel? (string-ref word -3)) \n             (get_closest_vowel (substring\
    \ word 0 -1))\n             (string (string-ref word -2)))]\n        [else (get_closest_vowel\
    \ (substring word 0 -1))]))\n", "  (let ([str (regexp-replace* (regexp-quote word)\
    \ #rx\"[^aeiou]{2,}\" \"\" 'ignore-case)])\n    (string-index (regexp-replace*\
    \ str #rx\"[^aeiou]\" \"\" 'ignore-case) (regexp-replace* str #rx\"[aeiou]\" \"\
    \" 'ignore-case))))\n</code>\n", "  (define (is-vowel? c)\n    (cond\n      [(char=?\
    \ c #\\a) #t]\n      [(char=? c #\\e) #t]\n      [(char=? c #\\i) #t]\n      [(char=?\
    \ c #\\o) #t]\n      [(char=? c #\\u) #t]\n      [else #f]))\n  (define (is-consonant?\
    \ c)\n    (not (is-vowel? c)))\n  (define (vowel-in-between-consonants? w)\n \
    \   (andmap is-consonant? w))\n  (define (get-vowel-from-in-between-consonants\
    \ w)\n    (if (is-vowel? (car w))\n        (car w)\n        \"\"))\n  (cond\n\
    \    [(empty? word) \"\"]\n    [(and (is-vowel? (first word)) (is-vowel? (last\
    \ word))) \"\" ]\n    [(and (is-vowel? (first word)) (vowel-in-between-consonants?\
    \ (rest word)))\n     (get-vowel-from-in-between-consonants (rest word))]\n  \
    \  [(and (is-vowel? (last word)) (vowel-in-between-consonants? (butlast word)))\n\
    \     (get-vowel-from-in-between-consonants (butlast word))]\n    [(vowel-in-between-consonants?\
    \ word)\n     (get-vowel-from-in-between-consonants word)]\n    [else \"\" ]))\n",
  "  (if (string-contains word #rx\"[aeiou]\")\n      (for/first ([vowel (in-string\
    \ \"aeiou\")])\n        (and (string-contains (string-drop word (string-index\
    \ word vowel)) #rx\"[^aeiou]\")\n             (string-contains (string-take word\
    \ (string-index word vowel)) #rx\"[^aeiou]\")\n             vowel))\n      \"\"\
    ))\n```\n\n## 6. Rotate an array N places to the left\n\n```racket\n#lang racket\n",
  "  (define (consonant? c)\n    (member c '(#\\B #\\C #\\D #\\F #\\G #\\H #\\J #\\\
    K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\Y #\\Z)))\n  (define\
    \ (vowel? c)\n    (member c '(#\\A #\\E #\\I #\\O #\\U)))\n  (define (gcv-iter\
    \ word i)\n    (cond [(empty? word) \"\"]\n          [(consonant? (first word))\
    \ (gcv-iter (rest word) (+ i 1))]\n          [(vowel? (first word)) (if (&gt;\
    \ (- i 1) 0) (gcv-iter (rest word) (+ i 1)) (string (first word)))]\n        \
    \  [else (gcv-iter (rest word) (+ i 1))]))\n  (gcv-iter word 0))\n</code>\nI'm\
    \ pretty sure it's because of recursion. I'm just not sure how to change this\
    \ to an iteration.\n\n\nA:\n\nThe <code>gcv-iter</code> procedure is defined on\
    \ a word and a counter. We can use the counter to keep track of the position from\
    \ the end of the word.\n<code>(define (get-closest-vowel w)\n  (define (gcv-iter\
    \ w cnt)\n    (cond [(zero? cnt) \"\"]\n          [(empty? w) \"\"]\n        \
    \  [(consonant? (first w)) (gcv-iter (rest w) (add1 cnt))]\n          [(vowel?\
    \ (first w)) (if (&gt; cnt 1)\n                                  (gcv-iter (rest\
    \ w) (add1 cnt))\n                                  (string (first w)))]\n   \
    \       [else (gcv-iter (rest w) (add1 cnt))]))\n  (gcv-iter w (sub1 (string-length\
    \ w))))\n</code>\n", "  (let ([vowels (regexp-match* #rx\"[a|e|i|o|u]\" word)]\n\
    \        [last_vowel (car (last vowels))])\n    (define (is_vowel x)\n      (member\
    \ x \"aeiou\"))\n    (define (last-consonant-index lst)\n      (for/fold ([counter\
    \ 0]) ([x (in-list lst)])\n        (cond [(is_vowel x) counter]\n            \
    \  [else (+ counter 1)])))\n    (define (previous-vowel-index index)\n      (last-consonant-index\
    \ (reverse (sublist word 0 index))))\n    (define (next-vowel-index index)\n \
    \     (last-consonant-index (sublist word index)))\n    (cond [(= (previous-vowel-index\
    \ (next-vowel-index (list-index word last_vowel))) 0) \"\"]\n          [else (char->string\
    \ (list-ref word (previous-vowel-index (next-vowel-index (list-index word last_vowel)))))])))\n",
  "  (if (string-empty? word)\n      \"\"\n      (let* ([first-letter (string-ref\
    \ word 0)]\n             [other-letters (substring word 1)]\n             [is-a-vowel?\
    \ (member first-letter \"aeiouAEIOU\")]\n             [has-vowel? (string-contains?\
    \ other-letters \"aeiouAEIOU\")])\n        (if (and (not is-a-vowel?) has-vowel?)\n\
    \            (get_closest_vowel other-letters)\n            (if is-a-vowel?\n\
    \                (string first-letter)\n                \"\")))))\n</code>\nExample\n\
    <code>&gt; (get_closest_vowel \"yogurt\")\n\"u\"\n&gt; (get_closest_vowel \"FULL\"\
    )\n\"U\"\n&gt; (get_closest_vowel \"quick\")\n\"\"\n&gt; (get_closest_vowel \"\
    ab\")\n\"\"\n</code>\n", "  (define (cons? c) (member c '(#\\B #\\C #\\D #\\F\
    \ #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\T #\\V #\\W #\\X #\\\
    Y #\\Z)))\n  (define (vow? c) (member c '(#\\A #\\E #\\I #\\O #\\U)))\n  (define\
    \ (is-cons-cons-vow? word k) (and (not (zero? k)) (cons? (string-ref word (- k\
    \ 1))) (vow? (string-ref word k)) (cons? (string-ref word (- k 2)))))\n  (define\
    \ (find-closest-vowel word k)\n    (cond [(zero? k) \"\"]\n          [(is-cons-cons-vow?\
    \ word k) (string (string-ref word k))]\n          [else (find-closest-vowel word\
    \ (- k 1))]))\n  (find-closest-vowel word (- (string-length word) 1)))\n</code>\n",
  "  (define (find-vowel w i)\n    (cond\n      [(empty? w) \"\"]\n      [(vowel?\
    \ (first w)) (if (consonant? (second w)) i \"\")]\n      [else (find-vowel (rest\
    \ w) (next-index i))]))\n  (define (vowel? c)\n    (member c '(\"a\" \"e\" \"\
    i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define (consonant? c)\n \
    \   (not (vowel? c)))\n  (define (next-index i)\n    (string-append i (string\
    \ (- (string->number i) 1))))\n  (find-vowel (reverse (string->list word))\n \
    \             (number->string (- (string-length word) 1))))\n```\n\n```racket\n\
    #lang racket\n", "  (cond [(member? word \"aeiou\") #f]\n        [(member? word\
    \ \"AEIOU\") #f]\n        [else (string-ref word (-(string-length word)2))]))\n",
  "  (string-upcase\n   (string-join\n    (filter\n     (lambda (s)\n       (string-ci=?\
    \ s (string (char-upcase s))))\n     (filter\n      (lambda (c)\n       (char-vowel?\
    \ c))\n      (reverse\n       (string-take word\n                    (sub1 (string-length\
    \ word))))))\n    \"\")))", "  (let ((vowels \"aeiou\"))\n    (let loop ((word\
    \ (string-reverse word))\n               (vowels vowels)\n               (count\
    \ 0))\n      (cond\n        [(empty? word) \"\" ]\n        [(and (member (string-ref\
    \ word 0) vowels) (not (member (string-ref word 1) vowels))\n             (not\
    \ (member (string-ref word 2) vowels)))\n         (string-ref word 0)]\n     \
    \   [else (loop (rest word) vowels (add1 count))]))))", "  (if (or (empty? word)\
    \ (char-vowel? (first word)))\n      \"\"\n      (let ([vowel-index (index-of-closest-vowel\
    \ (string->list word))])\n        (if (= -1 vowel-index)\n            \"\"\n \
    \           (list-ref word vowel-index)))))\n", "  (cond\n    [(empty? word) empty]\n\
    \    [(char-vowel? (last word)) (get_closest_vowel (butlast word))]\n    [(char-vowel?\
    \ (second (reverse word))) (string (second (reverse word)))]\n    [else (get_closest_vowel\
    \ (butlast word))]))\n", "  (local [(define vowels \"aeiouAEIOU\")]\n    (cond\
    \ [(string-empty? word) \"\"]\n          [(and (not (member (string-ref word (-\
    \ (string-length word) 1)) vowels))\n                (member (string-ref word\
    \ (- (string-length word) 2)) vowels))\n           (substring word (- (string-length\
    \ word) 2) (- (string-length word) 1))]\n          [(member (string-ref word (-\
    \ (string-length word) 1)) vowels)\n           (substring word (- (string-length\
    \ word) 1) (string-length word))]\n          [else (get_closest_vowel (substring\
    \ word 0 (- (string-length word) 1)))])))\n", "  (let loop ([word word] [i (sub1\
    \ (string-length word))])\n    (cond\n      [(string-empty? word) \"\"]\n    \
    \  [(<= i 0) \"\"]\n      [(consonant? (string-ref word i)) (loop (substring word\
    \ 0 i) (- i 1))]\n      [(consonant? (string-ref word (- i 1)))\n       (cond\n\
    \         [(vowel? (string-ref word i)) (string (string-ref word i))]\n      \
    \   [else (loop (substring word 0 i) (- i 1))])]\n      [else (loop (substring\
    \ word 0 i) (- i 1))])))\n", "  (match word [,vowel \"\"] [,c1 ,vowel ,c2 (string\
    \ vowel)] [,c1 ,c2 ,vowel (string vowel)] [,c1 ,c2 ,c3 ,vowel (string vowel)]\
    \ [,c1 ,c2 ,c3 ,c4 ,vowel (string vowel)] [_ \"\" ]))\n", "  (string-append\n\
    \   (string-reverse\n    (string-take (string-reverse word)\n                \
    \ (or (or (or (or (or (or (regexp-match #rx\"[^aeiou]u\" word)\n             \
    \                             (regexp-match #rx\"[^aeiou]o\" word))\n        \
    \                             (regexp-match #rx\"[^aeiou]i\" word))\n        \
    \                        (regexp-match #rx\"[^aeiou]e\" word))\n             \
    \              (regexp-match #rx\"[^aeiou]a\" word))\n                      (regexp-match\
    \ #rx\"[^aeiou]y\" word))\n                 (regexp-match #rx\"[^aeiou]\" word))))))\n",
  "  (let ([vowels '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")]\n\
    \        [length (string-length word)])\n    (if (or (= length 1) (= length 2))\n\
    \        \"\"\n        (let* ([is-vowel (lambda (x) (in-list? x vowels))]\n  \
    \             [is-last-letter-vowel (is-vowel (string-ref word (- length 1)))])\n\
    \          (if is-last-letter-vowel\n              (let loop ([index (- length\
    \ 2)])\n                (if (and (is-vowel (string-ref word index)) (not (is-vowel\
    \ (string-ref word (- index 1)))))\n                    (string-ref word index)\n\
    \                    (loop (- index 1))))\n              (let loop ([index (-\
    \ length 1)])\n                (if (and (is-vowel (string-ref word index)) (not\
    \ (is-vowel (string-ref word (- index 1)))))\n                    (string-ref\
    \ word index)\n                    (loop (- index 1)))))))))", "  (define (is-vowel?\
    \ c)\n    (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"\
    U\")))\n  (define (is-consonant? c)\n    (not (is-vowel? c)))\n  (define (in-between-two-consonants?\
    \ word i)\n    (and (> i 0) (< i (- (length word) 1))\n         (is-consonant?\
    \ (string-ref word (- i 1)))\n         (is-consonant? (string-ref word (+ i 1)))))\n\
    \  (define (solve word i)\n    (if (= i (- (length word) 1)) \"\"\n        (let\
    \ ((c (string-ref word i)))\n          (if (and (is-vowel? c) (in-between-two-consonants?\
    \ word i)) c\n              (solve word (+ i 1))))))\n  (solve word 0))\n", " \
    \ (if (or (eq? (string-length word) 1) (eq? (string-length word) 0))\n      \"\
    \"\n      (let* ([vowels (string-&gt;list \"aeiou\")]\n             [chars (string-&gt;list\
    \ word)]\n             [rev (reverse chars)]\n             [prev-is-consonant?\
    \ (member (string-&gt;symbol (list (car rev))) vowels)]\n             [next-is-consonant?\
    \ (member (string-&gt;symbol (list (cadr rev))) vowels)])\n        (cond [(and\
    \ (not prev-is-consonant?) (not next-is-consonant?))\n               (get_closest_vowel\
    \ (string-join (reverse (cddr rev))))]\n              [(and prev-is-consonant?\
    \ next-is-consonant?)\n               (string (car rev))]\n              [else\n\
    \               \"\"\n               ]))))\n</code>\n", "  (define vowel?\n  \
    \  (lambda (char)\n      (member char '(#\\a #\\e #\\i #\\o #\\u #\\A #\\E #\\\
    I #\\O #\\U))))\n  (let loop ((word (reverse word)) (closest-vowel (list)))\n\
    \    (cond [(null? word) (list->string (reverse closest-vowel))]\n          [(vowel?\
    \ (car word)) (if (or (null? (cdr word)) (vowel? (cadr word)))\n             \
    \                      (loop (cdr word) closest-vowel)\n                     \
    \              (loop (cdr word) (cons (car word) closest-vowel)))]\n         \
    \ [else (loop (cdr word) closest-vowel)])))", "  (define (is-consonant? c)\n \
    \   (and (not (member c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n         (or (char-alphabetic?\
    \ c)\n             (char-numeric? c))))\n  (define (c-to-string c)\n    (string\
    \ c))\n  (if (string=? word \"\")\n      \"\"\n      (if (is-consonant? (string-ref\
    \ word (sub1 (string-length word))))\n          (if (string=? word \"a\")\n  \
    \            \"a\"\n              (get_closest_vowel (substring word 0 (sub1 (string-length\
    \ word)))))\n          (if (is-consonant? (string-ref word 0))\n             \
    \ (if (and (member (string-ref word 1) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n   \
    \                    (is-consonant? (string-ref word 2)))\n                  (string-ref\
    \ word 1)\n                  (get_closest_vowel (substring word 1 (string-length\
    \ word))))\n              (get_closest_vowel (substring word 1 (string-length\
    \ word)))))))\n", "  (string-length (string-replace word #rx\"[aeiou]\" \"\")))\n\
    </code>\nHowever, it doesn't seem to be very fast, while getting the result with\
    \ a non-functional approach is quite fast.\n<code>;; How to convert this function\
    \ to a functional one?", "  (cond\n    [(empty? word)\n     \"\"]\n    [(or (vowel?\
    \ (last word)) (vowel? (first word)))\n     \"\"]\n    [(consonant? (last word))\n\
    \     (get_closest_vowel (rest word))]\n    [(consonant? (first word))\n     (first\
    \ word)]))\n", "  (let* ([w2 (string-&gt;list word)]\n         [vowels (list #\\\
    a #\\e #\\i #\\o #\\u)]\n         [found #f]\n         [vowel #\\a])\n    (do\
    \ ([n (length w2) (- n 1)])\n        ((or (= n 0) found) vowel)\n      (when (member\
    \ (list-ref w2 n) vowels)\n        (let ([cons-before #f]\n              [cons-after\
    \ #f])\n          (do ([i (- n 1) (- i 1)])\n              ((or (= i 0) cons-before)\
    \ #f)\n            (when (not (member (list-ref w2 i) vowels))\n             \
    \ (set! cons-before #t)))\n          (do ([i (+ n 1) (+ i 1)])\n             \
    \ ((or (= i (length w2)) cons-after) #f)\n            (when (not (member (list-ref\
    \ w2 i) vowels))\n              (set! cons-after #t)))\n          (when (and cons-before\
    \ cons-after)\n            (set! found #t)\n            (set! vowel (list-ref\
    \ w2 n)))))))\n</code>", "  (define (is_vowel? c)\n    (cond ((equal? c #\\a)\
    \ #t)\n          ((equal? c #\\e) #t)\n          ((equal? c #\\i) #t)\n      \
    \    ((equal? c #\\o) #t)\n          ((equal? c #\\u) #t)\n          (else #f)))\n\
    \  (define (get-closest-vowel-helper word prev)\n    (cond ((null? word) \"\"\
    )\n          ((and (is_vowel? (car word))\n                (not (is_vowel? prev)))\n\
    \           (list->string (list (car word))))\n          (else (get-closest-vowel-helper\
    \ (cdr word) (car word)))))\n  (get-closest-vowel-helper (cdr word) (car word)))",
  "  (define (get-closest-vowel-helper word index last-vowel-index)\n    (cond\n \
    \     [(= index (string-length word))\n       last-vowel-index]\n      [(member\
    \ (string-ref word index) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n       (get-closest-vowel-helper\
    \ word (+ index 1) index)]\n      [else\n       (get-closest-vowel-helper word\
    \ (+ index 1) last-vowel-index)]))\n  (let ([last-vowel-index (get-closest-vowel-helper\
    \ word 0 -1)])\n    (if (= last-vowel-index -1)\n        \"\"\n        (string-ref\
    \ word last-vowel-index))))\n</code>\n", "  (define (reverse-string s)\n    (apply\
    \ string (reverse (string->list s))))\n  (define (closest-vowel-aux word)\n  \
    \  (if (string-empty? word) #f\n        (if (or (char=? (string-ref word 0) #\\\
    a)\n                (char=? (string-ref word 0) #\\e)\n                (char=?\
    \ (string-ref word 0) #\\i)\n                (char=? (string-ref word 0) #\\o)\n\
    \                (char=? (string-ref word 0) #\\u))\n            (string-ref word\
    \ 0)\n            (closest-vowel-aux (substring word 1)))))\n  (closest-vowel-aux\
    \ (reverse-string word)))\n", "  (let ((vowels \"aeiouAEIOU\"))\n    (string-index\
    \ (string-join \n                   (filter \n                    (\u03BB (x)\n\
    \                      (and (member (string-ref word x) vowels)\n            \
    \               (not (member (string-ref word (- x 1)) vowels))\n            \
    \               (not (member (string-ref word (+ x 1)) vowels))))\n          \
    \          (iota (- (string-length word) 2)))))))\n", "  (define vowels (list\
    \ \"a\" \"e\" \"i\" \"o\" \"u\"))\n  (define word-list (string->list word))\n\
    \  (define (slice-list lst start stop)\n    (sublist lst start stop))\n  (define\
    \ (get-vowel word-list)\n    (define (get-next-vowel word-list index)\n      (cond\
    \ ((null? word-list) \"\")\n            ((memq (car word-list) vowels) (car word-list))\n\
    \            (else (get-next-vowel (cdr word-list) (+ index 1)))))\n    (define\
    \ (get-before-vowel word-list index)\n      (cond ((null? word-list) \"\")\n \
    \           ((memq (car word-list) vowels) (car word-list))\n            (else\
    \ (get-before-vowel (cdr word-list) (+ index 1)))))\n    (define (get-closest-vowel\
    \ word-list index)\n      (cond ((not (or (get-next-vowel word-list 0) (get-before-vowel\
    \ word-list 0))) \"\")\n            ((= (length (get-next-vowel word-list 0))\
    \ 0) (get-before-vowel word-list 0))\n            ((= (length (get-before-vowel\
    \ word-list 0)) 0) (get-next-vowel word-list 0))\n            ((<= (length (get-next-vowel\
    \ word-list 0)) (length (get-before-vowel word-list 0))) (get-next-vowel word-list\
    \ 0))\n            (else (get-before-vowel word-list 0))))\n    (get-closest-vowel\
    \ word-list 0))\n  (get-vowel word-list))", "  (let loop ([word word] [answer\
    \ \"\"])\n    (if (empty? word)\n        answer\n        (let ([n (string-length\
    \ word)])\n          (if (and (> n 1)\n                   (is-vowel? (string-ref\
    \ word (- n 1)))\n                   (is-consonant? (string-ref word (- n 2))))\n\
    \              (loop (substring word 0 (- n 1)) (string-ref word (- n 1)))\n \
    \             (loop (substring word 0 (- n 1)) answer))))))\n", "  (cond\n   \
    \ [(equal? word \"\") \"\"]\n    [(regexp-match? #rx\"[aeiou]\" word) word]\n\
    \    [else (get_closest_vowel (string-tail word 1))]))\n", "  (define (vowel?\
    \ c) (member c '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \  (define (previous-vowel word p)\n    (if (= p 0)\n        \"\"\n        (let\
    \ ([c (string-ref word p)])\n          (if (vowel? c)\n              c\n     \
    \         (previous-vowel word (- p 1))))))\n  (define (get-previous-closest word\
    \ p)\n    (if (= p 0)\n        \"\"\n        (let ([c (string-ref word p)])\n\
    \          (if (vowel? c)\n              (let ([c-prev (string-ref word (- p 1))])\n\
    \                (if (vowel? c-prev)\n                    (get-previous-closest\
    \ word (- p 1))\n                    c))\n              (get-previous-closest\
    \ word (- p 1))))))\n  (define (get-next-closest word p)\n    (if (= p (- (string-length\
    \ word) 1))\n        \"\"\n        (let ([c (string-ref word p)])\n          (if\
    \ (vowel? c)\n              (let ([c-next (string-ref word (+ p 1))])\n      \
    \          (if (vowel? c-next)\n                    (get-next-closest word (+\
    \ p 1))\n                    c))\n              (get-next-closest word (+ p 1))))))\n\
    \  (define (get-closest-vowel word p)\n    (let ([c (string-ref word p)])\n  \
    \    (if (vowel? c)\n          (let ([p-prev (previous-vowel word (- p 1))])\n\
    \            (if (string=? p-prev \"\")\n                (get-next-closest word\
    \ p)\n                (let ([p-next (get-next-closest word p)])\n            \
    \      (if (string=? p-next \"\")\n                      p-prev\n            \
    \          (let ([dist-prev (- p p-prev)]\n                            [dist-next\
    \ (- p p-next)", "  (string-copy (get-closest-vowel-aux (string->list word) ')))\n",
  "  (define (inner-get-closest-vowel index)\n    (cond ((&lt;= index 0) \"\")\n \
    \         ((or (char-alphabetic? (string-ref word index))\n               (string-ref\
    \ word index) #\\e)\n           (char-&gt;string (string-ref word index)))\n \
    \         (else (inner-get-closest-vowel (- index 1)))))\n  (inner-get-closest-vowel\
    \ (- (string-length word) 1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
