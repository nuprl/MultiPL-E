name: HumanEval_85_add
language: rkt
prompt: "#lang racket\n\n;; Given a non-empty list of integers lst. add the even elements\
  \ that are at odd indices..\n;; Examples:\n;; add([4, 2, 6, 7]) ==> 2\n(define (add\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate add))\n\
  \    (check-equal? (candidate (list 4 88)) 88)\n    (check-equal? (candidate (list\
  \ 4 5 6 7 2 122)) 122)\n    (check-equal? (candidate (list 4 0 6 7)) 0)\n    (check-equal?\
  \ (candidate (list 4 4 6 8)) 12)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) 0]\n    [(even? (first lst)) (+ (first lst)\
    \ (add (rest lst)))]\n    [else (add (rest lst))]))\n", "  (if (empty? lst)\n\
    \      0\n      (if (even? (first lst))\n          (+ (first lst) (add (rest lst)))\n\
    \          (add (rest lst)))))\n", "  (list-ref lst 1))\n```\n\n```\n#lang racket\n",
  "  (define (evens lst)\n    (filter even? lst))\n  (apply + (evens (list-ref lst\
    \ 1 2))))\n", "  (if (null? lst)\n      0\n      (if (even? (car lst))\n     \
    \     (+ (car lst) (add (cdr lst)))\n          (add (cdr lst)))))\n", "  (cond\n\
    \    [(= (length lst) 1) (car lst)]\n    [(= (remainder (length lst) 2) 0) (add\
    \ (cdr lst))]\n    [else (+ (car lst) (add (cdr lst)))]))\n", "  (sum (filter-map\
    \ (lambda (i)\n                     (if (and (even? i) (odd? (list-ref lst i)))\n\
    \                         i\n                         #f))\n                 \
    \  (range (length lst)))))\n</code>\n<code>#lang clojure\n", "  (let loop ([lst\
    \ lst] [ind 0] [acc 0])\n    (if (null? lst)\n        acc\n        (if (and (even?\
    \ ind) (even? (car lst)))\n            (loop (cdr lst) (+ ind 1) (+ acc (car lst)))\n\
    \            (loop (cdr lst) (+ ind 1) acc)))))\n", "  (if (empty? lst)\n    \
    \  0\n      (if (zero? (modulo (car lst) 2))\n          (if (zero? (modulo (length\
    \ lst) 2))\n              (add (cdr lst))\n              (+ (car lst) (add (cdr\
    \ lst))))\n          (add (cdr lst)))))\n", "  (accumulate + 0 (filter-odd-indexed\
    \ (filter even? lst))))\n", "  (list-ref lst 1))\n", "  (sum-odd-indexed-evens\
    \ lst 1))\n", "  (cond\n    [(empty? lst) 0]\n    [(and (even? (second lst)) (odd?\
    \ (first lst)))\n     (+ (second lst) (add (rest (rest lst))))]\n    [else (add\
    \ (rest lst))]))\n", "  (apply + (filter even? (filter-index even? lst))))\n",
  "  ;; if empty list, return 0\n  (if (null? lst)\n      0\n      ;; if first element\
    \ is even, recurse with the rest of the list and add that number\n      (if (even?\
    \ (car lst))\n          (+ (car lst) (add (cdr lst)))\n          ;; if first element\
    \ is odd, recurse with the rest of the list\n          (add (cdr lst)))))\n```\n\
    \n```\n#lang racket\n", "  (define (helper lst)\n    (cond ((empty? lst) empty)\n\
    \          ((= (modulo (first lst) 2) 0) (cons (first lst) (helper (rest lst))))\n\
    \          (else (helper (rest lst)))))\n  (cond ((empty? lst) 0)\n        (else\
    \ (add-list (helper lst)))))\n```\n\n```py\n# Given a non-empty list of integers\
    \ lst. add the even elements that are at odd indices..\n# Examples:\n# add([4,\
    \ 2, 6, 7]) ==> 2\n\ndef add(lst):\n    def helper(lst):\n        if len(lst)\
    \ == 0:\n            return []\n        elif lst[0] % 2 == 0:\n            return\
    \ [lst[0]] + helper(lst[1:])\n        else:\n            return helper(lst[1:])\n\
    \    if len(lst) == 0:\n        return 0\n    else:\n        return sum(helper(lst))\n\
    ```\n\n##### Notes:\n\n* [`modulo`](https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._modulo%29%29)\n\
    \n***\n\n## [Haskell](https://www.codewars.com/kata/55f5d4f75a14d83924000198)\n\
    \n```haskell\nmodule Challenge where\n\nsumOddEven :: [Int] -> Int\nsumOddEven\
    \ xs = sum (filter (\\x -> x `mod` 2 == 0) (map snd (filter (\\x -> (fst x) `mod`\
    \ 2 == 1) (zip [1..] xs))))\n```\n\n##### Notes:\n\n* [`filter`](https://www.haskell.org/hoogle/?hoogle=filter)\n\
    * [`map`](https://www.haskell.org/hoogle/?hoogle=map)\n* [`zip`](https://www.haskell.org/hoogle/?",
  "  (add-it lst 0 0 0))\n", "  (match lst\n    [(cons (? even?) rest) (+ (car lst)\
    \ (add rest))]\n    [(cons (? odd?)  rest) (add rest)]\n    [empty           \
    \    0]))\n", "    (define (odd? n) (= 1 (remainder n 2)))\n    (define (even?\
    \ n) (= 0 (remainder n 2)))\n    (cond [(empty? lst) 0]\n          [(and (odd?\
    \ (length lst)) (even? (first lst))) (add (rest lst))]\n          [(and (even?\
    \ (length lst)) (even? (first lst))) (+ (first lst) (add (rest lst)))]\n     \
    \     [else (add (rest lst))]))\n", "    (cond\n        [(empty? lst) 0]\n   \
    \     [(even? (car lst)) (+ (car lst) (add (cdr lst)))]\n        [else (add (cdr\
    \ lst))]))\n", "  (cond [(empty? lst) 0]\n        [(not (zero? (remainder (car\
    \ lst) 2)))\n         (+ (car lst) (add (cdr lst)))]\n        [else (add (cdr\
    \ lst))]))\n", "  (apply + (filter even? (filter odd? (iota (sub1 (length lst)))))))\n",
  "  (apply + (filter odd? (filter even? (map add1 (range 0)))))\n)\n", "  (apply\
    \ + (filter even? (filter-map (curry (lambda (x i)\n                         \
    \                    (and (even? i) x))) lst (in-naturals 1)))))\n", "  (define\
    \ (iter lst sum idx)\n    (cond ((empty? lst) sum)\n          ((and (even? idx)\
    \ (even? (first lst))) (iter (rest lst) (+ sum (first lst)) (+ idx 1)))\n    \
    \      (else (iter (rest lst) sum (+ idx 1)))))\n  (iter lst 0 0))\n", "  (cond\
    \ [(empty? lst) 0]\n        [(and (even? (car lst)) (odd? (pos (car lst) lst)))\
    \ (+ (car lst) (add (cdr lst)))]\n        [else (add (cdr lst))]))\n", "  (apply\
    \ + (filter odd? (filter even? (filter-index even? lst)))))\n", "  (define (sum-even-odd-idx\
    \ lst idx count)\n    (cond ((null? lst) count)\n          ((and (even? idx) (even?\
    \ (car lst)))\n           (sum-even-odd-idx (cdr lst) (+ idx 1) (+ count (car\
    \ lst))))\n          (else (sum-even-odd-idx (cdr lst) (+ idx 1) count))))\n \
    \ (sum-even-odd-idx lst 0 0))\n```\n\n```racket\n#lang racket\n", "  (apply +\
    \ (filter even? (filter-odd-indices lst))))\n", "  (if (or (empty? lst) (empty?\
    \ (cdr lst)))\n      0\n      (if (even? (car lst))\n          (+ (car lst) (add\
    \ (cddr lst)))\n          (add (cdr lst)))))\n", "  (define (f lst x)\n    (if\
    \ (null? lst)\n        x\n        (if (and (even? (car lst)) (odd? (length lst)))\n\
    \            (f (cdr lst) (+ x (car lst)))\n            (f (cdr lst) x))))\n \
    \ (f lst 0))\n", "  (cond\n    [(empty? lst) 0]\n    [(= 1 (remainder (car lst)\
    \ 2)) (add (cdr lst))]\n    [else (+ (car lst) (add (cdr lst)))]))\n", "  (for/sum\
    \ ([x (in-list lst)])\n    (if (and (even? x) (odd? (in-list lst x)))\n      \
    \  x\n        0)))\n", "  (apply + (filter even? (filter-odd-indices lst))))\n",
  "  (cond\n    [(empty? lst) 0]\n    [(zero? (remainder (first lst) 2)) (add (rest\
    \ lst))]\n    [else (+ (first lst) (add (rest lst)))]))\n\n```\n\n```racket\n\n\
    #lang racket\n", "  (accumulate-even-odd lst 0 add 0 add))\n", "  (for/sum ([v\
    \ (in-list lst) :when (even? v)]\n            [i (in-naturals)])\n    v))\n```\n\
    \n## User-defined operators\n\nUser-defined operators are like macros that accept\
    \ input forms and output\nparsed symbols.\n\n```racket\n#lang racket\n", "  (if\
    \ (null? lst) 0\n      (+ (if (and (even? (car lst)) (odd? (car (cdr lst)))) (car\
    \ lst) 0)\n         (add (cdr lst)))))\n", "  (cond [(null? lst) 0]\n        [(zero?\
    \ (modulo (car lst) 2))\n         (+ (car lst) (add (cdr lst)))]\n        [else\
    \ (add (cdr lst))]))\n", "  (let loop ((lst lst) (acc 0))\n    (if (null? lst)\n\
    \        acc\n        (loop (cdr lst) (if (and (even? (car lst)) (odd? (modulo\
    \ (length lst) 2))) (+ acc (car lst)) acc)))))\n", "  (cond\n    [(and (not (null?\
    \ lst)) (not (null? (cdr lst)))) (+ (cadr lst) (add (cddr lst)))]\n    [else 0]))\n",
  "  (if (empty? lst)\n      0\n      (let ((x (first lst))\n            (xs (rest\
    \ lst)))\n        (if (even? x)\n            (+ x (add xs))\n            (add\
    \ xs)))))\n\n", "  (evens-odds lst))\n", "    (define (even? n)\n        (= (remainder\
    \ n 2) 0))\n    (define (odd? n)\n        (not (even? n)))\n    (define (helper\
    \ rst i)\n        (if (null? rst) 0\n            (if (and (even? i) (even? (car\
    \ rst))) (+ (car rst) (helper (cdr rst) (+ i 1)))\n                (helper (cdr\
    \ rst) (+ i 1)))))\n    (helper lst 0))\n", "  (apply + (filter even? (range 1\
    \ (length lst) 2) lst)))\n</code>\nWhich should return <code>2</code> but is returning\
    \ <code>0</code>.\n<code>add([4, 2, 6, 7])\n</code>\nWhat am I doing wrong?\n\n\
    \nA:\n\nHere's one possible solution:\n<code>(define (add lst)\n  (apply + (filter\
    \ even? (cddr lst))))\n</code>\nOr, in a shorter way:\n<code>(define (add lst)\n\
    \  (apply + (filter even? (list-tail lst 2))))\n</code>\nBoth solutions take advantage\
    \ of the fact that in Racket lists can be sliced like this: <code>(cddr lst)</code>\
    \ returns the list <code>lst</code> without the first two elements. The first\
    \ solution also makes use of the fact that <code>cddr</code> can also be called\
    \ recursively to get rid of an arbitrary number of elements in the head of the\
    \ list.\n", "  (for/sum ([elt lst]\n            #:when (odd? (length lst))\n \
    \           #:when (even? elt))\n    elt))\n", "  (define (even? x) (= (remainder\
    \ x 2) 0))\n  (define (odd? x) (= (remainder x 2) 1))\n  (foldl (lambda (x acc)\
    \ (if (and (even? x) (odd? acc)) (+ x acc) acc)) 0 lst))\n</code>\nThis code return\
    \ <code>0</code> instead of <code>2</code>. I don't know why. Can you help me?\n",
  "  (letrec ([ret (foldr + 0 (map-some (\u03BB (n) (if (and (even? n) (odd? (index\
    \ lst n))) (list n))) lst))])\n    ret))\n```\n\n### [Q2: Max String Length](https://codewars.com/kata/5842df8ccbd22792a4000245)\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(null? lst) 0]\n    [(even? (car\
    \ lst)) (+ (car lst) (add (cdr lst)))]\n    [else (add (cdr lst))]))\n", "  (define\
    \ lst-evens-odd-indices (filter (lambda (x) (= 0 (remainder x 2)))\n         \
    \                                (filter (lambda (x) (even? x))\n            \
    \                                     (range 1 (length lst)))))\n  (apply + (map\
    \ (lambda (x) (list-ref lst x)) lst-evens-odd-indices)))\n", "  (local [(define\
    \ (helper i sum)\n            (cond\n              [(empty? lst) sum]\n      \
    \        [(zero? (modulo i 2)) (helper (+ i 1) (+ sum (first lst)))]\n       \
    \       [else (helper (+ i 1) sum)]))]\n    (helper 0 0)))\n```\n\n## Challenge\
    \ #2\n\n```#lang racket\n", "  (if (or (null? lst) (null? (cdr lst)))\n      0\n\
    \      (let ([a (car lst)]\n            [b (car (cdr lst))])\n        (+ a (add\
    \ (cdr (cdr lst)))))))\n", "  (sum (filter odd? (evens-at-odds lst))))\n", " \
    \ (cond [(empty? lst) 0]\n        [(odd? (cdr lst)) (+ (car lst) (add (cddr lst)))]\n\
    \        [else (add (cddr lst))]))\n", "  (apply + (filter (lambda (x) (odd? x))\
    \ (filter even? lst))))\n", "  (cond ((null? lst) 0)\n        ((even? (first lst))\
    \ (+ (first lst) (add (rest lst))))\n        (else (add (rest lst)))))\n", " \
    \ (define n lst)\n  (define s 0)\n  (for ([i (in-range (length lst))])\n    (set!\
    \ n (cdr n))\n    (set! s (+ s (car n)))\n    (set! n (cdr n)))\n  s)\n", "  (let*\
    \ ([lst2 (for/fold ([lst-new (list)]) ([n (in-list lst)])\n                  (if\
    \ (and (even? n) (odd? (in-list-index lst (list n))))\n                      (append\
    \ lst-new (list n))\n                      lst-new))])\n    (apply + lst2)))\n",
  "  (foldl + 0 (filter even? (filter-odd-indices lst))))\n", "  (foldl + 0 (filter\
    \ number? (cddr lst))))\n```\n\nThe result should be `2`.\n\n## Use map to square\
    \ the numbers of a list\n\nImplement a function that squares the numbers of a\
    \ list.\n\n```\n#lang racket\n", "  (define (loop lst acc)\n    (cond\n      [(null?\
    \ lst) acc]\n      [(odd? (car lst)) (loop (cdr lst) (+ acc (car lst)))]\n   \
    \   [else (loop (cdr lst) acc)]))\n  (loop lst 0))\n", "  (let ([result 0])\n\
    \    (for ([(n i) (in-indexed lst)])\n      (when (and (even? n) (odd? i))\n \
    \       (set! result (+ result n))))\n    result))", "  (let* ([filt (filter odd?\
    \ (filter even? (range (length lst)))))\n         [filt_pos (map (lambda (x) (+\
    \ x 1)) filt)])\n    (apply + (map (lambda (x) (list-ref lst x)) filt_pos))))\n",
  "  (if (null? lst)\n      0\n      (if (odd? (index lst))\n          (add (tail\
    \ lst))\n          (+ (first lst) (add (tail lst))))))\n", "  (if (empty? lst)\n\
    \      0\n      (if (even? (car lst))\n          (+ (car lst) (add (cdr lst)))\n\
    \          (add (cdr lst)))))\n", "  (foldl + 0 (filter even? (filter-index odd?\
    \ lst))))\n", "  (cond [(empty? lst) 0]\n        [(= (remainder (car lst) 2) 0)\
    \ (car lst)]\n        [else (car lst)]))\n</code>\nMy problem is that the program\
    \ is not adding up my list at all.\n<code>&gt; (add '(4 2 6 7))\n4\n</code>\n\
    It does, however, work for lists with a single even number.\n<code>&gt; (add '(4))\n\
    4\n</code>\nWould I have to use <code>map</code> to accumulate the even numbers\
    \ at odd indices? I've never used <code>map</code> before, so I'm not too familiar\
    \ with it.\n\n\nA:\n\nThe <code>car</code> of the list is an even number, so the\
    \ first clause evaluates to <code>4</code>, and the result of the whole <code>cond</code>\
    \ expression is <code>4</code>.\nYou could use <code>filter</code> and <code>cdr</code>:\n\
    <code>(define (even-odd lst)\n  (filter even? (cdr (filter odd? lst))))\n</code>\n\
    The first <code>filter</code> retains only the odd numbers, and the second <code>filter</code>\
    \ retains only the even numbers of the result, including the numbers at odd positions.\n\
    You may use <code>reduce</code> with <code>+</code>:\n<code>(define (add lst)\n\
    \  (reduce + (even-odd lst)))\n</code>\n", "  (apply + (filter even? (filter odd?\
    \ (enumerate lst)))))\n", "  (if (null? lst)\n      0\n      (if (even? (car lst))\n\
    \          (+ (car lst) (add (cdr lst)))\n          (add (cdr lst)))))\n", " \
    \ (cond\n    [(empty? lst) '()]\n    [(odd? (remainder (car lst) 2)) (add (cdr\
    \ lst))]\n    [else (+ (car lst) (add (cdr lst)))]))\n", "  (sum-even-odd-index\
    \ lst 0 0))\n", "  (foldl + 0 (filter even? (filter-odd lst))))\n", "  (sum (filter-odds\
    \ (filter even? lst))))\n", "  (if (= 0 (modulo (length lst) 2))\n      0\n  \
    \    (accumulate + 0\n                  (for/list ([i (in-range 1 (length lst)\
    \ 2)] [e (in-list lst)])\n                    (if (even? e) e 0)))))\n", "  (define\
    \ (add_h acc index lst)\n    (cond [(empty? lst) acc]\n          [(and (even?\
    \ index) (even? (first lst)))\n           (add_h (+ acc (first lst)) (+ index\
    \ 1) (rest lst))]\n          [else (add_h acc (+ index 1) (rest lst))]))\n  (add_h\
    \ 0 0 lst))\n", "  (local [(define (add* lst result)\n            (if (empty?\
    \ lst)\n                result\n                (let ([num (first lst)])\n   \
    \               (if (and (even? num) (odd? (length lst)))\n                  \
    \    (add* (rest lst) (+ result num))\n                      (add* (rest lst)\
    \ result)))))])\n    (add* lst 0)))\n", "  (local [(define (helper lst count)\n\
    \            (cond\n              [(null? lst) 0]\n              [(and (odd? count)\
    \ (even? (car lst))) (+ (car lst) (helper (cdr lst) (+ count 1)))]\n         \
    \     [else (helper (cdr lst) (+ count 1))]))]\n    (helper lst 0)))\n", "  (letrec\n\
    \    ([loop (lambda (acc idx lst)\n      (cond\n        [(null? lst) acc]\n  \
    \      [(= (modulo idx 2) 1) (loop (+ acc (car lst)) (+ idx 1) (cdr lst))]\n \
    \       [else (loop acc (+ idx 1) (cdr lst))]))])\n    (loop 0 0 lst)))\n", " \
    \ (let loop ([lst lst] [i 0] [sum 0])\n    (cond\n      [(empty? lst) sum]\n \
    \     [(odd? i) (loop (rest lst) (+ i 1) (+ sum (first lst)))]\n      [else (loop\
    \ (rest lst) (+ i 1) sum)])))\n", "  (cond [(empty? lst) 0]\n        [(not (even?\
    \ (list-ref lst 0))) (add (cdr lst))]\n        [else (+ (list-ref lst 0) (add\
    \ (cdr lst)))]))\n", "  (cond ((null? lst) 0)\n        ((odd? (cdr lst)) (+ (car\
    \ lst) (add (cddr lst))))\n        (else (add (cdr lst)))))\n", "  (local ((define\
    \ (is-even? x)\n            (equal? 0 (remainder x 2)))\n          (define (odd-idx?\
    \ idx)\n            (is-even? (add1 idx))))\n    (foldl (lambda (idx elt acc)\n\
    \             (if (and (odd-idx? idx) (is-even? elt))\n                 (add1\
    \ acc)\n                 acc))\n           0\n           lst)))\n", "  (cond\n\
    \    [(null? lst) 0]\n    [(even? (car lst)) (add (cdr lst))]\n    [else (+ (car\
    \ lst) (add (cdr lst)))]))\n", "  (cond\n    [(null? lst) 0]\n    [(odd? (car\
    \ lst))\n     (add (cdr lst))]\n    [else\n     (+ (car lst) (add (cdr lst)))]))\n\
    ```\n\n#### Codewars\n\n```racket\n#lang racket\n", "  (if (null? lst) 0\n   \
    \ (add-helper lst 0 0)))\n", "  (cond\n    [(empty? lst) 0]\n    [(and\n     \
    \ (zero? (modulo (first lst) 2))\n      (odd? (length lst)))\n     (+ (first lst)\
    \ (add (rest lst)))]\n    [else (add (rest lst))]))\n", "  (define (add-iter lst\
    \ acc)\n    (cond ((empty? lst) acc)\n          ((even? (car lst))\n         \
    \  (add-iter (cdr lst) (+ acc (car lst))))\n          (else (add-iter (cdr lst)\
    \ acc))))\n  (add-iter lst 0))\n```", "  (foldl (lambda (el acc) (if (and (even?\
    \ el) (odd? acc)) (+ el acc) acc)) 0 lst))\n", "  (foldl (lambda (acc x) (if (and\
    \ (even? x) (odd? (list-ref lst (flr acc)))) (add1 acc) acc)) 0 lst))\n</code>\n\
    I know that it's not a good idea to add a <code>flr</code> to the <code>list-ref</code>\
    \ but I didn't know how to get rid of the fractional part of <code>acc</code>.\
    \ I would like to know how to do it in a better way.\n\n\nA:\n\nI suppose you\
    \ can also use Racket's <code>odd-index?</code>:\n<code>(require racket/list)\n",
  "  (cond\n    [(empty? lst) 0]\n    [(or (even? (first lst)) (odd? (zero? (length\
    \ lst)))) (+ (first lst) (add (rest lst)))]\n    [else (add (rest lst))]))\n",
  "  (define (add-helper lst n odd-sum)\n    (if (empty? lst)\n        odd-sum\n \
    \       (cond\n         ((= 0 (modulo n 2)) (add-helper (rest lst) (+ n 1) (+\
    \ odd-sum (first lst))))\n         (else (add-helper (rest lst) (+ n 1) odd-sum)))))\n\
    \  (add-helper lst 0 0))\n", "    (cond\n        [(or (null? lst) (null? (cdr\
    \ lst))) 0]\n        [(even? (car lst)) (+ (car lst) (add (cdr (cdr lst))))]\n\
    \        [else (add (cdr lst))]))", "  (let loop ([lst lst] [res 0])\n    (cond\
    \ [(empty? lst) res]\n          [(odd? (cdr lst))\n           (loop (cddr lst)\
    \ (+ res (car lst)))]\n          [else (loop (cddr lst) res)])))\n", "    (accumulate\
    \ + 0 (filter even? (filter-odd lst))))\n", "  ;; check that it is a list and\
    \ it is not empty\n  (check-expect (add (list 1 2 3)) 0)\n  (check-expect (add\
    \ (list 1 2 3 4)) 2)\n  (check-expect (add (list 2 3)) 0)\n  (check-expect (add\
    \ (list 2 3 4)) 2)\n  (check-expect (add (list -1 1 2 3)) 2)\n  (check-expect\
    \ (add (list -1 1 -2 3)) -2)\n  (check-expect (add (list -1 1 2 -3)) 0)\n  (check-expect\
    \ (add (list -1 1 2 3 -5)) 0)\n  (check-expect (add (list -1 1 -2 3 -5)) -2)\n\
    \  (check-expect (add (list -1 1 -2 3 -5 -6)) -6)\n  (check-expect (add (list\
    \ -1 1 -2 3 -5 -6 8)) 4)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10)) 10)\n\
    \  (check-expect (add (list -1 1 -2 3 -5 -6 8 10 -12)) -2)\n  (check-expect (add\
    \ (list -1 1 -2 3 -5 -6 8 10 -12 14)) 8)\n  (check-expect (add (list -1 1 -2 3\
    \ -5 -6 8 10 -12 14 16)) 18)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10\
    \ -12 14 16 -18)) -2)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10 -12 14\
    \ 16 -18 20)) 10)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10 -12 14 16 -18\
    \ 20 -22)) -2)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10 -12 14 16 -18\
    \ 20 -22 24)) 14)\n  (check-expect (add (list -1 1 -2 3 -5 -6 8 10 -", "  (apply\
    \ + (filter even? (filter-odd lst))))\n", "  (apply + (filter even? (filter odd?\
    \ (enumerate lst)))))\n", "  (cond\n    [(empty? lst) 0]\n    [(and (even? (first\
    \ lst)) (odd? (add1 (remainder (length lst) 2)))) (+ (first lst) (add (rest lst)))]\n\
    \    [else (add (rest lst))]))", "  (sum (filter even? (list-ref lst 1 3 5))))\n\
    </code>\nIs there a way to write a <code>list-ref</code> that only fetches the\
    \ elements I want instead of using <code>filter</code> after?\n\n\nA:\n\nNot as\
    \ a built-in function, but with your own list comprehension:\n<code>(define (list-ref-even\
    \ lst)\n  (for/list ([i (in-range (length lst))]\n             #:when (even? i)\n\
    \             #:when (even? (list-ref lst i)))\n    (list-ref lst i)))\n</code>\n",
  "  (cond\n    [(empty? lst) 0]\n    [(even? (car lst)) (car lst)]\n    [else (add\
    \ (cdr lst))]))\n", "  (cond [(empty? lst) 0]\n        [(number? (first lst))\n\
    \         (cond [(odd? (remainder (position lst) 2)) (+ (first lst) (add (rest\
    \ lst)))]\n               [else (add (rest lst))])]\n        [else (add (rest\
    \ lst))]))\n", "  (define (loop lst even odd)\n    (if (empty? lst)\n        0\n\
    \        (let ((n (first lst)))\n          (if (and (not (odd? n)) (odd? odd))\n\
    \              (+ n (loop (rest lst) (add1 even) (add1 odd)))\n              (loop\
    \ (rest lst) (add1 even) (add1 odd))))))\n  (loop lst 0 0))\n</code>\n", "  (apply\
    \ + (filter (\u03BB (x) (= 0 (modulo x 2))) (filter-odds lst))))\n", "  (for/sum\
    \ ([el (in-list lst) :when (even? el)]\n            [idx (in-range (length lst))\
    \ :when (odd? idx)])\n    el))\n", "  (if (empty? lst) 0\n      (let ([curr (first\
    \ lst)])\n        (if (and (even? curr) (odd? (rest-index lst))) (+ curr (add\
    \ (rest lst)))\n            (add (rest lst))))))\n", "  (if (null? lst)\n    \
    \  0\n      (let ([even? (remainder (car lst) 2)]\n            [idx (remainder\
    \ (length lst) 2)])\n        (if (and even? (not idx))\n            (+ (car lst)\
    \ (add (cdr lst)))\n            (add (cdr lst))))))\n", "  (apply + (filter (lambda\
    \ (x) (and (even? x) (odd? (position x lst)))) lst)))\n", "  (define (helper lst\
    \ prev acc)\n    (if (null? lst)\n        acc\n        (let ([value (car lst)])\n\
    \          (helper (cdr lst) (modulo (+ value prev) 2) (if (= (modulo (+ value\
    \ prev) 2) 1)\n                                                          (+ acc\
    \ value)\n                                                          acc)))))\n\
    \  (helper lst 0 0))\n", "  (apply + (filter even? (filter-map (lambda (x y) y)\
    \ (build-list (length lst) add1) lst))))\n", "  (sum (build-list lst)))\n", " \
    \ (letrec ([odd? (lambda (n) (eq? (remainder n 2) 1))]\n           [even? (lambda\
    \ (n) (eq? (remainder n 2) 0))]\n           [even-odds (lambda (lst n acc)\n \
    \                       (cond [(null? lst) acc]\n                            \
    \  [(even? n) (even-odds (cdr lst) (add1 n) (add acc (car lst)))]\n          \
    \                    [else (even-odds (cdr lst) (add1 n) acc)]))])\n    (even-odds\
    \ lst 0 0)))\n```\n\n### Get the even numbers of a list\n\n```racket\n#lang racket\n",
  "  (cond [(= (remainder (length lst) 2) 0) (add-even-helper lst)]\n        [else\
    \ (add-odd-helper lst)]))\n", "    (foldl + 0 (filter even? (filter odd? (range\
    \ 1 (length lst)))))\n)\n", "  (begin\n    (cond [(empty? lst) 0]\n          [(empty?\
    \ (rest lst)) 0]\n          [(or\n            (and (even? (car lst)) (odd? (cadr\
    \ lst)))\n            (and (odd? (car lst)) (even? (cadr lst))))\n           (+\
    \ (car lst) (add (rest lst)))]\n          [else (add (rest lst))])))\n</code>\n\
    This is a simple problem but I'm not sure how to test such a thing in Racket.\n\
    There are two ways I can think of:\n\nA simple unit test where I just test on\
    \ some given examples.\nA test as described in this exercise.\n\nBut that exercise\
    \ is a bit confusing to me. It says to check if the procedure is tail-recursive\
    \ and then continue from there.\nI'm not sure what the point is of checking if\
    \ a function is tail-recursive. I mean, if I'm writing the function, I can control\
    \ this and make it so.\nIf I'm writing a function that takes a function as an\
    \ argument, I don't see why I would care about if it is tail-recursive. Is there\
    \ a way to find out?\nAnd what do I do after that?\nSo my question is:\n\nIs checking\
    \ if a function is tail-recursive relevant in this situation?\nIf it is, how would\
    \ I go about testing this?\nIf it isn't, what would you recommend doing instead?\n\
    \n\n\nA:\n\nI would say it's relevant in the sense that you want to write a function\
    \ that is tail-recursive, but that's not the only way to do it.\nChecking if a\
    \ function is tail-recursive can be done by checking if there is a <code>goto</code>\
    \ statement in the compiled code, or doing a manual inspection. \nIn this case,\
    \ you could also use the racket profiler to check it.\nThe point of checking if\
    \ a function is tail-recursive is to make sure the function will not eat up all\
    \ the stack when called with a large argument, and possibly crash the program.\n\
    For this function, you could instead write it like this:\n<code>(define (add lst)\n\
    \  (apply +\n         (filter even?\n                 (filter-map (\u03BB (i x",
  "  (apply + (filter even? (filter-odd lst))))\n</code>\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [(even? (first lst)) (+ (first lst) (add (rest lst)))]\n    [else\
    \ (add (rest lst))]))\n", "  (let* ([odd-indices (list->set\n                \
    \       (for/list ([ind (in-range (length lst))])\n                         (if\
    \ (odd? ind) ind)))])\n    (foldl + 0 (for/list ([n (in-list lst)]\n         \
    \                 #:when (even? n)\n                          #:when (set-member?\
    \ odd-indices (list-ref lst n))\n                          #:collect n))))\n</code>\n\
    I don't like the idea of creating a complete set that contains all the odd indices\
    \ and then filtering the elements of the list by those indices. Is there a way\
    \ to do this without creating a set?\n\n\nA:\n\nThere are multiple ways to do\
    \ this, this is one of them:\n<code>(define (add lst)\n  (define (from-odd? index\
    \ n)\n    (and (odd? index)\n         (even? n)))\n  (foldl + 0 (filter from-odd?\
    \ lst)))\n</code>\n", "  (apply + (filter even? (filter odd? (range 0 (length\
    \ lst)) (\u03BB (i) (list-ref lst i))))))\n", "  (if (empty? lst)\n      0\n \
    \     (if (even? (car lst))\n          (+ (car lst) (add (cdr lst)))\n       \
    \   (add (cdr lst)))))\n", "  (cond\n    [(empty? lst) 0]\n    [(even? (first\
    \ lst)) (+ (first lst) (add (rest lst)))]\n    [else (add (rest lst))]))\n```\n\
    \nInput:\n```text", "  (match lst\n    [(cons (? even?) (? odd?)) 'dummy]\n  \
    \  [(cons (? odd?) lst2) 'dummy]\n    [(cons lst1 (cons lst2 (cons lst3 lst4)))\
    \ 'dummy]))\n", "  (for/sum ([x (in-list lst) :when (odd? (add1 (modulo (list-ref\
    \ lst (sub1 x)) 2))))]\n            [y (in-list lst) :when (even? (add1 (modulo\
    \ (list-ref lst (sub1 y)) 2)))]\n            x)\n  )\n", "  (cond [(empty? lst)\
    \ 0]\n        [(zero? (remainder (car lst) 2))\n         (+ (car lst) (add (cdr\
    \ lst)))]\n        [else\n         (add (cdr lst))]))\n```\n\n``` #lang racket",
  "  (letrec ([sum 0]\n           [ind 1])\n    (for ([i lst])\n      (cond\n    \
    \    [(= (remainder ind 2) 1) (= (add i) ind)]\n        [else (= (add sum i) ind)]))\n\
    \    sum))\n", "  (apply + (map (lambda (x) x) (filter even? (range 0 (length\
    \ lst) 2)))))\n", "  (cond\n    [(empty? lst) 0]\n    [(= 1 (remainder (car lst)\
    \ 2)) (add (cdr lst))]\n    [else (+ (car lst) (add (cdr lst)))]))\n", "  (define\
    \ (add-helper lst sum)\n    (if (null? lst)\n        sum\n        (if (and (even?\
    \ (car lst)) (odd? (quotient (length lst) 2)))\n            (add-helper (cdr lst)\
    \ (+ sum (car lst)))\n            (add-helper (cdr lst) sum))))\n  (add-helper\
    \ lst 0))\n", '  (sum (map odd-indices lst)))', "  (define (addAux lst pos acc)\n\
    \    (cond ((null? lst)\n           acc)\n          ((and (zero? (remainder pos\
    \ 2)) (even? (car lst)))\n           (addAux (cdr lst) (+ pos 1) (+ acc (car lst))))\n\
    \          (else\n           (addAux (cdr lst) (+ pos 1) acc))))\n  (addAux lst\
    \ 0 0))\n", "  (let ((acc 0))\n    (for ([e lst]\n          [i (in-range (length\
    \ lst))])\n      (when (and (= (modulo i 2) 1)\n                 (= (modulo e\
    \ 2) 0))\n        (set! acc (+ acc e))))\n    acc))\n", "  (add-cps lst 0 (lambda\
    \ (v) v)))\n", "  (cond\n    [(empty? lst)\n     0]\n    [(not (empty? (cdr lst)))\n\
    \     (if (even? (car lst))\n         (+ (car lst) (add (cddr lst)))\n       \
    \  (add (cdr lst)))]\n    [else\n     (car lst)]))\n", "  (add-even-odd-indices\
    \ lst 0 0))\n", "  (let loop ((lst lst) (sum 0))\n    (cond\n      [(empty? lst)\
    \ sum]\n      [(even? (car lst)) (loop (cdr lst) (+ sum (car lst)))]\n      [else\
    \ (loop (cdr lst) sum)])))\n", "  (for/sum ([i (in-naturals)]\n            [val\
    \ (in-list lst)])\n    (if (and (even? i) (odd? val))\n        val\n        0)))\n",
  "  (cond [(empty? lst) 0]\n        [(= 1 (modulo (first lst) 2)) (+ (add (rest lst))\
    \ (first lst))]\n        [else (add (rest lst))]))\n```\n\n## Problem 5 - Sum\
    \ of Min and Max\n\n```\n#lang racket\n", "  (for/sum ([i (in-naturals)])\n  \
    \  (let ([val (list-ref lst i)])\n      (if (and (even? val) (odd? i))\n     \
    \     val\n          0))))\n", "  (accumulate + 0 (map (lambda (n) (if (even?\
    \ n) n 0)) (range (length lst)) lst)))\n", "  (sum\n   (filter even?\n       \
    \    (filter (lambda (n) (not (zero? (modulo n 2))))\n                   lst))))",
  "  (accumulate + 0 (cddr (filter even? lst))))\n", "  (letrec ((even-odd-positions\n\
    \             (lambda (lst acc pos)\n               (cond\n                 [(empty?\
    \ lst) (reverse acc)]\n                 [(odd? pos)\n                  (even-odd-positions\
    \ (rest lst) (cons (first lst) acc) (+ pos 1))]\n                 [else (even-odd-positions\
    \ (rest lst) acc (+ pos 1))]))))\n    (accumulate + 0 (even-odd-positions lst\
    \ '() 0))))\n```\n\n```racket\n#lang racket\n", "  (for/sum ([i (in-range (length\
    \ lst))] #:when (and (even? i) (even? (list-ref lst i))))\n    (list-ref lst i)))\n\
    \n\n", "  (for/sum ([elt lst] #:when (even? elt) #:index odd?) elt))\n", "  (letrec\
    \ ((loop (lambda (lst index)\n                   (cond [(null? lst) 0]\n     \
    \                    [(= (modulo index 2) 1)\n                          (+ (car\
    \ lst) (loop (cdr lst) (+ index 1)))]\n                         [else (loop (cdr\
    \ lst) (+ index 1))]))))\n    (loop lst 0)))\n", "  (foldl + 0 (filter even? (filter-odds\
    \ lst))))\n", '  (apply + (filter even? (cddr lst))))', "  (foldl (lambda (x y)\
    \ (+ (if (even? x) x 0) y)) 0 lst))\n</code>\n", "  (let add-helper ([lst lst]\
    \ [cntr 0] [s 0])\n    (if (null? lst)\n        s\n        (if (and (even? cntr)\
    \ (odd? (car lst)))\n            (add-helper (cdr lst) (+ cntr 1) (+ s (car lst)))\n\
    \            (add-helper (cdr lst) (+ cntr 1) s)))))\n", "  (define (add-iter\
    \ lst n acc)\n    (if (empty? lst)\n        acc\n        (if (even? n)\n     \
    \       (add-iter (rest lst) (add1 n) (add1 acc))\n            (add-iter (rest\
    \ lst) (add1 n) acc))))\n  (add-iter lst 0 0))\n", "  (define size (length lst))\n\
    \  (define (accumulate x y)\n    (if (= y size)\n        x\n        (if (and (even?\
    \ (list-ref lst y))\n                 (odd? y))\n            (+ x (list-ref lst\
    \ y))\n            x)))\n  (for/fold ([x 0]) ([y (in-range size)])\n    (accumulate\
    \ x y)))\n", "  (cond [(empty? lst) 0]\n        [(odd? (count lst))\n        \
    \ (+ (first lst) (add (rest lst)))]\n        [else (add (rest lst))]))\n", " \
    \ (let ([idx 0])\n    (sum (filter-map (lambda (x)\n                       (and\
    \ (even? x)\n                            (odd? idx)\n                        \
    \    (set! idx (+ idx 1))\n                            x))\n                 \
    \    lst))))\n", "  (let loop ((lst lst) (s 0))\n    (if (null? lst)\n       \
    \ s\n        (loop (cdr lst) (if (odd? (car lst)) (+ s (car lst)) s)))))\n", " \
    \ (apply + (filter even? (filter-odds lst))))\n", "  (sum (keep-indexed even?\
    \ lst 2)))\n", "  (define (add-helper lst i sum)\n    (cond\n      [(empty? lst)\
    \ sum]\n      [(even? i) (add-helper (rest lst) (+ i 1) (+ sum (first lst)))]\n\
    \      [else (add-helper (rest lst) (+ i 1) sum)]))\n  (add-helper lst 0 0))\n",
  "  (define (iter lst sum)\n    (cond ((null? lst) sum)\n          ((even? (car lst))\
    \ (iter (cdr lst) (+ sum (car lst))))\n          (else (iter (cdr lst) sum))))\n\
    \  (iter lst 0))\n", "  (let loop ((lst lst) (sum 0))\n    (if (null? lst)\n \
    \       sum\n        (let ((i (car lst)))\n          (if (and (even? i) (odd?\
    \ (length lst)))\n              (loop (cdr lst) (+ sum i))\n              (loop\
    \ (cdr lst) sum))))))\n", "  (define (isEven n)\n    (= (remainder n 2) 0))\n\
    \  (define (isOdd n)\n    (= (remainder n 2) 1))\n  (define (sum lst)\n    (foldl\
    \ + 0 lst))\n  (sum (filter isEven (filter isOdd lst))))\n", "  (letrec ([acc\
    \ 0]\n           [ind 0]\n           [loop ([lst (in-list lst)])\n           \
    \  (cond [(empty? lst) acc]\n                   [(zero? (remainder ind 2)) (loop\
    \ (rest lst))]\n                   [(even? (first lst)) (loop (rest lst) (+ acc\
    \ (first lst)))])\n             (set! ind (+ ind 1)))])\n    (loop lst)))\n```\n\
    \n## Task 3\n\n```#lang racket\n", "  (define (iter lst sum)\n    (cond ((null?\
    \ lst) sum)\n          ((even? (car lst)) (+ sum (car lst)))\n          (else\
    \ (iter (cdr lst) sum))))\n  (iter (cdr lst) 0))\n", "  (let loop ([lst lst] [acc\
    \ 0])\n    (if (null? lst)\n        acc\n        (loop (cdr lst)\n           \
    \   (if (odd? (length lst))\n                  (if (even? (car lst))\n       \
    \               (+ acc (car lst))\n                      acc)\n              \
    \    acc)))))\n", "  (cond\n    [(null? lst) 0]\n    [(even? (car lst)) (+ (car\
    \ lst) (add (cdr lst)))]\n    [else (add (cdr lst))]))\n```\n\n### How to implement\
    \ the functions?\n\nImplement the functions one by one.\n\n* First write a function\
    \ signature (a function name with parameters)\n* Then write a docstring with doctest\
    \ comments.\n* Write helper functions (if you need any).\n* Write the main function\
    \ body.\n* Run the tests to verify that your code is working.\n\n*NOTE: Doctest\
    \ comments can contain any characters you want including whitespace as long as\
    \ the test results are indented by 4 spaces.*\n\n### How to run the tests?\n\n\
    * Run the tests using the built-in Check syntax (see the language documentation)\n\
    * Use the DrRacket `Check Syntax` button\n* Use the `raco test` command line tool\n\
    \n### How to get help?\n\n* Don't hesitate to ask questions.\n* You can ask me\
    \ directly or on the class `#help` channel on Slack.\n* You can also look for\
    \ answers online.\n\n### How to evaluate the assignment?\n\n* We will use the\
    \ built-in `Check` syntax to verify that your code is working.\n* You code will\
    \ automatically be checked for correctness when you submit your work on Canvas.\n\
    * **IMPORTANT:** Each of your functions should pass all the tests to get credit\
    \ for the assignment. Make sure to write your tests before you start writing the\
    \ main body of your functions.\n\n### Submission instructions\n\nSubmit your code\
    \ on Canvas before the deadline. Only your highest score will be recorded and\
    \ count towards your grade.\n\n## Grading rubric\n\nThis assignment is worth **10\
    \ points**. The rubric is as follows:\n\n* 3 points: `combine` function\n* 3 points:\
    \ `add` function\n* 2 points: Correctness (your functions pass all the tests)\n\
    * 2 points: Style (proper use of Racket syntax and conventions)", "  (sum (list-of-even-at-odd-indexes\
    \ lst)))\n", "  (cond\n    [(null? lst) 0]\n    [(even? (car lst)) (+ (car lst)\
    \ (add (cdr lst)))]\n    [else (add (cdr lst))]))\n", "  (if (empty? lst)\n  \
    \    0\n      (letrec ([lst (remove-odds lst)]\n               [lst (filter odd?\
    \ lst)])\n        (apply + lst))))\n", "  (foldl + 0\n         (filter even? (map\
    \ car (filter odd? (take-even lst))))))\n", "  (apply + (filter even? (filter\
    \ odd? (range)))))\n\n", "  (cond [(empty? lst) 0]\n        [(even? (first lst))\
    \ (+ (first lst) (add (rest lst)))]\n        [else (add (rest lst))]))\n", " \
    \ (apply + (filter even? (filter-odd lst))))\n", "  (if (empty? lst)\n      0\n\
    \      (if (even? (car lst))\n          (+ (car lst) (add (cdr lst)))\n      \
    \    (add (cdr lst)))))\n```\n\n```racket\n#lang racket\n", "  (define (f i lst)\n\
    \    (cond [(empty? lst) i]\n          [(odd? (car lst)) (f (+ i (car lst)) (cdr\
    \ lst))]\n          [else (f i (cdr lst))]))\n  (f 0 lst))\n", "  (apply + (for/list\
    \ ([e lst] #:when (and (even? e) (odd? (list-ref lst e)))))))\n</code>\n\n<code>#lang\
    \ racket\n", "  (cond\n    [(null? lst) 0]\n    [(and (even? (car lst)) (odd?\
    \ (list-ref lst 0)))\n     (+ (car lst) (add (cdr lst)))]\n    [else (add (cdr\
    \ lst))]))\n```\n\n#2\n```#lang racket\n", "  (define (a lst)\n    (cond\n   \
    \   [(empty? lst) 0]\n      [(even? (first lst)) (add (rest lst))]\n      [else\
    \ (+ (first lst) (add (rest lst)))]))\n  (a (rest lst)))\n", "  (if (null? lst)\n\
    \      0\n      (if (zero? (modulo (car lst) 2))\n          (if (even? (length\
    \ lst))\n              (add (cdr lst))\n              (+ (car lst) (add (cdr lst))))\n\
    \          (add (cdr lst)))))\n", "    (letrec ((even-at-odd-index? (lambda (lst)\
    \ (and (even? (car lst)) (odd? (car (cdr lst))))))\n             (sum-of-even-at-odd-index\
    \ (lambda (lst acc) (if (even-at-odd-index? lst)\n                           \
    \                                  (sum-of-even-at-odd-index (cdr lst) (+ acc\
    \ (car lst)))\n                                                             acc))))\n\
    \      (sum-of-even-at-odd-index lst 0)))\n", "  (apply + (filter even? (filter-map\
    \ (lambda (e) (if (odd? e) e #f)) (range 1 (length lst))))))\n</code>\nHowever,\
    \ I am not convinced that this is the best way to tackle this.\n\n\nA:\n\nThe\
    \ key observation is that an element is the sum of its odd and even parts.\nFor\
    \ instance, <code>7 = 3 + 4</code>. We have an odd index, and the element is even,\
    \ so we take the even part.\n<code>11 = 3 + 8</code>. We have an odd index, and\
    \ the element is odd, so we don't take it.\n<code>-14 = -1 + -15</code>. We have\
    \ an even index, and the element is odd, so we take the odd part.\n<code>0 = 0\
    \ + 0</code>. We have an even index, and the element is even, so we don't take\
    \ it.\nSo we do <code>(modulo x 2)</code> to get the even and odd parts, then\
    \ <code>(if even odd)</code> to filter out the part we want.\nHere is an implementation\
    \ of that strategy:\n<code>(define (add lst)\n  (apply +\n         (filter even?\n\
    \                 (map (lambda (i x)\n                        (if (odd? i)\n \
    \                           (remainder x 2)\n                            (quotient\
    \ x 2)))\n                      (range (length lst))\n                      lst))))\n\
    </code>\nTo test it:\n<code>(define test-cases\n  '((4 2 6 7)\n    (1 2 3 4 5\
    \ 6 7 8 9)\n    (7 15 23 31 39 47 55 63 71 79 87 95 103 111 119 127)\n    (1)\n\
    \    (0)))\n", "  (cond [(empty? lst) (error \"empty list\")]\n        [(= 1 (modulo\
    \ (length lst) 2)) (car lst)]\n        [else (+ (car lst) (add (cddr lst)))]))\n\
    </code>\nThe problem is that if I try to call this function like this:\n<code>(add\
    \ (list 4 2 6 7))\n</code>\nI get an error that the function is undefined. If\
    \ I change the function to <code>(define (add lst)</code> I don't get an error\
    \ but it returns <code>'(4 . 2)</code> instead of the number 2.\nI'm not sure\
    \ if it's a problem with the way the function is defined or the way I'm trying\
    \ to call it.\n\n\nA:\n\nThere are a couple of errors in your code, but the main\
    \ one is that you're using the wrong parentheses to build the list - you're using\
    \ square brackets <code>[...]</code> instead of round parentheses <code>(...)</code>.\
    \ Also, your usage of <code>length</code> is wrong - it's a procedure that takes\
    \ one argument, a list, and returns the length of that list. If you pass it two\
    \ arguments you'll get the same error you've been getting:\n<code>(length lst\
    \ 1)\n</code>\n<blockquote>\n<p>error: expected one argument for length, but received\
    \ 2</p>\n</blockquote>\nHere's a corrected version of your code:\n<code>(define\
    \ (add lst)\n  (cond [(empty? lst) (error \"empty list\")]\n        [(= 1 (modulo\
    \ (length lst) 2)) (car lst)]\n        [else (+ (car lst) (add (cddr lst)))]))\n\
    </code>\nAnd here's a fixed version of your test:\n<code>(add '(4 2 6 7))\n</code>\n\
    <blockquote>\n<p>2</p>\n</blockquote>\n", "  (define (add-helper acc lst)\n  \
    \  (if (null? lst)\n        acc\n        (cond ((or (even? (car lst)) (odd? (length\
    \ lst))) (add-helper (+ acc (car lst)) (cdr lst)))\n              (else (add-helper\
    \ acc (cdr lst))))))\n  (add-helper 0 lst))\n", "  (foldl (\u03BB (x a) (+ a (if\
    \ (and (even? x) (odd? (length a))) x 0))) 0 lst))\n", "  (define (add-evens lst)\n\
    \    (cond ((null? lst) 0)\n          ((or (even? (car lst)) (even? (cadr lst)))\n\
    \           (+ (car lst) (add-evens (cdr lst))))\n          (else (add-evens (cdr\
    \ lst)))))\n  (add-evens lst))\n", "  (cond\n    [(empty? lst) (error \"Empty\
    \ list\")]\n    [(empty? (rest lst)) (first lst)]\n    [(even? (first lst)) (+\
    \ (first lst) (add (rest (rest lst))))]\n    [else (add (rest lst))]))\n", " \
    \ (if (empty? lst)\n      0\n      (if (even? (car lst))\n          (+ (car lst)\
    \ (add (cdr lst)))\n          (add (cdr lst)))))\n", "  (cond\n    [(empty? lst)\
    \ 0]\n    [(even? (first lst)) (+ (first lst) (add (rest lst)))]\n    [else (add\
    \ (rest lst))]))\n", "  (accumulate + 0\n              (for/list ([i (in-list\
    \ lst)\n                          :when (even? i)\n                          :when\
    \ (odd? (index-of i lst))])\n                i)))\n", "  (apply + (filter (lambda\
    \ (e) (= 0 (remainder e 2))) (filter-map (lambda (x) (list-ref lst x)) (range\
    \ 1 (- (length lst) 1) 2)))))\n", "  (cond [(empty? lst) 0]\n        [(zero? (remainder\
    \ (first lst) 2)) (add (rest lst))]\n        [else (+ (first lst) (add (rest lst)))]))\n",
  "  (for/sum ([i (in-range (length lst))]\n            [n (in-list lst)])\n    (if\
    \ (and (even? i) (even? n)) n 0)))\n", "  (if (null? lst)\n      0\n      (add\
    \ (cdr (cdr lst))) + (car (cdr lst))))\n", "  (cond\n    [(empty? lst) 0]\n  \
    \  [(even? (car lst)) (car lst)]\n    [else (+ (car lst) (add (cdr lst)))]))\n",
  "  (let loop ([lst lst] [s 0])\n    (cond\n      [(empty? lst) s]\n      [(even?\
    \ (first lst)) (loop (rest lst) (+ s (first lst)))]\n      [else (loop (rest lst)\
    \ s)])))\n</code>\nSee here: http://ideone.com/cQ0n0J\n", "  (cond\n    [(empty?\
    \ lst) 0]\n    [(even? (first lst)) (+ (first lst) (add (rest lst)))]\n    [else\
    \ (add (rest lst))]))", "  (reduce + 0 (filter even? (filter odd? (range 0 (length\
    \ lst)))))\n)\n```\n\nGiven two lists of the same length, print each index of\
    \ the two lists on a new line\n```#lang racket\n", "  (apply +\n         (for/list\
    \ ([x (in-list lst)])\n           (if (and (even? x) (odd? (list-ref lst (- (list-index\
    \ lst x) 1))))\n               x))))\n", "  (accumulate + 0 (curryr append)\n\
    \              (list (list-ref lst 0))\n              (list (list-ref lst 2))\n\
    \              (list (list-ref lst 4))\n              (list (list-ref lst 6))\n\
    \              (list (list-ref lst 8))\n              (list (list-ref lst 10))\n\
    \              (list (list-ref lst 12))\n              (list (list-ref lst 14))\n\
    \              (list (list-ref lst 16))\n              (list (list-ref lst 18))\n\
    \              (list (list-ref lst 20))\n              (list (list-ref lst 22))\n\
    \              (list (list-ref lst 24))\n              (list (list-ref lst 26))\n\
    \              (list (list-ref lst 28))\n              (list (list-ref lst 30))\n\
    \              (list (list-ref lst 32))\n              (list (list-ref lst 34))\n\
    \              (list (list-ref lst 36))\n              (list (list-ref lst 38))\n\
    \              (list (list-ref lst 40))\n              (list (list-ref lst 42))\n\
    \              (list (list-ref lst 44))\n              (list (list-ref lst 46))\n\
    \              (list (list-ref lst 48))\n              (list (list-ref lst 50))\n\
    \              (list (list-ref lst 52))\n              (list (list-ref lst 54))\n\
    \              (list (list-ref lst 56))\n              (list (list-ref lst 58))\n\
    \              (list (list-ref lst 60))\n              (list (list-ref lst 62))\n\
    \              (list (list-ref lst 64))\n              (list (list-ref lst 66))\n\
    \              (list (list-ref lst 68))\n              (list (list-ref lst 70))\n\
    \              (list (list-ref lst 72))\n              (list (list-ref lst 74))\n\
    \              (list (list-ref lst 76))\n              (list (list-ref lst 78))\n\
    \              (list (list-ref lst 80))\n              (list (list", "  (define\
    \ (iter lst c)\n    (if (empty? lst)\n        0\n        (if (zero? (remainder\
    \ c 2))\n            (+ (car lst) (iter (cdr lst) (+ c 1)))\n            (iter\
    \ (cdr lst) (+ c 1)))))\n  (iter lst 0))\n", "  (local [\n    (define (add-helper\
    \ lst res is-even-index? even-odd-index)\n      (cond\n        [(empty? lst) (if\
    \ (is-even-index? even-odd-index) (list-ref res (- even-odd-index 1)) 0)]\n  \
    \      [(not (is-even-index? even-odd-index)) (add-helper (rest lst) res is-even-index?\
    \ (+ even-odd-index 1))]\n        [(and (even? (first lst)) (is-even-index? even-odd-index))\
    \ (add-helper (rest lst) (list-add res (first lst)) is-even-index? (+ even-odd-index\
    \ 1))]\n        [else (add-helper (rest lst) res is-even-index? (+ even-odd-index\
    \ 1))]))\n    ])\n  (add-helper lst '() even? 0))\n", "  (match lst\n    [($ (?\
    \ even? x) xs ...) (+ x (add xs))]\n    [($ x xs ...) (add xs)]\n    [else 0]))\n",
  "  (accumulate + 0 (filter even? (build-list (length lst) add1)) lst))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
