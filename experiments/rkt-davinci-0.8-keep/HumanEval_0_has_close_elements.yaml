name: HumanEval_0_has_close_elements
language: rkt
prompt: "#lang racket\n\n;; Check if in given list of numbers, are any two numbers\
  \ closer to each other than\n;; given threshold.\n;; >>> has_close_elements([1.0,\
  \ 2.0, 3.0], 0.5)\n;; False\n;; >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0,\
  \ 2.0], 0.3)\n;; True\n(define (has_close_elements numbers threshold)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate has_close_elements))\n\
  \    (check-equal? (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.3) #t)\n    (check-equal?\
  \ (candidate (list 1.0 2.0 3.9 4.0 5.0 2.2) 0.05) #f)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 5.9 4.0 5.0) 0.95) #t)\n    (check-equal? (candidate (list 1.0 2.0\
  \ 5.9 4.0 5.0) 0.8) #f)\n    (check-equal? (candidate (list 1.0 2.0 3.0 4.0 5.0\
  \ 2.0) 0.1) #t)\n    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 1.0) #t)\n\
  \    (check-equal? (candidate (list 1.1 2.2 3.1 4.1 5.1) 0.5) #f)\n))\n\n(test-humaneval)"
completions: ["  (define (helper list1 list2)\n    (cond ((and (null? list1) (null?\
    \ list2)) #f)\n          ((null? list1) (helper list2 list1))\n          ((< (absolute\
    \ (- (car list1) (car list2))) threshold) #t)\n          (else (helper (cdr list1)\
    \ list2))))\n  (helper numbers numbers))\n", "  (let loop ([elements numbers]\n\
    \             [result #f])\n    (if (empty? elements)\n        result\n      \
    \  (let ([elem1 (first elements)]\n              [elem2 (second elements)])\n\
    \          (if (not (empty? elem2))\n              (if (&lt; (- elem1 elem2) threshold)\n\
    \                  (loop (rest elements) #t)\n                  (loop (rest elements)\
    \ result))\n              (loop (rest elements) result))))))\n</code>\nThe function\
    \ is fast enough, because it does not compare all numbers with each other. But\
    \ I feel like I could simplify the whole thing. I am fairly new to Scheme, so\
    \ I am not sure how to do that (and if it is even possible). \nI am trying to\
    \ reduce the number of parameters and local variables, but I don't seem to get\
    \ anywhere. \nIs it possible to make this function simpler? If yes, how?\n\n\n\
    A:\n\nThere is nothing wrong with your solution and it is clear, concise and fast.\n\
    Maybe you can try something a little different as an exercise though, using the\
    \ built-in <code>every</code> procedure:\n<code>(define (has-close-elements numbers\
    \ threshold)\n  (every (lambda (x)\n           (let loop ((xs (cdr numbers))\n\
    \                      (found #f))\n             (if (null? xs)\n            \
    \     (not found)\n                 (if (&lt; (abs (- x (car xs))) threshold)\n\
    \                     (loop (cdr xs) #t)\n                     (loop (cdr xs)\
    \ found)))))\n         numbers))\n</code>\nThe <code>every</code> procedure takes\
    \ a predicate and a list, and applies the predicate to every element in the list.\
    \ The predicate can be anything that returns a boolean, in this case we're using\
    \ a lambda procedure that receives each element in the list and applies a recursive\
    \ <code>loop</code> procedure to the rest of the list.\nIt's basically the same\
    \ logic as your code, but written in a different way, where we're using <code>every</code>\
    \ to iterate the list and the <code>loop</code> procedure to iterate the tail\
    \ of the list. This may not be very efficient - it all depends on how <code",
  "  (if (empty? numbers)\n      false\n      (or (= (sub1 (length numbers)) 0)\n\
    \          (let ([first (first numbers)])\n            (or (has_close_elements\
    \ (rest numbers) threshold)\n                (has_close_element? (rest numbers)\
    \ first threshold))))))\n", "  (let loop ([numbers numbers]\n             [threshold\
    \ threshold])\n    (if (or (null? numbers) (null? (cdr numbers)))\n        #f\n\
    \        (let ([diff (abs (- (car numbers) (cadr numbers)))])\n          (if (>\
    \ diff threshold)\n              (loop (cdr numbers) threshold)\n            \
    \  #t)))))\n", "  (cond ((null? numbers) #f)\n        ((null? (cdr numbers)) #f)\n\
    \        ((&lt; (abs (- (car numbers) (cadr numbers))) threshold) #t)\n      \
    \  (else (has_close_elements (cdr numbers) threshold))))\n", "  (if (null? numbers)\n\
    \      #f\n      (let ((next (cdr numbers)))\n        (if (null? next)\n     \
    \       #f\n            (let ((diff (abs (- (car numbers) (car next)))))\n   \
    \           (if (> diff threshold)\n                  (has_close_elements next\
    \ threshold)\n                  #t))))))\n", "  (cond ((null? numbers) #f)\n \
    \       ((null? (cdr numbers)) #f)\n        ((< (abs (- (car numbers) (cadr numbers)))\
    \ threshold) #t)\n        (else (has_close_elements (cdr numbers) threshold))))\n",
  "  (cond [(empty? numbers) false]\n        [(< (abs (- (first numbers) (second numbers)))\
    \ threshold) true]\n        [else (has_close_elements (rest numbers) threshold)]))\n",
  "  (if (null? numbers)\n      #f\n      (let ((subseq (subseq numbers 1)))\n   \
    \     (if (null? subseq)\n            #f\n            (let ((current (car numbers))\n\
    \                  (subseq (subseq numbers 1)))\n              (or (< (abs (-\
    \ current (car subseq))) threshold)\n                  (has_close_elements subseq\
    \ threshold)))))))\n```\n\n### Task 2\n```racket\n#lang racket\n", "  (for/or\
    \ ([i numbers]\n           [j numbers])\n    (and (not (= i j))\n         (< (abs\
    \ (- i j)) threshold))))\n```\n\n```py\ndef has_close_elements(numbers, threshold):\n\
    \    for i in numbers:\n        for j in numbers:\n            if i == j:\n  \
    \              continue\n            if abs(i - j) < threshold:\n            \
    \    return True\n    return False\n```\n\n```racket\n#lang racket\n", "  (local\
    \ [(define (compare-fn a b)\n            (if (< (abs (- a b)) threshold)\n   \
    \             #t\n                #f))]\n    (for/or ([(i j) (in-nested-list numbers\
    \ numbers)])\n      (compare-fn i j))))\n", "  (letrec ([elements-to-check (build-list\
    \ (length numbers) numbers)]\n           [len (length numbers)]\n           [numbers-length\
    \ (length numbers)]\n           [cur-index 0]\n           [is-closer? (build-list\
    \ len (lambda (i) (threshold>? (list-ref numbers i) threshold)))]\n          \
    \ [prev-number (list-ref numbers 0)]\n           [cur-number 0])\n    (let loop\
    \ ([i 0])\n      (if (or (= i len)\n              (not (or (not (list-ref is-closer?\
    \ i))\n                       (not (= (list-ref is-closer? i) #f)))))\n      \
    \    #f\n          (set! cur-number (list-ref numbers i))\n          (if (< (abs\
    \ (- cur-number prev-number)) threshold)\n              #t\n              (set!\
    \ prev-number cur-number)\n              (loop (+ i 1)))))))\n", "  (let recur\
    \ ((numbers numbers)\n              (length (length numbers)))\n    (if (<= length\
    \ 1)\n        #f\n        (let* ((first (first numbers))\n               (second\
    \ (second numbers))\n               (diff (- first second)))\n          (if (<\
    \ diff threshold)\n              #t\n              (recur (rest numbers) (- length\
    \ 1)))))))\n", "  (define (has_close_elements_iter numbers threshold current_index)\n\
    \    (if (equal? current_index (length numbers))\n        #f\n        (let ([current_number\
    \ (list-ref numbers current_index)])\n          (or (< (abs (- current_number\
    \ (list-ref numbers (- current_index 1)))) threshold)\n              (has_close_elements_iter\
    \ numbers threshold (+ current_index 1))))))\n  (has_close_elements_iter numbers\
    \ threshold 1))\n", "  (or\n   (empty? numbers)\n   (and\n    (not (null? (cdr\
    \ numbers)))\n    (or\n     (< (abs (- (car numbers) (cadr numbers))) threshold)\n\
    \     (has_close_elements (cdr numbers) threshold)))))\n", "  (cond\n    [(empty?\
    \ numbers) #f]\n    [(eq? 1 (length numbers)) #f]\n    [(<= (abs (- (first numbers)\
    \ (second numbers))) threshold) #t]\n    [else (has_close_elements (rest numbers)\
    \ threshold)]))\n", "  (cond\n    [(null? numbers)\n     #f]\n    [(null? (cdr\
    \ numbers))\n     #f]\n    [(< (abs (- (car numbers) (cadr numbers))) threshold)\n\
    \     #t]\n    [else\n     (has_close_elements (cdr numbers) threshold)]))\n",
  "  (cond\n    [(empty? numbers) #f]\n    [(has_close_elements (rest numbers) threshold)\
    \ #t]\n    [(< (abs (- (first numbers) (first (rest numbers)))) threshold) #t]\n\
    \    [else #f]))\n", "  (for/or ([cur numbers] [next (in-list (cdr numbers))])\n\
    \    (<= (abs (- cur next)) threshold)))\n", "  (if (null? numbers)\n      #f\n\
    \      (or (< (abs (- (car numbers) (cadr numbers))) threshold)\n          (has_close_elements\
    \ (cdr numbers) threshold))))\n", "  (define result #f)\n  (define (helper ns)\n\
    \    (cond [(empty? ns) (set! result #f)]\n          [(empty? (rest ns)) (set!\
    \ result #f)]\n          [(< (abs (- (first ns) (first (rest ns)))) threshold)\
    \ (set! result #t)]\n          [else (helper (rest ns))]))\n  (helper numbers)\n\
    \  result)", "  (cond ((null? numbers) #f)\n        ((null? (cdr numbers)) #f)\n\
    \        ((< (abs (- (car numbers) (cadr numbers))) threshold) #t)\n        (else\
    \ (has_close_elements (cdr numbers) threshold))))\n", "  (define (check list threshold)\n\
    \    (cond ((null? list) #f)\n          ((< (abs (- (car list) (cadr list))) threshold)\
    \ #t)\n          (else (check (cdr list) threshold))))\n  (check (sort numbers\
    \ <) threshold))\n", "  (cond\n    [(null? numbers) #f]\n    [(null? (cdr numbers))\
    \ #f]\n    [(< (- (car numbers) (cadr numbers)) threshold) #t]\n    [else (has_close_elements\
    \ (cdr numbers) threshold)]))\n", "  (define (helper n1 n2)\n    (if (< n2 (length\
    \ numbers))\n        (if (< (abs (- (list-ref numbers n1) (list-ref numbers n2)))\
    \ threshold)\n            #t\n            (helper n1 (+ n2 1)))\n        #f))\n\
    \  (define (inner lst)\n    (if (null? lst)\n        #f\n        (let ((first\
    \ (car lst)))\n          (if (helper first (+ (list-index first numbers) 1))\n\
    \              #t\n              (inner (cdr lst))))))\n  (inner numbers))\n",
  "  (if (null? numbers)\n      #f\n      (let ([n (car numbers)])\n        (or\n\
    \         (filter (lambda (x) (&lt; (abs (- x n)) threshold)) (cdr numbers))\n\
    \         (has_close_elements (cdr numbers) threshold)))))\n", "  (define (check-numbers\
    \ numbers)\n    (cond\n      [(empty? numbers) #f]\n      [(cons? numbers) (member\
    \ (first numbers) (rest numbers))]))\n  (cond\n    [(empty? numbers) #f]\n   \
    \ [(cons? numbers) (check-numbers (map (lambda (x) (/ x threshold)) numbers))]))\n",
  "  (if (null? numbers)\n      #f\n      (or (< (abs (- (car numbers) (cadr numbers)))\
    \ threshold)\n          (has_close_elements (cdr numbers) threshold))))\n", " \
    \ (let ([numbers (sort numbers <)])\n    (let loop ([numbers (cdr numbers)])\n\
    \      (if (null? numbers)\n          #f\n          (or (= (abs (- (car numbers)\
    \ (cadr numbers))) threshold)\n              (loop (cdr numbers)))))))\n", " \
    \ (define (aux lst acc)\n    (if (null? lst)\n        acc\n        (if (any_close\
    \ (car lst) (cdr lst) threshold)\n            #t\n            (aux (cdr lst) acc))))\n\
    \  (aux numbers #f))\n", "  (if (null? numbers)\n      #f\n      (or (< (abs (-\
    \ (car numbers) (cadr numbers))) threshold)\n          (has_close_elements (cdr\
    \ numbers) threshold))))\n", "  (cond\n    [(null? numbers) #f]\n    [(null? (cdr\
    \ numbers)) #f]\n    [(< (abs (- (car numbers) (cadr numbers))) threshold) #t]\n\
    \    [else (has_close_elements (cdr numbers) threshold)]))\n", "  (let ([numbers-length\
    \ (length numbers)])\n    (define (loop i)\n      (cond\n        [(>= i numbers-length)\
    \ #f]\n        [(<= (abs (- (list-ref numbers i) (list-ref numbers (+ i 1))))\
    \ threshold) #t]\n        [else (loop (+ i 1))]))\n    (loop 0)))\n", "  (cond\
    \ ((null? numbers) #f)\n        ((null? (cdr numbers)) #f)\n        ((< (abs (-\
    \ (car numbers) (cadr numbers))) threshold) #t)\n        (else (has_close_elements\
    \ (cdr numbers) threshold))))\n", "  (if (null? numbers)\n      #f\n      (let*\
    \ ((first (car numbers))\n             (remaining (cdr numbers))\n           \
    \  (others (filter (lambda (x) (< (abs (- x first)) threshold)) remaining)))\n\
    \        (if (null? others)\n            (has_close_elements remaining threshold)\n\
    \            #t))))\n", "  (cond\n    [(empty? numbers) #f]\n    [(empty? (rest\
    \ numbers)) #f]\n    [(< (abs (- (first numbers) (second numbers))) threshold)\
    \ #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n", "  (let\
    \ loop ([rest numbers]\n             [previous-number 0.0])\n    (if (null? rest)\n\
    \        #f\n        (let ([current-number (car rest)])\n          (if (&lt; (-\
    \ current-number previous-number) threshold)\n              #t\n             \
    \ (loop (cdr rest) current-number))))))\n</code>\n", "  (define (dist-to-next\
    \ [list] [current-elem] [next-elem])\n    (if (or (null? list) (null? current-elem)\
    \ (null? next-elem))\n        threshold\n        (min (abs (- current-elem next-elem))\
    \ (dist-to-next (cdr list) next-elem (car list)))))\n  (if (or (null? numbers)\
    \ (null? (cdr numbers)))\n      #f\n      (if (> (dist-to-next numbers (car numbers)\
    \ (cadr numbers)) threshold)\n          (has_close_elements (cdr numbers) threshold)\n\
    \          #t)))\n", "  (cond\n    [(empty? numbers) #f]\n    [(< (abs (- (first\
    \ numbers) (second numbers))) threshold) #t]\n    [else (has_close_elements (rest\
    \ numbers) threshold)]))\n", "  (for/or ([i (in-range (length numbers))]\n   \
    \        [j (in-range (add1 i) (length numbers))])\n    (< (abs (- (list-ref numbers\
    \ i) (list-ref numbers j))) threshold)))\n", "  (let loop ([numbers numbers]\n\
    \             [threshold threshold])\n    (cond\n      [(null? numbers) false]\n\
    \      [(null? (cdr numbers)) false]\n      [(< (abs (- (car numbers) (cadr numbers)))\
    \ threshold) true]\n      [else (loop (cdr numbers) threshold)])))\n", "  (define\
    \ min-difference-so-far 1000)\n  (define (check-difference n1 n2)\n    (define\
    \ diff (abs (- n1 n2)))\n    (if (< diff threshold)\n        #t\n        (if (<\
    \ diff min-difference-so-far)\n            (begin\n              (set! min-difference-so-far\
    \ diff)\n              #f))))\n  (filter check-difference numbers))", "  (if (or\
    \ (null? numbers) (null? (cdr numbers)))\n      #f\n      (or (< (- (car numbers)\
    \ (car (cdr numbers))) threshold)\n          (has_close_elements (cdr numbers)\
    \ threshold))))\n", "  (cond\n    [(empty? numbers) false]\n    [(empty? (rest\
    \ numbers)) false]\n    [else\n     (let ([next-numbers (rest numbers)])\n   \
    \    (cond\n         [(<= (abs (- (first numbers) (first next-numbers))) threshold)\
    \ true]\n         [else (has_close_elements next-numbers threshold)]))]))\n",
  "  (cond\n    [(or (null? numbers)\n         (null? (cdr numbers)))\n     #f]\n\
    \    [(< (abs (- (car numbers) (cadr numbers))) threshold)\n     #t]\n    [else\n\
    \     (has_close_elements (cdr numbers) threshold)]))\n", "  (let loop ([numbers\
    \ numbers]\n             [rest-numbers (cdr numbers)])\n    (or (and (pair? numbers)\n\
    \             (< (abs (- (car numbers) (car rest-numbers))) threshold))\n    \
    \    (and (pair? rest-numbers)\n             (loop rest-numbers (cdr rest-numbers))))))\n",
  "  (if (empty? numbers)\n      #f\n      (let ([first (first numbers)]\n       \
    \     [rest (rest numbers)])\n        (if (any (lambda (e) (< (abs (- e first))\
    \ threshold)) rest)\n            #t\n            (has_close_elements rest threshold)))))\n",
  "  (not (null? (filter (lambda (elem) (and (< (- elem (car numbers)) threshold)\n\
    \                                          (< (- (car numbers) elem) threshold)))\n\
    \                       (cdr numbers)))))\n", "  (define (aux numbers index result\
    \ threshold)\n    (if (= index (length numbers))\n        result\n        (if\
    \ (< (- (list-ref numbers index) (list-ref numbers (- index 1))) threshold)\n\
    \            (aux numbers (+ index 1) #t threshold)\n            (aux numbers\
    \ (+ index 1) result threshold))))\n  (aux numbers 1 #f threshold))\n", "  (cond\n\
    \    [(empty? numbers) false]\n    [(null? (cdr numbers)) false]\n    [(< (abs\
    \ (- (car numbers) (cadr numbers))) threshold) true]\n    [else (has_close_elements\
    \ (cdr numbers) threshold)]))\n```\n\n```#lang racket\n", "  (cond\n    [(empty?\
    \ numbers)\n     false]\n    [(or\n      (empty? (rest numbers))\n      (empty?\
    \ (rest (rest numbers))))\n     false]\n    [else\n     (let\n         ([x (first\
    \ numbers)]\n          [y (first (rest numbers))])\n       (or\n         (> (abs\
    \ (- x y)) threshold)\n         (has_close_elements (rest numbers) threshold)))]))\n",
  "  (for/or ([num numbers] [other (in-list numbers)]\n           #:when (and (not\
    \ (= num other))\n                       (< (abs (- num other)) threshold)))\n\
    \    #t))\n", "  (local [(define (closer-than-threshold? n1 n2)\n            (<\
    \ (abs (- n1 n2)) threshold))]\n    (let loop ([numbers numbers])\n      (cond\
    \ [(empty? numbers) false]\n            [(and (pair? (cdr numbers))\n        \
    \          (closer-than-threshold? (car numbers) (cadr numbers)))\n          \
    \   true]\n            [else (loop (cdr numbers))]))))\n", "  (letrec ([check-diffs\
    \ (lambda (ds)\n                          (cond\n                            [(null?\
    \ ds) #f]\n                            [(< (car ds) threshold) #t]\n         \
    \                   [else (check-diffs (cdr ds))]))])\n    (check-diffs (map (lambda\
    \ (x y) (- x y)) numbers (cdr numbers)))))\n```\n\n```python\ndef has_close_elements(numbers,\
    \ threshold):\n    def check_diffs(ds):\n        if not ds:\n            return\
    \ False\n        elif ds[0] < threshold:\n            return True\n        else:\n\
    \            return check_diffs(ds[1:])\n    return check_diffs(map(lambda x,\
    \ y: x - y, numbers, numbers[1:]))\n```\n\n### 2.5.5 List permutations\n\n```racket\n\
    #lang racket\n", "  (not (null? (filter (\u03BB (elem)\n                     \
    \ (let ([closer-elements (filter (\u03BB (x) (< (abs (- elem x)) threshold)) numbers)])\n\
    \                        (not (null? closer-elements))))\n                   \
    \  numbers))))\n", "  (define (aux [first-number : (Listof Number)] [next-number\
    \ : Number] [rest-numbers : (Listof Number)])\n    (cond\n      [(empty? rest-numbers)\n\
    \       false]\n      [(< (abs (- first-number next-number)) threshold)\n    \
    \   true]\n      [else\n       (aux (cons first-number (cons next-number (cons\
    \ rest-numbers '())))\n            (first rest-numbers)\n            (rest rest-numbers))]))\n\
    \  (aux (list (first numbers))\n       (second numbers)\n       (rest (rest numbers))))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? numbers) false]\n  \
    \  [(empty? (rest numbers)) false]\n    [else\n     (or\n      (< (abs (- (first\
    \ numbers) (second numbers))) threshold)\n      (has_close_elements (rest numbers)\
    \ threshold))]))\n", "  (letrec ([rec (lambda (current_number rest_of_list)\n\
    \                  (if (null? rest_of_list)\n                      #f\n      \
    \                (if (&lt; (abs (- current_number (car rest_of_list))) threshold)\n\
    \                          #t\n                          (rec (car rest_of_list)\
    \ (cdr rest_of_list)))))])\n    (rec (car numbers) (cdr numbers))))\n", "  (not\
    \ (null? (filter (lambda (x) (list-index-of (list-ref numbers (add1 x))\n    \
    \                                             numbers)\n                     \
    \        (lambda (n) (not (= (sub1 n) x))))\n                       (iota (sub1\
    \ (length numbers)))))))\n```\n\n```racket\n#lang racket\n", "  (define (helper\
    \ nums prev)\n    (cond\n      [(empty? nums) #f]\n      [(< (abs (- (first nums)\
    \ prev)) threshold) #t]\n      [else (helper (rest nums) (first nums))]))\n  (helper\
    \ (rest numbers) (first numbers)))\n```\n\n### Exercise 20.4.4\n\n```scheme\n\
    #lang racket\n", "  (for/or ([number (in-list numbers)]\n           [number2 (in-list\
    \ numbers)])\n    (and (not (= number number2))\n         (< (abs (- number number2))\
    \ threshold))))\n", "  (define (has_close_elements_recur numbers threshold)\n\
    \    (cond\n      [(empty? numbers) false]\n      [(or (empty? (rest numbers))\n\
    \           (empty? (rest (rest numbers)))) false]\n      [(< (abs (- (first numbers)\
    \ (second numbers))) threshold) true]\n      [else (has_close_elements_recur (rest\
    \ numbers) threshold)]))\n  (has_close_elements_recur (sort numbers <=) threshold))\n",
  "  (for/or ([n1 numbers]\n           [n2 (cdr numbers)])\n    (< (abs (- n1 n2))\
    \ threshold)))\n", "  (if (null? numbers)\n      #f\n      (let* ([first (car\
    \ numbers)]\n             [rest (cdr numbers)]\n             [closer (has_closer_elements\
    \ rest threshold first)])\n        (if closer\n            #t\n            (has_close_elements\
    \ rest threshold)))))\n", "  (define (is_close n1 n2) (< (abs (- n1 n2)) threshold))\n\
    \  (define (loop lst)\n    (if (null? lst)\n        #f\n        (if (is_close\
    \ (car lst) (cadr lst))\n            #t\n            (loop (cdr lst)))))\n  (loop\
    \ numbers))\n```\n\n## Arrays\n\nArrays can be created with `make-array` function.\
    \ It takes two parameters `make-array`: dimensions and initial value.\n\n```Racket\n\
    #lang racket\n", "  (for/or ([first-number numbers]\n           [second-number\
    \ (rest numbers)])\n    (< (abs (- first-number second-number)) threshold)))\n",
  "  (let ([result #f])\n    (for ((n1 numbers)\n          (n2 (cdr numbers)))\n \
    \     (unless result\n        (when (< (abs (- n1 n2)) threshold)\n          (set!\
    \ result #t))))\n    result))\n", "  (let loop ([i 0] [j 1])\n    (if (= j (length\
    \ numbers))\n        #f\n        (if (< (- (list-ref numbers i) (list-ref numbers\
    \ j)) threshold)\n            #t\n            (loop (+ i 1) (+ j 1))))))\n", " \
    \ (define (go nums prev threshold)\n    (cond [(null? nums) false]\n         \
    \ [(< (abs (- (car nums) prev)) threshold) true]\n          [else (go (cdr nums)\
    \ (car nums) threshold)]))\n  (go (cdr numbers) (car numbers) threshold))\n",
  "  (let loop ([numbers numbers]\n             [prev-number (car numbers)])\n   \
    \ (cond\n      [(empty? numbers) false]\n      [(< (abs (- (car numbers) prev-number))\
    \ threshold) true]\n      [else (loop (cdr numbers) (car numbers))])))\n", " \
    \ (define (helper numbers threshold)\n    (if (null? numbers)\n        #f\n  \
    \      (let* ([n (car numbers)]\n               [others (cdr numbers)]\n     \
    \          [result (map (lambda (other)\n                              (if (&lt;\
    \ (abs (- n other)) threshold)\n                                  #t\n       \
    \                           #f))\n                            others)])\n    \
    \      (if (member #t result)\n              #t\n              (helper others\
    \ threshold)))))\n  (helper numbers threshold))\n", "  (cond\n    [(empty? numbers)\n\
    \     #f]\n    [(< (cadr numbers) (+ (car numbers) threshold))\n     #t]\n   \
    \ [else\n     (has_close_elements (cdr numbers) threshold)]))\n", "  (cond\n \
    \   [(empty? numbers) false]\n    [(empty? (rest numbers)) false]\n    [else\n\
    \     (or\n      (define (closer-than? a b)\n        (and (<= (- b a) threshold)\n\
    \             (<= (- a b) threshold)))\n      (or (closer-than? (first numbers)\
    \ (second numbers))\n          (has_close_elements (rest numbers) threshold)))]))\n",
  "  (cond\n    [(empty? numbers) #f]\n    [(< threshold (abs (- (first numbers) (second\
    \ numbers)))) #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n",
  "  (for/or ([i (in-range (length numbers))]\n           [j (in-range (add1 i) (length\
    \ numbers))])\n    (< (abs (- (list-ref numbers i) (list-ref numbers j))) threshold)))\n",
  "  (local [(define (has-close-elements? xs result)\n            (cond [(null? xs)\
    \ result]\n                  [(abs (- (car xs) (cadr xs))) &lt; threshold]\n \
    \                 [else (has-close-elements? (cdr xs) (or result #f))]))]\n  \
    \  (has-close-elements? numbers #f)))\n</code>\nAny feedback is welcome!\n\n\n\
    A:\n\nI'm not familiar with Racket, but I'll give this a shot.\n<code>(define\
    \ (has_close_elements numbers threshold)\n  (local [(define (has-close-elements?\
    \ xs result)\n            (cond [(null? xs) result]\n                  [(abs (-\
    \ (car xs) (cadr xs))) &lt; threshold]\n                  [else (has-close-elements?\
    \ (cdr xs) (or result #f))]))]\n    (has-close-elements? numbers #f)))\n</code>\n\
    I would recommend the following:\n\nFunction names should be all lowercase.\n\
    Parens should be used for grouping, not for line breaks.\nInstead of <code>(has-close-elements?\
    \ numbers #f)</code>, use <code>(has-close-elements? numbers)</code>.\nI would\
    \ avoid the <code>local</code> construct. Either put all the code in a new function,\
    \ or move the function definition to the top level.\nI would use a <code>while</code>\
    \ loop instead of a <code>cond</code> to iterate through the list.\n\nHere's what\
    \ the code looks like with these suggestions applied:\n<code>(define (has-close-elements\
    \ numbers threshold)\n  (define (has-close-elements? xs)\n    (let ((result #f))\n\
    \      (while (and (not result) (pair? xs))\n        (if (&lt; (abs (- (car xs)\
    \ (cadr xs))) threshold)\n            (set! result #t))\n        (set! xs (cdr\
    \ xs)))\n      result))\n  (has-close-elements? numbers))\n</code>\n", "  (cond\
    \ ((null? numbers) false)\n        ((null? (cdr numbers)) false)\n        ((<\
    \ (abs (- (car numbers) (cadr numbers))) threshold) true)\n        (else (has_close_elements\
    \ (cdr numbers) threshold))))\n", "  (cond\n    [(empty? numbers) #f]\n    [(empty?\
    \ (rest numbers)) #f]\n    [(< (abs (- (first numbers) (second numbers))) threshold)\
    \ #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n", "  (let\
    \ loop ([numbers numbers]\n             [threshold threshold])\n    (if (null?\
    \ numbers)\n        #f\n        (or (abs (- (car numbers) (cadr numbers)) threshold)\n\
    \            (loop (cdr numbers) threshold)))))\n", "  (let loop ([numbers numbers]\n\
    \             [prev-num 0])\n    (if (empty? numbers)\n        #f\n        (let\
    \ ([diff (abs (- (first numbers) prev-num))])\n          (if (&lt; diff threshold)\n\
    \              #t\n              (loop (rest numbers) (first numbers)))))))\n",
  "  (define (dist a b)\n    (if (> a b) (- a b) (- b a)))\n  (for/or ([x (in-list\
    \ numbers)]\n           [y (in-list numbers)])\n    (and (not (= x y))\n     \
    \    (< (dist x y) threshold))))\n", "  (cond\n    [(empty? numbers) false]\n\
    \    [(< (abs (- (first numbers) (first (rest numbers)))) threshold) true]\n \
    \   [else (has_close_elements (rest numbers) threshold)]))\n", "  (define (inner-check\
    \ lst)\n    (if (null? lst)\n        #f\n        (if (or (> (abs (- (car lst)\
    \ (cadr lst))) threshold)\n                (> (abs (- (car lst) (caddr lst)))\
    \ threshold))\n            #t\n            (inner-check (cdr lst)))))\n  (inner-check\
    \ numbers))\n\n", "  (andmap\n   (lambda (m)\n     (andmap\n      (lambda (n)\n\
    \        (if (and (not (equal? m n))\n                 (or (and (negative? (-\
    \ m n))\n                          (<= (- m n) threshold))\n                 \
    \    (and (positive? (- m n))\n                          (>= (- m n) threshold))))\n\
    \            #t\n            #f))\n      numbers))\n   numbers))\n", "  (for/or\
    \ ([num1 numbers]\n           [num2 (in-list numbers)])\n    (and (eq? num1 num2)\n\
    \         (&lt; (abs (- num1 num2)) threshold))))\n", "  (cond\n    [(null? numbers)\
    \ #f]\n    [(< (abs (- (car numbers) (cadr numbers))) threshold) #t]\n    [else\
    \ (has_close_elements (cdr numbers) threshold)]))\n", "  (define (is_closer? n1\
    \ n2)\n    (< (abs (- n1 n2)) threshold))\n  (define (loop [remaining (rest numbers)]\n\
    \               [previous (first numbers)])\n    (cond [(empty? remaining) #f]\n\
    \          [(is_closer? previous (first remaining)) #t]\n          [else (loop\
    \ (rest remaining) (first remaining))]))\n  (loop (rest numbers) (first numbers)))\n",
  "  (if (empty? numbers)\n      #f\n      (let ((first (first numbers))\n       \
    \     (rest (rest numbers)))\n        (if (empty? rest)\n            #f\n    \
    \        (if (< (abs (- first (first rest))) threshold)\n                #t\n\
    \                (has_close_elements rest threshold))))))\n", "  (define (check-pair\
    \ remaining current accumulator)\n    (if (null? remaining)\n        accumulator\n\
    \        (let ((diff (abs (- (car remaining) current))))\n          (if (> diff\
    \ threshold)\n              (check-pair (cdr remaining) (car remaining) accumulator)\n\
    \              (check-pair (cdr remaining) (car remaining) #t)))))\n  (check-pair\
    \ (cdr numbers) (car numbers) #f))\n```\n\n```racket\n#lang racket\n", "  (cond\
    \ [(empty? numbers) false]\n        [(empty? (rest numbers)) false]\n        [else\n\
    \         (let* ([first (first numbers)]\n                [second (first (rest\
    \ numbers))]\n                [distance (abs (- first second))])\n           (if\
    \ (< distance threshold)\n               true\n               (has_close_elements\
    \ (rest numbers) threshold)))]))\n", "  (cond\n    [(empty? numbers)\n     #f]\n\
    \    [(< (abs (- (first numbers) (second numbers))) threshold)\n     #t]\n   \
    \ [else\n     (has_close_elements (rest numbers) threshold)]))\n", "  (let loop\
    \ ([numbers numbers]\n             [threshold threshold])\n    (if (null? numbers)\n\
    \        #f\n        (if (or (and (not (null? (cdr numbers)))\n              \
    \       (not (>= (- (car numbers) (cadr numbers)) threshold)))\n             \
    \   (and (not (null? (cddr numbers)))\n                     (not (>= (- (car numbers)\
    \ (caddr numbers)) threshold))))\n            #t\n            (loop (cdr numbers)\
    \ threshold)))))\n", "  (let ([closer-than-threshold?\n         (lambda (x y)\n\
    \           (< (- x y) threshold))])\n    (or (map closer-than-threshold? (cdr\
    \ numbers) numbers)\n        (map closer-than-threshold? numbers (cdr numbers)))))\n",
  "  (let f ([lst numbers])\n    (cond [(empty? lst) false]\n          [(empty? (rest\
    \ lst)) false]\n          [(< (abs (- (first lst) (first (rest lst)))) threshold)\
    \ true]\n          [else (f (rest lst))])))\n", "  (let ([length (length numbers)])\n\
    \    (for/or ([i (in-range length)]\n             [j (in-range (+ i 1) length)])\n\
    \      (< (abs (- (list-ref numbers i) (list-ref numbers j))) threshold))))\n\n",
  "  (foldl (lambda (x y)\n           (cond\n             [(empty? y) #f]\n      \
    \       [(<= (abs (- x (first y))) threshold) #t]\n             [else #f]))\n\
    \         '() numbers))\n", "  (cond [(empty? numbers) false]\n        [(= (length\
    \ numbers) 1) false]\n        [else\n         (let ([first-n (first numbers)]\n\
    \               [second-n (second numbers)])\n           (if (< (abs (- first-n\
    \ second-n)) threshold)\n               true\n               (has_close_elements\
    \ (rest numbers) threshold)))]))\n", "  (not (null? (filter (\u03BB (x) (< (abs\
    \ (- (car x) (cadr x))) threshold)) (map list numbers (rest numbers))))))\n",
  "  (define (has_close-elements-aux result lst)\n    (cond ((null? lst) result)\n\
    \          ((/= result true)\n           (has_close-elements-aux (is-close? (car\
    \ lst) (cadr lst) threshold) (cdr lst)))\n          (else true)))\n  (has_close-elements-aux\
    \ false numbers))\n", "  (let loop ([numbers numbers]\n             [has-close-elements\
    \ #f])\n    (cond [(empty? numbers) has-close-elements]\n          [(<= (abs (-\
    \ (first numbers) (second numbers))) threshold)\n           (loop (rest numbers)\
    \ #t)]\n          [else (loop (rest numbers) has-close-elements)])))\n", "  (define\
    \ (aux numbers threshold)\n    (let* ([x (car numbers)]\n           [y (cadr numbers)])\n\
    \      (if (null? y)\n          #f\n          (if (< (abs (- x y)) threshold)\n\
    \              #t\n              (aux (cdr numbers) threshold)))))\n  (aux numbers\
    \ threshold))\n", "  (let ([n (length numbers)])\n    (for/or ([i (in-range n)]\n\
    \             [j (in-range n)])\n      (>= (abs (- (list-ref numbers i) (list-ref\
    \ numbers j))) threshold))))\n", "  (let helper ([lst (cdr numbers)] [prev (car\
    \ numbers)])\n    (if (null? lst)\n        #f\n        (if (< (abs (- (car lst)\
    \ prev)) threshold)\n            #t\n            (helper (cdr lst) (car lst))))))\n\
    ```\n\n```racket\n#lang racket\n", "  (define (are_close x y)\n    (< (abs (-\
    \ x y)) threshold))\n  (let loop ([i 0] [is-close #f])\n    (cond [(= i (sub1\
    \ (length numbers))) is-close]\n          [(are_close (list-ref numbers i) (list-ref\
    \ numbers (add1 i))) #t]\n          [else (loop (add1 i) is-close)])))\n", " \
    \ (if (null? numbers)\n      #f\n      (let* ([distance (find_smallest_difference\
    \ (cdr numbers))]\n             [smallest-distance (car distance)]\n         \
    \    [smallest-index (cdr distance)])\n        (if (< smallest-distance threshold)\n\
    \            #t\n            (has_close_elements (cons (list-ref numbers smallest-index)\n\
    \                                      (remove-item (cdr numbers) smallest-index))\n\
    \                                threshold)))))\n", "  (let loop ([numbers numbers]\n\
    \             [threshold threshold])\n    (cond [(empty? numbers) #f]\n      \
    \    [(= (count (first numbers) numbers) 1) (loop (rest numbers) threshold)]\n\
    \          [(< (first numbers) threshold) #t]\n          [else (loop (rest numbers)\
    \ threshold)])))\n", "  (let loop ([pos 0] [len (length numbers)])\n    (cond\n\
    \      [(>= pos (- len 2)) #f]\n      [(>= (abs (- (list-ref numbers pos) (list-ref\
    \ numbers (+ pos 1)))) threshold) #t]\n      [else (loop (+ pos 1) len)])))\n\
    ```\n\n```racket\n#lang racket\n", "  (let loop ([numbers numbers]\n         \
    \    [threshold threshold])\n    (cond\n      [(null? numbers) #f]\n      [(<\
    \ (abs (- (car numbers) (cadr numbers))) threshold) #t]\n      [else (loop (cdr\
    \ numbers) threshold)])))\n", "  (for/or ([x (in-list numbers)]\n           [y\
    \ (in-list numbers)])\n    (and (not (= x y))\n         (< (abs (- x y)) threshold))))\n",
  "  (define (has_close_elements? numbers)\n    (cond\n      [(empty? numbers) false]\n\
    \      [(has_close_elements? (rest numbers))]\n      [(< (- (first numbers) (second\
    \ numbers)) threshold) true]\n      [else (has_close_elements? (rest numbers))]))\n\
    \  (has_close_elements? numbers))\n", "  (cond\n    ((null? numbers) #f)\n   \
    \ ((or (or (and (&lt; (abs (- (car numbers) (cadr numbers))) threshold) #t)\n\
    \              (and (&lt; (abs (- (car numbers) (caddr numbers))) threshold) #t))\n\
    \         (has_close_elements (cdr numbers) threshold)) #t)\n    (else #f)))\n",
  "  (if (null? numbers)\n      #f\n      (if (has_close_element_next? numbers threshold)\n\
    \          #t\n          (has_close_elements (cdr numbers) threshold))))\n", " \
    \ (define (helper numbers result-so-far)\n    (cond\n      [(empty? numbers) result-so-far]\n\
    \      [(or (empty? (rest numbers)) (and (empty? (rest (rest numbers)))) #f) result-so-far]\n\
    \      [(closer? (first numbers) (second numbers) threshold) (helper (rest numbers)\
    \ #t)]\n      [else (helper (rest numbers) result-so-far)]))\n  (helper numbers\
    \ #f))\n", "  (let loop ([numbers numbers]\n             [result #f])\n    (cond\n\
    \      [(null? numbers) result]\n      [(< (abs (- (car numbers) (cadr numbers)))\
    \ threshold) #t]\n      [else (loop (cdr numbers) result)])))\n", "  (cond\n \
    \   [(null? numbers) #f]\n    [(null? (cdr numbers)) #f]\n    [(<= (abs (- (car\
    \ numbers) (cadr numbers))) threshold) #t]\n    [else (has_close_elements (cdr\
    \ numbers) threshold)]))\n```\n\n```racket\n#lang racket\n", "  (let loop ([numbers\
    \ numbers]\n             [threshold threshold])\n    (cond\n      [(null? numbers)\
    \ #f]\n      [(<= (abs (- (car numbers) (cadr numbers))) threshold) #t]\n    \
    \  [else (loop (cdr numbers) threshold)])))\n", "  (let loop ([elements numbers]\n\
    \             [exceptions empty])\n    (if (empty? elements)\n        #f\n   \
    \     (if (null? (filter (\u03BB (x) (< (abs (- (first elements) x)) threshold))\n\
    \                           (rest elements)))\n            (loop (rest elements)\
    \ (cons (first elements) exceptions))\n            #t))))\n", "  (let loop ([a\
    \ (first numbers)]\n             [rest (rest numbers)])\n    (if (empty? rest)\n\
    \        #f\n        (if (>= (abs (- a (first rest))) threshold)\n           \
    \ (loop (first rest) (rest rest))\n            #t))))\n", "  (if (null? numbers)\n\
    \      #f\n      (let ([distance (- (car numbers) (car (cdr numbers)))])\n   \
    \     (if (< distance threshold)\n            #t\n            (has_close_elements\
    \ (cdr numbers) threshold)))))\n", "  (let loop ([numbers numbers]\n         \
    \    [acc false])\n    (if (empty? numbers)\n        acc\n        (let* ([element\
    \ (first numbers)]\n               [rest (rest numbers)])\n          (if (any\
    \ (\u03BB (x) (< (abs (- element x)) threshold)) rest)\n              (loop rest\
    \ true)\n              (loop rest acc))))))\n", "  (for/or ([x numbers]\n    \
    \       [y (in-list numbers)]\n           #:when (< (abs (- x y)) threshold))\n\
    \    #t))", "  (cond ((null? numbers) #f)\n        ((= (rest numbers) '()) #f)\n\
    \        ((< (abs (- (first numbers) (second numbers))) threshold) #t)\n     \
    \   (else (has_close_elements (rest numbers) threshold))))\n", "  (for/or ([number1\
    \ numbers]\n           [number2 numbers])\n    (and (not (= number1 number2))\n\
    \         (<= (abs (- number1 number2)) threshold))))\n", "  (let loop ([numbers\
    \ numbers]\n             [result #f])\n    (if (null? numbers)\n        result\n\
    \        (if (null? (cdr numbers))\n            result\n            (let ([diff\
    \ (abs (- (car numbers) (car (cdr numbers))))])\n              (if (< diff threshold)\n\
    \                  (loop (cdr numbers) #t)\n                  (loop (cdr numbers)\
    \ result)))))))\n", "  (if (empty? numbers)\n      #f\n      (cond ((empty? (rest\
    \ numbers)) #f)\n            ((<= (abs (- (first numbers) (second numbers))) threshold)\
    \ #t)\n            (else (has_close_elements (rest numbers) threshold)))))\n",
  "  (if (null? numbers)\n      #f\n      (let ([first (car numbers)]\n          \
    \  [rest (cdr numbers)])\n        (if (has_close_element first rest threshold)\n\
    \            #t\n            (has_close_elements rest threshold)))))\n", "  (match\
    \ numbers\n    ((list) #f)\n    ((list number remaining)\n     (let ((others (has_close_elements\
    \ remaining threshold)))\n       (or (less? (abs (- number (first remaining)))\
    \ threshold)\n           others)))))\n", "  (define (helper num1 rest)\n    (cond\
    \ ((null? rest) false)\n          ((< (abs (- num1 (car rest))) threshold) true)\n\
    \          (else (helper num1 (cdr rest)))))\n  (cond ((null? numbers) false)\n\
    \        (else (or (helper (car numbers) (cdr numbers))\n                  (has_close_elements\
    \ (cdr numbers) threshold)))))\n", "  (define (aux lst)\n    (if (null? lst)\n\
    \        #f\n        (let ([x (car lst)]\n              [xs (cdr lst)])\n    \
    \      (cond\n            [(= xs '()) #f]\n            [(< (abs (- x (car xs)))\
    \ threshold) #t]\n            [else (aux xs)]))))\n  (aux numbers))\n", "  (cond\n\
    \    [(empty? numbers) #f]\n    [(< (abs (- (first numbers) (second numbers)))\
    \ threshold) #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n",
  "  (cond [(empty? numbers) false]\n        [(and (empty? (rest numbers)) false)\
    \ (has_close_elements (rest numbers) threshold)]\n        [(and (empty? (rest\
    \ (rest numbers))) false) (has_close_elements (rest numbers) threshold)]\n   \
    \     [else\n         (let ([diff (abs (- (first numbers) (second numbers)))])\n\
    \           (if (< diff threshold)\n               (or (eq? diff 0) true)\n  \
    \             (has_close_elements (rest numbers) threshold)))]))\n", "  (cond\n\
    \    [(null? numbers) #f]\n    [(= (length numbers) 1) #f]\n    [(has_close_elements_iter\
    \ numbers threshold) #t]\n    [else #f]))\n", "  (define (has_closer? numbers\
    \ threshold)\n    (if (empty? numbers)\n        #f\n        (if (or (and (length?\
    \ numbers) (pair? (cdr numbers))\n                     (let ([diff (abs (- (car\
    \ numbers) (cadr numbers)))])\n                       (if (and (&lt; diff threshold)\n\
    \                                (&gt;= (length? numbers) 3))\n              \
    \             #t\n                           (has_closer? (cdr numbers) threshold))))\n\
    \                (and (length? numbers) (= (length? numbers) 2)\n            \
    \         (&lt; (abs (- (car numbers) (cadr numbers))) threshold)))\n        \
    \    #t\n            (has_closer? (cdr numbers) threshold))))\n  (has_closer?\
    \ numbers threshold))\n", "  (define (are_close number1 number2)\n    (< (abs\
    \ (- number1 number2)) threshold))\n  (cond ((null? numbers) #f)\n        ((null?\
    \ (cdr numbers)) #f)\n        ((are_close (car numbers) (cadr numbers)) #t)\n\
    \        (else (has_close_elements (cdr numbers) threshold))))\n", "  (let loop\
    \ ([numbers numbers]\n             [found? #f])\n    (if (empty? numbers)\n  \
    \      found?\n        (let ([next (rest numbers)])\n          (if (empty? next)\n\
    \              found?\n              (let ([diff (abs (- (first numbers) (first\
    \ next)))])\n                (if (&lt; diff threshold)\n                    #t\n\
    \                    (loop next found?))))))))\n</code>\nAnd the test:\n<code>#lang\
    \ racket\n", "  (local ((define (has_close_elements-inner l threshold)\n     \
    \       (cond\n              [(empty? l) #f]\n              [(has_close_elements-inner\
    \ (cdr l) threshold) #t]\n              [(< (abs (- (car l) (cadr l))) threshold)\
    \ #t]\n              [else #f])))\n    (has_close_elements-inner (sort < numbers)\
    \ threshold)))\n```\n\n```racket\n#lang racket\n", "  (cond\n    [(empty? numbers)\
    \ false]\n    [(empty? (rest numbers)) false]\n    [else\n     (cond\n       [(<\
    \ (abs (- (first numbers) (second numbers))) threshold) true]\n       [else (has_close_elements\
    \ (rest numbers) threshold)])]))\n", "  (for/or ([i numbers] [j numbers] #:when\
    \ (not (= i j)))\n    (< (abs (- i j)) threshold)))\n", "  (let loop ([numbers\
    \ numbers]\n             [result #f])\n    (if (null? numbers)\n        result\n\
    \        (if (< (abs (- (car numbers) (cadr numbers))) threshold)\n          \
    \  (loop (cdr numbers) #t)\n            (loop (cdr numbers) result)))))\n", " \
    \ (local ((define (has-close-elements? n1 n2)\n            (>= (abs (- n1 n2))\
    \ threshold)))\n    (or (empty? numbers)\n        (has-close-elements? (first\
    \ numbers) (second numbers))\n        (has-close-elements? (first numbers) (third\
    \ numbers))\n        (has-close-elements? (second numbers) (third numbers))\n\
    \        (has-close-elements? (second numbers) (fourth numbers))\n        (has-close-elements?\
    \ (third numbers) (fourth numbers))\n        (has-close-elements? (third numbers)\
    \ (fifth numbers))\n        (has-close-elements? (fourth numbers) (fifth numbers))\n\
    \        (has-close-elements? (fourth numbers) (sixth numbers))\n        (has-close-elements?\
    \ (fifth numbers) (sixth numbers)))))\n```\n\n## Exercise 12:\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? numbers) #f]\n    [(and (closer? (first numbers)\
    \ (second numbers) threshold)\n          (has_close_elements (rest numbers) threshold))\
    \ #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n", "  (and/c\
    \ (not (empty? numbers))\n         (or/c (has_close_elements (rest numbers) threshold)\n\
    \               (closer-than-p (first numbers) (second numbers) threshold))))\n",
  "  (cond ((null? numbers) #f)\n        ((< (apply - (car numbers) (cadr numbers))\
    \ threshold) #t)\n        (else (has_close_elements (cdr numbers) threshold))))\n",
  "  (cond ((null? numbers) #f)\n        ((null? (cdr numbers)) #f)\n        ((< (abs\
    \ (- (car numbers) (cadr numbers))) threshold) #t)\n        (else (has_close_elements\
    \ (cdr numbers) threshold))))\n", "  (or (null? numbers)\n      (let ([first (car\
    \ numbers)]\n            [rest (cdr numbers)])\n        (or (< (abs (- first (car\
    \ rest))) threshold)\n            (has_close_elements rest threshold)))))\n",
  "  (for/or ([n1 numbers]\n           [n2 (in-list numbers)]\n           #:when (not\
    \ (= n1 n2)))\n    (< (abs (- n1 n2)) threshold)))\n\n", "  (cond\n    [(null?\
    \ numbers) #f]\n    [(null? (cdr numbers)) #f]\n    [(<= (abs (- (car numbers)\
    \ (cadr numbers))) threshold) #t]\n    [else (has_close_elements (cdr numbers)\
    \ threshold)]))\n```\n### Exercise 3\n\n```racket\n#lang racket\n", "  (cond\n\
    \    [(empty? numbers)\n     #f]\n    [(and (rest (rest numbers)) ; at least 2\
    \ elements\n          (>= (abs (- (second numbers) (first numbers))) threshold))\n\
    \     (has_close_elements (rest numbers) threshold)]\n    [else\n     #t]))\n",
  "  (define (has_close_elements-inner numbers threshold element)\n    (if (empty?\
    \ numbers)\n        #f\n        (let ((distance (abs (- element (first numbers)))))\n\
    \          (if (< distance threshold)\n              #t\n              (has_close_elements-inner\
    \ (rest numbers) threshold element)))))\n  (or (has_close_elements-inner (rest\
    \ numbers) threshold (first numbers))\n      (has_close_elements-inner (rest numbers)\
    \ threshold (first (rest numbers)))))\n", "  (cond ((null? numbers) #f)\n    \
    \    ((null? (cdr numbers)) #f)\n        ((<= (abs (- (car numbers) (cadr numbers)))\
    \ threshold) #t)\n        (else (has_close_elements (cdr numbers) threshold))))\n",
  "  (cond\n    [(null? numbers) #f]\n    [(member (abs (- (car numbers) (cadr numbers)))\n\
    \             (map (lambda (x) (abs (- (car numbers) x))) (cdr numbers)))\n  \
    \   #t]\n    [else (has_close_elements (cdr numbers) threshold)]))\n", "  (let\
    \ ([lst (sort numbers <)])\n    (local [(define (between? x y z) (<= (abs (- x\
    \ y)) z))]\n      (for/or ([i lst] [j (in-list (cdr lst))])\n              (between?\
    \ i j threshold)))))\n", "  (cond\n    [(null? numbers) #f]\n    [(null? (cdr\
    \ numbers)) #f]\n    [(< (abs (- (car numbers) (cadr numbers))) threshold) #t]\n\
    \    [else (has_close_elements (cdr numbers) threshold)]))\n```\n\n```racket\n\
    #lang racket\n", "  (cond [(empty? numbers) false]\n        [(and (positive? (remainder\
    \ (length numbers) 2))\n              (has_closer_than_threshold (first numbers)\
    \ (second numbers) threshold)) true]\n        [else (has_close_elements (rest\
    \ numbers) threshold)]))\n", "  (cond\n    ((empty? numbers) #f)\n    ((member?\
    \ (list-ref numbers 0) (rest numbers)) #t)\n    (else (has_close_elements (rest\
    \ numbers) threshold))))\n", "  (for/or ([x numbers]\n           [y (rest numbers)])\n\
    \    (< (abs (- x y)) threshold)))\n", "  (if (null? numbers)\n      #f\n    \
    \  (cond ((null? (cdr numbers)) #f)\n            ((< (abs (- (car numbers) (cadr\
    \ numbers))) threshold) #t)\n            (else (has_close_elements (cdr numbers)\
    \ threshold)))))\n", "  (cond [(null? numbers) #f]\n        [(empty? (cdr numbers))\
    \ #f]\n        [(< (abs (- (car numbers) (cadr numbers))) threshold) #t]\n   \
    \     [else (has_close_elements (cdr numbers) threshold)]))\n", "  (define (has_close_elements?\
    \ n1 n2)\n    (< (abs (- n1 n2)) threshold))\n  (for/or ([i (in-range (length\
    \ numbers))]\n           [j (in-range i (add1 i))])\n    (has_close_elements?\
    \ (list-ref numbers i) (list-ref numbers j))))\n", "  (and (pair? numbers) (abs\
    \ (- (car numbers) (cadr numbers)) < threshold) #t))\n```\n\n## Periodic Table\n\
    \n```racket\n#lang racket\n", "  (let loop ([numbers numbers]\n             [index\
    \ 1])\n    (if (null? numbers)\n        #f\n        (let ([first-element (car\
    \ numbers)])\n          (if (> index (length numbers))\n              #f\n   \
    \           (if (< (- first-element (list-ref numbers index)) threshold)\n   \
    \               #t\n                  (loop (cdr numbers) (+ index 1))))))))\n",
  "  (if (null? numbers)\n      #f\n      (let ([closest (car numbers)])\n       \
    \ (if (member closest numbers)\n            #t\n            (has_close_elements\
    \ (cdr numbers) threshold)))))\n```\n\n```racket\n#lang racket\n", "  (cond ((empty?\
    \ numbers) #f)\n        ((empty? (rest numbers)) #f)\n        ((< (abs (- (first\
    \ numbers) (second numbers))) threshold) #t)\n        (else (has_close_elements\
    \ (rest numbers) threshold))))\n", "  (define (close? current comparison)\n  \
    \  (< (abs (- current comparison)) threshold))\n  (for/or ([first-pair (in-list\
    \ numbers)]\n           [second-pair (in-list numbers)])\n    (close? first-pair\
    \ second-pair)))\n", "  (cond ((empty? numbers) #f)\n        ((empty? (rest numbers))\
    \ #f)\n        ((< (abs (- (first numbers) (first (rest numbers)))) threshold)\
    \ #t)\n        (else (has_close_elements (rest numbers) threshold))))\n", "  (if\
    \ (empty? numbers)\n      #f\n      (let* ([rest (rest numbers)]\n           \
    \  [head (first numbers)])\n        (or (member (abs (- head (first rest))) threshold)\n\
    \            (has_close_elements rest threshold)))))\n", "  (cond\n    [(null?\
    \ numbers) #f]\n    [(null? (cdr numbers)) #f]\n    [(< (abs (- (car numbers)\
    \ (cadr numbers))) threshold) #t]\n    [else (has_close_elements (cdr numbers)\
    \ threshold)]))\n", "  (cond\n    [(empty? numbers) #f]\n    [(empty? (rest numbers))\
    \ #f]\n    [(<= (abs (- (first numbers) (second numbers))) threshold) #t]\n  \
    \  [else (has_close_elements (rest numbers) threshold)]))\n```\n\n```racket\n\
    #lang racket\n", "  (for*/first ([i (in-naturals)\n                j (in-naturals\
    \ (add1 i))]\n               #:when (< (abs (- (list-ref numbers i) (list-ref\
    \ numbers j))) threshold))\n    i))\n", "  (define (loop elt others)\n    (if\
    \ (null? others)\n        #f\n        (if (&lt; (abs (- elt (car others))) threshold)\n\
    \            #t\n            (loop elt (cdr others)))))\n  (define (accum elt\
    \ others acc)\n    (if (null? others)\n        acc\n        (accum elt (cdr others)\
    \ (or (loop elt others) acc))))\n  (accum (car numbers) (cdr numbers) #f))\n",
  "  (if (null? numbers)\n      #f\n      (or (has_close_elements (cdr numbers) threshold)\n\
    \          (let ((curr-elem (car numbers))\n                (rest-elems (cdr numbers)))\n\
    \            (or (some (lambda (elem)\n                        (< (abs (- curr-elem\
    \ elem)) threshold))\n                      rest-elems)\n                #f)))))\n",
  "  (define (check_close? n1 n2 threshold)\n    (let ([dist (- n1 n2)])\n      (<\
    \ dist threshold)))\n  (for/or ([n1 numbers]\n           [n2 (rest numbers)])\n\
    \    (check_close? n1 n2 threshold)))\n", "  (for/or ([a numbers]\n          \
    \ [b (in-list numbers)]\n           #:when (and (not (equal? a b))\n         \
    \              (< (abs (- a b)) threshold)))\n    #t))\n", "  (cond\n    [(or\
    \ (null? numbers) (null? (cdr numbers))) false]\n    [(< (abs (- (car numbers)\
    \ (cadr numbers))) threshold) true]\n    [else (has_close_elements (cdr numbers)\
    \ threshold)]))\n", "  (and (not (empty? numbers))\n       (or (has_close_elements\
    \ (rest numbers) threshold)\n           (and (not (empty? (rest numbers)))\n \
    \               (< (- (first numbers) (first (rest numbers))) threshold)))))\n\
    \n", "  (cond [(null? numbers)\n         #f]\n        [(or (and (pair? numbers)\n\
    \                  (null? (cdr numbers)))\n             (null? (cdr (cdr numbers))))\n\
    \         #f]\n        [(< (abs (- (car numbers) (cadr numbers))) threshold)\n\
    \         #t]\n        [else\n         (has_close_elements (cdr numbers) threshold)]))\n",
  "  (cond\n    [(null? numbers) #f]\n    [(= (length numbers) 1) #f]\n    [(< (abs\
    \ (- (car numbers) (cadr numbers))) threshold) #t]\n    [else (has_close_elements\
    \ (cdr numbers) threshold)]))\n", "  (for*/or ([i (in-range (length numbers))]\n\
    \            [j (in-range (add1 i) (length numbers))])\n    (if (< (abs (- (list-ref\
    \ numbers i) (list-ref numbers j))) threshold)\n        #t\n        #f)))\n",
  "  (let loop ([numbers numbers]\n             [last_element (first numbers)])\n\
    \    (if (or (= (length numbers) 1)\n            (= (length numbers) 0))\n   \
    \     #f\n        (if (< (abs (- (first numbers) last_element)) threshold)\n \
    \           #t\n            (loop (rest numbers) (first numbers))))))\n", "  (cond\n\
    \    [(empty? numbers) #f]\n    [(empty? (rest numbers)) #f]\n    [(<= (abs (-\
    \ (first numbers) (second numbers))) threshold) #t]\n    [else (has_close_elements\
    \ (rest numbers) threshold)]))\n", "  (cond\n    [(empty? numbers) #f]\n    [(empty?\
    \ (rest numbers)) #f]\n    [(< (abs (- (first numbers) (second numbers))) threshold)\
    \ #t]\n    [else (has_close_elements (rest numbers) threshold)]))\n", "  (for/or\
    \ ([i (in-list numbers)]\n           [j (in-list numbers)]\n           #:when\
    \ (and (not (= i j))\n                       (<= (abs (- i j)) threshold)))\n\
    \    #t))\n", "  (cond\n    [(empty? numbers) false]\n    [(null? (cdr numbers))\
    \ false]\n    [(>= (abs (- (car numbers) (cadr numbers))) threshold) (has_close_elements\
    \ (cdr numbers) threshold)]\n    [else true]))\n", "  (cond [(empty? numbers)\
    \ false]\n        [(empty? (rest numbers)) false]\n        [else (or (>= (- (first\
    \ numbers) (second numbers)) threshold)\n                  (has_close_elements\
    \ (rest numbers) threshold))]))\n", "  (for/or ([numbers numbers]\n          \
    \ [i (in-naturals)])\n    (for/or ([other-numbers (in-list (rest numbers))]\n\
    \             [j (in-naturals)])\n      (< (- (abs (- (list-ref numbers i) (list-ref\
    \ other-numbers j))) threshold) 0.000001))))\n", "  (local [(define (inner numbers\
    \ threshold)\n            (if (or (null? numbers) (null? (cdr numbers)))\n   \
    \             #f\n                (let ([first (car numbers)]\n              \
    \        [second (car (cdr numbers))])\n                  (if (< (abs (- first\
    \ second)) threshold)\n                      #t\n                      (inner\
    \ (cdr numbers) threshold)))))\n          ]\n    (inner numbers threshold)))\n",
  "  (cond ((null? numbers)\n         false)\n        ((null? (cdr numbers))\n   \
    \      false)\n        ((< (abs (- (car numbers) (cadr numbers))) threshold)\n\
    \         true)\n        (else\n         (has_close_elements (cdr numbers) threshold))))\n\
    ```\n\n``` #lang racket", "  (let loop ([numbers numbers]\n             [acc #f])\n\
    \    (cond [(empty? numbers) acc]\n          [(empty? (rest numbers)) acc]\n \
    \         [(< (abs (- (first numbers) (second numbers))) threshold) #t]\n    \
    \      [else (loop (rest numbers)\n                      acc)])))\n", "  (define\
    \ (helper lst)\n    (match lst\n      [(list) #f]\n      [(list head tail ...)\n\
    \       (if (< (abs (- head (first tail))) threshold)\n           #t\n       \
    \    (helper (cons head tail)))]))\n  (helper numbers))\n```\n\n```racket\n#lang\
    \ racket\n", "  (define (closer? a b)\n    (>= (abs (- a b)) threshold))\n  (or\
    \ (not (null? (cdr numbers)))\n      (closer? (car numbers) (cadr numbers))\n\
    \      (has_close_elements (cdr numbers) threshold)))\n", "  (for/or ([i numbers]\n\
    \           [j numbers])\n    (and (not (= i j))\n         (< (abs (- i j)) threshold))))\n",
  "  (if (null? numbers)\n      false\n      (or (close? (car numbers) (cadr numbers)\
    \ threshold)\n          (has_close_elements (cdr numbers) threshold))))\n", " \
    \ (for/or ([element numbers]\n           [other numbers])\n    (< (abs (- element\
    \ other)) threshold)))\n", "  (let loop ([i 0] [j 0])\n    (cond\n      [(= i\
    \ (- (length numbers) 1)) #f]\n      [(= j (- (length numbers) 1)) (loop (+ i\
    \ 1) (+ i 1))]\n      [(< (abs (- (list-ref numbers i) (list-ref numbers j)))\
    \ threshold) #t]\n      [else (loop i (+ j 1))])))\n", "  (cond\n    [(empty?\
    \ numbers) #f]\n    [(equal? (first numbers) (rest numbers)) #t]\n    [else (has_close_elements\
    \ (rest numbers) threshold)]))\n", "  (if (empty? numbers)\n      #f\n      (cond\
    \ [(empty? (rest numbers))\n             #f]\n            [(< (abs (- (first numbers)\
    \ (second numbers))) threshold)\n             #t]\n            [else\n       \
    \      (has_close_elements (rest numbers) threshold)])))\n", "  (let loop ([result\
    \ #f]\n             [numbers (rest numbers)])\n    (cond [(null? numbers) result]\n\
    \          [(< (- (first numbers) (second numbers)) threshold) #t]\n         \
    \ [else (loop result (rest numbers))])))\n", "  (if (or (null? numbers) (null?\
    \ (cdr numbers)))\n      #f\n      (or (< (abs (- (car numbers) (cadr numbers)))\
    \ threshold)\n          (has_close_elements (cdr numbers) threshold))))\n", " \
    \ (for/or ([x numbers] [y (in-list numbers #:when (not (eq? x y)))]\n        \
    \   #:when (< (abs (- x y)) threshold))\n    #t))\n```\n\n```python\n#lang python\n\
    \n# Check if in given list of numbers, are any two numbers closer to each other\
    \ than\n# given threshold.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#\
    \ False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True\n\
    def has_close_elements(numbers, threshold):\n    for x in numbers:\n        for\
    \ y in numbers:\n            if x == y:\n                continue\n          \
    \  if abs(x - y) < threshold:\n                return True\n    return False\n\
    ```\n\n**Input**\n\n```racket\n> (has_close_elements '(1.0 2.0 3.0) 0.5)\nFalse\n\
    > (has_close_elements '(1.0 2.8 3.0 4.0 5.0 2.0) 0.3)\nTrue\n```\n\n```python\n\
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0,\
    \ 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n```\n\n## Updating the collection of existing\
    \ code snippets\n\nIn this section we present how to update the existing code\
    \ snippets in the\ncollection to match the latest versions of their implementations.\n\
    \n### Current built-in solution\n\nIn directory where the collection of code snippets\
    \ is placed, run:\n\n```\nmake update-built-in\n```\n\nThe above command will\
    \ update the code snippets in the collection, using the\ncurrently installed Python\
    \ interpreter.\n\n### Built-in solution using a specific Python interpreter\n\n\
    In directory where the collection of code snippets is placed, run:\n\n```\nmake\
    \ PY=path-to-python-interpreter update-built-in", "  (cond\n    [(empty? numbers)\
    \ false]\n    [(empty? (rest numbers)) false]\n    [else\n     (cond\n       [(<\
    \ (abs (- (first numbers) (second numbers))) threshold) true]\n       [else (has_close_elements\
    \ (rest numbers) threshold)])]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
