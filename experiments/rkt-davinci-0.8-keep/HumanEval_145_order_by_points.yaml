name: HumanEval_145_order_by_points
language: rkt
prompt: "#lang racket\n\n;; Write a function which sorts the given list of integers\n\
  ;; in ascending order according to the sum of their digits.\n;; Note: if there are\
  \ several items with similar sum of their digits,\n;; order them based on their\
  \ index in original list.\n;; For example:\n;; >>> order_by_points([1, 11, -1, -11,\
  \ -12]) == [-1, -11, 1, -12, 11]\n;; >>> order_by_points([]) == []\n(define (order_by_points\
  \ nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n\
  \    (check-equal? (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11))\n\
  \    (check-equal? (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56\
  \ 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457))\n    (check-equal?\
  \ (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 -11 -32 43\
  \ 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9))\n    (check-equal? (candidate\
  \ (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6))\n))\n\n(test-humaneval)"
completions: ["  (sort nums < #:key (lambda (n) (+ (remainder n 10) (quotient n 10)))))\n",
  "  (for/list ([(num . idx) (in-indexed nums)])\n    (cons (sum-digits num) idx)))\n",
  "  (sort (map (lambda (n) (list n (sum-digits n))) nums)\n        (lambda (a b)\n\
    \          (cond\n            [(< (car a) (car b)) #t]\n            [(> (car a)\
    \ (car b)) #f]\n            [else\n             (cond\n               [(< (cadr\
    \ a) (cadr b)) #t]\n               [(> (cadr a) (cadr b)) #f]\n              \
    \ [else #f])]))))\n", "  (define (sum_digits n)\n    (accumulate + 0 (map (\u03BB\
    \ (c) (- (char->integer c) (char->integer #\\0))) (string->list (number->string\
    \ n)))))\n  (sort nums < (map sum_digits nums)))\n", "  (sort (map (\u03BB (a)\
    \ (cons (foldl + 0 (map digit-value (string->list (number->string a)))) a)) nums)\
    \ (\u03BB (a b) (string<? (number->string (cdr a)) (number->string (cdr b))))))\n",
  "  (sort nums #:key (lambda (x) (+ (remainder x 10) (remainder (quotient x 10) 10)\
    \ (quotient x 100)))))\n", "  (sort (map (lambda (x)\n               (list x (foldr\
    \ + 0 (string->list (number->string x)))))\n             nums)\n        <\n  \
    \      (lambda (x y)\n          (and (eq? (second x) (second y))\n           \
    \    (eq? (first x) (first y))))))\n", "  (sort nums\n        (lambda (n1 n2)\n\
    \          (< (foldl + 0 (string->list (number->string n1)))\n             (foldl\
    \ + 0 (string->list (number->string n2)))))))\n", "  (sort nums (lambda (x y)\n\
    \               (let ([x-sum (sum-digits x)]\n                     [y-sum (sum-digits\
    \ y)])\n                 (cond [(> x-sum y-sum) (< x y)]\n                   \
    \    [(< x-sum y-sum) (> x y)]\n                       [else (< x y)])))))\n",
  "  (sort nums < #:key (lambda (x) (+ (modulo x 10) (quotient x 10)))))\n", "  (sort\
    \ nums\n        (lambda (x y)\n          (< (foldl + 0 (map (lambda (digit) (char->integer\
    \ digit))\n                              (list->string\n                     \
    \          (number->string (abs x)))))\n             (foldl + 0 (map (lambda (digit)\
    \ (char->integer digit))\n                              (list->string\n      \
    \                         (number->string (abs y)))))))))\n```\n\n```\n#lang racket\n",
  "  (sort (for/list ([num nums])\n           (list (abs num) (if (zero? (modulo num\
    \ 10)) 0 (abs (modulo num 10))) num))\n        (\u03BB (a b) (if (zero? (modulo\
    \ (first a) 10))\n                     (if (zero? (modulo (first b) 10))\n   \
    \                      (if (< (second a) (second b))\n                       \
    \      #t\n                             #f)\n                         #t)\n  \
    \                   (if (zero? (modulo (first b) 10))\n                      \
    \   #f\n                         (if (< (second a) (second b))\n             \
    \                #t\n                             #f))))))\n", "  (sort nums\n\
    \        (lambda (n1 n2)\n          (< (sum-digits n1) (sum-digits n2)))))\n",
  "  (sort (lambda (a b) (< (sum-digits a) (sum-digits b))) nums))\n", "  (sort (map\
    \ (\u03BB (pair)\n               (car pair))\n             (sort (map (\u03BB\
    \ (n)\n                          (list n (sum-digits n)))\n                  \
    \      nums)\n                   <\n                   (\u03BB (a b)\n       \
    \              (if (= (cadr a) (cadr b))\n                         (< (car a)\
    \ (car b))\n                         (< (cadr a) (cadr b))))))\n        <))\n",
  "  (sort (map (lambda (x) (list x (sum-digits x))) nums)\n        < (lambda (a b)\
    \ (eq? (second a) (second b)))))\n", "  (sort (map-indexed (lambda (i x) (cons\
    \ x i)) nums)\n        (lambda (a b)\n          (let ([a-sum (sum-digits (car\
    \ a))]\n                [b-sum (sum-digits (car b))])\n            (cond [(= a-sum\
    \ b-sum) (< (cdr a) (cdr b))]\n                  [(< a-sum b-sum) #t]\n      \
    \            [else #f])))))\n", "  (sort nums (\u03BB (x y) (let ([xs (sum-digits\
    \ x)]\n                            [ys (sum-digits y)])\n                    \
    \  (cond [(< xs ys) #t]\n                            [(> xs ys) #f]\n        \
    \                    [else (and (< x y) #t)])))))\n", "  (define (sums lst)\n\
    \    (for/list ([n lst])\n      (sum (for/list ([s (string->list (number->string\
    \ n))])\n              (string->number s)))))\n  (sort (map list nums (sums nums))\n\
    \        < #:key cdr))\n", "  (define (sum-digits n)\n    (cond [(empty? nums)\
    \ 0]\n          [(< n 10) n]\n          [else (+ (modulo n 10) (sum-digits (quotient\
    \ n 10)))]))\n  (if (empty? nums)\n      (empty)\n      (append (list (list-ref\
    \ nums 0))\n              (order_by_points (list-tail nums)))))\n", "  (sort (lambda\
    \ (num1 num2)\n          (< (sum_of_digits num1) (sum_of_digits num2)))\n    \
    \    nums))\n", "  (cond [(empty? nums) '()]\n        [else (append (list (argmin\
    \ nums))\n                      (order_by_points (remove (argmin nums) nums)))]))\n",
  "  (sort nums #:key\n        (lambda (x) (list (sum_digits x) x))))\n", "  (sort\
    \ (map vector nums (map (\u03BB (n) (if (negative? n) (- n) n)) nums) (map (\u03BB\
    \ (n) (if (negative? n) n (- n))) nums))\n        (\u03BB (e1 e2) (< (sum (cddr\
    \ e1)) (sum (cddr e2))))))\n", "  (sort nums (lambda (a b)\n               (<\
    \ (sum-digits a) (sum-digits b)))))\n", "  (sort nums\n        (lambda (a b)\n\
    \          (< (+ (modulo a 10) (/ a 10))\n             (+ (modulo b 10) (/ b 10))))))\n",
  "  (sort nums\n        (lambda (x y)\n          (&lt; (sum-digits x) (sum-digits\
    \ y)))))\n", "  (sort nums\n        #:key\n        (lambda (num)\n          (let\
    \ loop ([i 0] [sum 0])\n            (if (= 0 i)\n                sum\n       \
    \         (loop (- i 1) (+ sum (remainder num 10)))))))\n  )\n", "  (sort nums\n\
    \        (lambda (x y)\n          (< (sum-digits x) (sum-digits y)))))\n", " \
    \ (sort nums #:key\n        (lambda (n)\n          (apply + (map string->number\
    \ (string-&gt;list (number-&gt;string n)))))))\n</code>\nWhich works fine and\
    \ gives\n<code>&gt; (order_by_points [1 11 -1 -11 -12])\n'(-1 -11 1 -12 11)\n\
    </code>\nBut when I try with more than one digit numbers (i.e., not just -1, 1,\
    \ 11, -11, -12), for example\n<code>&gt; (order_by_points [0 -10 10 -5 5])\n'(0\
    \ -10 10 -5 5)\n</code>\nwhat I expect is to have\n<code>'(0 -5 5 -10 10)\n</code>\n\
    which I don't understand why I don't get.\nIf I add a print to see how the key\
    \ is evaluated I get\n<code>&gt; (define (order_by_points nums)\n    (sort nums\
    \ #:key\n          (lambda (n)\n            (printf \"~a\\n\" (apply + (map string-&gt;number\
    \ (string-&gt;list (number-&gt;string n)))))\n            (apply + (map string-&gt;number\
    \ (string-&gt;list (number-&gt;string n)))))))\n&gt; (order_by_points [0 -10 10\
    \ -5 5])\n0\n-5\n5\n-10\n10\n'(0 -10 10 -5 5)\n</code>\nSo it seems <code>-5</code>\
    \ is correctly evaluated to <code>-5</code> but it seems to be ignored by <code>sort</code>.\n\
    Any idea why?\n\n\nA:\n\nYou're sorting on the absolute value of the numbers.\
    \ Since <code>-5</code> is the same as <code>5</code>, and <code>-10</code> is\
    \ the same as <code>10</code>, you get an order that looks like <code>0 -10 10\
    \ -5 5</code>.\nTo fix this, you can use <code>&lt;</code> instead of <code>&lt;=</code>\
    \ to make", "  (sort nums\n        (lambda (a b)\n          (< (foldl (lambda\
    \ (x y) (+ x y)) 0 (map string->number (string-split (number->string a) #rx\"\
    [,.]\")))\n             (foldl (lambda (x y) (+ x y)) 0 (map string->number (string-split\
    \ (number->string b) #rx\"[,.]\")))))))\n", "  (sort nums (\u03BB (x y) (< (sum-digits\
    \ x) (sum-digits y)))))\n", "  (sort nums (\u03BB (x y)\n    (< (reduce + (for/list\
    \ ([c (in-string (number->string x))])\n                    (string->number (string\
    \ c))))\n       (reduce + (for/list ([c (in-string (number->string y))])\n   \
    \                 (string->number (string c))))))))", "  (cond [(empty? nums)\
    \ nums]\n        [else\n         (sort (lambda (a b) (sum-of-digits-lt? a b))\
    \ nums)]))\n", "  (sort nums (lambda (a b) (or (< (digit-sum a) (digit-sum b))\n\
    \                               (= (digit-sum a) (digit-sum b))\n            \
    \                   (> a b)))))\n", "  (sort (indexed-list nums) compare-points))\n",
  "  (sort (build-list nums) < #:key sum-digits))\n", "  (sort nums (\u03BB (a b)\n\
    \               (< (list-sum (list->integer-list a))\n                  (list-sum\
    \ (list->integer-list b))))))\n", "  (define (sum-of-digits n)\n    (let loop\
    \ ([n n] [acc 0])\n      (if (zero? n)\n          acc\n          (loop (quotient\
    \ n 10) (+ acc (remainder n 10))))))\n  (define (sum-of-digits2 n)\n    (for/fold\
    \ ([acc 0]) ([d (in-list (number->list n))])\n      (+ acc d)))\n  (define (int-sort\
    \ x y)\n    (cond [(or (and (positive? x) (negative? y))\n               (and\
    \ (positive? x) (positive? y) (< x y))\n               (and (negative? x) (negative?\
    \ y) (> x y)))\n           #t]\n          [else #f]))\n  (define (compare-by-digits\
    \ x y)\n    (int-sort (sum-of-digits x) (sum-of-digits y)))\n  (sort compare-by-digits\
    \ nums))\n", "  (if (empty? nums)\n      nums\n      (let* ([d (list-ref nums\
    \ 0)]\n             [dx (abs d)]\n             [sum (+ (modulo dx 10) (/ dx 10))])\n\
    \        (append (list d)\n                (order_by_points (filter (lambda (x)\
    \ (not (equal? x d))) nums))))))\n```\n\n### Author's solution\n\n```racket\n\
    #lang racket\n", "  (sort nums\n        (lambda (x y) (< (sum-digits x) (sum-digits\
    \ y)))))\n", "  (define (sum-digits n)\n    (apply + (map string->number (string-&gt;list\
    \ (number-&gt;string n)))))\n  (if (null? nums)\n      '()\n      (append (list\
    \ (car (sort (map list nums)\n                               &lt; #:key sum-digits)))\n\
    \              (order_by_points (cdr nums)))))\n</code>\nTests:\n<code>#lang racket\n",
  "  (sort (for/list ([num nums])\n          [(sum-digits num) num])\n        (\u03BB\
    \ (n1 n2) (< (first n1) (first n2)))))\n", "  (sort (for/list ([n nums])\n   \
    \       (cons n (sum-digits n)))\n        < #:key second))\n", "  (cond [(empty?\
    \ nums) empty]\n        [else (sort nums (\u03BB (a b)\n                     \
    \    (or (< (sum-digits a) (sum-digits b))\n                             (and\
    \ (= (sum-digits a) (sum-digits b))\n                                  (< (index\
    \ nums a) (index nums b))))))]))\n", "  ;; Your code here.\n  (sort (map (lambda\
    \ (x) (cons x (sum-digits x))) nums)\n        (lambda (x y) (< (cdr x) (cdr y)))))\n",
  "  (sort nums\n        (lambda (a b)\n          (and (&lt; (sum-digits a) (sum-digits\
    \ b))\n               (&lt;= (find-first-index nums a) (find-first-index nums\
    \ b))))))\n", "  (sort nums \n        < \n        (map (\u03BB (x) \n        \
    \       (for/sum ([d (in-string (number->string x))])\n                 (string->number\
    \ (string d))))\n             nums)))\n```\n\n## Test Suite\n\n```racket", " \
    \ (define (sum-digits n)\n    (cond\n      [(zero? n) 0]\n      [else (+ (remainder\
    \ n 10) (sum-digits (quotient n 10)))]))\n  (define (is-less-than? n1 n2)\n  \
    \  (< (sum-digits n1) (sum-digits n2)))\n  (sort nums is-less-than?))\n", "  (sort\
    \ (\u03BB (x y)\n          (and (eq? (cond ((< x 0) (+ (- x) 11))\n          \
    \                ((> x 0) (+ x 1))\n                          (else x))\n    \
    \               (cond ((< y 0) (+ (- y) 11))\n                          ((> y\
    \ 0) (+ y 1))\n                          (else y)))\n               (< (car x)\
    \ (car y))))\n        (for/list ([i (in-naturals)]\n                   [j nums])\n\
    \          (list i j))))\n```\n\n### Mission #2.2\n\n```racket\n#lang racket\n",
  "  (sort nums\n    (lambda (x y)\n      (let ([xv (abs (+ (quotient x 10) (remainder\
    \ x 10)))])\n        (let ([yv (abs (+ (quotient y 10) (remainder y 10)))])\n\
    \          (cond\n            [(> xv yv) #t]\n            [(= xv yv) (< x y)]\n\
    \            [else #f]))))))\n", "  (sort (map (lambda (num-index)\n         \
    \      (cons num-index (reduce + (map digit-value (string->list (number->string\
    \ (car num-index)))))))\n             (build-list (length nums) (lambda (i) (list\
    \ (list-ref nums i) i))))\n        (lambda (num-index-a num-index-b)\n       \
    \   (or (< (cdr num-index-a) (cdr num-index-b))\n              (and (= (cdr num-index-a)\
    \ (cdr num-index-b))\n                   (< (cadr num-index-a) (cadr num-index-b)))))))\n",
  "  (let sort-by-sum-of-digits ([nums nums] [result '()])\n    (cond [(empty? nums)\
    \ result]\n          [else (sort-by-sum-of-digits (rest nums)\n              \
    \                          (append result\n                                  \
    \              (list (first nums))))])))\n", "  (sort nums (lambda (a b)\n   \
    \            (< (reduce + (number->list a))\n                  (reduce + (number->list\
    \ b))))))\n", "  (sort nums (lambda (x y)\n               (if (= (sum-digits x)\
    \ (sum-digits y))\n                   (< (index nums x) (index nums y))\n    \
    \               (< (sum-digits x) (sum-digits y))))))\n", "  (define (loop original-idx\
    \ nums)\n    (cond [(empty? nums) '()]\n          [else\n           (let* ([num\
    \ (first nums)]\n                  [num-points (calc-points num)]\n          \
    \        [ordered-rest (loop (add1 original-idx) (rest nums))]\n             \
    \     [rest-num (first ordered-rest)]\n                  [rest-num-points (second\
    \ ordered-rest)])\n             (if (< num-points rest-num-points)\n         \
    \        (cons num (cons num-points ordered-rest))\n                 (cons rest-num\
    \ (cons rest-num-points (cons num\n                                          \
    \                (rest (rest ordered-rest)))))))]))\n  (let loop ([nums nums])\n\
    \    (cond [(empty? nums) '()]\n          [else\n           (let* ([num (first\
    \ nums)]\n                  [sorted-rest (loop (rest nums))]\n               \
    \   [rest-num (first sorted-rest)]\n                  [rest-num-points (second\
    \ sorted-rest)])\n             (if (< (calc-points num) rest-num-points)\n   \
    \              (cons num (cons (calc-points num) sorted-rest))\n             \
    \    (cons rest-num (cons rest-num-points (cons num\n                        \
    \                                  (rest (rest sorted-rest))))))))])))\n", " \
    \ (sort nums\n        (lambda (a b)\n          (&lt; (foldr + 0 (string-&gt;list\
    \ (number-&gt;string a)))\n             (foldr + 0 (string-&gt;list (number-&gt;string\
    \ b)))))))\n</code>\nThis question is for practicing Racket, so I'm assuming the\
    \ built-in library is OK. I wonder if there is a way to avoid using <code>string-&gt;list</code>\
    \ to get rid of O(n) space complexity?\n\n\nA:\n\nYou're using the wrong sort\
    \ algorithm. You want a stable sort, which <code>sort</code> is, but you're using\
    \ it with a function that is not transitive. That means that <code>sort</code>\
    \ is not guaranteed to produce a correct answer. Instead, use <code>sort/comp</code>,\
    \ which sorts with a transitive key function:\n<code>(define (order-by-points\
    \ nums)\n  (sort/comp (lambda (a b) (&lt; (sum-digits a) (sum-digits b)))\n  \
    \           nums))\n", "  (sort nums <= (lambda (a b) (let ([sum-a (sum-digits\
    \ a)]\n                                   [sum-b (sum-digits b)])\n          \
    \                     (if (= sum-a sum-b)\n                                  \
    \ (< (position a nums) (position b nums))\n                                  \
    \ (< sum-a sum-b))))))\n", "  ;; The examples don't make any sense,\n  ;; because\
    \ if the inputs are all non-negative,\n  ;; then the input list is already sorted.\n\
    \  ;; So try to work with these instead.\n  (let ([nums (sort nums <)])\n    (sort\
    \ (map (\u03BB (n) (list n (sum-digits n))) nums)\n          (\u03BB (a b) (and\
    \ (> (cadr a) (cadr b))\n                        (< (car a) (car b)))))))\n",
  "  (sort (build-points nums)\n        <\n        (lambda (p1 p2) (or (equal? (car\
    \ p1) (car p2))\n                            (< (cdr p1) (cdr p2))))))\n", " \
    \ (sort nums < (\u03BB (a b) (eq? (sum-digits a) (sum-digits b)))))\n", "  (sort\
    \ (map (lambda (x) (values x (sum-digits x))) (iota (length nums)))\n        (lambda\
    \ (x y)\n          (if (= (second x) (second y))\n              (< (first x) (first\
    \ y))\n              (< (second x) (second y))))))\n", "  (sort nums (\u03BB (x\
    \ y) (\u2264 (sum-digits x) (sum-digits y)))))\n", "  (sort nums\n        #:key\n\
    \        (lambda (num)\n          (cond\n            [(> num 0) (+ (remainder\
    \ num 10) (/ num 10))]\n            [(< num 0) (- (+ (remainder (- num) 10) (/\
    \ (- num) 10)))]))))\n", "  (sort (build-list-of-tuples nums) compare-lists))\n",
  "  (sort (map sum-of-digits nums) < nums))\n", "  (sort nums (lambda (a b)\n   \
    \            (if (= (sum-digits a) (sum-digits b))\n                   (< (position\
    \ a nums) (position b nums))\n                   (< (sum-digits a) (sum-digits\
    \ b))))))\n", "  (sort nums (lambda (a b)\n               (< (+ (remainder a 10)\
    \ (remainder (quotient a 10) 10))\n                  (+ (remainder b 10) (remainder\
    \ (quotient b 10) 10))))))\n```\n\n# Code Blocks by Language\n\n## Python\n\n\
    ```python\n#lang python\n\ndef odd_numbers(numbers):\n    \"\"\"\n    Return odd\
    \ numbers from the given list.\n    \"\"\"\n    return [n for n in numbers if\
    \ n % 2 == 1]\n```\n\n## Racket\n\n```racket\n#lang racket\n", "  (define (sum-of-digits\
    \ num)\n    (cond ((= num 0) 0)\n          (else (+ (remainder num 10)\n     \
    \              (sum-of-digits (quotient num 10))))))\n  (define (pair-with-digits\
    \ num)\n    (cons num (sum-of-digits num)))\n  (define (sort-by-points nums)\n\
    \    (if (null? nums)\n        nums\n        (cons (car (sort (pair-with-digits\
    \ (car nums))\n                         (sort-by-points (cdr nums))\n        \
    \                 (lambda (a b) (< (cdr a) (cdr b)))))\n              (sort-by-points\
    \ (cdr nums)))))\n  (map car (sort-by-points nums)))\n", "  (sort nums\n     \
    \   (lambda (num1 num2) (< (sum-digits num1) (sum-digits num2)))))\n", "  (sort\
    \ nums (\u03BB (a b)\n               (let ((a-sum (sum-digits a))\n          \
    \           (b-sum (sum-digits b)))\n                 (cond ((> a-sum b-sum) #t)\n\
    \                       ((< a-sum b-sum) #f)\n                       ((= a-sum\
    \ b-sum)\n                        (< (index-of nums a) (index-of nums b))))))))\n",
  "  (sort (for/list ([num nums])\n           (list num (sum-digits num)))\n     \
    \   < #:key (lambda (x) (cadr x))))\n", "  (sort nums\n        (lambda (a b)\n\
    \          (if (< (sum-digits a) (sum-digits b))\n              #t\n         \
    \     (if (= (sum-digits a) (sum-digits b))\n                  (< (index-of nums\
    \ a) (index-of nums b))\n                  #f)))))\n", "  (define (get-sum num)\n\
    \    (define (iter-help num sum)\n      (if (zero? num)\n          sum\n     \
    \     (iter-help (quotient num 10) (+ sum (remainder num 10)))))\n    (iter-help\
    \ num 0))\n  (apply append (list->vector (quicksort get-sum nums))))\n", "  (sort\
    \ nums (\u03BB (x y) (< (digit-sum x) (digit-sum y)))))\n", "  (sort nums\n  \
    \      (lambda (a b)\n          (if (= (sum-digits a) (sum-digits b))\n      \
    \        (< a b)\n              (< (sum-digits a) (sum-digits b))))))\n", "  (sort\
    \ nums sum-of-digits-number-predicate))\n", "  (sort nums sum-of-digits<=?))\n",
  "  (sort nums\n        (lambda (x y)\n          (if (= (sum-digits x) (sum-digits\
    \ y))\n              (< (index x nums) (index y nums))\n              (< (sum-digits\
    \ x) (sum-digits y))))))\n", "  (sort (cons nums '()) #:key sum-digits))\n", " \
    \ (sort nums\n        (lambda (x y)\n          (<= (sum-digits x) (sum-digits\
    \ y)))))\n", "  (sort (map (lambda (n)\n               (cons n (apply + (map (lambda\
    \ (n) (string->number (string n)))\n                                     (string->list\
    \ (number->string n))))))\n             nums)\n        (lambda (p1 p2)\n     \
    \     (or (< (cdr p1) (cdr p2))\n              (and (= (cdr p1) (cdr p2))\n  \
    \                 (< (car p1) (car p2)))))))\n```\n\n```racket\n#lang racket\n",
  "  (sort nums\n        (lambda (x y)\n          (< (helper x) (helper y)))))\n",
  "  (sort (range (length nums))\n        (\u03BB (i j)\n          (< (sum-digits\
    \ (list-ref nums i))\n             (sum-digits (list-ref nums j))))))\n", "  (define\
    \ (sum-digits n)\n    (cond [(= n 0) 0]\n          [else (+ (modulo n 10) (sum-digits\
    \ (quotient n 10)))]))\n  (sort nums < #:key sum-digits))\n", "  (sort nums <\
    \ #:key (\u03BB (x) (cond\n                               [(< x 0) (+ x 1)]\n\
    \                               [else (+ x -1)]))))\n```\n\n```python\n\"\"\"\n\
    Write a function which sorts the given list of integers\nin ascending order according\
    \ to the sum of their digits.\nNote: if there are several items with similar sum\
    \ of their digits,\norder them based on their index in original list.\nFor example:\n\
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> order_by_points([])\
    \ == []\n\"\"\"\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit\
    \ in str(abs(n)))\n\ndef order_by_points(nums):\n    nums_indices = list(enumerate(nums))\n\
    \    return [\n        n for n, _ in sorted(\n            nums_indices,\n    \
    \        key=lambda x: (sum_of_digits(x[1]), x[0]),\n        )\n    ]\n```\n\n\
    ### Solution 1\n\n```c\nvoid order_by_points(int* a, int a_len) {\n    for (int\
    \ i = 0; i < a_len; i++) {\n        for (int j = 0; j < a_len - 1; j++) {\n  \
    \          int a_i = a[i];\n            int a_j = a[j];\n            int i_sum\
    \ = 0;\n            int j_sum = 0;\n            int n = a_i;\n            while\
    \ (n != 0) {\n                i_sum += n % 10;\n                n /= 10;\n   \
    \         }\n            n = a_j;\n            while (n != 0) {\n            \
    \    j_sum += n % 10;\n                n /= 10;\n            }\n            if\
    \ (i_sum > j_sum) {\n                int temp = a[i];\n                a[i] =\
    \ a[j];\n                a[j] = temp;\n            }\n        }\n    }\n}\n```\n\
    \n### Solution 2\n\n```go\n", "  (sort (iota (length nums))\n        (\u03BB (i\
    \ j) (< (sum-digits (list-ref nums i))\n                    (sum-digits (list-ref\
    \ nums j))))))\n", "  (quicksort nums))\n", "  (sort nums (lambda (x y)\n    \
    \           (if (&lt; (sum-digits x) (sum-digits y))\n                   '#t\n\
    \                   (if (= (sum-digits x) (sum-digits y))\n                  \
    \     (&lt; (list-index nums x) (list-index nums y))\n                       '#f)))))\n\
    </code>\nHow can I improve this code?\n\n\nA:\n\nYes, there are better ways to\
    \ do this.  The big problem with this code is you are using a lot of if-statements.\
    \  Your code is difficult to read, and therefore difficult to maintain and error\
    \ prone.  Also, if-statements are much less efficient than the equivalent boolean\
    \ expression.  Finally, your code is not very functional.\nThe code below doesn't\
    \ use if-statements at all.  It also uses a lot less code and is a lot more functional.\
    \  It passes all the tests you described.\n<code>#lang racket\n", "  (sort nums\n\
    \        (lambda (x y) (let-values ([(sx sy) (values (sum-digits x) (sum-digits\
    \ y))])\n                         (if (= sx sy)\n                            \
    \ (< x y)\n                             (< sx sy))))))\n", "  (define (sum-digits\
    \ n)\n    (define (sum-digits-helper n sum)\n      (if (zero? n)\n          sum\n\
    \          (sum-digits-helper (quotient n 10) (+ sum (remainder n 10)))))\n  \
    \  (sum-digits-helper n 0))\n  (sort nums < #:key sum-digits))\n```\n\nJavaScript\n\
    ```javascript\n// Write a function which sorts the given list of integers\n//\
    \ in ascending order according to the sum of their digits.\n// Note: if there\
    \ are several items with similar sum of their digits,\n// order them based on\
    \ their index in original list.\n// For example:\n// >>> order_by_points([1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11]\n// >>> order_by_points([]) == []\n\
    function order_by_points(nums) {\n  function sum_digits(n) {\n    function sum_digits_helper(n,\
    \ sum) {\n      if (n === 0) {\n        return sum;\n      } else {\n        return\
    \ sum_digits_helper(Math.floor(n / 10), sum + (n % 10));\n      }\n    }\n   \
    \ return sum_digits_helper(n, 0);\n  }\n  return nums.sort((a, b) => sum_digits(a)\
    \ - sum_digits(b));\n}\n```\n\n## Challenge 2\n\nRacket\n```racket\n#lang racket\n",
  "  (sort nums (lambda (x y)\n               (if (= (sum-digits x) (sum-digits y))\n\
    \                   (< (list-index nums x) (list-index nums y))\n            \
    \       (< (sum-digits x) (sum-digits y))))))\n", "  (sort nums\n        (lambda\
    \ (x y)\n          (let* ([sx (number->string x)]\n                 [sy (number->string\
    \ y)]\n                 [xs (foldl + 0 (map string-&gt;number sx))]\n        \
    \         [ys (foldl + 0 (map string-&gt;number sy))])\n            (if (= xs\
    \ ys)\n                (&lt; x y)\n                (&lt; xs ys))))))\n", "  (define\
    \ (sum-digits n)\n    (cond [(zero? n) 0]\n          [else (+ (modulo n 10) (sum-digits\
    \ (quotient n 10)))]))\n  (sort (map list nums)\n        (lambda (a b)\n     \
    \     (< (sum-digits (cadr a)) (sum-digits (cadr b))))))", "  (sort (map (lambda\
    \ (x) (list x (digit-sum x))) nums)\n          #:key (lambda (x) (cadr x))))\n",
  "  (map first\n       (sort (for/list ([num nums])\n               [num (sum-digits\
    \ num)])\n             (\u03BB (x y) (< (second x) (second y)))\n            \
    \ )))\n", "  (sort nums (lambda (x y)\n\t       (or (< (+ (modulo x 10)\n\t\t\t\
    \ (if (not (zero? (quotient x 10)))\n\t\t\t     (+ (modulo (quotient x 10) 10)\n\
    \t\t\t\t(if (not (zero? (quotient (quotient x 10) 10)))\n\t\t\t\t    (+ (modulo\
    \ (quotient (quotient x 10) 10) 10)\n\t\t\t\t       (if (not (zero? (quotient\
    \ (quotient (quotient x 10) 10) 10)))\n\t\t\t\t\t   (+ (modulo (quotient (quotient\
    \ (quotient x 10) 10) 10) 10)\n\t\t\t\t\t      (if (not (zero? (quotient (quotient\
    \ (quotient (quotient x 10) 10) 10) 10)))\n\t\t\t\t\t\t  (+ (modulo (quotient\
    \ (quotient (quotient (quotient x 10) 10) 10) 10) 10)\n\t\t\t\t\t\t  0))))\n\t\
    \t\t\t    0))))\n\t\t\t 0))\n\t\t   (< (+ (modulo y 10)\n\t\t\t (if (not (zero?\
    \ (quotient y 10)))\n\t\t\t     (+ (modulo (quotient y 10) 10)\n\t\t\t\t(if (not\
    \ (zero? (quotient (quotient y 10) 10)))\n\t\t\t\t    (+ (modulo (quotient (quotient\
    \ y 10) 10) 10)\n\t\t\t\t       (if (not (zero? (quotient (quotient (quotient\
    \ y 10) 10) 10)))\n\t\t\t\t\t   (+ (modulo (quotient (quotient (quotient y 10)\
    \ 10) 10) 10)\n\t\t\t\t\t      (if (not (zero? (quotient (quotient (quotient (quotient\
    \ y 10) 10) 10) 10)))\n\t\t\t\t\t\t  (+ (modulo (quotient (quotient (quotient\
    \ (quotient y 10) 10) 10", "  (sort nums (\u03BB (x y) (< (sum-digits x) (sum-digits\
    \ y)))))\n", "  (sort nums\n        (lambda (x y)\n          (< (sum-digits x)\
    \ (sum-digits y)))))\n", "  (sort nums\n        #:key (lambda (n)\n          \
    \     (if (negative? n)\n                   (- (apply + (for/list ([d (in-string\
    \ (number->string n))])\n                                  (string->number (string\
    \ d))))\n                      1)\n                   (apply + (for/list ([d (in-string\
    \ (number->string n))])\n                                  (string->number (string\
    \ d))))))))\n", '  (sort nums (lambda (a b) (< (sum-digits a) (sum-digits b)))))',
  "  (match nums\n    [() '()]\n    [(cons n ns)\n     (define (sum-digits n)\n  \
    \     (if (= n 0)\n           0\n           (+ (remainder n 10)\n            \
    \  (sum-digits (quotient n 10)))))\n     (define (sum-digits-digit-pairs n)\n\
    \       (list (cons (sum-digits n) n)))\n     (define (sum-digits-digit-pairs-for-all\
    \ nums)\n       (apply append (map sum-digits-digit-pairs nums)))\n     (sort\
    \ (sum-digits-digit-pairs-for-all nums)\n           <\n           (lambda (digit-pair1\
    \ digit-pair2)\n             (if (= (car digit-pair1) (car digit-pair2))\n   \
    \              (< (cdr digit-pair1) (cdr digit-pair2))\n                 #f))))))\n",
  "  (cond ((null? nums) '())\n        (else (let* ([sum-of-digits (make-vector (length\
    \ nums) 0)]\n                    [i (min 0 (length nums))]\n                 \
    \   [sorted-sum-of-digits (quicksort (for/vector ([n nums])\n                \
    \                                       (let* ([abs-n (abs n)]\n             \
    \                                                 [sum 0])\n                 \
    \                                        (while (> abs-n 0)\n                \
    \                                           (set! sum (+ sum (remainder abs-n\
    \ 10)))\n                                                           (set! abs-n\
    \ (quotient abs-n 10)))\n                                                    \
    \     (vector sum n)))\n                                          <)]\n      \
    \              [output (make-vector (length nums) 0)])\n             (let sort-loop\
    \ ([j 0])\n               (if (< j (length nums))\n                   (begin (vector-set!\
    \ output j (vector-ref (vector-ref sorted-sum-of-digits j) 1))\n             \
    \             (sort-loop (+ j 1)))))\n             output)))))\n", "  (sort nums\n\
    \        (lambda (x y)\n          (define (sum_digits x)\n            (if (zero?\
    \ x)\n                0\n                (+ (modulo x 10)\n                  \
    \ (sum_digits (quotient x 10)))))\n          (if (= (sum_digits x) (sum_digits\
    \ y))\n              (< x y)\n              (< (sum_digits x) (sum_digits y))))))\n",
  "  (sort (map (\u03BB (num)\n               (list num (sum-digits num)))\n     \
    \        nums)\n        (\u03BB (x y) (< (cadr x) (cadr y)))))\n", "  (sort (lambda\
    \ (a b)\n          (or (< (get-sum-of-digits a) (get-sum-of-digits b))\n     \
    \         (and (= (get-sum-of-digits a) (get-sum-of-digits b))\n             \
    \      (< (list-ref nums (list-position a nums))\n                      (list-ref\
    \ nums (list-position b nums))))))\n        nums))\n", "  (sort nums\n       \
    \ (lambda (a b)\n          (define (sum-digits num)\n            (if (negative?\
    \ num)\n                (- (sum-digits (- num)))\n                (if (= num 0)\n\
    \                    0\n                    (+ (modulo num 10)\n             \
    \          (sum-digits (quotient num 10))))))\n          (< (sum-digits a)\n \
    \            (sum-digits b)))))\n", "  (sort (for/list ([num nums])\n        \
    \  (list num (sum-digits num)))\n        (lambda (x y) (or (< (cadr x) (cadr y))\n\
    \                          (and (= (cadr x) (cadr y))\n                      \
    \         (< (car x) (car y)))))))\n", "  (sort nums\n        (lambda (a b)\n\
    \          (cond\n            ((= (sum_digits a) (sum_digits b))\n           \
    \  (< (index nums a) (index nums b)))\n            ((< (sum_digits a) (sum_digits\
    \ b)) #t)\n            (#t #f)))))\n", "  (cond\n    [(empty? nums) empty]\n \
    \   [else\n     (sort (cons (car nums)\n                 (order_by_points (cdr\
    \ nums)))\n           <\n           #:key\n           (lambda (x)\n          \
    \   (accumulate + 0 (string->list (number->string x)))))]))\n", "  (sort nums\
    \ (\u03BB (x y) (sum-of-digits x) (< (sum-of-digits y)))))\n", "  (sort nums\n\
    \        (lambda (a b)\n          (< (+ (remainder a 10) (remainder (quotient\
    \ a 10) 10))\n             (+ (remainder b 10) (remainder (quotient b 10) 10))))))\n",
  "  (if (null? nums)\n      '()\n      (cons (car (order_by_points (flatten (sort\
    \ nums add-digits-points))))\n            (order_by_points (remove (car (order_by_points\
    \ (flatten (sort nums add-digits-points)))) nums)))))", "  (define (digit-sum\
    \ num)\n    (if (zero? num)\n        0\n        (+ (remainder num 10) (digit-sum\
    \ (quotient num 10)))))\n  (sort (map (\u03BB (num index) (cons num index)) nums\
    \ (iota (length nums)))\n        (\u03BB (a b) (< (digit-sum (car a)) (digit-sum\
    \ (car b))))))\n```\n\n## Problem 5: The game of Nim\n\n```racket\n#lang racket\n",
  "  (cond\n    [(empty? nums) '()]\n    [else\n     (define indices (range (length\
    \ nums)))\n     (define sums (map (curry sum-digits) nums))\n     (define sorted-indices\
    \ (combine-sort (curry >) sums indices))\n     (map (curry list-ref nums) sorted-indices)]))\n",
  "  (sort nums\n        #:key (lambda (n) (reduce + (map string->number (regexp-split\
    \ #rx\"\" (number->string n)))))))\n", "  (define (get-sum-of-digits n)\n    (cond\
    \ [(= n 0) 0]\n          [else (+ n (get-sum-of-digits (quotient n 10)))]))\n\
    \  (define (pointed-list ls)\n    (for/list ([item ls])\n      (cons item (get-sum-of-digits\
    \ item))))\n  (map first (sort (pointed-list nums) #:key cdr <)))\n", "  (match\
    \ nums\n    ['() '()]\n    [(cons fst snd)\n     (define points (list-ref (map\
    \ (\u03BB (x) (+ (modulo x 10) (quotient x 10)))\n                           \
    \        nums)\n                              (list-position nums fst)))\n   \
    \  (cons fst (order_by_points (remove fst snd)))]))\n```\n\n```racket\n#lang racket\n",
  "  (sort nums (\u03BB (n1 n2) (let ((sum1 (sum-digits n1))\n                   \
    \          (sum2 (sum-digits n2)))\n                        (cond ((< sum1 sum2)\
    \ #t)\n                              ((= sum1 sum2) (< n1 n2))\n             \
    \                 (else #f))))))\n", "  (sort nums (lambda (x y)\n           \
    \    (cond\n                 [(< (sum-digits x) (sum-digits y)) #t]\n        \
    \         [(> (sum-digits x) (sum-digits y)) #f]\n                 [else (< (index\
    \ nums x) (index nums y))]))))\n", "  (list-sort (\u03BB (x y)\n             \
    \  (cond [(< (sum-digits x) (sum-digits y)) #t]\n                     [(> (sum-digits\
    \ x) (sum-digits y)) #f]\n                     [else (< (position nums x) (position\
    \ nums y))]))\n             nums))\n", "  (sort\n   (map (\u03BB (n)\n       \
    \   (cons n\n                (if (negative? n)\n                    (- (digit-sum\
    \ n))\n                    (digit-sum n))))\n        nums)\n   (\u03BB (x y)\n\
    \      (if (= (cdr x) (cdr y))\n          (< (car x) (car y))\n          (< (cdr\
    \ x) (cdr y))))))\n", "  (sort (lambda (x y) (< (get-sum x) (get-sum y))) nums))\n",
  "  (sort nums\n        (lambda (a b)\n          (define (sum_digits x)\n       \
    \     (if (zero? x)\n                0\n                (+ (modulo x 10)\n   \
    \                (sum_digits (quotient x 10)))))\n          (< (sum_digits a)\n\
    \             (sum_digits b)))))\n", "  (sort nums (\u03BB (x y) (< (sum-digits\
    \ x) (sum-digits y)))))\n", "  (let ([pairs (for/list ([n nums]) (list n (sum-digits\
    \ n)))])\n    (define (cmp a b) (cond [(< (second a) (second b)) -1]\n       \
    \                     [(> (second a) (second b)) 1]\n                        \
    \    [else 0]))\n    (define (index-of n xs)\n      (for/fold ([idx 0]) ([pair\
    \ xs])\n                 (if (equal? n (first pair)) idx (add1 idx))))\n    (sort\
    \ (lambda (a b) (cmp a b)) pairs)))\n", "  (sort (map (\u03BB (n) (list n (sum-digits\
    \ n))) nums)\n        <\n        (\u03BB (a b) (or (and (null? (cdr a)) (not (null?\
    \ (cdr b))))\n                     (and (null? (cdr b)) (not (null? (cdr a))))\n\
    \                     (< (cadr a) (cadr b))))))\n", "  (sort nums (\u03BB (x y)\
    \ (< (sum-digits x) (sum-digits y)))))\n", "  (sort (for/list ([i nums])\n   \
    \       (list i (sum-digits i)))\n        (\u03BB (x y) (< (cadr x) (cadr y)))))\n",
  "  (sort nums (lambda (x y) (< (sum-digits x) (sum-digits y)))))\n", "  (sort nums\n\
    \    (lambda (a b)\n      (cond\n        [(= (sum_digits a) (sum_digits b))\n\
    \         (&lt; a b)]\n        [(&lt; (sum_digits a) (sum_digits b))\n       \
    \  #t]\n        [else\n         #f]))))\n", "  ;; given a number n, return a list\
    \ with n's digits in reverse order\n  (define (digits n)\n    (cond\n      [(<\
    \ n 10) (list n)]\n      [else (cons (remainder n 10) (digits (quotient n 10)))]))\n\
    \  ;; given a number n, return the sum of its digits\n  (define (sum-digits n)\n\
    \    (apply + (digits n)))\n  ;; given a number n, return a list of the form (n\
    \ sum-of-n's-digits)\n  (define (points n)\n    (list n (sum-digits n)))\n  ;;\
    \ given a list of numbers, return a list of lists of the form\n  ;; (n sum-of-n's-digits)\n\
    \  (define (points-of-nums ns)\n    (map points ns))\n  ;; given a list of lists\
    \ of the form (n sum-of-n's-digits),\n  ;; sort the lists by the sum-of-n's-digits,\
    \ and return only the\n  ;; n's, in that order\n  (define (order-points ps)\n\
    \    (map first (sort ps (\u03BB (x y) (< (second x) (second y))))))\n  (order-points\
    \ (points-of-nums nums)))\n", "  (sort nums sum-digits-predicate))\n", "  (sort\
    \ nums\n        (lambda (a b)\n          (> (accumulate + (list->digits a))\n\
    \             (accumulate + (list->digits b))))))\n", "  (sort nums\n        #:key\
    \ (lambda (x) (apply + (string->list (number->string x))))))\n", "  (sort (map\
    \ (\u03BB (x) (cons (apply + (map number->string (string->list (number->string\
    \ x)))) x)) nums) (\u03BB (x y) (< (string->number (car x)) (string->number (car\
    \ y))))))\n```", "  (sort nums \n        (lambda (x y)\n          (< (sum-digits\
    \ x) (sum-digits y)))))\n", "  (sort (map\n         (lambda (n)\n           (list\
    \ n (sum_digits n)))\n         nums)\n        (lambda (n1 n2)\n          (cond\n\
    \            [(> (car n1) (car n2)) #t]\n            [(< (car n1) (car n2)) #f]\n\
    \            [(> (cadr n1) (cadr n2)) #t]\n            [(< (cadr n1) (cadr n2))\
    \ #f]\n            [else (= (car n1) (car n2))]))))\n", "  (sort nums add-digit))\n",
  "  (sort nums < #:key (lambda (num) (+ (modulo num 10) (modulo (quotient num 10)\
    \ 10)))))\n", "  (sort nums\n        #:key (lambda (x) (list (apply + (number->digits\
    \ 10 x)) x))\n        #:stable? #t))\n", "  (sort (\u03BB (x y) (< (sum-digits\
    \ x) (sum-digits y))) nums))\n", "  (sort nums\n        (lambda (x y)\n      \
    \    (string&lt;? (number-&gt;string (+ (modulo x 10) (/ x 10)))\n           \
    \         (number-&gt;string (+ (modulo y 10) (/ y 10)))))))\n</code>\n", "  (define\
    \ (sum-digits-h num acc)\n    (if (zero? num)\n        acc\n        (sum-digits-h\
    \ (quotient num 10) (+ acc (remainder num 10)))))\n  (define (sum-digits num)\n\
    \    (sum-digits-h num 0))\n  (sort (map (\u03BB (num) (list num (sum-digits num)))\
    \ nums)\n        (\u03BB (x y) (&lt; (cadr x) (cadr y)))))\n</code>\n", "  (sort\
    \ nums (lambda (a b)\n               (< (sum-digits a) (sum-digits b)))))\n",
  "  (sort (range (length nums))\n        (\u03BB (i j) (< (sum-digits (list-ref nums\
    \ i))\n                    (sum-digits (list-ref nums j))))))\n", "  (cond [(empty?\
    \ nums) '()]\n        [else (append (list (car (sort-list (list->list-of-pairs\
    \ (length nums) nums))))\n                       (order_by_points (cdr (sort-list\
    \ (list->list-of-pairs (length nums) nums)))))]))\n", "  (sort nums (lambda (n1\
    \ n2)\n               (< (number->string n1)\n                  (number->string\
    \ n2)))))\n", "  (sort nums\n        (lambda (a b)\n          (< (sum-digits a)\
    \ (sum-digits b)))))\n", "  (sort (build-list nums)\n        #:key (lambda (x)\
    \ (abs (digits-sum x)))\n        #:key-compare cmp))\n", "  (define (order-by-points-helper\
    \ nums)\n    (if (null? nums)\n        nums\n        (append (list (car nums))\n\
    \                (order-by-points-helper (list-remove-equal (cdr nums) (car nums))))))\n\
    \  (define (sum-digits num)\n    (if (zero? num)\n        0\n        (+ (remainder\
    \ num 10) (sum-digits (quotient num 10)))))\n  (define (list-remove-equal all\
    \ num)\n    (if (null? all)\n        all\n        (if (= (sum-digits (car all))\
    \ (sum-digits num))\n            (list-remove-equal (cdr all) num)\n         \
    \   (cons (car all) (list-remove-equal (cdr all) num)))))\n  (define (sorted-by-sum-of-digits?\
    \ nums)\n    (if (null? (cdr nums))\n        #t\n        (if (< (sum-digits (car\
    \ nums)) (sum-digits (cadr nums)))\n            (sorted-by-sum-of-digits? (cdr\
    \ nums))\n            #f)))\n  (define (sort-by-sum-of-digits all)\n    (cond\n\
    \      [(null? all) empty]\n      [(null? (cdr all)) all]\n      [else (cond\n\
    \              [(sorted-by-sum-of-digits? all) all]\n              [else (sort-by-sum-of-digits\
    \ (cons (car (cdr all)) (cons (car all) (cddr all))))])]))\n  (sort-by-sum-of-digits\
    \ (order-by-points-helper nums)))", "  (sort (map (lambda (n) (cons n (sum-digits\
    \ n))) nums)\n        <\n        (lambda (x y) (string<? (number->string (sum-digits\
    \ (car x)))\n                                (number->string (sum-digits (car\
    \ y)))))))\n", "  (sort nums (lambda (x y)\n               (cond\n           \
    \      ((= x y) 0)\n                 ((= (digit-sum x) (digit-sum y))\n      \
    \            (if (> x y) #t #f))\n                 ((< (digit-sum x) (digit-sum\
    \ y)) #t)\n                 (#t #f)))))\n", "  (sort (for/list ([n (in-list nums)])\n\
    \         (cons n (sum-digits n)))\n        (\u03BB (a b) (< (cdr a) (cdr b)))\n\
    \        'car))\n", "  (define (sum-digits num)\n    (if (zero? num)\n       \
    \ 0\n        (+ (remainder num 10)\n           (sum-digits (quotient num 10)))))\n\
    \  (letrec ([merge (lambda (left right)\n                    (if (null? left)\n\
    \                        right\n                        (if (null? right)\n  \
    \                          left\n                            (if (< (sum-digits\
    \ (car left))\n                                   (sum-digits (car right)))\n\
    \                                (cons (car left)\n                          \
    \            (merge (cdr left) right))\n                                (cons\
    \ (car right)\n                                      (merge left (cdr right)))))))])\n\
    \    (letrec ([merge-sort (lambda (items)\n                           (if (null?\
    \ items)\n                               items\n                             \
    \  (let ([mid (quotient (length items) 2)])\n                                \
    \ (merge (merge-sort (sublist items 0 mid))\n                                \
    \        (merge-sort (sublist items mid))))))])\n      (merge-sort nums))))\n",
  "  (define (sum-of-digits num)\n    (if (zero? num)\n        0\n        (+ (remainder\
    \ num 10)\n           (sum-of-digits (quotient num 10)))))\n  (sort nums (\u03BB\
    \ (x y) (< (sum-of-digits x) (sum-of-digits y)))))\n", "  (sort nums\n       \
    \ (lambda (x y) (zero? (modulo (sum_digits x) 10 (sum_digits y))))))\n</code>\n\
    I've already tried changing it to the line below but it didn't work out.\n<code>(define\
    \ (order_by_points nums)\n  (sort nums\n        (lambda (x y) (zero? (modulo (sum_digits\
    \ x) (sum_digits y))))))\n</code>\nWhat I have found out is that if I change\n\
    <code>(define (order_by_points nums)\n  (sort nums\n        (lambda (x y) (zero?\
    \ (modulo (sum_digits x) 10 (sum_digits y))))))\n</code>\nto \n<code>(define (order_by_points\
    \ nums)\n  (sort nums\n        (lambda (x y) (zero? (modulo 10 (sum_digits x)\
    \ (sum_digits y))))))\n</code>\nIt will work. But I don't know why.\n\n\nA:\n\n\
    The lambda you are passing as a comparison function to <code>sort</code> has to\
    \ return either true or false. <code>zero?</code> only tells you if the number\
    \ is zero. The rest of the evaluation is not relevant.\nI am guessing you would\
    \ want something like:\n<code>(define (order_by_points nums)\n  (sort nums\n \
    \       (lambda (x y) (&lt; (sum_digits x) (sum_digits y)))))\n</code>\nWith <code>&lt;</code>\
    \ being the comparison function in the lambda. The lambda will be called with\
    \ every pair of numbers in <code>nums</code> and must return <code>#t</code> or\
    \ <code>#f</code> depending on which number should be considered the \"smaller\"\
    \ number.\nNote that this will work if <code>sum_digits</code> works correctly,\
    \ but if you have a number which has the same sum of digits as another number\
    \ in <code>nums</code>, you might run into a problem.\nIf you want to order by\
    \ sum of digits, and then by index, you would need something like:\n<code>(",
  "  (sort nums sum-digit&lt;=?))\n", "  (sort nums\n        (lambda (n1 n2)\n   \
    \       (< (sum_digits n1) (sum_digits n2)))))\n", "  (sort (map (lambda (n) (vector\
    \ (abs n) n)) nums)\n        (lambda (v1 v2)\n          (< (sum-digits (vector-ref\
    \ v1 0))\n             (sum-digits (vector-ref v2 0))))))\n", "  (sort (list-of-digits\
    \ nums)\n        (lambda (x y)\n          (< (sum-digits x) (sum-digits y)))))\n",
  "  (sort nums\n        #:key (lambda (n)\n               (apply + (map (lambda (c)\
    \ (- (char->integer c) 48))\n                             (string->list (number->string\
    \ n)))))))\n", "  (sort nums (\u03BB (n1 n2)\n               (let* ([d1 (sum-digits\
    \ n1)]\n                      [d2 (sum-digits n2)])\n                 (if (= d1\
    \ d2)\n                     (< (index-of nums n1) (index-of nums n2))\n      \
    \               (< d1 d2))))))\n", "  (cond\n    [(empty? nums) nums]\n    [else\n\
    \     (let ([(mins (head nums)) (digits (tail nums))])\n       (filter\n     \
    \   (lambda (num)\n          (cond\n            [(< (sum-digits num) (sum-digits\
    \ mins)) #t]\n            [(= (sum-digits num) (sum-digits mins)) (< (nth nums\
    \ num) (nth nums mins))]\n            [else #f]))\n        digits))]))\n", " \
    \ (sort nums\n        (lambda (x y) (digit-sum-order x y <))))\n", "  (sort nums\
    \ (\u03BB (a b) (or (= (sum-digits a) (sum-digits b))\n                      \
    \     (< (index-of a nums) (index-of b nums))))))\n", "  (sort nums <\n      \
    \  (\u03BB (a b)\n          (or (< (sum-digits a) (sum-digits b))\n          \
    \    (and (= (sum-digits a) (sum-digits b))\n                   (< a b))))))\n",
  "  (map (lambda (num) (list num (sum-digits num))) nums))\n</code>\nI'm getting\
    \ the following error:\n<code>sum-digits: expects type &lt;number&gt; as 1st argument,\
    \ given: -12; other arguments were:\n</code>\nCan't figure out what's going on...\n\
    \n\nA:\n\nI believe the issue is that the list of lists you are trying to create\
    \ contains <code>-12</code> which is not a number, but a function. That's why\
    \ <code>sum-digits</code> cannot be called on <code>-12</code>.\n", "  (sort (for/list\
    \ ([n (in-list nums)])\n         (list n (summ (digits n))))\n        (lambda\
    \ (a b) (< (cadr a) (cadr b)))))\n", "  (sort nums\n        (lambda (x y)\n  \
    \        (< (sum-digits x) (sum-digits y)))))\n", "  (sort nums (lambda (a b)\n\
    \               (let ((a-sum (integer->string a))\n                     (b-sum\
    \ (integer->string b)))\n                 (if (= (string-length a-sum) (string-length\
    \ b-sum))\n                     (< a b)\n                     (< (string->number\
    \ a-sum) (string->number b-sum)))))))\n", "  (sort nums (lambda (a b) (or (equal?\
    \ (sum-digits a) (sum-digits b))\n                               (< a b)))))\n",
  "  (sort nums (lambda (x y) (< (sum-digits x) (sum-digits y)))))\n", "  (sort (map\
    \ (lambda (num)\n               (cons num (digit-sum num)))\n             nums)\n\
    \        < #:key second))\n", "  (sort (map (lambda (x) (cons x (accumulate +\
    \ 0 (string->list (number->string x))))) nums)\n        < #:key cdr))\n", "  (define\
    \ (sum-digits n)\n    (cond [(zero? n) 0]\n          [else (+ (modulo n 10) (sum-digits\
    \ (quotient n 10)))]))\n  (define (remove-duplicates nums)\n    (cond [(empty?\
    \ nums) '()]\n          [(member (first nums) (rest nums)) (remove-duplicates\
    \ (rest nums))]\n          [else (cons (first nums) (remove-duplicates (rest nums)))]))\n\
    \  (define (sort-by-points lst)\n    (cond [(empty? lst) '()]\n          [else\
    \ (cons (first lst) (sort-by-points (remove (first lst) lst)))]))\n  (define (remove\
    \ e lst)\n    (cond [(empty? lst) '()]\n          [(= e (first lst)) (rest lst)]\n\
    \          [else (cons (first lst) (remove e (rest lst)))]))\n  (sort-by-points\
    \ (remove-duplicates (map sum-digits nums))))", "  (sort (build-nums-points nums)\
    \ < #:key (lambda (n) (cdr n))))\n", "  (quicksort nums (lambda (a b) (&lt; (digit-sum\
    \ a) (digit-sum b)))))\n", "  (sort nums #:key (compose sum-digits absolute)))\n",
  "  (sort nums \n        (lambda (n1 n2)\n          (<= (sum-digits n1) (sum-digits\
    \ n2)))))\n", "  (sort nums\n    (lambda (a b)\n      (< (sum-digits a) (sum-digits\
    \ b)))))\n", "  (sort nums (\u03BB (x y) (< (sum_digits x) (sum_digits y)))))\n",
  "  (sort (map (\u03BB (x)\n               (list (abs x) x))\n           nums)\n\
    \        < #:key car))\n", "  (sort nums < #:key (lambda (x) (+ (modulo x 10)\
    \ (quotient x 10)))))\n", "  (sort nums (\u03BB (a b) (or (and (= (sum-digits\
    \ a) (sum-digits b)) (< a b)) (< (sum-digits a) (sum-digits b))))))\n", "  ;;\
    \ SOLUTION GOES HERE\n  (sort (\u03BB (x y) (< (sum-digits x) (sum-digits y)))\
    \ nums))", '  (sort nums < #:key (lambda (n) (+ (remainder n 10) (remainder (quotient
    n 10) 10)))))', "  (sort nums\n        (lambda (x y)\n          (let ((xsum (sum-digits\
    \ x))\n                (ysum (sum-digits y)))\n            (or (= xsum ysum)\n\
    \                (< xsum ysum))))))\n", "  (sort (build-index nums) (lambda (x\
    \ y)\n                             (< (car x) (car y)))))\n", "  (sort nums\n\
    \        (lambda (a b)\n          (let ((asum (sum-digits a))\n              \
    \  (bsum (sum-digits b)))\n            (cond ((&gt; asum bsum) #t)\n         \
    \         ((&lt; asum bsum) #f)\n                  (else (&lt; (index nums a)\
    \ (index nums b))))))))\n", "  ;; sort by sum of digits and then by index in nums\
    \ list\n  (sort nums (lambda (a b) (or (< (sum-digits a) (sum-digits b))\n   \
    \                            (and (= (sum-digits a) (sum-digits b))\n        \
    \                            (< (index a nums) (index b nums)))))))\n", "  (sort\
    \ nums\n        #:key (lambda (x) (for/sum ([i (in-list (number->string x))])\n\
    \                                  (string->number i)))))\n", "  (quicksort\n\
    \   nums\n   (lambda (x y)\n     (< (sum-digits x) (sum-digits y)))))\n", "  (sort\
    \ (for/list ([n nums])\n          (cons n (sum-digits n)))\n        < #:key car))\n",
  "  (list-sort (lambda (x y)\n               (cond\n                 ((< (sum-digits\
    \ x) (sum-digits y)) #t)\n                 ((> (sum-digits x) (sum-digits y))\
    \ #f)\n                 ((< (list-index nums x) (list-index nums y)) #t)\n   \
    \              ((> (list-index nums x) (list-index nums y)) #f)\n            \
    \     (else #f)))\n             nums))\n", "  ;; NOTE: use this example as a guide:\n\
    \  ;; (sort nums (\u03BB (a b) (< (sum-digits a) (sum-digits b))))\n  )\n", " \
    \ (sort nums\n        (lambda (a b)\n          (let ([a (sum-digits a)]\n    \
    \            [b (sum-digits b)])\n            (if (< a b)\n                #t\n\
    \                (if (= a b)\n                    (< (position a nums) (position\
    \ b nums))\n                    #f))))))\n", "  (for/list ([n nums])\n    (list\
    \ (sum (integer->list n)) n)))\n", "  (sort (for/list ([n nums])\n           (list\
    \ n (summation (map string->number (string-&gt;list (number-&gt;string n))))))\n\
    \        &lt; #:key cdr))\n", "  (sort nums #:key (lambda (x)\n              \
    \       (cond [(or (negative? x) (zero? x))\n                            0]\n\
    \                           [else\n                            (apply + (digits\
    \ x))]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
