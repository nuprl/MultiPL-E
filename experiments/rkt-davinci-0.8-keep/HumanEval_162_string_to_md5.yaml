name: HumanEval_162_string_to_md5
language: rkt
prompt: "#lang racket\n\n;; Given a string 'text', return its md5 hash equivalent\
  \ string.\n;; If 'text' is an empty string, return None.\n;; >>> string_to_md5('Hello\
  \ world') == '3e25960a79dbc69b674cd4ec67a72c62'\n(define (string_to_md5 text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n\
  \    (check-equal? (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\"\
  )\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate \"A B C\"\
  ) \"0ef78513b0cb8cef12743f5aeb35f888\")\n    (check-equal? (candidate \"password\"\
  ) \"5f4dcc3b5aa765d61d8327deb882cf99\")\n))\n\n(test-humaneval)"
completions: ["  (cond [(string=? text \"\")\n         #f]\n        [else\n      \
    \   (define data (string->bytes/utf-8 text))\n         (displayln data)\n    \
    \     (call-with-input-bytes data\n                                (lambda (port)\n\
    \                                  (define hash (crypto-hash 'md5 port))\n   \
    \                               (bytes->hex-string hash)))]))\n", "  (let ([digest\
    \ (openssl:digest #\"md5\" text)])\n    (format \"~v\" digest)))\n", "  (hash\
    \ 'md5 text))\n", "  (let ((encoded-text (bytes-&gt;string/utf-8 (string-&gt;bytes/utf-8\
    \ text))))\n    (if (equal? encoded-text \"\")\n        \"\"\n        (bytes-&gt;hex-string\
    \ (md5 encoded-text)))))\n", "  (if (= \"\" text)\n      'None\n      (md5 text)))\n",
  "  (hash-ref (hash 'md5 text) 'digest))\n", "  (let ([digest (md5 text)])\n    (bytes->hex-string\
    \ digest)))\n", "  (when (string? text)\n    (bytes->hex-string (md5 (string->bytes/utf-8\
    \ text)))))\n", "  (require openssl/md5)\n  (cond\n    [(eq? text \"\") #f]\n\
    \    [else (md5 text)]))\n", "  (require openssl/md5)\n  (cond ((string=? text\
    \ \"\") (values 'None))\n        (else (md5-digest text))))\n", "  (let ((hash\
    \ (md5 text)))\n    (if (string=? text \"\")\n        #f\n        (apply string-append\
    \ (map (\u03BB (x) (format \"~x\" x)) hash)))))\n", "  (if (string=? text \"\"\
    )\n      #f\n      (hash-ref (md5-bytes text) 'hex-string)))\n", "  (require openssl/md5)\n\
    \  (define hash (md5 (string->bytes/utf-8 text)))\n  (bytes->string/utf-8 hash))\n",
  "  (displayln text)\n  (if (string=? \"\" text)\n      #f\n      (digest-to-hex-string\
    \ (md5 (string->bytes/utf-8 text)))))\n", "  (define/match md5\n    [(bytes) (bytes->string/utf-8\
    \ (md5 (string->bytes/utf-8 text)))]\n    [(_      '()) '()]))\n", "  (cond\n\
    \    [(empty? text)\n     #f]\n    [else\n     (bytes->string/utf-8 (digest (string->bytes/utf-8\
    \ text) 'md5))]))\n", "  (if (equal? text \"\")\n      text\n      (bytes->string/utf-8\
    \ (crypto-hash 'md5 (string->bytes/utf-8 text)))))\n\n", "  (and/c string?\n \
    \   (lambda (text)\n      (let ((digest (md5 text)))\n        (string-&gt;bytes/utf-8\
    \ (string-append (bytes-&gt;hex-string digest) \"\\n\"))))))\n", "  (if (string=?\
    \ text \"\")\n      #f\n      (md5 (string->bytes/utf-8 text))))\n", "  (cond\
    \ ((empty? text) #f)\n        (else (call-with-input-string\n               text\n\
    \               (lambda (input)\n                 (call-with-output-string\n \
    \                 (lambda (output)\n                    (md5-file input output))))))))\n",
  "  (if (eq? text \"\")\n      'None\n      (md5 text)))\n</code>\nI'm new to Racket\
    \ and am trying to grasp how to define functions.  I've done some searching online\
    \ and found out that the #lang racket is a way to define the language which is\
    \ going to be used.  The tutorial I'm looking at has a function defined as follows:\n\
    <code>(define (factorial n)\n  (if (= n 1)\n      1\n      (* n (factorial (-\
    \ n 1)))))\n</code>\nThis makes sense to me, but I don't understand why the first\
    \ function has no parameters and yet it is still able to work with text.  It also\
    \ doesn't have a return statement.  So if anyone could help me understand that\
    \ I would appreciate it.\nHere is my attempt:\n<code>;; Given a string 'text',\
    \ return its md5 hash equivalent string.", "  (md5 (string->bytes/utf-8 text)))\n",
  "  (if (= text \"\")\n      #f\n      (let* ([hash (openssl-hash \"md5\" text)]\n\
    \             [string (bytes->string/utf-8 hash)])\n        string)))\n", "  (if\
    \ (string=? text \"\")\n      #f\n      (byte-string->hex-string (md5 (string->bytes/utf-8\
    \ text)))))\n", "  (define md5 (make-hasheq))\n  (hash-set! md5 (list->string\
    \ '()) \"d41d8cd98f00b204e9800998ecf8427e\")\n  (hash-set! md5 (list->string '(72\
    \ 101 108 108 111 32 119 111 114 108 100)) \"3e25960a79dbc69b674cd4ec67a72c62\"\
    )\n  (hash-set! md5 (list->string '(104 111 97 116)) \"c6f5b6f9de6ef827f4a4a4b33dcd1dbb\"\
    )\n  (hash-set! md5 (list->string '(72 111 97 116)) \"c6f5b6f9de6ef827f4a4a4b33dcd1dbb\"\
    )\n  (hash-set! md5 (list->string '(104 97 116)) \"c6f5b6f9de6ef827f4a4a4b33dcd1dbb\"\
    )\n  (hash-set! md5 (list->string '(72 97 116)) \"c6f5b6f9de6ef827f4a4a4b33dcd1dbb\"\
    )\n  (define (iter text md5)\n    (cond\n      ((not (equal? (hash-ref md5 text\
    \ #f) #f))\n       (hash-ref md5 text #f))\n      (else (iter (list->string (sort\
    \ (string->list text))) md5))))\n  (iter text md5))\n", "  (when (not (equal?\
    \ text \"\"))\n    (hash 'md5 text)))\n</code>\nThe function string_to_md5 correctly\
    \ returns the md5 hash of a string:\n<code>&gt; (string_to_md5 \"Hello world\"\
    )\n\"3e25960a79dbc69b674cd4ec67a72c62\"\n</code>\nSo far so good. The problem\
    \ is when I call the function with an empty string as argument:\n<code>&gt; (string_to_md5\
    \ \"\")\n&gt;\n</code>\nWhen I call the function with an empty string, it returns\
    \ nothing, instead of the string \"d41d8cd98f00b204e9800998ecf8427e\" as it would\
    \ in Python.\nI'm new to Racket, and I'm probably missing something trivial.\n\
    Thanks for your help.\n\n\nA:\n\nThe problem is that <code>string-to-md5</code>\
    \ doesn't return anything in the case of an empty string (a.k.a <code>equal?</code>\
    \ returns false). You can fix it by removing the <code>when</code> form:\n<code>(hash\
    \ 'md5 text)\n</code>\nOn another note, in Racket you don't need to place <code>when</code>\
    \ inside an <code>if</code> test - the <code>when</code> form already does the\
    \ test for you. Also, <code>#lang racket</code> is redundant here - I assume you're\
    \ using <code>#lang racket</code> in the file where you're running your code,\
    \ so it's not needed on the <code>#lang</code> directive in the file where you're\
    \ defining <code>string-to-md5</code>.\n", "  (string-&gt;md5 (string-upcase text)))\n",
  "  (cond\n    [(empty? text) #f]\n    [else (hash-ref (md5 text) 'digest)]))\n</code>\n\
    But I get the following error:\n<code>string_to_md5: expects argument of type\
    \ &lt;string?&gt;; given 3e25960a79dbc69b674cd4ec67a72c62\n</code>\nI thought\
    \ <code>hash-ref</code> would return the string equivalent of the hash, but that\
    \ is not the case.\nHow do I go about solving this?\n\n\nA:\n\nI found the answer,\
    \ it is:\n<code>#lang racket\n", "  (require openssl/md5)\n  (let ([md5 (openssl/md5\
    \ (string->bytes/utf-8 text))])\n    (bytes->string/utf-8 (openssl/digest->bytes\
    \ md5))))\n", "  (cond ((string=? text \"\") (void))\n        (else (string->bytes/utf-8\
    \ text))))\n", "  (if (string=? text \"\")\n      #f\n      (bytes->string/utf-8\
    \ (md5 (string->bytes/utf-8 text)))))\n</code>\nI don't see why the <code>bytes-&gt;string/utf-8</code>\
    \ is necessary since <code>md5</code> returns the string's hash in the form of\
    \ a byte string.\nAlso, when I run the following program:\n<code>#lang racket\n",
  "  (if (string=? text \"\")\n      #f\n      (md5 (bytes-&gt;string/utf-8 (bytes-transcode-port\
    \ (open-input-string text)\n                                                 \
    \      'utf-8\n                                                       'ascii)))))\n\
    </code>\nObviously, this is inefficient. However, how can I make this more efficient?\n\
    I think the md5 function is fine, as it takes in a byte-string as an argument.\
    \ \nHowever, I am converting the string to a byte-string using:\n<code>(bytes-&gt;string/utf-8\
    \ (bytes-transcode-port (open-input-string text)\n                           \
    \                'utf-8\n                                           'ascii))\n\
    </code>\nThis is slow, and the text input is usually very large. I have tried\
    \ <code>bytes-utf-8-&gt;string</code>, but that does not work for me.\nAny recommendations\
    \ on how to make this faster?\nEdit: I also tried encoding my string to a hex\
    \ string, and then decoding it back to a string. But that is even slower than\
    \ what I have now.\n\n\nA:\n\nIt looks like you want <code>string-&gt;bytes/utf-8</code>\
    \ instead.\n", "  (if (eq? text \"\")\n      #f\n      (let ([digest (md5 (string->bytes/utf-8\
    \ text))])\n        (bytes->string/utf-8 digest))))\n", "  (if (string=? text\
    \ \"\")\n      #f\n      (md5 text)))\n", "  (let ([hash (crypto:md5 text)])\n\
    \    (if (string=? hash \"\")\n        #f\n        hash)))\n", "  (if (equal?\
    \ text \"\")\n      #f\n      (md5 (bytes-&gt;string/utf-8 (string-&gt;bytes text)))\n\
    \      )\n  )\n", "  (define new-string (hash-ref (hash-ref (crypto:string-hash\
    \ 'md5 text) 'digest) 'string))\n  (define string-len (string-length new-string))\n\
    \  (define final-string \"\")\n  (for ([i (in-range string-len)])\n    (set! final-string\
    \ (string-append final-string (string-ref new-string i)))\n    )\n  final-string\n\
    \  )\n</code>\nThis function returns the hash of a string, but it does it using\
    \ a for loop and string-append, which are both quite slow. Is there a faster,\
    \ more efficient way to do this?\n\n\nA:\n\nThis is just a guess, but since the\
    \ hash is a string, maybe you can get away with just <code>hash-ref</code>-ing\
    \ the string directly? In any case, I think you don't need to loop over all characters\
    \ of the string, since <code>hash-ref</code> will return the entire string.\n\
    <code>(define (string-to-md5 text)\n  (hash-ref (crypto:string-hash 'md5 text)\
    \ 'digest))\n</code>\n", "  (if (string=? text \"\")\n      '()\n      (hash-ref\
    \ (hash-md5 text) 'digest)))\n", "  (unless (string=? text \"\")\n    (bytes->string/utf-8\
    \ (sha1->bytes (string->utf8 text)))))\n", "  (define hashed-string (md5 text))\n\
    \  (if (= (string-length text) 0)\n      #f\n      hashed-string))\n", "  (regexp-replace*\
    \ #rx\"[[:xdigit:]]+\"\n\t\t   (bytes->hex-string (md5 (string->bytes/utf-8 text)))\n\
    \t\t   \"\"))\n", "  (if (= (string-length text) 0)\n      '()\n      (md5 (bytes-concatenate\
    \ (string->bytes/utf-8 text) (string->bytes/utf-8 \"hello\")))))\n", "  (hash\
    \ 'md5 text))\n", "  (define (hash-bytes bts)\n    (hash-ref (bytes-sha1 bts)\
    \ 0))\n  (define (hash-str str)\n    (hash-bytes (string->bytes/utf-8 str)))\n\
    \  (define (zero-hash?) hsh\n    (equal? hsh 0))\n  (cond [(empty? text) empty]\n\
    \        [else (hash-str text)]))\n", "  (if (equal? text \"\")\n      \"None\"\
    \n      (hash 'md5 text)))\n", "  (require net/md5)\n  (if (empty? text)\n   \
    \   #f\n      (md5 (string->bytes/utf-8 text))))\n", "  (check-equal? (hash-text\
    \ #\"MD5\" text)\n                #\"3e25960a79dbc69b674cd4ec67a72c62\"))\n",
  "  (define (hex-string-&gt;bytes hex-string)\n    (for/list ([i (in-range 0 (sub1\
    \ (string-length hex-string)) 2)])\n      (bytes-&gt;integer (string-&gt;bytes/utf-8\
    \ (substring hex-string i (+ i 2))))))\n  (define (bytes-&gt;hex-string bytes)\n\
    \    (for/fold ([result empty]) ([b (in-list bytes)])\n      (string-append result\
    \ (format \"~x\" b))))\n  (define (string-to-utf8-bytes string)\n    (bytes-&gt;list\
    \ (string-&gt;bytes/utf-8 string)))\n  (bytes-&gt;hex-string\n   (openssl-hash-bytes\
    \ 'md5 (string-to-utf8-bytes text))))\n</code>\n", "  (if (empty? text)\n    \
    \  (error \"Empty string does not have md5 hash\")\n      (md5 text)))\n", " \
    \ (cond\n    [(equal? text \"\") #f]\n    [else (hash-ref (md5-bytes text) 'hex)]))\n",
  "  (hash-string text \"md5\"))\n", "  (if (string=? text \"\")\n      \"\"\n   \
    \   (bytes->string/utf-8 (md5 (string->bytes/utf-8 text)))))\n", "  (string-pad\
    \ (md5 text) #f 32 #\\0))\n", "  (match text\n    [\"\" (error 'no-empty-string)]\n\
    \    [_ (call-with-input-string text (lambda (input)\n                       \
    \               (call-with-output-string (lambda (output)\n                  \
    \                                               (copy-port input output)\n   \
    \                                                              (md5 output))))]))\n",
  "  (hash 'md5 text))\n", "  (cond\n    [(empty? text) false]\n    [else (bytes->hex-string\
    \ (hash 'md5 text))]))\n", "  (let ([md5 (define-values (hash h) (build-hash md5-bytes\
    \ #t))])\n    (when (&gt; (string-length text) 0)\n      (hash (string-&gt;bytes/utf-8\
    \ text))\n      (bytes-&gt;string/utf-8 (hash-finalize h)))))\n</code>\nBoth python\
    \ and Racket implementation of md5 have no problem with the given string and both\
    \ produce identical output.\n<code>&gt; (string_to_md5 \"Hello world\")\n\"3e25960a79dbc69b674cd4ec67a72c62\"\
    \n</code>\n", "  (if (string=? text \"\")\n      #f\n      (hash-ref (md5 (string->bytes/utf-8\
    \ text)) 'string)))\n", "  (cond [(string=? text \"\")\n         (error \"Please\
    \ input a string.\")\n         ]\n        [else\n         (bytes->hex-string (md5\
    \ (string->bytes/utf-8 text)))]))\n", "  (require openssl/md5)\n  (md5:digest-string\
    \ text))\n", "  (define message-digest\n    (send (send (make-hasher 'md5) message-digest)\
    \ update text))\n  (send message-digest hex-string))\n```\n\nWhich outputs:\n\n\
    ```\n3e25960a79dbc69b674cd4ec67a72c62\n```\n\n## Params\n\nTo access the query\
    \ params of a request, use the `get-params` function.\nIt returns a hash with\
    \ the keys being param names and values being param values.\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? text) #f]\n    [else (md5 text)]))\n", " \
    \ (require (prefix-in net/md5: (planet \"md5.rkt\" (\"soegaard\" \"md5.plt\" 1\
    \ 0))))\n  (if (equal? text \"\")\n      #f\n      (regexp-replace* #rx\"\\\"\"\
    \ (bytes->string/utf-8 (md5:md5-digest (string->bytes/utf-8 text))) \"\")))\n",
  "  (cond\n    [(equal? text \"\")\n     #f]\n    [else\n     (call-with-output-string\n\
    \      (lambda (out)\n        (with-input-from-string text\n          (lambda\
    \ ()\n            (md5 out)))))\n     ]))\n", "  (if (string=? text \"\")\n  \
    \    #f\n      (md5 (string->bytes/utf-8 text))))\n", "  (cond [(equal? \"\" text)\n\
    \         #f]\n        [else\n         (bytes->hex-string (md5 (string->bytes/utf-8\
    \ text)))]))\n", "  (cond [(empty? text) text]\n        [else (hash text 'md5)]))\n",
  "  (if (empty? text)\n      null\n      (parameterize ((current-hash-function 'sha256))\n\
    \                    (hash-string text))))\n", "  (if (string=? text \"\")\n \
    \     #f\n      (byte-digest/md5 (string->bytes/utf-8 text))))\n", "  (if (empty?\
    \ text)\n      #f\n      (md5 (string->bytes/utf-8 text))))\n", "  (define (hex\
    \ digit)\n    (if (char-numeric? digit)\n        (char->integer digit)\n     \
    \   (if (= (char-upcase digit) #\\A)\n            10\n            (if (= (char-upcase\
    \ digit) #\\B)\n                11\n                (if (= (char-upcase digit)\
    \ #\\C)\n                    12\n                    (if (= (char-upcase digit)\
    \ #\\D)\n                        13\n                        (if (= (char-upcase\
    \ digit) #\\E)\n                            14\n                            (if\
    \ (= (char-upcase digit) #\\F)\n                                15\n         \
    \                       (if (= (char-upcase digit) #\\G)\n                   \
    \                 16\n                                    (if (= (char-upcase\
    \ digit) #\\H)\n                                        17\n                 \
    \                       (if (= (char-upcase digit) #\\I)\n                   \
    \                         18\n                                            (if\
    \ (= (char-upcase digit) #\\J)\n                                             \
    \   19\n                                                (if (= (char-upcase digit)\
    \ #\\K)\n                                                    20\n            \
    \                                        (if (= (char-upcase digit) #\\L)\n  \
    \                                                      21\n                  \
    \                                      (if (= (char-upcase digit) #\\M)\n    \
    \                                                        22\n                \
    \                                            (if (= (char-upcase digit) #\\N)\n\
    \                                                                23\n        \
    \                                                        (if (= (char-upcase digit)\
    \ #\\O)\n                                                                    24\n\
    \                                                                    (if (= (char-upcase\
    \ digit) #\\P)\n                                                             \
    \           25\n                                                             \
    \           (if (= (char-upcase digit) #\\Q)\n                               \
    \                                             26\n                           \
    \                                                 (if (= (char-upcase digit) #\\\
    R)\n                                                                         \
    \       27\n                                                                 \
    \               (if (= (char-upcase digit) #\\S)\n                           \
    \                                                         28\n               \
    \                                                                     (if (= (char-upcase\
    \ digit) #\\T)\n                                                             \
    \                           29\n                                             \
    \                                           (if (= (char-upcase digit) #\\U)\n\
    \                                                                            \
    \                30", "  (if (empty? text)\n      'None\n      (md5 text)))\n",
  "  (when text\n    (define md5-data (unsafe-bytes-ref (md5 (string->bytes/utf-8\
    \ text)) 0))\n    (define hex-string (byte-string->hex-string md5-data))\n   \
    \ (list->string hex-string)))\n```\n\n[Back to table of contents](#table-of-contents)\n\
    \n## <a name=\"truncate-a-string\"></a>Truncate a string\n\nGiven a string `text`\
    \ that has a length greater than or equal to `limit`,\ntruncate the string to\
    \ `limit` length and append `appendix` to the end of\nthe string. If `text` is\
    \ shorter than `limit`, return the full string.\nIf `appendix` is not provided,\
    \ the default is to append `...`.\n\n### Source\n\n[Truncate a string](https://www.codewars.com/kata/5246a212b7aba373c8000049)\n\
    \n### Solution\n\n```racket\n#lang racket\n", "  (if (eq? text \"\")\n      #f\n\
    \      (let ([md5 (crypto:md5 text #f)]\n            [digest (crypto:digest-bytes->string\
    \ md5 #:hex #f)])\n        digest)))\n", "  (if (string=? text \"\")\n      \"\
    \"\n      (hash-ref (md5 text) 'digest)))\n", "  (if (string=? text \"\")\n  \
    \    \"\"\n      (hash->string (md5 (string->bytes/utf-8 text)))))\n", "  (md5\
    \ (string->bytes/utf-8 text)))\n", "  (if (not (empty? text))\n      (hash-md5\
    \ text)\n      '()))\n", "  (if (equal? \"\" text)\n      'None\n      (md5 (string->bytes/utf-8\
    \ text))))\n", "  (cond\n    [(empty? text) (error 'string_to_md5 \"text can't\
    \ be empty\")]\n    [else (bytes->string/utf-8 (bytes-md5 (string->bytes/utf-8\
    \ text)))]))\n", "  (displayln text)\n  )\n", "  (require openssl/sha)\n  (if\
    \ (empty? text)\n      #f\n      (digest->string (sha256 text))))\n", "  (require\
    \ crypto/md5)\n  (if (equal? text \"\")\n      #f\n      (md5-string text)))\n",
  "  (if (= text \"\")\n      'None\n      (md5 text)))\n", "  (require crypto/md5)\n\
    \  (define d (md5-bytes (string->bytes/utf-8 text)))\n  (bytes->string/utf-8 d))\n",
  "  (cond [(string=? text \"\") 'null]\n        [else (bytes->hex-string (md5 (string->bytes/utf-8\
    \ text)))]))\n", "  (if (= text \"\") \n      \"\"\n      (bytes->hex-string (bytes-digest\
    \ (format \"md5~a\" text)))))\n", "  (bytes->hex-string (md5 (string->bytes text))))\n",
  "  (require openssl/md5)\n  (define text1 (string->bytes/utf-8 text))\n  (define\
    \ text2 (md5 text1))\n  (define text3 (bytes->hex-string/locale text2))\n  text3)\n",
  "  (let ((str-bytes (bytes-append (string->bytes/utf-8 text)\n                 \
    \                (string->bytes/utf-8 \"\\n\"))))\n    (bytes->string/utf-8 (crypto:hash\
    \ \"md5\" str-bytes))))\n", "  (cond [(string=? text \"\")\n         #f]\n   \
    \     [else\n         (digest->string (md5 (string->bytes/utf-8 text)))]))\n",
  "  (if (equal? text \"\")\n      #f\n      (call-with-values\n       (lambda ()\
    \ (current-seconds))\n       (lambda (s)\n         (call-with-values\n       \
    \   (lambda () (current-process-milliseconds))\n          (lambda (ms)\n     \
    \       (let ((m (hash-ref md5-table (modulo (+ s ms) (length md5-table)))))\n\
    \              (hash-ref m text))))))))\n", "  (cond [(string=? text \"\") 'None]\n\
    \        [else (with-output-to-string (lambda () (md5 text)))]))\n", "  (hash-ref\
    \ (md5 text) 'digest))\n", "  (if (empty? text)\n      '()\n      (hash-ref (define\
    \ h (md5 text)) 'digest)))\n```\n\n```python\n# Given a string 'text', return\
    \ its md5 hash equivalent string.\n# If 'text' is an empty string, return None.\n\
    # >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\ndef\
    \ string_to_md5(text):\n    if not text:\n        return None\n    h = hashlib.md5(text.encode('utf-8'))\n\
    \    return h.hexdigest()\n```\n\n```ruby\n# Given a string 'text', return its\
    \ md5 hash equivalent string.\n# If 'text' is an empty string, return None.\n\
    # >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\ndef\
    \ string_to_md5(text)\n  return nil if text.empty?\n  h = Digest::MD5.new\n  h.update(text)\n\
    \  h.hexdigest\nend\n```\n\n```rust\n// Given a string 'text', return its md5\
    \ hash equivalent string.\n// If 'text' is an empty string, return None.\n// >>>\
    \ string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nfn string_to_md5(text:\
    \ &str) -> String {\n    if text.is_empty() {\n        return String::new();\n\
    \    }\n    let mut hasher = Md5::new();\n    hasher.input(text.as_bytes());\n\
    \    hasher.result_str()\n}\n```\n\n##### Params\n\n* **string** `text`: String\
    \ to convert.\n\n##### Return\n\n* **string** The hash equivalent of 'text'.\n\
    \n<br>\n\n### <a name=\"count-words-in-string\"> `count_words_in_string` \nGiven\
    \ a string 'text', return a dictionary of words and the counts of the number of\
    \ times they", "  (define md5 (format \"echo -n ~a | md5sum | cut -d' ' -f1\"\
    \ text))\n  (string-trim (substring (subprocess md5) 0 32)))\n", "  (if (= (string-length\
    \ text) 0)\n      (error \"Empty string\")\n      (let ((hash (crypto:md5 text)))\n\
    \        (string-append (substring hash 0 2)\n                       (substring\
    \ hash 2 4)\n                       (substring hash 4 6)\n                   \
    \    (substring hash 6 8)\n                       (substring hash 8 10)\n    \
    \                   (substring hash 10 12)\n                       (substring\
    \ hash 12 14)\n                       (substring hash 14 16)))))\n", "  (unless\
    \ (string=? \"\" text)\n    (md5 (string->bytes/utf-8 text))))\n", "  (if (equal?\
    \ text \"\")\n      #f\n      (hash-ref (md5 text) 'digest)))\n", "  (cond\n \
    \   [(string=? text \"\") #f]\n    [else (md5 text)]))\n", "  (define (to-hexstr\
    \ n)\n    (cond\n      ((&lt; n 16) (format \"0~x\" n))\n      ((else) (format\
    \ \"~x\" n))))\n  (cond\n    ((empty? text) #f)\n    ((else\n       (define m\
    \ (make-md5-digest text))\n       (for/string ([byte (in-bytes m)])\n        \
    \ (to-hexstr byte))))))\n</code>\nOutput:\n<code>&gt; (string_to_md5 \"Hello world\"\
    )\n\"3e25960a79dbc69b674cd4ec67a72c62\"\n</code>\n", "  (cond [(string=? text\
    \ \"\")\n         #f]\n        [else\n         (byte-string->hex-string (md5 (string->utf8\
    \ text)))]))\n", "  (let loop ([s (string->list text)])\n    (cond [(empty? s)\
    \ '()]\n          [else (cons (integer->char (integer->string (hash (car s))))\n\
    \                      (loop (cdr s)))])))\n", "  (require openssl/md5)\n  (let\
    \ ([text-bytes (string->bytes/utf-8 text)])\n    (bytes->hex-string (md5 text-bytes))))\n\
    ```\n\n```racket\n#lang racket\n", "  (if (string=? text \"\")\n      \"\"\n \
    \     (byte-digest (string->bytes/utf-8 text) (make-hash 'md5))))\n```\n\nBut\
    \ now we need to help Racket understand that \"none\" is not a string\nand, as\
    \ such, it can't be compared with the string ``\"\"``.\nTo do that, we use a ``#:pre``\
    \ predicate:\n\n```racket\n#lang racket\n", "  (cond [(empty? text) 'None]\n \
    \       [else (hash text 'md5)]))\n", "  (if (eq? text \"\")\n      #f\n     \
    \ (call-with-input-string text\n                              (lambda (input)\n\
    \                                (call-with-output-string\n                  \
    \               (lambda (output)\n                                   (md5-final\
    \ output)\n                                   (copy-port input output)\n     \
    \                              (md5-update output)))))))\n```", "  (hash text\
    \ 'md5 #t))\n", "  (define digest (md5 text))\n  (define hex (byte-digest->hex-string\
    \ digest))\n  hex)\n", "  (define hex-digits \"0123456789abcdef\")\n  (define\
    \ (md5-hex md5-hash)\n    (map (\u03BB (md5-hash-value)\n           (vector-ref\
    \ hex-digits\n                       (quotient md5-hash-value 16)))\n        \
    \ md5-hash))\n  (and (string-length text)\n       (md5-hex (md5 text))))\n</code>\n\
    but still no luck.  I'm not sure what's going on.  I'm using <code>Racket 5.2.1\
    \ [cswu@localhost ~]$</code> from the command line.\nFor the full challenge, see\
    \ this link.\n\n\nA:\n\nYour code works for me. If you use <code>md5</code> as\
    \ a symbol and not as a function, then it prints <code>#&lt;procedure:md5&gt;</code>\
    \ which is not the same thing as <code>3e25960a79dbc69b674cd4ec67a72c62</code>.\n\
    I'm thinking this is a <code>racket</code> command-line issue with the <code>#lang\
    \ racket</code> header. I tried it with a <code>#lang racket/base</code> header\
    \ and it works fine. You can also try calling <code>racket</code> explicitly,\
    \ which is what the <code>racket</code> command does for you anyways.\n<code>$\
    \ racket -t /path/to/file.rkt\n3e25960a79dbc69b674cd4ec67a72c62\n</code>\n", " \
    \ (if (string=? text \"\") \n      #f\n      (let ([m (md5 (string->bytes/utf-8\
    \ text))])\n        (format \"~a\" m))))\n", "  (require crypto/md5)\n  (if (empty?\
    \ text)\n      #f\n      (md5 text)))\n", "  (if (empty? text)\n      #f\n   \
    \   (md5 text)))\n", "  (let ([hash (make-bytes 16)])\n    (hash-md5 (bytes-append\
    \ text #\"\") hash)\n    (bytes->hex-string hash)))\n", "  (let ([bytes (string->bytes/utf-8\
    \ text)])\n    (let ([md5-bytes (bytes-md5 bytes)])\n      (bytes->string/utf-8\
    \ md5-bytes))))\n", "  (if (empty? text)\n      (empty)\n      (parameterize ([current-input-port\
    \ text])\n\t\t     (parameterize ([current-output-port (open-output-string)])\n\
    \t\t\t\t    (crypto-md5)))))\n", "  (define (char-&gt;hex-digit c)\n    (cond\n\
    \      [(char=? c #\\0) #x0]\n      [(char=? c #\\1) #x1]\n      [(char=? c #\\\
    2) #x2]\n      [(char=? c #\\3) #x3]\n      [(char=? c #\\4) #x4]\n      [(char=?\
    \ c #\\5) #x5]\n      [(char=? c #\\6) #x6]\n      [(char=? c #\\7) #x7]\n   \
    \   [(char=? c #\\8) #x8]\n      [(char=? c #\\9) #x9]\n      [(char=? c #\\a)\
    \ #xa]\n      [(char=? c #\\b) #xb]\n      [(char=? c #\\c) #xc]\n      [(char=?\
    \ c #\\d) #xd]\n      [(char=? c #\\e) #xe]\n      [(char=? c #\\f) #xf]\n   \
    \   ))\n  (define (bin-&gt;hex b)\n    (let-values (((m1 m2 m3 m4)\n         \
    \         (c4list-&gt;values (byte-&gt;c4list b))))\n      (string-append (list-&gt;string\
    \ (list (char-&gt;hex-digit m1)\n                                          (char-&gt;hex-digit\
    \ m2)\n                                          (char-&gt;hex-digit m3)\n   \
    \                                       (char-&gt;hex-digit m4))))))\n  (let-values\
    \ (((md5-string #f)\n                (string-&gt;md5 text)))\n    (if md5-string\n\
    \        (string-join\n         (build-list 16\n                     (lambda (i)\n\
    \                       (bin-&gt;hex (c4list-ref md5-string i))))\n         \"\
    \"))))\n</code>\n", "  (define (bin_to_string n)\n    (bytes->string/utf-8 (bytes-append\
    \ (number->string n))))\n  (define (digest_to_md5 digest)\n    (let ([hash (-&gt;&gt;\
    \ (string-&gt;digest/md5 digest)\n                      (U16-&gt;bytes #:pad #f)\n\
    \                      (bytes-&gt;hex-string))])\n      (bin_to_string hash)))\n\
    \  (let ([ret (cond\n              [(string=? text \"\") #f]\n              [else\
    \ (digest_to_md5 text)])])\n    ret))\n", "  (cond [(empty? text) #f]\n      \
    \  [else (hash 'md5 text)]))\n", "  (hash-ref (crypto-hash 'md5 text) 'digest))\n",
  "  (if (string=? text \"\")\n      #f\n      (md5-bytes text #\"^a-zA-Z0-9\\s\"\
    )))\n", "  (require openssl/md5)\n  (if (= (string-length text) 0)\n      (void)\n\
    \      (string->md5 text)))\n", "  (if (string=? text \"\")\n      #f\n      (md5\
    \ (string->bytes/utf-8 text))))\n", "  (cond ((string=? text \"\") #f)\n     \
    \   (else (md5 text))))\n", "  (define md5hash\n    (bytes->hex-string (crypto:md5\
    \ (string->bytes/utf-8 text))))\n  (cond ((string=? text \"\") md5hash)\n    \
    \    (else md5hash)))\n", "  (if (equal? text \"\")\n      'None\n      (hash\
    \ text #hasheq 'md5)))\n", "  (if (equal? text \"\")\n      #f\n      (hash-ref\
    \ (crypt-md5 (bytes text)) 0)))\n", "  (define (string-to-bytes text)\n    (bytes\
    \ text 'utf-8))\n  (define (bytes-to-hexbytes bytes)\n    (bytes->hex-bytes bytes))\n\
    \  (define (hexbytes-to-string hexbytes)\n    (bytes->string/utf-8 hexbytes))\n\
    \  (define (md5bytes bytes)\n    (hash-ref (hash/md5 bytes) 'hash))\n  (define\
    \ (bytes-to-md5-string bytes)\n    (hexbytes-to-string (bytes-to-hexbytes bytes)))\n\
    \  (if (empty? text) #f\n      (bytes-to-md5-string (md5bytes (string-to-bytes\
    \ text)))))\n", "  (cond\n    [(string=? text \"\") \"\"]\n    [else (md5 text)]))\n",
  "  (if (string=? text \"\")\n      #f\n      (md5 (string->bytes/utf-8 text))))\n",
  "  (if (string=? text \"\")\n      (void)\n      (display (bytes->string/utf-8 (crypto-hash\
    \ 'md5 (string->bytes/utf-8 text))))))\n", "  (if (= (string-length text) 0)\n\
    \      #f\n      (bytes->string/utf-8 (md5-bytes (string->bytes/utf-8 text)))))\n",
  "  (let ([bytes (string->bytes/utf-8 text)])\n    (bytes->hex-string (md5 bytes))))\n",
  "  (if (string=? text \"\")\n      (void)\n      (begin\n        (require md5)\n\
    \        (md5 text))))\n", "  (if (string=? text \"\")\n      'None\n      (let\
    \ ((md5hash (md5 (string->bytes/utf-8 text))))\n        (bytes->string/utf-8 md5hash))))\n",
  "  (define (hex-string-to-integer hex-string)\n    (let ((hex->int (string->number\
    \ hex-string 16)))\n      hex->int))\n  (regexp-replace* #rx\"\\W+\" text \"\"\
    )\n  (define md5-hash (md5 text))\n  (hex-string-to-integer md5-hash))\n", " \
    \ (let ([hash (string->bytes/utf-8 (hash-ref (hash 'md5 text) 'md5))])\n    (bytes->string/utf-8\
    \ (base16-encode hash))))\n", "  (cond [(empty? text) '()]\n        [else (require\
    \ srfi/1 rfc2104 openssl)\n              (define (md5-hex a-string)\n        \
    \        (rfc2104:md5 #:input a-string))\n              (openssl:bytes-&gt;hex\
    \ (md5-hex text))]))\n</code>\nThe <code>openssl</code> and <code>rfc2104</code>\
    \ modules should be available through Racket package manager. <code>md5-hex</code>\
    \ is a helper function that is defined in <code>rfc2104</code> module. \nTo import\
    \ the <code>rfc2104</code> module, you can use\n<code>(require srfi/1 rfc2104\
    \ openssl)\n</code>\n", "  (when (not (string=? text \"\"))\n    (define hashed-text\
    \ (md5 text))\n    (md5-bytes->hex-string hashed-text)))\n", "  (md5 text))\n",
  "  (cond [(equal? text \"\") \n         #f]\n        [else \n         (display (md5\
    \ (string->bytes/utf-8 text)))\n         (md5 (string->bytes/utf-8 text))]))\n",
  "  (define digest (md5 text))\n  (define dig2str (string->bytes/utf-8 digest))\n\
    \  (define ashex (bytes->hex-string dig2str))\n  ashex)\n", "  (require openssl/md5)\n\
    \  (cond\n    [(empty? text)\n     #f]\n    [else\n     (bytes->hex-string (md5\
    \ (string->bytes/utf-8 text)))]))\n", "  (md5 (string->bytes/utf-8 text)))\n",
  "  (define (unhex str)\n    (match str\n      [(char-set \"0123456789abcdef\") #t]\n\
    \      [_ #f]))\n  (define (to-int str)\n    (cond\n      [(string=? (string-append\
    \ (substring str 0 1) (substring str 1 2)) \"00\")\n       0]\n      [(string=?\
    \ (string-append (substring str 0 1) (substring str 1 2)) \"0a\")\n       10]\n\
    \      [(string=? (string-append (substring str 0 1) (substring str 1 2)) \"0b\"\
    )\n       11]\n      [(string=? (string-append (substring str 0 1) (substring\
    \ str 1 2)) \"0c\")\n       12]\n      [(string=? (string-append (substring str\
    \ 0 1) (substring str 1 2)) \"0d\")\n       13]\n      [(string=? (string-append\
    \ (substring str 0 1) (substring str 1 2)) \"0e\")\n       14]\n      [(string=?\
    \ (string-append (substring str 0 1) (substring str 1 2)) \"0f\")\n       15]\n\
    \      [(string=? (string-append (substring str 0 1) (substring str 1 2)) \"10\"\
    )\n       16]\n      [(string=? (string-append (substring str 0 1) (substring\
    \ str 1 2)) \"11\")\n       17]\n      [(string=? (string-append (substring str\
    \ 0 1) (substring str 1 2)) \"12\")\n       18]\n      [(string=? (string-append\
    \ (substring str 0 1) (substring str 1 2)) \"13\")\n       19]\n      [(string=?\
    \ (string-append (substring str 0 1) (substring str 1 2)) \"14\")\n       20]\n\
    \      [(string=? (string-append (substring str 0 1) (substring str 1 2)) \"15\"\
    )\n       21]\n      [(string=? (string-append (substring str 0 1) (substring\
    \ str 1 2)) \"16\")\n       22]\n      [(string=? (string-append (substring str\
    \ 0 1) (", "  (require md5)\n  (define bytes-array (string->bytes/utf-8 text))\n\
    \  (bytes->hex-string (md5 bytes-array)))\n", "  (let* ([md5-hash (with-input-from-string\
    \ text md5)]\n         [md5-hex (md5-final md5-hash)])\n    (apply string-append\
    \ (map byte-&gt;hex-string md5-hex))))\n", "  (define byte-string (bytes-&gt;string/utf-8\
    \ text))\n  (define digest (crypto:md5 byte-string))\n  (string-&gt;hex-string\
    \ digest))\n", "  (match text\n    [(or \"\" _) #f]\n    [_ (define bytes (bytes-append\
    \ text #\"\"))\n       (define hash (racket/md5-bytes bytes 0 (bytes-length bytes)))\n\
    \       (bytes->string/utf-8 (racket/hash-bytes->bytes hash))]))\n", "  (cond\
    \ ((null? text)\n         '())\n        (else\n         (md5 (string->bytes/utf-8\
    \ text)))))\n", "  (or (md5 (string->bytes/utf-8 text)) #f))\n", "  (let* ([hasher\
    \ (crypto:make-hash 'md5)]\n         [hash (hasher (crypto:bytes->string/utf-8\
    \ (string->bytes/utf-8 text)))]\n         [final-hash (bytes->string/utf-8 (crypto:hash-bytes\
    \ hash))])\n    final-hash))\n", "  (if (= (string-length text) 0)\n      #f\n\
    \      (hash-ref (hash-md5 (string->bytes/utf-8 text)) 0)))\n", "  (cond ((= (string-length\
    \ text) 0) #f)\n        (else (md5 text))))\n", "  (let ([digest (md5 text #:encoding\
    \ 'utf-8)])\n    (if (empty? text)\n        #f\n        (apply bytes-&gt;string/utf-8\
    \ (bytes-concatenate #\"\" digest)))))\n", "  (let ((digest (string->bytes/utf-8\
    \ text)))\n    (hash 'md5 digest 'hex)))\n", "  (hash 'md5 text))\n", "  (define\
    \ (str-to-byte-string str)\n    (map byte-string->integer (string->list str)))\n\
    \  (define (byte-string->integer byte)\n    (bytes-ref byte 0))\n  (define (int-to-byte-string\
    \ i)\n    (list->bytes (list i)))\n  (define (byte-string->hex-string byte)\n\
    \    (bytes->hex-string (list->bytes (list byte))))\n  (define (bytes->hex-string\
    \ bs)\n    (define (byte->hex-string b)\n      (define (ones-comp b)\n       \
    \ (if (= b 0)\n            #xFF\n            (- b)))\n      (let ((high (byte-string->integer\
    \ (int-to-byte-string (inexact->exact (floor (/ b 16.0))))))\n            (low\
    \ (byte-string->integer (int-to-byte-string (inexact->exact (floor (modulo b 16.0)))))))\n\
    \        (string-append (number->string (ones-comp high) 16)\n               \
    \        (number->string (ones-comp low) 16))))\n    (cond ((zero? (bytes-length\
    \ bs))\n           \"\")\n          (else\n           (string-append (byte->hex-string\
    \ (bytes-ref bs 0))\n                          (bytes->hex-string (subbytes bs\
    \ 1))))))\n  (bytes->hex-string (md5 (string->bytes/utf-8 text))))\n", "  (if\
    \ (string=? text \"\")\n      'None\n      (bytes->hex-string (md5 (string->bytes/utf-8\
    \ text)))))\n", "  (if (string=? text \"\")\n      #f\n      (hash-ref (make-hasheq\
    \ (md5 (string->bytes/utf-8 text))) 'md5)))\n", "  (display text) (newline)\n\
    \  (string-hash text))\n", "  (and (not (empty? text))\n       (crypto:string->bytes/utf-8\
    \ text)\n       (crypto:digest (crypto:make-hash 'md5))\n       (bytes->string/utf-8\
    \ (crypto:digest (crypto:make-hash 'md5)))))\n```\n\n## [Python](https://docs.python.org/3.5/library/hashlib.html)\n\
    \n## [Ruby](https://ruby-doc.org/stdlib-2.4.0/libdoc/digest/rdoc/Digest.html)\n\
    \n## [Rust](https://doc.rust-lang.org/stable/rust-by-example/std_misc/file/open.html)\n\
    \n## [Scala](https://www.scala-lang.org/api/2.12.8/scala/io/Source.html)\n\n##\
    \ [Swift](https://developer.apple.com/documentation/foundation/nsstring/1413791-md5)\n\
    \n## [TypeScript](https://www.typescriptlang.org/docs/handbook/basic-types.html)\n\
    \n## [Visual Basic](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/keywords/md5)",
  "  (if (= text \"\")\n      null\n      (hash-ref (hash \"md5\" (string->bytes/utf-8\
    \ text)) 'digest)))\n```\n\n#### 2.  \u041D\u0430\u043F\u0438\u0448\u0438\u0442\
    \u0435 \u0444\u0443\u043D\u043A\u0446\u0438\u044E, \u043A\u043E\u0442\u043E\u0440\
    \u0430\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u0442 \u044F\u0432\
    \u043B\u044F\u0435\u0442\u0441\u044F \u043B\u0438 \u0441\u0442\u0440\u043E\u043A\
    \u0430 \u043F\u0430\u043B\u0438\u043D\u0434\u0440\u043E\u043C\u043E\u043C.\n\u041F\
    \u0440\u0438\u043C\u0435\u0440:\n```\n#lang racket\n", "  (if (= (string-length\
    \ text) 0)\n      #f\n      (hash-ref (md5 (string->bytes/utf-8 text)) 'md5)))\n\
    ```\n\n```racket\n#lang racket\n", "  (cond [(string=? text \"\") #f]\n      \
    \  [else (hash-ref (bytes->hash/md5 text) 'md5)]))\n", "  (hash 'md5 text))\n",
  "  (cond\n    [(equal? text \"\") #f]\n    [else\n     (define hashed (md5 text))\n\
    \     (byte-string->hex-string hashed)]))\n", "  (or (equal? text \"\") (md5 text)))\n",
  "  (check-type text string?)\n  (if (zero? (string-length text))\n      (error \"\
    the input string must not be empty\")\n      (hash-ref (hash 'md5 text) 'md5)))\n",
  "  (bytes->hex-string (md5 (string->bytes text))))\n", "  (define md5 (require \"\
    openssl/md5\" \"racket\"))\n  (define (hex2 str)\n    (define (hex1 n)\n     \
    \ (let ([c (integer->char n)])\n        (if (char-numeric? c) c (char-upcase c))))\n\
    \    (for/list ([i (in-range (string-length str))])\n      (string-append (list->string\
    \ (map hex1 (bytes-&gt;list/reference (string-&gt;bytes/utf-8 (substring str i\
    \ (+ i 1)))))))))\n  (hex2 (bytes-&gt;string/utf-8 (md5 text))))\n", "  (if (string=?\
    \ text \"\")\n      #f\n      (hash-ref (hash \"md5\" (hash text)) \"md5\")))\n",
  "  (if (= text \"\")\n      'None\n      (crypto-hash 'md5 text)))\n", "  (if (=\
    \ text \"\")\n      \"None\"\n      (md5 (bytes-&gt;string/utf-8 (bytes text)))))\n",
  "  (define (loop acc i)\n    (cond [(= 0 i)\n           (byte-string->hex-string\
    \ acc)]\n          [else\n           (loop (md5-bytes (string->bytes (bytes->string/utf-8\
    \ text))) (- i 1))]))\n  (if (string=? text \"\")\n      \"None\"\n      (loop\
    \ (md5-bytes (string->bytes (bytes->string/utf-8 text))) 1)))\n```\n\n#### Output\n\
    ```racket", "  (define (byte-list->hex-string lst)\n    (apply string-append (map\
    \ bytes->hex-string lst)))\n  (cond ((empty? text) #f)\n        (else (byte-list->hex-string\
    \ (hash-string-bytes text)))))\n", "  (hash-to-bytes 'md5 (string->bytes/utf-8\
    \ text)))\n", "  (if (string=? text \"\")\n      #f\n      (hash (string->bytes/utf-8\
    \ text))))\n", "  (unless (string=? text \"\")\n    (hash-ref (md5 text) 'digest)))\n",
  "  (define binhash (hx:md5-hex text))\n  (if (string=? text \"\")\n      #f\n  \
    \    binhash))\n", "  (let* ([md5 (sha256 text)]\n         [hex-string (bytes->hex-string\
    \ md5)])\n    hex-string))\n", "  (cond\n    [(string=? text \"\") #f]\n    [else\
    \ (hash-ref (hash \"md5\" text) \"hexdigest\")]))\n", "  (cond [(empty? text)\
    \ #f]\n        [else (hash-ref (hash 'md5 text) 'digest)]))\n</code>\nWhat is\
    \ the error I'm making?\nThanks for your help.\n\n\nA:\n\nThere are several problems\
    \ with your code:\n<code>(define (string_to_md5 text)\n  (cond [(empty? text)\
    \ #f]\n        [else (hash-ref (hash 'md5 text) 'digest)]))\n</code>\n\nYou have\
    \ to create the hash, and then get its values from it.\nThe <code>hash</code>\
    \ function takes only one argument, which is the hash algorithm. Then you need\
    \ to get the digest with <code>hash-ref</code>, as you did.\n<code>#f</code> is\
    \ a boolean value and not a string, so returning <code>#f</code> when the input\
    \ is empty is okay.\nYou need to convert the hexadecimal output of the hash to\
    \ a string in order to be able to use it in the test.\n\nUsing the <code>hash</code>\
    \ function you wrote in your comment:\n<code>(define (string_to_md5 text)\n  (let\
    \ ([hex-digest (bytes-&gt;hex-string (hash 'md5 text))])\n    (if (empty? text)\n\
    \        #f\n        hex-digest)))\n</code>\nOr using <code>string-append</code>\
    \ instead of <code>bytes-&gt;hex-string</code>:\n<code>(define (string_to_md5\
    \ text)\n  (let ([hex-digest (string-append (hash 'md5 text))])\n    (if (empty?\
    \ text)\n        #f\n        hex-digest)))\n</code>\nAnd here's a version that\
    \ uses <code>cond</code> instead of <code>if</code>:\n<code>(define (string_to_md5\
    \ text)\n  (cond [(empty? text) #f]\n        [else (bytes-&gt;hex-string (hash\
    \ 'md5 text))]))\n</code>\n", "  (string-hash 'md5 text))\n", "  (if (equal? text\
    \ \"\")\n      (void)\n      (hash-ref (md5-hash text) 'hash-hex)))\n", "  (define\
    \ (to-hex x)\n    (cond\n      [(= x 10) 'a]\n      [(= x 11) 'b]\n      [(= x\
    \ 12) 'c]\n      [(= x 13) 'd]\n      [(= x 14) 'e]\n      [(= x 15) 'f]\n   \
    \   [else x]))\n  (define (to-digits x)\n    (if (empty? x)\n        empty\n \
    \       (cons (to-hex (quotient x 16))\n              (cons (to-hex (remainder\
    \ x 16))\n                    empty))))\n  (define (format-to-hex-string x)\n\
    \    (bytes->string/utf-8 (apply string (reverse (map char->integer (to-digits\
    \ x))))))\n  (cond\n    [(equal? text \"\") (error \"Text cannot be empty.\")]\n\
    \    [else (define-values (digest len) (hash 'md5 text))\n          (apply string-append\
    \ (map format-to-hex-string (bytes->list/unsafe digest)))]))\n", "  (if (string=?\
    \ text \"\")\n      #f\n      (hash-ref (file->hash \"data/md5_hashes.rkt\") text)))\n",
  "  (define h (call-with-input-string text (lambda (s) (md5 s))))\n  (when (string=?\
    \ \"\" text) (error \"An empty string was passed to 'string_to_md5'!\"))\n  (bytes->string/utf-8\
    \ (bytes-append (sha1-bytes #\"\\0\") (sha1-bytes h))))\n", "  (bytes->string/utf-8\
    \ (md5 (string->bytes/utf-8 text))))\n", "  (require (prefix-in racket: net/md5))\n\
    \  (if (string=? text \"\")\n      \"\"\n      (racket:md5-digest (racket:string->bytes/utf-8\
    \ text))))\n", "  (define h (hash 'md5 text))\n  (if (eq? h \"\")\n      (hash\
    \ 'md5 \"\")\n      (string->hex-string h)))\n", "  (if (string=? text \"\")\n\
    \      #f\n      (hash-ref (string->bytes/utf-8 text) 'md5)))\n", "  (define (md5-digest->string\
    \ d)\n    (bytes->string/utf-8 (md5 d)))\n  (let ([text (string->bytes/utf-8 text)])\n\
    \    (unless (bytes-empty? text)\n      (md5-digest->string (md5 text)))))\n",
  "  (if (eq? text \"\")\n      #f\n      (match-define (bytes-&gt;hex-string (md5\
    \ text)) (bytes-&gt;hex-string (md5 text)))\n  )\n)\n</code>\nThe error message:\n\
    <code>string_to_md5.rkt:12:1: match-define: no match in: (md5 text)\n</code>\n\
    I get this by running <code>racket -t string_to_md5.rkt</code> with no input file.\n\
    Can you please help me understand where I am going wrong?\nThanks!\n\n\nA:\n\n\
    The problem is that in Racket you need to provide an expression to <code>match-define</code>,\
    \ but you're providing a result of <code>md5</code> call, a byte string.\nYou\
    \ could try this simplified version instead:\n<code>(define (string-to-md5 text)\n\
    \  (define-values (digest-bytes _) (md5 text))\n  (bytes-&gt;hex-string digest-bytes))\n\
    </code>\n", "  (and (not (string=? text \"\"))\n       (hash-ref (md5 text) 'digest)))\n",
  "  (if (= text \"\")\n      #f\n      (bytes->string/utf-8 (md5 (string->bytes/utf-8\
    \ text)))))\n", "  (define hash (openssl-hash 'md5 text))\n  (displayln hash)\n\
    \  (displayln (hex-bytes->string/utf-8 hash))\n  (bytes->string/utf-8 hash))\n",
  "  (if (string=? text \"\")\n      #f\n      (md5 text)))\n", "  (if (string=? text\
    \ \"\")\n      #f\n      (bytes->string/utf-8 (md5 (string->bytes/utf-8 text)))))\n",
  "  (unless (string=? text \"\")\n    (hash-ref (MD5-finalize\n               (MD5-update\n\
    \                (MD5-finalize (MD5-update (MD5-begin) text)) \"\")) 'string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
