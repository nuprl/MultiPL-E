name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n;; >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
  ;; [0.0, 0.25, 0.5, 0.75, 1.0]\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (define (convert x min max)\n    (/ (- x min) (- max min)))\n  (define\
    \ (recur acc numbers min max)\n    (if (null? numbers)\n        acc\n        (let\
    \ ([n (car numbers)])\n          (recur (cons (convert n min max) acc) (cdr numbers)\
    \ (min n min) (max n max)))))\n  (reverse (recur '() numbers (apply max numbers)\
    \ (apply min numbers))))\n", "  (define min (min numbers))\n  (define max (max\
    \ numbers))\n  (map (lambda (x) (/ (- x min) (- max min))) numbers))\n", "  (define\
    \ max (apply max numbers))\n  (define min (apply min numbers))\n  (define transform-fn\
    \ (/ (- max min) (- 1 min)))\n  (map (\u03BB (x) (* transform-fn x)) numbers))\n",
  "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map\
    \ (\u03BB (x) (/ (- x min) (- max min))) numbers)))\n", "  (define (find_min_max\
    \ lst)\n    (let loop ([lst lst] [min (car lst)] [max (car lst)])\n      (cond\n\
    \        [(null? lst) (values min max)]\n        [(< (car lst) min) (loop (cdr\
    \ lst) (car lst) max)]\n        [(> (car lst) max) (loop (cdr lst) min (car lst))]\n\
    \        [else (loop (cdr lst) min max)])))\n  (let-values ([(min max) (find_min_max\
    \ numbers)])\n    (map (\u03BB (x) (/ (- x min) (- max min))) numbers)))\n", " \
    \ (map (/ (- _ 0.0) (- (apply max numbers) 0.0)) numbers))\n", "  (let ((min-value\
    \ (apply min numbers))\n        (max-value (apply max numbers)))\n    (map (\u03BB\
    \ (n) (/ (- n min-value) (- max-value min-value))) numbers)))\n```\n\n```racket\n\
    #lang racket\n", "  (let* ([max (apply max numbers)]\n         [min (apply min\
    \ numbers)]\n         [delta (- max min)])\n    (map (lambda (x)\n           (/\
    \ (- x min) delta))\n         numbers)))\n", "  (define lo (apply min numbers))\n\
    \  (define hi (apply max numbers))\n  (define lo-hi (- hi lo))\n  (map (lambda\
    \ (n) (/ (- n lo) lo-hi)) numbers))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [ranges (- max min)])\n    (map\
    \ (lambda (number) (/ (- number min) ranges)) numbers)))\n", "  (define min-v\
    \ (apply min numbers))\n  (define max-v (apply max numbers))\n  (define denom\
    \ (- max-v min-v))\n  (cond\n    [(= denom 0)\n     (printf \"Denominator cannot\
    \ be 0\\n\")\n     numbers]\n    [else\n     (map (lambda (x) (/ (- x min-v) denom))\
    \ numbers)]))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [min-max (- max min)])\n    (if (zero? min-max)\n      \
    \  (error \"Error, min and max are equal\"))\n    (map (\u03BB (v)\n         \
    \  (/ (- v min) min-max))\n         numbers)))\n", "  (define (rescale_helper\
    \ min max numbers)\n    (cond [(empty? numbers) '()]\n          [else (cons (/\
    \ (- (first numbers) min) (- max min))\n                     (rescale_helper min\
    \ max (rest numbers)))]))\n  (rescale_helper (apply min numbers) (apply max numbers)\
    \ numbers))\n", "  (map (\u03BB (x) (/ x (apply max numbers))) numbers))\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [min-max (- max min)])\n    (map (\u03BB (n) (/ (- n min) min-max)) numbers)))\n",
  "  (define (do_rescale_to_unit numbers)\n    (if (null? numbers) '()\n        (let\
    \ ([min (apply min numbers)]\n              [max (apply max numbers)])\n     \
    \     (if (= min max) '()\n              (let ([diff (- max min)])\n         \
    \       (cons (/ (- (car numbers) min) diff)\n                      (do_rescale_to_unit\
    \ (cdr numbers))))))))\n  (do_rescale_to_unit numbers))\n", "  (define (sub-min\
    \ n lst)\n    (map (lambda (x) (- x n)) lst))\n  (define (div-max n lst)\n   \
    \ (map (lambda (x) (/ x n)) lst))\n  (define (rescale xs)\n    (let* ([min (apply\
    \ min xs)]\n           [max (apply max xs)]\n           [sub (sub-min min xs)]\n\
    \           [div (div-max max sub)])\n      div))\n  (rescale numbers))\n", " \
    \ (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map\
    \ (/ (- _ min) (- max min)) numbers)))\n", "  (for/list ([number numbers])\n \
    \   (/ (- number (min numbers)) (- (max numbers) (min numbers)))))\n", "  (let\
    \ ([min (min numbers)]\n        [max (max numbers)])\n    (map (\u03BB (n) (/\
    \ (- n min) (- max min))) numbers)))\n", "  (let* ([sorted (sort numbers &lt;)]\n\
    \         [min (car sorted)]\n         [max (car (reverse sorted))]\n        \
    \ [rescale_factor (/ 1.0 (- max min))])\n    (map (lambda (x) (* (- x min) rescale_factor))\
    \ numbers)))\n", "  (define (rescale-map x)\n    (/ (- x (apply min numbers))\n\
    \       (- (apply max numbers) (apply min numbers))))\n  (map rescale-map numbers))\n",
  "  (let ([numbers (sort numbers <)])\n    (let ([min (car numbers)]\n          [max\
    \ (car (reverse numbers))])\n      (map (lambda (n)\n             (/ (- n min)\
    \ (- max min)))\n           numbers))))\n", "  (define min-max (extremes numbers))\n\
    \  (let ([min (car min-max)]\n        [max (cadr min-max)])\n    (map (lambda\
    \ (x) (/ (- x min) (- max min))) numbers)))\n", "  (let ([f (minmax numbers)])\n\
    \    (map (\u03BB (x) (/ (- x (first f)) (- (second f) (first f)))) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n\
    ```\n\n## Problem 5\n``` #lang racket\n", "  (define minimum (apply min numbers))\n\
    \  (define maximum (apply max numbers))\n  (define range (- maximum minimum))\n\
    \  (map (lambda (x) (/ (- x minimum) range)) numbers))\n", "  (define (divide_by_num\
    \ n x) (/ x n))\n  (define (rescale lst)\n    (if (null? lst)\n        '()\n \
    \       (cons (define (divide_by_num n x) (/ x n))\n              (rescale (cdr\
    \ lst)))))\n  (let* ((min (apply min numbers))\n         (max (apply max numbers))\n\
    \         (scaled-max (- max min)))\n    (rescale (map (divide_by_num scaled-max)\
    \ (map (- min) numbers)))))\n", "  (let* ([min (apply min numbers)]\n        \
    \ [max (apply max numbers)]\n         [diff (- max min)])\n    (map (\u03BB (x)\
    \ (/ (- x min) diff)) numbers)))\n", "  (define min-value (apply min numbers))\n\
    \  (define max-value (apply max numbers))\n  (define diff (subtract max-value\
    \ min-value))\n  (cond\n    [(zero? diff)\n     (map (\u03BB (x) (/ x max-value))\
    \ numbers)]\n    [else\n     (map (\u03BB (x) (/ (subtract x min-value) diff))\
    \ numbers)]))\n```\n\n<!-- end list -->\n\n``` r\nrescale_to_unit <- function(numbers)\
    \ {\n  min_value <- min(numbers)\n  max_value <- max(numbers)\n  diff <- max_value\
    \ - min_value\n  if (diff == 0) {\n    return(numbers / max_value)\n  } else {\n\
    \    return((numbers - min_value) / diff)\n  }\n}\n```\n\n### Clustering by similarity\n\
    \nClustering by similarity is performed by first, rescaling all the\nvectors to\
    \ be of unit length, and then finding the two vectors most\nsimilar to each other\
    \ in a list of vectors. The similarity is measured\nusing cosine similarity.\n\
    \n``` r\n##' Compute cosine similarity between two vectors\n##' @param vector1\
    \ The first vector\n##' @param vector2 The second vector\n##' @return The cosine\
    \ similarity between the two vectors\ncosine_similarity <- function(vector1, vector2)\
    \ {\n  return(sum(vector1 * vector2) / (sqrt(sum(vector1 * vector1)) * sqrt(sum(vector2\
    \ * vector2))))\n}\n```\n\n``` racket", "  (for/list ([n numbers])\n    (/ (-\
    \ n (min numbers)) (- (max numbers) (min numbers)))))\n", "  (let* ([max_element\
    \ (apply max numbers)]\n         [min_element (apply min numbers)]\n         [m\
    \ (if (zero? (- max_element min_element)) 1.0\n              (/ 1.0 (- max_element\
    \ min_element)))]\n         [c (- 1.0 (* max_element m))])\n    (map (lambda (x)\
    \ (* m x c)) numbers)))\n\n", "  (let ([min (apply min numbers)]\n        [max\
    \ (apply max numbers)])\n    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n",
  "  (let* ([min-max (foldl (lambda (min-max n)\n                           (match-define\
    \ (list min max) min-max)\n                           (list (min min n) (max max\
    \ n)))\n                         (list (car numbers) (car numbers))\n        \
    \                 (cdr numbers))]\n         [min (car min-max)]\n         [max\
    \ (cadr min-max)])\n    (map (lambda (n) (/ (- n min) (- max min))) numbers)))\n",
  "  (define min\n    (apply min numbers))\n  (define max\n    (apply max numbers))\n\
    \  (define range\n    (- max min))\n  (map (lambda (x)\n         (/ (- x min)\
    \ range))\n       numbers))\n", "  (define (step-1 lst)\n    (map\n     (lambda\
    \ (n)\n       (/ n (apply max lst)))\n     lst))\n  (define (step-2 lst)\n   \
    \ (map\n     (lambda (n)\n       (- n (apply min lst)))\n     lst))\n  (define\
    \ (step-3 lst)\n    (map\n     (lambda (n)\n       (/ n (apply max lst)))\n  \
    \   lst))\n  (step-3 (step-2 (step-1 numbers))))\n\n", "  (let* ([min (apply min\
    \ numbers)]\n         [max (apply max numbers)]\n         [range (- max min)])\n\
    \    (if (zero? range)\n        (map (lambda (num) 0) numbers)\n        (map (lambda\
    \ (num) (/ (- num min) range)) numbers))))\n", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (if (zero? (sub1 max))\n \
    \                  0.0\n                   (- max min))])\n    (map (\u03BB (x)\
    \ (/ (- x min) diff)) numbers)))\n", "  (define max-num (apply max numbers))\n\
    \  (define min-num (apply min numbers))\n  (define distance (- max-num min-num))\n\
    \  (map (lambda (n)\n         (if (equal? distance 0)\n             (error \"\
    Cannot scale a list that has all the same numbers!\")\n             (/ (- n min-num)\
    \ distance)))\n       numbers))\n```\n\n### Exercise 4: Computing Standard Deviation\n\
    \n``` #lang racket\n", "  (let* ([lowest (apply min numbers)]\n         [highest\
    \ (apply max numbers)]\n         [slope (/ 1.0 (- highest lowest))]\n        \
    \ [intercept (- 0 lowest)])\n    (map (\u03BB (x) (+ (* slope x) intercept)) numbers)))\n",
  "  (let* ((min (apply min numbers))\n         (max (apply max numbers))\n      \
    \   (scaler (- 1.0 min))\n         (scaled-numbers (map (lambda (x) (- x min))\
    \ numbers)))\n    (map (lambda (x) (/ x scaler)) scaled-numbers)))\n", "  (define\
    \ minval (apply min numbers))\n  (define maxval (apply max numbers))\n  (map (lambda\
    \ (n) (/ (- n minval) (- maxval minval))) numbers))\n", "  (let ([min (apply min\
    \ numbers)]\n        [max (apply max numbers)])\n    (map (lambda (n) (/ (- n\
    \ min) (- max min))) numbers)))\n", "  (let* ([min (apply min numbers)]\n    \
    \     [max (apply max numbers)]\n         [denominator (- max min)])\n    (if\
    \ (= denominator 0)\n        numbers\n        (map (lambda (x) (/ (- x min) denominator))\
    \ numbers))))\n", "  (define min (apply min numbers))\n  (define max (apply max\
    \ numbers))\n  (define denom (- max min))\n  (if (zero? denom)\n      (for/list\
    \ ([x numbers])\n        (if (zero? x)\n            0\n            1))\n     \
    \ (for/list ([x numbers])\n        (/ (- x min) denom))))\n", "  (let ([min (min-list\
    \ numbers)]\n        [max (max-list numbers)])\n    (map (lambda (x) (/ (- x min)\
    \ (- max min))) numbers)))\n", "  (let* ([min_value (apply min numbers)]\n   \
    \      [max_value (apply max numbers)]\n         [delta (if (zero? (- max_value\
    \ min_value)) 1 (- max_value min_value))])\n    (for/list ([n numbers])\n    \
    \  (/ (- n min_value) delta))))\n", "  (let ([sorted (sort numbers <)])\n    (let\
    \ ([min-max (apply max sorted)])\n      (map (\u03BB (x) (/ x min-max)) sorted))))\n",
  "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map\n\
    \     (lambda (n) (/ (- n min) (- max min)))\n     numbers)))\n", "  (define (min-max-helper\
    \ nums min-sofar max-sofar)\n    (cond\n      [(empty? nums) (values min-sofar\
    \ max-sofar)]\n      [(< min-sofar (first nums)) (min-max-helper (rest nums) (first\
    \ nums) max-sofar)]\n      [(> max-sofar (first nums)) (min-max-helper (rest nums)\
    \ min-sofar (first nums))]\n      [else (min-max-helper (rest nums) min-sofar\
    \ max-sofar)]))\n  (define (rescale-helper nums min max step)\n    (cond\n   \
    \   [(empty? nums) empty]\n      [else (cons (/ (- (first nums) min) step) (rescale-helper\
    \ (rest nums) min max step))]))\n  (let-values ([(min max) (min-max-helper numbers\
    \ (first numbers) (first numbers))])\n    (rescale-helper numbers min max (- max\
    \ min))))\n", "  (let ([min-num (apply min numbers)]\n        [max-num (apply\
    \ max numbers)])\n    (map (lambda (x) (/ (- x min-num) (- max-num min-num)))\
    \ numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n\
    \    (map\n     (lambda (x) (/ (- x min) (- max min)))\n     numbers)))\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [substract-by-min (map (lambda (number) (- number min)) numbers)]\n     \
    \    [scaling-factor (/ 1.0 (- max min))]\n         [scaled (map (lambda (number)\
    \ (* number scaling-factor)) substract-by-min)])\n    scaled))\n", "  (let ([minval\
    \ (apply min numbers)]\n        [maxval (apply max numbers)])\n    (for/list ([n\
    \ numbers])\n      (/ (- n minval) (- maxval minval)))))\n", "  (define (min_max_finder\
    \ acc current)\n    (let* ([minimum (min (car acc) current)]\n           [maximum\
    \ (max (cadr acc) current)])\n      (list minimum maximum)))\n  (define (mapper\
    \ lst)\n    (let* ([minimum (car lst)]\n           [maximum (cadr lst)]\n    \
    \       [diff (sub1 maximum)])\n      (lambda (current) (/ (- current minimum)\
    \ diff))))\n  (let* ([min_max (reduce min_max_finder numbers)]\n         [mapping-fn\
    \ (mapper min_max)])\n    (map mapping-fn numbers)))\n", "  (let ([max_n (apply\
    \ max numbers)]\n        [min_n (apply min numbers)])\n    (map (lambda (n) (/\
    \ (- n min_n) (- max_n min_n))) numbers)))\n", "  (rescale_helper (min_max numbers)\
    \ numbers))\n", "  (define min (apply min numbers))\n  (define max (apply max\
    \ numbers))\n  (map (lambda (x) (/ (- x min) (- max min))) numbers))\n```\n\n\
    ```racket\n#lang racket\n", "  (define (rescale_n number)\n    (/ (- number (apply\
    \ min numbers))\n       (- (apply max numbers) (apply min numbers))))\n  (map\
    \ rescale_n numbers))\n```\n### Other\n```racket", "  (let ([min (apply min numbers)]\n\
    \        [max (apply max numbers)])\n    (map (lambda (x) (/ (- x min) (- max\
    \ min))) numbers)))\n", "  (let ((min (apply min numbers))\n        (max (apply\
    \ max numbers)))\n    (map\n     (lambda (n) (/ (- n min) (- max min)))\n    \
    \ numbers)))\n", "  (define step (/ 1.0 (- (apply max numbers) (apply min numbers))))\n\
    \  (define base (apply min numbers))\n  (map (lambda (x) (* step (- x base)))\
    \ numbers))\n```\n### 3 - Step 3: cross-validation\n```racket\n#lang racket\n",
  "  (let* ([diff (- (max numbers) (min numbers))]\n         [scale (/ 1 diff)])\n\
    \    (map (lambda (x) (* (- x (min numbers)) scale)) numbers)))\n", "  (let* ([min-number\
    \ (apply min numbers)]\n         [max-number (apply max numbers)]\n         [distance\
    \ (subtract max-number min-number)])\n    (if (zero? distance) numbers\n     \
    \   (map (lambda (x) (divide (subtract x min-number) distance)) numbers))))\n",
  "  (let ([min_number (apply min numbers)]\n        [max_number (apply max numbers)])\n\
    \    (map (lambda (n) (/ (- n min_number) (- max_number min_number))) numbers)))\n",
  "  (define lowest_number (apply min numbers))\n  (define highest_number (apply max\
    \ numbers))\n  (define denominator (- highest_number lowest_number))\n  (map (lambda\
    \ (num) (/ (- num lowest_number) denominator)) numbers))\n", "  (let* ([scale\
    \ (apply min max numbers)]\n         [mul (/ 1 (- (apply max numbers) scale))])\n\
    \    (for/list ([n numbers])\n      (* (- n scale) mul))))\n", "  (define number-min\
    \ (apply min numbers))\n  (define number-max (apply max numbers))\n  (define number-range\
    \ (- number-max number-min))\n  (for/list ([number numbers])\n    (/ (- number\
    \ number-min) number-range)))\n", "  (let ([min-number (apply min numbers)]\n\
    \        [max-number (apply max numbers)])\n    (map\n     (lambda (x) (/ (- x\
    \ min-number) (- max-number min-number)))\n     numbers)))\n", "  (define (loop\
    \ numbers min max acc)\n    (cond [(empty? numbers)\n           acc]\n       \
    \   [else\n           (let ([new-number (/ (- (first numbers) min) (- max min))])\n\
    \             (loop (rest numbers) min max (append acc (list new-number))))]))\n\
    \  (loop numbers (min numbers) (max numbers) empty))\n", "  (define list_min (apply\
    \ min numbers))\n  (define list_max (apply max numbers))\n  (define range (- list_max\
    \ list_min))\n  (map (lambda (x) (/ (- x list_min) range)) numbers))\n", "  (let*\
    \ ([from-min (apply min numbers)]\n         [from-max (apply max numbers)]\n \
    \        [diff (- from-max from-min)])\n    (map (lambda (x) (/ (- x from-min)\
    \ diff)) numbers)))\n", "  (let* ([smallest-number (apply min numbers)]\n    \
    \     [largest-number (apply max numbers)]\n         [size-of-scale (- largest-number\
    \ smallest-number)])\n    (cond\n      [(> size-of-scale 0)\n       (map (/ (-\
    \ size-of-scale) (- numbers smallest-number)))]\n      [else (list 1))])))\n",
  "  (let* ((biggest (apply max numbers))\n         (smallest (apply min numbers))\n\
    \         (range (- biggest smallest)))\n    (map (lambda (num)\n           (/\
    \ (- num smallest) range))\n         numbers)))\n", "  (let* ([max (apply max\
    \ numbers)]\n         [min (apply min numbers)]\n         [range (- max min)])\n\
    \    (map (lambda (e)\n           (if (= range 0)\n               0\n        \
    \       (/ (- e min) range)))\n         numbers)))\n", "  (define (inner numbers)\n\
    \    (cond ((empty? numbers) empty)\n          ((= (first numbers) (apply min\
    \ numbers))\n           (cons 0 (inner (rest numbers))))\n          ((= (first\
    \ numbers) (apply max numbers))\n           (cons 1 (inner (rest numbers))))\n\
    \          (else\n           (cons (/ (- (first numbers) (apply min numbers))\n\
    \                     (- (apply max numbers) (apply min numbers)))\n         \
    \        (inner (rest numbers))))))\n  (inner numbers))\n", "  (define (rescale-helper\
    \ numbers position)\n    (if (empty? numbers)\n        '()\n        (cons (/ (first\
    \ numbers) (float (last numbers)))\n              (rescale-helper (rest numbers)\
    \ (+ position 1)))))\n  (rescale-helper numbers 0))\n", "  (define (rescale_to_unit_helper\
    \ numbers min max acc)\n    (if (null? numbers)\n        acc\n        (let ([n\
    \ (car numbers)])\n          (rescale_to_unit_helper (cdr numbers)\n         \
    \                         (if (< n min) n min)\n                             \
    \     (if (> n max) n max)\n                                  (cons (/ (- n min)\
    \ (- max min)) acc)))))\n  (reverse (rescale_to_unit_helper numbers (car numbers)\
    \ (car numbers) '())))\n```\n\n## Recursion in Racket\n\n* [Racket: Recursion\
    \ - video](https://www.youtube.com/watch?v=1yCfIy0fPj8)\n* [Racket: Recursion\
    \ - slides](https://docs.google.com/presentation/d/1eoOyH2T6LsU6NwU6pEbgYIHlIjuX9SlUxAGnbsR7JPU/edit#slide=id.g43a0863b3f_0_0)\n\
    \n### Exercise - List Length\n\nCreate a function that returns the length of a\
    \ list. Do not use the built-in `length` function.\n\n```racket", "  (let* ([numbers-to-be-scaled\
    \ (apply list numbers)]\n         [min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (if (= range 0)\n        (map\
    \ (lambda (x) 0) numbers-to-be-scaled)\n        (map (lambda (x) (/ (- x min)\
    \ range)) numbers-to-be-scaled))))\n", "  (let* ([min (apply min numbers)]\n \
    \        [max (apply max numbers)]\n         [scale (/ 1.0 (- max min))])\n  \
    \  (map (/ (- _ min)) numbers)))\n", "  (let ([min-val (apply min numbers)]\n\
    \        [max-val (apply max numbers)])\n    (map (lambda (n) (/ (- n min-val)\
    \ (- max-val min-val))) numbers)))\n", "  (let* ([min-max (min-max numbers)]\n\
    \         [mn (car min-max)]\n         [mx (cadr min-max)]\n         [delta (-\
    \ mx mn)])\n    (if (= delta 0)\n        (map (lambda (x) (/ x mn)) numbers)\n\
    \        (map (lambda (x) (/ (- x mn) delta)) numbers))))\n", "  (let ([min (apply\
    \ min numbers)]\n        [max (apply max numbers)])\n    (map (lambda (number)\
    \ (/ (- number min) (- max min))) numbers)))\n", "  (let ([range (apply - (apply\
    \ min-max numbers))])\n    (map (lambda (number) (/ (- number (min numbers)) range))\
    \ numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n\
    \    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n```\n\n##### Racket\
    \ version\n\n```racket\n#lang racket\n", "  (let* ([min-numbers (apply min numbers)]\n\
    \         [max-numbers (apply max numbers)]\n         [diff-numbers (- max-numbers\
    \ min-numbers)])\n    (map (\u03BB (n) (/ (- n min-numbers) diff-numbers)) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [range (- max min)])\n    (map (lambda (x) (/ (- x min) range)) numbers)))\n",
  "  (define (rescale_to_unit-helper numbers current minimum maximum result)\n   \
    \ (if (empty? numbers)\n        result\n        (let* ([n (first numbers)]\n \
    \              [result (cons (if (zero? maximum) 0 (/ (- n minimum) maximum))\
    \ result)])\n          (rescale_to_unit-helper (rest numbers) n (min current n)\
    \ (max current n) result))))\n  (let* ([numbers (reverse numbers)]\n         [result\
    \ (rescale_to_unit-helper numbers (first numbers) (first numbers) (first numbers)\
    \ empty)])\n    (reverse result)))\n", "  (let\n    ;; keep track of smallest\
    \ and largest numbers as we iterate\n    ((smallest (car numbers))\n     (largest\
    \ (car numbers)))\n    (map\n      (lambda (n)\n        (let ((smallest (min n\
    \ smallest))\n              (largest (max n largest)))\n          (\n        \
    \    ;; scale number\n            (/ (- n smallest) (- largest smallest))\n  \
    \        )\n        )\n      )\n      numbers\n    )\n  )\n)\n", "  (let* ([min\
    \ (apply min numbers)]\n         [max (apply max numbers)]\n         [range (-\
    \ max min)])\n    (map (lambda (n) (/ (- n min) range)) numbers)))\n", "  (define\
    \ (trs lst min max)\n    (cond\n      [(empty? lst) empty]\n      [else (cons\
    \ (/ (- (first lst) min) (- max min)) (trs (rest lst) min max))]))\n  (define\
    \ (minnums lst min current)\n    (cond\n      [(empty? lst) min]\n      [else\
    \ (minnums (rest lst) (if (< (first lst) current) (first lst) current) (first\
    \ lst))]))\n  (define (maxnums lst max current)\n    (cond\n      [(empty? lst)\
    \ max]\n      [else (maxnums (rest lst) (if (> (first lst) current) (first lst)\
    \ current) (first lst))]))\n  (trs numbers (minnums numbers (first numbers) (first\
    \ numbers)) (maxnums numbers (first numbers) (first numbers))))\n", "  (define\
    \ (helper res lst)\n    (cond [(empty? lst) res]\n          [else (helper (cons\
    \ (first lst / (last res)) res) (rest lst))]))\n  (reverse (helper (list (last\
    \ numbers)) (reverse numbers))))\n", "  (let* ([lo (apply min numbers)]\n    \
    \     [hi (apply max numbers)]\n         [a (/ (- 1.0) (- hi lo))]\n         [b\
    \ (* (- 0.0) (- hi lo))])\n    (map (lambda (x) (+ (* a x) b)) numbers)))\n",
  "  (let ([min (-&gt;&gt; numbers\n                  (map real-&gt;inexact)\n   \
    \               (apply min))]\n        [max (-&gt;&gt; numbers\n             \
    \     (map real-&gt;inexact)\n                  (apply max))])\n    (map (lambda\
    \ (x)\n           (/ (- (real-&gt;inexact x) min)\n              (- max min)))\n\
    \         numbers)))\n", "  (define min (apply min numbers))\n  (define max (apply\
    \ max numbers))\n  (for/list ([number numbers])\n    (/ (- number min) (- max\
    \ min))))\n", "  (define (rescale n)\n    (/ (- n (min numbers))\n       (- (max\
    \ numbers) (min numbers))))\n  (map rescale numbers))\n", "  (define minval (apply\
    \ min numbers))\n  (define maxval (apply max numbers))\n  (map (lambda (x) (/\
    \ (- x minval) (- maxval minval))) numbers))\n", "  (let* ([numbers_count (length\
    \ numbers)]\n         [min_val (apply min numbers)]\n         [max_val (apply\
    \ max numbers)]\n         [length (sub1 numbers_count)])\n    (for/list ([numbers\
    \ numbers])\n      (/ (- n min_val) (- max_val min_val)))))\n", "  (let ([min-value\
    \ (apply min numbers)]\n        [max-value (apply max numbers)])\n    (map (lambda\
    \ (x)\n           (/ (- x min-value) (- max-value min-value)))\n         numbers)))\n",
  "  (define (rescale n min max)\n    (/ (- n min) (- max min)))\n  (define min (apply\
    \ min numbers))\n  (define max (apply max numbers))\n  (map (\u03BB (n) (rescale\
    \ n min max)) numbers))\n", "  (let* ([min (apply min numbers)]\n         [max\
    \ (apply max numbers)]\n         [diff (- max min)])\n    (map\n     (lambda (n)\n\
    \       (/ (- n min) diff))\n     numbers)))\n", "  (let* ([all-numbers-but-first\
    \ (rest numbers)]\n         [min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [delta (- max min)])\n    (map (lambda (x)\n           (/\
    \ (- x min) delta))\n         numbers)))\n", "  (define (divide_by n x) (/ x n))\n\
    \  (define (subtract_by n x) (- x n))\n  (define my-min (apply min numbers))\n\
    \  (define my-max (apply max numbers))\n  (define (helper n)\n    (divide_by (-\
    \ my-max my-min) (subtract_by my-min n)))\n  (map helper numbers))\n", "  (define\
    \ (min-max-of lst)\n    (for/fold ([min (first lst)]\n               [max (first\
    \ lst)])\n        ([val (in-list (rest lst))])\n      (values (min min val) (max\
    \ max val))))\n  (define (apply-linear-transform lst min max)\n    (for/list ([x\
    \ (in-list lst)])\n      (/ (- x min) (- max min))))\n  (apply-linear-transform\
    \ numbers (apply min-max-of numbers)))\n", "  (map (curry scale-linear-transform\
    \ (min numbers) (max numbers)) numbers))\n", "  (define (rescale_to_unit-helper\
    \ pairs)\n    (define min-pair (apply min pairs))\n    (define max-pair (apply\
    \ max pairs))\n    (define min-val (car min-pair))\n    (define max-val (car max-pair))\n\
    \    (define min-index (cdr min-pair))\n    (define max-index (cdr max-pair))\n\
    \    (vector-ref\n     (rescale-with-min-max-index numbers min-val max-val min-index\
    \ max-index)\n     min-index))\n  (rescale_to_unit-helper (vector-indexed numbers)))\n",
  "  (define (rescale_helper old-min old-max new-min new-max x)\n    (+ new-min (*\
    \ (/ (- x old-min) (- old-max old-min)) (- new-max new-min))))\n  (define (rescale_helper_2\
    \ x)\n    (rescale_helper (apply min numbers) (apply max numbers) 0 1 x))\n  (map\
    \ rescale_helper_2 numbers))\n", "  (let* ([min_num (apply min numbers)]\n   \
    \      [max_num (apply max numbers)]\n         [min_max_diff (- max_num min_num)])\n\
    \    (map (lambda (x) (/ (- x min_num) min_max_diff)) numbers)))\n", "  (let*\
    \ ([numbers sorted] (sort numbers #&lt;=?))\n         [min (first numbers)]\n\
    \         [max (last numbers)])\n    (map (lambda (num) (/ (- num min) (- max\
    \ min))) numbers)))\n</code>\n", "  (define (clamp n)\n    (min 1 (max 0 n)))\n\
    \  (define (transform n)\n    (clamp (/ (- n min) (- max min))))\n  (define min\
    \ (apply min numbers))\n  (define max (apply max numbers))\n  (map transform numbers))\n",
  "  (define (recur numbers biggest smallest result)\n    (cond\n      [(empty? numbers)\
    \ result]\n      [(= (first numbers) biggest)\n       (recur (rest numbers) biggest\
    \ smallest (append result (list 1.0)))]\n      [(= (first numbers) smallest)\n\
    \       (recur (rest numbers) biggest smallest (append result (list 0.0)))]\n\
    \      [else\n       (recur (rest numbers) biggest smallest\n              (append\
    \ result (list (/ (- (first numbers) smallest) (- biggest smallest)))))]))\n \
    \ (recur numbers (apply max numbers) (apply min numbers) (list)))\n", "  (let\
    \ ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map (\u03BB\
    \ (num)\n           (/ (- num min) (- max min)))\n         numbers)))\n```\n\n\
    But a quick implementation in Scheme is not enough, we also need to be able to\
    \ benchmark it.\n\nFor that, I'm going to use Racket's `time` function, which\
    \ can be used like this:\n\n```racket\n#lang racket\n", "  (let ([min (apply min\
    \ numbers)]\n        [max (apply max numbers)])\n    (map (\u03BB (x) (/ (- x\
    \ min) (- max min))) numbers)))\n```\n\n## Tests\n\n```racket", "  (let* ([numbers-count\
    \ (length numbers)]\n         [min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [range (- max min)])\n    (map (lambda (n) (/ (- n min)\
    \ range)) numbers)))\n", "  (let* ([min (apply min numbers)]\n         [max (apply\
    \ max numbers)]\n         [delta (- max min)])\n    (map (lambda (x) (if (equal?\
    \ 0 delta) (/ x max) (/ (- x min) delta))) numbers)))\n", "  (define (find-min-max\
    \ numbers min max)\n    (if (null? numbers)\n        (list min max)\n        (let\
    \ ((num (car numbers)))\n          (find-min-max (cdr numbers) (if (< num min)\
    \ num min) (if (> num max) num max)))))\n  (let* ((min-max (find-min-max numbers\
    \ (car numbers) (car numbers)))\n         (min (car min-max))\n         (max (cadr\
    \ min-max))\n         (diff (- max min)))\n    (if (< diff 0.001)\n        '()\n\
    \        (cons (if (equal? min max) 0.0 (/ (- (car numbers) min) diff))\n    \
    \          (rescale_to_unit (cdr numbers))))))\n", "  (let* ([min-num (apply min\
    \ numbers)]\n         [max-num (apply max numbers)]\n         [diff-nums (- max-num\
    \ min-num)])\n    (cond [(= diff-nums 0) (map (\u03BB (n) 0) numbers)]\n     \
    \     [else (map (\u03BB (n) (/ (- n min-num) diff-nums)) numbers)])))\n", " \
    \ (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n    (map\
    \ (lambda (x) (/ (- x min) (- max min))) numbers)))\n", "  (let* ([min (apply\
    \ min numbers)]\n         [max (apply max numbers)]\n         [delta (- max min)])\n\
    \    (if (= delta 0)\n        (make-list (length numbers) 0)\n        (map (lambda\
    \ (e) (/ (- e min) delta)) numbers))))\n", "  (define min (apply min numbers))\n\
    \  (define max (apply max numbers))\n  (map\n   (lambda (x)\n     (/ (- x min)\
    \ (- max min)))\n   numbers))\n", "  (let ((list (list->vector numbers)))\n  \
    \  (let ((list-min (vector-min list))\n          (list-max (vector-max list)))\n\
    \      (vector-map\n       (lambda (n)\n         (/ (- n list-min) (- list-max\
    \ list-min)))\n       list))))\n", "  (define (transform n)\n    (/ (- n (first\
    \ min-max)) (- (second min-max) (first min-max))))\n  (define min-max (list (apply\
    \ min numbers) (apply max numbers)))\n  (map transform numbers))\n", "  (let*\
    \ ([min-value (apply min numbers)]\n         [max-value (apply max numbers)]\n\
    \         [offset    (- min-value)]\n         [scale     (- max-value min-value)])\n\
    \    (map (lambda (number)\n           (/ (- number offset) scale))\n        \
    \ numbers)))\n", "  (let ([min-number (apply min numbers)]\n        [max-number\
    \ (apply max numbers)])\n    (if (= max-number min-number)\n        (for/list\
    \ ([n (in-list numbers)])\n          0)\n        (for/list ([n (in-list numbers)])\n\
    \          (/ (- n min-number) (- max-number min-number))))))\n", "  (let* ([minimum\
    \ (apply min numbers)]\n         [maximum (apply max numbers)]\n         [unit-range\
    \ (- maximum minimum)])\n    (map (lambda (n)\n           (/ (- n minimum) unit-range))\n\
    \         numbers)))\n", "  (define min_value (apply min numbers))\n  (define\
    \ max_value (apply max numbers))\n  (define range (- max_value min_value))\n \
    \ (map (lambda (x) (/ (- x min_value) range)) numbers))\n", "  (map (lambda (number)\n\
    \         (/ (- number (apply min numbers))\n            (- (apply max numbers)\
    \ (apply min numbers))))\n       numbers))\n", "  (let ([min-num (apply min numbers)]\n\
    \        [max-num (apply max numbers)])\n    (map (lambda (x) (/ (- x min-num)\
    \ (- max-num min-num))) numbers)))\n", "  (define minimum (apply min numbers))\n\
    \  (define maximum (apply max numbers))\n  (define delta (sub1 maximum))\n  (define\
    \ (tr f)\n    (if (eq? f minimum)\n        0\n        (if (eq? f maximum)\n  \
    \          1\n            (/ (- f minimum) delta))))\n  (map tr numbers))\n",
  "  (define (fn n)\n    (/ (- n (car numbers)) (- (car (reverse numbers)) (car numbers))))\n\
    \  (map fn numbers))\n", "  (define (rescale numbers (min '+inf.0) (max '-inf.0))\n\
    \    (cond [(empty? numbers) (cons min (cons max '()))]\n          [else (rescale\
    \ (rest numbers) (min-number min (first numbers)) (max-number max (first numbers)))]))\n\
    \  (define (rescale_help numbers min max)\n    (cond [(empty? numbers) '()]\n\
    \          [else (cons (/ (- (first numbers) min) (- max min)) (rescale_help (rest\
    \ numbers) min max))]))\n  (rescale_help numbers (first (rescale numbers)) (second\
    \ (rescale numbers))))\n", "  (define (r min max x)\n    (/ (- x min) (- max min)))\n\
    \  (apply map (lambda (x) (r (apply min numbers) (apply max numbers) x)) numbers))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [scale (/ (- max min) 1.0)])\n    (map (lambda (n) (/ (- n min) scale)) numbers)))\n",
  "  (define (rescale_value value)\n    (/ (- value min)\n       (- max min)))\n \
    \ (define (rescale_values)\n    (map rescale_value numbers))\n  (define min (min\
    \ numbers))\n  (define max (max numbers))\n  (rescale_values))\n", "  (map (lambda\
    \ (x) (/ (- x (min-in-list numbers)) (- (max-in-list numbers) (min-in-list numbers))))\
    \ numbers))\n", "  (if (empty? numbers)\n      empty\n      (if (empty? (rest\
    \ numbers))\n          (list 0)\n          (let ([delta (/ (- (apply max numbers)\
    \ (apply min numbers)) 1.0)])\n            (if (zero? delta)\n               \
    \ (map (lambda (n) (/ n (apply max numbers))) numbers)\n                (map (lambda\
    \ (n) (/ (- n (apply min numbers)) delta)) numbers))))))\n```\n\n## Python\n\n\
    ```python\n# Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n# such that the smallest number will become 0 and the\
    \ largest will become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0,\
    \ 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers):\n    if len(numbers) ==\
    \ 0:\n        return []\n    if len(numbers) == 1:\n        return [0]\n    delta\
    \ = max(numbers) - min(numbers)\n    if delta == 0:\n        return [n / max(numbers)\
    \ for n in numbers]\n    return [(n - min(numbers)) / delta for n in numbers]\n\
    ```\n\n## Haskell\n\n```haskell\n-- Given list of numbers (of at least two elements),\
    \ apply a linear transform to that list,\n-- such that the smallest number will\
    \ become 0 and the largest will become 1\n-- >>> rescale_to_unit [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]\n-- [0.0, 0.25, 0.5, 0.75, 1.0]\nrescale_to_unit :: (Ord a, Fractional\
    \ a) => [a] -> [a]\nrescale_to_unit [] = []\nrescale_to_unit [x] = [0]\nrescale_to_unit\
    \ xs =\n  let delta = (maximum xs) - (minimum xs)\n  in\n    if delta == 0\n \
    \   then (map (/ (maximum xs)) xs)\n    else (map ((/", "  (let ([min (min numbers)]\n\
    \        [max (max numbers)])\n    (map (lambda (x) (/ (- x min) (- max min)))\
    \ numbers)))\n", "  (let ([min (apply min numbers)]\n        [max (apply max numbers)])\n\
    \    (map (\u03BB (x) (/ (- x min) (- max min))) numbers)))\n```\n\n# \u8ACB\u4F7F\
    \u7528 Java \u5BE6\u4F5C\u4E0A\u8FF0\u7A0B\u5F0F\u78BC\u3002\n\n```java\nimport\
    \ java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class RescaleToUnit\
    \ {\n    public static void main(String[] args) {\n        rescaleToUnit(new double[]{1.0,\
    \ 2.0, 3.0, 4.0, 5.0}).forEach(System.out::println);\n    }\n\n    public static\
    \ double[] rescaleToUnit(double[] numbers) {\n        double min = Arrays.stream(numbers).min().getAsDouble();\n\
    \        double max = Arrays.stream(numbers).max().getAsDouble();\n        return\
    \ Arrays.stream(numbers).map(x -> (x - min) / (max - min)).toArray();\n    }\n\
    }\n```\n\n```\n0.0\n0.25\n0.5\n0.75\n1.0\n```\n\n# \u8ACB\u4F7F\u7528 Haskell\
    \ \u5BE6\u4F5C\u4E0A\u8FF0\u7A0B\u5F0F\u78BC\u3002\n\n```haskell\n-- Given list\
    \ of numbers (of at least two elements), apply a linear transform to that list,\n\
    -- such that the smallest number will become 0 and the largest will become 1\n\
    -- >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n-- [0.0, 0.25, 0.5, 0.75, 1.0]\n\
    \nmodule RescaleToUnit where\n\nrescaleToUnit :: (Ord a, Fractional a) => [a]\
    \ -> [a]\nrescaleToUnit numbers =\n  let min = minimum numbers\n      max = maximum\
    \ numbers\n  in map (\\x -> (x - min) / (max - min)) numbers\n```\n\n```\n$ ghci\
    \ RescaleToUnit.hs\nGHCi, version 8.4.3: http://www.haskell.org/ghc", "  (define\
    \ minimum_number (apply min numbers))\n  (define maximum_number (apply max numbers))\n\
    \  (define (map_func x)\n    (/ (- x minimum_number) (- maximum_number minimum_number)))\n\
    \  (map map_func numbers))\n", "  (let* ([diff (- (apply max numbers) (apply min\
    \ numbers))]\n         [scale (/ 1 diff)])\n    (map (/ (- _ (apply min numbers))\
    \ diff) numbers)))\n```\n\n```text\n>>> (rescale_to_unit [1.0, 2.0, 3.0, 4.0,\
    \ 5.0])\n'(0.0 0.25 0.5 0.75 1.0)\n```\n\n### Task 4\n\n``` #lang racket\n", " \
    \ (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n     \
    \    [diff (- max min)])\n    (map (lambda (number) (/ (- number min) diff)) numbers)))\n",
  "  (let ((min (apply min numbers))\n        (max (apply max numbers)))\n    (map\
    \ (\u03BB (x) (/ (- x min) (- max min))) numbers)))\n", "  (let ([largest (apply\
    \ max numbers)]\n        [smallest (apply min numbers)])\n    (map (lambda (num)\
    \ (/ (- num smallest) (- largest smallest))) numbers)))\n", "  (match-define (list\
    \ minn maxx) (min-max numbers))\n  (map (\u03BB (n) (/ (- n minn) (- maxx minn)))\
    \ numbers))\n", "  (let* ([min (apply min numbers)]\n         [max (apply max\
    \ numbers)]\n         [factor (/ 1.0 (- max min))])\n    (map (lambda (number)\n\
    \           (* (- number min) factor))\n         numbers)))\n", "  (let* ([min\
    \ (apply min numbers)]\n         [max (apply max numbers)]\n         [len (length\
    \ numbers)])\n    (for/list ([(i (in-range len))])\n      (/ (- (list-ref numbers\
    \ i) min) (- max min)))))\n", "  (let ([max (apply max numbers)]\n        [min\
    \ (apply min numbers)])\n    (map (lambda (n) (/ (- n min) (- max min))) numbers)))\n\
    ```\n\n```\n#lang racket\n", "  (define (unit n)\n    (/ (- n (min numbers)) (-\
    \ (max numbers) (min numbers))))\n  (map unit numbers))\n", "  (define min-num\
    \ (apply min numbers))\n  (define max-num (apply max numbers))\n  (map (lambda\
    \ (x) (/ (- x min-num) (- max-num min-num))) numbers))\n```\n\n```\njared@Jareds-MacBook-Pro\
    \ ~/Desktop/Programming_Exercises/python\n$ python rescale_to_unit.py\n[0.0, 0.25,\
    \ 0.5, 0.75, 1.0]\n```\n\n[Python solution](https://github.com/compciv/daily-coding-problem/blob/master/solutions/problem_018_R_Py.md)\n\
    \n### Day 19: Lowest Common Ancestor of a Binary Search Tree\n\nThis problem was\
    \ asked by Facebook.\n\nGiven a binary search tree, find the lowest common ancestor\
    \ of two given nodes in the tree. Assume that each node in the tree also has a\
    \ pointer to its parent.\n\n```scheme\n#lang racket\n", "  (let* ([min (apply\
    \ min numbers)]\n         [range (- (apply max numbers) min)])\n    (map (lambda\
    \ (n) (/ (- n min) range)) numbers)))\n", "  (define min-value (apply min numbers))\n\
    \  (define max-value (apply max numbers))\n  (map\n   (lambda (number)\n     (/\
    \ (- number min-value) (- max-value min-value)))\n   numbers))\n```\n\nYou will\
    \ find other cases where a linear transform is used to normalize data, for instance,\
    \ in the field of [Image Processing](https://en.wikipedia.org/wiki/Normalization_(image_processing)).\n\
    \n### Normal Distribution\n\n![Normal Distribution](images/normal-distribution.jpg)\n\
    \nAlthough we are not going to talk about how to generate a normal distribution\
    \ of data, it's worth mentioning that this is one of the most common distributions\
    \ that we can encounter in real life: [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution)\
    \ or Gaussian distribution. This distribution is the result of a linear combination\
    \ of uncorrelated random variables.\n\n![Normal Distribution Formula](images/normal-distribution-formula.jpg)\n\
    \nSo, if we have uncorrelated random variables in our dataset, the resulting distribution\
    \ is a normal distribution.\n\n### Covariance\n\n![Covariance](images/covariance.jpg)\n\
    \nWe know that, in order to get a normal distribution of data, the variables should\
    \ be uncorrelated. So, how can we know if a variable is correlated with another\
    \ variable?\n\nAs you can see in the image above, we can calculate the correlation\
    \ of two variables by using the covariance of them. The covariance is a measure\
    \ of how much two random variables vary together. In fact, a covariance matrix\
    \ is a matrix of covariances between the elements of a vector.\n\nThe formula\
    \ of the covariance is:\n\n![Covariance Formula](images/covariance-formula.jpg)\n\
    \nSo, if the covariance of two variables is zero, that means that the two variables\
    \ are uncorrelated.\n\nIf the covariance is positive, that means that both variables\
    \ move in the same direction. If the covariance is negative, that means that the\
    \ variables move in opposite directions.\n\n### Pearson Correlation\n\n![Pearson\
    \ Correlation](images/pearson-correlation.jpg)\n\nBesides the covariance, we can\
    \ also use another way to measure how two", "  (let* ([min (apply min numbers)]\n\
    \         [max (apply max numbers)]\n         [diff (- max min)])\n    (map (lambda\
    \ (n) (/ (- n min) diff)) numbers)))\n", "  (let* ([min-val (apply min numbers)]\n\
    \         [max-val (apply max numbers)]\n         [denominator (- max-val min-val)])\n\
    \    (if (zero? denominator)\n        numbers\n        (map (\u03BB (x) (/ (-\
    \ x min-val) denominator)) numbers))))\n", "  (let* ([minimum (apply min numbers)]\n\
    \         [maximum (apply max numbers)]\n         [range (- maximum minimum)])\n\
    \    (map (lambda (x) (/ (- x minimum) range)) numbers)))\n```\n\n```Python\n\
    def rescale_to_unit(numbers):\n    minimum = min(numbers)\n    maximum = max(numbers)\n\
    \    range = maximum - minimum\n    return [float(n - minimum) / range for n in\
    \ numbers]\n```\n\n```Clojure", "  (define max-val (apply max numbers))\n  (define\
    \ min-val (apply min numbers))\n  (map\n   (lambda (x) (/ (- x min-val) (- max-val\
    \ min-val)))\n   numbers))\n", "  (let ([min (apply min numbers)]\n        [max\
    \ (apply max numbers)])\n    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n\
    ```\n\n```racket\n#lang racket\n", "  (let* ([min (apply min numbers)]\n     \
    \    [max (apply max numbers)]\n         [diff (- max min)])\n    (map\n     (lambda\
    \ (number)\n       (/ (- number min) diff))\n     numbers)))\n", "  (define sorted-numbers\
    \ (sort numbers <))\n  (let ((min (car sorted-numbers))\n        (max (car (reverse\
    \ sorted-numbers))))\n    (map (lambda (n) (/ (- n min) (- max min))) numbers)))\n",
  "  (let* ([min_value (apply min numbers)]\n         [max_value (apply max numbers)]\n\
    \         [difference (- max_value min_value)])\n    (if (not (number? difference))\n\
    \        '()\n        (map (lambda (n)\n               (/ (- n min_value) difference))\n\
    \             numbers))))\n", "  (define min (apply min numbers))\n  (define max\
    \ (apply max numbers))\n  (define range (- max min))\n  (define (unit x) (/ (-\
    \ x min) range))\n  (map unit numbers))\n", "  (apply map\n         (lambda (x)\n\
    \           (/ (- x (apply min numbers))\n              (- (apply max numbers)\
    \ (apply min numbers))))\n         numbers))\n", "  (local\n    ;; Given list\
    \ of numbers, return the minimum and maximum value\n    ([minmax numbers]\n  \
    \   (let* ([min_max (apply minmax numbers)]\n            [minimum (car min_max)]\n\
    \            [maximum (cadr min_max)])\n       (values minimum maximum)))\n  \
    \  ;; Given list of numbers, return the minimum and maximum value\n    ([rescale-number\
    \ numbers minimum maximum]\n     (let* ([number (car numbers)]\n            [ratio\
    \ (/ (- number minimum) (- maximum minimum))])\n       (cons ratio (rescale-number\
    \ (cdr numbers) minimum maximum))))\n    (let* ([min_max (minmax numbers)]\n \
    \          [minimum (car min_max)]\n           [maximum (cadr min_max)])\n   \
    \   (rescale-number numbers minimum maximum))))\n```\n\n```\n> (rescale-to-unit\
    \ (list 1.0 2.0 3.0 4.0 5.0))\n'(0.0 0.25 0.5 0.75 1.0)\n```\n\n## Scaling to\
    \ arbitrary range\n\nIf you need to scale numbers to arbitrary range, extend `rescale-to-unit`\
    \ function to accept\ntarget range. `(rescale-to-unit numbers 10.0 20.0)`\n\n\
    ```racket\n#lang racket\n", "  (cond [(= (length numbers) 2) numbers]\n      \
    \  [else (cond [(= (length numbers) 3)\n                     (list (first numbers)\
    \ (/ (second numbers) 3) (/ (third numbers) 3))]\n                    [else (cond\
    \ [(= (length numbers) 4)\n                                 (list (first numbers)\
    \ (/ (second numbers) 4) (/ (third numbers) 4) (/ (fourth numbers) 4))]\n    \
    \                            [else (cond [(= (length numbers) 5)\n           \
    \                                  (list (first numbers) (/ (second numbers) 5)\
    \ (/ (third numbers) 5) (/ (fourth numbers) 5) (/ (fifth numbers) 5))]\n     \
    \                                       [else (cond [(= (length numbers) 6)\n\
    \                                                         (list (first numbers)\
    \ (/ (second numbers) 6) (/ (third numbers) 6) (/ (fourth numbers) 6) (/ (fifth\
    \ numbers) 6) (/ (sixth numbers) 6))]\n                                      \
    \                  [else (cond [(= (length numbers) 7)\n                     \
    \                                                (list (first numbers) (/ (second\
    \ numbers) 7) (/ (third numbers) 7) (/ (fourth numbers) 7) (/ (fifth numbers)\
    \ 7) (/ (sixth numbers) 7) (/ (seventh numbers) 7))]\n                       \
    \                                             [else (cond [(= (length numbers)\
    \ 8)\n                                                                       \
    \          (list (first numbers) (/ (second numbers) 8) (/ (third numbers) 8)\
    \ (/ (fourth numbers) 8) (/ (fifth numbers) 8) (/ (sixth numbers) 8) (/ (seventh\
    \ numbers) 8) (/ (eighth numbers) 8))]\n                                     \
    \                                           [else (cond [(= (length numbers) 9)\n\
    \                                                                            \
    \                 (list (first numbers) (/ (second numbers) 9) (/ (third numbers)\
    \ 9) (/ (fourth numbers) 9) (/ (fifth numbers) 9) (/ (sixth numbers) 9) (/ (seventh\
    \ numbers) 9) (/ (eighth numbers) 9) (/ (ninth numbers) 9))]\n               \
    \                                                                            \
    \ [else (cond [(= (length numbers) 10)\n                                     \
    \                                                                    (list (first\
    \ numbers) (/ (second numbers) 10) (/ (third numbers) 10) (/ (fourth numbers)\
    \ 10)", "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n\
    \         [diff (- max min)])\n    (map (\u03BB (n) (/ (- n min) diff)) numbers)))\n",
  "  (let ((smallest (min numbers))\n        (largest (max numbers)))\n    (map (\u03BB\
    \ (x) (/ (- x smallest) (- largest smallest))) numbers)))\n", "  (define (actual-rescale\
    \ x) (/ (- x (list-min numbers)) (- (list-max numbers) (list-min numbers))))\n\
    \  (map actual-rescale numbers))\n", "  (define (apply-lin-transform x)\n    (/\
    \ (- x (apply min numbers)) (- (apply max numbers) (apply min numbers))))\n  (map\
    \ apply-lin-transform numbers))\n", "  (let ([max (apply max numbers)]\n     \
    \   [min (apply min numbers)])\n    (map (lambda (n) (/ (- n min) (- max min)))\
    \ numbers)))\n", "  (define (max_number xs)\n    (cond\n      [(empty? xs) (error\
    \ \"Empty list!\")]\n      [(= 1 (length xs)) (first xs)]\n      [else (max (first\
    \ xs) (max_number (rest xs)))]))\n  (define (min_number xs)\n    (cond\n     \
    \ [(empty? xs) (error \"Empty list!\")]\n      [(= 1 (length xs)) (first xs)]\n\
    \      [else (min (first xs) (min_number (rest xs)))]))\n  (define (scale x)\n\
    \    (/ (- x (min_number numbers)) (- (max_number numbers) (min_number numbers))))\n\
    \  (map scale numbers))\n\n", "  (let\n    ([min-num (apply min numbers)]\n  \
    \   [max-num (apply max numbers)]\n     [diff    (- max-num min-num)])\n    (if\
    \ (number=? diff 0) numbers\n        (map (\u03BB (n) (/ (- n min-num) diff))\
    \ numbers))))\n", "  (map (/ (- 0 (apply min numbers))\n           (- (apply max\
    \ numbers) (apply min numbers)))\n       numbers))\n", "  (define (min_max_info\
    \ numbers)\n    (let ([min (apply min numbers)]\n          [max (apply max numbers)])\n\
    \      (list min max (- max min))))\n  (define (unit_value number min_max_info)\n\
    \    (define (min-info mmi) (list-ref mmi 0))\n    (define (max-info mmi) (list-ref\
    \ mmi 1))\n    (define (range-info mmi) (list-ref mmi 2))\n    (let ([min (min-info\
    \ min_max_info)]\n          [max (max-info min_max_info)]\n          [range (range-info\
    \ min_max_info)])\n      (/ (- number min) range)))\n  (define (map-with-min-max\
    \ f numbers)\n    (let ([min-max-info (min_max_info numbers)])\n      (map (\u03BB\
    \ (x) (f x min-max-info)) numbers)))\n  (map-with-min-max unit_value numbers))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (\u03BB (x)\n           (/ (- x min) diff))\n\
    \         numbers)))\n```\n\n```python\n# Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n# such that the smallest\
    \ number will become 0 and the largest will become 1\n# >>> rescale_to_unit([1.0,\
    \ 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5, 0.75, 1.0]\ndef rescale_to_unit(numbers):\n\
    \    min = min(numbers)\n    max = max(numbers)\n    diff = max - min\n    return\
    \ [ (x - min) / diff for x in numbers ]\n```", "  (let* ([min-value (apply min\
    \ numbers)]\n         [max-value (apply max numbers)]\n         [scale (/ (- 1.0)\
    \ (- max-value min-value))])\n    (map (lambda (x) (* scale (- x min-value)))\
    \ numbers)))\n</code>\nI would like to use the <code>#lang typed/racket</code>\
    \ language, to add type annotations.\nHowever, I'm not sure how to add the types\
    \ to the first argument of the function.\nThis is what I tried:\n<code>#lang typed/racket\n",
  "  (let* ((max (apply max numbers))\n         (min (apply min numbers))\n      \
    \   (diff (- max min)))\n    (map (lambda (e)\n           (/ (- e min) diff))\n\
    \         numbers)))\n", "  (define (min_of numbers)\n    (define (min-of-iter\
    \ a remaining)\n      (if (null? remaining)\n          a\n          (min-of-iter\
    \ (min a (car remaining)) (cdr remaining))))\n    (min-of-iter (car numbers) (cdr\
    \ numbers)))\n  (define (max_of numbers)\n    (define (max-of-iter a remaining)\n\
    \      (if (null? remaining)\n          a\n          (max-of-iter (max a (car\
    \ remaining)) (cdr remaining))))\n    (max-of-iter (car numbers) (cdr numbers)))\n\
    \  (define (rescale-to-unit-iter min max xs)\n    (if (null? xs)\n        '()\n\
    \        (cons (/ (- (car xs) min) (- max min)) (rescale-to_unit (cdr xs)))))\n\
    \  (rescale-to-unit-iter (min_of numbers) (max_of numbers) numbers))\n", "  (let*\
    \ ([smallest (apply min numbers)]\n         [largest (apply max numbers)]\n  \
    \       [range (- largest smallest)])\n    (map\n     (lambda (n)\n       (/ (-\
    \ n smallest) range))\n     numbers)))\n", "  (local ((define min (min-list numbers))\n\
    \          (define max (max-list numbers))\n          (define range (- max min)))\n\
    \    (map (lambda (number) (/ (- number min) range)) numbers)))\n", "  (rescale_to_range\
    \ numbers (apply min numbers) (apply max numbers) 0 1))\n", "  (define min-num\
    \ (apply min numbers))\n  (define max-num (apply max numbers))\n  (define length-num\
    \ (- max-num min-num))\n  (define unit-num (if (zero? length-num) 0 (/ 1.0 length-num)))\n\
    \  (define res (- numbers min-num))\n  (define res (map (lambda (n) (* n unit-num))\
    \ res))\n  res)\n", "  (let ([minval (apply min numbers)]\n        [maxval (apply\
    \ max numbers)])\n    (map (\u03BB (x) (/ (- x minval) (- maxval minval))) numbers)))\n\
    </code>\nAnd when I run it, it gives me a long error:\n<code>&gt; (rescale_to_unit\
    \ (list 1.0 2.0 3.0 4.0 5.0))\n. . application: not a procedure;\nexpected a procedure\
    \ that can be applied to arguments\n  given: 0.0\n  arguments...:\n   -1.0\n \
    \  [thunk]\n</code>\nI'm confused as to why, it should work (a list of numbers\
    \ and outputting a list of numbers). What is the error?\n\n\nA:\n\nYou're importing\
    \ the wrong file. You want:\n<code>#lang planet dyoo/matrix:1:0/matrix\n</code>\n\
    and not:\n<code>#lang planet dyoo/matrix:1:0/matrix-lang\n</code>\nThe latter\
    \ contains a <code>define-syntax</code> for <code>define</code> that makes <code>define</code>\
    \ work differently than you expect (it's actually defined in terms of <code>define-values</code>).\
    \ If you had wanted to use that, then you would have to write:\n<code>#lang planet\
    \ dyoo/matrix:1:0/matrix-lang\n", "  (define sorted-numbers (sort numbers <))\n\
    \  (define first-number (car sorted-numbers))\n  (define last-number (car (reverse\
    \ sorted-numbers)))\n  (map (lambda (number) (/ (- number first-number) (- last-number\
    \ first-number))) numbers))\n", "  (let ([minimum-number (apply min numbers)]\n\
    \        [maximum-number (apply max numbers)])\n    (map (\u03BB (number)\n  \
    \        (/ (- number minimum-number) (- maximum-number minimum-number)))\n  \
    \       numbers)))\n", "  (let* ([lowest_number (apply min numbers)]\n       \
    \  [range (apply - numbers)])\n    (map / (map - numbers (- lowest_number)) range)))\n",
  "  (define (mapfun n)\n    (define (interval)\n      (/ (- n (apply min numbers))\
    \ (- (apply max numbers) (apply min numbers))))\n    (interval))\n  (map mapfun\
    \ numbers))\n", "  (rescale_to_unit-r (min (car numbers) (cadr numbers)) (max\
    \ (car numbers) (cadr numbers)) numbers))\n", "  (let ([min-num (apply min numbers)]\n\
    \        [max-num (apply max numbers)])\n    (map\n     (lambda (x)\n       (/\
    \ (- x min-num) (- max-num min-num)))\n     numbers)))\n", "  (let ((max (apply\
    \ max numbers))\n        (min (apply min numbers)))\n    (map (lambda (x) (/ (-\
    \ x min) (- max min))) numbers)))\n", "  (define (map_fun n) (/ (- n (min numbers))\
    \ (- (max numbers) (min numbers))))\n  (map map_fun numbers))\n", "  (match numbers\n\
    \    [(list num . rest)\n     (let-values ([(min max) (find-min-max numbers)])\n\
    \       (map /\n            (map - numbers (repeat min (length numbers)))\n  \
    \          (list (- max min))))]))\n", "  (if (empty? numbers)\n      empty\n\
    \      (define (rescale_pair lowest-seen highest-seen pair)\n        (let ([new-lowest\
    \ (min lowest-seen (car pair))]\n              [new-highest (max highest-seen\
    \ (car pair))])\n          (cons (/ (- (car pair) new-lowest) (- new-highest new-lowest))\
    \ (cdr pair))))\n    (let ([lowest (first numbers)]\n          [highest (first\
    \ numbers)])\n      (map (\u03BB (pair) (rescale_pair lowest highest pair)) numbers))))\n\
    ```\n\n```racket\n#lang racket\n", "  (let ([min (apply min numbers)]\n      \
    \  [max (apply max numbers)])\n    (map\n     (lambda (x)\n       (/ (- x min)\
    \ (- max min)))\n     numbers)))\n", "  (let ([min (apply min numbers)]\n    \
    \    [max (apply max numbers)])\n    (map (\u03BB (e) (/ (- e min) (- max min)))\
    \ numbers)))\n", "  (define mini (apply min numbers))\n  (define maxi (apply max\
    \ numbers))\n  (define (rescale number)\n    (/ (- number mini) (- maxi mini)))\n\
    \  (map rescale numbers))\n", "  (let ((min (apply min numbers))\n        (max\
    \ (apply max numbers)))\n    (map (lambda (x) (/ (- x min) (- max min))) numbers)))\n",
  "  (let* ([min (apply min numbers)]\n         [max (apply max numbers)]\n      \
    \   [diff (- max min)])\n    (map (lambda (n) (/ (- n min) diff)) numbers)))\n",
  "  (let ([min-num (apply min numbers)]\n        [max-num (apply max numbers)])\n\
    \    (map (lambda (num)\n           (/ (- num min-num) (- max-num min-num)))\n\
    \         numbers)))\n", "  (define (rescale_number number)\n    (/ (- number\
    \ (minimum numbers)) (- (maximum numbers) (minimum numbers))))\n  (map rescale_number\
    \ numbers))\n", "  (let* ([min_max (min_max numbers)]\n         [min (first min_max)]\n\
    \         [max (second min_max)])\n    (map (lambda (n) (/ (- n min) (- max min)))\
    \ numbers)))\n", "  (let ([max_n (apply max numbers)]\n        [min_n (apply min\
    \ numbers)])\n    (map (lambda (n) (/ (- n min_n) (- max_n min_n))) numbers)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
