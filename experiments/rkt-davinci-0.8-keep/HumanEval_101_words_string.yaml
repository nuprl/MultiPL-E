name: HumanEval_101_words_string
language: rkt
prompt: "#lang racket\n\n;; You will be given a string of words separated by commas\
  \ or spaces. Your task is\n;; to split the string into words and return an array\
  \ of the words.\n;; For example:\n;; words_string(\"Hi, my name is John\") == [\"\
  Hi\", \"my\", \"name\", \"is\", \"John\"]\n;; words_string(\"One, two, three, four,\
  \ five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n(define\
  \ (words_string s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n\
  \    (check-equal? (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\"\
  \ \"is\" \"John\"))\n    (check-equal? (candidate \"One, two, three, four, five,\
  \ six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\"))\n    (check-equal?\
  \ (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\"))\n    (check-equal?\
  \ (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\"\
  \ \"four\" \"five\" \"six\"))\n    (check-equal? (candidate \"\") (list ))\n   \
  \ (check-equal? (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\"))\n\
  ))\n\n(test-humaneval)"
completions: ["  (string-split s))\n", "  (split-string s #rx\"\\s+\"))\n", "  (string-split\
    \ s \", \"))\n", "  (string-split s #\",\"))\n```\n\n```scheme\n#lang racket\n",
  "  (regexp-split #rx\",| \" s))\n</code>\n", "  (regexp-split #rx\"[ ,]+\" s))\n\
    </code>\nThe first test passes, but the second one fails with the following error.\n\
    <code>FAILED: [\"words_string\"] (words_string_test.rkt:7)\n    actual: [\"One\"\
    , \"two\", \"three\", \"four\", \"five\", \"six\"]\n    expected: (list \"One\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\")\n</code>\nTests fail for a lot\
    \ of other languages, but that <code>actual</code> line looks normal. So, am I\
    \ missing something, or are the tests wrong?\n\n\nA:\n\nThat's indeed a bug.\n\
    The test is expecting a list, but your answer is an array, so the comparison fails.",
  "  (define (single-split s)\n    (string-split s (rx (or \",\" \" \"))))\n  (define\
    \ (multi-split s)\n    (for/list ([part (in-list (single-split s))])\n      (if\
    \ (string=? part \"\")\n          (list)\n          (list part))))\n  (multi-split\
    \ s))\n", "  (split-string s \"\\\\s+\"))\n", "  (regexp-split #rx\"[ ,]+\" s))\n",
  "  (map string-&gt;symbol (string-split s #\\space #\\,)))\n", "  (let ([s (string-split\
    \ s #rx\",\")]\n        [s (filter empty? s)])\n    (map string-trim s)))\n",
  "  (string-split s #\\space #\\,))\n", "  (regexp-split \"\\\\s+\" s))\n", "  (string-split\
    \ s #rx\",| \"))\n</code>\nIt passes the tests but I'm not sure if that is a valid\
    \ Racket solution since I'm using a <code>regex</code> to split the string.\n",
  "  (split-string s #rx\"[[:space:],]+\"))\n", "  (string-split s \"\\\\,\\\\|\\\\\
    \ \"))\n", "  (regexp-split #rx\"\\s+\" s))\n</code>\n", "  (regexp-split #rx\"\
    ,| \" s))\n", "  (string-&gt;list s))\n", "  (string-split s \"\\\\W+\"))\n",
  "  (string-&gt;list s))\n</code>\nThis sort of works, but it doesn't solve the problem,\
    \ since it creates a list of chars. I know it's simple to do with regex, but I\
    \ want to learn how to do it in Racket.\n\n\nA:\n\nYou could use <code>string-split</code>\
    \ and <code>regexp-match</code> to achieve your task, something like this:\n<code>(define\
    \ (words_string s)\n  (string-split s #rx\"[, ]+\"))\n</code>\n", "  (split-string\
    \ s \"[[:space:]]*[,]?[[:space:]]*\"))\n", "  (map string-normalize-spaces (string-split\
    \ s \",\")))\n", "  (split s))\n", "  (split-string s \"[, ]+\"))\n", "  (regexp-split\
    \ #rx\"[\\s,]+\" s))\n", "  (string-split s \"[, ]+\"))\n", "  (regexp-split #rx\"\
    \\s*[,\\s]\\s*\" s))\n", "  (match s\n    [\"\" '()]\n    [_ (split-string (string-join\
    \ (reverse (regexp-split #rx\"[\" s)) \",\") #rx\"\\s*,\\s*\" 'omit)]))\n", " \
    \ (split-string s \"[, ]+\"))\n", "  (split-string s \"[[:space:]]+\"))\n", " \
    \ (match (split-string s)\n    [('(x ...) x)\n     x]))\n", "  (string-split s\
    \ \" |,\"))\n", "  (string-split s #:regexp (rx (or \",\" \" \"))))\n", "  (regexp-split\
    \ #rx\"[\\s,]+\" s))\n</code>\n", "  (match (regexp-split #rx\",\" s)\n    [`()\
    \ ()]\n    [lst (regexp-split #rx\" \" (string-join lst \" \"))]))\n", "  (string-split\
    \ s (regexp #rx\"[, ]+\")))\n", "  (string-split s #\\space))\n", "  (regexp-split\
    \ #rx(\",\") s))\n</code>\nThis is what I tried:\n<code>#lang racket\n", "  (regexp-split\
    \ s \"[, ]+\"))\n", "  (map string-trim (regexp-split #rx\"[ ,]+\" s)))\n```\n\
    \n```ruby\n#lang racket\n", "  (match (regexp-split #rx\"\\W+\" s)\n    [`(\"\"\
    ) '()]\n    [l l]))\n", "  (regexp-split #rx\"\\s*(?:,\\s*|\\s+)+\" s))\n", " \
    \ (regexp-split #rx\"\\s+\" s))\n</code>\nTest:\n<code>#lang racket\n", "  (if\
    \ (string=? \"\" s)\n      '()\n      (split-string s)))\n", "  (match s\n   \
    \ [([chars ...] . _) (map (\u03BB (c) (string-append #\\Space c)) chars)]))\n",
  "  (string-split s #\"[,\\s+]\"))\n", "  (regexp-split #rx\"\\s|,\" s))\n", "  (split-string\
    \ s #rx\"[ ,]+\"))\n</code>\nThe good thing is this works great. The bad thing\
    \ is that I want to learn both Scheme and Racket and I want to learn them side\
    \ by side. I am also limited in that I don't know how to compile Racket to a <code>.exe</code>\
    \ file (therefore each time I want to run this, I have to open Racket and load\
    \ the <code>.rkt</code> file). I tried to write the same code in <code>Scheme</code>\
    \ but I keep getting the following error:\n<code>$ MzScheme\nWelcome to MzScheme\
    \ v5.2.1 [3m], Copyright (c) 2004-2010 PLT Scheme Inc.\n&gt;(define (words_string\
    \ s)", "  (define (find-word s)\n    (string-split s (regexp \", \") #:max 2))\n\
    \  (mapv (lambda (w) (first (find-word w))) (string-split s \" \")))\n", "  (cond\n\
    \    [(empty? s) empty]\n    [else (list (regexp-match #rx\"\\w+\" s))]))", " \
    \ (regexp-split #rx\"\\s|,\" s))\n</code>\nRegards!\n\n\nA:\n\nYour question is\
    \ a bit vague, but I'm going to try to answer it anyway.\nReading Racket code\n\
    The best way to understand a foreign piece of code is to open it up in DrRacket\
    \ and use its handy debugger.\nIf you have the source code of a program, you can\
    \ open it up in DrRacket, set some breakpoints and run the program. It will stop\
    \ at the breakpoints and you can inspect the state of the program at that point.\n\
    In your case, you can set a breakpoint at the first line of the function, start\
    \ the program and you'll see something like this:\n\nThat's the local state of\
    \ the program. It says that the current procedure is <code>words_string</code>,\
    \ and it has one argument, <code>s</code>, of type <code>string?</code>.\nIf you\
    \ continue running the program, you'll see that the next expression to be evaluated\
    \ is:\n<code>(regexp-split #rx\"\\s|,\" s)\n</code>\nIf you continue running,\
    \ it will evaluate the next expression, which is the <code>define</code>. By now\
    \ you'll have seen all of the code.\nIf the program you're trying to understand\
    \ is a library you've downloaded, you'll probably have to build it in Racket and\
    \ then run it through the debugger.\nCommon Racket idioms\nRacket is very flexible,\
    \ but it's not uncommon to find some idioms used in more than one place.\nFor\
    \ example, instead of using a regular expression to split a string, we can use\
    \ the <code>string-split</code> procedure:\n<code>(define (words_string s)\n \
    \ (string-split s #\\space))\n</code>\nI like to think of the <code>#\\</code>\
    \ followed by a character as the <code>char</code> type, although that's not the\
    \ case.\nIf we want to be more permissive, we can use the <code>or</code> function\
    \ to construct a character predicate that will recognize more than one character:\n\
    <code>(define (words_string s)\n  (string-split s (or #\\space #\\,)))\n</code>\n\
    Finally,", "  (regexp-split #rx\"\\s*[ ,]+\\s*\" s))\n", "  (regexp-split #rx\"\
    [, ]+\" s))\n", "  (match s\n    [(list _) '()]\n    [(list c ...) (cons (string\
    \ (cons c '())) (words_string (string (cdr (list c ...)))))])\n  )\n</code>\n\
    In the last line I want to get a string without the first character. I know that\
    \ I can use <code>(list-rest (list c ...))</code> but I need to construct a string\
    \ (not a list) from this string representation of a list (a list is defined as\
    \ <code>(list c ...)</code>).\n\n\nA:\n\nIn Racket, strings are immutable lists\
    \ of characters, so to extract a substring, you can use <code>list-rest</code>\
    \ directly. You may also want to use <code>string-&gt;list</code> to convert a\
    \ string to a list of characters:\n<code>(define (words_string s)\n  (match (string-&gt;list\
    \ s)\n    [(list _) '()]\n    [(list c ...) (cons (string (cons c '())) (words_string\
    \ (string (list-rest (list c ...)))))]))\n</code>\nNote that <code>words_string</code>\
    \ returns a list of strings, not a list of words.\n", "  (string-&gt;list (regexp-replace\
    \ #rx\" \" s \",\")))\n", "  (split-string s))\n", "  (regexp-split #rx\"\\s+\"\
    \ s))\n", "  (define words (split-string s \",\"))\n  (map string-trim words))\n\
    </code>\nor\n<code>#lang racket\n", "  (regexp-split #rx\"[, ]+\" s))\n", "  (split-string\
    \ s \"[[:space:],]\"))\n", "  (string-split s) )\n", "  (regexp-split #rx\"[,\
    \ ]+\" s))\n", "  (cond\n    [(empty? s) '()]\n    [else (cons (first (string-split\
    \ s #\\,)) (words_string (rest (string-split s #\\,))))]))\n</code>\nI'm still\
    \ new to Racket and its syntax, so I'm wondering whether there's a cleaner and/or\
    \ more idiomatic way to implement this.\n", "  (split-string s \"[ ,]+\"))\n",
  "  (string-split s \",\"))\n", "  (if (empty? s) '()\n      (cons (first (regexp-match\
    \ #rx\"\\w+\" s))\n            (words_string (regexp-replace* #rx\"\\w+,\" \"\"\
    \ s)))))\n", "  (string-split s #rx\",\"))\n", "  (split-string s #:separator\
    \ \"[ ,]+\"))\n", "  (split-string s \"[ ,]+\"))\n", "  (define (punct? c)\n \
    \   (or (char=? c #\\,) (char=? c #\\space)))\n  (let ([chars (string->list s)])\n\
    \    (define (process-string acc word-chars)\n      (cond [(empty? chars)\n  \
    \           (if (empty? word-chars) acc\n                 (cons (list->string\
    \ (reverse word-chars)) acc))]\n            [(punct? (first chars))\n        \
    \     (process-string (cons (list->string (reverse word-chars)) acc)\n       \
    \                      '())]\n            [else (process-string acc (cons (first\
    \ chars) word-chars))]))\n    (reverse (process-string '() '()))))\n", "  (string-split\
    \ s #\",\" #\\space))\n</code>\nPython:\n<code>#!/usr/bin/env python\n\n# You\
    \ will be given a string of words separated by commas or spaces. Your task is\n\
    # to split the string into words and return an array of the words.\n# For example:\n\
    # words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\",\
    \ \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"One\"\
    , \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s):\n   \
    \ return s.split()\n</code>\n\n<code>words_string</code> is a function that takes\
    \ a string as an argument and returns a list of strings.\n<code>string-split</code>\
    \ is a built-in function that takes a string and one or more characters, and splits\
    \ the string on those characters. For example, <code>(string-split \"Hi, my name\
    \ is John\" #\",\")</code> returns <code>'(\"Hi\" \" my name is John\")</code>.\n\
    The two <code>#\\space</code> characters are the literal character space.\nThe\
    \ characters <code>#\\</code> are an escape sequence, and they escape the following\
    \ character as a literal character.\n", "  (match s\n        [\"\" '()]\n    \
    \    [(regexp #rx\"[^, ]+,[^, ]+\") (append (words_string (substring s 0 (regexp-match-end\
    \ 1)))\n                                          (words_string (substring s (regexp-match-end\
    \ 1))))]\n        [(regexp #rx\"[^, ]+\") (append (words_string (substring s 0\
    \ (regexp-match-end 1)))\n                                      (words_string\
    \ (substring s (regexp-match-end 1))))]\n        (_ '())))\n", "  (regexp-split\
    \ #rx\"[,\\s]+\" s))\n", "  (cond [(string=? s \"\") empty]\n        [else (cons\
    \ (first s) (words_string (rest s)))]))\n```\n\n### Results\n* Your solution took\
    \ 33.27 milliseconds\n* The best solution took 11.28 milliseconds\n\n### Discussion\n\
    Your solution took 3.00 times as long as the best solution\nYour solution did\
    \ not match the best solution\n\n## 19.  Rot13\n\nKata details\n\n### Description\n\
    ROT13 is a simple letter substitution cipher that replaces a letter with the letter\
    \ 13 letters after it in the alphabet. ROT13 is an example of the Caesar cipher.\n\
    \nCreate a function that takes a string and returns the string ciphered with Rot13.\
    \ If there are numbers or special characters included in the string, they should\
    \ be returned as they are. Only letters from the latin/english alphabet should\
    \ be shifted, like in the original Rot13 \"implementation\".\n\nPlease note that\
    \ using encode is considered cheating.\n\n### Solution\n```\n#lang racket", " \
    \ (define (words-string-sub s l)\n    (cond ((string=? s \"\") l)\n          ((char-whitespace?\
    \ (string-ref s 0)) (words-string-sub (substring s 1) l))\n          (else (words-string-sub\
    \ (substring s (string-index s #\\,)) (cons (substring s 0 (string-index s #\\\
    ,)) l)))))\n  (words-string-sub s '()))\n", "  (regexp-split #rx\"\\W+\" s))\n\
    </code>\n\nThe above is just a quick example. There is lots of good stuff in Racket's\
    \ documentation.\n", "  (string-split s (regexp #rx\", \")))\n", "  (cond\n  \
    \  [(empty? s) empty]\n    [else (cons (car (string-split s #\\,)) (words_string\
    \ (cdr (string-split s #\\,))))]))\n", "  (string-split s #\\,))\n", "  (define\
    \ (extract_word s)\n    (cond\n      [(string=? \"\" s) \"\" (error \"extract_word:\
    \ invalid s\")]\n      [(string=? \" \" (substring s 0 1)) (extract_word (substring\
    \ s 1))]\n      [(string=? \",\" (substring s 0 1)) (extract_word (substring s\
    \ 1))]\n      [else (begin\n              (set! s (substring s 1))\n         \
    \     (cons (substring s 0 1) (extract_word s)))]))\n  (define (loop_extract_word\
    \ s sx)\n    (if (string=? \"\" s)\n        sx\n        (loop_extract_word (extract_word\
    \ s) (cons (extract_word s) sx))))\n  (loop_extract_word s '()))", "  (string-split\
    \ s #\\space #\\,))\n", "  (string-split s #rx\" *, *\"))\n</code>\n", "  (define\
    \ (my-string-split s char)\n    (regexp-split #rx(~a char) s))\n  (my-string-split\
    \ s \" \"))\n", "  (regexp-split #rx\"\\W+\" s))\n", "  (split-string s \"[ ,]+\"\
    ))\n", "  (if (empty? s) '()\n      (match (regexp-match #rx\"[^ ]+\" s)\n   \
    \          [(list start end) (cons (substring s start end) (words_string (substring\
    \ s end)))]\n             [() '()])))\n", "  (regexp-split #rx\"\\s*[ ,]+\\s*\"\
    \ s))\n", "  (string-split s #\\,))\n\n", "  (split-string s #\"[ ,]+\"))\n",
  "  (regexp-split #rx\"\\s+\" s))\n", "  (regexp-split #rx\"\\s+\" s))\n", "  (string-split\
    \ s))\n", "  (regexp-split #rx\"\\s|,\" s))\n", "  (map (lambda (x) (string-trim\
    \ x)) (regexp-split #rx\",\" s)))\n", "  (split-string s \"[, ]\"))\n", "  (string-split\
    \ s #rx\" |,\"))\n", "  (map (curry string-trim) (string-split s \" |,\")))\n\
    ```\n\n### Testing\n\n```racket\n#lang racket\n", "  (match s\n    [,a ,b ,c]\n\
    \    [(string-split s #\\,)])\n  )\n", "  (string-split s #\\,))\n</code>\nHere\
    \ is the error message I am getting:\n<code>Welcome to DrRacket, version 6.11\
    \ [3m].\nLanguage: racket [custom]; memory limit: 128 MB.\nstring-split: string:\
    \ expects argument of type &lt;string&gt;; given \"Hi, my name is John\"\n&gt;\
    \ \n</code>\nI am not sure what is wrong with this line and I think I am following\
    \ the syntax correctly.\n\n\nA:\n\n<code>string-split</code> is expecting a string\
    \ as the first argument. You are passing in a list. This seems to be a syntax\
    \ error in the code.\n", "  (split-string s (regexp #rx\"\\\\s|,\") #:omit-nulls?\
    \ #t))\n", "  (regexp-split #rx\"\\s|,\" s))\n", "  (regexp-split #rx\" |,\" s))\n",
  "  (define words (string-split s))\n  (if (or (eq? words \"\") (eq? words \" \"\
    ))\n      '()\n      words))\n", "  (regexp-split #rx\"\\\\s*[,\\\\s]\\\\s*\"\
    \ s))\n```\n\nWhat is a regular expression?\n\n## Putting this all together\n\n\
    - Create a string that contains a comma separated list of your favorite foods.\n\
    - Split the string into individual words\n- Create a directory called `my-fav-foods`\n\
    - Inside that directory, create a file for each word in the list of your favorite\
    \ foods\n- Start each file with `#lang racket`\n- Inside each file, output the\
    \ following:\n\n```", "  (map string-&gt;symbol (string-split s #\\,)))\n", " \
    \ (string-split s #rx\",\\s*\"))\n</code>\n", "  (define (collapse x y)\n    (cond\
    \ ((equal? x \"\") y)\n          ((equal? y \"\") x)\n          ((equal? (string-length\
    \ x) 1) (string-append x y))\n          ((equal? (string-length y) 1) (string-append\
    \ x y))\n          (else (string-append x (string-append \", \" y)))))\n  (apply\
    \ string-split (regexp #rx\",? \") s #:collapse collapse))\n```\n\n7. Regexp\n\
    ```racket\n#lang racket\n", "  (string-split s \"\\\\W+\"))\n", "  (map string-&gt;symbol\
    \ (string-split s)))\n", "  (regexp-split #rx\"[, ]+\" s))\n", "  (split-string\
    \ s))\n", "  (split-string s \"[, ]+\"))\n", "  (regexp-split #rx\"\\s*[,\\s]+\\\
    s*\" s))\n", "  (if (string=? \"\" s)\n      '()\n      (cons (car (split-at-first-occurrence\
    \ #\\, s))\n            (words_string (cdr (split-at-first-occurrence #\\, s))))))\n",
  "  (split-string s \"[, ]+\"))\n", "  (string-split s #rx\"(\\s|,)+\"))\n", "  (regexp-split\
    \ #rx\"[ ,]+\" s))\n", "  (map (lambda (x) (string-trim x)) (string-split s #\\\
    ,)))\n</code>\n", "  (regexp-split #rx\"\\s|,\" s))\n", "  (split-string s \"\
    [, ]+\"))\n", "  (regexp-split #rx\",|\\s+\" s))\n", "  (string-split s))\n",
  "  (split-string s \"[, ]+\"))\n", "  (string-split s \",\" \" \"))\n", "  (string-split\
    \ s (rx (| (any \" \") \",\"))))\n", "  (map (\u03BB (s) (symbol->string s)) (string-split\
    \ s)))\n", "  (split-string s \"[[:space:],]+\"))\n", "  (regexp-split #rx\"\\\
    s|,\" s))\n", "  (split s #\\, #\\Space))\n", "  (split s \",\" \" \"))\n", " \
    \ (string-split s #\\,))\n", "  (regexp-split #rx\",\\s*|\\s+\" s))\n</code>\n",
  "  (regexp-split #rx\"\\s*[,\\s]\\s*\" s))\n", "  (string-&gt;list (regexp-replace\
    \ #rx\"\\\\s+\" s \", \")))\n", "  (regexp-split #rx\", |\" s))\n", "  (regexp-split\
    \ #rx\"\\s*(?:,|\\s)\\s*\" s))\n", "  (split-string s))\n", "  (string-split s\
    \ #rx\",\\s*\"))\n", "  (filter string? (regexp-split \",\" s)))\n</code>\n",
  "  (split-string s \"\\\\s+\" #:trim? #t))\n", "  (split-string s #:whitespace?\
    \ #t #:separator (list \",\" \" \")))\n", "  (match s\n    [\"\" empty]\n    [any\
    \ (list (regexp-match #rx\"[^, ]+\" s))]))\n", "  (regexp-split #rx\" *, *\" s))\n",
  "  (regexp-split #rx\" *, *\" s))\n", "  (regexp-split #rx\"\\s*[, ]\\s*\" s))\n",
  "  (regexp-split #rx\"\\s|,\" s))\n", "  (string-split s #\"\\s+\"))\n", "  (split-string\
    \ s \"[[:space:]]*[,]?[[:space:]]*\"))\n</code>\nTest cases:\n<code>;; Default\
    \ output:", "  (regexp-split #rx\"[, ]+\" s))\n", "  (split-string s \"[ \\t\\\
    n]*[, ]+[ \\t\\n]*\"))\n", "  (regexp-split #rx\"\\s+\" s))\n", "  (string-split\
    \ s (string-join (string-&gt;list \" ,\\n\") \"\")))\n</code>\nThe error I'm getting\
    \ is:\n<code>application: not a procedure;\n expected a procedure that can be\
    \ applied to arguments\n  given: #(32 44 10)\n  arguments...:\n   #&lt;procedure:car&gt;\n\
    \   #&lt;procedure:cdr&gt;\n   #&lt;procedure:is-pair?&gt;\n   #&lt;procedure:string-contains?&gt;\n\
    \   #&lt;procedure:string-trim&gt;\n   #&lt;procedure:string-trim-both&gt;\n \
    \  #&lt;procedure:string-trim-right&gt;\n   #&lt;procedure:string-trim-left&gt;\n\
    \   #&lt;procedure:string-trim-both/inplace&gt;\n   #&lt;procedure:string-trim-right/inplace&gt;\n\
    \   #&lt;procedure:string-trim-left/inplace&gt;\n   #&lt;procedure:string-trim/inplace&gt;\n\
    \   #&lt;procedure:string-join-list&gt;\n   #&lt;procedure:string-join&gt;\n \
    \  #&lt;procedure:string-&gt;list&gt;\n   #&lt;procedure:string-split&gt;\n  \
    \ #&lt;procedure:string-split-delimiter&gt;\n   #&lt;procedure:string-replace&gt;\n\
    \   #&lt;procedure:string-replace/backward&gt;\n   #&lt;procedure:string-replace/backward/inplace&gt;\n\
    \   #&lt;procedure:string-replace/inplace&gt;\n   #&lt;procedure:string-pad&gt;\n\
    \   #&lt;procedure:string-pad/right&gt;\n   #&lt;procedure:string-pad/left&gt",
  "  (regexp-split (regexp \" *, *\") s))\n", "  (string-split s #\\,))\n", "  (regexp-split\
    \ #rx\", ?\" s))\n", "  (regexp-split #rx\"\\s*[, ]\\s*\" s))\n", "  (regexp-split\
    \ #rx\"\\s|,\" s))\n</code>\n", "  (regexp-split #rx\"\\s+\" s))\n```\n\n```\n\
    #lang racket\n", "  (match s [(regexp #rx\"^\\\"[^\\\"]+\\\"$\") (string-split\
    \ s #rx\"\\\"\" #rx\"\\\"\")]\n           [(regexp #rx\"^'[^']+'$\") (string-split\
    \ s #rx\"'\" #rx\"'\")]\n           [else (string-split s #rx\"\\s+\")]))", " \
    \ (string-split s #\\space))\n", "  (string-split s #rx\"[, ]+\"))\n", "  (regexp-split\
    \ #rx\"[, ]+\" s))\n```\n\n## 2. \n<p>xkcd.com</p>\n<p>\n<img src=\"https://imgs.xkcd.com/comics/extrapolating.png\"\
    \ alt=\"extrapolating\">\n</p>\n<!--\nhttps://xkcd.com/373/\n-->\n```racket\n\
    #lang racket\n", "  (string-split s #\\,)\n  )\n", "  (regexp-split #rx\"[, ]+\"\
    \ s))\n</code>\n<code>#lang racket\n", "  (regexp-split #rx\",*\\\\s+\" s))\n",
  "  (split-string s \"[, ]+\"))\n</code>\nSo, while I am learning the basics, I am\
    \ going to use Racket instead of Ruby to solve the challenges.\n\n\nA:\n\nThis\
    \ is not a correct translation of your Ruby code to Racket.  I think you're confusing\
    \ the behavior of <code>map</code> with the behavior of <code>for</code> in Python.\
    \  In your Ruby code, <code>map</code> returns a new array that contains the results\
    \ of the block passed to it.  It's equivalent to writing:\n<code>values = []\n\
    for word in words\n  values &lt;&lt; word.downcase\nend\n</code>\nIn your Racket\
    \ code, <code>map</code> doesn't return an array; instead, it returns a function.\
    \  So what you're actually doing is creating a function that converts a string\
    \ to lowercase, then you're immediately calling that function.  The result is\
    \ a string, which isn't what you want.\nHow you would write this in Racket depends\
    \ on what you're trying to accomplish.  If you want to mutate the original array,\
    \ you could write:\n<code>(for ((i (in-range (vector-length words))))\n  (vector-set!\
    \ words i (string-downcase (vector-ref words i))))\n</code>\nYou should also be\
    \ able to write this with a <code>for/vector</code> loop:\n<code>(for/vector ((word\
    \ words))\n  (string-downcase word))\n</code>\nIf you just want to return a copy\
    \ of the array containing all lowercase strings, you can use <code>map</code>\
    \ directly:\n<code>(map string-downcase words)\n</code>\nIf you want to show the\
    \ result of the <code>map</code> call, you can use <code>displayln</code> in the\
    \ REPL to print the result:\n<code>&gt; (displayln (map string-downcase words))\n\
    '(\"hi\" \"i\" \"am\" \"superman\")\n</code>\n", "  (string-split s \"[[:space:],]+\"\
    ))\n", "  (regexp-split (regexp #rx\"\\s*[ ,]+\\s*\") s))\n", "  (apply string-&gt;list\
    \ s))\n", "  (string-split s #\\space))\n", "  (regexp-split #rx\",\" s))\n",
  "  (string-split s \",[ ]*\"))\n", "  (map string-upcase (regexp-split #rx\"[ ,]\"\
    \ s)))\n", "  (split-string s \"\\\\W\"))\n", "  (string-split s #\\,))\n", " \
    \ (split-string s \"[ \\t\\n\\r,]+\"))\n", "  (split-string s \"[ ,]+\"))\n",
  "  (split-string s \"[[:space:],]+\"))\n", "  (regexp-split #rx\"[ ,]+\" s))\n",
  "  (split-string s \"[[:space:],]+\"))\n</code>\n", "  (split-string s \"[[:space:],]+\"\
    ))\n", "  (string-split s))\n", "  (string-split s \"[ \\n\\t\\r,]+\"))\n</code>\n",
  "  (regexp-split #rx\"\\s*[, ]\\s*\" s))\n</code>\n", "  (string-split s))\n", " \
    \ (split-string s #rx\"[, ]+\"))\n", "  (regexp-split #rx\"[, ]+\" s))\n", " \
    \ (split s \", \"))\n", "  (string-split s #\"[\\,\\s]+\"))\n", "  (string-split\
    \ s))\n", "  (define wds (string-split s #\\space))\n  (cond [(empty? wds) null]\n\
    \        [(not (string-contains? (first wds) #\\,)) (cons (first wds) (words_string\
    \ (string-join (rest wds) #\\space)))]\n        [(string-contains? (first wds)\
    \ #\\,) (append (string-split (first wds) #\\,) (words_string (string-join (rest\
    \ wds) #\\space)))]))\n", "  (regexp-split #rx\"(,\\\\s*|\\\\s+)\" s))\n", " \
    \ (string-split s (regexp #rx\"[ ,]+\")))\n", "  (regexp-split #rx\"[, ]+\" s))\n\
    ```\n\n## Links\n\n* [Racket - string-regexp.rkt](http://docs.racket-lang.org/reference/string-regexp.html)\n\
    * [Racket - regexp-split](http://docs.racket-lang.org/reference/srfi-13.html#%28def._%28%28lib._racket%2Fprivate%2Fmisc..rkt%29._regexp-split%29%29)\n\
    * [Racket - Examples: Strings](http://docs.racket-lang.org/guide/examples.html#%28part._.Strings%29)\n\
    * [Stackoverflow - How to split a string and store in array in Racket?](http://stackoverflow.com/questions/13100815/how-to-split-a-string-and-store-in-array-in-racket)\n\
    * [CodingBat - Problem: Java String split](http://codingbat.com/prob/p121193)\n\
    * [Racket: Using list?](http://stackoverflow.com/questions/9793341/racket-using-list)\n\
    * [Racket: split-regexp - Split a string into a list of substrings delimited by\
    \ regexp matches](http://lists.racket-lang.org/users/archive/2009-April/037028.html)\n\
    * [Racket: split string on spaces](http://stackoverflow.com/questions/12133450/racket-split-string-on-spaces)\n\
    * [Racket: Return all elements in a list except the first](http://stackoverflow.com/questions/19058761/racket-return-all-elements-in-a-list-except-the-first)\n\
    * [Racket: How to split a string and store in array in Racket?](http://stackoverflow.com/questions/13100815/how-to-split-a-string-and-store-in-array-in-racket)\n\
    * [Racket: how do I split a string into a list of words?](", "  (regexp-split\
    \ #rx\"[,\\s]+\" s))\n</code>\nYou can test it like this:\n<code>&gt; (define\
    \ (word-count s) (count (words_string s)))\n&gt; (word-count \"Hi, my name is\
    \ John\")\n5\n&gt; (word-count \"One, two, three, four, five, six\")\n6\n</code>\n",
  "  (regexp-split #rx\"\\s*[, ]\\s*\" s))\n", "  (split-string s #rx\"\\s+\"))\n\
    ```\n\n```clojure", "  (split-string s #rx\"\\s*,\\s*|\\s+\"))\n", "  (regexp-split\
    \ #rx\"\\s*[, ]\\s*\" s))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
