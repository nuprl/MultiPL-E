name: HumanEval_131_digits
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the product of the\
  \ odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; digits(1)\
  \  == 1\n;; digits(4)  == 0\n;; digits(235) == 15\n(define (digits n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n\
  \    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal?\
  \ (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate\
  \ 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate\
  \ 2468) 0)\n))\n\n(test-humaneval)"
completions: ["  (cond ((< n 1) 0)\n        ((odd? n) (modulo n 10))\n        (else\
    \ 0)))\n", "  (cond [(= n 0) 0]\n        [(odd? (remainder n 10)) (* (digits (quotient\
    \ n 10)) (remainder n 10))]\n        [else (digits (quotient n 10))]))\n", " \
    \ (cond\n    ((= n 0) 0)\n    ((= (remainder n 2) 1) (* (remainder n 10) (digits\
    \ (quotient n 10))))\n    (else (digits (quotient n 10)))))\n", "  (define (helper\
    \ n accum)\n    (cond [(empty? n) accum]\n          [(odd? (string->number (first\
    \ n))) (helper (rest n) (* (string->number (first n)) accum))]\n          [else\
    \ (helper (rest n) accum)]))\n  (helper (number->string n) 1))\n", "  (cond\n\
    \    [(empty? n) 0]\n    [(odd? (first n))\n     (* (first n) (digits (rest n)))]\n\
    \    [else (digits (rest n))]))\n", "  (if (zero? n) 0\n      (* (if (odd? (remainder\
    \ n 10))\n            (remainder n 10)\n            1)\n         (digits (quotient\
    \ n 10)))))\n\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (define (digits-iter\
    \ n prod-so-far)\n    (cond [(zero? n) prod-so-far]\n          [(odd? n) (digits-iter\
    \ (quotient n 10) (* (remainder n 10) prod-so-far))]\n          [else (digits-iter\
    \ (quotient n 10) prod-so-far)]))\n  (digits-iter n 1))\n</code>\nHow is this\
    \ implementation different from this one?\n\n\nA:\n\nThe first one (mine) is tail-recursive.\
    \ The second one is not.\nA tail-recursive function, like <code>digits</code>,\
    \ is defined using a tail-recursive helper.\nThe tail-recursive helper uses the\
    \ output of a recursive step as the output of the function, without doing anything\
    \ else.\nFor example, the recursive helper <code>digits-iter</code> takes as a\
    \ second parameter the result of the previous recursive call, and the last line\
    \ just uses the result of the previous recursive call (without doing anything\
    \ else):\n<code>(digits-iter (quotient n 10) prod-so-far)\n</code>\nIn the second\
    \ implementation, there's no helper. The recursive call:\n<code>(digits (quotient\
    \ n 10))\n</code>\nis not the last thing the function does.\n", "  (if (positive?\
    \ n)\n      (cond\n        [(odd? n) (* n (digits (/ n 10)))]\n        [else (digits\
    \ (/ n 10))])\n      0))\n", "  (if (= n 0)\n      0\n      (if (odd? (remainder\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n          (digits\
    \ (quotient n 10)))))\n</code>\nI get the following error:\n<code>Error: application:\
    \ not a procedure;\n expected a procedure that can be applied to arguments\n \
    \ given: 0\n  arguments...:\n   [none]\n</code>\nI am new to Racket.\n\n\nA:\n\
    \nUse <code>integer?</code> to check if a number is an integer or not\n<code>(define\
    \ (digits n)\n  (if (integer? n)\n      (if (= n 0)\n          0\n          (if\
    \ (odd? (remainder n 10))\n              (* (remainder n 10) (digits (quotient\
    \ n 10)))\n              (digits (quotient n 10))))\n      (error \"Digits expects\
    \ an integer number\")))\n</code>\nEven better, use <code>exact-integer?</code>\
    \ to check if the number is an exact integer or not\n<code>(define (digits n)\n\
    \  (if (exact-integer? n)\n      (if (= n 0)\n          0\n          (if (odd?\
    \ (remainder n 10))\n              (* (remainder n 10) (digits (quotient n 10)))\n\
    \              (digits (quotient n 10))))\n      (error \"Digits expects an exact\
    \ integer number\")))\n</code>\nI think the error is because Racket evaluates\
    \ the expressions in the <code>if</code> clauses before deciding which one to\
    \ take, and therefore you have\n<code>(if #f\n    (* (remainder n 10) (digits\
    \ (quotient n 10)))\n    (digits (quotient n 10)))\n</code>\nbut <code>digits</code>\
    \ is called with a <code>0</code> that is not an integer, but a real number.\n",
  "  (if (zero? n)\n      0\n      (let ([remainder (modulo n 10)])\n        (if (even?\
    \ remainder)\n            (digits (quotient n 10))\n            (* remainder (digits\
    \ (quotient n 10)))))))\n", "  (let loop ([n n] [sum 0])\n    (if (zero? n)\n\
    \        sum\n        (let* ([digit (modulo n 10)]\n               [new-sum (if\
    \ (even? digit)\n                            sum\n                           \
    \ (+ sum digit))])\n          (loop (quotient n 10) new-sum)))))\n```\n\n### Problem\
    \ 6.3\n\n```scheme\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder\
    \ n 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n</code>\n", "  (cond\n    [(= 0 n) 0]\n    [(odd? (remainder n 10))\
    \ (* (digits (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient\
    \ n 10))]))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder\
    \ n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n</code>\n\
    How to fix this function so that it runs as intended?\n\n\nA:\n\nYou could write\
    \ it like this:\n<code>(define (digits n)\n  (if (odd? (remainder n 10))\n   \
    \   (* (remainder n 10) (digits (quotient n 10)))\n      (digits (quotient n 10))))\n\
    </code>\nbut you are wrong, since <code>digits (quotient n 10)</code> may return\
    \ 0, and you want it to return 1. So one solution could be this:\n<code>(define\
    \ (digits n)\n  (if (odd? (remainder n 10))\n      (* (remainder n 10) (digits\
    \ (quotient n 10)))\n      1))\n</code>\nBut it is not tail recursive, so you\
    \ could rewrite it this way:\n<code>(define (digits n acc)\n  (if (odd? (remainder\
    \ n 10))\n      (digits (quotient n 10) (* (remainder n 10) acc))\n      acc))\n",
  "  (cond ((zero? n) 0)\n        ((odd? (remainder n 10)) (* (remainder n 10) (digits\
    \ (quotient n 10))))\n        (else (digits (quotient n 10)))))\n", "  (if (odd?\
    \ n)\n      (if (zero? (modulo n 10))\n          0\n          (* n (digits (quotient\
    \ n 10))))\n      (digits (quotient n 10))))\n</code>\n", "  (cond [(zero? n)\
    \ 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n", "  (define (odd? c)\n    (zero? (modulo c 2)))\n  (cond\n\
    \    [(zero? n)\n     0]\n    [(odd? (modulo n 10))\n     (* (modulo n 10) (digits\
    \ (quotient n 10)))]\n    [else\n     (digits (quotient n 10))]))\n", "  (foldr\
    \ (lambda (n acc)\n           (if (even? n) acc (* n acc)))\n         1\n    \
    \     (number->list n)))\n", "  (if (zero? n)\n      0\n      (let* ([d (remainder\
    \ n 10)]\n             [d (if (zero? (remainder d 2))\n                    1\n\
    \                    d)])\n        (+ d (digits (quotient n 10))))))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(not (even? (remainder n 10)))\n     (* (remainder n\
    \ 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n</code>\n\
    The tests:\n<code>#lang racket\n", "  (cond\n    [(= 0 n) 0]\n    [(= 1 (remainder\
    \ n 2)) (* (quotient n 10) (digits (remainder n 10)))]\n    [else (digits (quotient\
    \ n 10))]))\n", "  (define (iter n prod)\n    (cond\n      [(zero? n) prod]\n\
    \      [(odd? (remainder n 10)) (iter (quotient n 10) (* prod (remainder n 10)))]\n\
    \      [else (iter (quotient n 10) prod)]))\n  (iter n 1))\n", "  (cond\n    [(zero?\
    \ n) (printf \"Cond failed: digits(zero?)\\n\")]\n    [(odd? n)\n     (cond\n\
    \       [(zero? (modulo n 10)) (printf \"Cond failed: digits(zero?)\\n\")]\n \
    \      [(odd? (modulo n 10))\n        (* (modulo n 10) (digits (quotient n 10)))]\n\
    \       [else (digits (quotient n 10))])]\n    [else\n     (cond\n       [(zero?\
    \ (modulo n 10)) (printf \"Cond failed: digits(zero?)\\n\")]\n       [(odd? (modulo\
    \ n 10)) (digits (quotient n 10))]\n       [else (digits (quotient n 10))])]))\n\
    </code>\nIn my test harness, I can test all of the base cases (1, 4, 235, 15,\
    \ 0) fine. But when I test a number with a mix of odd and even digits (e.g. 1326)\
    \ I get:\n<code>Cond failed: digits(zero?)\n0\n</code>\nAs if my cond statement\
    \ has failed in one of the conditions when I'm checking for a <code>zero?</code>.\
    \ I've tried tracing through it in the DrRacket debug console, but I can't see\
    \ where I'm making a mistake.\n\n\nA:\n\nYou get this error because the number\
    \ you input gets divided by 10 to the point where it becomes 0 and then it enters\
    \ the first <code>cond</code> clause and tries to print \"Cond failed: digits(zero?)\\\
    n\"\nInstead of printing the error message, you should just check if the number\
    \ is 0 and return 0 if it is. \n<code>(define (digits n)\n  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? n)\n     (cond\n       [(zero? (modulo n 10)) (printf \"Cond\
    \ failed: digits(zero?)\\n\")]\n       [(odd? (modulo n 10))\n        (* (modulo\
    \ n 10) (digits (quotient n 10)))]\n       [else (digits (quotient n 10))])]\n\
    \    [else\n     (cond\n       [(zero? (modulo n 10)) (", "  (if (zero? n) 0\n\
    \      (if (even? (remainder n 10)) 0\n          (* (remainder n 10) (digits (quotient\
    \ n 10))))))\n\n", "  (cond\n    [(zero? n) 0]\n    [(even? (remainder n 10))\n\
    \     (digits (quotient n 10))]\n    [else\n     (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n</code>\nThis doesn't work\
    \ for a couple of reasons. The main problem is that if the number is less than\
    \ 10, it returns the number itself, which is not the product of the digits. I'm\
    \ also not sure how to make sure that it terminates correctly. Any help would\
    \ be appreciated.\n\n\nA:\n\nThis was my solution, I was surprised how easy it\
    \ was. \n<code>#lang racket\n", "  (if (odd? n)\n      n\n      0))\n", "  (let\
    \ loop ([n n] [accum 1])\n    (cond\n      [(not (even? n))\n       (let ([div\
    \ (quotient n 10)])\n         (if (even? div)\n             accum\n          \
    \   (loop div (* accum (remainder n 10)))))\n      ]\n      [else\n       0])))\n",
  "  (cond\n    [(< n 10) (cond [(odd? n) n]\n                   [else 0])]\n    [else\
    \ (+ (cond [(odd? (modulo n 10)) (modulo n 10)]\n                   [else 0])\n\
    \             (digits (quotient n 10)))]))\n", "  (if (zero? n)\n      0\n   \
    \   (let ((d (remainder n 10)))\n        (if (even? d)\n            (digits (quotient\
    \ n 10))\n            (* d (digits (quotient n 10)))))))\n</code>\nThis produces\
    \ the desired result:\n<code>&gt; (digits 235)\n15\n</code>\nBut it's not as concise\
    \ as I'd like.  Ideally, I'd like to use the product of all the odd digits where\
    \ I'm using the sum of all the odd digits:\n<code>(foldr * 1 (filter odd? (digits\
    \ 235)))\n</code>\nI can get a list of the odd digits using <code>filter</code>:\n\
    <code>&gt; (filter odd? (digits 235))\n'(5 3)\n</code>\nAnd I can use <code>foldr</code>\
    \ to multiply them, but I also get 1 as a product:\n<code>&gt; (foldr * 1 (filter\
    \ odd? (digits 235)))\n15\n</code>\nThe problem is <code>filter</code>'s contract\
    \ requires the result to be a sequence.  It's not contractually permitted to return\
    \ <code>'()</code> when the filtered list is empty.  If <code>filter</code> would\
    \ return <code>'()</code> when the filtered list is empty, I could combine <code>filter</code>\
    \ and <code>foldr</code> to achieve my desired result:\n<code>&gt; (foldr * 1\
    \ (filter odd? (digits 1)))\n1\n</code>\nIs there a better way to achieve my desired\
    \ result that I'm not thinking of?  Is there a way to get <code>filter</code>\
    \ to produce the empty list when the filtered list is empty?  Am I stuck with\
    \ the nested if-expressions?\n\n\nA:\n\nLooks fine to me. A simpler alternative\
    \ would be to use <code>foldr</code> in place of the <code>if</code>s:\n<code>(define\
    \ (digits n)\n  (foldr (lambda (d r)\n           (if (even? d)\n             \
    \  r\n               (* d r)))\n         1\n         (dig", "  (cond\n    [(>\
    \ n 0)\n     (if (odd? (modulo n 10))\n         (* (modulo n 10) (digits (quotient\
    \ n 10)))\n         (digits (quotient n 10)))]\n    [else 0]))\n", "  (cond [(<\
    \ n 1) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits\
    \ (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (cond\n\
    \    [(< n 10)\n     (if (odd? n) n 0)]\n    [else\n     (if (odd? (modulo n 10))\n\
    \         (* (modulo n 10) (digits (quotient n 10)))\n         (digits (quotient\
    \ n 10)))]))\n", "  (cond\n    [(= 0 n) 0]\n    [(odd? (remainder n 10)) (* (digits\
    \ (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient n 10))]))\n",
  "  (let loop ([n n] [total 0])\n    (cond\n      [(zero? n) total]\n      [(= (remainder\
    \ n 2) 1) (loop (quotient n 10) (* total (remainder n 10)))]\n      [else (loop\
    \ (quotient n 10) total)])))\n</code>\n", "  (if (= n 0)\n      0\n      (let\
    \ ([digit (modulo n 10)])\n        (if (odd? digit)\n            (* digit (digits\
    \ (quotient n 10)))\n            (digits (quotient n 10))))))\n", "  (cond [(=\
    \ n 0) 0]\n        [(even? (remainder n 10)) (digits (quotient n 10))]\n     \
    \   [else (* (remainder n 10) (digits (quotient n 10)))]))\n", "  (if (= n 0)\n\
    \      1\n      (* (if (odd? (modulo n 10))\n             (modulo n 10)\n    \
    \         1)\n         (digits (quotient n 10)))))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(even? (remainder n 10)) (digits (quotient n 10))]\n    [else (* (remainder\
    \ n 10) (digits (quotient n 10)))]))\n", "  (cond\n    [(zero? n) 0]\n    [(even?\
    \ (remainder n 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits\
    \ (quotient n 10)))]))\n", "  (cond ((> n 0) (string->number (number->string (product-of-odd-digits\
    \ n))))\n        (else 0)))\n", "  (if (even? n)\n      0\n      (* n (digits\
    \ (quotient n 10)))))\n", "  (if (= n 0)\n      0\n      (if (even? (remainder\
    \ n 10))\n          (digits (quotient n 10))\n          (* (remainder n 10) (digits\
    \ (quotient n 10))))))\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder n\
    \ 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n</code>\nThis works for the first two tests, but fails for the last\
    \ one. I think it has something to do with how the function is evaluating the\
    \ product, but I'm not sure how to go about debugging.\n\n\nA:\n\nYou're failing\
    \ because you don't have a base case for the recursion. You're assuming that <code>n</code>\
    \ will eventually be zero, but it's not, in the case where all digits are even.\
    \ And then you make the mistake of multiplying the <code>0</code> you get by the\
    \ product of the rest of the digits. Just check if <code>n</code> is 0, and if\
    \ so then return 1, which is the neutral element for multiplication:\n<code>(define\
    \ (digits n)\n  (cond\n    [(= n 0) 1]\n    [(even? (remainder n 10)) (digits\
    \ (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient n 10)))]))\n\
    </code>\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (modulo n 10))\n     (* (modulo\
    \ n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))", " \
    \ (if (zero? n)\n      0\n      (if (even? (remainder n 10))\n          (digits\
    \ (quotient n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n",
  "  (define (helper m acc)\n    (cond\n      [(= m 0) acc]\n      [(even? (remainder\
    \ m 10)) (helper (quotient m 10) acc)]\n      [else (helper (quotient m 10) (*\
    \ acc (remainder m 10)))]))\n  (helper n 1))\n", "  (if (zero? n)\n      0\n \
    \     (if (even? (remainder n 10))\n          (digits (quotient n 10))\n     \
    \     (* (remainder n 10) (digits (quotient n 10))))))\n", "  (cond\n    [(< n\
    \ 10) n]\n    [(even? (modulo n 10)) (digits (quotient n 10))]\n    [else (* (modulo\
    \ n 10) (digits (quotient n 10)))]))\n", "  (local [(define (iter a-n)\n     \
    \       (cond [(zero? a-n) 0]\n                  [(and (odd? (remainder a-n 10))\n\
    \                        (zero? (quotient a-n 10)))\n                   (remainder\
    \ a-n 10)]\n                  [(odd? (remainder a-n 10))\n                   (*\
    \ (remainder a-n 10)\n                      (iter (quotient a-n 10)))]\n     \
    \             [else (iter (quotient a-n 10))]))]\n    (iter n)))\n</code>\nI wrote\
    \ a few tests:\n<code>#lang racket\n", "  (cond [(empty? n) 0]\n        [(odd?\
    \ (first n)) (* (first n) (digits (rest n)))]\n        [else (digits (rest n))]))\n",
  "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (if (positive? n)\n      (let loop ((n n) (p 1))\n        (cond ((< n 10) (if\
    \ (odd? n) n 0))\n              ((odd? n) (loop (quotient n 10) (* p (remainder\
    \ n 10))))\n              (else (loop (quotient n 10) p))))\n    0))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(even? (remainder n 10)) (digits (quotient n 10))]\n\
    \    [else (* (remainder n 10) (digits (quotient n 10)))]))\n", "  (define (iter-digits\
    \ n acc)\n    (cond\n      [(even? n) (iter-digits (quotient n 10) acc)]\n   \
    \   [(zero? n) acc]\n      [else (iter-digits (quotient n 10) (* n acc))]))\n\
    \  (iter-digits n 1))\n```\n\n### Digits Product\n\n```racket\n#lang racket\n",
  "  (apply * (filter odd? (filter number? (string->list (number->string n))))))\n",
  "  (if (zero? n)\n      0\n      (let* ([d (remainder n 10)]\n             [rest\
    \ (quotient n 10)])\n        (if (odd? d)\n            (if (zero? rest)\n    \
    \            d\n                (* d (digits rest)))\n            (digits rest)))))\n",
  "  (define (even? n) (= (remainder n 2) 0))\n  (define (digits-helper n result)\n\
    \    (cond ((zero? n) result)\n          ((even? (quotient n 10)) (digits-helper\
    \ (quotient n 10) result))\n          (else (digits-helper (quotient n 10) (*\
    \ result (remainder n 10))))))\n  (digits-helper n 1))\n", "  (cond\n    [(= 0\
    \ n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (cond\n    [(empty? n)\
    \ 0]\n    [(odd? (car n)) (* (car n) (digits (cdr n)))]\n    [else (digits (cdr\
    \ n))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= (remainder n 2) 1) (* (quotient\
    \ n 10) (digits (remainder n 10)))]\n    [else (digits (quotient n 10))]))\n",
  "  (define (todigit n)\n    (cond [(even? n)\n           0]\n          [else\n \
    \          n]))\n  (cond [(zero? n)\n         0]\n        [else\n         (* (todigit\
    \ (remainder n 10))\n            (digits (quotient n 10)))]))\n", "  (cond ((zero?\
    \ n) 0)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n       \
    \ (else (* (remainder n 10) (digits (quotient n 10))))))\n</code>\nSolutions that\
    \ I can't understand\nThe solutions with the highest votes from the site above,\
    \ I do not understand:\nSolution 1:\n<code>#lang racket\n", "  (local ((define\
    \ (even? n)\n             (eq? (remainder n 2) 0)))\n    (cond\n      ((zero?\
    \ n) 0)\n      ((even? (modulo n 10)) (digits (quotient n 10)))\n      (else (*\
    \ (modulo n 10) (digits (quotient n 10)))))))\n", "  (if (not (positive? n))\n\
    \      0\n      (if (odd? n)\n          (* n (digits (quotient n 10)))\n     \
    \     (digits (quotient n 10)))))\n</code>\n", "  (cond\n    [(zero? n) 0]\n \
    \   [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient n 10)))]\n\
    \    [else (digits (quotient n 10))]))\n\n```\n\n```\n#lang racket\n", "  (if\
    \ (= n 0)\n      0\n      (let ((remainder (modulo n 10)))\n        (if (even?\
    \ remainder)\n            (digits (quotient n 10))\n            (* remainder (digits\
    \ (quotient n 10)))))))\n", "  (cond [(zero? n) 0]\n        [(odd? (remainder\
    \ n 10)) (* (remainder n 10) (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n</code>\nThis is a straightforward translation from the\
    \ pseudocode.\nI've tried to use the same variable names.\nI've also tried to\
    \ use the same names for functions, that is, <code>quotient</code> where I'd use\
    \ <code>div</code> and <code>remainder</code> where I'd use <code>mod</code>.\n\
    In this case, I ended up with a relatively simple solution.\n", "  (cond [(or\
    \ (negative? n) (zero? n)) 0]\n        [else (+ (* (remainder n 10) (digits (quotient\
    \ n 10)))\n                 (if (odd? (remainder n 10)) 1 0))]))\n", "  (if (or\
    \ (&lt; n 0) (zero? n))\n      0\n      (if (even? n)\n          (digits (quotient\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n</code>\n",
  "  (cond [(zero? n) 0]\n        [(even? n) (digits (quotient n 10))]\n        [else\
    \ (* (remainder n 10) (digits (quotient n 10)))]))\n\n", "  (define (iter n acc)\n\
    \    (cond [(zero? n) (if (zero? acc) 0 acc)]\n          [(odd? (remainder n 10))\
    \ (iter (quotient n 10) (* acc (remainder n 10)))]\n          [else (iter (quotient\
    \ n 10) acc)]))\n  (iter n 1))\n", "  (if (zero? n)\n      0\n      (if (even?\
    \ (remainder n 10))\n          (digits (quotient n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10))))))\n</code>\nSo, for example, the decimal number\
    \ 235 will be evaluated like this:\n<code>(digits 235)\n  (* (remainder 235 10)\
    \ (digits (quotient 235 10)))\n    (* 5 (digits 23))\n      (* (remainder 23 10)\
    \ (digits (quotient 23 10)))\n        (* 3 (digits 2))\n          (* (remainder\
    \ 2 10) (digits (quotient 2 10)))\n            (* 2 (digits 0))\n            \
    \  0\n            2\n          0\n        0\n      0\n    0\n  0\n0\n</code>\n\
    As you can see, the number 235 has three odd digits, and the value of <code>(digits\
    \ 235)</code> is 30, as expected.\n", "  (cond\n    [(zero? n) 0]\n    [(odd?\
    \ (remainder n 10)) (* (remainder n 10) (digits (quotient n 10)))]\n    [else\
    \ (digits (quotient n 10))]))\n</code>\nI think it's not a lazy evaluation issue,\
    \ because I tried <code>(digits 1000000)</code> and it still produced the same\
    \ error.\nOr would you recommend a totally different approach?\n\n\nA:\n\nThe\
    \ problem is that it causes an overflow.\nThe easiest way to fix this is to make\
    \ a helper function:\n<code>(define (digits n)\n  (digits-helper n 1))\n", " \
    \ (define (helper n odd-product)\n    (cond [(even? n) odd-product]\n        \
    \  [(odd? n) (helper (quotient n 10) (* odd-product (remainder n 10)))]))\n  (helper\
    \ n 1))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient n\
    \ 10)))]\n        [else (digits (quotient n 10))]))\n</code>\nHowever, when I\
    \ run <code>(digits 4)</code>, it results in a stack overflow error. I'm not sure\
    \ why, since 0 is caught as a base case and returns 0.\n\n\nA:\n\nI don't know\
    \ what the problem is, but this is a way to fix it:\n<code>(define (digits n)\n\
    \  (cond [(zero? n) 0]\n        [(odd? n) (let* ([d (quotient n 10)]\n       \
    \                  [x (digits d)])\n                     (if (zero? x) n (* n\
    \ x)))]\n        [else (digits (quotient n 10))]))\n</code>\n", "  (cond\n   \
    \ [(= n 0) 0]\n    [(even? (remainder n 10)) (digits (quotient n 10))]\n    [else\
    \ (* (remainder n 10) (digits (quotient n 10)))]))\n", "  (if (zero? n)\n    \
    \  0\n      (let ([x (modulo n 10)])\n        (if (odd? x)\n            (* x (digits\
    \ (quotient n 10)))\n            (digits (quotient n 10))))))\n</code>\n\n<code>#lang\
    \ racket\n", "  (cond\n    [(= n 0) 0]\n    [(= (remainder n 2) 1) (* (quotient\
    \ n 10) (digits (remainder n 10)))]\n    [else (digits (quotient n 10))]))\n",
  "  (if (zero? n) 0\n      (let ([d (remainder n 10)])\n        (if (odd? d)\n  \
    \          (* d (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n",
  "  (cond\n    [(zero? n) 0]\n    [(and (even? (remainder n 10)) (even? (remainder\
    \ (/ n 10) 10))) 0]\n    [(even? (remainder n 10))\n     (digits (/ n 10))]\n\
    \    [(even? (remainder (/ n 10) 10))\n     (remainder n 10)]\n    [else\n   \
    \  (* (remainder n 10) (digits (/ n 10)))]))\n", "  (if (= n 0) 0\n      (let\
    \ ([digit (modulo n 10)])\n        (if (odd? digit) (* digit (digits (quotient\
    \ n 10)))\n            (digits (quotient n 10))))))\n", "  (define (get-odd-digits-product\
    \ result)\n    (cond\n      [(zero? n) result]\n      [(odd? (remainder n 10))\
    \ (get-odd-digits-product (* result (remainder n 10)))]\n      [else (get-odd-digits-product\
    \ result)]))\n  (get-odd-digits-product 1))\n", "  (cond ((even? n) 0)\n     \
    \   ((< n 10) n)\n        (else (* (remainder n 10) (digits (quotient n 10))))))\n",
  "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))\n          (digits (quotient n 10)))))\n", " \
    \ (if (zero? n)\n      0\n      (let ([d (remainder n 10)])\n        (if (odd?\
    \ d)\n            (* d (digits (quotient n 10)))\n            (digits (quotient\
    \ n 10))))))\n", "  (if (zero? n)\n      0\n      (let* ([d (remainder n 10)]\n\
    \             [next (quotient n 10)])\n        (if (odd? d)\n            (* d\
    \ (digits next))\n            (digits next)))))\n</code>\n", "  (cond [(= n 0)\
    \ 0]\n        [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient n\
    \ 10)))]\n        [else (digits (quotient n 10))]))\n</code>\n", "  (cond\n  \
    \  ((< n 1) (error \"n must be positive\"))\n    ((< n 10) n)\n    (else (let\
    \ loop ([n n] [p 1])\n             (if (< n 10)\n                 (* n p)\n  \
    \               (loop (quotient n 10) (* (remainder n 10) p)))))))\n</code>\n\
    The usual solution is to split the digits of a number via <code>quotient</code>\
    \ and <code>remainder</code>, which is precisely what <code>loop</code> does.\
    \ Since the product of the digits is returned, I go through the digits in reverse\
    \ order and use the inner <code>*</code> to build the product.\n<code>digits</code>\
    \ simply checks for the edge cases, i.e. the numbers less than 10, and then invokes\
    \ <code>loop</code> to calculate the product of the digits.\n", "  (cond [(empty?\
    \ n) 0]\n        [(odd? (first n)) (* (first n) (digits (rest n)))]\n        [else\
    \ (digits (rest n))]))\n</code>\nIn an R5RS-compatible dialect, the call to <code>empty?</code>\
    \ must be replaced with <code>(null? n)</code>, and <code>first</code> and <code>rest</code>\
    \ must be defined as:\n<code>(define (first lst) (car lst))", "  (cond\n    [(zero?\
    \ n) 0]\n    [(and (zero? (remainder n 2)) (zero? (remainder (quotient n 10) 2)))\n\
    \     (digits (quotient n 10))]\n    [else (+ (remainder n 10) (digits (quotient\
    \ n 10)))]))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (*\
    \ (remainder n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n",
  "  (accumulate * 1 (filter odd? (map char->integer (number->string n)))))\n", " \
    \ (cond\n    ((zero? n) 0)\n    ((odd? (modulo n 10)) (* (modulo n 10) (digits\
    \ (quotient n 10))))\n    (else (digits (quotient n 10)))))\n", "  (define (iter-digits\
    \ n result)\n    (cond\n      [(zero? n) result]\n      [(even? (remainder n 10))\
    \ (iter-digits (quotient n 10) result)]\n      [else (iter-digits (quotient n\
    \ 10) (* result (remainder n 10)))]))\n  (iter-digits n 1))\n```\n\n```scheme\n\
    #lang racket\n", "  (if (zero? n)\n      0\n      (let ([d (remainder n 10)])\n\
    \        (if (odd? d)\n            (* d (digits (quotient n 10)))\n          \
    \  (digits (quotient n 10))))))\n</code>\nThe recursive call <code>(digits (quotient\
    \ n 10))</code> is in tail position.\n", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n</code>\n", "  (define (helper n accum)\n\
    \    (cond [(< n 10) (if (odd? n) n accum)]\n          [else (helper (quotient\
    \ n 10) (* (remainder n 10) accum))]))\n  (helper n 1))\n", "  (define (digits-helper\
    \ num result)\n    (cond [(= num 0) (if (= result 0) 0 result)]\n          [(odd?\
    \ (remainder num 10)) (digits-helper (quotient num 10) (* result (remainder num\
    \ 10)))]\n          [else (digits-helper (quotient num 10) result)]))\n  (digits-helper\
    \ n 1))\n", "  (if (zero? n)\n      0\n      (let* ([d (remainder n 10)]\n   \
    \          [num (digits (quotient n 10))])\n        (if (even? d)\n          \
    \  num\n            (* d num)))))\n", "  (cond [(zero? n) 0]\n        [(odd? n)\
    \ (* n (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))",
  "  (cond ((zero? n) 1)\n        ((odd? (remainder n 10)) (* (digits (quotient n\
    \ 10)) (remainder n 10)))\n        (else (digits (quotient n 10)))))\n", "  (if\
    \ (zero? n)\n      0\n      (let ((r (remainder n 10)))\n        (if (odd? r)\n\
    \            (* r (digits (quotient n 10)))\n            (digits (quotient n 10))))))\n",
  "  (if (zero? n) 0\n      (if (even? (remainder n 10))\n          (digits (quotient\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10))))))\n\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(odd? (remainder n 10)) * (digits (quotient n 10))]\n\
    \    [else (digits (quotient n 10))]))\n", "  (cond\n    [(zero? n) 0]\n    [(=\
    \ 1 (remainder n 2)) (* (remainder n 10) (digits (quotient n 10)))]\n    [else\
    \ (digits (quotient n 10))]))\n", "  (define (helper n acc)\n    (cond [(= n 0)\
    \ acc]\n          [(odd? (remainder n 10)) (helper (quotient n 10) (* acc (remainder\
    \ n 10)))]\n          [else (helper (quotient n 10) acc)]))\n  (helper n 1))\n",
  "  (cond [(= n 0) 0]\n        [(even? (remainder n 10)) (digits (quotient n 10))]\n\
    \        [else (* (remainder n 10) (digits (quotient n 10)))]))\n", "  (if (zero?\
    \ n) 0\n      (* (remainder n 10)\n         (if (even? (remainder n 10)) 0 1)\n\
    \         (digits (quotient n 10)))))\n</code>\nHere's my Java solution:\n<code>public\
    \ class Digits {\n    public static void main(String[] args) {\n        System.out.println(digits(1));\n\
    \        System.out.println(digits(4));\n        System.out.println(digits(235));\n\
    \    }\n\n    private static int digits(int n) {\n        if (n == 0) return 0;\n\
    \        return (n % 10) * (isEven(n % 10) ? 0 : 1) * digits(n / 10);\n    }\n\
    \n    private static boolean isEven(int n) {\n        return n % 2 == 0;\n   \
    \ }\n}\n</code>\nOf course, these two solutions are functionally equivalent. I'm\
    \ curious about what is idiomatic for the two languages.\n\n\nA:\n\nI think you\
    \ are asking \"What is idiomatic for these two languages?\"\nIf that is the case,\
    \ then I'll try to answer it from my point of view as a Racket programmer.\nThe\
    \ Racket way\nAn idiomatic Racket solution should use the <code>expt</code> function\
    \ to \"count\" the digits and the <code>number-&gt;digits</code> function to compute\
    \ the digits.\n<code>(define (digits n)\n  (define digits-list (number-&gt;digits\
    \ n 10))\n  (define num-digits (expt 10 (length digits-list)))\n  (for/fold ([result\
    \ 1]) ([i num-digits])\n    (define i (quotient i 10))\n    (if (odd? (list-ref\
    \ digits-list i))\n        (* result (list-ref digits-list i))\n        result)))\n\
    </code>\nTail recursion\nA Racket programmer would also try to make the recursive\
    \ function tail recursive.\n<code>(define (digits n)\n  (define (iter n result\
    \ i)\n    (if (= n 0)\n        result\n        (iter (quotient n 10) (if (odd?\
    \ (remain", "  (define (find-odds n acc)\n    (if (zero? n)\n        acc\n   \
    \     (let ((m (modulo n 10)))\n          (if (odd? m)\n              (find-odds\
    \ (quotient n 10) (* acc m))\n              (find-odds (quotient n 10) acc)))))\n\
    \  (find-odds n 1))\n", "  (cond\n    [(= n 0) 0]\n    [(= 0 (modulo n 2)) (digits\
    \ (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient n 10)))]))\n\
    ```\n\n## [Number of trailing zeros of N!](https://www.codewars.com/kata/number-of-trailing-zeros-of-n)\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder\
    \ n 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= 0 (modulo n 2)) (digits (quotient\
    \ n 10))]\n    [else (+ (* (remainder n 10) (digits (quotient n 10)))\n      \
    \        (remainder n 10))]))\n</code>\n", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n", "  (cond [(zero? n) 0]\n        [(odd?\
    \ n) (* n (digits (quotient n 10)))]\n        [else (digits (quotient n 10))]))",
  "  (define (mul-odd-digits n acc)\n    (cond [(zero? n) acc]\n          [(odd? (remainder\
    \ n 10))\n           (mul-odd-digits (quotient n 10) (* acc (remainder n 10)))]\n\
    \          [else (mul-odd-digits (quotient n 10) acc)]))\n  (mul-odd-digits n\
    \ 1))\n", "  (if (zero? n) 1\n      (* (odd? (remainder n 10))\n         (digits\
    \ (quotient n 10)))))\n</code>\n", "  (if (even? n)\n      0\n      (* n (digits\
    \ (quotient n 10)))))", "  (let loop ([n n] [prod 1])\n    (cond\n      [(odd?\
    \ n) (loop (quotient n 10) (* prod (remainder n 10)))]\n      [(positive? n) (loop\
    \ (quotient n 10) prod)]\n      [else prod])))\n", "  (cond ((= 0 n) 0)\n    \
    \    ((odd? (remainder n 10)) (* (remainder n 10) (digits (quotient n 10))))\n\
    \        (else (digits (quotient n 10)))))\n", "  (cond\n    [(even? n) 0]\n \
    \   [(= 1 n) n]\n    [else (* (remainder n 10) (digits (quotient n 10)))]))\n\
    </code>\nbut I am getting errors:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: '(digits (quotient n\
    \ 10))\n  arguments...:\n   1\n   2\n   5\n</code>\nI am still new to Racket but\
    \ I have done some programming in other languages and have a feeling this is not\
    \ that complicated, but if someone could point me in the right direction that\
    \ would be great.\n\n\nA:\n\nTry\n<code>(define (digits n)\n  (cond\n    [(even?\
    \ n) 0]\n    [(= 1 n) n]\n    [else (* (remainder n 10) (digits (quotient n 10)))]))\n\
    </code>\nSo your code is actually not a valid scheme code because it evaluates\
    \ the expression <code>(digits (quotient n 10))</code> before it calls <code>*</code>.\
    \ \n", "  (if (zero? n) 0\n      (* (modulo n 10) (digits (quotient n 10)))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((even? (remainder n 10)) (digits (quotient n 10)))\n\
    \    (else (* (remainder n 10) (digits (quotient n 10))))))\n</code>\n", "  (if\
    \ (odd? n)\n      (let ([r (remainder n 10)])\n        (+ r (digits (quotient\
    \ n 10))))\n      (digits (quotient n 10))))\n</code>\nHowever, I was wondering\
    \ if it's possible to do this with a <code>foldr</code> function:\n<code>#lang\
    \ racket\n", "  (local [(define (digits-iter n accum)\n            (cond [(= n\
    \ 0) accum]\n                  [(odd? (remainder n 10))\n                   (digits-iter\
    \ (quotient n 10) (* accum (remainder n 10)))]\n                  [else (digits-iter\
    \ (quotient n 10) accum)]))]\n    (digits-iter n 1)))\n</code>\nMy solution takes\
    \ n and recursively calls itself until n = 0. Each call checks if the last digit\
    \ is odd. If so, it multiplies that value by the accumulator. If not, it moves\
    \ to the next digit. Is there a better solution? Thanks.\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(odd? (remainder n 10))\n     (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n    [else (digits (quotient n 10))]))\n</code>\nI understand how this\
    \ works but I don't understand how it would work if the argument is negative.\
    \ For example, <code>(digits -1000)</code> returns <code>0</code> when it should\
    \ return <code>1</code>. How would I fix this?\n\n\nA:\n\nYou can extract the\
    \ sign and use it to modify the result of <code>digits</code> so that it is positive\
    \ for positive numbers and negative for negative numbers:\n<code>(define (digits\
    \ n)\n  (let ((sign (if (negative? n) -1 1)))\n    (* sign\n       (cond\n   \
    \      [(zero? n) 0]\n         [(odd? (remainder n 10))\n          (* (remainder\
    \ n 10) (digits (quotient n 10)))]\n         [else (digits (quotient n 10))]))))\n\
    </code>\n", "  (define (digits-iter n p acc)\n    (cond\n      [(= n 0) \n   \
    \    (if (= p 0) 0 acc)]\n      [(even? p)\n       (digits-iter (quotient n 10)\n\
    \                    (remainder n 10)\n                    acc)]\n      [else\n\
    \       (digits-iter (quotient n 10)\n                    (remainder n 10)\n \
    \                   (* p acc))]))\n  (digits-iter n 0 1))\n", "  (foldl (*) 1\
    \ (filter odd? (string->list (number->string n)))))\n", "  (cond\n    [(zero?\
    \ n) 1]\n    [(even? n) (digits (quotient n 10))]\n    [else (* (remainder n 10)\
    \ (digits (quotient n 10)))]))\n```\n\n```racket", "  (cond [(zero? n)\n     \
    \    0]\n        [(odd? (remainder n 10))\n         (* (remainder n 10) (digits\
    \ (quotient n 10)))]\n        [else\n         (digits (quotient n 10))]))\n\n\n",
  "  (cond [(> n 9)\n         (* (modulo n 10) (digits (quotient n 10)))]\n      \
    \  [(even? n) 0]\n        [else n]))\n", "  (cond [(zero? n) 0]\n        [(and\
    \ (odd? n) (positive? n)) (* n (digits (quotient n 10)))]\n        [else (digits\
    \ (quotient n 10))]))\n</code>\nSo I have a solution, however I have no idea how\
    \ to actually test my code. \nI have tried to add this to the code:\n<code>(define\
    \ digits-test\n  (test-suite\n   \"digits\"\n   (test-eq? (digits 1) 1)\n   (test-eq?\
    \ (digits 4) 0)\n   (test-eq? (digits 235) 15)))\n</code>\nHowever then I get\
    \ the error message:\n<code>eval:28:0: define: bad syntax in: (define digits-test\
    \ (test-suite \"digits\" (test-eq? (digits 1) 1) (test-eq? (digits 4) 0) (test-eq?\
    \ (digits 235) 15)))\n</code>\nI am quite new to this, so I hope someone can help\
    \ me out a bit.\nI have worked through the Racket documentation, but I am still\
    \ not sure what I am doing wrong.\nI have also tried to evaluate the test in DrRacket,\
    \ by adding the additional code, to get the desired output.\nBut I still get a\
    \ syntax error.\nAny suggestions?\n\n\nA:\n\n<code>#lang racket\n", "  (cond ((negative?\
    \ n) (error \"n must be positive\"))\n        ((zero? n) (error \"n must be positive\"\
    ))\n        ((= n 1) 1)\n        ((even? (modulo n 10))\n         (digits (quotient\
    \ n 10)))\n        (else\n         (* (modulo n 10)\n            (digits (quotient\
    \ n 10))))))\n</code>\nThis version uses the function <code>product</code> that\
    \ is in the <code>racket/list</code> library (see the manual).\n<code>#lang racket\n",
  "  (cond ((= n 0) 0)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n\
    \        (else (* (remainder n 10) (digits (quotient n 10))))))\n", "  (if (odd?\
    \ n)\n      (* n (digits (quotient n 10)))\n      (if (zero? n)\n          1\n\
    \          (digits (quotient n 10)))))\n", "  (if (even? n)\n      0\n      (*\
    \ n (digits (quotient n 10)))))\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder\
    \ n 10))\n     (digits (quotient n 10))]\n    [else\n     (* (remainder n 10)\
    \ (digits (quotient n 10)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder\
    \ n 10)) (digits (quotient n 10))]\n    [else (* (remainder n 10) (digits (quotient\
    \ n 10)))]))\n</code>\nHow should I rewrite this so it is easier to understand?\n\
    \n\nA:\n\nI'd recommend to use a <code>match</code> pattern instead, it makes\
    \ the code more readable:\n<code>(define (digits n)\n  (match n\n    [(? even?)\
    \ 0]\n    [(? odd?) (* (remainder n 10) (digits (quotient n 10)))]))\n</code>\n",
  "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient n 10)))]\n    \
    \    [else (digits (quotient n 10))]))\n", "  (if (zero? n) 0\n      (if (zero?\
    \ (modulo n 2)) (digits (quotient n 10))\n          (* (modulo n 10) (digits (quotient\
    \ n 10))))))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (positive? n)\n      (if (odd? n)\n          (* n (digits\
    \ (quotient n 10)))\n          (digits (quotient n 10)))\n      1))\n</code>\n\
    I would like to do this problem without using loops or helper functions.\n\n\n\
    A:\n\nYou can define helper functions inside a function, just like you defined\
    \ <code>digits</code> in your function <code>digits</code>.\n<code>(define (digit-product\
    \ n)\n  (define (product-of-odd-digits n)\n    ...)\n  (define (odd? n)\n    ...)\n\
    \  (if (positive? n)\n      (if (odd? n)\n          (* n (product-of-odd-digits\
    \ (quotient n 10)))\n          (product-of-odd-digits (quotient n 10)))\n    \
    \  1))\n</code>\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n</code>\nI am getting an error saying:\n<code>application: not a\
    \ procedure;\n expected a procedure that can be applied to arguments\n  given:\
    \ #&lt;procedure:remainder&gt;\n  arguments...:\n   20\n   10\n</code>\nI am not\
    \ sure what is wrong here. Any help would be appreciated.\n\n\nA:\n\nFirst, let's\
    \ get the error message right:\n<code>application: not a procedure;\n expected\
    \ a procedure that can be applied to arguments\n  given: #&lt;procedure:*&gt;\n\
    \  arguments...:\n   #&lt;procedure:remainder&gt;\n   10\n</code>\nThe error message\
    \ is saying that <code>*</code> is being passed a non-number. That is, we have\
    \ something like <code>(* (remainder x y) ...)</code>. Now, <code>*</code> multiplies\
    \ numbers, so, if we have something like <code>(* (remainder x y) z)</code>, we\
    \ need <code>(remainder x y)</code> to evaluate to a number. So what is the problem\
    \ here?\nHere is the problem: <code>(remainder n 10)</code> is using the <code>remainder</code>\
    \ binding from the calling scope, rather than the <code>remainder</code> binding\
    \ created in the body of <code>digits</code>. The problem is solved by adding\
    \ <code>#:use-module (rnrs) #:prefix r:</code> after the <code>#lang racket</code>\
    \ line.\n", "  (if (zero? n)\n      0\n      (let ((d (remainder n 10)))\n   \
    \     (if (even? d)\n            (digits (quotient n 10))\n            (* d (digits\
    \ (quotient n 10)))))))\n", "  (cond\n    [(= n 0) 0]\n    [(even? (remainder\
    \ n 10)) (digits (quotient n 10))]\n    [else\n     (* (remainder n 10) (digits\
    \ (quotient n 10)))]))\n</code>\nAnd this solution that uses recursion\n<code>#lang\
    \ racket\n", "  (if (= n 0)\n      1\n      (* (if (odd? (modulo n 10))\n    \
    \         (modulo n 10)\n             1)\n         (digits (quotient n 10)))))\n",
  "  (match n\n    [`(,) k (cons (cons x xs) ...)`\n     (if (odd? x)\n       (* k\
    \ x (apply * (map (lambda (i) (if (odd? i) i 1)) xs)))\n       (digits `(,) k\
    \ xs))]\n    [_ 1]))\n", "  (define (digits-iter n product)\n    (cond [(= n 0)\
    \ product]\n          [(odd? (remainder n 10)) (digits-iter (quotient n 10) (*\
    \ product (remainder n 10)))]\n          [else (digits-iter (quotient n 10) product)]))\n\
    \  (digits-iter n 1))\n", "  (define (remainder d)\n    (remainder/help d 0))\n\
    \  (define (remainder/help d acc)\n    (cond [(zero? d) acc]\n          [(odd?\
    \ d) (remainder/help (quotient d 10) (* acc d))]\n          [else (remainder/help\
    \ (quotient d 10) acc)]))\n  (remainder n))\n</code>\nI'm not too much of a fan\
    \ of the <code>cond</code> but I didn't know what else to do.  Thanks for the\
    \ help.\n\n\nA:\n\nInstead of a recursive helper function you could use a <code>for/fold</code>\
    \ loop to do the work.\n<code>(define (digits n)\n  (for/fold ([acc 1])\n    \
    \        ([d (in-list (number-&gt;list n))])\n    (if (odd? d)\n        (* acc\
    \ d)\n        acc)))\n</code>\n", "  (if (zero? n) 0\n      (if (odd? (remainder\
    \ n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n          (digits\
    \ (quotient n 10)))))\n", "  (cond [(zero? n) 0]\n        [(odd? (remainder n\
    \ 10))\n         (* (remainder n 10) (digits (quotient n 10)))]\n        [else\
    \ (digits (quotient n 10))]))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (modulo\
    \ n 10)) (* (modulo n 10) (digits (quotient n 10)))]\n    [else (digits (quotient\
    \ n 10))]))\n", "  (define (sum i)\n    (cond [(zero? i) 0]\n          [(even?\
    \ (remainder i 10)) (+ (sum (quotient i 10)) 0)]\n          [else (+ (sum (quotient\
    \ i 10)) (* (remainder i 10) (digits (quotient i 10))))]))\n  (sum n))", "  (letrec\
    \ ([digits/helper (lambda (a n)\n                            (if (= n 0)\n   \
    \                             a\n                                (let ([x (modulo\
    \ n 10)])\n                                  (if (odd? x)\n                  \
    \                    (digits/helper (* a x) (quotient n 10))\n               \
    \                       (digits/helper a (quotient n 10))))))])\n    (digits/helper\
    \ 1 n)))\n</code>\nThis is a pretty standard recursive function. I'm taking the\
    \ last digit and if it's odd I'm multiplying it by all the other odd numbers.\
    \ If it's even I'm cutting it out of the result.\nThe problem is that I get a\
    \ stack overflow. If I try to <code>(digits 1234567891)</code> it will eventually\
    \ run out of memory.\nMy suspicion is that I'm somehow accumulating the recursive\
    \ calls. If this is the case, is there some way to fix this?\n\n\nA:\n\nHere's\
    \ a version that uses continuation-passing style, which should be tail-recursive:\n\
    <code>(define (digits n)\n  (let loop ([n n] [acc 1])\n    (if (zero? n)\n   \
    \     acc\n        (let ([d (remainder n 10)])\n          (if (odd? d)\n     \
    \         (loop (quotient n 10) (* acc d))\n              (loop (quotient n 10)\
    \ acc))))))\n</code>\n", "  (if (= n 0)\n      0\n      (let ((d (remainder n\
    \ 10)))\n        (if (odd? d)\n            (* d (digits (quotient n 10)))\n  \
    \          (digits (quotient n 10))))))\n", "  (if (empty? n)\n      0\n     \
    \ (if (odd? (first n))\n          (* (first n) (digits (rest n)))\n          (digits\
    \ (rest n)))))\n</code>\nHave the same question for the <code>digits</code> function\
    \ in Clojure:\n<code>(defn digits [n]\n  (if (empty? n)\n    0\n    (if (odd?\
    \ (first n))\n      (* (first n) (digits (rest n)))\n      (digits (rest n)))))\n\
    </code>\nWhy did I define the function as <code>(defn digits [n]</code> in Clojure?\n\
    Because the function takes only one parameter. I could have also defined it like\
    \ this:\n<code>(defn digits \"Given a positive integer n, return the product of\
    \ the odd digits. Return 0 if all digits are even. For example: digits(1)  ==\
    \ 1 digits(4)  == 0 digits(235) == 15\"\n  [n]\n  (if (empty? n)\n    0\n    (if\
    \ (odd? (first n))\n      (* (first n) (digits (rest n)))\n      (digits (rest\
    \ n)))))\n</code>\nNow this definition of <code>digits</code> looks like the one\
    \ used in Racket. You may wonder why do I need the whole docstring. I will explain\
    \ this in one of the next articles.\nFor example, if I want to test the definition\
    \ of <code>digits</code> in Clojure, I will use the following:\n<code>(digits\
    \ [3 2 2])", "  (if (zero? n)\n      0\n      (let ([last-digit (modulo n 10)])\n\
    \        (if (even? last-digit)\n            (digits (quotient n 10))\n      \
    \      (* last-digit (digits (quotient n 10)))))))\n</code>\nThe code works correctly\
    \ with all inputs I have tested.\nI'm not a beginner with Racket but I'm certainly\
    \ not an expert.\nI'm interested in learning the best practices when programming\
    \ in Racket.\nHow would you modify this code?\n\n\nA:\n\nIn general, you've done\
    \ a good job with your code. It's easy to understand, it's very Racket-y, and\
    \ it's correct.\nI have a few nitpicks, though:\n\nYour code doesn't work on negative\
    \ numbers, which is a bug. To fix it, add the following at the top of your <code>digits</code>\
    \ function:\n<code>(if (negative? n) (set! n (- n)))\n</code>\n\nIt's a bit odd\
    \ to have a function named <code>digits</code> return a number. It makes more\
    \ sense to either have it return a list of digits or a number of digits. If you\
    \ want to stick with the <code>digits</code> name, I'd recommend making the function\
    \ return the number of digits.\n\nThe <code>let</code> form you're using is a\
    \ bit unnecessary. It's fine to just write:\n<code>(* last-digit (digits (quotient\
    \ n 10)))\n</code>\n\nWhy do you need the <code>if</code> statement around the\
    \ recursive call? I.e., why not just do this:\n<code>(* last-digit (digits (quotient\
    \ n 10)))\n</code>\nHere's what the code looks like with the changes applied:\n\
    <code>(define (digits n)\n  (if (negative? n) (set! n (- n)))\n  (if (zero? n)\n\
    \      0\n      (let ([last-digit (modulo n 10)])\n        (* last-digit (digits\
    \ (quotient n 10))))))\n</code>\n", "  (if (zero? n)\n      0\n      (if (odd?\
    \ (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))", "  (if (zero? n)\n      0\n      (if\
    \ (odd? (remainder n 10))\n          (* (remainder n 10) (digits (quotient n 10)))\n\
    \          (digits (quotient n 10)))))\n", "  (cond ((= n 0) 0)\n        ((odd?\
    \ (remainder n 10))\n         (* (remainder n 10) (digits (quotient n 10))))\n\
    \        (else (digits (quotient n 10)))))\n", "  (cond\n    [(= n 0) 0]\n   \
    \ [(even? (remainder n 10)) (digits (quotient n 10))]\n    [else (* (remainder\
    \ n 10) (digits (quotient n 10)))]))\n", "  (cond\n    [(<= n 0) 0]\n    [(odd?\
    \ n) (* (remainder n 10) (digits (quotient n 10)))]\n    [else (digits (quotient\
    \ n 10))]))\n```\n\n```racket", "  (local [(define (iter n result)\n         \
    \   (cond [(zero? n) result]\n                  [(odd? n)\n                  \
    \ (iter (quotient n 10)\n                         (* (remainder n 10) result))]\n\
    \                  [else (iter (quotient n 10) result)]))]\n    (iter n 1)))\n\
    </code>\n", "  (cond\n    [(empty? n) 0]\n    [(odd? (first n))\n     (* (first\
    \ n) (digits (rest n)))]\n    [else (digits (rest n))]))\n", "  (cond ((equal?\
    \ (remainder n 10) 0) 0)\n        ((= n 0) 1)\n        ((= (remainder n 10) 0)\
    \ (* (digits (quotient n 10)) (remainder n 10)))\n        (else (* (digits (quotient\
    \ n 10)) (remainder n 10)))))\n</code>\nI've been trying to debug this code, and\
    \ when I input the number 235, it returns 2160 instead of 15. I'm trying to figure\
    \ out what is causing this, but I'm not sure where to begin. What I think is happening\
    \ is that the system is just taking the remainder of 235 and multiplying that\
    \ by 1, but I'm not sure why it is doing that.\n\n\nA:\n\n<code>(cond\n  ((equal?\
    \ (remainder n 10) 0) 0)\n  ((= n 0) 1)\n  ((= (remainder n 10) 0) (* (digits\
    \ (quotient n 10)) (remainder n 10)))\n  (else (* (digits (quotient n 10)) (remainder\
    \ n 10))))\n</code>\nThe problem is in the third <code>cond</code> clause.  The\
    \ third clause is executed when the number is not zero and the last digit is zero.\
    \  In the case of 235, the result is <code>(* (digits 23) 0)</code>.  In this\
    \ case, the <code>else</code> clause is also executed, giving <code>(* (digits\
    \ 23) 5)</code>.  Since <code>(digits 23)</code> is also executed when we execute\
    \ <code>(digits 235)</code>, the same thing happens to 23, giving <code>(* (*\
    \ (digits 2) 3) 5)</code>.  Continuing in this fashion, we get the result you\
    \ observed.\nIf the goal is to multiply just the odd digits, then one way to do\
    \ it is to return zero when the last digit is zero, regardless of whether the\
    \ remainder of the number is zero or not:\n<code>(cond\n  ((= (remainder n 10)\
    \ 0) 0)\n  ((= n 0) 1)\n  (else (* (digits (quotient n 10)) (remainder n 10))))\n\
    </code>\n", "  (define (product lst)\n    (if (null? lst)\n        1\n       \
    \ (* (car lst) (product (cdr lst)))))\n  (product (filter odd? (build-list (string->number\
    \ (number->string n)) (lambda (i) i)))))", "  (if (= 0 n)\n      0\n      (let\
    \ ([m (remainder n 10)])\n        (if (odd? m)\n            (* m (digits (quotient\
    \ n 10)))\n            (digits (quotient n 10))))))", "  (accumulate * 1 (filter\
    \ odd? (integer->list n))))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder\
    \ n 10))\n     (+ (* (remainder n 10) (digits (quotient n 10)))\n        (digits\
    \ (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n", "  (cond ((= n\
    \ 0) 0)\n        ((odd? (remainder n 10)) (* (digits (quotient n 10)) (remainder\
    \ n 10)))\n        (else (digits (quotient n 10)))))\n</code>\nIt works for integer\
    \ > 0 and < 0, but not for integer == 0. Any clue why?\n\n\nA:\n\nWhen you call\
    \ <code>(digits 1)</code>, your <code>cond</code> expression enters the third\
    \ <code>else</code> clause:\n<code>(else (digits (quotient n 10)))))\n</code>\n\
    which happens to return <code>0</code>. \nIn order to keep track of how you've\
    \ done in your recursive calls, you should make sure you return at least the value\
    \ of the recursive call:\n<code>(else (* (digits (quotient n 10)) 1)))\n</code>\n\
    In this way, if your recursive call returns <code>0</code>, your current call\
    \ will also return <code>0</code>.\n", "  (define (iter n mult)\n    (cond\n \
    \     [(= n 0) mult]\n      [(odd? (remainder n 10)) (iter (quotient n 10) (*\
    \ (remainder n 10) mult))]\n      [else (iter (quotient n 10) mult)]))\n  (iter\
    \ n 1))\n", "  (define (helper n acc)\n    (cond [(= n 0) acc]\n          [(odd?\
    \ (remainder n 10)) (helper (quotient n 10) (* (remainder n 10) acc))]\n     \
    \     [else (helper (quotient n 10) acc)]))\n  (helper n 1))\n</code>\nI tried\
    \ to use <code>foldl</code> and it failed, as it doesn't allow me to pass an initial\
    \ value of 1.\nI'm also wondering if there's a way to get rid of the <code>helper</code>\
    \ function.\n\n\nA:\n\nThis is a solution that does not use <code>foldl</code>:\n\
    <code>(define (digits n)\n  (cond [(zero? n) 0]\n        [(odd? (remainder n 10))\
    \ (* (remainder n 10) (digits (quotient n 10)))]\n        [else (digits (quotient\
    \ n 10))]))\n</code>\n\nHere is a solution that uses <code>foldl</code> and <code>map</code>:\n\
    <code>(define (digits n)\n  (foldl * 1 (map (lambda (x) (if (odd? x) x 1)) (integer-&gt;list\
    \ n))))\n</code>\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* n (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n</code>\nCan I get some\
    \ advice to fix this?\n\n\nA:\n\nI'd use a different approach:\n<code>(define\
    \ (digits n)\n  (define (digits-aux n acc)\n    (cond ((&lt; n 10)\n         \
    \  (if (odd? n)\n               (* n acc)\n               acc))\n          ((odd?\
    \ n)\n           (digits-aux (quotient n 10) (* n acc)))\n          (else\n  \
    \         (digits-aux (quotient n 10) acc))))\n  (digits-aux n 1))\n</code>\n\
    This way we treat the most significant digit differently, just before we return.\
    \ We don't do the multiplication if it's even (like in your code), but it's just\
    \ an <code>if</code> statement, and then we multiply, just like in your code,\
    \ but we also multiply the accumulator so that the result of the multiplication\
    \ is preserved.\nLet's take a look at what happens when we multiply:\n<code>(digits\
    \ 567)\n", "  (if (= n 0) 0\n    (if (odd? (remainder n 10))\n        (* (remainder\
    \ n 10) (digits (quotient n 10)))\n        (digits (quotient n 10)))))\n", " \
    \ (let loop ([n n] [acc 1])\n    (cond [(even? n) acc]\n          [(zero? n) acc]\n\
    \          [else (loop (quotient n 10) (* acc (remainder n 10)))])))\n```\n\n\
    ```\n#lang racket\n", "  (cond\n    [(= 0 n) 0]\n    [(odd? (remainder n 10))\
    \ (* (digits (quotient n 10)) (remainder n 10))]\n    [else (digits (quotient\
    \ n 10))]))\n</code>\nMy approach works, but I am wondering what the advantage\
    \ of such a function is. Is this the right way to code this?\n\n\nA:\n\nYou can\
    \ use pattern matching in your function:\n<code>(define (digits n)\n  (cond\n\
    \    [(= 0 n) 0]\n    [(odd? (remainder n 10)) (digits (quotient n 10))]\n   \
    \ [else (* (digits (quotient n 10)) (remainder n 10))]))\n</code>\nOr, you can\
    \ use the <code>if</code> expression:\n<code>(define (digits n)\n  (if (= 0 n)\n\
    \      0\n      (if (odd? (remainder n 10))\n          (digits (quotient n 10))\n\
    \          (* (digits (quotient n 10)) (remainder n 10)))))\n</code>\n", "  (cond\n\
    \    [(= n 0) 1]\n    [(= (remainder n 2) 0) (digits (quotient n 10))]\n    [else\
    \ (* (remainder n 10) (digits (quotient n 10)))]))\n", "  (if (zero? n)\n    \
    \  0\n      (* (if (odd? (remainder n 10)) (remainder n 10) 1)\n         (digits\
    \ (quotient n 10)))))\n</code>\n", "  (if (even? n)\n      0\n      (* n (digits\
    \ (quotient n 10)))))\n</code>\nPlease note that I would like to solve this problem\
    \ without using helper functions (such as <code>odd?</code>).\n\n\nA:\n\nThe problem\
    \ is that you don't handle the termination case for the recursion.  The final\
    \ <code>n</code> in the <code>digits</code> recursion is <code>1</code>, so <code>(even?\
    \ n)</code> is <code>#f</code>, so you multiply by <code>0</code> (because <code>(digits\
    \ (quotient n 10))</code> is <code>0</code>), instead of <code>1</code>.\nYou\
    \ could add a check for <code>n</code> being less than <code>10</code>, and then\
    \ return <code>n</code> in that case.\nYou could also perhaps deal with odd values\
    \ of <code>n</code> in a simpler way, which would mean that you wouldn't have\
    \ to have an explicit termination case:\n<code>(define (digits n)\n  (if (or (even?\
    \ n) (&lt; n 10))\n      0\n      (* n (digits (quotient n 10)))))\n</code>\n",
  "  (cond [(zero? n) 0]\n        [(even? n) (digits (quotient n 10))]\n        [else\
    \ (if (zero? (quotient n 10))\n                 n\n                 (* n (digits\
    \ (quotient n 10))))]))", "  (define (loop k acc)\n    (cond\n      [(< k 1) (if\
    \ (= acc 0) 0 acc)]\n      [(odd? (remainder k 10)) (loop (quotient k 10) (* acc\
    \ (remainder k 10)))]\n      [else (loop (quotient k 10) acc)]))\n  (loop n 1))\n",
  "  (cond\n    [(< n 10)\n     (if (odd? n) n 0)]\n    [else\n     (if (odd? (modulo\
    \ n 10))\n         (+ (* (quotient n 10) 10)\n            (digits (modulo n 10)))\n\
    \         (digits (quotient n 10)))]))\n", "  (cond\n    [(< n 10) (if (odd? n)\
    \ n 0)]\n    [else (* (if (odd? (modulo n 10)) (modulo n 10) 1) (digits (quotient\
    \ n 10)))]))\n", "  (if (zero? n)\n      0\n      (if (odd? (remainder n 10))\n\
    \          (* (remainder n 10) (digits (quotient n 10)))\n          (digits (quotient\
    \ n 10)))))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? (remainder n 10)) (* (remainder\
    \ n 10) (digits (quotient n 10)))]\n    [else (digits (quotient n 10))]))\n</code>\n\
    And here is my solution in Racket. What is the best way of doing this exercise?\n",
  "  (if (zero? n) 1\n      (* (remainder n 10) (digits (quotient n 10)))))\n", " \
    \ (if (odd? n) (* n (digits (quotient n 10))) (digits (quotient n 10))))\n</code>\n\
    I'm not sure how to terminate the recursion.  If I enter (digits 128), it returns\
    \ 0, when it should return 0 and stop.  I can add a terminating condition with\n\
    <code>(if (zero? n) n (+ n (digits (quotient n 10))))\n</code>\nbut then I get:\n\
    <code>digits: application: not a procedure;\n expected a procedure that can be\
    \ applied to arguments\n  given: 1\n  arguments...:\n   n\n   -285212671\n</code>\n\
    Any ideas?\n\n\nA:\n\nYou have to multiply the result of <code>digits</code> with\
    \ <code>n</code>, not with <code>1</code>. That is, you need:\n<code>(define (digits\
    \ n)\n  (if (zero? n)\n      0\n      (* (remainder n 10) (digits (quotient n\
    \ 10)))))\n</code>\n", "  (cond [(= n 0) 0]\n        [(and (= (remainder n 2)\
    \ 1)\n              (> n 0))\n         (* (remainder n 10)\n            (digits\
    \ (quotient n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (cond ((=\
    \ n 0) 1)\n        ((even? (remainder n 10)) (digits (quotient n 10)))\n     \
    \   (else (* (remainder n 10) (digits (quotient n 10))))))\n", "  (if (equal?\
    \ n 0)\n      0\n      (let* ([c (modulo n 10)]\n             [r (quotient n 10)])\n\
    \        (if (and (<= c 9)\n                 (>= c 0))\n            (if (odd?\
    \ c)\n                (* c (digits r))\n                (digits r))\n        \
    \    0))))\n", "  (if (even? n) 0\n    (if (zero? n) 1\n      (* (remainder n\
    \ 10) (digits (quotient n 10))))))\n```\n\n```\n#lang racket\n", "  (cond [(zero?\
    \ n) 0]\n        [(odd? (remainder n 10)) (* (remainder n 10) (digits (quotient\
    \ n 10)))]\n        [else (digits (quotient n 10))]))\n", "  (if (= n 0)\n   \
    \   0\n      (let ((digit (modulo n 10))\n            (remaining-digits (quotient\
    \ n 10)))\n        (if (and (even? digit) (not (= remaining-digits 0)))\n    \
    \        (digits remaining-digits)\n            (* digit (digits remaining-digits))))))\n\
    </code>\nIn Java\n<code>public static int digits(int n) {\n    if (n == 0) return\
    \ 0;\n    int digit = n % 10;\n    int remainingDigits = n / 10;\n    if (digit\
    \ % 2 == 0 &amp;&amp; remainingDigits != 0)\n        return digits(remainingDigits);\n\
    \    return digit * digits(remainingDigits);\n}\n</code>\n", "  (if (zero? n)\n\
    \      0\n      (let ([d (remainder n 10)])\n        (if (odd? d)\n          \
    \  (begin\n              (displayln d)\n              (* d (digits (quotient n\
    \ 10))))\n            (digits (quotient n 10))))))\n", "  (cond\n    [(empty?\
    \ n)\n     0]\n    [(odd? (first n))\n     (* (first n) (digits (rest n)))]\n\
    \    [else\n     (digits (rest n))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
