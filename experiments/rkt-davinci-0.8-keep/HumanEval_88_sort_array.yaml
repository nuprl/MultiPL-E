name: HumanEval_88_sort_array
language: rkt
prompt: "#lang racket\n\n;; Given an array of non-negative integers, return a copy\
  \ of the given array after sorting,\n;; you will sort the given array in ascending\
  \ order if the sum( first index value, last index value) is odd,\n;; or sort it\
  \ in descending order if the sum( first index value, last index value) is even.\n\
  ;; Note:\n;; * don't change the given array.\n;; Examples:\n;; * sort_array([])\
  \ => []\n;; * sort_array([5]) => [5]\n;; * sort_array([2, 4, 3, 0, 1, 5]) => [0,\
  \ 1, 2, 3, 4, 5]\n;; * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
  (define (sort_array array)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 5)) (list 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3\
  \ 4 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0))\n\
  \    (check-equal? (candidate (list 2 1)) (list 1 2))\n    (check-equal? (candidate\
  \ (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87))\n    (check-equal? (candidate\
  \ (list 21 14 23 11)) (list 23 21 14 11))\n))\n\n(test-humaneval)"
completions: ["  (if (empty? array)\n      '()\n      (sort (array-&gt;list array)\
    \ &lt; #:key (lambda (x) (if (odd? (+ (car array) (car (reverse array)))) x (-\
    \ x))))))\n</code>\nI'm getting an error. Which is:\n<code>Expected result: '(0\
    \ 1 2 3 4 5)\nActual result: '(4 3 2 1 0 5)\n</code>\nI'm sure there's a better\
    \ way to do this. Any suggestions?\n\n\nA:\n\nIf you can use a small amount of\
    \ mutability, then you can construct the list in the correct order and then sort\
    \ it, without the need to worry about keeping track of the first and last elements.\n",
  "  (define (merge a b)\n    (cond [(empty? a) b]\n          [(empty? b) a]\n   \
    \       [(< (first a) (first b)) (cons (first a) (merge (rest a) b))]\n      \
    \    [else (cons (first b) (merge a (rest b)))]))\n  (define (merge-sort arr)\n\
    \    (if (< (length arr) 2)\n        arr\n        (let* ([split (quotient (length\
    \ arr) 2)]\n               [a (merge-sort (slice arr 0 split))]\n            \
    \   [b (merge-sort (slice arr split))])\n          (merge a b))))\n  (let* ([odd?\
    \ (odd? (+ (first array) (last array)))]\n         [sorted (merge-sort array)])\n\
    \    (if odd?\n        sorted\n        (reverse sorted))))\n", "  (if (= (length\
    \ array) 0)\n      '()\n      (if (= (length array) 1)\n          array\n    \
    \      (sort_array_helper array 0 (sub1 (length array))\n                    \
    \         (< (modulo (+ (list-ref array 0) (list-ref array (sub1 (length array))))\
    \ 2)\n                                0)))))\n", "  (if (null? array) '()\n  \
    \    (let ((odd_nums (filter odd? array))\n            (even_nums (filter even?\
    \ array)))\n        (if (odd? (+ (car array) (car (reverse array))))\n       \
    \     (append (sort < odd_nums) (sort > even_nums))\n            (append (sort\
    \ > odd_nums) (sort < even_nums))))))\n", "  (define (helper array n)\n    (if\
    \ (null? array) (list)\n        (let ([x (car array)])\n          (append (helper\
    \ (cdr array) n) (list x)))))\n  (if (= 0 (modulo (+ (first array) (last array))\
    \ 2))\n      (helper array -1)\n      (helper array 1)))\n", "  (if (empty? array)\n\
    \      '()\n      (let loop ([odd #t] [even #t] [index 0] [index-max (sub1 (length\
    \ array))])\n        (cond [(< index index-max)\n               (let ([first (array-ref\
    \ array index)]\n                     [last (array-ref array (sub1 index-max))])\n\
    \                 (if (odd? (+ first last))\n                     (if odd (loop\
    \ #f even (add1 index) (sub1 index-max))\n                         (loop odd #f\
    \ (add1 index) (sub1 index-max)))\n                     (if even (loop odd #f\
    \ (add1 index) (sub1 index-max))\n                         (loop odd even (add1\
    \ index) (sub1 index-max)))))\n               (if even (reverse array) array)]\n\
    \              [else (if even (reverse array) array)]))))\n", "  (if (null? array)\n\
    \      '()\n      (cond ((= (modulo (+ (car array) (last array)) 2) 0)\n     \
    \        (reverse array))\n            (else\n             array))))\n", "  (define\
    \ (is_even? n)\n    (= (remainder n 2) 0))\n  (define (sum lst)\n    (if (null?\
    \ lst)\n        0\n        (+ (car lst) (sum (cdr lst)))))\n  (define (sort-ascending?\
    \ lst)\n    (let ([first (car lst)]\n          [last (car (reverse lst))])\n \
    \     (is_even? (+ first last))))\n  (define (merge lst1 lst2)\n    (cond\n  \
    \    [(empty? lst1) lst2]\n      [(empty? lst2) lst1]\n      [(> (car lst1) (car\
    \ lst2)) (cons (car lst2) (merge lst1 (cdr lst2)))]\n      [else (cons (car lst1)\
    \ (merge (cdr lst1) lst2))]))\n  (define (merge-sort lst)\n    (let ([len (length\
    \ lst)])\n      (cond\n        [(= len 1) lst]\n        [else (merge (merge-sort\
    \ (take lst (/ len 2)))\n                     (merge-sort (drop lst (/ len 2))))])))\n\
    \  (define (sort lst asc?)\n    (if asc?\n        (merge-sort lst)\n        (reverse\
    \ (merge-sort lst))))\n  (sort array (sort-ascending? array)))\n```\n\n## Example\
    \ Tests\n\n### Racket\n\n```racket\n#lang racket\n", "  (cond [(null? array) '()]\n\
    \        [(< (length array) 2) array]\n        [else (sort-helper array 0)]))\n",
  "  (define (is-odd? n) (= 1 (remainder n 2)))\n  (define (head arr) (car arr))\n\
    \  (define (tail arr) (cdr arr))\n  (define (last arr) (car (reverse arr)))\n\
    \  (define (sum a b) (+ a b))\n  (cond\n    [(empty? array) array]\n    [(empty?\
    \ (tail array)) array]\n    [(is-odd? (sum (head array) (last array))) (reverse\
    \ (sort array <))]\n    [else (sort array >)]))\n```\n\n> \uC774\uB807\uAC8C \uC2E4\
    \uC81C\uB85C \uD504\uB85C\uADF8\uB798\uBC0D\uD574\uBCF4\uBA74, \uADF8\uB7F0 \uACBD\
    \uC6B0\uAC00 \uC788\uAD6C\uB098 \uD558\uB294 \uC0DD\uAC01\uC774 \uB4E4\uC5C8\uB2E4\
    . \uC774\uB7F0 \uACBD\uC6B0\uC758 \uC218\uB97C \uBAA8\uB450 \uC0DD\uAC01\uD558\
    \uBA74\uC11C \uD480\uAC8C \uB418\uB294 \uAC83\uC774 \uC544\uB2C8\uB77C, \uAE30\
    \uBCF8\uC801\uC778 \uD504\uB85C\uADF8\uB798\uBC0D \uC6D0\uB9AC\uB97C \uAC00\uC9C0\
    \uACE0 \uC788\uC73C\uBA74 \uB41C\uB2E4. \uC774\uB807\uAC8C \uD480\uAC8C \uB418\
    \uBA74 \uB354 \uC27D\uAC8C \uD480\uAC8C \uB41C\uB2E4. \uADF8\uB798\uC11C \uC0DD\
    \uAC01\uC744 \uD558\uACE0, \uD480\uACE0, \uD480\uACE0, \uD480\uACE0 \uADF8\uB798\
    \uC11C \uC9C0\uAE08\uC758 \uC0C1\uD0DC\uC5D0 \uC774\uB974\uAC8C \uB418\uC5C8\uB2E4\
    .\n\n##### \uBCC0\uC218 \uB2E4", "  (cond\n    [(empty? array)\n     '()]\n  \
    \  [(or (odd? (add (first array) (last array)))\n         (even? (add (first array)\
    \ (last array))))\n     (sort (append (sort array #:key cdr) (sort array #:key\
    \ car)) <)]\n    [else\n     (sort (append (sort array #:key car) (sort array\
    \ #:key cdr)) >)]))\n", "  (let\n    ([n (length array)])\n    (if (< n 2)\n \
    \     array\n      (let\n        ([even? (even? (+ (vector-ref array 0) (vector-ref\
    \ array (- n 1))))])\n        (if even?\n          (let*\n            ([aux (make-vector\
    \ n)]\n             [i (floor (/ n 2))]\n             [j (if (odd? n) i (+ i 1))])\n\
    \            (for ([k (in-range n)])\n              (if (odd? k)\n           \
    \     (vector-set! aux k (vector-ref array (- i 1)))\n                (vector-set!\
    \ aux k (vector-ref array (- j 1))))\n              (if (odd? k)\n           \
    \     (set! i (- i 1))\n                (set! j (- j 1))))\n            aux)\n\
    \          (vector-sort array <)))))\n", "  (cond [(null? array) array]\n    \
    \    [(empty? array) array]\n        [else (define (sum_of_first_and_last value)\n\
    \                (+ (car value) (car (reverse value))))\n              (define\
    \ (sort-by-sum-of-first-and-last array)\n                (cond [(= (sum_of_first_and_last\
    \ array) 0) array]\n                      [(odd? (sum_of_first_and_last array))\
    \ (sort array <)]\n                      [else (sort array >)]))\n           \
    \   (sort-by-sum-of-first-and-last array)]))\n", "  (sort\n   (lambda (x y)\n\
    \     (cond\n       [(= (modulo (+ (first array) (last array)) 2) 0)\n       \
    \ (< x y)]\n       [else\n        (> x y)]))\n   array))\n```\n\n#### Two Sum\n\
    \n```racket\n#lang racket\n", "  (if (= (length array) 0)\n      '()\n      (if\
    \ (= (length array) 1)\n          array\n          (if (odd? (+ (car array) (last\
    \ array)))\n              (vector-sort array <)\n              (vector-sort array\
    \ >)))))\n```\n\n![](./images/003.png)\n\n## 4. Convert string to camel case\n\
    \n```#lang racket\n", "  (define (ascending? a b) (< a b))\n  (define (descending?\
    \ a b) (> a b))\n  (define (sum a b) (+ a b))\n  (define (first-index array) (vector-ref\
    \ array 0))\n  (define (last-index array) (vector-ref array (- (vector-length\
    \ array) 1)))\n  (define (sort-conditional array)\n    (if (zero? (modulo (sum\
    \ (first-index array) (last-index array)) 2))\n        (vector-sort! array descending?)\n\
    \        (vector-sort! array ascending?)))\n  (sort-conditional array))\n```\n\
    \n### \u4F18\u79C0\u4EE3\u7801\u793A\u4F8B2\n\n```racket\n#lang racket\n", " \
    \ (if (odd? (length array))\n      (sort < array)\n      (sort > array)))\n",
  "  (cond [(empty? array) array]\n        [(= (length array) 1) array]\n        [else\
    \ (let* ([first-element (car array)]\n                     [last-element (car\
    \ (reverse array))]\n                     [sum (+ first-element last-element)])\n\
    \                (cond [(odd? sum) (sort array <)]\n                      [else\
    \ (sort array >)]))]))\n", "  (let loop ([array array] [index 0])\n    (if (=\
    \ index (add1 (length array)))\n        array\n        (if (odd? (add (list-ref\
    \ array index) (list-ref array (sub1 (length array)))))\n            (loop (insert-list-into-list\
    \ array index (list-ref array index)) (add1 index))\n            (loop (insert-list-into-list\
    \ array index (list-ref array (sub1 (length array)))) (add1 index))))))\n", " \
    \ (if (or (empty? array) (singleton? array))\n      array\n      (if (odd? (+\
    \ (car array) (last array)))\n          (sort array <)\n          (sort array\
    \ >))))", "  (if (null? array)\n      array\n      (let-values ([(first-value\
    \ last-value) (values (first array) (last array))])\n        (if (zero? (remainder\
    \ (+ first-value last-value) 2))\n            (reverse array)\n            array))))\n\
    ```\n\n### [Folding the Paper (6kyu)](https://www.codewars.com/kata/5813d19765d81c592200001a)\n\
    \nTask:\nYou are given a piece of paper to fold in half until you only have a\
    \ piece that is 1/10000 as big as the original piece of paper.\nHow many folds\
    \ will you have to make?\n\n### [Evaluate mathematical expression (6kyu)](https://www.codewars.com/kata/52a78825cdfc2cfc87000005)\n\
    \nTask:\nYou need to evaluate a mathematical expression given in string format.\n\
    \n### [Odd or Even? (6kyu)](https://www.codewars.com/kata/5949481f86420f59480000e7)\n\
    \nTask:\nGiven an array of numbers (a list in groovy), determine whether the sum\
    \ of all of the numbers is odd or even.\n\n### [Points in Segments (5kyu)](https://www.codewars.com/kata/points-in-segments)\n\
    \nTask:\nWe consider a segment of points in the plane of length n (the points\
    \ are numbered from 0 to n-1) and height h.\nWe build a set of segments, each\
    \ of them parallel to the previous one and at a distance of h from it.\nEach segment\
    \ is built upon two points, one from the previous segment and one from the current\
    \ segment.\nThe segments are built in such a way that the two points of a segment\
    \ are not the same and no three points belong to the same segment.\nIn other words,\
    \ each segment contains two different points from the previous segment.\nEach\
    \ segment also contains two different points from the current segment, but they\
    \ don't have to be distinct from the two points of the previous segment.\n\n###\
    \ [Find The Parity Outlier (6kyu)](https://www.codewars.com/kata/5526fc", "  (cond\
    \ [(null? array) '()]\n        [(even? (add1 (length array)))\n         (quick-sort\
    \ array <)]\n        [(odd? (add1 (length array)))\n         (quick-sort array\
    \ >)]))\n", "  (if (empty? array)\n      '()\n      (let ([sum (for/sum ([e (in-vector\
    \ array)]) e)])\n        (if (odd? sum)\n            (merge array (sort array\
    \ <))\n            (merge array (sort array >))))))\n", "  (cond [(empty? array)\
    \ '()]\n        [(= (length array) 1) array]\n        [else (cond [(= (remainder\
    \ (+ (car array) (last array)) 2) 0) (sort array >)]\n                    [else\
    \ (sort array <)])]))\n", "  (cond [(empty? array) empty]\n        [(= (length\
    \ array) 1) array]\n        [else (cond [(odd? (+ (car array) (last array)))\n\
    \                     (sort (build-list (length array) identity) <)]\n       \
    \             [else (sort (build-list (length array) identity) >)])]))\n```\n\n\
    ## Results\n\n```text\n#lang racket\n", "  (let helper ([array array] [left 0]\
    \ [right (length array)])\n    (if (< left right)\n        (let* ([pivot (nth\
    \ array (quotient (+ left right) 2))]\n               [store-index left]\n   \
    \            [i left])\n          (while (< i right)\n            (if (< (nth\
    \ array i) pivot)\n                (begin\n                  (swap! array i store-index)\n\
    \                  (set! store-index (+ store-index 1))\n                  (set!\
    \ i (+ i 1))))\n            (set! i (+ i 1)))\n          (swap! array store-index\
    \ (sub1 right))\n          (set! right (sub1 right))\n          (helper array\
    \ left right))\n        array)))\n", "  (define (swap lst)\n    (match lst\n \
    \     [(list x xs) (cons x (swap xs))]\n      [(list x y xs) (cons y (cons x xs))]))\n\
    \  (if (null? array) (list)\n      (if (even? (+ (car array) (car (reverse array))))\n\
    \          (swap array)\n          array)))\n", "  (sort (list-ref array 0) (list-ref\
    \ array (sub1 (length array))) array))\n", "  (cond\n    [(empty? array) '()]\n\
    \    [(empty? (rest array)) array]\n    [else\n     (let* ([first (first array)]\n\
    \            [last (last array)]\n            [sorted-tail (sort_array (rest (rest\
    \ array)))]\n            [sorted-head\n             (cond\n               [(odd?\
    \ (+ first last)) (sort < (list first last))]\n               [else (sort > (list\
    \ first last))])])\n       (append sorted-head sorted-tail))]))\n", "  (cond\n\
    \    [(null? array) '()]\n    [(odd? (+ (car array) (last array)))\n     (merge\
    \ (sort_array (cdr array)) (sort (cdr (reverse array))))]\n    [else\n     (merge\
    \ (sort_array (cdr array)) (sort (reverse (cdr (reverse array)))))]))\n", "  (define\
    \ odd? (lambda (i) (odd? (+ (array-ref array 0) (array-ref array (sub1 (array-length\
    \ array)))))))\n  (define sort-compare\n    (lambda (a b)\n      (if (odd?)\n\
    \          (- a b)\n          (- b a))))\n  (array-sort sort-compare array))",
  "  (if (null? array)\n      array\n      (if (odd? (+ (car array) (cdr (reverse\
    \ array))))\n          (sort (sort array >) <)\n          (sort (sort array <)\
    \ >))))", "  (cond [(empty? array) '()]\n        [(= (length array) 1) array]\n\
    \        [else (sort_array_helper array)]))\n", "  (cond\n    [(empty? array)\
    \ empty]\n    [(empty? (rest array)) array]\n    [else\n     (define (is-even?\
    \ x)\n       (= (remainder x 2) 0))\n     (if (is-even? (+ (first array) (last\
    \ array)))\n         (sort > array)\n         (sort < array))]))\n", "  (if (empty?\
    \ array)\n      array\n      (sort-array-helper array)))\n", "  (sort array (\u03BB\
    \ (x y) (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length\
    \ array) 1)))) (< x y) (> x y)))))\n", "  (let ([len (length array)])\n    (if\
    \ (= 0 len)\n        array\n        (let ([odd? (odd? (+ (vector-ref array 0)\
    \ (vector-ref array (- len 1))))])\n          (let ([pairs (for/list ([i (in-range\
    \ 0 len)])\n                                 (list (vector-ref array i) i))])\n\
    \            (vector-map (lambda (index)\n                          (vector-ref\
    \ array (cadr index)))\n                        (if odd?\n                   \
    \         (sort pairs compare-odd-vectors)\n                            (sort\
    \ pairs compare-even-vectors))))))))\n", "  (sort (lambda (a b)\n          (if\
    \ (even? (+ (car array) (last array)))\n              (&lt; a b)\n           \
    \   (&gt; a b)))\n        array))\n</code>\nThe test cases are:\n<code>(define\
    \ (sort_array_tests)\n  (test-equal (sort_array (list 2 4 3 0 1 5))\n        \
    \      (list 0 1 2 3 4 5))\n  (test-equal (sort_array (list 2 4 3 0 1 5 6))\n\
    \              (list 6 5 4 3 2 1 0))\n  (test-equal (sort_array (list 5))\n  \
    \            (list 5))\n  (test-equal (sort_array (list))\n              (list)))\n\
    </code>\n", "  (cond\n    [(zero? (length array)) empty]\n    [(= 1 (length array))\
    \ array]\n    [else\n     (let ([sorted-array (sort array\n                  \
    \             (\u03BB (x y)\n                                 (if (odd? (+ (first\
    \ array) (last array)))\n                                     (< x y)\n      \
    \                               (> x y))))])\n       sorted-array)]))\n", "  (match\
    \ (sort array #:key (case->* (modulo (sum array) 2) (odd? #t) (even? #f)))\n \
    \   [empty '()]\n    [(_)\n     (if (even? (sum array))\n         (reverse array)\n\
    \         array)]))\n", "  (if (not (empty? array))\n      (if (odd? (+ (car array)\
    \ (last array)))\n          (list-sort (append (list (car array)) (cdr array))\n\
    \                      <)\n          (list-sort (append (list (car array)) (cdr\
    \ array))\n                      >))))\n", "  (map (lambda (x) (- (car x) (cdr\
    \ x)))\n       (sort (for/list ([x (in-list array)])\n               (cons x (if\
    \ (even? (+ (length array) (car array) (last array)))\n                      \
    \     x (- x))))\n             >)))\n", "  (if (null? array)\n      '()\n    \
    \  (let* ([size (length array)]\n             [size-even? (even? size)]\n    \
    \         [first-half (slice array 0 (quotient size 2))]\n             [second-half\
    \ (slice array (quotient size 2) size)])\n        (if size-even?\n           \
    \ (append (reverse (sort first-half #:key (\u03BB (x) x)))\n                 \
    \   (reverse (sort second-half #:key (\u03BB (x) x))))\n            (append (sort\
    \ first-half #:key (\u03BB (x) x))\n                    (sort second-half #:key\
    \ (\u03BB (x) x)))))))\n", "  (if (null? array)\n      array\n      (let ([n (length\
    \ array)])\n        (cond\n         [(odd? (+ (list-ref array 0) (list-ref array\
    \ (- n 1))))\n          (reverse (sort array #:key (\u03BB (x) x)))]\n       \
    \  [else\n          (sort array #:key (\u03BB (x) x))]))))\n", "  (cond\n    [empty?\
    \ array] '()\n    [(= (length array) 1) array]\n    [else\n     (define (asc?)\n\
    \       (odd? (+ (car array) (last array))))\n     (define (desc?)\n       (even?\
    \ (+ (car array) (last array))))\n     (cond\n       [(asc?) (sort > array)]\n\
    \       [(desc?) (sort < array)]\n       [else '()])]))", "  (if (null? array)\n\
    \      '()\n      (let ([first (car array)]\n            [last (car (reverse array))])\n\
    \        (if (even? (+ first last))\n            (reverse (sort array <))\n  \
    \          (sort array >)))))\n", "  (match array\n    [(list) '()]\n    [(list\
    \ x) (list x)]\n    [(list x . xs)\n     (if (even? (+ x (last xs)))\n       \
    \  (append (sort_array (list x)) (sort_array xs))\n         (append (sort_array\
    \ xs) (sort_array (list x))))]))\n", "  (match array\n    [(list) '()]\n    [(list\
    \ element) '(element)]\n    [(list element1 element2 ...)\n     (define (even?\
    \ n)\n       (= (remainder n 2) 0))\n     (define (odd? n)\n       (not (even?\
    \ n)))\n     (cond [(even? (+ (first array) (last array)))\n            (sort\
    \ array <)]\n           [(odd? (+ (first array) (last array)))\n            (sort\
    \ array >)])]))\n", "  (define (sort_array_helper array helper)\n    (cond [(empty?\
    \ array) (reverse helper)]\n          [(odd? (+ (first array) (last array)))\n\
    \           (sort_array_helper (rest (butlast array)) (cons (first array) helper))]\n\
    \          [else (sort_array_helper (rest (butlast array)) (cons (last array)\
    \ helper))]))\n  (if (empty? array)\n      array\n      (sort_array_helper array\
    \ '())))\n", "  (if (= 0 (length array))\n      array\n      (if (= 1 (length\
    \ array))\n          array\n          (if (even? (+ (first array) (last array)))\n\
    \              (sort array <)\n              (sort array >)))))\n```\n\n## Source\n\
    CodeWars", "  (cond [(null? array) array]\n        [(null? (cdr array)) array]\n\
    \        [(= (even? (+ (car array) (car (last array)))) 1)\n         (define a\
    \ (sort array <))\n         (append (drop-right a 1) (reverse (take-right a 1)))]\n\
    \        [else\n         (define a (sort array >))\n         (append (drop-right\
    \ a 1) (reverse (take-right a 1)))]))\n", "  (sort array (\u03BB (a b) (cond [(=\
    \ (modulo (+ (first array) (last array)) 2) 0)\n                             \
    \  (> a b)]\n                              [else\n                           \
    \    (< a b)]))))\n", "  (if (empty? array)\n      empty\n      (insert-sorted\
    \ array)))\n", "  (define sum (apply + array))\n  (define comparer\n    (cond\
    \ ((= 0 (modulo sum 2)) (\u03BB (a b) (> a b)))\n          (else (\u03BB (a b)\
    \ (< a b)))))\n  (sort comparer array))\n", "  (if (null? array)\n      '()\n\
    \      (match array\n        [() '()]\n        [(cons first rest)\n         (let\
    \ ([sum (match first [0 0] [(add-first rest)])])\n           (if (even? sum)\n\
    \               (sort rest >)\n               (sort rest <)))])))\n  ```\n- 7kyu_sum-of-pairs.rkt\n\
    \  ```racket\n  #lang racket\n  \n  ;; Given a list of integers and a single sum\
    \ value, return the first two values (parse from the left please)\n  ;; in order\
    \ of appearance that add up to form the sum.\n  ;; Examples:\n  ;; * sum_pairs([5,\
    \ 8, 13, -3], 10) => [5, 5]\n  ;; * sum_pairs([5, 8, 13, -3], 8) => nil\n  ;;\
    \ * sum_pairs([1, 3, 2, 2], 4) => [1, 3]\n  ;; * sum_pairs([21, 20, 18, 13, 12,\
    \ 13, 10], 33) => [20, 13]\n  ;; * sum_pairs([21, 20, 18, 13, 12, 13, 10], 40)\
    \ => [18, 22]\n  ;; * sum_pairs([21, 20, 18, 13, 12, 13, 10], 18) => [13, 5]\n\
    \  ;; * sum_pairs([], 100) => nil\n  ;;\n  ;; Good luck and enjoy!\n  (define\
    \ (sum_pairs lst sum)\n    (if (null? lst)\n        '()\n        (let ([sums (for/fold\
    \ ([sum? (in-list '())])\n                       ([item lst])\n              \
    \         (if (member sum? sum)\n                           sum?\n           \
    \                (cons sum (cons item sum?))))])\n          (if (null? sums)\n\
    \              '()\n              (match sums [(cons first rest) (cons first (take\
    \ rest 1))])))))\n  ```\n- 7kyu_string_to_number.rkt\n  ```racket\n  #lang racket\n\
    \  \n  ;; Given a string, return the equivalent number.\n  ;; Example:", "  (let\
    \ ([first (first array)]\n        [last (last array)])\n    (cond\n      [(zero?\
    \ (remainder (+ first last) 2))\n       (quicksort (list->vector array) (lambda\
    \ (a b) (< b a)))]\n      [else\n       (quicksort (list->vector array) (lambda\
    \ (a b) (< a b)))])))\n", "  (if (not (empty? array))\n      (let* ((sum_first_last\
    \ (remainder (+ (first array) (last array)) 2))\n             (sort-fn (if (=\
    \ sum_first_last 0) list->vector sort))\n             (sorted-arr (sort-fn array)))\n\
    \        (vector->list sorted-arr))\n      '()))\n", "  (sort (sort array #:key\
    \ (lambda (x) (if (even? (+ (first array) (last array))) 'desc 'asc))) #:key (lambda\
    \ (x) (if (even? (+ (first array) (last array))) 'asc 'desc))))\n", "  (if (empty?\
    \ array)\n      empty\n      (if (odd? (+ (car array) (car (reverse array))))\n\
    \          (sort < array)\n          (sort > array))))\n", "  (if (eq? '() array)\n\
    \      '()\n      (let* ([n (car array)]\n             [tail (cdr array)]\n  \
    \           [sum (+ (car array) (car (reverse array)))]\n             [new-array\
    \ (if (odd? sum) (reverse array) array)])\n        (cons n (sort_array tail)))))\n",
  "  (sort array\n        (lambda (a b)\n          (let ((sum (+ (first array) (last\
    \ array))))\n            (cond\n              [(zero? (modulo sum 2)) (and (positive?\
    \ (- a b)) (positive? (- b a))) ]\n              [else (positive? (- a b))])))))\n",
  "  (sort-array array 'lt:< #:sort-key (if (odd? (+ (car array) (last array))) first\
    \ identity)))\n```\n## Solutions (Ruby)\n\n```ruby\ndef sort_array(array)\n  if\
    \ array.empty?\n    []\n  elsif (array[0] + array[-1]) % 2 == 0\n    array.sort.reverse\n\
    \  else\n    array.sort\n  end\nend\n```\n## Solutions (Swift)\n\n```swift\nfunc\
    \ sortArray(_ array: [Int]) -> [Int] {\n    if array.isEmpty {\n        return\
    \ []\n    }\n    if (array[0] + array[array.count - 1]) % 2 == 0 {\n        return\
    \ array.sorted(by: >)\n    }\n    return array.sorted()\n}\n```\n## Solutions\
    \ (JavaScript)\n\n```javascript\nfunction sortArray(array) {\n  if (array.length\
    \ == 0) {\n    return [];\n  }\n  if ((array[0] + array[array.length - 1]) % 2\
    \ == 0) {\n    return array.sort(function(a, b) {\n      return b - a;\n    });\n\
    \  }\n  return array.sort(function(a, b) {\n    return a - b;\n  });\n}\n```\n\
    ## Solutions (Python)\n\n```python\ndef sort_array(array):\n    if not array:\n\
    \        return []\n    if (array[0] + array[-1]) % 2 == 0:\n        return sorted(array,\
    \ reverse=True)\n    return sorted(array)\n```\n## Solutions (Java)\n\n```java\n\
    import java.util.Arrays;\n\npublic class Solution {\n    public static int[] sortArray(int[]\
    \ array) {\n        if (array.length == 0) {\n            return new int[0];\n\
    \        }\n        if ((array[0] + array[array.length - 1]) % 2 == 0) {\n   \
    \         Arrays.sort(array);\n            int start = 0;\n            int end\
    \ = array.length - 1;\n            while (start < end) {\n                int\
    \ temp", "  (cond\n    [(empty? array) '()]\n    [(equal? (sum array) 0) array]\n\
    \    [(even? (sum array)) (sort array >)]\n    [else (sort array <)]))\n", " \
    \ (if (empty? array)\n      '()\n      (let ([first (first array)]\n         \
    \   [last (last array)])\n        (let ([ret (sort array (if (odd? (+ first last))\
    \ > <))])\n          (if (equal? first last)\n              ret\n            \
    \  (cons last (sort_array (remove last ret))))))))\n", "  (if (= (length array)\
    \ 0)\n      '()\n      (if (= (length array) 1)\n          array\n          (if\
    \ (odd? (+ (list-ref array 0) (list-ref array (- (length array) 1))))\n      \
    \        (sort array <)\n              (sort array >)))))", "  (if (empty? array)\n\
    \      array\n      (let ([i 0]\n            [result (vector)]\n            [sorted-array\
    \ (sort array (lambda (a b) (< a b)))]\n            [flipped? (odd? (+ (vector-ref\
    \ array 0) (vector-ref array (- (vector-length array) 1))))])\n        (for ([value\
    \ (in-vector sorted-array)])\n          (vector-set! result i value)\n       \
    \   (if flipped?\n              (set! i (+ i 2))\n              (set! i (+ i 1))))\n\
    \        (cond [(< i (vector-length result))\n               (vector-set! result\
    \ i (vector-ref sorted-array (- (vector-length sorted-array) 1)))])\n        result)))\n",
  "  (if (empty? array)\n      '()\n      (quicksort array))\n)\n", "  (match array\n\
    \    ([_] array)\n    ([_ _] (sort_array array))\n    ([] '())\n    ([_ _ _] (sort_array\
    \ (sort array #:key car)))))\n", "  (sort array\n        (\u03BB (a b)\n     \
    \     (if (even? (+ (array-ref array 0) (array-ref array (sub1 (array-length array)))))\n\
    \              (> a b)\n              (< a b)))))\n", "  (if (empty? array)\n\
    \      '()\n      (sort_array_helper\n       (build-list (length array) (lambda\
    \ (x) (list x array)))\n       '())))\n", "  (define (odd-even? n)\n    (cond\n\
    \      [(odd? n) 'odd]\n      [(even? n) 'even]))\n  (define (asc-desc? array)\n\
    \    (cond\n      [(odd? (+ (array-ref array 0) (array-ref array (- (array-length\
    \ array) 1)))) 'asc]\n      [(even? (+ (array-ref array 0) (array-ref array (-\
    \ (array-length array) 1)))) 'desc]))\n  (define (sorted-array? sorted-array)\n\
    \    (define (asc-sorted? array)\n      (cond\n        [(< (array-ref array 0)\
    \ (array-ref array 1)) (asc-sorted? (subarray array 1))]\n        [(= (array-ref\
    \ array 0) (array-ref array 1)) (asc-sorted? (subarray array 1))]\n        [(>\
    \ (array-ref array 0) (array-ref array 1)) #f]))\n    (define (desc-sorted? array)\n\
    \      (cond\n        [(> (array-ref array 0) (array-ref array 1)) (desc-sorted?\
    \ (subarray array 1))]\n        [(= (array-ref array 0) (array-ref array 1)) (desc-sorted?\
    \ (subarray array 1))]\n        [(< (array-ref array 0) (array-ref array 1)) #f]))\n\
    \    (cond\n      [(equal? 'asc (asc-desc? sorted-array)) (asc-sorted? sorted-array)]\n\
    \      [(equal? 'desc (asc-desc? sorted-array)) (desc-sorted? sorted-array)]))\n\
    \  (define (sort-array array)\n    (define (swap-array array swapped index)\n\
    \      (define (swap-with-next array index)\n        (array-set! array index (array-ref\
    \ array (+ index 1)))\n        (array-set! array (+ index 1) swapped))\n     \
    \ (cond\n        [(< swapped (array-ref array index)) (swap-with-next array index)]\n\
    \        [(= swapped (array-ref array index)) (swap-with-next array index)]\n\
    \        [(> swapped (array-ref array index))", "  (if (empty? array)\n      '()\n\
    \      (sort array <=)))\n", "  (let ([odd? (odd? (+ (array-ref array 0) (array-ref\
    \ array (- (array-length array) 1))))])\n    (if odd?\n        (sort array <)\n\
    \        (sort array >))))", "  (let* ([a (build-list (length array) id)]\n  \
    \       [b (build-list (length array) add1)]\n         [x (sum a)]\n         [y\
    \ (sum b)])\n    (if (= (modulo x y) 0)\n        (vector-sort array >)\n     \
    \   (vector-sort array <))))\n```\n\n## Test suite\n\nRun `(test)` from the REPL\
    \ to run awesome tests.\n\n## Source\n\n[https://www.codewars.com/kata/sort-array-by-sum-of-its-parts/train/racket](https://www.codewars.com/kata/sort-array-by-sum-of-its-parts/train/racket)\n\
    \n## Submitting Incomplete Solutions\nIt's possible to submit an incomplete solution\
    \ so you can see how others have completed the exercise.", "  (define sum (list-ref\
    \ array 0) (last array))\n  (cond\n    ((= (mod sum 2) 0) (sort array >))\n  \
    \  (else (sort array <))))", "  (cond [(empty? array) empty]\n        [(null?\
    \ (rest array)) array]\n        [(odd? (+ (first array) (last array)))\n     \
    \    (sort array <)]\n        [else\n         (sort array >)]))\n", "  (apply\
    \ (if (odd? (+ (car array) (cdr (reverse array)))) list values) array))\n", " \
    \ (define (sum_of_first_and_last xs)\n    (+ (car xs) (car (reverse xs))))\n \
    \ (define (ascending? xs)\n    (odd? (sum_of_first_and_last xs)))\n  (define (compare\
    \ x y)\n    (cond\n      [(> x y) 1]\n      [(< x y) -1]\n      [else 0]))\n \
    \ (define (descending? xs)\n    (even? (sum_of_first_and_last xs)))\n  (define\
    \ (sort xs)\n    (if (ascending? xs)\n        (sort xs <)\n        (sort xs >)))\n\
    \  (sort array))\n", "  (if (empty? array)\n      array\n      (if (equal? (first\
    \ array) (last array))\n          array\n          (if (zero? (modulo (+ (first\
    \ array) (last array)) 2))\n              (reverse array)\n              (sort\
    \ array <)))))", "  (if (zero? (modulo (+ (vector-ref array 0) (vector-ref array\
    \ (- (vector-length array) 1))) 2))\n      (vector-sort array <)\n      (vector-sort\
    \ array >)))\n", "  (if (null? array)\n      '()\n      (if (even? (+ (car array)\
    \ (last array)))\n          (reverse array)\n          array)))\n", "  (match\
    \ array\n    ['() '()]\n    [(cons first (cons second rest))\n     (cond\n   \
    \    [(odd? (+ first second))\n        (cons second (cons first (sort_array rest)))]\n\
    \       [else\n        (cons first (cons second (sort_array rest)))])]))\n", " \
    \ (if (null? array)\n      '()\n      (let ((index1 (list-ref array 0))\n    \
    \        (index2 (list-ref array (- (length array) 1))))\n        (if (odd? (+\
    \ index1 index2))\n            (insertion-sort array #:key identity)\n       \
    \     (insertion-sort array #:key (\u03BB (x) (- 0 x)))))))\n", "  (if (equal?\
    \ array '())\n      '()\n      (displayln (first array))\n      (displayln (last\
    \ array))\n      (if (equal? array '())\n          '()\n          (if (even? (+\
    \ (first array) (last array)))\n              (append (sort_array (cdr (reverse\
    \ array))) (list (first (reverse array))))\n              (append (list (first\
    \ array)) (sort_array (cdr array)))\n          )\n      )\n  )\n)\n", "  (define\
    \ \n    (inner array-length previous-index this-index next-index)\n    (if (zero?\
    \ array-length)\n        array\n        (let \n          ([this-index (modulo\
    \ this-index array-length)]\n           [next-index (modulo next-index array-length)])\n\
    \          (if \n            (and \n              (not (zero? previous-index))\n\
    \              (not (zero? next-index))\n              (or \n                (=\
    \ this-index array-length)\n                (= next-index array-length)))\n  \
    \          array\n            (inner \n              array-length \n         \
    \     this-index \n              next-index \n              (+ next-index 1))))))\n\
    \  (inner \n    (vector-length array) \n    (vector-ref array 0) \n    (- (vector-length\
    \ array) 1) \n    (- (vector-length array) 2)))\n```\n\n## References\n\n* [Racket:\
    \ Documents and Tips](https://github.com/fukamachi/racket-study#racket-documents-and-tips)\n\
    * [racket documentation](https://docs.racket-lang.org/)\n* [Racket: How to Use\
    \ Racket?](https://github.com/fukamachi/racket-study#racket-how-to-use-racket)\n\
    * [How to run racket-code on Emacs?](https://github.com/fukamachi/racket-study#how-to-run-racket-code-on-emacs)",
  "  (cond [(empty? array) '()]\n        [(empty? (rest array)) (list (first array))]\n\
    \        [else\n         (let ([first-element (first array)]\n               [last-element\
    \ (last array)])\n           (if (odd? (+ first-element last-element))\n     \
    \          (let ([sort-array (sort array <)])\n                 (append (reverse\
    \ (rest (rest sort-array)))\n                         (list (first sort-array))\n\
    \                         (list (second sort-array))))\n               (let ([sort-array\
    \ (sort array >)])\n                 (append (reverse (rest (rest sort-array)))\n\
    \                         (list (first sort-array))\n                        \
    \ (list (second sort-array))))))]))\n", "  (define (ascending? value1 value2)\n\
    \    (< value1 value2))\n  (define (descending? value1 value2)\n    (> value1\
    \ value2))\n  (define (reverse_array array)\n    (if (null? array)\n        empty\n\
    \        (append (reverse_array (cdr array)) (list (car array)))))\n  (if (= (modulo\
    \ (+ (car array) (car (reverse array))) 2) 0)\n      (reverse_array (sort array\
    \ descending?))\n      (sort array ascending?)))\n```\n\n\u4F7F\u7528 [Racket\
    \ \u5B98\u65B9\u6587\u6863](https://docs.racket-lang.org/guide/pairs.html) \u67E5\
    \u8BE2\u94FE\u8868\u64CD\u4F5C\u51FD\u6570\uFF0C\u53D1\u73B0\u53EF\u4EE5\u7528\
    \ `reverse` \u51FD\u6570\u6765\u5B9E\u73B0\u94FE\u8868\u7FFB\u8F6C\u3002\n\n##\
    \ 6. \u5408\u5E76\u4E24\u4E2A\u94FE\u8868\n\n> \u5C06\u4E24\u4E2A\u5347\u5E8F\u94FE\
    \u8868\u5408\u5E76\u4E3A\u4E00\u4E2A\u65B0\u7684 \u5347\u5E8F \u94FE\u8868\u5E76\
    \u8FD4\u56DE\u3002\u65B0\u94FE\u8868\u662F\u901A\u8FC7\u62FC\u63A5\u7ED9\u5B9A\
    \u7684\u4E24\u4E2A\u94FE\u8868\u7684\u6240\u6709\u8282\u70B9\u7EC4\u6210\u7684\
    \u3002\n\n[6. \u5408\u5E76\u4E24\u4E2A\u94FE\u8868](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\
    \n\u89E3\u9898\u601D\u8DEF\uFF1A\n\n- \u5408\u5E76\u4E24\u4E2A\u94FE\u8868\uFF0C\
    \u5982\u679C\u4E24\u4E2A\u94FE\u8868\u6709\u4E00\u4E2A\u4E3A\u7A7A\uFF0C\u5C31\
    \u8FD4\u56DE\u53E6\u4E00\u4E2A\u94FE\u8868\uFF1B\n- \u5982\u679C\u4E24\u4E2A\u94FE\
    \u8868\u90FD\u4E0D\u4E3A\u7A7A\uFF0C\u6BD4\u8F83\u4E24\u4E2A\u94FE\u8868\u7684",
  "  (cond [(empty? array) '()]\n        [(> (first array) (last array)) (sort_array\
    \ (reverse array))]\n        [else (reverse (sort_array (reverse array)))]))",
  "  (if (= 0 (length array))\n      '()\n      (if (= 1 (length array))\n       \
    \   array\n          (if (odd? (+ (first array) (last array)))\n             \
    \ (sort array <)\n              (sort array >)))))\n```\n\n## 10.3.3. \u89E3\u8AAC\
    \n\n\u914D\u5217\u306E\u9577\u3055\u304C 0 \u307E\u305F\u306F 1 \u306E\u5834\u5408\
    \u306F\u3001\u914D\u5217\u3092\u305D\u306E\u307E\u307E\u8FD4\u3057\u307E\u3059\
    \u3002\n\u305D\u308C\u4EE5\u5916\u306E\u5834\u5408\u306F\u3001\u914D\u5217\u306E\
    \u9577\u3055\u304C\u5947\u6570\u304B\u5076\u6570\u304B\u3067\u3001\u30BD\u30FC\
    \u30C8\u3092\u884C\u3044\u307E\u3059\u3002\n\u914D\u5217\u306E\u9577\u3055\u304C\
    \u5947\u6570\u3067\u3042\u308C\u3070\u6607\u9806\u3001\u5076\u6570\u3067\u3042\
    \u308C\u3070\u964D\u9806\u3067\u3059\u3002\n\n## 10.3.4. \u6240\u611F\n\n\u3088\
    \u304F\u3042\u308B\u30D0\u30D6\u30EB\u30BD\u30FC\u30C8\u3068\u304B\u4F7F\u3048\
    \u3070\u3001\u9806\u756A\u3092\u6307\u5B9A\u3059\u308B\u30AA\u30D7\u30B7\u30E7\
    \u30F3\u4ED8\u304D\u3067\u7C21\u5358\u306B\u3067\u304D\u308B\u3093\u3067\u3059\
    \u304C\u3001\n\u305B\u3063\u304B\u304F\u306A\u306E\u3067`sort`\u3092\u4F7F\u3063\
    \u3066\u307F\u307E\u3057\u305F\u3002", "  (let\n    [(first_value (vector-ref\
    \ array 0))\n     (last_value (vector-ref array (- (vector-length array) 1)))]\n\
    \    (if\n      (odd? (+ first_value last_value))\n      (sort array (vector-&gt;list\
    \ array))\n      (reverse (sort array (vector-&gt;list array))))))\n</code>\n\
    I tried to use define (sort_array array) as the function so I can call it in my\
    \ tests.\nI also tried to use (sort array (vector->list array)) as the sort function\n\
    and reverse it if the condition is even.\nwhen I run the tests they are all failing.\n\
    can anyone tell me what am I doing wrong?\n\n\nA:\n\nI solved it.\n<code>#lang\
    \ racket\n", "  (cond\n    [(empty? array) empty]\n    [(empty? (rest array))\
    \ (list (first array))]\n    [else\n     (let* ([left (sort_array (take (length\
    \ array) (rest array) (sub1 (length array)))))\n            [right (sort_array\
    \ (drop (length array) (rest array) (sub1 (length array))))])\n       (cond\n\
    \         [(odd? (+ (first array) (last array)))\n          (append (merge_asc\
    \ left right) (list (first array)))]\n         [else\n          (append (merge_desc\
    \ left right) (list (first array)))]))]))\n", "  (cond\n    [(empty? array) '()]\n\
    \    [(= (array-length array) 1) array]\n    [(= (modulo (+ (array-ref array 0)\
    \ (array-ref array (- (array-length array) 1))) 2) 0)\n     (sort array >)]\n\
    \    [else (sort array <)]))", "  (if (equal? (length array) 0)\n      empty\n\
    \      (if (equal? (length array) 1)\n          array\n          (if (even? (+\
    \ (car array) (last array)))\n              (sort-descending array)\n        \
    \      (sort-ascending array)))))\n", "  (cond\n    [(empty? array) array]\n \
    \   [(empty? (rest array)) array]\n    [else\n     (if (even? (+ (first array)\
    \ (last array)))\n         (reverse (sort array <))\n         (sort array <))]))",
  "  (match (array-append array (list (modulo (+ (array-ref array 0) (array-ref array\
    \ (- (array-length array) 1))) 2)))\n    [(list (or 1 _))\n     (array-sort array\
    \ <)]\n    [(list (or 0 _))\n     (array-sort array >)]))\n", "  (if (null? array)\n\
    \      '()\n      (letrec ([even? (lambda (i) (even? (modulo i 2)))]\n       \
    \        [first-element (car array)]\n               [last-element (car (reverse\
    \ array))]\n               [odd? (lambda (i) (not (even? i)))])\n        (if (odd?\
    \ (+ first-element last-element))\n            (reverse (sort array <))\n    \
    \        (sort array >)))))\n", "  (let* ([sum (reduce + (list (car array) (car\
    \ (reverse array))))]\n         [length (length array)])\n    (if (odd? sum)\n\
    \        (for/fold ([sum 0] [sum-pos 0] [diff-pos 0]) ([i (in-range length)])\n\
    \          (if (and (zero? sum) (zero? sum-pos))\n              (values (+ i (array-ref\
    \ array i)) i i)\n              (values sum sum-pos diff-pos)))\n        (for/fold\
    \ ([sum 0] [sum-pos 0] [diff-pos 0]) ([i (in-range length)])\n          (if (and\
    \ (zero? sum) (zero? sum-pos))\n              (values (+ i (array-ref array i))\
    \ i i)\n              (values sum sum-pos diff-pos))))))\n", "  (cond\n    [(empty?\
    \ array) '()]\n    [(empty? (rest array)) array]\n    [else\n     (let ([length\
    \ (add1 (length array))])\n       (cond\n         [(even? (apply + (take array\
    \ (/ length 2))))\n          (reverse (sort array <))]\n         [else\n     \
    \     (sort array <)]))]))\n", "  (define len (length array))\n  (if (odd? (+\
    \ (vector-ref array 0) (vector-ref array (- len 1))))\n      (let loop ([array\
    \ array] [i 0] [j (- len 1)])\n        (if (&lt; i j)\n            (let ([tmp\
    \ (vector-ref array i)])\n              (vector-set! array i (vector-ref array\
    \ j))\n              (vector-set! array j tmp)\n              (loop array (+ i\
    \ 1) (- j 1)))\n            array))\n      (let loop ([array array] [i 0] [j (-\
    \ len 1)])\n        (if (&lt; i j)\n            (let ([tmp (vector-ref array i)])\n\
    \              (vector-set! array i (vector-ref array j))\n              (vector-set!\
    \ array j tmp)\n              (loop array (+ i 1) (- j 1)))\n            array))))\n",
  "  (define (even? x) (= (remainder x 2) 0))\n  (if (empty? array)\n      '()\n \
    \     (sort (reverse array) #:key (lambda (x)\n                              \
    \      (if (even? (add1 (length array)))\n                                   \
    \     (sub1 x)\n                                        x)))))", "  (if (empty?\
    \ array)\n      '()\n      (let* ((sum (apply + array))\n             (comparator\
    \ (if (odd? sum)\n                             (lambda (x y) (< x y))\n      \
    \                       (lambda (x y) (> x y)))))\n        (mergesort comparator\
    \ array))))\n", "  (cond\n    [(empty? array) (vector)]\n    [(= (array-length\
    \ array) 1) array]\n    [(= (modulo (+ (array-ref array 0) (array-ref array (-\
    \ (array-length array) 1))) 2) 0)\n     (sort array >)]\n    [else (sort array\
    \ <)]))\n", "  (let loop ([a array] [lst '()])\n    (if (empty? a)\n        (list->vector\
    \ (reverse lst))\n        (let ([sum (apply + (list (first a) (last a)))]\n  \
    \            [res (vector-sort\n                    (lambda (x y)\n          \
    \            (if (odd? sum)\n                          (vector-length x y)\n \
    \                         (vector-length y x)))\n                    a)])\n  \
    \        (loop (subvector res 1 (- (vector-length res) 1))\n                (cons\
    \ (vector-ref res 0) lst))))))\n", "  (if (empty? array)\n      '()\n      (sort_array_internal\
    \ (sort array <) (sort array >) 0 (sub1 (length array)))))\n", "  (cond [(null?\
    \ array) '()]\n        [(= (length array) 1) array]\n        [else\n         (if\
    \ (odd? (+ (first array) (last array)))\n             (list->vector (sort array\
    \ (lambda (x y) (< x y))))\n             (list->vector (sort array (lambda (x\
    \ y) (> x y)))))]))", "  (define (sort-odd list)\n    (sort list >))\n  (define\
    \ (sort-even list)\n    (sort list <))\n  (if (odd? (+ (first array) (last array)))\n\
    \      (sort-odd array)\n      (sort-even array)))\n", "  (cond\n    [(null? array)\
    \ null]\n    [(= (length array) 1) array]\n    [else\n     (letrec\n         ([even?\
    \ (lambda (x) (= 0 (remainder x 2)))]\n          [odd? (lambda (x) (not (even?\
    \ x)))]\n          [odd-even-sort (lambda (x y)\n                           (cond\n\
    \                             [(and (even? (car x)) (even? (car y))) (< (car x)\
    \ (car y))]\n                             [(and (odd? (car x)) (odd? (car y)))\
    \ (< (car x) (car y))]\n                             [(and (even? (car x)) (odd?\
    \ (car y))) #t]\n                             [(and (odd? (car x)) (even? (car\
    \ y))) #f]))]\n          [sort-func (lambda (array)\n                       (sort\
    \ odd-even-sort array))])\n       (sort-func array))]))\n", "  (if (empty? array)\n\
    \      '()\n      (let ([sum (+ (first array) (last array))])\n        (if (odd?\
    \ sum)\n            (sort array <)\n            (sort array >)))))\n```\n\n####\
    \ Sample Test(s)\n\n```racket", "  (sort-by (lambda (x y)\n             (if (even?\
    \ (+ (first array) (last array)))\n                 (and (< x y) #t)\n       \
    \          (and (> x y) #t)))\n           array))", "  (sort-by (match-lambda\
    \ [(list f l) (if (odd? (+ f l)) < >)]) array))\n```\n\n### Solution\n\n```racket",
  "  (cond [(empty? array) empty]\n        [(empty? (rest array)) array]\n       \
    \ [(empty? (rest (rest array))) array]\n        [else\n         (define reverse?\
    \ (odd? (+ (first array) (last array))))\n         (define sorted-array (sort\
    \ array <))\n         (if reverse? (reverse sorted-array) sorted-array)]))\n",
  "  (match array\n    [() empty]\n    [(cons x xs)\n     (if (even? (+ (car array)\
    \ (cadr (reverse array))))\n         (reverse (car-cons-cdr (sort (car-cons-cdr\
    \ array))\n                                 empty))\n         (sort (car-cons-cdr\
    \ array)))]))\n", "  (define (odd? n) (= (remainder n 2) 1))\n  (cond [(null?\
    \ array) '()]\n        [(null? (cdr array)) array]\n        [(odd? (+ (car array)\
    \ (last array)))\n         (reverse (sort array <))]\n        [else (sort array\
    \ >)]))", "  (if (zero? (length array))\n      '()\n      (let ([odd? (odd? (+\
    \ (car array) (car (reverse array))))])\n        (if odd?\n            (sort array\
    \ <)\n            (sort array >)))))", "  (sort array (lambda (a b) (if (even?\
    \ (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1)))) (>\
    \ a b) (< a b)))))\n", "  (let ([len (vector-length array)])\n    (let ([sum (+\
    \ (vector-ref array 0) (vector-ref array (- len 1)))])\n      (if (odd? sum)\n\
    \          (define sorted-array (sort array <))\n          (define sorted-array\
    \ (sort array >)))\n      sorted-array)))\n", "  (sort array\n        <\n    \
    \    #:key (\u03BB (num) (if (even? (+ (car array) (last array))) num (- num)))))\n",
  "  (define (odd? a)\n    (eq? (remainder a 2) 1))\n  (define (decreasing-order?\
    \ a b)\n    (< b a))\n  (define (increasing-order? a b)\n    (< a b))\n  (cond\n\
    \    [(odd? (array-ref array 0)) (sort array decreasing-order?)]\n    [else (sort\
    \ array increasing-order?)]))\n", "  (if (equal? array '())\n      '()\n     \
    \ (if (= (remainder (+ (first array) (last array)) 2) 0)\n          (reverse array)\n\
    \          array)))\n", "  (if (empty? array)\n      array\n      (if (= (modulo\
    \ (+ (first array) (last array)) 2) 0)\n          (sort array >)\n          (sort\
    \ array <))))\n", "  (if (empty? array)\n      '()\n      (cond\n        [(= (remainder\
    \ (+ (first array) (last array)) 2) 0) (reverse array)]\n        [else (sort <\
    \ array)])))\n", "  (sort (lambda (x y)\n          (if (odd? (+ (first array)\
    \ (last array)))\n              (< x y)\n              (> x y)))\n        array))\n",
  "  (cond\n    [(empty? array) '()]\n    [(even? ( + (car array) (last array))) (append\
    \ (sort_array (butlast array)) (list (last array)))]\n    [else (append (reverse\
    \ (sort_array (cdr array))) (list (car array)))]))\n", "  (let ([first (first\
    \ array)]\n        [last (last array)])\n    (if (odd? (+ first last))\n     \
    \   (vector-sort array <)\n        (vector-sort array >))))\n```\n\n```\n#lang\
    \ racket\n", "  (let ([s (array-sum array)])\n    (sort (compose not null?)\n\
    \          (map (\u03BB (x) (if (even? s) x (first array)))\n               (array-sort\
    \ (compose (\u03BB (x) (if (even? s) x (not x))) >) array)))))\n", "  (if (null?\
    \ array)\n      '()\n      (let ([odd? (odd? (+ (car array) (last array)))])\n\
    \        (let ([a (sort array <)])\n          (if odd?\n              a\n    \
    \          (reverse a))))))\n", "  (cond\n    [(empty? array) (values '())]\n\
    \    [(empty? (rest array)) (values array)]\n    [else\n     (let*\n         ([f\
    \ (car array)]\n          [l (last array)]\n          [sum (+ f l)]\n        \
    \  [arr (rest (butlast array))])\n       (cond\n         [(odd? sum) (values (append\
    \ (sort arr <) (list f) (list l)))]\n         [else (values (append (sort arr\
    \ >) (list f) (list l)))]))]))", "  (cond\n    [(empty? array) '()]\n    [(= (length\
    \ array) 1) array]\n    [else\n     (sort (lambda (a b)\n             (if (odd?\
    \ (+ (first array) (last array)))\n                 (< a b)\n                \
    \ (> a b)))\n           array)]))\n</code>\nAny feedback will be appreciated.\n\
    \n\nA:\n\nI think the most important thing that you can do to improve your code\
    \ is to make it more readable. Instead of creating a long, complicated <code>cond</code>\
    \ expression, try to break it up into individual helper functions, where you can\
    \ assign meaningful names to the different parts. The whole <code>cond</code>\
    \ expression should be a simple sequence of calls to those functions, that are\
    \ easy to read and understand.\nFor example, I'd rewrite it like this:\n<code>(define\
    \ (sort-array array)\n  (cond\n    [(empty? array) empty]\n    [(singleton? array)\
    \ array]\n    [else\n     (sort-by-sum array (odd? (+ (first array) (last array))))]))\n",
  "  (if (empty? array)\n      array\n      (if (even? (+ (car array) (last array)))\n\
    \          (sort > array)\n          (sort < array))))\n", "  (let loop ([array\
    \ array] [acc '()])\n    (cond\n      [(empty? array) (reverse acc)]\n      [(empty?\
    \ (rest array)) (reverse (cons (first array) acc))]\n      [(= (add1 (modulo (add1\
    \ (vector-ref array 0)) 2)) (add1 (modulo (add1 (vector-ref array (sub1 (vector-length\
    \ array)))) 2))) (loop (rest array) (cons (first array) acc))]\n      [else (loop\
    \ (rest array) (cons (first array) acc))])))", "  (let ([sum (add (array-ref array\
    \ 0) (array-ref array (sub1 (array-length array))))])\n    (if (odd? sum)\n  \
    \      (sort array <)\n        (sort array >))))\n", "  (cond [(empty? array)\
    \ array]\n        [(empty? (rest array)) array]\n        [else\n         (cond\
    \ [(even? (+ (first array) (last array)))\n                (sort > array)]\n \
    \              [else\n                (sort < array)])]))\n```\n\n> \u601D\u8DEF\
    \uFF1A \u8FD9\u9053\u9898\u57FA\u672C\u662F\u8981\u6C42\u6C42\u548C\uFF0C \u5224\
    \u65AD\u5947\u5076\uFF0C \u5224\u65AD\u5934\u5C3E\uFF0C \u6392\u5E8F\u7B49\u57FA\
    \u672C\u8BED\u6CD5\u5E94\u7528\n\n```clojure", "  (let* ([len (length array)]\n\
    \         [index-0 0]\n         [index-l (sub1 len)]\n         [sum (add (list-ref\
    \ array index-0) (list-ref array index-l))])\n    (if (odd? sum)\n        (sort\
    \ array <)\n        (sort array >))))\n", "  (if (empty? array)\n      empty\n\
    \      (if (odd? (+ (first array) (last array)))\n          (sort array <)\n \
    \         (sort array >))))\n```\n\n### Solution 2\n\n```racket\n#lang racket\n",
  "  (define sum (for/sum ([num array]) num))\n  (define sorted\n    (sort array\n\
    \          (if (even? sum) > <)))\n  sorted)\n", "  (cond [(null? array) '()]\n\
    \        [(= (length array) 1) array]\n        [else\n         (sort_array-helper\
    \ (sort (sort_array (take array 1)) <)\n                            (reverse (sort\
    \ (sort_array (drop array 1)) <)))]))\n", "  (cond [(null? array) '()]\n     \
    \   [(equal? (modulo (+ (first array) (last array)) 2) 0) (reverse array)]\n \
    \       [else (sort < array)]))\n", "  (if (empty? array)\n      '()\n      (let*\
    \ ([sum_first_last (+ (first array) (last array))]\n             [sorted (sort\
    \ array (\u03BB (a b) (< a b)))]\n             [rev (sort sorted (\u03BB (a b)\
    \ (> a b)))]\n             [front (take array (quotient (length array) 2))]\n\
    \             [rear (reverse (drop array (quotient (length array) 2)))])\n   \
    \     (if (even? sum_first_last)\n            (append front rear)\n          \
    \  (append rear front)))))\n", "  (define (is-even? n) (= (remainder n 2) 0))\n\
    \  (define (sum-first-last array)\n    (define (sum-i-j i j) (+ (list-ref array\
    \ i) (list-ref array j)))\n    (sum-i-j 0 (- (length array) 1)))\n  (define (sort-ascending\
    \ array)\n    (sort array <))\n  (define (sort-descending array)\n    (sort array\
    \ >))\n  (cond\n    [(empty? array) empty]\n    [(is-even? (sum-first-last array))\
    \ (sort-descending array)]\n    [else (sort-ascending array)]))", "  (if (empty?\
    \ array)\n      array\n      (if (even? (+ (first array) (last array)))\n    \
    \      (sort array >)\n          (sort array <))))", "  (if (empty? array)\n \
    \     array\n      (cond ((<= (add1 (car array)) (length array))\n           \
    \  (cons (sort_array (sub1 (car array)))\n                   (sort_array (sub1\
    \ (cdr array)))))\n            (else (sort_array (sub1 (car array)))))))", " \
    \ (let ((smaller-than-first-index? (lambda (x)\n                             \
    \        (< x (vector-ref array 0))))\n        (greater-than-first-index? (lambda\
    \ (x)\n                                     (> x (vector-ref array 0)))))\n  \
    \  (if (even? (+ (vector-ref array 0) (vector-ref array (- (vector-length array)\
    \ 1))))\n        (append (vector-map smaller-than-first-index? array)\n      \
    \          (vector-map greater-than-first-index? array))\n        (append (vector-map\
    \ greater-than-first-index? array)\n                (vector-map smaller-than-first-index?\
    \ array)))))\n```\n\nBut we can't be sure of this yet. Let's try some tests.\n\
    \n```racket", "  (define (sorti array)\n    (if (empty? array)\n        empty\n\
    \        (cons (first array) (sorti (sort-rest array)))))\n  (define (sort-rest\
    \ array)\n    (if (empty? array)\n        empty\n        (sorti (filter (\u03BB\
    \ (x) (eq? x (second array))) (rest array)))))\n  (sorti array))\n", "  (cond\
    \ [(empty? array) empty]\n        [(even? (array-sum array)) (sort array >)]\n\
    \        [else (sort array <)]))\n", "  (cond [(empty? array) '()]\n        [(null?\
    \ (cdr array)) array]\n        [(even? (+ (car array) (car (last array))))\n \
    \        (sort > array)]\n        [else (sort < array)]))\n", "  (sort array\n\
    \        (\u03BB (x y)\n          (let* ([s (add1 (+ (first array) (last array)))]\n\
    \                 [cx (cond [(= 0 (modulo x 2)) x]\n                         \
    \  [else (sub1 x)])]\n                 [cy (cond [(= 0 (modulo y 2)) y]\n    \
    \                       [else (sub1 y)])])\n            (if (even? s)\n      \
    \          (or (> cx cy) (= cx cy))\n                (or (< cx cy) (= cx cy)))))))\n\
    ```\n* Examples:\n```racket", "  (define (even? x) (= (remainder x 2) 0))\n  (define\
    \ (sort-ascending a b)\n    (cond [(< a b) #t]\n          [(> a b) #f]\n     \
    \     [else #f]))\n  (define (sort-descending a b)\n    (cond [(> a b) #t]\n \
    \         [(< a b) #f]\n          [else #f]))\n  (define (sort-asc-or-desc lst)\n\
    \    (cond [(empty? lst) empty]\n          [(= (length lst) 1) lst]\n        \
    \  [(even? (sum (first lst) (last lst))) (sort sort-descending lst)]\n       \
    \   [else (sort sort-ascending lst)]))\n  (sort-asc-or-desc array))\n", "  (match\
    \ array\n    [(list) array]\n    [(list _) array]\n    [(list _ _) (if (odd? (+\
    \ (car array) (last array)))\n                   (sort array <)\n            \
    \       (sort array >))]\n    [_ (if (odd? (+ (car array) (last array)))\n   \
    \     (sort array <)\n        (sort array >))]))\n", "  (let loop ((array array)\
    \ (result (list)))\n    (cond ((null? array) (reverse result))\n          ((=\
    \ (remainder (+ (car array) (cadr array)) 2) 0) (loop (cdr array) (cons (car array)\
    \ result)))\n          (else (loop (cdr array) (cons (car array) result))))))\n",
  "  (define (odd? x)\n    (= (remainder x 2) 1))\n  (define (sort-even array)\n \
    \   (sort array >))\n  (define (sort-odd array)\n    (sort array <))\n  (if (=\
    \ (length array) 0)\n      array\n      (if (odd? (+ (array-ref array 0) (array-ref\
    \ array (- (length array) 1))))\n          (sort-odd array)\n          (sort-even\
    \ array))))\n", "  (cond [(empty? array) '()]\n        [(= (sum-even-odd? array)\
    \ 0) (sort array >)]\n        [(= (sum-even-odd? array) 1) (sort array <)]))\n",
  "  (sort array (lambda (x y)\n                (if (= (modulo (+ (vector-ref array\
    \ 0) (vector-ref array (vector-length array))) 2) 0)\n                    (> x\
    \ y)\n                    (< x y)))))\n", "  (match array\n    ['() '()]\n   \
    \ [array\n     (let ([sorted-list (list-sort < array)])\n       (match (add1 (modulo\
    \ (add1 (length array)) 2))\n         [0 (reverse sorted-list)]\n         [_ sorted-list]))]))\n",
  "  (cond [(null? array) '()]\n        [(even? (add1 (length array))) (list-sort\
    \ < array)]\n        [else (list-sort > array)]))", "  (cond\n    [(empty? array)\
    \ array]\n    [(even? (add1 (last array)))\n     (reverse array)]\n    [else\n\
    \     (sort array <)]))\n", "  (sort\n   array\n   (lambda (a b)\n     (and\n\
    \      (let* ((array-length (length array))\n             (sum-index (modulo (+\
    \ 0 (sub1 array-length)) 2)))\n        (cond\n          ((= sum-index 0)\n   \
    \        (and (> a b)) )\n          ((= sum-index 1)\n           (and (< a b))\
    \ ))) ))) )\n", "  (sort (lambda (x y)\n          (if (and (even? (+ (first array)\
    \ (last array)))\n                   (< x y))\n              #t\n            \
    \  (and (odd? (+ (first array) (last array)))\n                   (> x y))))\n\
    \        array))\n", "  (cond\n    [(empty? array) array]\n    [(even? (add1 (length\
    \ array))) (reverse array)]\n    [else array]))\n", "  (if (= (length array) 0)\n\
    \      array\n      (if (= (length array) 1)\n          array\n          (if (odd?\
    \ (+ (array-ref array 0) (array-ref array (- (length array) 1))))\n          \
    \    (sort (array->list array) <)\n              (sort (array->list array) >)))))\n",
  "  (define (get-sum a b)\n    (+ a b))\n  (define (is-sorted? arr)\n    (and (not\
    \ (null? arr))\n         (let loop ([arr (cdr arr)])\n           (or (null? arr)\n\
    \               (and (<= (car arr) (cadr arr))\n                    (loop (cdr\
    \ arr)))))))\n  (define (bubble-sort arr)\n    (define (swap lst)\n      (cond\
    \ [(null? lst) null]\n            [(null? (cdr lst)) lst]\n            [(< (cadr\
    \ lst) (car lst)) (cons (cadr lst) (cons (car lst) (cddr lst)))]\n           \
    \ [else (cons (car lst) (swap (cdr lst)))]))\n    (cond [(is-sorted? arr) arr]\n\
    \          [else (bubble-sort (swap arr))]))\n  (define (quick-sort arr)\n   \
    \ (define (partition xs pivot-index)\n      (define (swap xs i j)\n        (define\
    \ (swap-help xs a b)\n          (define (append x y)\n            (if (null? x)\
    \ y\n                (cons (car x) (append (cdr x) y))))\n          (append (append\
    \ (take xs a) (list (list-ref xs b)))\n                  (append (list (list-ref\
    \ xs a)) (drop xs (+ b 1)))))\n        (swap-help xs i j))\n      (define (partition-help\
    \ xs pivot-index result-list)\n        (cond [(null? xs) result-list]\n      \
    \        [(< (car xs) (list-ref xs pivot-index))\n               (partition-help\
    \ (cdr xs) pivot-index (append result-list (list (car xs))))]\n              [else\
    \ (partition-help (cdr xs) pivot-index (append result-list (list (list-ref xs\
    \ pivot-index))))]))\n      (define (take-drop xs n)\n        (if (< n 1) (values\
    \ null xs)\n            (", "  (if (= (length array) 0)\n      array\n      (if\
    \ (= (length array) 1)\n          array\n          (if (zero? (remainder (+ (first\
    \ array) (last array)) 2))\n              (reverse array)\n              (sort\
    \ < array)))))\n", "  (if (even? (add1 (length array)))\n      (sort array >)\n\
    \      (sort array <)))", "  (cond [(empty? array) empty]\n        [(empty? (rest\
    \ array)) array]\n        [(if (odd? (+ (car array) (last array))) (odd? (car\
    \ array)) (even? (car array)))\n         (cons (car array) (sort_array (rest array)))]\n\
    \        [else\n         (append (sort_array (cdr array)) (list (car array)))]))\n",
  "  (cond\n    [(empty? array) empty]\n    [(= (length array) 1) array]\n    [else\n\
    \     (let* ([mid (quotient (length array) 2)]\n            [left (take array\
    \ mid)]\n            [right (drop array mid)]\n            [sum (add (car array)\
    \ (car (reverse array)))])\n       (if (odd? sum)\n           (append (sort_array\
    \ left) (sort_array right))\n           (append (reverse (sort_array left)) (reverse\
    \ (sort_array right)))))]))\n```\n\n### Best practice:\n```\n#lang racket\n",
  "  (cond\n    [(empty? array) array]\n    [(= (length array) 1) array]\n    [else\n\
    \     (let ([sorted-array (sort (lambda (a b)\n                              \
    \   (if (even? (+ (first array) (last array)))\n                             \
    \        (> a b)\n                                     (< a b)))\n           \
    \                    array)])\n       sorted-array)]))\n```\n\n```ruby\n#lang\
    \ racket\n", "  (define (odd? index)\n    (odd? index))\n  (define (is-even? index)\n\
    \    (even? index))\n  (define (sum-of-first-and-last-value array)\n    (+ (array-ref\
    \ array 0) (array-ref array (- (array-length array) 1))))\n  (define (sort-odd\
    \ array)\n    (sort array <))\n  (define (sort-even array)\n    (sort array >))\n\
    \  (cond ((null? array) '())\n        ((array-length array) 1)\n        ((is-even?\
    \ (sum-of-first-and-last-value array)) (sort-even array))\n        (else (sort-odd\
    \ array))))\n", "  (sort array <))\n", "  (if (empty? array)\n      '()\n    \
    \  (define len (length array))\n      (define sum (apply + (take array len)))\n\
    \      (if (odd? sum)\n          (sort array <)\n          (sort array >))))\n\
    ```\n\n#### JavaScript\n\n```js\n// Given an array of non-negative integers, return\
    \ a copy of the given array after sorting,\n// you will sort the given array in\
    \ ascending order if the sum( first index value, last index value) is odd,\n//\
    \ or sort it in descending order if the sum( first index value, last index value)\
    \ is even.\n// Note:\n// * don't change the given array.\n// Examples:\n// * sort_array([])\
    \ => []\n// * sort_array([5]) => [5]\n// * sort_array([2, 4, 3, 0, 1, 5]) => [0,\
    \ 1, 2, 3, 4, 5]\n// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1,\
    \ 0]\n\nfunction sort_array(array) {\n  if (array.length == 0) {\n    return [];\n\
    \  }\n\n  var len = array.length;\n  var sum = array.slice(0, len).reduce((a,\
    \ b) => a + b);\n  if (sum % 2 == 0) {\n    return array.sort((a, b) => b - a);\n\
    \  } else {\n    return array.sort((a, b) => a - b);\n  }\n}\n```\n\n#### Ruby\n\
    \n```ruby\n# Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n# you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n# or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n# Note:\n#\
    \ * don't change the given array.\n# Examples:\n# * sort_array([]) => []\n# *\
    \ sort_array([5]) => [5]\n# * sort_array([2, 4, 3, 0, 1, 5]) => [0,", "  (if (zero?\
    \ (length array))\n      array\n      (sort_array_unsorted array (length array)\n\
    \                           (length array)\n                           (if (odd?\
    \ (+ (first array) (last array)))\n                               ascending\n\
    \                               descending))))\n", "  (if (empty? array) '()\n\
    \      (cond [(= (modulo (+ (car array) (last array)) 2) 0)\n             (reverse\
    \ array)]\n            [else\n             (sort array (\u03BB (a b) (&lt; a b)))])))\n\
    </code>\nAm I on the right track?\n\n\nA:\n\nIt seems like you are on the right\
    \ track. The only thing that I noticed was that you were mutating the variable\
    \ <code>array</code> in the first part of the <code>cond</code>. This can be avoided\
    \ by using <code>reverse</code> and <code>sort</code> with a key function. The\
    \ key function will be a lambda that returns a boolean (true) or an integer (false).\
    \ So,\n<code>(define (sort_array array)\n  (if (empty? array) '()\n      (if (zero?\
    \ (modulo (+ (car array) (last array)) 2))\n          (sort array (\u03BB (a b)\
    \ (&gt; a b)))\n          (reverse (sort array (\u03BB (a b) (&lt; a b)))))))\n\
    </code>\n", "  (cond\n    [(empty? array) '()]\n    [(null? (cdr array)) array]\n\
    \    [else\n     (let ([s (+ (car array) (car (last array)))])\n       (cond\n\
    \         [(odd? s) (sort array <)]\n         [else (sort array >)]))]))", " \
    \ (if (empty? array)\n      empty\n      (if (= (length array) 1)\n          array\n\
    \          (if (even? (+ (first array) (last array)))\n              (quicksort\
    \ (reverse array))\n              (quicksort array)))))\n```", "  (let ([odd?\
    \ (odd? (+ (vector-ref array 0) (vector-ref array (- (vector-length array) 1))))])\n\
    \    (sort array (if odd? < >))))\n", "  (if (empty? array)\n      array\n   \
    \   (if (= (list-length array) 1)\n          array\n          (if (odd? (+ (car\
    \ array) (last array)))\n              (sort array <)\n              (sort array\
    \ >)))))\n```\n\n### Kata7\n[Kata7](https://www.codewars.com/kata/57eae65a4321032ce000002d)\n\
    \n```racket\n#lang racket\n", "  (cond\n    [(= (length array) 0) array]\n   \
    \ [(= (length array) 1) array]\n    [(odd? (+ (first array) (last array)))\n \
    \    (list->vector (sort array (\u03BB (x y) (< x y))))]\n    [else\n     (list->vector\
    \ (sort array (\u03BB (x y) (> x y))))]))\n", "  (if (zero? (remainder (+ (first\
    \ array) (last array)) 2))\n      (sort array <)\n      (sort array >)))\n```\n\
    \n## \u4F4E\u843D\u7684\u79D1\u6280\n\n> \u4E00\u4E2A\u540D\u53EB\u201CLow Tech\
    \ Magazine\u201D\u7684\u7F51\u7AD9\u5F00\u59CB\u505A\u6280\u672F\u4E0A\u7684\u5B9E\
    \u9A8C\uFF0C\u5E0C\u671B\u80FD\u591F\u521B\u9020\u4E00\u4E2A\u80FD\u8FD0\u884C\
    \u4E45\u4E00\u70B9\u7684\u7F51\u7AD9\uFF0C\u4EE5\u53CA\u63D0\u4F9B\u4E00\u4E2A\
    \u66F4\u771F\u5B9E\u7684\u7F51\u7EDC\u7ECF\u9A8C\u3002\u4F5C\u4E3A\u6280\u672F\
    \u7684\u4E00\u90E8\u5206\uFF0C\u4ED6\u4EEC\u51B3\u5B9A\u7528 HTML \u521B\u5EFA\
    \u4E00\u4E2A\u7F51\u7AD9\uFF0C\u800C\u4E0D\u662F WordPress \u4E4B\u7C7B\u7684\u5DE5\
    \u5177\u3002\u4F46\u662F\uFF0C\u4ED6\u4EEC\u540E\u6765\u53D1\u73B0\uFF0C\u4F7F\
    \u7528 HTML \u521B\u5EFA\u4E00\u4E2A\u7F51\u7AD9\u662F\u4EF6\u56F0\u96BE\u7684\
    \u4E8B\u3002\u6BCF\u6B21\u4ED6\u4EEC\u8981\u4E3A\u7F51\u7AD9\u65B0\u589E\u4E00\
    \u4E2A\u9875\u9762\uFF0C\u4ED6\u4EEC\u90FD\u8981\u590D\u5236\u5E76\u7C98\u8D34\
    \u4E00\u4E2A\u57FA\u672C\u7684 HTML \u6846\u67B6\u3002\n>\n> \u8BF7\u4F60\u521B\
    \u5EFA\u4E00\u4E2A\u51FD\u6570\uFF0C\u4E3A\u4ED6\u4EEC\u751F\u6210\u8FD9\u4E2A\
    \ HTML \u6846\u67B6\u3002\u9664\u4E86\u63D0\u4F9B\u4E00\u4E2A\u51FD\u6570\u548C\
    \u4E00\u4E2A URL \u4E4B\u5916\uFF0C\u4F60\u5E94\u8BE5\u4EC0\u4E48\u90FD\u4E0D\u505A\
    \u3002\u4F60\u7684\u51FD\u6570\u5E94\u8BE5\u4EA7\u751F\u4E00\u4E2A\u9002\u5F53\
    \u7684 HTML \u6587\u6863\uFF0C\u5B83\u7684\u9875\u7709\u5E94\u8BE5\u5982\u4E0B\
    \u6240\u793A\uFF1A\n>\n> ```", '  (sort (lambda (a b) (if (odd? (+ (car array)
    (cadr (reverse array)))) (< a b) (> a b))) array))', "  (cond\n    [(empty? array)\
    \ '()]\n    [(empty? (rest array)) array]\n    [else\n     (let ([first (first\
    \ array)]\n           [last (last array)])\n       (if (even? (+ first last))\n\
    \           (sort (rest array) >)\n           (sort (rest array) <)))]))\n", " \
    \ (let ([sum (for/sum ([i (in-range (length array))]) (+ (vector-ref array i)\
    \ i))])\n    (if (odd? sum)\n        (array-sort array <)\n        (array-sort\
    \ array >))))\n", "  (if (empty? array)\n      '()\n      (if (< (length array)\
    \ 2)\n          array\n          (if (odd? (+ (first array) (last array)))\n \
    \             (let ([sorted-array (sort array <)])\n                (cons (first\
    \ sorted-array) (cons (last sorted-array) (butlast (butfirst sorted-array)))))\n\
    \              (let ([sorted-array (sort array >)])\n                (cons (first\
    \ sorted-array) (cons (last sorted-array) (butlast (butfirst sorted-array)))))))))",
  "  (let* ([sum (apply + array)]\n         [n (length array)])\n    (if (= 0 (% sum\
    \ n))\n        (sort array <)\n        (sort array >))))", "  (if (null? array)\n\
    \      array\n      (sort array <)))", "  (let ((first (car array))\n        (last\
    \ (car (reverse array))))\n    (cond ((= (add1 (remainder (+ first last) 2)) 1)\n\
    \           (sort array <))\n          (else\n           (sort array >)))))",
  "  (if (null? array)\n      '()\n      (let* ([first (car array)]\n            \
    \ [last (last array)]\n             [first_last (list first last)])\n        (if\
    \ (odd? (apply + first_last))\n            (sort array <)\n            (sort array\
    \ >)))))\n```\n\n```racket\n#lang racket\n", "  (if (even? (add1 (car array)))\
    \ (sort array <) (sort array >)))\n```\n\n> https://www.codewars.com/kata/sorting-on-planet-twisted-3-7/train/racket\n\
    \n```racket\n#lang racket\n", "  (if (= 0 (length array))\n      '()\n      (if\
    \ (= 1 (length array))\n          array\n          (let ((first-value (vector-ref\
    \ array 0))\n                (last-value (vector-ref array (- (length array) 1))))\n\
    \            (if (odd? (+ first-value last-value))\n                (ascending-sort-array\
    \ array)\n                (descending-sort-array array))))))\n", "  (define (swap-two-elements\
    \ arr n m)\n    (let ([tmp (vector-ref arr n)])\n      (vector-set! arr n (vector-ref\
    \ arr m))\n      (vector-set! arr m tmp)))\n  (define (sort-sub-array arr n)\n\
    \    (let loop ([i 0])\n      (when (< i n)\n        (if (odd? (+ (vector-ref\
    \ arr i) (vector-ref arr (- n 1 i))))\n            (swap-two-elements arr i (-\
    \ n 1 i))\n            #f)\n        (loop (+ i 1)))))\n  (sort-sub-array array\
    \ (vector-length array))\n  array)\n", "  (let ([n (length array)])\n    (if (odd?\
    \ (+ (array-ref array 0) (array-ref array (- n 1))))\n        (sort array <)\n\
    \        (sort array >))))", "  (cond\n    [(empty? array) '()]\n    [(= (length\
    \ array) 1) array]\n    [else\n     (begin\n       (define (partition array pivot-pos)\n\
    \         (define pivot (list-ref array pivot-pos))\n         (define (collect-smaller-elements\
    \ array pivot-pos left-pos)\n           (cond\n             [(= (length array)\
    \ left-pos)\n              (list (reverse array) pivot-pos)]\n             [(<=\
    \ (list-ref array left-pos) pivot)\n              (collect-smaller-elements array\
    \ pivot-pos (+ left-pos 1))]\n             [else\n              (collect-smaller-elements\
    \ (append (list (list-ref array left-pos)) (remove (list-ref array left-pos) array))\
    \ pivot-pos (+ left-pos 1))]))\n         (define (collect-larger-elements array\
    \ pivot-pos right-pos)\n           (cond\n             [(= (- (length array) 1)\
    \ right-pos)\n              (list (reverse array) (- right-pos 1))]\n        \
    \     [(>= (list-ref array right-pos) pivot)\n              (collect-larger-elements\
    \ array pivot-pos (- right-pos 1))]\n             [else\n              (collect-larger-elements\
    \ (append (list (list-ref array right-pos)) (remove (list-ref array right-pos)\
    \ array)) pivot-pos (- right-pos 1))]))\n         (define (swap array pivot-pos\
    \ left-pos)\n           (define left-element (list-ref array left-pos))\n    \
    \       (define (replace-at array index value)\n             (append (sublist\
    \ array 0 index) (list value) (sublist array (+ index 1) (length array))))\n \
    \          (define (swap-and-collect array pivot-pos left-pos right-pos)\n   \
    \          (append (reverse (sublist array 0 left-pos)) (list (list-ref array\
    \ right-pos)) (reverse (sublist array left-pos right-pos)) (list left-element)\
    \ (sublist array (+ right-pos 1) (length array))))\n           (if (= left-pos\
    \ pivot-pos)\n               (swap-and-collect array pivot", "  (if (empty? array)\n\
    \      '()\n      (let ((first (first array))\n            (last (last array)))\n\
    \        (quicksort array\n                   (if (even? (+ first last))\n   \
    \                    >\n                       <)))))\n", "  (cond\n    [(or (empty?\
    \ array) (= (length array) 1)) array]\n    [(even? (+ (first array) (last array)))\n\
    \     (list-sort array >)]\n    [else\n     (list-sort array <)]))\n", "  (if\
    \ (null? array)\n      array\n      (if (= (modulo (+ (car array) (last array))\
    \ 2) 0)\n          (sort array <)\n          (sort array >))))\n```\n\n## Test\
    \ Cases\n\n```racket", "  (define (check-sum a b)\n    (if (odd? (+ a b))\n  \
    \      #t\n        #f))\n  (define (sort-array-aux array a b)\n    (if (equal?\
    \ a 0)\n        array\n        (sort-array-aux (if (check-sum (list-ref array\
    \ a) (list-ref array (- b 1)))\n                            (reverse (remove (list-ref\
    \ array a) (append (list (list-ref array a)) (sort-array-aux (remove (list-ref\
    \ array (- b 1)) array) (- a 1) (- b 2)))))\n                            (reverse\
    \ (remove (list-ref array (- b 1)) (append (list (list-ref array (- b 1))) (sort-array-aux\
    \ (remove (list-ref array a) array) (- a 1) (- b 2)))))) (- a 1) (- b 1)))\n \
    \ (if (empty? array)\n      array\n      (sort-array-aux array (- (length array)\
    \ 1) (length array))))\n", "  (cond ((empty? array) '())\n        ((= (length\
    \ array) 1) array)\n        ((even? (+ (first array) (last array)))\n        \
    \ (sort >= array))\n        (else (sort <= array))))\n", "  (define (odd? n) (=\
    \ (remainder n 2) 1))\n  (define (first a) (array-ref a 0))\n  (define (last a)\
    \ (array-ref a (- (array-length a) 1)))\n  (if (null? array) array\n      (if\
    \ (odd? (+ (first array) (last array))) (sort array <) (sort array >))))\n", " \
    \ (let ([len (array-length array)])\n    (if (odd? (+ (array-ref array 0) (array-ref\
    \ array (- len 1))))\n        (sort array <)\n        (sort array >))))\n```\n\
    \n```\n#lang racket\n", "  (sort (if (odd? (+ (car array) (cadr (reverse array))))\
    \ array (reverse array))))\n", "  (cond\n    [(empty? array) array]\n    [(> (count\
    \ array) 1)\n     (sort array (\u03BB (a b)\n                   (define sum (+\
    \ (first array) (last array)))\n                   (if (odd? sum) (< a b) (> a\
    \ b))))]\n    [else array]))", "  (if (= (length array) 0)\n      array\n    \
    \  (let ([first (first array)]\n            [last (last array)])\n        (if\
    \ (odd? (+ first last))\n            (sort array <)\n            (sort array >)))))\n",
  "  (let ([len (vector-length array)])\n    (if (odd? (+ (vector-ref array 0) (vector-ref\
    \ array (- len 1))))\n        (sort array <)\n        (sort array >))))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
