name: HumanEval_116_sort_array
language: rkt
prompt: "#lang racket\n\n;; In this Kata, you have to sort an array of non-negative\
  \ integers according to\n;; number of ones in their binary representation in ascending\
  \ order.\n;; For similar number of ones, sort based on decimal value.\n;; It must\
  \ be implemented like this:\n;; >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4,\
  \ 5]\n;; >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n;; >>> sort_array([1,\
  \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n(define (sort_array arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list 1 5 2 3 4)) (list 1 2 4 3 5))\n    (check-equal?\
  \ (candidate (list -2 -3 -4 -5 -6)) (list -4 -2 -6 -5 -3))\n    (check-equal? (candidate\
  \ (list 1 0 2 3 4)) (list 0 1 2 4 3))\n    (check-equal? (candidate (list )) (list\
  \ ))\n    (check-equal? (candidate (list 2 5 77 4 5 3 5 7 2 3 4)) (list 2 2 4 4\
  \ 3 3 5 5 5 7 77))\n    (check-equal? (candidate (list 3 6 44 12 32 5)) (list 32\
  \ 3 5 6 12 44))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16\
  \ 32))\n    (check-equal? (candidate (list 2 4 8 16 32)) (list 2 4 8 16 32))\n))\n\
  \n(test-humaneval)"
completions: ["  (define (bin-repr num)\n    (if (zero? num)\n        \"0\"\n    \
    \    (let* ([rev-bin (reverse (bin-repr (quotient num 2)))])\n          (if (zero?\
    \ (remainder num 2))\n              rev-bin\n              (cons #\\1 rev-bin)))))\n\
    \  (let* ([bin-arr (map bin-repr arr)]\n         [lengths (map string-length bin-arr)]\n\
    \         [ones (map (lambda (str) (count #\\1 str)) bin-arr)]\n         [ordering\
    \ (sort-on (lambda (x y) (string<? (car x) (car y)))\n                       \
    \     (map list bin-arr arr))])\n    (map (lambda (x) (cadr x)) ordering)))\n\
    ```\n### Solution: Ruby\n```ruby\ndef sort_array(arr)\n  l = arr.map { |e| e.to_s(2).count(\"\
    1\") }\n  l.sort!\n  arr.sort_by { |e| [l.index(e.to_s(2).count(\"1\")), e] }\n\
    end\n```\n### Solution: Perl\n```perl\nsub sort_array {\n  my @result =\n  map\
    \  { $_->[1] }\n  sort { $a->[0] cmp $b->[0] || $a->[1] <=> $b->[1] }\n  map \
    \ { [ sprintf(\"%0*d\", length, unpack(\"B*\", pack(\"N\", $_))), $_ ] }\n  @_;\n\
    \  return @result;\n}\n```\n### Solution: Python\n```python\ndef sort_array(arr):\n\
    \    return sorted(arr, key=lambda x: '{0:b}'.format(x).count('1'))\n```\n###\
    \ Solution: Js\n```js\nfunction sort_array(arr) {\n    return arr.sort(function(a,\
    \ b) {\n        var counta = a.toString(2).split('1').length-1;\n        var countb\
    \ = b.toString(2).split('1').length-1;\n", "  (sort\n   (lambda (a b)\n     (let\
    \ ([sa (decimal-to-binary a)]\n           [sb (decimal-to-binary b)])\n      \
    \ (if (equal? (count-ones sa) (count-ones sb))\n           (< a b)\n         \
    \  (< (count-ones sa) (count-ones sb)))))\n   arr))\n", "  (sort (lambda (x y)\n\
    \          (let ([bx (dec->bin x)]\n                [by (dec->bin y)])\n     \
    \       (or (and (< (len bx) (len by)) (not (= x y)))\n                (and (not\
    \ (bin-eq? bx by)) (< bx by))\n                (< x y))))\n        arr))\n", " \
    \ (sort arr\n        (\u03BB (x y) (string<? (number->string x 2) (number->string\
    \ y 2)))))\n", "  (sort arr (< (count-bits (decode-float (first)))\n         \
    \      (count-bits (decode-float (second))))))\n", "  (sort arr < compare-binary-strings))\n",
  "  (sort\n   (sort arr #:key (curry bit-count <))\n   #:key (curry bit-count >)))\n",
  "  (define (ones-dec x)\n    (cons (string-count (integer->binary x) #\\1) x))\n\
    \  (sort (map ones-dec arr) #:key car #:lt <))\n```\n\n```racket\n#lang racket\n",
  "  (define (sort-by-bin-num lst)\n    (sort lst\n          <\n          (\u03BB\
    \ (x y) (and (< (truncate (log x 2)) (truncate (log y 2)))\n                 \
    \        (< x y)))))\n  (cond [(empty? arr) '()]\n        [else (sort-by-bin-num\
    \ arr)]))\n```\n\n```scheme\n#lang racket\n", "  (define (sort-array-helper arr)\n\
    \    (cond\n      [(null? arr) '()]\n      [(null? (cdr arr)) arr]\n      [else\n\
    \       (let* ([i (car arr)]\n              [j (cadr arr)]\n              [compare-result\
    \ (if (= (count-ones i) (count-ones j))\n                                  (<\
    \ i j)\n                                  (< (count-ones i) (count-ones j)))]\n\
    \              [last-arr (sort-array-helper (cdr arr))])\n         (if compare-result\n\
    \             (cons i (cons j last-arr))\n             (cons j (cons i last-arr))))]))\n\
    \  (sort-array-helper arr))\n", "  (sort arr (lambda (x y) (cond [(< (dec2bin\
    \ x) (dec2bin y)) #t]\n                                [(> (dec2bin x) (dec2bin\
    \ y)) #f]\n                                [else (< x y)]))))\n", "  (sort (lambda\
    \ (a b)\n          (cond [(and (>= a 0) (>= b 0))\n                 (cond [(<\
    \ (count-ones a) (count-ones b)) #t]\n                       [(> (count-ones a)\
    \ (count-ones b)) #f]\n                       [else (< a b)])]\n             \
    \   [(>= a 0) #t]\n                [(>= b 0) #f]\n                [else (< a b)]))\n\
    \        arr))\n", "  (sort (\u03BB (a b)\n          (let ([a-ones (number->string\
    \ a 2)]\n                [b-ones (number->string b 2)])\n            (cond\n \
    \             [(< (length a-ones) (length b-ones)) #t]\n              [(> (length\
    \ a-ones) (length b-ones)) #f]\n              [(< a b) #t]\n              [(>\
    \ a b) #f]\n              [else #f])))\n        arr))", "  (sort arr\n       \
    \ <\n        (lambda (a b)\n          (let ([a-ones (get-number-of-ones a)]\n\
    \                [b-ones (get-number-of-ones b)])\n            (if (= a-ones b-ones)\n\
    \                (< a b)\n                (< a-ones b-ones))))))\n", "  (sort\
    \ (map\n         (\u03BB (x) (cons (bit-count x) x))\n         arr)\n        <\n\
    \        #:key (\u03BB (x) x)))\n", "  (for/sort ((x arr))\n    (cons x (string->number\
    \ (string-intersperse #\"0\" (number->string x 2)) 2))))\n", "  (sort (map (lambda\
    \ (x) (list x (integer->binary x))) arr)\n        (lambda (x y)\n          (if\
    \ (equal? (cadr x) (cadr y))\n              (< (car x) (car y))\n            \
    \  (string<? (cadr x) (cadr y))))))\n", "  (sort arr (\u03BB (a b)\n         \
    \      (or (< (count-ones a) (count-ones b))\n                   (and (= (count-ones\
    \ a) (count-ones b))\n                        (< a b))))))\n", "  (sort (lambda\
    \ (a b) (if (= (get_ones a) (get_ones b))\n                          (< a b)\n\
    \                          (< (get_ones a) (get_ones b))))\n        arr))\n",
  "  (sort arr (\u03BB (x y) (cond\n                       ((< (number->string x 2)\
    \ (number->string y 2)) #t)\n                       ((> (number->string x 2) (number->string\
    \ y 2)) #f)\n                       ((< x y) #t)\n                       ((> x\
    \ y) #f)\n                       (#t #f)))))", "  (sort (\u03BB (x y)\n      \
    \    (cond [(< (binary-ones x) (binary-ones y)) #t]\n                [(> (binary-ones\
    \ x) (binary-ones y)) #f]\n                [(< x y) #t]\n                [(> x\
    \ y) #f]\n                [else #f]))\n        arr))\n", "  (sort arr\n      \
    \  (lambda (a b)\n          (and (eq? (count-ones a) (count-ones b))\n       \
    \        (< a b)))))\n", "  (sort\n   (map (lambda (n) (list n (number->string\
    \ n 2))) arr)\n   (lambda (a b)\n     (cond\n       ((< (cadr a) (cadr b)) #t)\n\
    \       ((> (cadr a) (cadr b)) #f)\n       ((< (car a) (car b)) #t)\n       ((>\
    \ (car a) (car b)) #f)\n       (else #f)))))", "  (sort (\u03BB (x y)\n      \
    \    (< (remainder (bitwise-and x (bitwise-shift-left-logical 1\n            \
    \                                                  (exact-floor (log (bitwise-or\
    \ 1 x) 2)))))\n             (remainder (bitwise-and y (bitwise-shift-left-logical\
    \ 1\n                                                              (exact-floor\
    \ (log (bitwise-or 1 y) 2)))))\n             (or (= (remainder (bitwise-and x\
    \ (bitwise-shift-left-logical 1\n                                            \
    \                       (exact-floor (log (bitwise-or 1 x) 2)))))\n          \
    \           (remainder (bitwise-and y (bitwise-shift-left-logical 1\n        \
    \                                                           (exact-floor (log\
    \ (bitwise-or 1 y) 2)))))\n                 (not (equal? (remainder (bitwise-and\
    \ x (bitwise-shift-left-logical 1\n                                          \
    \                             (exact-floor (log (bitwise-or 1 x) 2)))))\n    \
    \                          (remainder (bitwise-and y (bitwise-shift-left-logical\
    \ 1\n                                                                       (exact-floor\
    \ (log (bitwise-or 1 y) 2)))))))\n                 (< x y))))\n        arr))\n\
    ```\n\n```python\n#lang python\n\n# In this Kata, you have to sort an array of\
    \ non-negative integers according to\n# number of ones in their binary representation\
    \ in ascending order.\n# For similar number of ones, sort based on decimal value.\n\
    # It must be implemented like this:\n# >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n# >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    # >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\ndef sort_array(arr):\n    return\
    \ sorted(arr, key=lambda e: (bin(e).count('1'), e))\n```\n\n```cpp\n// #", " \
    \ (sort arr (lambda (x y)\n              (let ([xones (length (filter (compose\
    \ not zero?) (integer->list 2 x)))])\n                (let ([yones (length (filter\
    \ (compose not zero?) (integer->list 2 y)))])\n                  (cond\n     \
    \               [(> xones yones) #t]\n                    [(< xones yones) #f]\n\
    \                    [else (> x y)]))))))\n", "  (sort (map (\u03BB (x) (list\
    \ (number->string x 2) x)) arr)\n        <\n        (\u03BB (x y)\n          (cond\
    \ [(equal? (car x) (car y))\n                 (string<? (car x) (car y))]\n  \
    \              [else\n                 (< (string-length (car x)) (string-length\
    \ (car y)))]))))\n```\n\n## 2. [Duck Duck Goose!](https://www.codewars.com/kata/duck-duck-goose/csharp)\n\
    ```#lang racket\n", "  (let ([f (string->number (lambda (x) (string-append \"\
    0b\" x)) 16)])\n    (sort (<=) (map f (map number->string arr)))))\n", "  (sort\
    \ arr\n        (\u03BB (a b)\n          (< (bit-count a) (bit-count b)))))\n",
  "  (sort (for/list ([n arr]) (list (list-ref arr n) (random) (integer->list n 2)))\
    \ < #:key list-ref))\n", "  (sort < (map (lambda (x)\n                 (list x\n\
    \                       (string-&gt;number\n                        (string-join\n\
    \                         (sort &gt; (map number-&gt;string (string-&gt;list (number-&gt;string\
    \ x))))))\n                       (string-&gt;number\n                       \
    \ (string-join\n                         (sort &gt; (map number-&gt;string (string-&gt;list\
    \ (number-&gt;string (binary-&gt;integer x)))))))))\n               arr)))\n</code>\n\
    In the tests, it works fine:\n<code>#lang racket\n", "  (define (binary x)\n \
    \   (for/fold ([accum '(1)]) ([n x])\n      (if (= n 0)\n          accum\n   \
    \       (cons (add1 (car accum)) (cdr accum)))))\n  (sort < arr))\n", "  (map\
    \ (lambda (x) (cadr x))\n       (sort (map (lambda (x) (cons (bytes->integer (string->bytes\
    \ (format \"~a\" x)) 2) x)) arr)\n             <)))\n", "  (define (ones n)\n\
    \    (foldr\n     (lambda (a b) (if (eq? a #\\1) (+ b 1) b))\n     0\n     (number->string\
    \ n 2)))\n  (define (sort-by-ones arr)\n    (sort arr < (\u03BB (x y)\n      \
    \            (cond\n                    [(eq? (ones x) (ones y)) (< x y)]\n  \
    \                  [else (< (ones x) (ones y))]))))\n  (define (sort-by-sign arr)\n\
    \    (sort arr < (\u03BB (x y) (and (not (negative? x)) (negative? y)))))\n  (sort-by-sign\
    \ (sort-by-ones arr)))\n", "  (define (ones n)\n    (cond [(= n 0) 0]\n      \
    \    [else (+ (modulo n 2) (ones (/ n 2)))]))\n  (sort arr <\n        (\u03BB\
    \ (a b)\n          (cond [(< (ones a) (ones b)) #t]\n                [(= (ones\
    \ a) (ones b)) (< a b)]\n                [else #f]))))\n```\n\n```racket\n#lang\
    \ racket\n", "  (sort (compose (curry reverse) (lambda (n) (decimal->integer n\
    \ 2))) arr))\n", "  (sort arr (\u03BB (a b) (string<? (number->string a 2) (number->string\
    \ b 2)))))\n", "  (sort arr < :key\n        (lambda (n)\n          (cons (integer-length\
    \ (integer->binary n)) n))))\n", "  (sort < arr))\n```\n\n```clojure", "  (sort\
    \ arr <=))\n", "  (sort arr (\u03BB (x y) (cond\n                         ((eq?\
    \ (length (member '1 (string->list (number->string x 2))))\n                 \
    \              (length (member '1 (string->list (number->string y 2)))))\n   \
    \                       (< x y))\n                         (else\n           \
    \               (< (length (member '1 (string->list (number->string x 2))))\n\
    \                             (length (member '1 (string->list (number->string\
    \ y 2))))))))))\n", "  (sort arr < :key count-ones))\n", "  (define (num-ones\
    \ n)\n    (define (calc ones n)\n      (if (zero? n)\n          ones\n       \
    \   (calc (+ ones (remainder n 2)) (quotient n 2))))\n    (calc 0 n))\n  (define\
    \ (arr-to-pairs arr)\n    (for/list ([n arr])\n      (cons n (num-ones n))))\n\
    \  (define (helper2 a b)\n    (define (helper1 a b)\n      (if (= (second a) (second\
    \ b))\n          (> (first a) (first b))\n          (> (second a) (second b))))\n\
    \    (if (> (second a) (second b))\n        a\n        b))\n  (define (reduce-pairs\
    \ arr)\n    (if (= (length arr) 1)\n        (first arr)\n        (reduce helper2\
    \ arr)))\n  (define (reduce-helper arr)\n    (if (= (length arr) 1)\n        (car\
    \ arr)\n        (reduce helper2 arr)))\n  (define (deconstruct p)\n    (cons (first\
    \ p) (map second p)))\n  (define (sort pairs)\n    (map first (sort (arr-to-pairs\
    \ pairs) <)))\n  (sort (map first (sort (arr-to-pairs arr) <))))\n", '  (sort
    arr #:key (lambda (x) (cons (bit-count x) x))))', "  (sort arr <))\n", "  (sort\
    \ arr number->< #:key (compose 1+ ones)))\n", "  (sort arr <\n        #:key\n\
    \        (lambda (x)\n          (bitwise-arithmetic-shift x -1))))\n", "  (define\
    \ (to-ones n)\n    (count (number->string n 2) #\\1))\n  (define (sort-pred (a\
    \ b)\n    (if (= (to-ones a) (to-ones b))\n        (< a b)\n        (< (to-ones\
    \ a) (to-ones b))))\n  (sort sort-pred arr))\n", "  (sort (map (lambda (n) (cons\
    \ (number->string n 2) n)) arr) < #:key car))\n```\n\nRun `racket test.rkt`:\n\
    \n```\n.F...\n\nfailure\nargument is not a list:\nx\n\n#<procedure:test-runner>\n\
    ```\n\nThe `test.rkt` file is in the root directory of the Kata, and the `test`\
    \ function\nis also in the same file. So this test should work, as both the `test`\
    \ function\nand the `sort_array` function are both in the same file. What's the\
    \ problem?\n\n## DrRacket Version\n\nI have the latest version of DrRacket installed,\
    \ and it looks like it is the\nsame version as the latest Racket version. So,\
    \ how can this be?\n\nIt is important to note that the file `test.rkt` is in the\
    \ top level directory\nof this Kata, and the `test` function is **not** in a module.\
    \ \n\nSo, to solve this, we need to make `test.rkt` a module.\n\n## The Fix\n\n\
    To make `test.rkt` a module, we need to add this to the top of the file:\n\n```racket\n\
    #lang racket", "  (sort (lambda (a b)\n          (or (< (count-ones a) (count-ones\
    \ b))\n              (and (= (count-ones a) (count-ones b))\n                \
    \   (< a b))))\n        arr))\n", "  (sort (for/list ([e (in-list arr)])\n   \
    \       (values (number->string e 2) e))\n        (lambda (e1 e2)\n          (if\
    \ (< (length (car e1)) (length (car e2)))\n              #t\n              (if\
    \ (= (length (car e1)) (length (car e2)))\n                  (< (cadr e1) (cadr\
    \ e2))\n                  #f)))))\n", "  (sort (for/list ([x arr])\n         \
    \ (values (number->string x 2) x))\n        (cut string<? <> <>)))\n", "  (sort\
    \ < (map (\u03BB (x) (list (ones-in-binary x) x)) arr)))\n", "  (sort arr\n  \
    \      (\u03BB (n1 n2)\n          (cond\n            [(= (int->bin n1) (int->bin\
    \ n2))\n             (< n1 n2)]\n            [else\n             (< (int->bin\
    \ n1) (int->bin n2))]))))", "  (sort (map (\u03BB (n)\n               (if (< n\
    \ 0) (- n) n))\n             arr)\n        (\u03BB (n1 n2)\n          (< (count-ones\
    \ n1) (count-ones n2) (\u03BB (b1 b2)\n                                      \
    \         (if b1 #t #f)))))\n  )\n", "  (sort (flatten (sort (map (lambda (x)\n\
    \                              (format \"~d~a\"\n                            \
    \          (integer->binary-string x)\n                                      x))\n\
    \                            arr)\n                        <)\n              \
    \  string<?)))\n", "  (sort (map (\u03BB (num)\n               (match-define (list\
    \ n1 n2) (integer->list num 2))\n               (list (list->string (reverse n1))\
    \ num))\n             arr)\n        <))\n", "  (list-sort (lambda (x y)\n    \
    \           (if (= (integer->digits 2 (bin-length x))\n                      (integer->digits\
    \ 2 (bin-length y)))\n                   (< x y)\n                   (< (bin-length\
    \ x) (bin-length y))))\n             arr))\n", "  (for/sort ([x arr])\n    (cons\
    \ x (integer->binary x))))\n", "  (define (count-ones x)\n    (cond [(zero? x)\
    \ 0]\n          [else (add1 (count-ones (bitwise-and x (sub1 x))))]))\n  (sort\
    \ (lambda (x y)\n          (cond [(= (count-ones x) (count-ones y))\n        \
    \         (< x y)]\n                [(< (count-ones x) (count-ones y))\n     \
    \            #t]\n                [else #f]))\n        arr))\n", "  (sort (map\
    \ (lambda (x) (cons x (integer->binary x))) arr)\n        (lambda (x y)\n    \
    \      (if (= (cdr x) (cdr y))\n              (string<? (integer->string (car\
    \ x)) (integer->string (car y)))\n              (string<? (cdr x) (cdr y))))))\n",
  "  (sort (map (\u03BB (n)\n               (list (bit-count n) n))\n            \
    \ arr)\n        <\n        #:key (\u03BB (n)\n               (car n))))\n```\n\
    \n```ruby\n# In this Kata, you have to sort an array of non-negative integers\
    \ according to\n# number of ones in their binary representation in ascending order.\n\
    # For similar number of ones, sort based on decimal value.\n# It must be implemented\
    \ like this:\n# >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4])\
    \ [0, 1, 2, 3, 4]\ndef sort_array(arr)\n  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend\n```\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\
    public class Kata\n{\n  public static int[] SortArray(int[] arr)\n  {\n    return\
    \ arr.OrderBy(x => Convert.ToString(x, 2).Count(c => c == '1')).ThenBy(x => x).ToArray();\n\
    \  }\n}\n```\n\n```fsharp\nlet sort_array arr =\n    arr |> Array.sortBy (fun\
    \ n -> (float (System.Convert.ToString(n, 2).Length), n))\n```\n\n```c\n#include\
    \ <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nint\
    \ cmp(const void *a, const void *b) {\n    const int x = *(const int *)a;\n  \
    \  const int y = *(const int *)b;\n    const int x_1 = __builtin_popcount(x);\n\
    \    const int y_1 = __builtin_popcount(y);\n    if (x_1", "  (sort arr (\u03BB\
    \ (x y) (and (or (= (number->string x #2)\n                                  (number->string\
    \ y #2))\n                              (< (number->string x #2)\n           \
    \                      (number->string y #2)))\n                          (< x\
    \ y)))))\n", "  (sort (lambda (a b)\n          (equal? (ones a) (ones b)))\n \
    \       arr))\n", "  (quicksort (list->sorted-list arr)\n             (lambda\
    \ (a b)\n               (define a-ones (bin-ones a))\n               (define b-ones\
    \ (bin-ones b))\n               (if (= a-ones b-ones)\n                   (< a\
    \ b)\n                   (< a-ones b-ones)))))\n", "  (sort (lambda (a b) (if\
    \ (eq? (compare-count-ones a b) -1) #t #f)) arr))\n", "  (sort (lambda (a b) (and\
    \ (or (&lt; a b)\n                               (= (count-ones a) (count-ones\
    \ b)))\n                           (&lt; a b)))\n        arr))", "  (sort\n  \
    \ (lambda (a b)\n     (let ((a-ones (count-ones a))\n           (b-ones (count-ones\
    \ b)))\n       (or\n        (and (not (zero? a-ones)) (not (zero? b-ones))\n \
    \            (or (< a-ones b-ones)\n                 (and (= a-ones b-ones) (<\
    \ a b))))\n        (and (zero? a-ones) (not (zero? b-ones))))))\n   arr))\n",
  "  (sort (map (\u03BB (x)\n               (vector x\n                       (bit-count\
    \ x)))\n             arr)\n        (\u03BB (v1 v2)\n          (cond\n        \
    \    [(< (vector-ref v1 1) (vector-ref v2 1)) #t]\n            [(> (vector-ref\
    \ v1 1) (vector-ref v2 1)) #f]\n            [(> (vector-ref v1 0) (vector-ref\
    \ v2 0)) #t]\n            [(< (vector-ref v1 0) (vector-ref v2 0)) #f]\n     \
    \       [else #f]))))\n```\n\n```haskell\nmodule SortArray where\n\nimport Data.List\
    \ (sortBy)\nimport Data.Ord (comparing)\n\nsortArray :: [Int] -> [Int]\nsortArray\
    \ xs = map (\\(x, _) -> x) $ sortBy (comparing snd) $ map (\\x -> (x, (bitCount\
    \ x, x))) xs\n\nbitCount :: Int -> Int\nbitCount 0 = 0\nbitCount 1 = 1\nbitCount\
    \ n = (n `mod` 2) + bitCount (n `div` 2)\n```\n\n## [Bit Counting](https://www.codewars.com/kata/526571aae218b8ee490006f4)\n\
    \nDescription:\n\nWrite a function that takes an integer as input, and returns\
    \ the number of bits that are equal to one in the binary representation of that\
    \ number. You can guarantee that input is non-negative.\n\nExample: The binary\
    \ representation of 1234 is 10011010010, so the function should return 5 in this\
    \ case\n\n```racket\n#lang racket\n", "  (sort (lambda (a b)\n          (cond\
    \ [(< a b) true]\n                [(> a b) false]\n                [else (let\
    \ ([a-ones (number-of-ones a)]\n                           [b-ones (number-of-ones\
    \ b)])\n                       (cond [(< a-ones b-ones) true]\n              \
    \               [(> a-ones b-ones) false]\n                             [else\
    \ (< a b)]))]))\n        arr))\n", "  (sort arr\n        <\n        (\u03BB (x\
    \ y)\n          (or (= (number->bit-string x) (number->bit-string y))\n      \
    \        (bit-string-length x < bit-string-length y)\n              (and (bit-string-length\
    \ x = bit-string-length y)\n                   (< x y))))))\n```\n\n### 1-4. 5Kyu-Remove\
    \ duplicate words\n\n##### Problem\n\nYour task is to remove all duplicate words\
    \ from a string, leaving only single (first) words entries.\n\nExample:\n\n`Input:`\n\
    \n`'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma\
    \ delta'`\n\n`Output:`\n\n`'alpha beta gamma delta'`\n\n##### Solution\n\n```#lang\
    \ racket", "  (sort (map (\u03BB (x) (list x (count-ones x))) arr)\n        (\u03BB\
    \ (a b)\n          (if (equal? (second a) (second b))\n              (< (first\
    \ a) (first b))\n              (< (second a) (second b))))))\n", "  (sort (map\
    \ (\u03BB (n)\n               (cons n (bit-count n)))\n             arr)\n   \
    \     (\u03BB (a b)\n          (if (= (cdr a) (cdr b))\n              (< (car\
    \ a) (car b))\n              (< (cdr a) (cdr b))))))\n", "  (apply append\n  \
    \       (sort (map (lambda (num)\n                      (cons (zeros num)\n  \
    \                          (cons num\n                                  '())))\n\
    \                    arr)\n               (lambda (l1 l2)\n                 (cond\n\
    \                   [(< (zeros (car l1))\n                       (zeros (car l2)))\n\
    \                    #t]\n                   [(> (zeros (car l1))\n          \
    \             (zeros (car l2)))\n                    #f]\n                   [(<\
    \ (car l1)\n                       (car l2))\n                    #t]\n      \
    \             [else\n                    #f])))))\n", "  (sort (curry compare\
    \ (flip <))\n        (sort (curry compare (flip >)) arr)))\n", "  (sort\n   (\u03BB\
    \ (x y)\n     (cond\n       [(< (bit-count x) (bit-count y)) #t]\n       [(> (bit-count\
    \ x) (bit-count y)) #f]\n       [(> x y) #t]\n       [else #f]))\n   arr))\n",
  "  (sort arr < :key (lambda (x) (cons (count-ones x) x))))\n", "  (sort (lambda\
    \ (x y)\n          (cond\n            [(< (count-ones x) (count-ones y))\n   \
    \          #t]\n            [(> (count-ones x) (count-ones y))\n             #f]\n\
    \            [else\n             (< x y)]))\n        arr))\n", "  (sort\n   (sort\
    \ arr (lambda (a b) (zero? (logand a b))))\n   (lambda (a b) (< (bit-count a)\
    \ (bit-count b)))))\n", "  (sort < arr))\n", "  (sort arr (lambda (x y)\n    \
    \          (if (= (count_ones x) (count_ones y))\n                  (if (= x y)\n\
    \                      #f\n                      (< x y))\n                  (<\
    \ (count_ones x) (count_ones y))))))\n", "  (let ([ones (lambda (x) (if (zero?\
    \ x) 0 (if (zero? (remainder x 2)) (+ 1 (ones (quotient x 2))) (ones (quotient\
    \ x 2)))))]\n        [compare (lambda (x y) (< (ones x) (ones y)))])\n    (sort\
    \ compare arr)))", "  (sort (for/list ([e arr])\n            (list (integer->binary\
    \ e) e))\n        (lambda (a b)\n          (or (< (car a) (car b))\n         \
    \     (and (= (car a) (car b))\n                   (< (cadr a) (cadr b)))))))\n",
  "  (sort arr\n        (lambda (n1 n2)\n          (if (&gt; n1 0)\n             \
    \ (if (&gt; n2 0)\n                  (&lt; (count-ones n1) (count-ones n2))\n\
    \                  #t)\n              (if (&gt; n2 0)\n                  #f\n\
    \                  (&lt; n1 n2))))))\n", "  (sort (for/list ([x arr])\n      \
    \    (list-ref x 0))\n        (lambda (x y)\n          (< (bytes->integer (byte-string\
    \ #\"x\" 0 1) 16)\n             (bytes->integer (byte-string #\"y\" 0 1) 16)))))\n",
  "  (sort arr (lambda (a b)\n              (cond [(> a b) #t]\n                 \
    \   [(< a b) #f]\n                    [else (< (bin2dec a) (bin2dec b))]))))\n",
  "  (define (fill-bits n)\n    (cond [(zero? n) 0]\n          [else (+ (fill-bits\
    \ (quotient n 2)) (remainder n 2))]))\n  (define (sort n m)\n    (cond [(< (fill-bits\
    \ n) (fill-bits m)) #t]\n          [(> (fill-bits n) (fill-bits m)) #f]\n    \
    \      [(< n m) #t]\n          [(> n m) #f]\n          [else #f]))\n  (sort arr))",
  "  (let loop ([lst arr] [acc '()])\n    (cond [(empty? lst) (reverse acc)]\n   \
    \       [else (let ([first (first lst)])\n                  (let ([ones (number-of-ones\
    \ first)])\n                    (loop (rest lst)\n                          (cons\
    \ first (filter (\u03BB (x)\n                                                (and\
    \ (not (= first x))\n                                                     (>=\
    \ (number-of-ones x) ones)))\n                                              acc))))))])))\n",
  "  (sort (map (lambda (x)\n               (cons x (count_ones x)))\n           \
    \  arr)\n        (lambda (a b)\n          (cond [(= (cdr a) (cdr b))\n       \
    \          (< (car a) (car b))]\n                [else\n                 (< (cdr\
    \ a) (cdr b))]))))\n", "  (sort (map (lambda (x)\n               (list x (string->number\
    \ (string-intersection (number->string x 2)\n                                \
    \                            \"1\"))))\n             arr)\n        < (lambda (x\
    \ y)\n           (if (= (cadr x) (cadr y))\n               (< (car x) (car y))\n\
    \               (< (cadr x) (cadr y))))))\n", "  (sort arr\n        (lambda (a\
    \ b)\n          (if (equal? (count-ones a) (count-ones b))\n              (< a\
    \ b)\n              (< (count-ones a) (count-ones b))))))\n", "  (quicksort arr\
    \ 0 (vector-length arr)))\n", "  (sort (curryr - number->string (curryr < integer->char-list\
    \ number->string)) arr))\n", "  (sort arr < #:key (lambda (num) (integer->binary\
    \ num))))\n", "  (sort arr < :key (lambda (x) (cdr (bin-ones-decimal x)))))\n",
  "  (define (ones n)\n    (cond\n      [(negative? n) (ones (- n))]\n      [(equal?\
    \ n 0) 0]\n      [else (+ (modulo n 2) (ones (quotient n 2)))]))\n  (list-sort\
    \ (lambda (x y) (< (ones x) (ones y))) arr))\n", "  (define (count-ones num)\n\
    \    (define (count-ones-helper num acc)\n      (cond [(zero? num) acc]\n    \
    \        [(and (even? num) (= acc 0)) 0]\n            [(and (even? num) (= acc\
    \ 1)) 1]\n            [(and (odd? num) (= acc 0)) 1]\n            [(and (odd?\
    \ num) (= acc 1)) 0]\n            [else (+ acc (count-ones-helper (quotient num\
    \ 2) 1))]))\n    (count-ones-helper num 0))\n  (let ([sorted (sort arr (\u03BB\
    \ (a b) (<= (count-ones a) (count-ones b))))])\n    (cond [(eq? (count-ones (car\
    \ sorted)) (count-ones (cadr sorted)))\n           (list-sort (\u03BB (a b) (<=\
    \ a b)) sorted)]\n          [else sorted])))", "  (sort < arr))\n", "  (quicksort\
    \ (sort arr (\u03BB (x y)\n                        (< (count-ones x) (count-ones\
    \ y))))))\n", "  (sort (map number->string arr) #:key string-length))\n", "  (sort\
    \ (lambda (x y) (< x y))\n        (map (lambda (x)\n               (+ (bitwise-count\
    \ x)\n                  (* 1e10 x)))\n             arr)))\n", "  (sort arr (\u03BB\
    \ (x y)\n              (if (or (and (zero? (modulo x 2)) (zero? (modulo y 2)))\n\
    \                      (and (not (zero? (modulo x 2))) (not (zero? (modulo y 2)))))\n\
    \                  (if (= (bit-count x) (bit-count y))\n                     \
    \ (< x y)\n                      (< (bit-count x) (bit-count y)))\n          \
    \        (and (zero? (modulo x 2)) (not (zero? (modulo y 2))))))))\n```\n\nSort\
    \ the binary numbers according to their bit counts, if the bit counts are\nequal\
    \ then sort the numbers in ascending order.\n\n### Test Suite\n\n``` racket\n\
    #lang racket\n", "  (let loop ([arr arr] [res (vector)])\n    (cond [(empty? arr)\
    \ (vector->list res)]\n          [else (loop (rest arr)\n                    \
    \  (vector-copy (vector-append res\n                                         \
    \         (vector (first arr)))))])))", "  (define (count_ones x)\n    (define\
    \ (count acc n)\n      (cond\n        [(zero? n) acc]\n        [(= (remainder\
    \ n 2) 1) (count (+ acc 1) (quotient n 2))]\n        [else (count acc (quotient\
    \ n 2))]))\n    (count 0 x))\n  (define (sort-pred a b)\n    (let* ([an (count_ones\
    \ a)]\n           [bn (count_ones b)])\n      (cond\n        [(< an bn) #t]\n\
    \        [(= an bn) (< a b)]\n        [else #f])))\n  (sort sort-pred arr))\n",
  "  (sort arr (\u03BB (a b) (< (count-ones a) (count-ones b)))))\n", "  (sort (compose\
    \ (map (compose bin->integer (compose integer->binary (compose first-digit (bin->integer)))))\
    \ string->number) identity) arr))\n", "  (sort (map (lambda (x) (list x (- (integer->char\
    \ x) (integer->char #x30)))) arr)\n        <\n        (lambda (x y)\n        \
    \  (if (eq? (length (cdr x)) (length (cdr y)))\n              (< (car x) (car\
    \ y))\n              (< (length (cdr x)) (length (cdr y)))))))\n", "  (mergesort\
    \ (map number->string arr) string<?))\n", "  (define (count-ones x)\n    (let\
    \ loop ([x x] [count 0])\n      (cond\n        [(= x 0) count]\n        [(odd?\
    \ x) (loop (quotient x 2) (+ count 1))]\n        [else (loop (quotient x 2) count)])))\n\
    \  (sort < arr))\n```\n\n```racket\n#lang racket\n", "  (sort (for/list ([x arr])\n\
    \          (cons x (string-&gt;number (number-&gt;string x 2))))\n        &lt;\
    \ #:key cdr))\n</code>\n", "  (sort arr (lambda (a b)\n              (or (&lt;\
    \ (bit-count a) (bit-count b))\n                  (and (= (bit-count a) (bit-count\
    \ b))\n                       (&lt; a b))))))\n</code>\n", "  (sort (map (lambda\
    \ (x) (list x x)) arr)\n        (lambda (e1 e2) (if (= (length (regexp-match #rx\"\
    1\" (number->string (car e1))))\n                              (length (regexp-match\
    \ #rx\"1\" (number->string (car e2)))))\n                           (< (car e1)\
    \ (car e2))\n                           (< (length (regexp-match #rx\"1\" (number->string\
    \ (car e1))))\n                              (length (regexp-match #rx\"1\" (number->string\
    \ (car e2)))))))))\n", "  (define (num-ones x)\n    (for/fold ([acc 0]) ([n (in-naturals\
    \ 1)])\n      (cond\n        [(> x 0) (if (zero? (modulo x 2))\n             \
    \        acc\n                     (add1 acc))]\n        [else acc])\n      (quotient\
    \ x 2)))\n  (cond\n    [(zero? (length arr)) '()]\n    [else (sort (lambda (x\
    \ y)\n                  (cond\n                    [(= (num-ones x) (num-ones\
    \ y)) (< x y)]\n                    [else (< (num-ones x) (num-ones y))]))\n \
    \               arr)]))\n", "  (sort (\u03BB (a b)\n          (cond [(> (length\
    \ (filter (\u03BB (x) (= x #\\1)) (integer->binary a)))\n                   (length\
    \ (filter (\u03BB (x) (= x #\\1)) (integer->binary b))))\n                 #t]\n\
    \                [(< (length (filter (\u03BB (x) (= x #\\1)) (integer->binary\
    \ a)))\n                   (length (filter (\u03BB (x) (= x #\\1)) (integer->binary\
    \ b))))\n                 #f]\n                [else\n                 (< a b)]))\n\
    \        arr))", "  (sort arr <))\n", "  (sort (map (lambda (x) (list x (bytes->integer/fl\
    \ (integer->bytes x 2)))) arr)\n        (lambda (x y) (< (cadr x) (cadr y)))))\n",
  "  (sort arr (\u03BB (a b) (&lt; a b))))\n", "  (if (empty? arr)\n      '()\n  \
    \    (let ([pivot (first arr)])\n        (append (sort_array (filter (lambda (n)\
    \ (< (bitcount n) (bitcount pivot))) (rest arr)))\n                (list pivot)\n\
    \                (sort_array (filter (lambda (n) (= (bitcount n) (bitcount pivot)))\
    \ (rest arr)))))))\n", "  (let* ([ones-count (sort (map (compose (count 1) binary)\
    \ arr) <)]\n         [position   (build-position ones-count arr)])\n    (sort-position\
    \ position arr)))\n", "  (sort (\u03BB (x y) (< (expt 2 x) (expt 2 y)))\n    \
    \    arr))\n", "  (sort (map (lambda (x) (list x (bin-to-int (int-to-bin x))))\
    \ arr)\n        (lambda (x y)\n          (< (car x) (car y)))))\n", "  (sort arr\
    \ (lambda (a b) (< (number-of-ones a) (number-of-ones b)))))\n", "  (sort arr\
    \ (\u03BB (x y)\n              (let* ([bx (number->string (integer->binary x))]\n\
    \                     [by (number->string (integer->binary y))])\n           \
    \     (cond [(< (string-length bx) (string-length by)) #t]\n                 \
    \     [(> (string-length bx) (string-length by)) #f]\n                      [(string<?\
    \ bx by) #t]\n                      [(string>? bx by) #f]\n                  \
    \    [(< x y) #t]\n                      [(> x y) #f]\n                      [else\
    \ #f])))))\n```\n\n- - -\n\nAnother solution from /u/AhmedSamhouri\n\n``` #lang\
    \ racket", "  (sort arr < #:key (lambda (n) (cons (bit-count n) n))))\n", "  (let*\
    \ ([arr (map number->string arr)]\n         [ones (map (compose string-length\
    \ binary->decimal) arr)]\n         [ones->arr (for/hash ([ones ones] [arr arr])\
    \ (cons ones arr))]\n         [ones (sort ones #:key ones->arr)]\n         [arr\
    \ (map ones->arr ones)])\n    (map string->number arr)))\n", "  (define (ones\
    \ n)\n    (cond [(= n 0) 0]\n          [else (+ (ones (quotient n 2)) (remainder\
    \ n 2))]))\n  (define (sort-ones arr)\n    (sort < arr))\n  (sort sort-ones arr))\n",
  "  (sort (map binary->integer (map integer->binary arr)) <))\n", "  (sort (map (\u03BB\
    \ (x) (list x (number->string x 2))) arr)\n        (\u03BB (x y) (or (eq? 0 (string-length\
    \ x))\n                     (eq? 0 (string-length y))\n                     (eq?\
    \ #t (string-contains (first x) (first y)))\n                     (eq? #t (string-contains\
    \ (first y) (first x)))\n                     (string-ci<? (first x) (first y))))))\n",
  "  (sort (lambda (x y) (&lt; (bit-count x) (bit-count y))) arr))\n</code>\n", " \
    \ (sort arr < :key (lambda (x) (list (count-ones x) x))))\n", "  (sort (\u03BB\
    \ (x y)\n         (< (number->string x 2) (number->string y 2)))\n        arr))\n",
  "  (sort (map (\u03BB (x) (cons (count-ones x) x)) arr)\n        <\n        #:key\
    \ cadr))\n", "  (define (count-ones n)\n    (define (bin n)\n      (if (zero?\
    \ n)\n          \"\"\n          (bin (quotient n 2))\n          (if (even? n)\n\
    \              (string-append (bin (quotient n 2)) \"0\")\n              (string-append\
    \ (bin (quotient n 2)) \"1\"))))\n    (apply + (map string->number (string-split\
    \ (bin n) \"\"))))\n  (sort (map-indexed (lambda (i x) (cons i x)) arr)\n    \
    \    (lambda (a b)\n          (define (ones a) (count-ones (second a)))\n    \
    \      (define (ones b) (count-ones (second b)))\n          (if (and (zero? (minus\
    \ (ones a) (ones b)))\n                   (zero? (minus (second a) (second b))))\n\
    \              #t\n              (zero? (minus (ones a) (ones b)))))))\n", " \
    \ (sort arr\n        (lambda (x y)\n          (let ([xb (format \"~b\" x)]\n \
    \               [yb (format \"~b\" y)])\n            (cond [(< (string-length\
    \ xb) (string-length yb))\n                   #t]\n                  [(> (string-length\
    \ xb) (string-length yb))\n                   #f]\n                  [(> x y)\n\
    \                   #t]\n                  [(< x y)\n                   #f]\n\
    \                  [else\n                   #f])))))", "  (sort (lambda (a b)\
    \ (< a b))\n        (map (lambda (x) (exact->inexact (integer->decimal-string\
    \ x))) arr)))", "  (sort (lambda (a b)\n          (cond [(= a b) #f]\n       \
    \         [(= (bit-count a) (bit-count b)) (< a b)]\n                [else (<\
    \ (bit-count a) (bit-count b))]))\n        arr))\n", "  (sort arr < :key (\u03BB\
    \ (n)\n                     (cons (integer->binary n count-ones) n))))\n", " \
    \ (for/list ((el (in-list arr)))\n    el))\n", "  (sort arr <=?))\n", "  (define\
    \ (bit-count n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 1]\n      [(= n\
    \ 2) 1]\n      [(= n 3) 2]\n      [(= n 4) 1]\n      [(= n 5) 2]\n      [(= n\
    \ 6) 2]\n      [(= n 7) 3]\n      [(= n 8) 1]\n      [(= n 9) 2]\n      [(= n\
    \ 10) 2]\n      [(= n 11) 3]\n      [(= n 12) 2]\n      [(= n 13) 3]\n      [(=\
    \ n 14) 3]\n      [(= n 15) 4]\n      [else (+ (remainder n 2) (bit-count (quotient\
    \ n 2)))]))\n  (define (custom-sort-pred a b)\n    (cond\n      [(= (bit-count\
    \ a) (bit-count b)) (> a b)]\n      [else (< (bit-count a) (bit-count b))]))\n\
    \  (sort custom-sort-pred arr))\n", "  (sort (lambda (x y)\n          (let ([x-ones\
    \ (count-ones x)]\n                [y-ones (count-ones y)])\n            (if (<\
    \ x-ones y-ones)\n                #t\n                (if (and (= x-ones y-ones)\
    \ (< x y))\n                    #t\n                    #f))))\n        arr))\n",
  "  (define (count-ones n)\n    (if (zero? n)\n        0\n        (+ (count-ones\
    \ (integer-floor (/ n 2)))\n           (remainder n 2))))\n  (sort (lambda (n1\
    \ n2)\n          (if (= (count-ones n1) (count-ones n2))\n              (< n1\
    \ n2)\n              (< (count-ones n1) (count-ones n2))))\n        arr))\n",
  "  (let loop ([arr arr] [acc '()])\n    (if (null? arr)\n        (sort acc (lambda\
    \ (a b) (< (car a) (car b))))\n        (loop (cdr arr)\n              (cons (cons\
    \ (count-ones (car arr)) (car arr)) acc)))))\n", "  (sort (for/list ([x arr])\n\
    \          (values x (integer->string x 2)))\n        < #:key cdr))", "  (sort\
    \ (map (\u03BB (i) (list i (bytes i))) arr)\n        <\n        (\u03BB (x y)\
    \ (or (and (equal? (cadr x) (cadr y))\n                         (apply < (car\
    \ x) (car y)))\n                    (apply < (cadr x) (cadr y))))))\n```\n\n```javascript\n\
    const sort_array = arr => arr.sort((a, b) => {\n  const [a1, b1] = [a, b].map(i\
    \ => i.toString(2).split('').filter(i => i === '1').length);\n  return a1 ===\
    \ b1 ? a - b : a1 - b1;\n});\n```\n\n## Tests\n\n```javascript\nTest.assertSimilar(sort_array([0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), [0, 1, 2, 4, 8, 3, 5, 6, 7, 9, 10]);\nTest.assertSimilar(sort_array([0,\
    \ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10]), [-10, -9, -8, -7, -6, -5, -4, -3,\
    \ -2, -1, 0]);\nTest.assertSimilar(sort_array([1024, 256, 128, 64, 32, 16, 8,\
    \ 4, 2, 1]), [1, 2, 4, 8, 16, 32, 64, 128, 256, 1024]);\nTest.assertSimilar(sort_array([1000,\
    \ 1000, -1000, -1000]), [-1000, -1000, 1000, 1000]);\nTest.assertSimilar(sort_array([-27,\
    \ -27, 5, -3, 4, -2, 6, -1, 0, 7, 1, -8, 2, 9, -9, -10, -11, -12, -13, -14, -15,\
    \ -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -28, -29, -30, -31, -32,\
    \ -33, -34, -35, -36", "  (define (ones x)\n    (if (zero? x)\n        0\n   \
    \     (+ 1 (ones (quotient x 2)))))\n  (quicksort arr <))\n", "  (sort arr (lambda\
    \ (a b)\n              (and (>= (number->string a 2) (number->string b 2))\n \
    \                  (>= a b)))))\n", "  (sort arr number-of-ones<=?))\n", "  (sort\
    \ (map (\u03BB (x) (list x (number->string x 2))) arr)\n        (\u03BB (x y)\
    \ (and (not (equal? (cadr x) (cadr y)))\n                      (string<? (cadr\
    \ x) (cadr y))))))\n", "  (define (has_one? n)\n    (zero? (remainder n 2)))\n\
    \  (define (recur lst)\n    (if (null? lst)\n        lst\n        (recur (append\
    \ (filter has_one? lst)\n                       (filter (\u03BB (n) (not (has_one?\
    \ n))) lst)))))\n  (recur arr))\n", "  (sort < arr))\n", "  (sort\n   arr\n  \
    \ (\u03BB (n1 n2)\n     (< (bit-count n1) (bit-count n2)))))\n", "  (match arr\n\
    \    [(list) '()]\n    [(list a . rest)\n     (let* ([sort-rest (sort_array rest)]\n\
    \            [max-rest (if (empty? sort-rest) a (car sort-rest))]\n          \
    \  [min-rest (if (empty? sort-rest) a (last sort-rest))])\n       (if (&lt; a\
    \ max-rest)\n           (let loop ([sort-rest sort-rest] [so-far '()])\n     \
    \        (if (empty? sort-rest)\n                 (reverse (cons a so-far))\n\
    \                 (if (&lt; a (car sort-rest))\n                     (reverse\
    \ (cons a (cons (car sort-rest) so-far)))\n                     (loop (cdr sort-rest)\
    \ (cons (car sort-rest) so-far)))))\n           (if (&gt; a min-rest)\n      \
    \         (append sort-rest (list a))\n               (append (list a) sort-rest))))]))\n\
    </code>\nI'd like some feedback on my implementation.  Is there a better way to\
    \ implement this?  What would a better implementation look like?\n\n\nA:\n\nYour\
    \ implementation does work, but there are some ways to simplify it.\nFirst, some\
    \ general advice: The single-element lists are annoying. It's not necessary that\
    \ the first element of a list be an atom; it could be a list, too. This allows\
    \ you to write a list of the form <code>(list a . b)</code> even if <code>b</code>\
    \ is empty: <code>(list a . ())</code>. This allows your <code>match</code> to\
    \ be simpler, and doesn't require you to use <code>cons</code> in <code>sort_array</code>.\n\
    The first case (<code>list</code>) is easy to handle: it just sorts <code>a</code>.\
    \ But the <code>rest</code> is more difficult. You have to find the maximum of\
    \ the rest, and then you have to find the minimum of the rest. It seems simpler\
    \ to just sort the rest.\nHere's a <code>sort-array</code> that simplifies these\
    \ operations:\n<code>(define (sort-array arr)\n  (match arr\n    [() '()", " \
    \ (sort (map (\u03BB (x) (list x (integer->binary x))) arr)\n        (\u03BB (a\
    \ b)\n          (let* ([ones1 (count-ones (cadr a))]\n                 [ones2\
    \ (count-ones (cadr b))])\n            (cond\n              [(> ones1 ones2) #t]\n\
    \              [(= ones1 ones2) (< (car a) (car b))]\n              [else #f])))))\n",
  "  (define (count-ones n)\n    (define (iter-count-ones n curr)\n      (cond\n \
    \       [(zero? n) curr]\n        [(odd? n) (iter-count-ones (quotient n 2) (+\
    \ curr 1))]\n        [else (iter-count-ones (quotient n 2) curr)]))\n    (iter-count-ones\
    \ n 0))\n  (define (num-cmp a b)\n    (cond\n      [(< a b) -1]\n      [(> a b)\
    \ 1]\n      [else 0]))\n  (define (ones-cmp a b)\n    (define (signum n)\n   \
    \   (cond\n        [(< n 0) -1]\n        [(> n 0) 1]\n        [else 0]))\n   \
    \ (signum (num-cmp (count-ones a) (count-ones b))))\n  (sort ones-cmp arr))\n",
  "  (let ((ones (map (lambda (x)\n                     (define (helper x acc)\n \
    \                      (if (= x 0)\n                           acc\n         \
    \                  (helper (quotient x 2)\n                                  \
    \ (+ 1 acc))))\n                     (helper x 0))\n                   arr)))\n\
    \    (sort arr\n          (lambda (x y)\n            (if (= (ones x) (ones y))\n\
    \                (< x y)\n                (< (ones x) (ones y)))))))\n", "  (sort\n\
    \   (sort arr <)\n   (lambda (a b) (and (not (= a b))\n                      (zero?\
    \ (compare a b))))))\n", "  (match arr\n    [() #f]\n    [(cons (? number? x)\
    \ xs)\n     (define (none f xs)\n       (match xs\n         [() #t]\n        \
    \ [(cons x xs) (and (f x) (none f xs))]))\n     (and (none number? arr)\n    \
    \      (sort_array (map count-ones arr)))]))", "  (define n-ones\n    (lambda\
    \ (n)\n      (define (count-ones n acc)\n        (cond\n          [(zero? n) acc]\n\
    \          [(odd? n) (count-ones (quotient n 2) (+ acc 1))]\n          [else (count-ones\
    \ (quotient n 2) acc)]))\n      (count-ones n 0)))\n  (sort (lambda (x y)\n  \
    \         (cond\n             [(< (n-ones x) (n-ones y)) #t]\n             [(>\
    \ (n-ones x) (n-ones y)) #f]\n             [(< x y) #t]\n             [(> x y)\
    \ #f]\n             [else #f]))\n         arr))\n", "  (sort (\u03BB (x y) (if\
    \ (and (equal? x 1) (equal? y 1)) #f #t)) arr))", "  (sort (list->vector arr)\
    \ #:key count-ones #:cmp <=))\n", "  (sort arr < :key count-ones))\n", "  (define\
    \ (count-ones n)\n    (cond [(= n 0) 0]\n          [else (+ (modulo n 2) (count-ones\
    \ (quotient n 2)))]))\n  (sort arr (\u03BB (a b) (or (= (count-ones a) (count-ones\
    \ b))\n                          (< a b)))))\n```\n\nFor more information on how\
    \ to solve this challenge, please visit [this link](https://www.codewars.com/kata/595f2b606e0fa0e8600000cd/solutions/racket).",
  "  (sort (\u03BB (a b) (< (count-ones a) (count-ones b))) arr))\n", "  (sort (lambda\
    \ (a b)\n          (if (< (count-ones a) (count-ones b))\n              #t\n \
    \             (if (or (= (count-ones a) (count-ones b))\n                    \
    \  (> a b))\n                  #f\n                  #t)))\n        arr))\n",
  "  (sort < arr))\n", "  (sort (for/list ([x arr])\n          (list (logand x 1)\
    \ x))\n        (\u03BB (l1 l2)\n          (cond [(= (car l1) (car l2))\n     \
    \            (< (cadr l1) (cadr l2))]\n                [else\n               \
    \  (< (car l1) (car l2))]))))\n", "  (define (ones x)\n    (if (zero? x) 0\n \
    \       (+ 1 (ones (quotient x 2)))))\n  (sort < arr (\u03BB (x y)\n         \
    \      (and (or (and (eq? 0 (ones x))\n                             (not (eq?\
    \ 0 (ones y))))\n                        (and (eq? 0 (ones y))\n             \
    \                (not (eq? 0 (ones x)))))\n                    (or (> x y)\n \
    \                       (= x y))))))\n", "  (sort (map (\u03BB (x) (list x (number->string\
    \ x 2))) arr)\n        (\u03BB (x y) (if (equal? (length (cadr x)) (length (cadr\
    \ y)))\n                     (string<? (cadr x) (cadr y))\n                  \
    \   (< (length (cadr x)) (length (cadr y)))))))\n", "  (for/list ([x arr])\n \
    \   (list x (count-ones x)))\n  (for/list ([x (sort arr < #:key (\u03BB (x) (list\
    \ (count-ones x) x)))]\n           #:when (> x 0))\n    x))\n", "  (sort (array-map\
    \ (\u03BB (n)\n                     (cond [(>= n 0) (cons n (bits n))]\n     \
    \                      [else (cons n n)]))\n                   arr)\n        (\u03BB\
    \ (x y) (or (and (eq? (car x) (car y))\n                          (< (cdr x) (cdr\
    \ y)))\n                     (< (car x) (car y))))))\n", '  (sort (map (curry
    (lambda (num) (cons num (parse-integer (number->string num) 2)))) arr) (curry
    string<? (cdr) (cdr))))', "  (sort arr < :key (\u03BB (x) (cons (count-ones x)\
    \ x))))\n", "  (sort (compose (map (compose ones bin)) number->string) < arr))\n",
  "  (sort (<) (map binary-to-num arr)))\n", '  (sort arr < :key (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose (compose (compose (compose (compose (compose
    (compose (compose (compose (compose', "  (sort (sort arr (\u03BB (x y) (< (bit-count\
    \ x) (bit-count y))))\n        (\u03BB (x y) (< x y))))\n", "  (sort arr < :key\
    \ (lambda (x) (cons (count-ones x) x))))\n", "  (define (num_ones n)\n    (let\
    \ loop ([n n] [ones 0])\n      (cond [(zero? n) ones]\n            [(odd? n) (loop\
    \ (quotient n 2) (+ ones 1))]\n            [else (loop (quotient n 2) ones)])))\n\
    \  (sort (comparator <) arr))\n", "  (sort (map (lambda (x)\n               (cons\
    \ x (bit-count x)))\n             arr)\n        (lambda (x y)\n          (cond\
    \ [(< (car x) (car y)) #t]\n                [(< (cdr x) (cdr y)) #t]\n       \
    \         [else #f]))))\n", "  (sort (lambda (x y) (< x y))\n        (map (lambda\
    \ (x)\n               (let loop ([x x] [c 0])\n                 (if (zero? x)\
    \ c\n                   (loop (bitwise-arithmetic-shift x -1) (+ c 1)))))\n  \
    \           arr)))\n", "  (sort arr\n        <\n        (compose list\n      \
    \           (compose\n                  cons\n                  (compose list\
    \ (compose len (lambda (i) (integer->list 2 i))))))))\n", '  (sort arr <))', " \
    \ (sort arr (lambda (a b)\n              (or\n               (and (even? a) (odd?\
    \ b))\n               (and\n                (and (odd? a) (even? b))\n       \
    \         (< a b))))))\n", "  (define (sorter item1 item2)\n    (cond\n      [(>\
    \ (count-ones item1) (count-ones item2)) #t]\n      [(= (count-ones item1) (count-ones\
    \ item2)) (< item1 item2)]\n      [else #f]))\n  (sort sorter arr))\n", "  (sort\
    \ arr (\u03BB (x y) (< (number-of-ones x) (number-of-ones y)))))\n", "  (sort\
    \ (map (lambda (x) (cons (number->string x 2) x)) arr)\n        (lambda (x y)\n\
    \          (cond\n            [(equal? (car x) (car y))\n             (< (cdr\
    \ x) (cdr y))]\n            [else\n             (< (string->number (car x) 2)\n\
    \                (string->number (car y) 2))]))))\n```\n\n## Comments\n\n```racket\n\
    #lang racket\n", "  (sort (map (\u03BB (x)\n               (list (count-ones x)\
    \ x))\n             arr)\n        (\u03BB (x y)\n          (or (= (first x) (first\
    \ y))\n              (< (first x) (first y)))))\n  (map second arr))\n", "  (sort\
    \ (for/list ([x arr])\n          (list (bit-count x) x))\n        (\u03BB (x y)\
    \ (and (< (car x) (car y))\n                      (< (cadr x) (cadr y))))\n  \
    \      (\u03BB (x) (cadr x))))\n```\n\n\u3053\u308C\u3082scheme\u3067\u66F8\u3044\
    \u3066\u3044\u308B\u306E\u3067\u3001racket\u3082\u66F8\u3044\u3066\u307F\u307E\
    \u3057\u305F\u3002\n\n\u7B54\u3048\u304C\u306A\u3093\u3067\u3057\u3087\u3046\u306D\
    \u3001\u3068\u3044\u3046\u3053\u3068\u3067\n\n```scala\ndef sortArray(arr: Array[Int]):\
    \ Array[Int] = {\n  arr.toList.sortBy(x => (Integer.bitCount(x), x)).toArray\n\
    }\n```\n\n\u3068\u306A\u308A\u307E\u3057\u305F\u3002\n\n\u3053\u308C\u3092\u66F8\
    \u304F\u3068\u304D\u306E\u601D\u8003\u306E\u4E00\u90E8\u3067\u3059\u304C\u3001\
    \n\n- \u6570\u5024\u306E\u914D\u5217\u3092\u53D7\u3051\u53D6\u308B\n- bit\u6570\
    \u3092\u6570\u3048\u308B `bitCount`\n- \u6570\u3048\u305Fbit\u6570\u3068\u3001\
    \u6570\u5B57\u3092\u5BFE\u306B\u3057\u3066\n- sortBy\n- \u914D\u5217\u306B\u623B\
    \u3059\n\n\u3068\u3044\u3046\u6D41\u308C\u3067\u3059\u3002\n\nsortBy\u306F\u300C\
    `Ordering`\u3092\u6307\u5B9A\u3059\u308B\u3053\u3068\u3067\u3001\u30EA\u30B9\u30C8\
    \u306E\u4E26\u3073\u66FF\u3048\u304C\u884C\u3048\u308B\u300D\u306E\u3067\u3059\
    \u304C\u3001\n\n- \u5F15\u6570\u306F2\u3064\n- \u7B2C\u4E00\u5F15\u6570\u3067\u4E26\
    \u3073\u66FF\u3048\u306E\u30AD\u30FC\u3092\u6307\u5B9A\n- \u7B2C\u4E8C\u5F15\u6570\
    \u3067\u8F9E\u66F8\u9806\u3092\u6307\u5B9A\n\n\u3068\u3044\u3046\u3053\u3068\u306B\
    \u306A\u3063\u3066\u3044\u307E\u3059\u3002\n\n\u7B2C\u4E00\u5F15\u6570\u306F\u3001\
    \u3053\u306E\u554F\u984C\u3067\u8A00\u3046\u3068\u300C`bitCount`\u300D\u3057\u305F\
    \u6570\u5B57\u3068\u3001\u6570\u5B57\u3092\u5BFE\u306B\u3057\u305F\u3082\u306E\
    \u3067\u3059\u3002\n\n\u7B2C\u4E8C\u5F15\u6570\u306F\u3001\u3053\u306E\u554F\u984C\
    \u3067\u8A00\u3046\u3068\n\n- bit", "  (sort (map (\u03BB (x) (cons x (integer->binary\
    \ x))) arr)\n        (\u03BB (x y) (cond ((< (cdr x) (cdr y)) #t)\n          \
    \             ((> (cdr x) (cdr y)) #f)\n                       ((< (car x) (car\
    \ y)) #t)\n                       (#t #f)))))\n", "  (sort < arr))\n", "  (define\
    \ (count-ones n)\n    (cond\n      [(< n 0) 0]\n      [(= n 0) 0]\n      [else\
    \ (+ (remainder n 2) (count-ones (quotient n 2)))]))\n  (sort (lambda (x y)\n\
    \          (if (< (count-ones x) (count-ones y))\n              #t\n         \
    \     (if (= (count-ones x) (count-ones y))\n                  (< x y)\n     \
    \             #f)))\n        arr))\n```\n\n```racket\n#lang racket\n", "  (sort\
    \ (lambda (a b)\n          (define a-ones (count-ones a))\n          (define b-ones\
    \ (count-ones b))\n          (cond [(> a-ones b-ones) #t]\n                [(<\
    \ a-ones b-ones) #f]\n                [else (< a b)]))\n        arr))\n", "  (sort\
    \ arr #:key (\u03BB (n) (cons (count-ones n) n))))\n", "  (let ([pairs\n     \
    \    (for/list ([x arr])\n           (let ([xbits (integer->binstr x)])\n    \
    \         (values x (length (regexp-match* #rx\"1\" xbits)))))]\n        [sorted\
    \ (sort pairs (\u03BB (p1 p2)\n                              (or (< (cdr p1) (cdr\
    \ p2))\n                                  (and (= (cdr p1) (cdr p2))\n       \
    \                                (< (car p1) (car p2))))))])\n    (for/list ([p\
    \ sorted]) (car p))))\n", "  (sort (map (lambda (n) (cons n (count-bits n))) arr)\n\
    \        (lambda (a b)\n          (or (and (zero? (sub1 (count-bits (car a))))\n\
    \                   (positive? (sub1 (count-bits (car b)))))\n              (and\
    \ (positive? (sub1 (count-bits (car a))))\n                   (zero? (sub1 (count-bits\
    \ (car b)))))\n              (< (car a) (car b))))))\n", "  (sort arr\n      \
    \  (lambda (a b)\n          (let ((a-ones (racket-ones a))\n                (b-ones\
    \ (racket-ones b)))\n            (cond ((> a-ones b-ones) #t)\n              \
    \    ((< a-ones b-ones) #f)\n                  (else (and (> a b) #t #f)))))))\n",
  "  (sort (\u03BB (a b) (< a b))\n        (sort (\u03BB (a b) (< (number->string\
    \ (integer->binary a) 2)\n                          (number->string (integer->binary\
    \ b) 2)))\n              arr)))\n", "  (sort arr (lambda (x y) (or (= (decimal-to-binary\
    \ x) (decimal-to-binary y))\n                               (< (decimal-to-binary\
    \ x) (decimal-to-binary y))))))\n", "  (sort (map (lambda (n) (list (count-ones\
    \ n) n)) arr)\n         <\n         (lambda (l r) (cond [(= (length l) (length\
    \ r))\n                              (< (last l) (last r))]\n                \
    \             [else\n                              (< (length l) (length r))]))))\n",
  "  (sort (map (lambda (x) (list x (bin-of x))) arr)\n        (lambda (x y) (if (=\
    \ (length (cadr x)) (length (cadr y)))\n                          (< (car x) (car\
    \ y))\n                          (< (length (cadr x)) (length (cadr y)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
