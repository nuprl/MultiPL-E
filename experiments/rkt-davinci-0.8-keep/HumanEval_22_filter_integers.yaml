name: HumanEval_22_filter_integers
language: rkt
prompt: "#lang racket\n\n;; Filter given list of any python values only for integers\n\
  ;; >>> filter_integers(['a', 3.14, 5])\n;; [5]\n;; >>> filter_integers([1, 2, 3,\
  \ 'abc', {}, []])\n;; [1, 2, 3]\n(define (filter_integers values)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_integers))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 4 #hash() (list ) 23.2 9 \"adasd\")) (list 4 9))\n    (check-equal? (candidate\
  \ (list 3 \"c\" 3 3 \"a\" \"b\")) (list 3 3 3))\n))\n\n(test-humaneval)"
completions: ["  (filter (\u03BB (value) (integer? value)) values))\n", "  (cond\n\
    \    [(null? values) '()]\n    [(integer? (car values)) (cons (car values) (filter_integers\
    \ (cdr values)))]\n    [else (filter_integers (cdr values))]))\n", "  (filter\
    \ integer? values))\n```\n# [Chapter 10](./Chapter10)\n\n**Problem 1**\n\n> Create\
    \ a function that creates a file if one doesn't exist.\n\n```racket\n#lang racket\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "  (filter integer? values))\n", "  (filter (lambda (value)\
    \ (integer? value)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "  (filter number? values))\n", "  (cond\n    [(empty? values) '()]\n    [(integer?\
    \ (first values)) (cons (first values) (filter_integers (rest values)))]\n   \
    \ [else (filter_integers (rest values))]))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (define (filter value)\n    (integer? value))\n  (filter-map\
    \ (lambda (v) (if (filter v) v)) values))\n", "  (filter (lambda (x) (number?\
    \ x)) values))\n", "  (cond [(empty? values) '()]\n        [(integer? (first values))\n\
    \         (cons (first values) (filter_integers (rest values)))]\n        [else\
    \ (filter_integers (rest values))]))\n", "  (filter integer? values))\n```\n\n\
    ## Modify\n\nImplement the following python functions in Racket:\n\n**map**\n\n\
    ```python\n#lang racket\n", "  (filter (lambda (v) (integer? v)) values))\n",
  "  (cond [(empty? values) '()]\n        [(integer? (first values))\n         (cons\
    \ (first values) (filter_integers (rest values)))]\n        [else (filter_integers\
    \ (rest values))]))\n", "  (filter number? values))\n", "  (filter (lambda (x)\
    \ (integer? x)) values))\n", "  (for/list ([value values]\n             #:when\
    \ (integer? value))\n    value))\n", "  (filter (lambda (x) (integer? x)) values))\n",
  "  (filter (lambda (x) (and (number? x) (integer? x))) values))\n", "  (filter integer?\
    \ values))\n", "  (filter integer? values))\n", "  (filter (lambda (value) (integer?\
    \ value)) values))\n", "  (filter (lambda (i) (integer? i)) values))\n", "  (cond\n\
    \    [(empty? values) empty]\n    [(integer? (first values))\n     (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (for/list ([v values]\n             #:when (integer? v))\n\
    \    v))\n", "  (filter number? values))\n", "  (filter (lambda (value) (integer?\
    \ value)) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (cond\
    \ ((empty? values) empty)\n        ((integer? (first values)) (cons (first values)\
    \ (filter_integers (rest values))))\n        (else (filter_integers (rest values)))))\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (for/list ([value values]\n\
    \             #:when (integer? value))\n    value))\n", "  (filter (lambda (value)\
    \ (integer? value)) values))\n", "  (define (integer? value)\n    (if (number?\
    \ value)\n        (integer? value)\n        #f))\n  (filter integer? values))\n",
  "  (filter integer? values))\n", "  (filter\n   (lambda (x) (integer? x))\n   values))\n\
    ```\n\n## List Comprehensions\n\nA more concise and efficient way to write the\
    \ above is with list comprehensions. First the syntax:\n\n```python\n[expr for\
    \ var in iterable if condition]\n```\n\n`expr` is the value of each item in the\
    \ list. `var` is the variable being assigned to. `iterable` is the sequence being\
    \ iterated over. `condition` is the optional filter expression. `condition` needs\
    \ to be enclosed in parenthesis if it contains commas.\n\nThe above example could\
    \ be written as:\n\n```python\n[value for value in values if isinstance(value,\
    \ int)]\n```\n\n## Dictionaries\n\nA dictionary is also known as a map, hash table,\
    \ or associative array. A dictionary contains key-value pairs, keys are unique\
    \ and case sensitive. To create a dictionary, use curly braces and colons.\n\n\
    ```python\n# empty dictionary\nd = {}\n\n# dictionary with initial values\nd =\
    \ {\n    'foo': 1,\n    'bar': 2,\n    'baz': 3\n}\n```\n\nYou can create a dictionary\
    \ using the built-in `dict` function by providing a sequence of key-value pairs.\n\
    \n```python\nd = dict([('foo', 1), ('bar', 2), ('baz', 3)])\n```\n\nYou can also\
    \ use the built-in `dict` function to create a dictionary from an iterable of\
    \ key-value pairs.\n\n```python\nd = dict(zip(['foo', 'bar', 'baz'], [1, 2, 3]))\n\
    ```\n\nTo get the value for a specific key, use the square bracket syntax.\n\n\
    ```python\nd['foo']\n```\n\nTo add or update a key-value pair, use the square\
    \ bracket syntax with assignment.\n\n```python\nd['foo'] = 42\n```\n\nTo delete\
    \ a key-value pair, use the `del` keyword.\n\n```python\ndel d['foo']\n```\n\n\
    To check if a key exists in a dictionary, use the `in` keyword.\n\n```python\n\
    d = {'foo", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter integer?\
    \ values))\n```\n\n__Do not use `type`__, but `integer?`, `float?`, `list?`, etc.\n\
    \n```racket\n#lang racket\n", "  (filter number? values))\n", "  (filter number?\
    \ values))\n", "  (filter (\u03BB (v) (integer? v)) values))\n", "  (filter (lambda\
    \ (x) (integer? x)) values))\n", "  (filter (lambda (item) (integer? item)) values))\n\
    ```\n\n```racket\n#lang racket\n", "  (filter number? values))\n", "  (filter\
    \ (lambda (x) (and (integer? x) x)) values))\n", "  (filter number? values))\n",
  "  (filter number? values))\n", "  (filter integer? values))\n", "  (filter number?\
    \ values))\n", "  (filter integer? values))\n", "  (filter (\u03BB (x) (integer?\
    \ x)) values))\n", "  (filter integer? values))\n", "  (for/list ([item values]\n\
    \             #:when (integer? item))\n    item))\n", "  (filter number? values))\n",
  "  (filter (\u03BB (value) (and (number? value) (integer? value))) values))\n",
  "  (filter (\u03BB (x) (integer? x)) values))\n", "  (filter number? values))\n",
  "  (filter number? values))\n", "  (filter number? values))\n", "  (for/list ([val\
    \ values]\n             #:when (integer? val))\n    val))\n", "  (filter integer?\
    \ values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda\
    \ (x) (integer? x)) values))\n", "  (filter number? values))\n", "  (filter integer?\
    \ values))\n", "  (filter (lambda (value) (integer? value)) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (filter (lambda (val) (integer? val))\
    \ values))\n", "  (filter integer? values))\n", "  (filter integer? values))\n",
  "  (filter integer? values))\n", "  (filter (lambda (x) (number? x)) values))\n",
  "  (filter integer? values))\n", "  (filter integer? values))\n", "  (cond\n   \
    \ [(empty? values) empty]\n    [(and (number? (first values)) (integer? (first\
    \ values)))\n     (cons (first values) (filter_integers (rest values)))]\n   \
    \ [else (filter_integers (rest values))]))\n```\n\n## Divide Integers\n\n```racket\n\
    #lang racket\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (value) (integer? value)) values))\n", "  (filter integer? values))\n\
    ```\n\n```racket\n#lang racket\n", "  (filter (lambda (value) (integer? value))\
    \ values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter integer?\
    \ values))\n", "  (filter number? values))\n", "  (filter integer? values))\n",
  "  (define (filter_integers_ iter acc)\n    (cond\n      [(empty? iter) acc]\n \
    \     [(integer? (first iter)) (filter_integers_ (rest iter) (append acc (list\
    \ (first iter))))]\n      [else (filter_integers_ (rest iter) acc)]))\n  (filter_integers_\
    \ values '()))\n", "  (cond [(null? values) '()]\n        [(integer? (car values))\
    \ (cons (car values) (filter_integers (cdr values)))]\n        [else (filter_integers\
    \ (cdr values))]))\n", "  (define (filter-rec xs)\n    (cond\n      [(empty? xs)\
    \ (quote ())]\n      [(not (integer? (first xs))) (filter-rec (rest xs))]\n  \
    \    [else (cons (first xs) (filter-rec (rest xs)))]))\n  (filter-rec values))\n",
  "  (filter integer? values))\n", "  (filter integer? values))\n", "  (filter (lambda\
    \ (x) (integer? x)) values))\n", "  (filter integer? values))\n", "  (filter integer?\
    \ values))\n```\n<div class=\"footnote\">\n  <p>Taken from <a href=\"https://docs.python.org/3/library/functions.html#filter\"\
    >Python docs</a></p>\n</div>\n\n*  \n    ```scheme\n    #lang racket\n    \n \
    \   ;; Determine if given list of values is sorted in ascending order\n    ;;\
    \ >>> is_sorted([1, 2, 3])\n    ;; True\n    ;; >>> is_sorted([3, 2, 1])\n   \
    \ ;; False\n    ;; >>> is_sorted([1, 2, 2])\n    ;; True\n    ;; >>> is_sorted([])\n\
    \    ;; True\n    ;; >>> is_sorted([1, 2, 3, 3, 3, 3, 3, 3, 4, 6, 7, 8, 9, 9])\n\
    \    ;; True\n    ;; >>> is_sorted([2, 2, 1])\n    ;; False\n    ;; >>> is_sorted([1,\
    \ 2, 3, 2])\n    ;; False\n    ;; >>> is_sorted([1, 2, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 4, 6, 7, 8, 9, 9])\n    ;; True\n    ;; >>> is_sorted([1, 2, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 4, 6, 7, 8, 9, 9, 10])\n    ;; True\n    ;; >>> is_sorted([1,\
    \ 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 6, 7, 8, 9, 9, 11])\n    ;; False\n    ;;\
    \ >>> is_sorted([1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 6, 7, 8, 9, 9, 10, 10])\n\
    \    ;; True\n    ;; >>> is_sorted([1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 6,\
    \ 7, 8, 9, 9, 10, 10, 11])\n    ;; True\n    ;; >>> is_sorted", "  (define (filter-recur\
    \ value acc)\n    (cond\n      [(empty? value) (reverse acc)]\n      [(and (number?\
    \ (first value)) (not (float? (first value))))\n       (filter-recur (rest value)\
    \ (cons (first value) acc))]\n      [else (filter-recur (rest value) acc)]))\n\
    \  (filter-recur values '()))\n", "  (filter (\u03BB (x) (integer? x)) values))\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda (value) (integer?\
    \ value)) values))\n", "  (filter (curryr is-integer?) values))\n", "  (for/list\
    \ ([v values]\n             #:when (integer? v))\n    v))\n", "  (cond\n    [(empty?\
    \ values) empty]\n    [(integer? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (filter\
    \ (lambda (v) (integer? v)) values))\n", "  (define (f values accum)\n    (if\
    \ (empty? values)\n        accum\n        (let ([curr (first values)])\n     \
    \     (if (number? curr)\n              (f (rest values) (append accum (list curr)))\n\
    \              (f (rest values) accum)))))\n  (f values '()))\n```\n\n```lisp",
  "  (remove-all\n   '()\n   (map\n    (lambda (x)\n      (if (integer? x)\n     \
    \     x\n          '()))\n    values)))\n", "  (filter number? values))\n", " \
    \ (define (is-int? val)\n    (and (not (string? val))\n         (not (list? val))\n\
    \         (not (hash? val))\n         (not (boolean? val))\n         (not (float?\
    \ val))))\n  (for/list ([value values]\n             #:when (is-int? value))\n\
    \    value))\n", "  (filter (lambda (x) (integer? x)) values))\n</code>\nWhen\
    \ I execute the script from the command-line the result is correct:\n<code>$ racket\
    \ test.rkt\n'(5)\n'(1 2 3)\n</code>\nBut when I execute it from another racket\
    \ script, the integer values are not \"carried\" over:\n<code>#lang racket\n",
  "  (filter integer? values))\n", "  (filter number? values))\n", "  (filter (lambda\
    \ (i) (and (integer? i) (not (zero? i)))) values))\n", "  (define is-integer?\
    \ (lambda (x) (and (integer? x) (not (nan? x)))))\n  (filter is-integer? values))\n",
  "  (filter (lambda (x) (integer? x)) values))\n```\n\n```py\ndef filter_integers(values):\n\
    \    return list(filter(lambda x: isinstance(x, int), values))\n```\n\n```sml\n\
    fun filter_integers xs =\n    List.filter (fn x => x = Int.toString x) xs\n```\n\
    \n## Python Snippets\n\n### map\n\n```py\ndef is_odd(n):\n    return n % 2 ==\
    \ 1\n\nnumbers = list(range(10))\nprint(list(map(is_odd, numbers)))\n```\n\n###\
    \ filter\n\n```py\ndef is_even(n):\n    return n % 2 == 0\n\nnumbers = list(range(10))\n\
    print(list(filter(is_even, numbers)))\n```\n\n### reduce\n\n```py\nfrom functools\
    \ import reduce\n\nnumbers = list(range(10))\nprint(reduce(lambda x, y: x + y,\
    \ numbers))\n```\n\n## Racket Snippets\n\n### map\n\n```racket", "  (cond [(null?\
    \ values) '()]\n        [(integer? (car values)) (cons (car values) (filter_integers\
    \ (cdr values)))]\n        [else (filter_integers (cdr values))]))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (cond [(empty? values) '()]\n    \
    \    [(and (integer? (first values)) (not (char? (first values)))) (cons (first\
    \ values) (filter_integers (rest values)))]\n        [else (filter_integers (rest\
    \ values))]))\n", "  (cond\n    [(null? values) '()]\n    [(integer? (car values))\
    \ (cons (car values) (filter_integers (cdr values)))]\n    [else (filter_integers\
    \ (cdr values))]))\n", "  (for/list ([value values]\n             #:when (integer?\
    \ value))\n    value))\n", "  (define (is-integer? value)\n    (and (number? value)\
    \ (not (exact? value))))\n  (filter is-integer? values))\n", "  (filter number?\
    \ values))\n", "  (filter integer? values))\n", "  (for/list ([v values]\n   \
    \          #:when (integer? v))\n    v))\n", "  (filter number? values))\n", " \
    \ (filter integer? values))\n", "  (filter (\u03BB (value) (integer? value)) values))\n",
  "  (define (helper ints results)\n    (cond\n      [(empty? ints) results]\n   \
    \   [(integer? (first ints)) (helper (rest ints) (append results (list (first\
    \ ints))))]\n      [else (helper (rest ints) results)]))\n  (helper values empty))\n",
  "  (filter (\u03BB (n) (integer? n)) values))\n", "  (filter integer? values))\n",
  "  (let ([integers (filter (lambda (v) (integer? v)) values)])\n    (if (empty?\
    \ integers)\n        #f\n        integers)))\n", "  (filter number? values))\n",
  "  (filter (lambda (v) (integer? v)) values))\n", "  (cond\n    [(null? values)\
    \ '()]\n    [(integer? (car values)) (cons (car values) (filter_integers (cdr\
    \ values)))]\n    [else (filter_integers (cdr values))]))\n", "  (filter integer?\
    \ values))\n", "  (filter (lambda (v) (integer? v)) values))\n", "  (filter integer?\
    \ values))\n```\n\n```racket\n#lang racket\n", "  (filter (\u03BB (value) (number?\
    \ value)) values))\n", "  (filter\n   (lambda (v) (integer? v))\n   values))\n",
  "  (filter (\u03BB (x) (integer? x)) values))\n", "  (filter integer? values))\n",
  "  (filter number? values))\n```\n\n### reduce\n```racket\n#lang racket\n", "  (filter\
    \ (\u03BB (x) (and (integer? x) x)) values))\n", "  (cond\n    [(empty? values)\
    \ empty]\n    [(integer? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (filter\
    \ (\u03BB (value) (integer? value)) values))\n", "  (cond\n    [(null? values)\
    \ '()]\n    [(integer? (car values)) (cons (car values) (filter_integers (cdr\
    \ values)))]\n    [else (filter_integers (cdr values))]))\n", "  (cond [(empty?\
    \ values) empty]\n        [(integer? (first values))\n         (cons (first values)\
    \ (filter_integers (rest values)))]\n        [else (filter_integers (rest values))]))\n",
  "  (filter (lambda (x) (integer? x)) values))\n</code>\n", "  (remove (lambda (x)\
    \ (not (integer? x))) values))\n", "  (filter (lambda (x) (and (integer? x) (positive?\
    \ x))) values))\n", "  (filter (lambda (val) (integer? val)) values))\n", "  (filter\
    \ (\u03BB (x) (and (integer? x) (not (zero? x)))) values))\n", "  (filter (lambda\
    \ (val) (integer? val)) values))\n", "  (filter number? values))\n", "  (let loop\
    \ ([values values]\n             [acc '()])\n    (cond [(empty? values)\n    \
    \       (reverse acc)]\n          [(or (integer? (first values))\n           \
    \    (fixnum? (first values)))\n           (loop (rest values)\n             \
    \    (cons (first values) acc))]\n          [else\n           (loop (rest values)\n\
    \                 acc)])))\n", "  (filter integer? values))\n```\n\n``` #lang\
    \ racket\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter number?\
    \ values))\n", "  (filter number? values))\n", "  (cond [(empty? values) empty]\n\
    \        [(integer? (first values))\n         (cons (first values) (filter_integers\
    \ (rest values)))]\n        [else (filter_integers (rest values))]))\n", "  (cond\n\
    \    [(empty? values) empty]\n    [(integer? (first values))\n     (cons (first\
    \ values) (filter_integers (rest values)))]\n    [else (filter_integers (rest\
    \ values))]))\n", "  (filter (\u03BB (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (value) (integer? value)) values))\n", "  (filter (\u03BB (v) (integer?\
    \ v)) values))\n", "  (filter number? values))\n", "  (filter integer? values))\n",
  "  (filter number? values))\n", "  (list-filter (lambda (n) (integer? n)) values))\n",
  "  (cond\n    ((null? values) '())\n    ((integer? (car values)) (cons (car values)\
    \ (filter_integers (cdr values))))\n    (else (filter_integers (cdr values)))))\n",
  "  (filter (lambda (x) (integer? x)) values))\n", "  (filter (lambda (value) (integer?\
    \ value)) values))\n", "  (filter (\u03BB (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (n) (integer? n)) values))\n", "  (for/list ([value values]\n      \
    \       #:when (integer? value))\n    value))\n", "  (define numbers (flatten\
    \ (map (lambda (x)\n                                  (if (integer? x)\n     \
    \                                 x\n                                      '()))\n\
    \                                values)))\n  (filter (lambda (n) (not (equal?\
    \ n '()))) numbers))\n", "  (filter (lambda (x) (integer? x)) values))\n", " \
    \ (filter integer? values))\n", "  (filter (lambda (x) (number? x)) values))\n",
  "  (cond\n    [(empty? values) empty]\n    [(integer? (first values))\n     (cons\
    \ (first values) (filter_integers (rest values)))]\n    [else (filter_integers\
    \ (rest values))]))\n", "  (filter integer? values))\n", "  (filter number? values))\n",
  "  (filter integer? values))\n", "  (filter (\u03BB (x) (integer? x)) values))\n",
  "  (filter (lambda (val) (integer? val)) values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (filter integer? values))\n", "  (cond\n    [(empty? values)\
    \ empty]\n    [(integer? (first values))\n     (cons (first values) (filter_integers\
    \ (rest values)))]\n    [else (filter_integers (rest values))]))\n", "  (filter\
    \ (\u03BB (x) (integer? x)) values))\n", "  (define (f-i values)\n    (cond\n\
    \      [(null? values) '()]\n      [(integer? (car values)) (cons (car values)\
    \ (f-i (cdr values)))]\n      [else (f-i (cdr values))]))\n  (f-i values))\n",
  "  (define (is_integer? value)\n    (integer? value))\n  (filter is_integer? values))\n",
  "  (let loop ([list-values values]\n             [list-result '()])\n    (cond [(empty?\
    \ list-values) (reverse list-result)]\n          [(integer? (first list-values))\n\
    \           (loop (rest list-values)\n                 (cons (first list-values)\
    \ list-result))]\n          [else (loop (rest list-values) list-result)])))\n\
    ```\n\n### Solution using map and filter\n\n```racket\n#lang racket\n", "  (filter\
    \ integer? values))\n", "  (filter (lambda (v) (integer? v)) values))\n", "  (filter\
    \ (lambda (x) (integer? x)) values))\n", "  (filter (\u03BB (x) (integer? x))\
    \ values))\n", "  (map (lambda (e)\n         (cond\n           [(integer? e) e]\n\
    \           [else false]))\n       values))\n", "  (filter number? values))\n",
  "  (filter integer? values))\n", "  (filter (\u03BB (x) (and (number? x) (integer?\
    \ x))) values))\n", "  (filter (lambda (x) (integer? x)) values))\n", "  (filter\
    \ (lambda (value) (integer? value)) values))\n", "  (filter (lambda (x) (integer?\
    \ x)) values))\n", "  (cond [(empty? values) '()]\n        [(integer? (first values))\n\
    \         (cons (first values) (filter_integers (rest values)))]\n        [else\
    \ (filter_integers (rest values))]))\n", "  (filter (\u03BB (value) (integer?\
    \ value)) values))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
