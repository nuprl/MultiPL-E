name: HumanEval_117_select_words
language: rkt
prompt: "#lang racket\n\n;; Given a string s and a natural number n, you have been\
  \ tasked to implement \n;; a function that returns a list of all words from string\
  \ s that contain exactly \n;; n consonants, in order these words appear in the string\
  \ s.\n;; If the string s is empty then the function should return an empty list.\n\
  ;; Note: you may assume the input string contains only letters and spaces.\n;; Examples:\n\
  ;; select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n;; select_words(\"\
  Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n;; select_words(\"simple\
  \ white space\", 2) ==> []\n;; select_words(\"Hello world\", 4) ==> [\"world\"]\n\
  ;; select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n(define (select_words s n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 4) (list \"little\"))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\"\
  ))\n    (check-equal? (candidate \"simple white space\" 2) (list ))\n    (check-equal?\
  \ (candidate \"Hello world\" 4) (list \"world\"))\n    (check-equal? (candidate\
  \ \"Uncle sam\" 3) (list \"Uncle\"))\n    (check-equal? (candidate \"\" 4) (list\
  \ ))\n    (check-equal? (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"\
  f\"))\n))\n\n(test-humaneval)"
completions: ["  (for/list ([word (in-string s)]\n             #:when (= n (consonants\
    \ word)))\n    word))\n", "  (unless (string=? s \"\")\n    (let ([n-cons s])\n\
    \      (for/list ([w (in-list (string-split s))])\n        (when (= n (word-consonants\
    \ w))\n          w)))))\n", "  (define (only-spaces? s)\n    (andmap (lambda (c)\
    \ (char=? c #\\space)) s))\n  (define (consonants s)\n    (count (lambda (c)\n\
    \             (not (char-ci=? c #\\a) (char-ci=? c #\\e)\n                  (char-ci=?\
    \ c #\\i) (char-ci=? c #\\o)\n                  (char-ci=? c #\\u))) s))\n  (define\
    \ (select-helper s n)\n    (if (empty? s) empty\n        (if (= n (consonants\
    \ (car s)))\n            (cons (car s) (select-helper (cdr s) n))\n          \
    \  (select-helper (cdr s) n))))\n  (if (only-spaces? s) empty\n      (select-helper\
    \ (string-split s) n)))\n", "  (define (num-consonants s)\n    (length (regexp-match\
    \ #rx\"[b-df-hj-np-tv-z]\" s)))\n  (for/list ([word (in-list (string-split s))]\n\
    \             #:when (= n (num-consonants word)))\n    word))\n```\n\n```\n#lang\
    \ racket\n", "  (if (zero? (string-length s))\n      empty\n      (if (equal?\
    \ n (count-consonants (first (string-split s))))\n          (cons (first (string-split\
    \ s)) (select_words (string-trim (first (rest (string-split s)))) n))\n      \
    \    (select_words (string-trim (first (rest (string-split s)))) n))))\n", " \
    \ (if (empty? s) empty\n      (for/list ([w (in-list (string-split s))]\n    \
    \             #:when (= n (list-length (filter (compose not vowel?) w))))\n  \
    \      w)))\n", "  (regexp-match* #rx(#:anchor-begin #:anchor-end \n         \
    \             #:min-repeat (in-range n (max-length #f))\n                    \
    \  \"([^aeiou ])\" )\n                 s))\n", "  (define (is_vowel c)\n    (member\
    \ c (list #\\a #\\e #\\i #\\o #\\u)))\n  (define (has-n-consonants? w n)\n   \
    \ (if (string-empty? w)\n        (= n 0)\n        (if (is_vowel (string-ref w\
    \ 0))\n            (has-n-consonants? (substring w 1) n)\n            (has-n-consonants?\
    \ (substring w 1) (- n 1)))))\n  (define (select-words-h s n acc)\n    (if (string-empty?\
    \ s)\n        acc\n        (if (has-n-consonants? (string-take-while (lambda (c)\
    \ (not (char=? c #\\space))) s) n)\n            (select-words-h (string-drop-while\
    \ (lambda (c) (not (char=? c #\\space))) s) n (cons (string-take-while (lambda\
    \ (c) (not (char=? c #\\space))) s) acc))\n            (select-words-h (string-drop-while\
    \ (lambda (c) (not (char=? c #\\space))) s) n acc))))\n  (reverse (select-words-h\
    \ s n '())))\n", "  (define (is-consonant? c)\n    (cond [(member c '(\"a\" \"\
    e\" \"i\" \"o\" \"u\")) #f]\n          [else #t]))\n  (define (is-n-consonants?\
    \ s n)\n    (if (empty? s)\n        (= n 0)\n        (if (is-consonant? (first\
    \ s))\n            (is-n-consonants? (rest s) (- n 1))\n            (is-n-consonants?\
    \ (rest s) n))))\n  (define (select_words_helper s n words-so-far)\n    (if (empty?\
    \ s)\n        words-so-far\n        (if (is-n-consonants? (first s) n)\n     \
    \       (select_words_helper (rest s) n (cons (first s) words-so-far))\n     \
    \       (select_words_helper (rest s) n words-so-far))))\n  (select_words_helper\
    \ (string-split s) n '()))\n", "  (define (select_words' s n idx)\n    (let ([c\
    \ (char-downcase (string-ref s idx))])\n      (cond [(char=? c #\\ ) (select_words'\
    \ s n (+ idx 1))]\n            [(member c \"aeiou\") (select_words' s n (+ idx\
    \ 1))]\n            [(< n 1) (cons (substring s 0 idx) (select_words' s n (+ idx\
    \ 1)))]\n            [else (select_words' s (- n 1) (+ idx 1))])))\n  (select_words'\
    \ s n 0))", "  (for/list ([word (in-string s)]\n             #:when (and (string-contains\
    \ word #\\space)\n                         (= n (number-of-consonants word))))\n\
    \    word))\n", "  (define (is-constant ch)\n    (or (equal? #\\b ch)\n      \
    \  (equal? #\\c ch)\n        (equal? #\\d ch)\n        (equal? #\\f ch)\n    \
    \    (equal? #\\g ch)\n        (equal? #\\h ch)\n        (equal? #\\j ch)\n  \
    \      (equal? #\\k ch)\n        (equal? #\\l ch)\n        (equal? #\\m ch)\n\
    \        (equal? #\\n ch)\n        (equal? #\\p ch)\n        (equal? #\\q ch)\n\
    \        (equal? #\\r ch)\n        (equal? #\\s ch)\n        (equal? #\\t ch)\n\
    \        (equal? #\\v ch)\n        (equal? #\\w ch)\n        (equal? #\\x ch)\n\
    \        (equal? #\\y ch)\n        (equal? #\\z ch)))\n  (define (count-constants\
    \ word)\n    (for/fold ([count 0]) ([ch (in-string word)])\n      (if (is-constant\
    \ ch)\n          (+ count 1)\n          count)))\n  (filter (\u03BB (word) (=\
    \ n (count-constants word)))\n          (string-split s #\\space)))", "  (cond\n\
    \    [(empty? s) empty]\n    [(= n 0) (list (first s))]\n    [else (append (select_words\
    \ (rest s) (- n 1))\n                  (select_words (rest s) n))]))\n```\n\n\
    ## My version\n```\n#lang racket\n", "  (cond\n    [(empty? s) empty]\n    [(zero?\
    \ n) empty]\n    [else\n     (cond\n       [(consonant? (string-ref s 0))\n  \
    \      (define s-rest (string-drop s 1))\n        (cond\n          [(select_words\
    \ s-rest (sub1 n)) (cons (word s n) (select_words s-rest (sub1 n)))]\n       \
    \   [else empty])]\n       [else\n        (define s-rest (string-drop s 1))\n\
    \        (cond\n          [(select_words s-rest n) (select_words s-rest n)]\n\
    \          [else empty])])]))\n", "  (define (is_vowel c)\n    (member c '(\"\
    a\" \"e\" \"i\" \"o\" \"u\" \"y\")))\n  (define (words s)\n    (regexp-match*\
    \ #rx\"\\S+\" s))\n  (define (counts-consonants w)\n    (for/fold ([count 0])\
    \ ([c (in-string w)])\n      (if (is_vowel c)\n          count\n          (add1\
    \ count))))\n  (for/list ([w (in-list (words s))]\n             #:when (= n (counts-consonants\
    \ w)))\n    w))\n```\n\n```racket\n#lang racket", "  (let\n    ([words (string-split\
    \ s #\\space)]\n     [vowels (string-&gt;list \"aeiou\")])\n    (let loop ([words\
    \ words] [res '()])\n      (if (null? words)\n          res\n          (let\n\
    \            ([word (car words)]\n             [ncons (length (for/list ([ch (in-string\
    \ word)])\n                               (if (member ch vowels)\n           \
    \                        '()\n                                   (list ch))))])\n\
    \            (if (= n ncons)\n                (loop (cdr words) (cons word res))\n\
    \                (loop (cdr words) res)))))))\n", "  (cond [(empty? s) empty]\n\
    \        [(= (string-length s) 1) empty]\n        [else (regexp-match* #rx(#\"\
    \ +\") s)]))\n```\n\n### [19] Write a function `interval-list` which accepts two\
    \ numbers (as strings)\n```scheme\n#lang racket\n", "  (define (count s)\n   \
    \ (length (regexp-match #rx\"[^aeiou ]\" s)))\n  (define (filter l n)\n    (filter\
    \ (lambda (w) (= (count w) n)) l))\n  (filter (regexp-match-positions #rx\"[a-zA-Z]+\"\
    \ s) n))\n", "  (if (empty? s)\n      '()\n      (let ([words (string-split s\
    \ #\\space)])\n        (remove (lambda (word)\n                  (not (= n (count-consonants\
    \ word))))\n                words))))\n", "  (if (string=? s \"\")\n      '()\n\
    \      (let* ([word (regexp-match #rx\"^[a-zA-Z]+\" s)]\n             [consonants\
    \ (string-filter (lambda (x) (not (member x '(\"a\" \"e\" \"i\" \"o\" \"u\"))))\
    \ (car word))])\n        (if (= (string-length consonants) n)\n            (cons\
    \ (car word) (select_words (string-drop s (string-length (car word))) n))\n  \
    \          (select_words (string-drop s (string-length (car word))) n)))))\n",
  "  (map first\n       (filter (lambda (w) (= n (length (regexp-match #rx\"[^aeiouyAEIOUY\
    \ ]\" w))))\n               (regexp-match #rx\"[^ ]+\" s))))\n", "  (cond [(string=?\
    \ s \"\") (list)]\n        [else (let ((word (car (string-split s))))\n      \
    \          (if (= n (count-consonants word))\n                    (cons word (select_words\
    \ (string-tail s (string-length word)) n))\n                    (select_words\
    \ (string-tail s (string-length word)) n)))]))\n", "  (cond\n    [(string=? s\
    \ \"\") '()]\n    [else\n     (let ([w (string-take-while (lambda (c) (char-alphabetic?\
    \ c)) s)])\n       (cond\n         [(string=? w \"\") (select_words (string-drop-while\
    \ (lambda (c) (char-alphabetic? c)) s) n)]\n         [(= n (count-consonants w))\
    \ (cons w (select_words (string-drop-while (lambda (c) (char-alphabetic? c)) s)\
    \ n))]\n         [else (select_words (string-drop-while (lambda (c) (char-alphabetic?\
    \ c)) s) n)]))]))\n", "  (cond ((string=? s \"\") '())\n        ((number=? n 0)\
    \ '())\n        ((number=? n 1) (remove-duplicates (split s \" \")))\n       \
    \ (else (remove-duplicates (filter\n                (lambda (x) (number=? (count-consonants\
    \ x) n))\n                (split s \" \"))))))\n", "  (split-at (s s) #\\ ))\n\
    </code>\nI get an error on the line <code>(define (select_words s n)</code> saying:\
    \ <code>application: not a procedure;</code>\nAnd here is the link for the question\n\
    This is part of this assignment. I am supposed to make all the functions in the\
    \ module and then I will be able to make the <code>select_words</code> function.\
    \ \nI have made all the other functions but I am not sure what I am doing wrong\
    \ here.\n\n\nA:\n\nThere's a conflict between the <code>s</code> variable used\
    \ in the function and the racket/string library. My advice would be to use a different\
    \ variable name, like <code>str</code> - but that's just a suggestion, you can\
    \ use whatever name you like.\n<code>(define (select_words str n)\n  (split-at\
    \ (s str) #\\ ))\n</code>\n", "  (define (word-n-cons s)\n    (let ([cs (filter\
    \ cons? (string->list s))])\n      (and (positive? (length cs)) (= n (length cs)))))\n\
    \  (filter word-n-cons (regexp-split #rx\"\\s+\" s)))\n", "  (define (is-vowel\
    \ c)\n    (or (equal? c #\\a)\n        (equal? c #\\e)\n        (equal? c #\\\
    i)\n        (equal? c #\\o)\n        (equal? c #\\u)))\n  (define (is-consonant\
    \ c)\n    (and (char-alphabetic? c)\n         (not (is-vowel c))))\n  (define\
    \ (num-consonants w)\n    (apply + (map (\u03BB (c) (if (is-consonant c) 1 0))\
    \ (string->list w))))\n  (define (all-words s)\n    (string-split s #\\space))\n\
    \  (define (filter-consonants ws n)\n    (filter (\u03BB (w) (= (num-consonants\
    \ w) n)) ws))\n  (filter-consonants (all-words s) n))\n```\n\n```racket\n#lang\
    \ racket\n", "  (cond\n    [(empty? s) '()]\n    [(= (count-vowels (first s))\
    \ n) (cons (first s) (select_words (rest s) n))]\n    [else (select_words (rest\
    \ s) n)]))", "  (define (cons_count str)\n    (cond ((empty? str) 0)\n       \
    \   ((member (first str) '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\\
    n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)) (+ 1 (cons_count (rest str))))\n\
    \          (else (cons_count (rest str)))))\n  (define (extract_words str)\n \
    \   (if (empty? str) '()\n        (cons (first (regexp-match #rx\"^[a-zA-Z]+\"\
    \ str)) (extract_words (rest (regexp-match #rx\"\\s[a-zA-Z]+\" str))))))\n  (define\
    \ (cons_words words)\n    (cond ((empty? words) '())\n          ((= n (cons_count\
    \ (first words))) (cons (first words) (cons_words (rest words))))\n          (else\
    \ (cons_words (rest words)))))\n  (cons_words (extract_words s)))", "  (if (eq?\
    \ s \"\") '()\n      (let ([w (string-tokenize s)])\n        (if (eq? (vowel-count\
    \ (first w)) n)\n            (cons (first w) (select_words (string-join (rest\
    \ w) \" \") n))\n            (select_words (string-join (rest w) \" \") n)))))\n",
  "  (regexp-match* #rx\"\\w+\" s)\n  (filter (lambda (e) (= n (consonants e))) (regexp-match*\
    \ #rx\"\\w+\" s)))\n", "  (define (is_vowel? c)\n    (or (char=? c #\\a)\n   \
    \     (char=? c #\\e)\n        (char=? c #\\i)\n        (char=? c #\\o)\n    \
    \    (char=? c #\\u)))\n  (define (count_cons c)\n    (if (is_vowel? c)\n    \
    \    0\n        1))\n  (define (count_consonants cs)\n    (if (empty? cs)\n  \
    \      0\n        (+ (count_cons (first cs))\n           (count_consonants (rest\
    \ cs)))))\n  (map\n   (\u03BB (s) (symbol->string s))\n   (filter\n    (\u03BB\
    \ (s) (= n (count_consonants (string->symbol s))))\n    (string-split s #\\space))))",
  "  (regexp-match* #rx(#,(string-append \"\\\\b[^aeiou ]{\\\\b\" n \"\\\\b}\\\\b\"\
    ) s)\n                 s))", "  (if (string=? \"\" s)\n      '()\n      (let*\
    \ ([words (string-split s)]\n             [select (filter (lambda (w)\n      \
    \                         (= n\n                                  (for/sum ([x\
    \ (in-string w)])\n                                           (if (not (char-vowel?\
    \ x)) 1 0))))\n                             words)])\n        select)))", "  (define\
    \ vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (define (count-consonants word)\n   \
    \ (if (empty? word) 0\n      (if (member (first word) vowels)\n          (count-consonants\
    \ (rest word))\n          (+ 1 (count-consonants (rest word))))))\n  (define (scan-string\
    \ word result)\n    (if (empty? word) result\n      (let ((next-word (string-split\
    \ word #\\space)))\n        (if (= n (count-consonants (first next-word)))\n \
    \           (scan-string (string-join (rest next-word) #\\space)\n           \
    \              (append result (list (first next-word))))\n            (scan-string\
    \ (string-join (rest next-word) #\\space) result)))))\n  (scan-string s (list)))\n",
  "  (define (cons? c)\n    (member c '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\"\
    \ \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"z\"\
    )))\n  (define (cons-count lst)\n    (define (inner n c)\n      (if (null? c)\
    \ n\n          (if (cons? (car c)) (inner (+ n 1) (cdr c)) (inner n (cdr c)))))\n\
    \    (inner 0 lst))\n  (define (inner lst out)\n    (if (null? lst) (reverse out)\n\
    \        (let ((cc (cons-count (string->list (car lst)))))\n          (if (= cc\
    \ n) (inner (cdr lst) (cons (car lst) out)) (inner (cdr lst) out)))))\n  (inner\
    \ (string-split s) '()))\n", "  (if (or (= n 0) (string=? s \"\"))\n      '()\n\
    \      (let ((word (car (string-split s #\\space))))\n        (if (= n (count-consonants\
    \ word))\n            (cons word (select_words (string-trim #\\space s) n))\n\
    \            (select_words (string-trim #\\space s) n)))))\n", "  (define (is-consonant\
    \ c)\n    (not (member c '(#\\a #\\e #\\i #\\o #\\u))))\n  (define (count-consonants\
    \ word)\n    (cond [(zero? (string-length word)) 0]\n          [(is-consonant\
    \ (string-ref word 0))\n           (+ 1 (count-consonants (substring word 1)))]\n\
    \          [else (count-consonants (substring word 1))]))\n  (define (select-words-helper\
    \ s n res)\n    (cond [(empty? s) res]\n          [(= n (count-consonants (car\
    \ s)))\n           (select-words-helper (cdr s) n (cons (car s) res))]\n     \
    \     [else (select-words-helper (cdr s) n res)]))\n  (reverse (select-words-helper\
    \ (string-split s #\\space) n empty)))\n```\n\n### 7. Number Suffix\n\n```racket\n\
    #lang racket\n", "  (for/list ([word (in-string s)]\n             #:when (equal?\
    \ n (count-const n word)))\n    word))\n", "  (if (string=? s \"\")\n      '()\n\
    \      (list-match (string-split s #\\space) n)))\n", "  (if (empty? s)\n    \
    \  empty\n      (remove-if (compose not \n                          (compose equal?\
    \ n \n                                  (compose length (regexp-match #rx\"^[^aeiouAEIOU]+$\"\
    ))))\n                 (regexp-match #rx\"[a-zA-Z]+\" s))))\n```\n\n```racket\n\
    #lang racket\n", "  (let loop ([s s] [words '()])\n    (cond [(string=? s \"\"\
    ) (reverse words)]\n          [(equal? n (count-consonants (first (string-split\
    \ s #\\space))))\n           (loop (second (string-split s #\\space))\n      \
    \           (cons (first (string-split s #\\space)) words))]\n          [else\
    \ (loop (second (string-split s #\\space)) words)])))\n", "  (if (equal? s \"\"\
    )\n      '()\n      (if (equal? (count-consonants (first (string-split s #\\space)))\
    \ n)\n          (cons (first (string-split s #\\space)) (select_words (string-split\
    \ s #\\space (rest (string-split s #\\space))) n))\n          (select_words (string-split\
    \ s #\\space (rest (string-split s #\\space))) n))))\n", "  (cond ((string=? s\
    \ \"\") empty)\n        ((= (count-consonants (string-&gt;list (string-trim s)))\
    \ n)\n         (cons (string-trim s) empty))\n        (else (select_words (rest\
    \ s) n))))\n", "  (let loop ([s s] [r '()])\n    (cond [(or (empty? s) (empty?\
    \ r)) r]\n          [(consonants s)\n           (let ([w (regexp-split #rx\" \"\
    \ s)])\n             (if (= n (consonants (car w)))\n                 (loop (string-join\
    \ (cdr w) \" \") (cons (car w) r))\n                 (loop (string-join (cdr w)\
    \ \" \") r)))]\n          [else (loop (regexp-replace #rx\" \" s \"\") r)])))\n",
  "  (if (string=? s \"\") '()\n      (let ((word (car (regexp-match #rx\"[A-Za-z]+\"\
    \ s))))\n        (cons word (select_words (substring s (add1 (string-length word)))\
    \ n)))))", "  (let* ([words (string-split s \" \")]\n         [filter (\u03BB\
    \ (word) (equal? n (count-consonants word)))]\n         [wordss (filter words\
    \ filter)])\n    wordss))\n", "  (cond\n    [(string=? s \"\") empty]\n    [else\n\
    \     (define L (string-split s #\\space))\n     (define R (filter (lambda (x)\
    \ (= n (word-consonants x))) L))\n     R]))\n", "  (regexp-match* #rx(word:\\\
    ([a-z]+\\) consonants:([^aeiou]*))\n                 s (\u03BB (word consonants)\n\
    \                     (if (= (string-length consonants) n)\n                 \
    \        (list word)\n                         '()))))\n\n", "  (cond\n    [(string=?\
    \ s \"\") empty]\n    [else\n     (filter (lambda (w)\n               (= n (consonants\
    \ w)))\n             (string-split s #\\space))]))\n", "  (define (is-vowel c)\n\
    \    (or (char=? #\\a c)\n        (char=? #\\e c)\n        (char=? #\\i c)\n \
    \       (char=? #\\o c)\n        (char=? #\\u c)))\n  (define (word-consonants\
    \ w)\n    (define (word-consonants w)\n      (cond ((empty? w) 0)\n          \
    \  ((is-vowel (first w)) (word-consonants (rest w)))\n            (else (+ 1 (word-consonants\
    \ (rest w))))))\n    (word-consonants (string->list w)))\n  (define (words s)\n\
    \    (define (words str)\n      (cond ((empty? str) (list (string-trim (list->string\
    \ s))))\n            ((char=? #\\  (first str)) (cons (string-trim (list->string\
    \ s)) (words (rest str))))\n            (else (words (rest str)))))\n    (words\
    \ (string->list s)))\n  (define (filter-words ws)\n    (cond ((empty? ws) (list))\n\
    \          ((= n (word-consonants (first ws))) (cons (first ws) (filter-words\
    \ (rest ws))))\n          (else (filter-words (rest ws)))))\n  (filter-words (words\
    \ s)))\n```\n\n```racket\n#lang racket\n", "  (if (string=? s \"\")\n      '()\n\
    \      (define (word-contains-n-consonants word n)\n        (cond [(equal? n 0)\
    \ true]\n              [(consonant? (string-ref word 0)) (word-contains-n-consonants\
    \ (substring word 1) (- n 1))]\n              [else (word-contains-n-consonants\
    \ (substring word 1) n)]))\n      (define (consonant? c)\n        (not (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))))\n      (define (select_words1 s n l)\n    \
    \    (if (string=? s \"\")\n            l\n            (define word (substring\
    \ s 0 (string-index s #\\space)))\n            (if (word-contains-n-consonants\
    \ word n)\n                (select_words1 (substring s (+ (string-length word)\
    \ 1)) n (cons word l))\n                (select_words1 (substring s (+ (string-length\
    \ word) 1)) n l))))\n      (select_words1 s n '())))\n", "  (map cdr\n       (filter\
    \ (lambda (e) (= n (car e)))\n               (map (lambda (w) (cons (word-num-of-consonants\
    \ w) w))\n                    (split (regexp #rx\" \") s)))))\n", "  (filter (lambda\
    \ (x) (equal? n (char-count x #\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\\
    m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z))) (string-split s)))\n\
    </code>\nThis code above does not work as expected because <code>char-count</code>\
    \ does not count any of the consonants that are given in the example.\n<code>char-count</code>\
    \ only counts these letters: <code>b</code>, <code>k</code>, <code>t</code> and\
    \ <code>v</code>.\nWhat am I doing wrong?\n\n\nA:\n\nFirst, <code>char-count</code>\
    \ counts individual chars, it doesn't take a string of chars as an argument. Second,\
    \ <code>char-count</code> takes a string and a char, the second arg should be\
    \ a char, not a list of chars.\n<code>(define (select_words s n)\n  (filter (lambda\
    \ (x) (equal? n (char-count x #\\b))\n                 (char-count x #\\c))\n\
    \                 (char-count x #\\d))\n                 (char-count x #\\f))\n\
    \                 (char-count x #\\g))\n                 (char-count x #\\h))\n\
    \                 (char-count x #\\j))\n                 (char-count x #\\k))\n\
    \                 (char-count x #\\l))\n                 (char-count x #\\m))\n\
    \                 (char-count x #\\n))\n                 (char-count x #\\p))\n\
    \                 (char-count x #\\q))\n                 (char-count x #\\r))\n\
    \                 (char-count x #\\s))\n                 (char-count x #\\t))\n\
    \                 (char-count x #\\v))\n                 (char-count x #\\w))\n\
    \                 (char-count x #\\x))\n                 (char-count x #\\y))\n\
    \                 (char-count x #\\z)))\n          (string-split s)))\n</code>\n\
    A better way", "  (let ([w (regexp-match #rx\"\\w+\" s)])\n    (map (lambda (w)\
    \ (list-ref w 0))\n         (filter (lambda (w) (= n (consonants (list-ref w 0))))\n\
    \                 (for/list ([w w]) w)))))\n", "  (cond\n    [(empty? s) empty]\n\
    \    [(equal? n (count-consonants (first (tokenize s #\\space))))\n     (cons\
    \ (first (tokenize s #\\space)) (select_words (second (tokenize s #\\space)) n))]\n\
    \    [else (select_words (second (tokenize s #\\space)) n)]))\n", "  (cond [(empty?\
    \ s) empty]\n        [(= n (count-consonants (car (string-split s #\\space))))\n\
    \         (append (select_words (cdr (string-split s #\\space)) n)\n         \
    \        (list (car (string-split s #\\space))))]\n        [else (select_words\
    \ (cdr (string-split s #\\space)) n)]))", "  (cond [(empty? s) empty]\n      \
    \  [(= n (count-consonants (string-trim s)))\n         (list (string-trim s))]\n\
    \        [else (select_words (rest s) n)]))\n", "  (regexp-match* #rx(#:line-start\n\
    \                      (? #:word\n                         (: #:vowel #:non-word)\n\
    \                         #:word{n}\n                         (: #:non-word #:vowel)\n\
    \                         #:word)\n                      #:line-end)\n       \
    \          s))\n", "  (map (\u03BB (l) (substring l 0 (sub1 (string-length l))))\n\
    \       (filter (\u03BB (l) (= n (filter (compose not char-alphabetic?) l)))\n\
    \               (split (compose string-length not) s))))\n</code>\nWhich one of\
    \ the above two would be preferred in your opinion?\n\n\nA:\n\nI think both answers\
    \ are fine, and in fact there's a lot of common ground between them, but I have\
    \ a few observations.\nFirst, you can safely replace the list of vowels <code>'(#\\\
    a #\\e #\\i #\\o #\\u)</code> with a string <code>\"aeiou\"</code>, it's more\
    \ natural in Racket.\nSecond, I find the solution with <code>string-contains</code>\
    \ to be clearer. It makes it very explicit what the goal of the procedure is,\
    \ and it makes the use of <code>filter</code> no longer necessary.\nThird, I find\
    \ it a bit strange that the solution based on <code>string-contains</code> uses\
    \ <code>string-length</code> to extract words from the input string, while the\
    \ solution based on <code>filter</code> uses <code>substring</code>. I think they\
    \ could be unified.\nFourth, instead of using <code>map</code> and <code>split</code>\
    \ as two steps, you can use a single <code>regexp-split</code> to extract the\
    \ words.\nFinally, instead of using <code>substring</code> to strip the last character,\
    \ you can use <code>string-drop-right</code> instead.\nWith that in mind, a modification\
    \ of the second solution would be like this:\n<code>(define (select-words str\
    \ n)\n  (filter (\u03BB (w)\n            (= n\n               (for/sum ([c (in-string\
    \ w)])\n                 (not (char-alphabetic? c)))))\n          (regexp-split\
    \ #rx\"\\s+\" str)))\n</code>\n", "  (if (string=? s \"\")\n      '()\n      (define\
    \ s-words (string-split s #\\space))\n      (define consonants (list #\\b #\\\
    c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\\
    w #\\x #\\y #\\z))\n      (define (count-consonants word)\n        (define (count-consonants-h\
    \ word count)\n          (if (string-empty? word)\n              count\n     \
    \         (define cc (if (char-member? (string-ref word 0) consonants) 1 0))\n\
    \              (count-consonants-h (substring word 1) (+ count cc))))\n      \
    \  (count-consonants-h word 0))\n      (define (match word)\n        (if (equal?\
    \ (count-consonants word) n)\n            (list word)\n            '()))\n   \
    \   (map match s-words)))\n", "  (for/list ([word (in-string s)])\n    (if (=\
    \ n (count-consonants word))\n        word)))\n", "  (regexp-match* #rx{(\\w+)(?{\n\
    \      (define word (list-ref (match:substrings (current-input-port)) 1))\n  \
    \    (and (= n (count-vowels word))\n           (list word))})} s))\n", "  (if\
    \ (= n 0)\n      (if (string=? s \"\")\n          '()\n          (list s))\n \
    \     (let ([all-conso (get-conso (string->list s))])\n        (if (empty? all-conso)\n\
    \            '()\n            (map\n             (lambda (x)\n               (list->string\
    \ x))\n             (filter\n              (lambda (x)\n                (= n (length\
    \ x)))\n              all-conso))))))\n", "  (define (is_consonant c)\n    (member\
    \ c (list #\\B #\\C #\\D #\\F #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\\
    R #\\S #\\T #\\V #\\W #\\X #\\Y #\\Z)))\n  (define (to_list str)\n    (let ([slen\
    \ (string-length str)])\n      (define (loop i result)\n        (if (= i slen)\n\
    \            result\n            (let ([ch (string-ref str i)])\n            \
    \  (if (char-alphabetic? ch)\n                  (loop (+ i 1) (cons (char-downcase\
    \ ch) result))\n                  (loop (+ i 1) result)))))\n      (loop 0 '())))\n\
    \  (define (count_consonants lst)\n    (define (loop lst)\n      (if (null? lst)\n\
    \          0\n          (if (is_consonant (car lst))\n              (+ 1 (loop\
    \ (cdr lst)))\n              (loop (cdr lst)))))\n    (loop lst))\n  (define (select_words-iter\
    \ slst nlst)\n    (if (null? slst)\n        '()\n        (let ([w (car slst)]\n\
    \              [c (car nlst)])\n          (if (= c n)\n              (cons w (select_words-iter\
    \ (cdr slst) (cdr nlst)))\n              (select_words-iter (cdr slst) (cdr nlst))))))\n\
    \  (let ([lst (to_list s)])\n    (select_words-iter (split lst) (map count_consonants\
    \ (split lst)))))\n", "  (cond\n    [(empty? s) empty]\n    [(= n (count-consonants\
    \ (first s)))\n     (cons (first s) (select_words (rest s) n))]\n    [else (select_words\
    \ (rest s) n)]))\n", "  (select_words_helper s n (string-split s #\\space)))\n",
  "  (filter\n   (lambda (x)\n     (= (length (filter (lambda (y)\n              \
    \            (or (= y #\\a) (= y #\\e) (= y #\\i) (= y #\\o) (= y #\\u)))\n  \
    \                      (list->string x)))\n        n))\n   (regexp-split #rx\"\
    \\s+\" s)))\n", "  (remove-if (\u03BB (w) (not (= n (vowels-and-consonants-count\
    \ s)))) (string-split s)))\n", "  (let*\n      ([vowels #\\a #\\e #\\i #\\o #\\\
    u #\\A #\\E #\\I #\\O #\\U]\n       [consonants (for/list ([letter (in-string\
    \ s)])\n                     (unless (member letter vowels) letter))]\n      \
    \ [word (first (regexp-match #rx\"\\w+\" s))]\n       [words (if (null? word)\
    \ '() (cons word (select_words (substring s (add1 (string-length word)))))])]\n\
    \       [consonant-counts (for/list ([word words])\n                         \
    \ (length (regexp-match #rx\"[^aeiou]\" word)))])\n    (for/list ([word (in-list\
    \ words)]\n               [count (in-list consonant-counts)])\n      (if (= count\
    \ n)\n          word))))\n", "  (foldl (lambda (w words)\n           (if (= n\
    \ (consonants-in w))\n               (cons w words)\n               words))\n\
    \         '()\n         (string-split s #\\space)))\n", "  (define (getWords s)\n\
    \    (regexp-match* #rx\"([a-zA-Z]+)\" s))\n  (define (filterWords words n)\n\
    \    (cond [(empty? words) '()]\n          [(= n (countConsonants (first words)))\
    \ (cons (first words) (filterWords (rest words) n))]\n          [else (filterWords\
    \ (rest words) n)]))\n  (filterWords (getWords s) n))\n", "  (if (empty? s)\n\
    \      empty\n      (let* ([words (in-list (string-split s #\\space))]\n     \
    \        [words-with-n-consonants (filter\n                                  \
    \     (lambda (word)\n                                         (= n (length (filter\
    \ (compose not vowel?) word))))\n                                       words)])\n\
    \        words-with-n-consonants)))\n", "  (cond\n    [(empty? s) '()]\n    [(=\
    \ n (count-consonants (first s))) (cons (first s) (select_words (rest s) n))]\n\
    \    [else (select_words (rest s) n)]))", "  (define (consonant? c)\n    (member\
    \ c '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\"\
    \ \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n  (define (consonants\
    \ n w)\n    (if (empty? w) n\n        (if (consonant? (first w)) (consonants (+\
    \ n 1) (rest w))\n            (consonants n (rest w)))))\n  (define (select-words\
    \ n l)\n    (if (empty? l) '()\n        (if (= n (consonants 0 (first l))) (cons\
    \ (first l) (select-words n (rest l)))\n            (select-words n (rest l)))))\n\
    \  (select-words n (string-split s)))\n</code>\nI am wondering if it can be done\
    \ in a more Racket-like way, without so many helper functions.\nAlso, if my current\
    \ way is the best, then I am wondering how to get rid of the <code>define</code>s\
    \ and replace them with <code>let</code>s.\nIf you know of a better way, that\
    \ is what I am interested in.\n\n\nA:\n\nYou have a lot of work ahead of you if\
    \ you want to write this in a more Racket-like way.\nI know you are new to Racket,\
    \ so I will not judge you for writing this kind of code, and I will not ask for\
    \ a rewrite of your code. But I will help you understand the Racket way better,\
    \ so that if you want to, you can rewrite your code.\nLet's go through it step\
    \ by step.\nFirst, your <code>consonant?</code> function is using <code>member</code>.\
    \ Racket has a string membership function that uses a regexp match under the hood:\n\
    <code>(define (consonant? c)\n  (string-match #rx\"[bcdfghjklmnpqrstvwxyz]\" c))\n\
    </code>\nI am not going to go into the details of the regexp here (see the documentation\
    \ of string-match for that),", "  (cond\n    [(empty? s) '()]\n    [(= (count-const\
    \ s) n) (cons (take-word s) (select_words (drop-word s) n))]\n    [else (select_words\
    \ (drop-word s) n)]))\n", "  (filter\n   (lambda (x)\n     (= n (for/sum ([c (in-string\
    \ x)])\n                  (cond\n                    [(char-alphabetic? c) (consonant?\
    \ c)]\n                    [else #f]))))\n   (string-split s)))\n", "  (for/list\
    \ ([i (in-list (string-tokenize s))]\n             #:when (= n (count-vowels i)))\n\
    \    i))\n", "  (if (eq? s \"\")\n      '()\n      (if (eq? (vowel? (car s)) #f)\n\
    \          (if (eq? n 1)\n              (cons (word_maker (string->list s) \"\"\
    ) '())\n              (select_words (cdr s) (- n 1)))\n          (select_words\
    \ (cdr s) n))))\n", "  (cond [(empty? s) empty]\n        [(= n (count-consonants\
    \ (first s))) (cons (first s) (select_words (rest s) n))]\n        [else (select_words\
    \ (rest s) n)]))\n</code>\n", "  (filter (lambda (word) (= n (count-vowels word)))\
    \ (string-split s #\\space)))\n", "  (define (is_consonant c)\n    (member c '(\"\
    b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"\
    r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n  (define (count_consonants\
    \ word)\n    (accumulate + 0 (map (lambda (c) (if (is_consonant c) 1 0)) word)))\n\
    \  (define (word_matches word)\n    (= n (count_consonants word)))\n  (filter\
    \ word_matches (string-split s)))\n```\n\n```racket\n#lang racket\n", "  (if (zero?\
    \ (string-length s))\n      '()\n      (let ([first-word (first (regexp-match\
    \ #rx\"^[a-z]+\" s))])\n        (if (= n (count-consonants first-word))\n    \
    \        (cons first-word (select-words (substring s (string-length first-word)\
    \ (string-length s)) n))\n            (select-words (substring s (string-length\
    \ first-word) (string-length s)) n)))))\n", "  (list-of-words s))\n", "  (let\
    \ loop ([s s] [words '()])\n    (cond [(empty? s) words]\n          [(char-consonant?\
    \ (first s))\n           (loop (rest s)\n                 (cons (make-word (first\
    \ s) (list (first s))) words))]\n          [(char-vowel? (first s))\n        \
    \   (loop (rest s)\n                 (cons (make-word (first s) '()) words))]\n\
    \          [else (loop (rest s) words)])))\n", "  (match n\n    [(consonants-in-word\
    \ s)\n     (cons s '())]\n    [(consonants-in-word (string-append word rest))\n\
    \     (cons word (select_words rest n))]\n    [_ '()]))\n", "  (cond\n    [(equal?\
    \ s \"\") '()]\n    [(equal? n 0) '()]\n    [(equal? (length (filter char-ci&lt;=?\
    \ \"aeiou\" (regexp-match #rx\".\" s))) n)\n     (cons (regexp-match #rx\"[a-z]+\"\
    \ s) (select_words (regexp-replace #rx\"[a-z]+\" s \"\") n))]\n    [else (select_words\
    \ (regexp-replace #rx\"[a-z]+\" s \"\") n)]))\n</code>\nIt seems to work, but\
    \ it's not elegant, and I'm not sure why it gets all words from the input string.\
    \ I think it's because the second case clause is matched first.\nI would like\
    \ to know:\n\nHow can I change the order of evaluation for the cond structure?\n\
    Is there a more elegant solution for this problem?\n\nAny help would be appreciated.\n\
    \n\nA:\n\nI think you're overcomplicating things by trying to use regular expressions\
    \ to solve the problem. The <code>regexp-match</code> function returns a list\
    \ of match results, and it's not entirely clear to me what you're trying to do\
    \ with them - I think that you're trying to use it to iterate over the input string,\
    \ but that doesn't really make sense.\nFor this kind of problem it's usually better\
    \ to write a function that performs the action directly over the characters of\
    \ the input string, rather than using a library that does something related to\
    \ what you want, but not exactly what you want.\nHere's a solution that processes\
    \ the input string directly and uses the <code>string-&gt;list</code> procedure\
    \ to convert the input string into a list of characters, which makes it easy to\
    \ iterate over the characters using <code>for/list</code>:\n<code>(define (select-words\
    \ s n)\n  (for/list ([word (in-list (string-&gt;list s))])\n    (let ((num-consonants\
    \ (length (filter char-ci&lt;=? \"aeiou\" word))))\n      (if (= num-consonants\
    \ n)\n          (list word)))))\n</code>\nIt works as expected:\n<code>(select-words\
    \ \"", "  (filter (lambda (w) (= n (length (filter (lambda (c) (or (char-ci=?\
    \ c #\\w) (char-ci=? c #\\e) (char-ci=? c #\\u) (char-ci=? c #\\o) (char-ci=?\
    \ c #\\i) (char-ci=? c #\\a))) w)))) (string-split s #\\space)))\n", "  (define\
    \ (select-words-with-vowels str)\n    (cond\n      [(empty? str) '()]\n      [(empty?\
    \ (rest str)) (list (first str))]\n      [else (cons (first str) (select-words-with-vowels\
    \ (rest str)))]))\n  (define (remove-letter-from-string str letter)\n    (cond\n\
    \      [(empty? str) '()]\n      [(equal? (first str) letter) (remove-letter-from-string\
    \ (rest str) letter)]\n      [else (cons (first str) (remove-letter-from-string\
    \ (rest str) letter))]))\n  (define (count-letters str letter)\n    (cond\n  \
    \    [(empty? str) 0]\n      [(equal? (first str) letter) (+ 1 (count-letters\
    \ (rest str) letter))]\n      [else (count-letters (rest str) letter)]))\n  (define\
    \ (select-words-from-string str vowels)\n    (define (have-vowels str vowels)\n\
    \      (cond\n        [(empty? vowels) false]\n        [(count-letters str (first\
    \ vowels)) (> (count-letters str (first vowels)) 0)]\n        [else (have-vowels\
    \ str (rest vowels))]))\n  (cond\n    [(empty? str) '()]\n    [(empty? (rest str))\
    \ (list (first str))]\n    [(have-vowels (first str) vowels) (select-words-from-string\
    \ (rest str) vowels)]\n    [else (cons (first str) (select-words-from-string (rest\
    \ str) vowels))]))\n  (define (remove-vowels str vowels)\n    (cond\n      [(empty?\
    \ vowels) str]\n      [else (remove-vowels (remove-letter-from-string str (first\
    \ vowels)) (rest vowels))]))\n  (define (select-words-with-n-consonants str vowels)\n\
    \    (cond\n      [(empty? str) '()]\n      [(= (length (first str)) n) (cons\
    \ (first str) (select-words-with-n-consonants", "  (cond [(empty? s) empty]\n\
    \        [(consonants-count (car (string-split s #\\space)) n)\n         (cons\
    \ (car (string-split s #\\space)) (select_words (string-drop s (string-length\
    \ (car (string-split s #\\space))) 1) n))]\n        [else (select_words (string-drop\
    \ s (string-length (car (string-split s #\\space))) 1) n)]))\n", "  (filter (lambda\
    \ (word) (= n (count-vowels word)))\n          (string-split s #\\space)))\n",
  "  (match s [(\"\") '()]\n          [else (append\n                 (if (= n (count-consonants\
    \ (regexp-match #rx\"[^ ]+\" s)))\n                     (list (regexp-match #rx\"\
    [^ ]+\" s))\n                     '())\n                 (select_words (regexp-replace\
    \ #rx\"[^ ]+\" s \"\") n))]))\n", "  (cond\n    [(= n 0) empty]\n    [(empty?\
    \ s) empty]\n    [else\n     (let*\n         ([s (string-&gt;list s)]\n      \
    \    [o (find #\\o s)]\n          [e (find #\\e s)]\n          [u (find #\\u s)]\n\
    \          [a (find #\\a s)]\n          [i (find #\\i s)]\n          [c (find\
    \ #\\c s)]\n          [v (find #\\v s)]\n          [x (find #\\x s)]\n       \
    \   [y (find #\\y s)]\n          [z (find #\\z s)]\n          [q (find #\\q s)]\n\
    \          [j (find #\\j s)]\n          [p (find #\\p s)]\n          [l (find\
    \ #\\l s)]\n          [w (find #\\w s)]\n          [d (find #\\d s)]\n       \
    \   [f (find #\\f s)]\n          [b (find #\\b s)]\n          [r (find #\\r s)]\n\
    \          [g (find #\\g s)]\n          [h (find #\\h s)]\n          [m (find\
    \ #\\m s)]\n          [t (find #\\t s)]\n          [n (find #\\n s)]\n       \
    \   [k (find #\\k s)]\n          [consonants\n           (list\n            (if\
    \ (empty? o) 0 1)\n            (if (empty? e) 0 1)\n            (if (empty? u)\
    \ 0 1)\n            (if (empty? a) 0 1)\n            (if (empty? i) 0 1)\n   \
    \         (if (empty? c) 0 1)\n            (if (empty? v) 0 1)\n            (if\
    \ (empty? x) 0 1)\n            (if (empty? y) 0 1)\n            (if (empty? z)\
    \ 0 1)\n            (if (empty? q) 0 1)\n            (if (empty? j) 0 1)\n   \
    \         (if (empty? p) 0 1)\n            (if (empty? l) 0 1)\n            (if\
    \ (empty? w) 0 1)\n            (", "  (filter (lambda (word) (= n (count-consonants\
    \ word))) (split-string s \" \")))\n", "  (if (= n 0)\n      '(#\\space)\n   \
    \   (string-&gt;list (if (regexp-match? (regexp/PCRE #px\"[^aeiou\\\\s]*\\\\s\"\
    ) s)\n                        (regexp-replace* (regexp/PCRE #px\"\\\\s{2,}\")\
    \ s \" \")\n                        s))))\n</code>\nHowever, this produces a list\
    \ of words, not just words that contain a specific number of consonants.\n\n\n\
    A:\n\nYou're code doesn't compile, but I'm guessing it's something like this:\n\
    <code>(define (select_words s n)\n  (if (= n 0)\n      '()\n      (string-&gt;list\
    \ (if (regexp-match? (regexp/PCRE #px\"[^aeiou\\\\s]*\\\\s\") s)\n           \
    \             (regexp-replace* (regexp/PCRE #px\"\\\\s{2,}\") s \" \")\n     \
    \                   s))))\n</code>\nSince you're checking for vowels, you'll only\
    \ have a space when you have exactly <code>n</code> consonants. But also, you\
    \ have no way of splitting the words into a list. Try:\n<code>(define (select_words\
    \ s n)\n  (if (= n 0)\n      '()\n      (regexp-match* (regexp/PCRE #px\"\\\\\
    b[^aeiou]{\" n \"}\\\\b\") s)))\n</code>\n", "  (for/list ([w (in-list (string-split\
    \ s #\\space))]\n             #:when (= n (length (get-vowels w))))\n    w))",
  "  (define (is-consonant c)\n    (regexp-match? #rx\"[bcdfghjklmnpqrstvwxz]\" (char->string\
    \ c)))\n  (define (count-consonants s)\n    (let ([c (string-ref s 0)])\n    \
    \  (if (eq? c #\\space)\n          0\n          (+ (if (is-consonant c) 1 0)\n\
    \             (count-consonants (substring s 1))))))\n  (define (select-words-loop\
    \ s n words)\n    (if (eq? s \"\")\n        words\n        (let ([c (string-ref\
    \ s 0)])\n          (if (eq? c #\\space)\n              (select-words-loop (substring\
    \ s 1) n words)\n              (let ([consonants (count-consonants s)])\n    \
    \            (select-words-loop (substring s 1) n\n                          \
    \         (if (= consonants n)\n                                       (cons (substring\
    \ s 0 (string-index s #\\space)) words)\n                                    \
    \   words)))))))\n  (select-words-loop s n '()))\n", "  (map (\u03BB (x) (string-trim\
    \ x))\n       (filter (\u03BB (x) (= n (count-const x)))\n               (map\
    \ (\u03BB (x) (string-trim x))\n                    (string-split s #rx\" \")))))\n",
  "  (if (or (empty? s) (= n 0))\n      empty\n      (cons (select_words-aux (string->list\
    \ s) 0 n) (select_words s (- n 1)))))\n", "    (filter (lambda (w) (equal? n (number-of-consonants\
    \ w)))\n            (split s #\\space)))\n", "  (cond\n    [(empty? s) empty]\n\
    \    [(regexp-match #rx\"^[aeiouAEIOU]+\" s) (select_words (substring s 1) n)]\n\
    \    [(regexp-match #rx\"^[^aeiouAEIOU]+\" s) (select_words (substring s 1) (add1\
    \ n))]\n    [(= n 0) (cons (regexp-match #rx\"^[^ ]+\" s) (select_words (substring\
    \ s (add1 (string-length (regexp-match #rx\"^[^ ]+\" s)))) 0))]\n    [else (select_words\
    \ (substring s (add1 (string-length (regexp-match #rx\"^[^ ]+\" s)))) (- n (string-length\
    \ (regexp-match #rx\"^[^aeiouAEIOU]+\" s))))]))\n", "  (let ((consonants (list\
    \ #\\B #\\C #\\D #\\F #\\G #\\H #\\J #\\K #\\L #\\M #\\N #\\P #\\Q #\\R #\\S #\\\
    T #\\V #\\W #\\X #\\Y #\\Z)))\n    (regexp-split #rx\"\\s+\" s)\n    (filter (lambda\
    \ (e) (= n (length (filter (lambda (consonant) (string-contains e consonant))\
    \ consonants)))) s)))\n\n", "  (define (is_consonant x)\n    (member x '(\"b\"\
    \ \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\" \"q\" \"r\"\
    \ \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n  (define (count_consonants word)\n\
    \    (cond [(empty? word) 0]\n          [(is_consonant (first word)) (+ 1 (count_consonants\
    \ (rest word)))]\n          [else (count_consonants (rest word))]))\n  (define\
    \ (select_words_iter s acc n)\n    (cond [(empty? s) (reverse acc)]\n        \
    \  [(equal? n (count_consonants (first s))) (select_words_iter (rest s) (cons\
    \ (first s) acc) n)]\n          [else (select_words_iter (rest s) acc n)]))\n\
    \  (select_words_iter (string-&gt;list s) '() n))\n</code>\n", "  (if (string=?\
    \ s \"\")\n      '()\n      (let* ([s (string-split s \" \")]\n             [s\
    \ (filter\n                 (lambda (x) (= n (word-consonants x)))\n         \
    \        s)])\n        s)))\n", "  (filter (\u03BB (w) (= n (word-consonants w)))\
    \ (string-&gt;words s)))\n", "  (define (has-n-consonants? s n)\n    (define VOWELS\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n    (if (or (empty? s) (= n 0))\n       \
    \ (zero? n)\n        (and\n         (not (member (first s) VOWELS))\n        \
    \ (has-n-consonants? (rest s) (- n 1)))))\n  (define (helper s r n)\n    (if (empty?\
    \ s)\n        r\n        (let ([word (find #\\space s)])\n          (if word\n\
    \              (if (has-n-consonants? (substring s 0 word) n)\n              \
    \    (helper (substring s (+ word 1)) (cons (substring s 0 word) r) n)\n     \
    \             (helper (substring s (+ word 1)) r n))\n              (if (has-n-consonants?\
    \ s n)\n                  (cons s r)\n                  r)))))\n  (helper s '()\
    \ n))\n", "  (cond ((equal? n 0) (list s))\n        ((member? (string-ref s 0)\
    \ '(#\\a #\\e #\\i #\\o #\\u)) (select_words (substring s 1) n))\n        (else\
    \ (append (list (string-append (string (string-ref s 0)) (select_words (substring\
    \ s 1) (- n 1)))) (select_words (substring s 1) n)))))\n", "  (cond ((empty? s)\
    \ '())\n        ((= n (count-consonants (first s))) (cons (first s) (select_words\
    \ (rest s) n)))\n        (else (select_words (rest s) n))))\n", "  (match (regexp-match*\
    \ #rx\"\\\\b[^aeiouAEIOU\\s]+\\\\b\" s)\n    [(list) '()]\n    [(list m)\n   \
    \  (if (= (string-length m) n) (list m) '())]\n    [(list m . ms)\n     (append\n\
    \      (if (= (string-length m) n) (list m) '())\n      (select_words (substring\
    \ s (add1 (string-length m))) n))]))\n</code>\nSome test:\n<code>&gt; (select_words\
    \ \"Mary had a little lamb\" 4)\n'(\"little\")\n&gt; (select_words \"Mary had\
    \ a little lamb\" 3)\n'(\"Mary\" \"lamb\")\n&gt; (select_words \"simple white\
    \ space\" 2)\n'()\n&gt; (select_words \"Hello world\" 4)\n'(\"world\")\n&gt; (select_words\
    \ \"Uncle sam\" 3)\n'(\"Uncle\")\n</code>\n", "  (define (helper s n)\n    (cond\
    \ ((string=? s \"\") '())\n          ((and (char-alphabetic? (string-ref s 0))\n\
    \                (string-count s #\\aeiouAEIOU) (= n (- (string-length s) (string-count\
    \ s #\\aeiouAEIOU))))\n           (cons (substring s 0 (- (string-length s) (string-count\
    \ s #\\ ))) (helper (substring s (string-length s)) n)))\n          ((char-alphabetic?\
    \ (string-ref s 0)) (helper (substring s 1) n))\n          (else (helper (substring\
    \ s 1) n))))\n  (helper s n))\n", "  (for/list ([word (in-string s)]\n       \
    \      #:when (= n (consonants word)))\n    word))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [(= n 0) empty]\n    [(consonant? (car s)) (cons (cons_word s\
    \ n) (select_words (cdr s) n))]\n    [else (select_words (cdr s) n)]))\n", " \
    \ (for/list ([word (in-list (string-split s #rx\"\\s+\"))] #:when (= n (get-n-consonants\
    \ word)))\n    word))\n", "  (filter\n   (lambda (x) (= n (word-consonants x)))\n\
    \   (regexp-split #rx\" \" s)))\n", "  (map (lambda (x) (if (= (length x) n) x\
    \ #f)) (string-split s)))\n</code>\n", "  (define (split s)\n    (string-split\
    \ s #\\space))\n  (define (not_vowel c)\n    (and (char-alphabetic? c) (not (or\
    \ (char-vowel? c) (char=? c #\\y)))))\n  (define (count-consonants s)\n    (length\
    \ (filter not_vowel (string->list s))))\n  (filter (lambda (w) (= n (count-consonants\
    \ w))) (split s)))\n```\n## Problem 5:\n### Problem:\nRearrange even and odd numbers\n\
    Given a list of numbers, rearrange them in such a way that all even numbers appear\
    \ before all the odd numbers in the modified list, and such that the relative\
    \ positions of the even and odd numbers remain the same.\nExamples:\nrearrange([2,\
    \ 1, 3, 0, -1, 5, 10]) ==> [0, 2, 10, 1, 3, -1, 5]\nrearrange([1, 0, -1, 2, -3,\
    \ 4]) ==> [0, 2, 4, 1, -1, -3]\n```racket\n#lang racket\n", "  (for/list ([w (in-list\
    \ (string-split s))] #:when (= n (count-consonants w)))\n    w))\n", "  (define\
    \ (consonant? c)\n    (member c '(#\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\\
    l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)))\n  (define (consonants\
    \ lst)\n    (cond [(empty? lst) '()]\n          [(consonant? (car lst)) (cons\
    \ (car lst) (consonants (cdr lst)))]\n          [else (consonants (cdr lst))]))\n\
    \  (define (word-consonants lst)\n    (cond [(empty? lst) '()]\n          [(consonant?\
    \ (car lst)) (cons (car lst) (word-consonants (cdr lst)))]\n          [else '()]))\n\
    \  (define (tot-consonants lst)\n    (cond [(empty? lst) 0]\n          [(consonant?\
    \ (car lst)) (+ 1 (tot-consonants (cdr lst)))]\n          [else (tot-consonants\
    \ (cdr lst))]))\n  (define (n-consonants lst n)\n    (cond [(empty? lst) '()]\n\
    \          [(equal? n (tot-consonants (word-consonants (car lst)))) (cons (car\
    \ lst) (n-consonants (cdr lst) n))]\n          [else (n-consonants (cdr lst) n)]))\n\
    \  (define (word-lst lst)\n    (cond [(empty? lst) '()]\n          [(equal? \"\
    \ \" (car lst)) (cons (consonants (cdr lst)) (word-lst (cdr lst)))]\n        \
    \  [else (word-lst (cdr lst))]))\n  (define (n-consonants-lst lst n)\n    (n-consonants\
    \ (word-lst lst) n))\n  (n-consonants-lst (string->list s)", "  (if (string=?\
    \ s \"\")\n      '()\n      (cons-if-equal n (consonants (string-trim (car (string-split\
    \ s #\\space))))\n                      (select_words (string-join (cdr (string-split\
    \ s #\\space)) #\\space) n))))\n", "  (let loop ([s s] [n n] [consonants 0] [words\
    \ '()])\n    (cond\n      [(or (null? s) (empty? s)) (reverse words)]\n      [(empty?\
    \ (regexp-match #rx\" \" s))\n       (if (= consonants n)\n           (loop \"\
    \" n 0 (cons s words))\n           (loop \"\" n 0 words))]\n      [(empty? (regexp-match\
    \ #rx\"[aeiou]\" (string-ref s 0)))\n       (loop (string-drop s 1) n (+ consonants\
    \ 1) words)]\n      [else (loop (string-drop s 1) n consonants words)])))\n",
  "  (for/list ([word (in-string s)]\n             #:when (= n (count-consonants word)))\n\
    \    word))\n", "  (if (empty? s)\n      '()\n      (let ([head (string-&gt;list\
    \ (car (string-split s)))]\n            [tail (select_words (cdr (string-split\
    \ s)) n)])\n        (if (= n (count-consonants head))\n            (cons (string-&gt;list\
    \ (car (string-split s))) tail)\n            tail))))\n", "  (cond\n    [(equal?\
    \ s \"\") empty]\n    [(equal? (length (regexp-match #rx\"^[^aeiou ]+\" s)) n)\n\
    \     (cons (string-trim s) (select_words (regexp-replace #rx\"[^aeiou ]+\" s\
    \ \"\") n))]\n    [else (select_words (regexp-replace #rx\"[^aeiou ]+\" s \"\"\
    ) n)]))\n", "  (cond\n    [(string=? s \"\") null]\n    [else (append (filter\
    \ (lambda (w) (= n (length (regexp-match* #rx\"^([^aeiou]+)$\" w))))\n       \
    \                    (string-split s \" \"))\n                   (select_words\
    \ (string-replace (regexp-replace* #rx\"^[^ ]+\" s \"\")\n                   \
    \                              #rx\"^ +\" \"\")\n                            \
    \     n))]))", "  (cond [(null? s) null]\n        [else (if (= n (count-consonants\
    \ (car (string-split s #\\space))))\n                 (cons (car (string-split\
    \ s #\\space)) (select_words (cdr (string-split s #\\space)) n))\n           \
    \      (select_words (cdr (string-split s #\\space)) n))]))\n", "  (if (string=?\
    \ s \"\") '()\n      (letrec ((words (string-split s \" \"))\n               (is-consonant?\
    \ (lambda (c) (not (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))))))\n        (define\
    \ (select-words-helper lst n)\n          (if (empty? lst) '()\n              (let\
    \ ((w (first lst))\n                    (n-consonants (for/sum ([c (in-string\
    \ w)])\n                                      (if (is-consonant? c) 1 0))))\n\
    \                (if (= n n-consonants)\n                    (cons w (select-words-helper\
    \ (rest lst) n))\n                    (select-words-helper (rest lst) n)))))\n\
    \        (select-words-helper words n))))\n", "  (define (count-cons s)\n    (cond\
    \ [(null? s) 0]\n          [(member (car s) '(#\\b #\\c #\\d #\\f #\\g #\\h #\\\
    j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z))\n  \
    \         (+ 1 (count-cons (cdr s)))]\n          [else (count-cons (cdr s))]))\n\
    \  (define (get-word lst)\n    (cond [(null? lst) lst]\n          [(char=? (car\
    \ lst) #\\space) '()]\n          [else (cons (car lst) (get-word (cdr lst)))]))\n\
    \  (define (is-word? w n)\n    (cond [(= n (count-cons w)) #t]\n          [else\
    \ #f]))\n  (define (get-words lst n rv)\n    (cond [(null? lst) rv]\n        \
    \  [(char=? (car lst) #\\space) (get-words (cdr lst) n rv)]\n          [else (get-words\
    \ (cdr lst) n (cons (get-word lst) rv))]))\n  (define (filter-words lst n rv)\n\
    \    (cond [(null? lst) rv]\n          [(is-word? (car lst) n) (filter-words (cdr\
    \ lst) n (cons (car lst) rv))]\n          [else (filter-words (cdr lst) n rv)]))\n\
    \  (reverse (filter-words (get-words (string->list s) n '()) n '())))\n", "  (if\
    \ (string=? s \"\")\n      empty\n      (build_word_lists (string-split s) (make-hash\
    \ 'equal?) n)))\n", "  (if (= n 0)\n      (if (string=? s \"\")\n          '()\n\
    \          (list s))\n      (let ([words (string-split s)])\n        (for/list\
    \ ([word words])\n          (if (= n (consonants-in-word word))\n            \
    \  word)))))\n", "  (filter (\u03BB (x) (equal? n (consonants x))) (string-split\
    \ s)))\n", "  (define (isVowel c)\n    (member c '(\"a\" \"e\" \"i\" \"o\" \"\
    u\" \"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define (isConstant c)\n    (not (isVowel\
    \ c)))\n  (let ([words (string-split s \" \")])\n    (for/list ([word words])\n\
    \      (let ([consonants (filter isConstant (string-&gt;list word))])\n      \
    \  (when (= (length consonants) n)\n          word)))))\n", "  (define (vowel?\
    \ c) (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define (consonant? c) (not (vowel?\
    \ c)))\n  (define (word-contains-n-consonants w)\n    (cond [(= n (count (word-&gt;list\
    \ w) consonant?))]\n          [else #f]))\n  (filter word-contains-n-consonants\n\
    \          (split s)))\n</code>\n", "  (let ([consonants #rx\"[^aeiouyAEIOUY]\"\
    ])\n    (filter\n     (lambda (x) (= n (string-contains (car x) consonants)))\n\
    \     (map (lambda (x) (list x)) (string-split s #rx\"\\s+\")))))\n```\n\n```racket\n\
    #lang racket\n", "  (filter (lambda (x) (= n (count-consonants x)))\n        \
    \  (string-tokenize s)))\n", "  (if (string=? s \"\")\n      '()\n      (let ([w\
    \ (regexp-match #rx\"^[a-z]+\" s)])\n        (cond\n         [(and (eq? (length\
    \ w) 1)\n               (= n (string-length (car w))))\n          (cons (car w)\
    \ (select_words (substring s (string-length (car w)) (string-length s)) n))]\n\
    \         [else (select_words (substring s (string-length (car w)) (string-length\
    \ s)) n)]))))\n", "  (if (string=? \"\" s) '()\n      (let ((words (map (\u03BB\
    \ (x) (string-&gt;symbol x)) (string-split s #\\space))))\n        (cond ((&gt;\
    \ (length words) 1) (cons (car words) (select_words (string-join (cdr words) #\\\
    space) n)))\n              ((&gt; (length (filter (\u03BB (x) (memq x '(#\\a #\\\
    e #\\i #\\o #\\u))) s)) n) (list (car words)))\n              (else '())))))\n\
    </code>\nThis works as expected until the last line. That line should return <code>'()</code>\
    \ but instead returns the first word. What am I doing wrong?\n\n\nA:\n\nYour <code>cond</code>\
    \ expression has an unusual form, it's essentially a <code>case</code> expression\
    \ that uses the first condition as an \"else\" case. The problem is in this line:\n\
    <code>(else '())\n</code>\nYou're in the else case, and you're returning the <code>car</code>\
    \ of the <code>words</code> list. This returns the first word in the sentence.\
    \ It should be just <code>else</code>, without any return value. As it is now,\
    \ you're treating the sentence <code>\"Uncle sam\"</code> as if it had more than\
    \ one word, when it doesn't, which explains why you're seeing unexpected results.\n",
  "  (define (f acc x)\n    (if (empty? x)\n        acc\n        (f (append acc (list\
    \ (car x))) (cdr x))))\n  (define (is-consonant? c)\n    (not (or (char=? c #\\\
    a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))))\n  (define\
    \ (filter-constrain ls n)\n    (filter\n     (lambda (x)\n       (= n (length\
    \ (string-filter is-consonant? x))))\n     ls))\n  (filter-constrain (f '() (string-split\
    \ s)) n))\n", "  (filter (lambda (word)\n            (= n (count-consonants word)))\n\
    \          (string-tokenize s)))\n", "  (filter (lambda (word)\n            (=\
    \ n (word-consonants word)))\n          (string-&gt;words s)))\n", "  (define\
    \ (consonant? c)\n    (not (or (equal? #\\a c) (equal? #\\e c) (equal? #\\i c)\
    \ (equal? #\\o c) (equal? #\\u c))))\n  (define (count-consonants str)\n    (define\
    \ (iter s n)\n      (if (empty? s)\n          n\n          (if (consonant? (first\
    \ s))\n              (iter (rest s) (+ n 1))\n              (iter (rest s) n))))\n\
    \    (iter str 0))\n  (define (iter str lst)\n    (if (empty? str)\n        lst\n\
    \        (let ((word (regexp-match #rx\"^([a-zA-Z]+)\" str)))\n          (if (and\
    \ (equal? n (count-consonants (car word)))\n                   (not (equal? (car\
    \ word) \"\")))\n              (iter (regexp-replace #rx\"^([a-zA-Z]+)\" str \"\
    \") (cons (car word) lst))\n              (iter (regexp-replace #rx\"^([a-zA-Z]+)\"\
    \ str \"\") lst)))))\n  (reverse (iter s '())))\n</code>\nTest case:\n<code>#|",
  "  (cond\n    [(empty? s) empty]\n    [(= n 0) (list (first s))]\n    [else (cons\
    \ (first s) (select_words (rest s) (- n 1)))]))\n", "  (define (count c l)\n \
    \   (if (null? l) c\n        (if (consonant? (car l)) (count (+ c 1) (cdr l))\
    \ (count c (cdr l)))))\n  (define (consonant? c)\n    (not (or (char=? c #\\a)\
    \ (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))))\n  (define\
    \ (helper s n l)\n    (if (null? s) l\n        (if (char=? (car s) #\\ ) (helper\
    \ (cdr s) n l)\n            (helper (cdr s) n (cons (string (car s)) l)))))\n\
    \  (define (string_helper l)\n    (if (null? l) \"\"\n        (string-append (car\
    \ l) (string_helper (cdr l)))))\n  (define (select l l2)\n    (if (null? l) l2\n\
    \        (if (= (count 0 (car l)) n) (select (cdr l) (cons (string_helper (car\
    \ l)) l2))\n            (select (cdr l) l2))))\n  (select (helper s n '()) '()))\n",
  "  (cond\n    [(&lt;= n 0) (list)]\n    [(&gt; n 20) (list)]\n    [(&gt; (string-length\
    \ s) 0) (cons (string-append s \" \") (select_words s (- n 1)))]\n    [else (list)]))\n",
  "  (define (find_n_consonants lst)\n    (cond\n      [(null? lst) 0]\n      [(consonant?\
    \ (car lst)) (add1 (find_n_consonants (cdr lst)))]\n      [else (find_n_consonants\
    \ (cdr lst))]))\n  (define (get_all_words lst acc)\n    (cond\n      [(null? lst)\
    \ acc]\n      [(string? (car lst)) (get_all_words (cdr lst) (cons (car lst) acc))]\n\
    \      [else (get_all_words (cdr lst) acc)]))\n  (define (consonant? c)\n    (member\
    \ c '(\"b\" \"c\" \"d\" \"f\" \"g\" \"h\" \"j\" \"k\" \"l\" \"m\" \"n\" \"p\"\
    \ \"q\" \"r\" \"s\" \"t\" \"v\" \"w\" \"x\" \"y\" \"z\")))\n  (define (filter\
    \ lst n)\n    (cond\n      [(null? lst) '()]\n      [(= n (find_n_consonants (string->list\
    \ (car lst)))) (cons (car lst) (filter (cdr lst) n))]\n      [else (filter (cdr\
    \ lst) n)]))\n  (filter (get_all_words (string-split s) '()) n))\n```\n\n```racket\n\
    #lang racket\n", "  (define (has-n-consonants w)\n    (cond [(string=? w \"\"\
    ) 0]\n          [(regexp-match #rx\"[aeiouy]\" w) (has-n-consonants (regexp-replace\
    \ #rx\"[aeiouy]\" w \"\"))]\n          [else (+ 1 (has-n-consonants (regexp-replace\
    \ #rx\"[aeiouy]\" w \"\")))]))\n  (map (lambda (w) (if (= (has-n-consonants w)\
    \ n) w)) (regexp-split #rx\"\\s+\" s)))\n```\n\n```racket\n#lang racket\n", " \
    \ (define (remove-vowels str)\n    (cond ((empty? str) '())\n          ((elem\
    \ (first str) '(\"a\" \"e\" \"i\" \"o\" \"u\")) (remove-vowels (rest str)))\n\
    \          (else (cons (first str) (remove-vowels (rest str))))))\n  (define (count-consonants\
    \ str)\n    (if (empty? str) 0\n        (+ (count-consonants (rest str)) 1)))\n\
    \  (define (select_words_helper lst cons-count acc)\n    (cond ((empty? lst) acc)\n\
    \          ((= cons-count n) (select_words_helper (rest lst) 0 (cons (first lst)\
    \ acc)))\n          (else (select_words_helper (rest lst) (+ cons-count 1) acc))))\n\
    \  (select_words_helper (regexp-split #rx\" \" s) 0 '()))\n</code>\nHowever, the\
    \ submission is not returning the correct answer. I am new to Racket, so it is\
    \ difficult to find the bug. Any help is appreciated.\n\n\nA:\n\nThe problem is\
    \ that you're not counting the consonants in each word, you're counting all the\
    \ consonants in the string. If you change your <code>select_words_helper</code>\
    \ to be:\n<code>(define (select_words_helper lst acc)\n  (cond ((empty? lst) acc)\n\
    \        ((= (count-consonants (first lst)) n) (select_words_helper (rest lst)\
    \ (cons (first lst) acc)))\n        (else (select_words_helper (rest lst) acc))))\n\
    </code>\nit works.\n", "  (define (consonant? s)\n    (and (char-alphabetic? s)\n\
    \         (not (member s '(#\\a #\\e #\\i #\\o #\\u #\\y)))))\n  (define (contains-n-consonants\
    \ word n)\n    (let loop ([i 0] [consonants 0])\n      (cond [(= i (string-length\
    \ word)) (= consonants n)]\n            [(consonant? (string-ref word i)) (loop\
    \ (+ i 1) (+ consonants 1))]\n            [else (loop (+ i 1) consonants)])))\n\
    \  (filter (\u03BB (word) (contains-n-consonants word n)) (string-split s)))\n",
  "  (define (vowel? c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\")) #t #f))\n\
    \  (define (consonant? c)\n    (not (vowel? c)))\n  (define (count-consonants\
    \ w)\n    (length (filter consonant? (string->list w))))\n  (filter (\u03BB (w)\
    \ (= n (count-consonants w))) (string-split s #\\space)))\n", "  (if (string=?\
    \ s \"\") '()\n      (let ([words (string-split s)])\n        (for/list ([w (in-list\
    \ words)])\n          (if (= n (consonants-in-word w)) w)))))\n", "  (let ([L\
    \ (string-split s \" \")])\n    (map\n     (\u03BB (str)\n       (if (eq? (count-consonants\
    \ str) n)\n           str\n           \"\"))\n     L)))\n", "  (define (split\
    \ s)\n    (if (string-empty? s)\n        '()\n        (cons (string-&gt;list (regexp-match\
    \ #rx\"[a-zA-Z]+\" s)) (split (regexp-match #rx\"\\s*\\w*\" s)))))\n  (define\
    \ (count l)\n    (define (is-vowel? c)\n      (if (member c '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))\n          true\n          false))\n\
    \    (if (null? l)\n        0\n        (if (is-vowel? (car l))\n            (count\
    \ (cdr l))\n            (+ 1 (count (cdr l))))))\n  (define (select lst)\n   \
    \ (if (null? lst)\n        '()\n        (if (= n (count (car lst)))\n        \
    \    (cons (list-&gt;string (car lst)) (select (cdr lst)))\n            (select\
    \ (cdr lst)))))\n  (select (split s)))\n</code>\nA few things bug me about this\
    \ code.\n\nIn <code>split</code>, I don't like doing <code>(regexp-match #rx\"\
    \\s*\\w*\" s)</code> then taking the <code>cdr</code> of the result. I think it\
    \ would be better to do something like <code>(regexp-match #rx\"\\w+\" s #:substring?\
    \ #t)</code>, but then I'm not sure how to do the other <code>regexp-match</code>\
    \ inside the <code>else</code> case. I have the feeling this is due to my inexperience\
    \ with Racket, so I'm not sure if this is something I should worry about or not.\n\
    Should I use <code>list-&gt;string</code> in <code>select</code> instead of <code>string-&gt;list</code>\
    \ in <code>split</code>? This way I'd be doing less string-to-list conversion,\
    \ but the code in <code>select</code> would be a bit more complex.", "  (define\
    \ (is_vowel c)\n    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=?\
    \ c #\\i)\n        (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (count_consonants\
    \ s)\n    (define (loop acc i)\n      (if (= i (string-length s))\n          acc\n\
    \          (if (and (>= i 0)\n                   (not (is_vowel (string-ref s\
    \ i))))\n              (loop (+ acc 1) (+ i 1))\n              (loop acc (+ i\
    \ 1)))))\n    (loop 0 0))\n  (define (loop acc i)\n    (if (= i (string-length\
    \ s))\n        acc\n        (let ([w (string-split s #\\ )])\n          (if (=\
    \ n (count_consonants (list-ref w i)))\n              (loop (append acc (list\
    \ (list-ref w i))) (+ i 1))\n              (loop acc (+ i 1))))))\n  (loop '()\
    \ 0))\n", "  (if (zero? (string-length s))\n      '()\n      (let* ([word (string-append\
    \ \" \" (string-take s (string-index s #\\ )))]\n             [words (select_words\
    \ (string-drop s (string-index s #\\ )) n)])\n        (if (= n (count-consonants\
    \ word))\n            (cons (string-trim (string-trim-both (string-drop word 1)\
    \ #\\ ) #\\ ) words)\n            words))))\n", "  (cond\n    [(empty? s) empty]\n\
    \    [(let* ([letters (list->string (string-split (string-filter char-alphabetic?\
    \ s) #\\space))]\n            [consonants (map (\u03BB (x) (string-contains-regexp?\
    \ x #rx\"[bcdfghjklmnpqrstvwxz]\")) letters)])\n       (filter (\u03BB (x) (=\
    \ x n)) consonants))]))\n", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n \
    \ (define (filter s)\n    (if (string-null? s)\n        '()\n        (cons (list->string\
    \ s)\n              (filter (regexp-replace* #rx(.*?) (string-tail s))))))\n \
    \ (for/list ([i (in-list (filter s))])\n    (if (= n (for/sum ([c (in-string i)])\n\
    \                      (if (memq c vowels) 0 1)))\n        i\n        #f)))\n\
    </code>\n", "  (define (is-consonant? c)\n    (cond\n      [(member c '(#\\a #\\\
    e #\\i #\\o #\\u)) #f]\n      [else #t]))\n  (define (count-consonants s)\n  \
    \  (cond\n      [(empty? s) 0]\n      [(is-consonant? (first s)) (+ 1 (count-consonants\
    \ (rest s)))]\n      [else (count-consonants (rest s))]))\n  (define (find-consonant-words\
    \ s)\n    (define (find-consonant-words1 result-list s)\n      (if (empty? s)\n\
    \          result-list\n          (let ((word (first s)))\n            (if (=\
    \ n (count-consonants word))\n                (find-consonant-words1 (append result-list\
    \ (list word)) (rest s))\n                (find-consonant-words1 result-list (rest\
    \ s))))))\n    (find-consonant-words1 empty s))\n  (find-consonant-words (string-tokenize\
    \ s)))", "  (letrec\n    ([word (lambda (ls)\n              (cond\n          \
    \      [(empty? ls) empty]\n                [(char-vowel? (first ls)) (word (rest\
    \ ls))]\n                [else (cons (first ls) (word (rest ls)))]))]\n     [count-consonants\
    \ (lambda (ls)\n                         (cond\n                           [(empty?\
    \ ls) 0]\n                           [(char-vowel? (first ls)) (count-consonants\
    \ (rest ls))]\n                           [else (+ 1 (count-consonants (rest ls)))]))]\n\
    \     [f (lambda (s)\n          (cond\n            [(empty? s) empty]\n      \
    \      [(empty? (rest s)) empty]\n            [(equal? (first s) #\\space) (f\
    \ (rest s))]\n            [else (cons (first s) (f (rest s)))]))]\n     [g (lambda\
    \ (s)\n          (cond\n            [(empty? s) empty]\n            [(empty? (rest\
    \ s)) empty]\n            [(equal? (first s) #\\space) (cons empty (g (rest s)))]\n\
    \            [else (cons (first s) (g (rest s)))]))]\n     [filter-by-consonants\
    \ (lambda (ls)\n                             (cond\n                         \
    \      [(empty? ls) empty]\n                               [(empty? (rest ls))\
    \ empty]\n                               [(= n (count-consonants (first ls)))\
    \ (cons (first ls) (filter-by-consonants (rest ls)))]\n                      \
    \         [else (filter-by-consonants (rest ls))]))]\n     [uncons (lambda (ls)\n\
    \               (cond\n                 [(empty? ls) empty]\n                \
    \ [(empty? (rest ls)) empty]\n                 [else (cons (first ls) (uncons\
    \ (rest ls)))]))])\n    (filter-by-consonants (uncons (g (f s))))))", "  (define\
    \ (is_consonant? c)\n    (and\n     (not (= #\\a c))\n     (not (= #\\e c))\n\
    \     (not (= #\\i c))\n     (not (= #\\o c))\n     (not (= #\\u c))))\n  (define\
    \ (word-consonants word)\n    (if (null? word)\n        0\n        (if (is_consonant?\
    \ (car word))\n            (+ 1 (word-consonants (cdr word)))\n            (word-consonants\
    \ (cdr word)))))\n  (define (word-loop words n)\n    (if (null? words)\n     \
    \   '()\n        (if (= n (word-consonants (car words)))\n            (cons (car\
    \ words) (word-loop (cdr words) n))\n            (word-loop (cdr words) n))))\n\
    \  (word-loop (string-split s) n))\n", "  (define (is-consonant c)\n    (and (not\
    \ (char-vowel? c)) (not (char=? c #\\space))))\n  (define (consonants s)\n   \
    \ (count (is-consonant s)))\n  (define (word-count s)\n    (count (char=? s #\\\
    space)))\n  (cond ((empty? s) '())\n        ((= n (consonants s)) (cons (list->string\
    \ s) (select_words (rest s) n)))\n        ((= 0 (word-count s)) (select_words\
    \ (rest s) n))\n        (else (select_words (rest s) n))))\n", "  (match n\n \
    \   [(n #:when (not (positive? n))) (error \"n is not positive\")]\n    [_ (let\
    \ ([words (string-split s)])\n          (filter (\u03BB (x) (= n (num-of-consonants\
    \ x))) words))]))\n", "  (map (lambda (word) (symbol->string word))\n       (filter\
    \ (lambda (word) (= n (count_consonants word))) (string->symbol/list s))))\n",
  "  (regexp-match* #rx(#:line-start\n                      (? #:not-newline)*\n \
    \                     (? #:not-newline\n                         (? #:not-newline)*\n\
    \                      )\n                      (? #:not-newline\n           \
    \              (? #:not-newline)*\n                      )\n                 \
    \     (? #:not-newline\n                         (? #:not-newline)*\n        \
    \              )\n                      (? #:not-newline\n                   \
    \      (? #:not-newline)*\n                      )\n                      (? #:not-newline)*\n\
    \                      #:line-end)\n                  s))\n\n```", "  (cond\n\
    \    [(= n 0) (list s)]\n    [(string-empty? s) empty]\n    [(consonant? (car\
    \ s)) (cons (cons (car s) (select_words (cdr s) (- n 1))) (select_words (cdr s)\
    \ n))]\n    [else (select_words (cdr s) n)]))\n", "  (if (string=? s \"\")\n \
    \     '()\n      (define (is-vowel? c)\n        (member c '(#\\a #\\e #\\i #\\\
    o #\\u #\\y)))\n      (define (filter-word w)\n        (define (loop w i)\n  \
    \        (if (= i (string-length w))\n              (= i n)\n              (if\
    \ (is-vowel? (string-ref w i))\n                  (loop w (+ i 1))\n         \
    \         (loop w (+ i 1)))))\n        (loop w 0))\n      (define (loop s i result)\n\
    \        (if (= i (string-length s))\n            result\n            (if (char=?\
    \ (string-ref s i) #\\ )\n                (if (filter-word (string-append result\
    \ (string #\\ )))\n                    (if (= (string-length result) 0)\n    \
    \                    (loop s (+ i 1) \"\")\n                        (loop s (+\
    \ i 1) \"\")\n                        )\n                    (loop s (+ i 1) \"\
    \")\n                    )\n                (loop s (+ i 1) (string-append result\
    \ (string (string-ref s i))))\n                )\n            )\n        )\n \
    \     (loop s 0 \"\")\n      )\n  )\n", "  (define VOWELS\n    (list #\\a #\\\
    e #\\i #\\o #\\u #\\y))\n  (define (count-consonants w)\n    (cond\n      [(empty?\
    \ w) 0]\n      [(member (car w) VOWELS) (count-consonants (cdr w))]\n      [else\
    \ (+ 1 (count-consonants (cdr w)))]))\n  (filter (lambda (w) (= n (count-consonants\
    \ w)))\n          (regexp-split #rx\"\\s+\" s)))\n</code>\n", "  (if (string=?\
    \ s \"\")\n      '()\n      (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)])\n\
    \        (define (n-cons s)\n          (if (string=? \"\" s)\n              0\n\
    \              (if (member (string-ref s 0) vowels)\n                  (n-cons\
    \ (substring s 1))\n                  (+ 1 (n-cons (substring s 1))))))\n    \
    \    (let ([w (string-split s)])\n          (filter\n           (lambda (l)\n\
    \             (and (not (null? l)) (= n (n-cons l))))\n           w)))));;\n",
  "  (define (is-consonant c)\n    (regexp-match #rx\"[^a,e,i,o,u]\" (string c)))\n\
    \  (define (word-consonants w)\n    (length (filter is-consonant w)))\n  (define\
    \ (is-n-consonants w)\n    (= n (word-consonants w)))\n  (define (words s)\n \
    \   (regexp-match #rx\"\\w+\" s))\n  (filter is-n-consonants (words s)))\n</code>\n",
  "  (cond [(string=? s \"\") empty]\n        [else (cons (car (match (regexp \"\\\
    \\w+\") s))\n                    (select_words (cdr (match (regexp \"\\\\w+\"\
    ) s)) n))]))\n", "  (cond\n    [(empty? s) empty]\n    [(consonants s n) (cons\
    \ (first (words s)) (select_words (rest (words s)) n))]\n    [else (select_words\
    \ (rest (words s)) n)]))\n", "  (cond ((string=? s \"\") '())\n        ((= (count-consonants\
    \ (string-take s 1)) n)\n         (cons (string-take s 1)\n               (select_words\
    \ (string-drop s 1) n)))\n        (else (select_words (string-drop s 1) n))))\n",
  '  (map (cut list <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <>
    <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <> <', "   \
    \ (cond\n        [(empty? s) empty]\n        [(= n (count-consonants (car (string-split\
    \ s))))\n         (cons (car (string-split s)) (select_words (cdr (string-split\
    \ s)) n))]\n        [else (select_words (cdr (string-split s)) n)]))\n</code>\n\
    The following error message is given: <code>expects type &lt;boolean&gt; as 1st\
    \ argument, given: \"Mary\"</code>\nCan someone guide me through what I am doing\
    \ wrong?\n\n\nA:\n\nYour function expects a string as an argument, not a list\
    \ of strings like <code>(string-split \"Mary had a little lamb\")</code> returns,\
    \ so you need to use it on the string directly:\n<code>(define (select_words s\
    \ n)\n  (cond\n    [(empty? s) empty]\n    [(= n (count-consonants (car (string-split\
    \ s))))\n     (cons (car (string-split s)) (select_words (cdr (string-split s))\
    \ n))]\n    [else (select_words (cdr (string-split s)) n)]))\n</code>\nAlso, there's\
    \ some problems with your <code>count-consonants</code> function: it's counting\
    \ consonants and vowels, even if the given argument is a <code>char?</code>, and\
    \ it's missing the base case for the recursive calls. Here's a fixed version:\n\
    <code>(define (count-consonants s)\n  (cond\n    [(empty? s) 0]\n    [(char=?\
    \ (car s) #\\a) (count-consonants (cdr s))]\n    [(char=? (car s) #\\e) (count-consonants\
    \ (cdr s))]\n    [(char=? (car s) #\\i) (count-consonants (cdr s))]\n    [(char=?\
    \ (car s) #\\o) (count-consonants (cdr s))]\n    [(char=? (car s) #\\u) (count-consonants\
    \ (cdr s))]\n    [else (+ 1 (count-consonants (cdr", "  (cond\n    [(empty? s)\
    \ (list)]\n    [(list? s)\n     (let ([l (select_words (first s) n)])\n      \
    \ (if (equal? n (count-consonants (first s)))\n           (cons (first s) l)\n\
    \           l))]\n    [else (select_words (get-words s) n)]))", "  (map (lambda\
    \ (x) (substring s x (+ x (string-length x)))) \n       (list-substrings s)))",
  "  (filter\n   (lambda (w) (= n (count-consonants w)))\n   (string-split s #\\space)))\n",
  "  (if (empty? s)\n      empty\n      (filter (\u03BB (w) (= n (count-consonants\
    \ w)))\n              (string-split s))))", "  (if (= n 1)\n      (cons (string-trim\
    \ s) '())\n      (for/list ([e (string-split s #\\space)])\n        (if (= n (count\
    \ (string-split e #\\space)\n                        (lambda (x)\n           \
    \               (if (not (member x '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n      \
    \                        x))))\n            (cons e '())))))\n</code>\n", "  (if\
    \ (equal? s \"\")\n      '()\n      (let* ([words (regexp-split #rx\"\\s+\" s)]\n\
    \             [selected (filter (lambda (w)\n                                \
    \ (consonants w n))\n                               words)])\n        selected)))\n",
  "  (define (word-count-consonants w)\n    (define (contains-consonant? w)\n    \
    \  (regexp-match #rx\"^[^aeiouAEIOU]\" w))\n    (define (count-consonants w)\n\
    \      (cond\n        [(empty? w) 0]\n        [(contains-consonant? (first w))\
    \ (+ 1 (count-consonants (rest w)))]\n        [else (count-consonants (rest w))]))\n\
    \    (count-consonants w))\n  (define (selector w)\n    (define (already-selected?\
    \ w selected)\n      (cond\n        [(empty? selected) #f]\n        [(equal? (first\
    \ selected) w) #t]\n        [else (already-selected? w (rest selected))]))\n \
    \   (cond\n      [(empty? w) #f]\n      [(equal? (word-count-consonants (first\
    \ w)) n) (and (not (already-selected? (first w) (rest w))) #t)]\n      [else (selector\
    \ (rest w))]))\n  (filter selector (string-split s #rx\"\\s+\")))", "  (if (=\
    \ n 0)\n      '()\n      (if (empty? s)\n          '()\n          (if (member?\
    \ (car s) '(a e i o u A E I O U))\n              (select_words (cdr s) n)\n  \
    \            (select_words (cdr s) (- n 1))))))\n", "  (define (is_consonant c)\n\
    \    (or (char=? c #\\b)\n        (char=? c #\\c)\n        (char=? c #\\d)\n \
    \       (char=? c #\\f)\n        (char=? c #\\g)\n        (char=? c #\\h)\n  \
    \      (char=? c #\\j)\n        (char=? c #\\k)\n        (char=? c #\\l)\n   \
    \     (char=? c #\\m)\n        (char=? c #\\n)\n        (char=? c #\\p)\n    \
    \    (char=? c #\\q)\n        (char=? c #\\r)\n        (char=? c #\\s)\n     \
    \   (char=? c #\\t)\n        (char=? c #\\v)\n        (char=? c #\\w)\n      \
    \  (char=? c #\\x)\n        (char=? c #\\y)\n        (char=? c #\\z)))\n  (define\
    \ (count_consonants word)\n    (define (count_helper index count)\n      (if (=\
    \ index (string-length word))\n          count\n          (if (is_consonant (string-ref\
    \ word index))\n              (count_helper (+ index 1) (+ count 1))\n       \
    \       (count_helper (+ index 1) count))))\n    (count_helper 0 0))\n  (define\
    \ (filter_words words)\n    (cond ((null? words) '())\n          ((= n (count_consonants\
    \ (car words))) (cons (car words) (filter_words (cdr words))))\n          (else\
    \ (filter_words (cdr words)))))\n  (filter_words (string-split s #\\space)))\n",
  "  (cond\n    [(empty? s) empty]\n    [(zero? n) empty]\n    [else\n     (cond\n\
    \       [(consonant? (first s))\n        (cons\n         (word (string->list s)\
    \ (first s) (add1 n))\n         (select_words (cdr s) (sub1 n)))]\n       [else\n\
    \        (select_words (cdr s) n)])]))\n", "  (if (string=? s \"\")\n      '()\n\
    \      (define (count-consonants lst)\n        (if (empty? lst)\n            0\n\
    \            (if (member (first lst) '(#\\a #\\e #\\i #\\o #\\u))\n          \
    \      (count-consonants (rest lst))\n                (+ 1 (count-consonants (rest\
    \ lst))))))\n      (define (get-word lst)\n        (if (empty? lst)\n        \
    \    '()\n            (if (member (first lst) '(#\\a #\\e #\\i #\\o #\\u #\\ \
    \ #\\b #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\\
    t #\\v #\\w #\\x #\\y #\\z))\n                (rest lst)\n                (cons\
    \ (first lst) (get-word (rest lst))))))\n      (define (iter lst res)\n      \
    \  (if (empty? lst)\n            (remove-duplicates res)\n            (if (= n\
    \ (count-consonants (get-word lst)))\n                (iter (rest lst) (cons (list->string\
    \ (get-word lst)) res))\n                (iter (rest lst) res))))\n      (iter\
    \ (string->list s) '())))\n```\n\n```racket\n#lang racket\n", "  (define (count-consonants\
    \ x)\n    (define (is-consonant? x)\n      (or (or (char=? x #\\b) (char=? x #\\\
    c))\n\t  (or (or (char=? x #\\d) (char=? x #\\f))\n\t      (or (or (char=? x #\\\
    g) (char=? x #\\h))\n\t\t  (or (or (char=? x #\\j) (char=? x #\\k))\n\t\t    \
    \  (or (or (char=? x #\\l) (char=? x #\\m))\n\t\t\t  (or (or (char=? x #\\n) (char=?\
    \ x #\\p))\n\t\t\t      (or (or (char=? x #\\q) (char=? x #\\r))\n\t\t\t\t  (or\
    \ (or (char=? x #\\s) (char=? x #\\t))\n\t\t\t\t      (or (or (char=? x #\\v)\
    \ (char=? x #\\w))\n\t\t\t\t\t  (char=? x #\\z))))))))))))\n    (accumulate +\
    \ 0 (map is-consonant? (string->list x))))\n  (define (find-words l)\n    (define\
    \ (find-words-h l accum)\n      (cond ((null? l) accum)\n\t    ((equal? n (count-consonants\
    \ (car l)))\n\t     (find-words-h (cdr l) (cons (car l) accum)))\n\t    (else\
    \ (find-words-h (cdr l) accum))))\n    (find-words-h l '()))\n  (find-words (string-split\
    \ s)))\n", "  (define (get_words lst)\n    (if (null? lst)\n        '()\n    \
    \    (cons (car lst) (get_words (cdr lst)))))\n  (define (get_consonants word)\n\
    \    (define (get_next_consonant word)\n      (if (or (char=? (string-ref word\
    \ 0) #\\A)\n              (char=? (string-ref word 0) #\\E)\n              (char=?\
    \ (string-ref word 0) #\\I)\n              (char=? (string-ref word 0) #\\O)\n\
    \              (char=? (string-ref word 0) #\\U))\n          (get_next_consonant\
    \ (substring word 1))\n          (list (string-ref word 0))))\n    (if (null?\
    \ word)\n        '()\n        (cons (get_next_consonant word) (get_consonants\
    \ (substring word 1)))))\n  (filter (lambda (word) (= n (length (get_consonants\
    \ word)))) (get_words (string-split s))))\n", "  (cond\n    [(empty? s) empty]\n\
    \    [(= n 0) (split (regexp #rx\" \") s)]\n    [(consonant? (first s))\n    \
    \ (cons (first s) (select_words (rest s) (- n 1)))]\n    [else (select_words (rest\
    \ s) n)]))\n", "  (if (null? s)\n      (list)\n      (if (= n (count-vowels (car\
    \ (string-split s #\\space))))\n          (cons (car (string-split s #\\space))\
    \ (select_words (cdr (string-split s #\\space)) n))\n          (select_words (cdr\
    \ (string-split s #\\space)) n))))\n", "  (for/list ([w (in-list (string-split\
    \ s))]\n             #:when (= n (count-consonants w)))\n    w))\n", "    (if\
    \ (string=? s \"\")\n        empty\n        (if (string=? (car (string-split s\
    \ #\\space))\n                (list->string (filter (lambda (c) (not (vowel? c)))\n\
    \                                      (string->list (car (string-split s #\\\
    space))))))\n            (cons (car (string-split s #\\space)) (select_words (cdr\
    \ (string-split s #\\space)) n))\n            (select_words (cdr (string-split\
    \ s #\\space)) n))))\n</code>\n", "  (cond\n    [(empty? s) empty]\n    [(= (number-of-consonants\
    \ (first (regexp-split #rx\" \" s))) n) (cons (first (regexp-split #rx\" \" s))\
    \ (select_words (rest (regexp-split #rx\" \" s)) n))]\n    [else (select_words\
    \ (rest (regexp-split #rx\" \" s)) n)]))\n", "  (if (empty? s)\n      '()\n  \
    \    (let ([lst (string-split s #\\space)])\n        (filter (lambda (x) (= n\
    \ (length (vowels/consonants x)))) lst))))\n", "  (let ([s (string-split s #\\\
    space)])\n    (define (loop lst)\n      (cond [(null? lst) '()]\n            [(eq?\
    \ n (count-consonants (car lst))) (cons (car lst) (loop (cdr lst)))]\n       \
    \     [else (loop (cdr lst))]))\n    (loop s)))\n", "  (define vowels\n    (list\
    \ #\\a #\\e #\\i #\\o #\\u #\\y))\n  (define (is_vowel c)\n    (member c vowels))\n\
    \  (define (count_cons c s)\n    (cond\n      [(empty? s) 0]\n      [(not (is_vowel\
    \ (first s))) (add1 (count_cons c (rest s)))]\n      [else (count_cons c (rest\
    \ s))]))\n  (define (count_cons_word c w)\n    (count_cons c (string->list w)))\n\
    \  (cond\n    [(empty? s) empty]\n    [(count_cons_word c (first (regexp-match\
    \ #rx\"[a-zA-Z]+\" s)))\n     (cons (first (regexp-match #rx\"[a-zA-Z]+\" s))\
    \ (select_words (regexp-replace #rx\"[a-zA-Z]+\" s \"\") n))]\n    [else (select_words\
    \ (regexp-replace #rx\"[a-zA-Z]+\" s \"\") n)]))\n", "  (if (string=? s \"\")\n\
    \      '()\n      (define words (string-split s #\\space))\n      (for/list ([word\
    \ words])\n        (if (= (consonants-in-word word) n)\n            word))))\n",
  "  (define (is-consonant c)\n    (not (char-ci=? c #\\a)\n         (char-ci=? c\
    \ #\\e)\n         (char-ci=? c #\\i)\n         (char-ci=? c #\\o)\n         (char-ci=?\
    \ c #\\u)))\n  (for/list ([w (in-list (string-split s))]\n             #:when\
    \ (= n (count (char-set is-consonant) w)))\n            w))\n", "  (define (select_words_aux\
    \ accu word)\n    (if (equal? word \"\")\n        accu\n        (if (= n (count-consonants\
    \ word))\n            (select_words_aux (append accu (list word)) \"\")\n    \
    \        (select_words_aux accu \"\"))))\n  (select_words_aux '() \"\"))\n", " \
    \ (define (helper s n i)\n    (cond\n      [(= i n)\n       (list s)]\n      [(string-index\
    \ s i #\\a #\\e #\\i #\\o #\\u)\n       (cons (substring s 0 i) (helper (substring\
    \ s (+ i 1) (string-length s)) n (+ i 1)))]\n      [else\n       (helper s n (+\
    \ i 1))]))\n  (flatmap string-&gt;list (helper s n 0)))\n</code>\n", "  (if (string=?\
    \ s \"\")\n      '()\n      (map (\u03BB (x) (car x))\n           (filter (\u03BB\
    \ (x) (= n (cdr x)))\n                   (map (\u03BB (x) (list x (count-consonants\
    \ x)))\n                        (string-tokenize s))))))\n", "  (filter (lambda\
    \ (word) (= n (count_consonants word)))\n          (string-split s #\\space)))\n",
  "  (cond\n    [(= 0 n) '()]\n    [(empty? s) '()]\n    [(consonants? (words s) n)\
    \ (list (car (words s)))]\n    [else (select_words (cdr (words s)) n)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
