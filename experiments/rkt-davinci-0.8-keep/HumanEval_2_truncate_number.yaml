name: HumanEval_2_truncate_number
language: rkt
prompt: "#lang racket\n\n;; Given a positive floating point number, it can be decomposed\
  \ into\n;; and integer part (largest integer smaller than given number) and decimals\n\
  ;; (leftover part always smaller than 1).\n;; Return the decimal part of the number.\n\
  ;; >>> truncate_number(3.5)\n;; 0.5\n(define (truncate_number number)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate truncate_number))\n\
  \    (check-equal? (candidate 3.5) 0.5)\n    (check-equal? (candidate 1.25) 0.25)\n\
  \    (check-equal? (candidate 123.0) 0.0)\n))\n\n(test-humaneval)"
completions: ["  (local [(define (truncate-impl initial-n)\n            (cond [(<\
    \ initial-n 1) 0]\n                  [else (truncate-impl (- initial-n 1))]))]\n\
    \    (- number (truncate-impl number))))\n", "  (round (sub1 (- number (floor\
    \ number)))))\n", "  (modulo number 1.0))\n```\n\n```", "  (define integer_part\
    \ (exact-floor number))\n  (- number integer_part))\n", "  (define (truncate-iter\
    \ number result)\n    (define (is-integer? number)\n      (= (floor number) number))\n\
    \    (cond ((is-integer? number) result)\n          (else (truncate-iter (- number\
    \ 1) (+ result 1)))))\n  (truncate-iter number 0))\n", "  (let ([left-over (-\
    \ number (floor number))])\n    left-over))\n", "  (if (and (integer? number)\
    \ (= number 0))\n      0\n      (if (and (integer? number) (&gt; number 0))\n\
    \          (- number (floor number))\n          (if (and (integer? number) (&lt;\
    \ number 0))\n              (- number (ceiling number))\n              (if (and\
    \ (real? number) (&gt; number 0))\n                  (if (integer? (floor number))\n\
    \                      (- number (floor number))\n                      (if (integer?\
    \ (ceiling number))\n                          (- number (ceiling number))\n \
    \                         (if (and (integer? (floor (+ 1 number))) (= (floor (+\
    \ 1 number)) 0))\n                              (- 1 number)\n               \
    \               (if (and (integer? (ceiling (+ 1 number))) (= (ceiling (+ 1 number))\
    \ 0))\n                                  (- 1 number)\n                      \
    \            (if (and (integer? (floor (+ number))) (= (floor (+ number)) 0))\n\
    \                                      (- number)\n                          \
    \            (if (and (integer? (ceiling (+ number))) (= (ceiling (+ number))\
    \ 0))\n                                          (- number)\n                \
    \                          0)))))\n                          )))\n           \
    \           )))\n              (if (and (real? number) (&lt; number 0))\n    \
    \              (if (integer? (floor number))\n                      (- number\
    \ (floor number))\n                      (if (integer? (ceiling number))\n   \
    \                       (- number (ceiling number))\n                        \
    \  (if (and (integer? (floor (+ 1 number))) (= (floor (+ 1 number)) 0))\n    \
    \                          (- 1 number)\n                              (if (and\
    \ (integer? (ceiling (+ 1 number))) (= (ceiling (+ 1 number)) 0))\n          \
    \                        (- 1 number)\n                                  (if (and\
    \ (integer? (floor (+ number))) (= (floor (+ number)) 0))\n                  \
    \                    (- number)\n                                      (if (and\
    \ (integer? (ceiling (+ number))) (= (ceiling (+ number)) 0))\n              \
    \                            (- number)\n                                    \
    \      0)))))\n                          )))\n                      )))\n    \
    \              ))))\n</code>\nBut my code is not returning the correct result.\
    \ For example:\n<code>&gt; (truncate_number 2.8)\n2.8\n&", "  (define int_part\
    \ (truncate number))\n  (- number int_part))\n", "  (let ((int-part (inexact->exact\
    \ (floor number))))\n    (- number int-part)))\n```\n\n14. Write a function that\
    \ will split a number into digits.\n\n```#lang racket\n", "  (define integral-part\
    \ (truncate number))\n  (- number integral-part))\n", "  (define (decimal number-int)\n\
    \    (- number number-int))\n  (decimal (round number)))\n", "  ;; You can use\
    \ the floor function from Racket:\n  ;; http://docs.racket-lang.org/reference/numbers.html#%28def._%28%28lib._racket%2Fmath..rkt%29._floor%29%29\n\
    \  ;; Hint: Remember that you have 3 ways to do arithmetic:\n  ;; 1. Using traditional\
    \ prefix form (ex: (+ a b) (- a b) (* a b) (/ a b))\n  ;; 2. Using infix form\
    \ with the function form (ex: (a + b) (a - b) (a * b) (a / b))\n  ;; 3. Using\
    \ the function form (ex: (+ a b) (- a b) (* a b) (/ a b))\n  )\n", "  ;; TODO\n\
    \  )\n", "  (define (eval-integer-part x)\n    (if (< x 1)\n        0\n      \
    \  (truncate x)))\n  (- number (eval-integer-part number)))\n", "  (define whole-part\
    \ (floor number))\n  (- number whole-part))\n", "  (if (&lt; (floor number) number)\n\
    \      (- number (floor number))\n      0.0))\n", "  (define (truncate-digit-helper\
    \ n)\n    (if (&lt; n 10)\n        n\n        (truncate-digit-helper (quotient\
    \ n 10))))\n  (/ (- number (truncate-digit-helper number)) 10))\n", "  (let ([i\
    \ (floor number)])\n    (- number i)))\n", "  (cond [(>= 1 number) 0]\n      \
    \  [else (- number (floor number))]))\n```\n\nEven though there is a function\
    \ that performs the desired operation", "  (- number (floor number)))\n", "  (define\
    \ (truncate-helper n i)\n    (if (>= n 1)\n        (truncate-helper (- n 1) (+\
    \ i 1))\n        (- n i)))\n  (truncate-helper number 0))\n", "  (define (helper\
    \ number result)\n    (if (&lt; number 1)\n        result\n        (helper (-\
    \ number 1) (+ result 1))))\n  (- number (helper number 0)))\n", "  ...)\n", " \
    \ (if (not (positive? number))\n      (display \"Error: number must be positive.\"\
    )\n      (let ((int (truncate number)))\n        (- number int))))\n", "  (let\
    \ ([number-as-string (number->string number)])\n    (string-&gt;number (string-trim\
    \ (regexp-replace* (regexp \"^\\\\d+\\\\.\") \"\" number-as-string)))))\n", " \
    \ (local ((define (get-floor-decimal-part number)\n            (cond\n       \
    \       [(> number 1) (get-floor-decimal-part (- number 1))]\n              [else\
    \ number])))\n    (cond\n      [(> number 1) (- number (get-floor-decimal-part\
    \ number))]\n      [else number])))\n", "  (if (&lt; number 1)\n      number\n\
    \      (truncate_number (- number 1))))\n", "  (define truncated-int (- (floor\
    \ number) number))\n  (define truncated-float (* truncated-int -1))\n  truncated-float)\n",
  "  (cond\n    [(< number 1)\n     (sub1 number)]\n    [else\n     (sub1 (truncate_number\
    \ (sub1 number)))]))\n```\n\n```racket\n#lang racket\n", "  (define (truncate-number-iter\
    \ number integer-part)\n    (cond\n      [(= number integer-part) 0]\n      [else\
    \ (- number integer-part)]))\n  (truncate-number-iter number (inexact->exact (floor\
    \ number))))\n", "  ;; how do I get a decimal value?\n  (modulo number 1))\n",
  "  (define (decimal-portion whole-portion)\n    (- whole-portion (floor whole-portion)))\n\
    \  (decimal-portion number))\n", "  (let* ([number (floor number)]\n         [result\
    \ (- number)])\n    result))\n```\n\n```scheme", "  (remainder number (floor number)))\n",
  "  (define n (integer->inexact number))\n  (- n (inexact->integer n)))\n", "  (let*\
    \ ([int-part (floor number)]\n         [dec-part (- number int-part)])\n    dec-part))\n",
  "  (- number (inexact->exact (inexact-part (floor number)))))\n", "  (modulo number\
    \ 1))\n", "  (if (and (integer? number) (&gt; number 0))\n      (truncate_number\
    \ (- number 1))\n      (if (integer? number)\n          0\n          number)))\n",
  "  (local [(define (truncate-helper n acc)\n            (if (and (integer? n) (not\
    \ (negative? n)))\n                acc\n                (truncate-helper (- n\
    \ 1) (+ acc (/ 1 (expt 10 (truncate-decimals n)))))))\n           (define (truncate-decimals\
    \ num)\n             (if (integer? num)\n                 0\n                \
    \ (+ 1 (truncate-decimals (/ num 10)))))\n           (define (truncate-integer-part\
    \ num)\n             (if (and (integer? num) (not (negative? num)))\n        \
    \         num\n                 (truncate-integer-part (- num 1))))]\n    (if\
    \ (integer? number)\n        0\n        (- number (truncate-integer-part number)))))\n",
  "  (- number (floor number)))\n", "  (if (integer? number)\n      0\n      (- number\
    \ (floor number))))\n", "  (if (integer? number)\n      0\n      (- number (floor\
    \ number))))\n", "  (- number (inexact->exact (floor number))))\n", "  (if (floor\
    \ number)\n      (+ number (- (floor number)))\n      0))\n", "  (define (truncate\
    \ number)\n    (if (<= number 1)\n        0\n        (truncate (- number 1))))\n\
    \  (- number (truncate number)))\n", "  (let* ([x (round number)]\n         [y\
    \ (sub1 x)])\n    (- number y)))\n", "  (if (positive? number)\n      (letrec\
    \ ([integer-part (floor number)]\n               [decimal-part (- number integer-part)])\n\
    \        decimal-part)\n      (error \"not a positive number\")))\n</code>\nThis\
    \ is what the test suite looks like.\n<code>#lang racket\n", "  (- number (truncate\
    \ number)))\n", "  (sub1 number (truncate number)))\n", "  (modulo number 1))\n",
  "  (let ((integer-part (truncate number)))\n    (- number integer-part)))\n", " \
    \ (- number (inexact->exact (floor number))))\n", "  (define (recursive n)\n \
    \   (if (or (&lt; n 1) (= n 1)) n (- n 1)))\n  (local ((define int-part (recursive\
    \ number)))\n    (- number int-part)))\n", "  (let* ([number (floor number)]\n\
    \         [truncate (- number number)])\n    truncate))\n", "  (define (truncate_helper\
    \ number acc)\n    (if (&lt; number 1)\n        acc\n        (truncate_helper\
    \ (- number 1) (+ acc 1))))\n  (- number (truncate_helper number 0)))\n", "  (modulo\
    \ number 1))\n", "  (let ([int_part (inexact->exact (floor number))])\n    (-\
    \ number int_part)))\n", "  (define (decimals n)\n    (if (integer? n)\n     \
    \ 0\n      (- n (exact-floor n))))\n  (decimals number))\n", "  (let ([int-part\
    \ (floor number)])\n    (- number int-part)))\n", "  (exact->inexact (/ (- number\
    \ (floor number)) 1)))\n", "  (let ([truncated-number (- number (fxround number))])\n\
    \    truncated-number))\n", "  (define (truncate-decimal-part number)\n    (if\
    \ (integer? number)\n        0\n        (- number (truncate number))))\n  (truncate-decimal-part\
    \ number))\n", "  (define (helper number)\n    (if (&lt; number 1)\n        (cons\
    \ 0 (cons number '()))\n        (let* ([int-part (integer-&gt;string (floor number))]\n\
    \               [leftover (string-&gt;number (- number (string-&gt;number int-part)))])\n\
    \          (cons (string-&gt;number int-part) (helper leftover)))))\n  (cdr (helper\
    \ number)))\n", "  (if (not (real? number))\n      (error \"Error: number is not\
    \ real.\")\n      (cond ((&lt; number 0)\n             (error \"Error: number\
    \ is not positive.\"))\n            ((= (truncate number) number)\n          \
    \   0)\n            (else (- number (truncate number))))))\n</code>\n", "  (define\
    \ (truncate-helper num)\n    (cond ((>= num 1) (truncate-helper (- num 1)))\n\
    \          ((< num 1) num)))\n  (truncate-helper number))\n", "  (define (iter\
    \ float x)\n    (if (&lt; float x)\n        (iter (* float 10) (* x 10))\n   \
    \     (* (- float (* (floor x) 10)) 10)))\n  (iter number 10))\n", "  (let ((number_integer\
    \ (truncate number)))\n    (- number number_integer)))\n", "  (define (truncate_number-iter\
    \ number decimals)\n    (if (number= 1 number)\n        decimals\n        (truncate_number-iter\
    \ (floor number) (fmod number 1))))\n  (truncate_number-iter number 0))\n", " \
    \ (define (decimals number)\n    (remainder number (inexact->exact (floor number))))\n\
    \  (decimals number))\n```\n\n#### Review\n\n```\n#lang racket\n", "  (define\
    \ integer-part (quotient number 1))\n  (- number integer-part))\n", "  (- number\
    \ (floor number)))\n", "  (define (truncate-integer number)\n    (if (zero? number)\
    \ 0\n      (if (&lt; number 1) number\n        (truncate-integer (quotient number\
    \ 10)))))\n  (- number (truncate-integer number)))\n</code>\nThe output of the\
    \ above code is as follows, where the first number is the input, and the second\
    \ is the expected output:\n<code>3.5 0.5\n3.141592653589793 0.141592653589793\n\
    1.7777777777777777 0.7777777777777777\n1.0 0.0\n0.5 0.5\n0.0 0.0\n</code>\nI would\
    \ have expected the output to be <code>1.0 0.0</code>, but instead, the code above\
    \ is converting <code>1.0</code> to an integer, so it is <code>1</code>, and the\
    \ code is subtracting that from <code>1.0</code>, giving <code>0.0</code>. \n\
    How can I fix this without changing the input interface to accept only integers?\n\
    \n\nA:\n\nI would do this with <code>floor</code>:\n<code>(define (truncate-number\
    \ number)\n  (- number (floor number)))\n</code>\nI don't see the point of re-implementing\
    \ <code>floor</code> when it exists. \n", "  (remainder number (floor number)))\n",
  "  (- number (floor number)))\n", "  (define integer_part (inexact->exact (floor\
    \ number)))\n  (- number integer_part))\n", "  (round (modulo number 1)))\n",
  "  (- number (floor number)))\n", "  (define (decimals-part n)\n    (if (&lt; n\
    \ 1) n (- n (floor n))))\n  (decimals-part number))\n", "  (define whole-number\
    \ (floor number))\n  (- number whole-number))\n", "  (define (int-part number)\n\
    \    (if (< number 1) 0\n        (1+ (int-part (- number 1)))))\n  (- number (int-part\
    \ number)))\n", "  (/ (- number (floor number)) 1.0))\n", "  (let ([full-num (integer->inexact\
    \ number)])\n    (let ([int-part (inexact->integer full-num)])\n      (- full-num\
    \ int-part))))\n", "  (define (loop i)\n    (if (< i number)\n        (loop (+\
    \ i 1))\n        (- number i)))\n  (loop 0))\n", "  (floor number))\n", "  (define\
    \ i (integer->char (truncate number)))\n  (- number (string->number (list-ref\
    \ (string->list (number->string number)) 0))))\n", "  (define whole_number (integer->char\
    \ (floor number)))\n  (- number (string->number whole_number)))\n", "  (truncate\
    \ number))\n", "  (- number (floor number)))\n", "  (let* ([number (round (* number\
    \ 10))]\n         [integer (quotient number 10)])\n    (/ (- number (* integer\
    \ 10)) 10)))\n", "  (define integer-part (truncate number))\n  (- number integer-part))\n",
  "  (require racket/fixnum)\n  (fixnum->flonum (- number (flonum->fixnum number))))\n",
  "  (define int-part (floor number))\n  (- number int-part))\n", "  (exact->inexact\
    \ (/ (- number (inexact->exact (truncate number))) 1)))\n", "  (define (helper\
    \ number i)\n    (cond ((= i number) 0)\n          ((> i number) (- i 1))\n  \
    \        (else (helper number (+ i 1)))))\n  (- number (helper number 0)))\n",
  "  (define (append list number)\n    (if (= (truncate number) number)\n        (cons\
    \ number list)\n        (append (cons (truncate number) list) (truncate (- number\
    \ (truncate number))))))\n  (define (from_digits list)\n    (let ((number (from_digits_iter\
    \ list 1)))\n      (if (> number 0)\n          (/ number (expt 10 (length list)))\n\
    \          0)))\n  (from_digits (append '() number)))\n", "  (cond\n    [(= (floor\
    \ number) number) 0]\n    [else (- number (floor number))]))\n", "  (let* ([integer-part\
    \ (inexact->exact (floor number))]\n         [decimal-part (- number integer-part)])\n\
    \    decimal-part))\n", "  (remainder number (floor number)))\n", "  (define (remainder\
    \ number)\n    (- number (floor number)))\n  (remainder number))\n", "  (round\
    \ (- number (floor number)) 3))\n", "  (- number (inexact->exact (floor number))))\n",
  "  (- number (floor number)))\n", "  (exact->inexact (- number (floor number))))\n",
  "  (- number (floor number)))\n", "  (define (help number)\n    (if (integer? number)\n\
    \        0\n        (+ (remainder number 1) (help (floor number)))))\n  (help\
    \ number))\n", "  (define int-part (integer->char (truncate number)))\n  (define\
    \ dec-part (substring number 1))\n  (string->number dec-part))\n", "  (- number\
    \ (exact-integer-sqrt number)))\n", "  (- number (truncate number)))\n", "  (local\
    \ ((define truncated-number (truncate number)))\n    (- number truncated-number)))\n",
  "  (* number (- 1 (floor number))))\n", "  (define integer-part (floor number))\n\
    \  (- number integer-part))\n", "  (local [(define (truncate_number number integer-part)\n\
    \            (cond\n              [(negative? number)\n               (truncate_number\
    \ (- number) integer-part)]\n              [(< number 1)\n               (cons\
    \ integer-part number)]\n              [else\n               (truncate_number\
    \ (- number 1) (+ integer-part 1))]))]\n    (cdr (truncate_number number 0))))\n",
  "  (define integer-part (quotient number 1))\n  (- number integer-part))\n", " \
    \ (define int-part (integer->char (truncate number)))\n  (define char-list (string->list\
    \ int-part))\n  (string->number (list->string (cdr char-list))))\n", "  (if (flzero?\
    \ (fl- (floor number) number))\n      0\n      (fl- number (floor number))))\n",
  "  ;; Use the modulo operator for the decimal part.\n  (modulo number 1))\n", " \
    \ (define (decimals num)\n    (modulo num 1))\n  (decimals number))\n", "  (...\
    \ number))\n", "  (define first_part (inexact->exact (floor number)))\n  (- number\
    \ first_part))\n", "  (define integer-part (inexact->exact (floor number)))\n\
    \  (- number integer-part))\n", "  (define integer_part (truncate number))\n \
    \ (- number integer_part))\n\n", "  (if (negative? number)\n      (- 1 (- number\
    \ (floor number)))\n      (- number (floor number))))\n", "  (exact->inexact (-\
    \ number (inexact->exact (floor number)))))\n", "  (- number (inexact->exact (floor\
    \ number))))\n```\n\n```racket\n#lang racket\n", "  (if (negative? number)\n \
    \     (- number (floor number))\n      (- number (floor number))))\n", "  (- number\
    \ (exact-integer-sqrt (floor number))))\n", "  (define integer-part (quotient\
    \ number 1))\n  (- number integer-part))\n", "  (let ([integer-part (inexact->exact\
    \ (floor number))])\n    (- number integer-part)))\n", "  (define integer-part\
    \ (truncate number))\n  (- number integer-part))\n", "  (remainder number (floor\
    \ number)))\n", "  (define int-part (- (floor number) number))\n  (if (&lt; int-part\
    \ 0)\n      (- int-part)\n      int-part))\n", "  (exact->inexact (remainder (inexact->exact\
    \ number) 1)))\n", "  (define (helper a b)\n    (- a (truncate a)))\n  (helper\
    \ number 1))\n", "  (define integer-part (inexact->exact (floor number)))\n  (-\
    \ number integer-part))\n", "  (match number\n    [(and (? number? x) (? (< x\
    \ 1))) x]\n    [(and (? number? x) (? (>= x 1))) (truncate_number (- x 1))]))\n",
  "  (let ([exact (truncate number)])\n    (- number exact)))\n", '  (modulo number
    1.0))', "  (define integer-part (inexact->exact (floor number)))\n  (- number\
    \ integer-part))\n", "  (let loop ((whole (floor number))\n             (remainder\
    \ (- number whole)))\n    (if (<= remainder 0)\n        0\n        remainder)))\n",
  "  (define (helper n factor)\n    (if (< n 1)\n        0\n        (+ (* n factor)\
    \ (helper (- n 1) (/ factor 10)))))\n  (helper (floor number) 0.1))\n", "  (local\
    \ [(define (next-num number-of-decimals)\n            (define (difference-of-num-and-prev-int\
    \ num)\n              (- num (inexact->exact (round num))))\n            (define\
    \ (position-of-decimal-point num)\n              (string-index num \".\"))\n \
    \           (define (decimal-part num)\n              (string-ref num (+ 1 (position-of-decimal-point\
    \ num))))\n            (define (next-decimal-number num)\n              (regexp-replace*\
    \ #rx\"\\..*\" (number->string num)\n                               (lambda (str)\n\
    \                                 (string-append \".\"\n                     \
    \                           (string-append\n                                 \
    \                (string (decimal-part num))\n                               \
    \                  (string (add1 (string->number\n                           \
    \                                     (string-drop str 1)))))))))\n          \
    \  (cond [(zero? number-of-decimals) num]\n                  [else (next-decimal-number\
    \ (next-num (sub1 number-of-decimals)))]))]\n    (next-num (position-of-decimal-point\
    \ (number->string number)))))", "  (let ([number-as-string (number->string number)])\n\
    \    (regexp-replace* #rx\"^[0-9]+.\" number-as-string \"\")\n    ))\n", "  (define\
    \ (truncate-helper x y)\n    (cond ((> x y) (truncate-helper (- x y) y))\n   \
    \       ((< x y) x)\n          (else 0)))\n  (truncate-helper (- number (inexact->exact\
    \ (floor number))) 1))\n", "  (let ([intpart (inexact->exact (floor number))])\n\
    \    (- number intpart)))\n", "  (- number (floor number)))\n```\n\n```racket\n\
    #lang racket\n", "  (define (truncate number)\n    (if (< number 1) number\n \
    \       (truncate (/ number 10))))\n  (- number (truncate number)))\n", "  (sub1\
    \ number (inexact->exact (floor number))))\n", "  (let ((int-part (inexact->exact\
    \ (floor number))))\n    (- number int-part)))\n", "  (display \"Enter a number\\\
    n\")\n  (define n (read))\n  (- n (floor n)))", "  (let ([int-part (inexact->exact\
    \ (floor number))])\n    (- number int-part)))\n", "  (define (loop number divisor\
    \ result)\n    (if (&lt;= number divisor)\n        (modulo (/ number divisor)\
    \ 1)\n        (loop number (* divisor 10) (* result 10))))\n  (loop number 10\
    \ 1))\n", "  (list 'THIS_IS_NOT_CORRECT))\n", "  (define int-part (inexact->exact\
    \ (floor number)))\n  (- number int-part))\n", "  (define remainder (modulo number\
    \ 1))\n  (if (negative? remainder)\n      (round number)\n      remainder))",
  "  (define (truncate_number_helper int-part dec-part)\n    (if (or (&lt; dec-part\
    \ 0)\n            (&gt; dec-part 1))\n        int-part\n        (truncate_number_helper\
    \ (+ int-part 1) (- dec-part 1))))\n  (- number (truncate_number_helper (quotient\
    \ number 1)\n                                    (- number (quotient number 1)))))\n\
    </code>\nTests:\n<code>;; Good Tests", "  (define decimals (- number (truncate\
    \ number)))\n  (if (negative? decimals)\n      (add1 decimals)\n      decimals))\n",
  "  (define integer-part (inexact->exact (floor number)))\n  (- number integer-part))\n",
  "  (let ([int-part (floor number)])\n    (- number int-part)))\n", "  (- number\
    \ (integer->inexact (floor number))))\n", "  (let ([int-part (inexact->exact (floor\
    \ number))])\n    (- number int-part)))\n", "  (let ([fn (floor number)])\n  \
    \  (- number fn)))\n", "  (- number (floor number)))\n", "  (define (truncate\
    \ number)\n    (cond\n      [(< number 1) number]\n      [else (truncate (- number\
    \ 1))]))\n  (- number (truncate number)))\n", "  (local [(define (decimals number)\n\
    \            (- number (truncate number)))\n          (define (truncate number)\n\
    \            (cond [(< number 1) 0]\n                  [else (+ (truncate (- number\
    \ 1)) 1)]))]\n    (decimals number)))\n", "  (define integral (floor number))\n\
    \  (- number integral))\n", "  (let ([decimals (modulo number 1)])\n    decimals))\n",
  "  (- number (truncate number)))\n", "  (define (inner number-int floor)\n    (if\
    \ (&lt;= number-int number)\n        (inner (add1 number-int) number-int)\n  \
    \      (- number floor)))\n  (inner 0 0))\n", "  (modulo number 1))\n", "  (define\
    \ (truncate n i)\n    (if (< n i)\n        (/ n i)\n        (truncate (- n i)\
    \ (* i 10))))\n  (if (integer? number)\n      0\n      (truncate number 1)))\n\
    ```\n\n## Frequency Analysis\n\nGiven an array of letters, return an object with\
    \ the frequency of letters as key/value pairs.\n\n```racket\n#lang racket\n",
  "  (if (&lt; number 1)\n      number\n      (- number (floor number))))\n", "  (define\
    \ (helper number integer-part)\n    (cond\n      [(< number 1) (values integer-part\
    \ (/ number 1))]\n      [else (helper (/ number 10) (add1 integer-part))]))\n\
    \  (call-with-values (lambda () (helper number 0))\n                    (lambda\
    \ (integer-part leftover)\n                      (/ (- number (* 10 leftover))\
    \ (* 10 integer-part)))))\n", "  (define integer-part (truncate number))\n  (-\
    \ number integer-part))\n", "  (let ((whole-part (truncate number)))\n    (- number\
    \ whole-part)))\n", "  ;; /\n  ;;\n  ;; \n  (define (truncate_iterative current-number\
    \ current-output)\n    (if (&lt; current-number 0)\n        current-output\n \
    \       (truncate_iterative (- current-number 1) (+ current-output number))))\n\
    \  (truncate_iterative (floor number) 0)\n)\n", "  (define (truncate_number-iter\
    \ number result)\n    (if (< number 1)\n        result\n        (truncate_number-iter\
    \ (- number 1) (- number 1))))\n  (- number (truncate_number-iter number 0)))\n",
  "  (define (loop number acc)\n    (if (= (truncate number) number)\n        acc\n\
    \        (loop (- number (truncate number)) (+ acc (truncate number)))))\n  (let\
    \ ([trunc (- number (truncate number))])\n    (if (= trunc 0)\n        0\n   \
    \     (loop (- number (truncate number)) 0))))\n", "  (local [(define integer-part\
    \ (quotient number 1))]\n    (- number integer-part)))\n", "  (if (negative? number)\n\
    \      (- number (truncate (- number)))\n      (- number (truncate number))))\n",
  "  (define number-as-string (number->string number))\n  (define decimal-separator-index\
    \ (regexp-index #rx\"\\.\" number-as-string))\n  (define decimals-as-string (substring\
    \ number-as-string (+ 1 decimal-separator-index)))\n  (string->number decimals-as-string))\n",
  "  (define (truncate-helper number integer-part)\n    (if (and (number? number)\
    \ (number? integer-part))\n        (if (&lt; number 1) number\n            (truncate-helper\
    \ (- number integer-part) (floor number)))))\n  (truncate-helper number (floor\
    \ number)))\n", "  (define integer-part (inexact->exact (truncate number)))\n\
    \  (- number integer-part))\n", "  (round number -1))\n", "  (let* ((integer-part\
    \ (truncate number))\n         (decimal-part (- number integer-part)))\n    decimal-part))\n",
  "  (- number (inexact->exact (floor number))))\n", "  (define (flr-int number)\n\
    \    (let ((base 10)\n          (res 0)\n          (pos 0))\n      (do ((i (floor\
    \ number) (- i 1)))\n          ((< i 0) res)\n        (set! res (+ res\n     \
    \                (* (- i (floor i))\n                        (expt base pos))))\n\
    \        (set! pos (+ pos 1)))))\n  (- number (flr-int number)))\n", "  (- number\
    \ (truncate number)))\n</code>\n", "  (cond [(<= number 0) (error \"Expected positive\
    \ number\")]\n        [else (let ([int-part (inexact->exact (floor number))])\n\
    \                 (- number int-part))]))\n", "  (- number (truncate number)))\n",
  "  (- number (floor number)))\n", "  (local ((define n (inexact->exact number)))\n\
    \    (- number n)))\n", "  (sub1 number (floor number)))\n", "  (if (< number\
    \ 1)\n      (- number (integer->inexact (round number)))\n      (truncate_number\
    \ (- number 1))))\n", "  (... number))\n", "  (define (truncate-help number truncated)\n\
    \    (cond\n      [(< number 1) (truncated)]\n      [else (truncate-help (- number\
    \ 1) (+ truncated 1))]))\n  (- number (truncate-help number 0)))\n```\n\n## Problem\
    \ 3.11\n\n```racket\n#lang racket\n", "  (define integer-part (inexact->exact\
    \ (floor number)))\n  (- number integer-part))\n", "  (local ((define-values (integer-part\
    \ decimals) (truncate number)))\n    decimals))\n", "  (define integer-part (truncate\
    \ number))\n  (- number integer-part))\n", "  (local [(define (truncate_number\
    \ number current-truncation result)\n            (cond\n              [(= 0 number)\n\
    \               (local [(define (convert_to_decimal number)\n                \
    \         (/ number current-truncation))]\n                 (convert_to_decimal\
    \ result))]\n              [(>= number current-truncation)\n               (truncate_number\
    \ (- number current-truncation)\n                                (* current-truncation\
    \ 10)\n                                (+ (* current-truncation (quotient number\
    \ current-truncation))\n                                   result))]\n       \
    \       [else\n               (truncate_number number\n                      \
    \          (* current-truncation 10)\n                                result)]))]\n\
    \    (truncate_number number 1 0)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
