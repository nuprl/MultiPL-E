name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; count_upper('aBCdEf') returns 1\n;; count_upper('abcdefg')\
  \ returns 0\n;; count_upper('dBBE') returns 0\n(define (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (string-fold (lambda (char sum)\n                 (if (and (vowel?\
    \ char)\n                          (even? sum))\n                     (+ sum 1)\n\
    \                     sum))\n               0\n               s))\n", "  (cond\
    \ [(empty? s) 0]\n        [(and (= (modulo (position (car s) s) 2) 0)\n      \
    \        (member (upcase (car s)) '(#\\A #\\E #\\I #\\O #\\U)))\n         (+ 1\
    \ (count_upper (cdr s)))]\n        [else (count_upper (cdr s))]))\n</code>\nOne\
    \ note: when you're doing an <code>and</code> or <code>or</code> of a whole bunch\
    \ of tests, it's better to write out the tests and rearrange the order of the\
    \ tests a bit so that you can use short-circuiting to your advantage.  In this\
    \ case, if the first thing in the <code>and</code> is false, you know the whole\
    \ thing is false, so there's no need to compute <code>(position (car s) s)</code>\
    \ or <code>(member (upcase (car s)) '(#\\A #\\E #\\I #\\O #\\U))</code> or do\
    \ the <code>upcase</code>.  So you can write it as\n<code>(and (member (upcase\
    \ (car s)) '(#\\A #\\E #\\I #\\O #\\U))\n     (= (modulo (position (car s) s)\
    \ 2) 0))\n</code>\n", "  (count-upper-helper s 0))\n", "  (define (helper s i\
    \ count)\n    (cond\n      [(> i (string-length s)) count]\n      [(and (even?\
    \ i) (vowel? (string-ref s i) #t)) (helper s (+ i 1) (+ count 1))]\n      [else\
    \ (helper s (+ i 1) count)]))\n  (helper s 0 0))\n", "  (define (is_upper? c)\n\
    \    (member c '(#\\A #\\E #\\I #\\O #\\U)))\n  (define (is_even? n)\n    (= (remainder\
    \ n 2) 0))\n  (define (get-vowels-even-indices s)\n    (if (null? s)\n       \
    \ '()\n        (if (is_even? (string-length s))\n            (if (is_upper? (string-ref\
    \ s 0))\n                (cons (string-ref s 0) (get-vowels-even-indices (substring\
    \ s 1)))\n                (get-vowels-even-indices (substring s 1)))\n       \
    \     (get-vowels-even-indices (substring s 1)))))\n  (length (get-vowels-even-indices\
    \ s)))\n", "  (let ((n (length s))\n        (i -1)\n        (count 0))\n    (let\
    \ loop ((i i))\n      (if (< i n)\n          (begin\n            (cond\n     \
    \         ((and (char-upper-case? (string-ref s i))\n                    (vowel?\
    \ (string-ref s i)))\n               (set! count (+ count 1)))\n             \
    \ (else 'false))\n            (loop (+ i 2)))))\n    count))\n", "  ;; Again,\
    \ get indices and use map\n  (count-if (lambda (idx)\n              (and (even?\
    \ idx) ;; checks if it's even\n                   (member (char-upcase (string-ref\
    \ s idx)) ;; checks if it's upper\n                           '(#\\A #\\E #\\\
    I #\\O #\\U))))\n            (build-list (string-length s) identity)))\n", " \
    \ (cond\n    [(empty? s) 0]\n    [(vowel? (string-ref s 0))\n     (count_upper\
    \ (substring s 2))]\n    [else\n     (count_upper (substring s 1))]))\n", "  (cond\
    \ ((null? s) 0)\n        ((char-lower-case? (string-ref s 0)) (count_upper (substring\
    \ s 1)))\n        ((member (string-ref s 0) '#(#\\A #\\E #\\I #\\O #\\U)) (add1\
    \ (count_upper (substring s 2))))\n        (else (count_upper (substring s 2)))))\n",
  "  (if (not (or (string=? s \"\") (string=? s \"a\") (string=? s \"e\") (string=?\
    \ s \"i\") (string=? s \"o\") (string=? s \"u\")))\n      (let ([first (substring\
    \ s 0 1)]\n            [rest (substring s 1)])\n        (cond\n         [(string=?\
    \ (string-upcase first) first) (+ 1 (count_upper rest))]\n         [else (count_upper\
    \ rest)]))\n      0))\n</code>\nThe problem is that when I try to run this, it\
    \ gives me a \n<code>application: not a procedure;\n expected a procedure that\
    \ can be applied to arguments\n  given: #&lt;syntax:racket/base:200:8&gt;\n  arguments...:\n\
    \   \"\"\n</code>\nI've tried changing the syntax, but it's always the same.\n\
    \n\nA:\n\nYou just need to remove the rest of the characters when it's a vowel:\n\
    <code>(define (count_upper s)\n  (if (not (or (string=? s \"\") (string=? s \"\
    a\") (string=? s \"e\") (string=? s \"i\") (string=? s \"o\") (string=? s \"u\"\
    )))\n      (let ([first (substring s 0 1)]\n            [rest (substring s 1)])\n\
    \        (cond\n         [(string=? (string-upcase first) first) (+ 1 (count_upper\
    \ rest))]\n         [else (count_upper rest)]))\n      0))\n</code>\n", "  (let\
    \ loop ([s s] [acc 0])\n    (if (empty? s)\n        acc\n        (if (in-range?\
    \ (modulo (char-upcase (car s)) 65) 5)\n            (loop (cdr s) (+ acc 1))\n\
    \            (loop (cdr s) acc)))))\n", "  (cond [(null? s) 0]\n        [(and\
    \ (vowel? (string-ref s 0))\n              (upper? (string-ref s 0))) (+ 1 (count_upper\
    \ (substring s 2)))]\n        [else (count_upper (substring s 2))]))\n", "  (define\
    \ (is_upper c)\n    (define (is_vowel c)\n      (member c '(#\\a #\\e #\\i #\\\
    o #\\u)))\n    (and\n     (is_vowel c)\n     (char-upcase c)\n     (char=? c (char-upcase\
    \ c))))\n  (define (is_even n)\n    (= (remainder n 2) 0))\n  (define (count_upper_helper\
    \ i c-list acc)\n    (cond\n      [(null? c-list) acc]\n      [(is_even i) (count_upper_helper\
    \ (+ i 1) (cdr c-list) (if (is_upper (car c-list)) (+ acc 1) acc))]\n      [else\
    \ (count_upper_helper (+ i 1) (cdr c-list) acc)]))\n  (count_upper_helper 0 (string->list\
    \ s) 0))", "  (local [(define (count-vowels so-far str)\n            (cond [(empty?\
    \ str) so-far]\n                  [(and (member (car str) '(#\\A #\\E #\\I #\\\
    O #\\U))\n                        (even? (string-length so-far)))\n          \
    \         (count-vowels (string-append so-far (list (car str)))\n            \
    \                     (cdr str))]\n                  [else (count-vowels so-far\
    \ (cdr str))]))]\n    (count-vowels \"\" s)))\n", "  (define (count_upper_iter\
    \ ind s)\n    (cond\n      [(= ind (string-length s)) 0]\n      [(and (even? ind)\
    \ (vowel? (string-ref s ind)))\n       (+ 1 (count_upper_iter (+ ind 1) s))]\n\
    \      [else (count_upper_iter (+ ind 1) s)]))\n  (count_upper_iter 0 s))\n",
  "  (let ((count 0))\n    (for/fold ([count 0]) ([c (in-string s)])\n      (cond\n\
    \        [(char-upper-case? c)\n         (if (even? count)\n             (add1\
    \ count)\n             count)]\n        [else\n         count]))\n    count))\n\
    </code>\nI could not decide which option is better. I guess that the first one\
    \ is more idiomatic, but the other one is more concise and readable.\n\n\nA:\n\
    \nThe most Racket-idiomatic way to do this would be to use a named <code>let</code>-binding\
    \ instead of a variable, and to use <code>andmap</code> instead of <code>for/fold</code>:\n\
    <code>(define (count-upper s)\n  (andmap\n   char-upper-case?\n   (in-string (substring\
    \ s 1 2))))\n</code>\nUsing <code>andmap</code> will automatically stop looking\
    \ as soon as it finds an even character that is not an uppercase vowel. \nYou\
    \ could also use <code>for/fold</code> with <code>break</code> to short-circuit:\n\
    <code>(define (count-upper s)\n  (for/fold ([count 0]) ([c (in-string s)])\n \
    \   (cond\n      [(char-upper-case? c)\n       (if (even? count)\n           (begin\
    \ (break) (add1 count))\n           count)]\n      [else\n       count])))\n</code>\n",
  "  (cond\n    [(empty? s) 0]\n    [(vowel? (string-ref s 0)) (+ 1 (count_upper (string-drop\
    \ s 2)))]\n    [else (count_upper (string-drop s 2))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(char-upper-case? (string-ref s 0))\n     (+ 1 (count_upper (substring\
    \ s 2)))]\n    [else (count_upper (substring s 2))]))\n", "  (cond [(empty? s)\
    \ 0]\n        [(string-upper-case? (string-ref s 0))\n         (+ 1 (count_upper\
    \ (substring s 2)))]\n        [else (count_upper (substring s 2))]))\n</code>\n\
    What I'm trying to do is count the number of vowels in even indices in a string\
    \ (they're uppercase).\nThe last test case should return 2, but is returning 0.\
    \ I've run out of ideas as to why this is happening. I think it's something to\
    \ do with calling <code>substring</code> with the wrong index, but I'm not sure.\n\
    Any help would be appreciated.\n\n\nA:\n\nIt's because you skip the first character\
    \ if it's an upper case letter (or anything, for that matter), and that's preventing\
    \ you from properly counting. Start by fixing that:\n<code>(define (count_upper\
    \ s)\n  (cond [(empty? s) 0]\n        [(string-upper-case? (string-ref s 0))\n\
    \         (+ 1 (count_upper (substring s 2)))]\n        [else\n         (count_upper\
    \ (substring s 1))]))\n</code>\nNow, there's a more direct and elegant way to\
    \ solve this, using <code>foldl</code>, <code>string-index</code> and a helper\
    \ procedure. Here's a solution:\n<code>(define (count-upper s)\n  (let loop ([i\
    \ 0] [count 0])\n    (if (string-index s i)\n        (let ([c (string-ref s i)])\n\
    \          (if (string-upper-case? c)\n              (loop (+ i 2) (+ count 1))\n\
    \              (loop (+ i 2) count)))\n        count)))\n</code>\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(vowel? (char-upcase (first s)))\n     (if (even? (string-index\
    \ s (first s)))\n         (+ 1 (count_upper (rest s)))\n         (count_upper\
    \ (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (let* ([cnt 0]\n   \
    \      [str-len (string-length s)]\n         [str-chars (string->list s)])\n \
    \   (for ([i (in-range 0 str-len 2)])\n      (if (member (list-ref str-chars i)\
    \ '(#\\A #\\E #\\I #\\O #\\U))\n          (set! cnt (+ cnt 1))))\n    cnt))\n",
  "  (let ((counter 0))\n    (for ((i (in-range (string-length s))))\n      (when\
    \ (and (= (modulo i 2) 0) (member (string-ref s i) '(#\\A #\\E #\\I #\\O #\\U)))\n\
    \        (set! counter (+ counter 1))))\n    counter))\n", "  (count-every-even\
    \ #true\n                    (string-&gt;list s)\n                    is-vowel?\n\
    \                    char-upcase?))\n", "  (define (count_upper' s index count)\n\
    \    (cond [(equal? (length s) index) count]\n          [(and (string-contains\
    \ \"AEIOU\" (string-ref s index))\n                (even? index))\n          \
    \ (count_upper' s (+ index 1) (+ count 1))]\n          [else (count_upper' s (+\
    \ index 1) count)]))\n  (count_upper' s 0 0))\n", "  (letrec ([s-even (lambda\
    \ (s) (string-join (filter (lambda (x) (even? (string-ref s x))) (string->list\
    \ s))))])\n    (length (filter char-ci=? (string->list \"AEIOU\") (string->list\
    \ (s-even s))))))\n", "  (define (is_upper c)\n    (char-upcase c))\n  (define\
    \ (is_vowel c)\n    (member c '(\"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define (even\
    \ i)\n    (= (modulo i 2) 0))\n  (define (count_upper_iter s i sum)\n    (cond\
    \ ((= i (string-length s)) sum)\n          ((and (even i) (is_upper (string-ref\
    \ s i)) (is_vowel (string-ref s i)))\n           (count_upper_iter s (+ i 1) (+\
    \ sum 1)))\n          (else (count_upper_iter s (+ i 1) sum))))\n  (count_upper_iter\
    \ s 0 0))\n", "  (define (count_upper-helper s idx acc)\n    (cond ((string=?\
    \ \"\" s) acc)\n          ((and (char-uppercase? (string-ref s idx)) (vowel? (string-ref\
    \ s idx)))\n           (count_upper-helper (substring s 1) (+ idx 1) (+ acc 1)))\n\
    \          (else (count_upper-helper (substring s 1) (+ idx 1) acc))))\n  (count_upper-helper\
    \ s 0 0))\n", "  (define (count-upper-vowels s)\n    (if (null? s)\n        0\n\
    \        (if (and (char-upper-case? (car s)) (vowel? (car s)))\n            (+\
    \ 1 (count-upper-vowels (cdr s)))\n            (count-upper-vowels (cdr s)))))\n\
    \  (count-upper-vowels (even-indices s)))\n", "  (count_upper_recursive s 0))\n",
  "  (let loop ([s s] [acc 0])\n    (cond [(empty? s) acc]\n          [(member (first\
    \ s) '(#\\A #\\E #\\I #\\O #\\U))\n           (loop (rest s) (+ 1 acc))]\n   \
    \       [else (loop (rest s) acc)])))\n", "  (define (is_upper c) (char-upcase\
    \ c))\n  (define (is_even i) (= (modulo i 2) 0))\n  (define (is_vowel c)\n   \
    \ (let ([c (char-downcase c)])\n      (or (char=? c #\\a)\n          (char=? c\
    \ #\\e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=?\
    \ c #\\u))))\n  (count (compose1 is_upper is_vowel) (string-indexes s is_even)))\n",
  "  (define (count_upper-aux s acc)\n    (cond\n      [(empty? s) acc]\n      [(or\
    \ (= 'a (first s)) (= 'e (first s)) (= 'i (first s)) (= 'o (first s)) (= 'u (first\
    \ s)))\n       (count_upper-aux (rest s) (if (even? acc) (+ acc 1) acc))]\n  \
    \    [else (count_upper-aux (rest s) (+ acc 1))]))\n  (count_upper-aux s 0))\n",
  "  (length (filter string-upper-case? (string-split s #\" \"))))\n", "  (define\
    \ (vowel? c)\n    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=?\
    \ c #\\i)\n        (char=? c #\\o)\n        (char=? c #\\u)))\n  (define (upper?\
    \ c)\n    (char-upper-case? c))\n  (define (upper-vowel? c)\n    (and (vowel?\
    \ c) (upper? c)))\n  (define (accumulator string-index letter-number)\n    (cond\n\
    \      [(= string-index (- (string-length s) 1)) letter-number]\n      [(even?\
    \ string-index)\n       (accumulator (+ string-index 1)\n                    (+\
    \ letter-number\n                       (if (upper-vowel? (string-ref s string-index))\n\
    \                           1\n                           0)))]\n      [else (accumulator\
    \ (+ string-index 1) letter-number)]))\n  (accumulator 0 0))\n</code>\n", "  (foldl\
    \ + 0\n         (filter (lambda (e) (is-vowel? e) (is-upper? e))\n           \
    \      (build-list (string-length s) (lambda (i) (string-ref s i))))))\n", " \
    \ (let loop ([s s] [count 0])\n    (if (null? s)\n        count\n        (if (and\
    \ (= (modulo (string-length s) 2) 0)\n                 (member (string-ref s 0)\
    \ '(#\\A #\\E #\\I #\\O #\\U)))\n            (loop (substring s 1) (+ count 1))\n\
    \            (loop (substring s 1) count)))))\n", "  (cond\n    [(null? s) 0]\n\
    \    [(and\n      (eq? (char-upcase (car s)) (car s))\n      (member (car s) '(#\\\
    A #\\E #\\I #\\O #\\U)))\n     (+ 1 (count_upper (cdr s)))]\n    [else (count_upper\
    \ (cdr s))]))\n", "  (define (is_vowel c)\n    (or (= c #\\a) (= c #\\e) (= c\
    \ #\\i) (= c #\\o) (= c #\\u)))\n  (define (is_even-index-uppercase str i)\n \
    \   (and (= (remainder i 2) 0)\n         (not (is_vowel (string-ref str i)))\n\
    \         (char-upper-case? (string-ref str i))))\n  (for/sum ([i (in-range (string-length\
    \ s))])\n    (is_even-index-uppercase s i)))\n</code>\n", "  (let loop ([s s]\
    \ [n 0])\n    (if (string-empty? s)\n        n\n        (if (and (member (string-ref\
    \ s 0) \"aeiouAEIOU\") (odd? (string-length s)))\n            (loop (substring\
    \ s 1) (+ n 1))\n            (loop (substring s 1) n)))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(symbol-upcase? (string-ref s 0)) (+ 1 (count_upper (substring s\
    \ 2)))]\n    [else (count_upper (substring s 2))]))\n</code>\nThis is clearly\
    \ still not optimal, so I would like to use regexps. I tried:\n<code>#lang racket\n",
  "  (let loop ([s s] [i 0] [acc 0])\n    (cond\n      [(empty? s) acc]\n      [(char-upcase?\
    \ (first s))\n       (loop (rest s) (+ i 1)\n             (if (even? i) (+ acc\
    \ 1) acc))]\n      [else (loop (rest s) (+ i 1) acc)])))\n", "  (define vowels\
    \ '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n  (define (is_vowel? ch)\n    (if (member\
    \ ch vowels)\n        true\n        false))\n  (define (even-indices lst)\n  \
    \  (filter (lambda (n) (= (remainder n 2) 0))\n            (range (length lst))))\n\
    \  (define (count-vowels lst idxs)\n    (cond\n      [(empty? idxs) 0]\n     \
    \ [(is_vowel? (list-ref lst (first idxs))) (+ 1 (count-vowels lst (rest idxs)))]\n\
    \      [else (count-vowels lst (rest idxs))]))\n  (count-vowels (string->list\
    \ s) (even-indices (string->list s))))\n```\n\nJava\n```java\npublic static int\
    \ countUpper(String s) {\n  String vowels = \"AEIOU\";\n  return IntStream.range(0,\
    \ s.length())\n                  .filter(i -> i % 2 == 0)\n                  .filter(i\
    \ -> vowels.contains(s.substring(i, i + 1)))\n                  .count();\n}\n\
    ```\n## Words with no vowels\nProblem statement\n\nGiven a list of words (strings),\
    \ return the list with all words that have no vowels removed.\n\nVowels are \"\
    a\", \"e\", \"i\", \"o\", \"u\".\n\nFor example:\n```\nfilter_no_vowels([\"python\"\
    , \"haskell\", \"java\"]) returns [\"haskell\"]\nfilter_no_vowels([\"javascript\"\
    , \"ruby\", \"C\", \"go\"]) returns [\"C\", \"go\"]\n```\n\nYou may assume that\
    \ the list contains no null strings.\n\nSolutions\n\nRacket\n```racket\n#lang\
    \ racket\n", "  (letrec ([ss (string->list s)]\n           [even (lambda (i) (=\
    \ (remainder i 2) 0))]\n           [is_upper (lambda (c) (char-upper-case? c))]\n\
    \           [is_vowel (lambda (c) (member c '(#\\a #\\e #\\i #\\o #\\u)))])\n\
    \    (count (lambda (c) (and (is_upper c) (is_vowel c)))\n           (filter even\
    \ ss))))\n", "  (define (count_upper_help s i acc)\n    (cond\n      [(empty?\
    \ s)\n       acc]\n      [(or (= i 0) (= i 2) (= i 4) (= i 6) (= i 8))\n     \
    \  (cond\n         [(char-upper-case? (first s))\n          (count_upper_help\
    \ (rest s) (+ i 1) (+ acc 1))]\n         [else\n          (count_upper_help (rest\
    \ s) (+ i 1) acc)])]\n      [else\n       (count_upper_help (rest s) (+ i 1) acc)]))\n\
    \  (count_upper_help s 0 0))\n", "  (cond\n    [(empty? s) 0]\n    [(and (vowel?\
    \ (car s)) (even? (remainder (string-length s) 2))) (+ 1 (count_upper (cdr s)))]\n\
    \    [else (count_upper (cdr s))]))\n", "  (let loop ([s s] [i 0] [acc 0])\n \
    \   (cond [(eq? i (string-length s)) acc]\n          [(and (equal? (char-upcase\
    \ (string-ref s i)) (string-ref s i))\n                (equal? (char-downcase\
    \ (string-ref s i)) \"a\")\n                (even? i))\n           (loop (substring\
    \ s 1) (+ i 1) (+ acc 1))]\n          [else (loop (substring s 1) (+ i 1) acc)])))\n",
  "  (let loop ([s s] [count 0])\n    (cond [(empty? s) count]\n          [(and (even?\
    \ (string-length s)) (member (string-ref s 0) '(\"A\" \"E\" \"I\" \"O\" \"U\"\
    )))\n           (loop (substring s 1) (+ count 1))]\n          [else (loop (substring\
    \ s 1) count)])))\n", "  (define (is_upper? c)\n    (or (= (char-upcase c) c)\n\
    \        (= (char-downcase c) c)))\n  (define (is_vowel? c)\n    (or (= c #\\\
    a)\n        (= c #\\e)\n        (= c #\\i)\n        (= c #\\o)\n        (= c #\\\
    u)))\n  (if (null? s)\n      0\n      (if (and (= (modulo (string-length s) 2)\
    \ 0)\n               (is_upper? (string-ref s 0))\n               (is_vowel? (string-ref\
    \ s 0)))\n          (+ 1 (count_upper (substring s 1)))\n          (count_upper\
    \ (substring s 1)))))\n</code>\nHere are some tests for the function:\n<code>#lang\
    \ racket\n", "  (cond\n    [(string-empty? s) 0]\n    [(vowel? (string-ref s 0))\
    \ (+ (odd? (string-length s)) (count_upper (string-tail s)))]\n    [else (count_upper\
    \ (string-tail s))]))\n", "  ;; split into a list of characters, then count if\
    \ uppercase, even and a vowel\n  (length (filter (lambda (x)\n               \
    \     (cond\n                      [(and (even? (string-ref s x))\n          \
    \                  (char-upper-case? (string-ref s x))\n                     \
    \       (member (string-ref s x) '(#\\A #\\E #\\I #\\O #\\U)))\n             \
    \          #t]\n                      [else #f]))\n                  (iota (string-length\
    \ s)))))\n</code>\n", "  (check-expect (count_upper \"aBCdEf\") 1)\n  (check-expect\
    \ (count_upper \"abcdefg\") 0)\n  (check-expect (count_upper \"dBBE\") 0)\n  (define\
    \ vowel-list (list \"A\" \"E\" \"I\" \"O\" \"U\"))\n  (cond\n    [(empty? s) 0]\n\
    \    [(and (member (string-upper-case (first s)) vowel-list)\n          (even?\
    \ (length s))) (+ 1 (count_upper (rest s)))]\n    [else (count_upper (rest s))]))\n\
    </code>\nWhat I'm trying to do here is say that if the current string position\
    \ is an even number, then if the character is a vowel and uppercase, add 1 to\
    \ the count. This works on the example I provided, but breaks in some edge cases,\
    \ such as \"ABCD\". \nHow can I fix this so that it works properly?\nThanks.\n\
    \n\nA:\n\nOne thing that's going to cause you problems is that you're trying to\
    \ iterate over both <code>s</code> and the index. That's a recipe for a disaster,\
    \ because the two lists don't have the same length and it's going to be hard to\
    \ keep the two lists in sync.\nInstead, keep two indices, one that's the current\
    \ index into <code>s</code> and another that keeps track of how many strings you've\
    \ already iterated over. That way, you're only iterating over one list. Your code\
    \ should look something like:\n<code>(define (count_upper s)\n  (check-expect\
    \ (count_upper \"aBCdEf\") 1)\n  (check-expect (count_upper \"abcdefg\") 0)\n\
    \  (check-expect (count_upper \"dBBE\") 0)\n  (define vowel-list (list \"A\" \"\
    E\" \"I\" \"O\" \"U\"))\n  (define (count_upper_helper s s-index count)\n    (cond\n\
    \      [(empty? s) count]\n      [(and (member (string-upper-case (first s)) vowel-list)\n\
    \            (even? s-index))\n       (count_upper_helper (rest s", "  ;; insert\
    \ your code here\n  )\n</code>\nThe I would do something like\n<code>#lang racket",
  "  (define vowels \"AEIOU\")\n  (define (upper-vowel? c)\n    (member c (string-upcase\
    \ vowels)))\n  (define (even? n)\n    (= (remainder n 2) 0))\n  (define (count-even-uppers\
    \ s)\n    (if (empty? s)\n        0\n        (+ (if (and (even? (char-index c))\n\
    \                   (upper-vowel? c))\n               1\n               0)\n \
    \          (count-even-uppers (rest s)))))\n  (count-even-uppers (string->list\
    \ s)))\n```\n\n```racket\n#lang racket\n", "  (let ([vowels '#(#\\a #\\e #\\i\
    \ #\\o #\\u)])\n    (for/sum ([i (in-range (string-length s))]\n             \
    \ [v vowels])\n      (and (even? i)\n           (char-upper-case? (string-ref\
    \ s i))\n           (equal? (char-upcase v) (string-ref s i))))))\n", "  (let\
    \ ((c 0))\n    (for ([i (in-range (string-length s))])\n      (when (member (string-ref\
    \ s i) '(#\\A #\\E #\\I #\\O #\\U))\n        (unless (odd? i)\n          (set!\
    \ c (+ c 1)))))\n    c))\n</code>\n", "  (let loop ([s s] [count 0])\n    (cond\
    \ [(null? s) count]\n          [(and (is_upper_vowel (car s))\n              \
    \  (even? (remainder (string-length s) 2)))\n           (loop (cdr s) (+ count\
    \ 1))]\n          [else (loop (cdr s) count)])))\n", "  (let loop ([s s] [i 0]\
    \ [n 0])\n    (if (or (null? s) (= i 0))\n        n\n        (loop (cdr s) (-\
    \ i 1)\n              (if (or (equal? (car s) 'A)\n                      (equal?\
    \ (car s) 'E)\n                      (equal? (car s) 'I)\n                   \
    \   (equal? (car s) 'O)\n                      (equal? (car s) 'U))\n        \
    \          (+ n 1)\n                  n)))))\n", "  (let loop ([s s] [counter\
    \ 0])\n    (cond [(empty? s) counter]\n          [(even? (remainder (pos s) 2))\n\
    \           (cond [((member (string-ref s 0) '(\"A\" \"E\" \"I\" \"O\" \"U\"))\
    \ #t)\n                  (loop (rest s) (+ counter 1))]\n                 [else\
    \ (loop (rest s) counter)])]\n          [else (loop (rest s) counter)])))\n</code>\n\
    Here's my attempt at Clojure:\n<code>(defn count-upper [s]\n  (loop [s s counter\
    \ 0]\n    (cond (empty? s) counter\n          (even? (remainder (pos s) 2))\n\
    \          (cond (member (string (first s)) [\"A\" \"E\" \"I\" \"O\" \"U\"])\n\
    \                (loop (rest s) (+ counter 1))\n                (loop (rest s)\
    \ counter))\n          (loop (rest s) counter))))\n</code>\nBut it doesn't seem\
    \ to be working at all. Any ideas?\n\n\nA:\n\nThe main problem is a misunderstanding\
    \ of how to use <code>cond</code>.\n<code>cond</code> takes pairs of values. \
    \ It tries to evaluate the first value in each pair.  If it's <code>true</code>,\
    \ it returns the second value in that pair.  Otherwise, it tries the next pair,\
    \ etc.\nThe first pair of your <code>cond</code> is <code>(empty? s)</code> and\
    \ <code>counter</code>.  Since <code>empty?</code> is true of <code>s</code>,\
    \ your <code>cond</code> returns <code>counter</code> and never tries the other\
    \ pairs.\nYou actually want to use <code>if</code> here instead of <code>cond</code>,\
    \ and use <code>cond</code> inside the <code>if</code>.\nThere are other problems,\
    \ too.  For example, you need to dereference <code>s</code> with <code>first</code>\
    \ and <code>rest</code>, not <code>pos</code> and <code>string</code>.\n", " \
    \ (let loop ([s s] [u 0])\n    (if (null? s)\n        u\n        (if (and (char-upper-case?\
    \ (car s))\n                 (char-vowel? (car s))\n                 (even? (string-index\
    \ s (car s))))\n            (loop (cdr s) (+ u 1))\n            (loop (cdr s)\
    \ u)))))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (string-index s))\n   \
    \  (if (member (string-ref s 0) \"AEIOU\")\n         (+ 1 (count_upper (string-drop\
    \ s 1)))\n         (count_upper (string-drop s 1)))]\n    [else (count_upper (string-drop\
    \ s 1))]))\n", "  (define (is_upper? c)\n    (and (not (string=? (string-upcase\
    \ c) (string-downcase c)))\n         (string=? (string-upcase c) c)))\n  (count\
    \ (lambda (c i)\n           (and (is_upper? c)\n                (even? i)))\n\
    \         s))\n", "  (let loop ([s s] [index 2] [count 0])\n    (cond\n      [(empty?\
    \ s) count]\n      [(and (eq? (modulo index 2) 0)\n            (eq? (string-upcase\
    \ (first s)) (first s))\n            (or (eq? (first s) #\\A)\n              \
    \  (eq? (first s) #\\E)\n                (eq? (first s) #\\I)\n              \
    \  (eq? (first s) #\\O)\n                (eq? (first s) #\\U)))\n       (loop\
    \ (rest s) (+ index 1) (+ count 1))]\n      [else (loop (rest s) (+ index 1) count)])))\n",
  "  (let loop ([s s] [count 0])\n    (if (empty? s)\n        count\n        (cond\n\
    \         [(and (eq? (char-upcase (first s)) (first s))\n               (is_vowel\
    \ (first s))\n               (even? (index (first s) s)))\n          (loop (rest\
    \ s) (+ count 1))]\n         [else (loop (rest s) count)]))))\n", "  (match (regexp-match*\
    \ #rx\"[AEIOU]\" s)\n    [(list) 0]\n    [(list ':submatch m) (if (even? (string-length\
    \ m)) 1 0)]))\n", "  (let ([accumulator 0])\n    (for ([i (in-range (string-length\
    \ s))])\n      (when (and (even? i) (is-vowel (char-upcase (string-ref s i))))\n\
    \        (set! accumulator (+ accumulator 1))))\n    accumulator))\n", "  (count\
    \ (\u03BB (c) (char-ci=? c #\\a #\\e #\\i #\\o #\\u)) (in-index (in-index s even?)\
    \ upper-case?)))\n</code>\nThis is using the utilities I defined in my general\
    \ library.\n", "  (define (iter s i)\n    (cond\n      [(empty? s) 0]\n      [(char-upcase?\
    \ (first s))\n       (if (zero? (modulo i 2))\n           (+ 1 (iter (rest s)\
    \ (+ i 1)))\n           (iter (rest s) (+ i 1)))]\n      [else (iter (rest s)\
    \ (+ i 1))]))\n  (iter s 0))\n", "  (define (count_upper_helper s acc index)\n\
    \    (cond ((< acc 0) acc)\n          ((string-empty? s) acc)\n          ((string-index-of-pred\
    \ \"AEIOU\" (string-ref s 0))\n           (count_upper_helper (string-drop s 1)\
    \ (+ acc (even? index)) (+ index 1)))\n          (else (count_upper_helper (string-drop\
    \ s 1) acc (+ index 1)))))\n  (count_upper_helper s 0 0))\n", "  (cond [(and (string?\
    \ s) (&gt; (string-length s) 0))\n         (if (and (string-ref s 0) (= 1 (remainder\
    \ (string-length s) 2)))\n             (+ 1 (count_upper (substring s 1 (string-length\
    \ s))))\n             (count_upper (substring s 1 (string-length s))))]\n    \
    \    [else 0]))\n</code>\nThis works fine and gives the correct answer; however,\
    \ I have a couple questions:\n\nWhy is it that I need the <code>if</code> condition\
    \ to be <code>(and (string-ref s 0) (= 1 (remainder (string-length s) 2)))</code>\
    \ rather than just <code>(and (string-ref s 0) (remainder (string-length s) 2))</code>?\n\
    For example, when I enter <code>(count_upper \"aBCdEf\")</code>, I get <code>3</code>\
    \ rather than <code>1</code>.\n\nI'm under the impression that I can add <code>string-ref</code>\
    \ to my check of whether the character is an uppercase vowel because <code>string-ref</code>\
    \ will return <code>#f</code> if the character is not a letter. So, if I just\
    \ say <code>(and (string-ref s 0))</code>, I should be able to check if the character\
    \ is a letter. However, when I do this, I get the following error:\n<code>string-ref:\
    \ expects type &lt;string-char&gt; as 1st argument, given: #f; other arguments\
    \ were: \"BCdEf\"\n</code>\n\nI believe I'm using <code>string-ref</code> correctly,\
    \ as I can call <code>(string-ref \"abc\" 0)</code> and it gives me <code>#\\\
    a</code>. \nWhy does it work with <code>string-ref</code> if I add <code>= 1 (remainder\
    \ (string-length s) 2)</code> in the if condition, but not by itself?\n\n\n\n\
    A:\n\nThe error happens when <code>string-ref</code> is given <code>#f</code>\
    \ as its first", "  (cond [(string-empty? s) 0]\n        [(and (member (string-ref\
    \ s 0) '(#\\A #\\E #\\I #\\O #\\U))\n              (even? (string-length s)))\n\
    \         (+ 1 (count_upper (string-drop s 1)))]\n        [else (count_upper (string-drop\
    \ s 1))]))\n```\n\n```racket\n#lang racket\n", "  (cond [(empty? s) 0]\n     \
    \   [(and (char-lower-case? (first s))\n              (char-vowel? (first s)))\n\
    \         (count_upper (rest s))]\n        [(and (char-upper-case? (first s))\n\
    \              (char-vowel? (first s)))\n         (+ 1 (count_upper (rest s)))]\n\
    \        [else (count_upper (rest s))]))\n</code>\nHowever, if I remove the nested\
    \ and clauses, I get the following error:\n<code>#lang racket\n", "  (cond\n \
    \   [(empty? s) 0]\n    [(and (char-upper-case? (first s))\n          (char-vowel?\
    \ (first s))\n          (even? (first s)))\n     (+ 1 (count_upper (rest s)))]\n\
    \    [else (count_upper (rest s))]))\n", "  (if (empty? s)\n      0\n      (if\
    \ (and (string-upper-case? (list-ref s 0))\n               (member (list-ref s\
    \ 0) (list #\\A #\\E #\\I #\\O #\\U)))\n          (+ 1 (count_upper (substring\
    \ s 2)))\n          (count_upper (substring s 2)))))\n</code>\nSo here is the\
    \ test I used:\n<code>#lang racket\n", "  (let/ec return\n    (for/fold ([counter\
    \ 0]) ([i (in-range (string-length s))])\n      (cond\n        [(string-ci=? (string-ref\
    \ s i) #\\a) (return (+ counter 1))]\n        [(string-ci=? (string-ref s i) #\\\
    e) (return (+ counter 1))]\n        [(string-ci=? (string-ref s i) #\\i) (return\
    \ (+ counter 1))]\n        [(string-ci=? (string-ref s i) #\\o) (return (+ counter\
    \ 1))]\n        [(string-ci=? (string-ref s i) #\\u) (return (+ counter 1))]\n\
    \        [else counter]))))\n", "  (define (check s idx)\n    (cond [(string=?\
    \ (string-upcase (substring s idx (+ idx 1)))\n                     (substring\
    \ s idx (+ idx 1))) 1]\n          [else 0]))\n  (let loop ([i 0] [total 0])\n\
    \    (cond [(< i (string-length s))\n           (if (zero? (modulo i 2))\n   \
    \            (loop (+ i 1) (+ total (check s i)))\n               (loop (+ i 1)\
    \ total))]\n          [else total])))\n", "  (let ([counter 0])\n    (for ([i\
    \ (in-range (string-length s))])\n      (when (and (even? i) (string-upper-case?\
    \ (string-ref s i)))\n        (set! counter (+ counter 1))))\n    counter))\n",
  "  (cond\n    [(null? s) 0]\n    [(or (= (remainder (add1 (string-length s)) 2)\
    \ 0)\n         (member (string-ref s 0) '(#\\a #\\e #\\i #\\o #\\u))) (add1 (count_upper\
    \ (substring s 1)))]\n    [else (count_upper (substring s 1))]))\n", "  (if (null?\
    \ s)\n      0\n      (if (and (member (string-upcase (car s)) \"AEIOU\")\n   \
    \            (even? (string-length s)))\n          (+ 1 (count_upper (cdr s)))\n\
    \          (count_upper (cdr s)))))\n", "  (cond\n    [(empty? s) 0]\n    [(odd?\
    \ (list-ref s 0)) (count_upper (rest s))]\n    [(char-upper-case? (first s)) (+\
    \ 1 (count_upper (rest s)))]\n    [else (count_upper (rest s))]))\n</code>\n",
  "  (let loop ([i 0] [count 0])\n    (cond [(empty? s) count]\n          [(equal?\
    \ (string-ref s i) #\\A) (loop (+ i 2) (+ count 1))]\n          [(equal? (string-ref\
    \ s i) #\\E) (loop (+ i 2) (+ count 1))]\n          [(equal? (string-ref s i)\
    \ #\\I) (loop (+ i 2) (+ count 1))]\n          [(equal? (string-ref s i) #\\O)\
    \ (loop (+ i 2) (+ count 1))]\n          [(equal? (string-ref s i) #\\U) (loop\
    \ (+ i 2) (+ count 1))]\n          [else (loop (+ i 2) count)])))\n", "  (cond\n\
    \    [(null? s) 0]\n    [(and (even? (length s))\n          (vowel? (first s))\n\
    \          (upper? (first s)))\n     (+ 1 (count_upper (rest s)))]\n    [else\
    \ (count_upper (rest s))]))\n", "  (let loop ([s s] [c 0])\n    (if (null? s)\n\
    \        c\n        (if (and (char-alphabetic? (car s)) (char-upper-case? (car\
    \ s)) (even? (char->integer (car s))))\n            (loop (cdr s) (+ c 1))\n \
    \           (loop (cdr s) c)))))\n", "  (define (count-uppers s idx)\n    (cond\
    \ [(empty? s) 0]\n          [(and (= 0 (modulo idx 2)) (char-upper-case? (first\
    \ s))) (+ 1 (count-uppers (rest s) (+ idx 1)))]\n          [else (count-uppers\
    \ (rest s) (+ idx 1))]))\n  (count-uppers s 0))\n", "  (cond [(empty? s) 0]\n\
    \        [(char-upcase? (first s))\n         (+ (if (even? (pos (first s))) 1\
    \ 0)\n            (count_upper (rest s)))]\n        [else (count_upper (rest s))]))\n",
  "  (define (is_upper? c)\n    (and (= c (string-upcase c))\n         (string-member\
    \ c \"AEIOU\")))\n  (define (loop s i acc)\n    (if (and (not (string-empty? s))\
    \ (even? i))\n        (if (is_upper? (string-ref s 0))\n            (loop (string-drop\
    \ s 1) (+ i 1) (+ acc 1))\n            (loop (string-drop s 1) (+ i 1) acc))\n\
    \        acc))\n  (loop s 0 0))\n", "  ;; YOUR CODE HERE\n  )\n", "  (cond [(empty?\
    \ s)\n\t 0]\n\t[(and (even? (string-length s)) (eq? (char-upcase (string-ref s\
    \ 0)) (string-ref s 0)))\n\t (+ 1 (count_upper (substring s 1)))]\n\t[else\n\t\
    \ (count_upper (substring s 1))]))\n", "  (define (count_upper_helper s i)\n \
    \   (cond\n      [(>= i (string-length s)) 0]\n      [(= (modulo i 2) 0)\n   \
    \    (cond\n         [(and (= (string-ref s i) #\\A) #t) (add1 (count_upper_helper\
    \ s (add1 i)))]\n         [(and (= (string-ref s i) #\\E) #t) (add1 (count_upper_helper\
    \ s (add1 i)))]\n         [(and (= (string-ref s i) #\\I) #t) (add1 (count_upper_helper\
    \ s (add1 i)))]\n         [(and (= (string-ref s i) #\\O) #t) (add1 (count_upper_helper\
    \ s (add1 i)))]\n         [(and (= (string-ref s i) #\\U) #t) (add1 (count_upper_helper\
    \ s (add1 i)))]\n         [else (count_upper_helper s (add1 i))])]\n      [else\
    \ (count_upper_helper s (add1 i))]))\n  (count_upper_helper s 0))\n", "  (define\
    \ (is-uppers ch)\n    (and (char-upper-case? ch)\n         (or (char=? ch #\\\
    A)\n             (char=? ch #\\E)\n             (char=? ch #\\I)\n           \
    \  (char=? ch #\\O)\n             (char=? ch #\\U))))\n  (let loop ([s s]\n  \
    \           [i 0]\n             [n 0])\n    (if (string-empty? s)\n        n\n\
    \        (if (and (even? i)\n                 (is-uppers (string-ref s 0)))\n\
    \            (loop (substring s 1) (+ i 1) (+ n 1))\n            (loop (substring\
    \ s 1) (+ i 1) n)))))\n", "  (for/sum ([i (in-range (string-length s))])\n   \
    \ (if (and (even? i) (vowel? (string-ref s i)))\n        1\n        0)))", " \
    \ (define (my-count lst)\n    (cond [(empty? lst) 0]\n          [(char-upper-case?\
    \ (car lst)) (add1 (my-count (cdr lst)))]\n          [else (my-count (cdr lst))]))\n\
    \  (define (even-char-at-even-pos? s i)\n    (char-upper-case? (string-ref s i)))\n\
    \  (let* ([s-len (string-length s)]\n         [pos (filter even? (range 0 s-len))])\n\
    \    (my-count (map (lambda (i) (even-char-at-even-pos? s i)) pos))))\n</code>\n\
    Test it with this:\n<code>#lang racket", "  (let loop ([i 0] [acc 0])\n    (if\
    \ (= i (string-length s))\n        acc\n        (let ([c (string-ref s i)])\n\
    \          (cond\n            [(and (= (modulo i 2) 0)\n                  (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U)))\n             (loop (+ i 1) (+ acc 1))]\n  \
    \          [else (loop (+ i 1) acc)])))))\n", "  (local\n    ([define count 0]\n\
    \     [define VOWELS (list #\\a #\\e #\\i #\\o #\\u)]\n     [define (get-char\
    \ s i) (string-ref s i)])\n    (for/fold ([i 0]) ([char (in-string s)])\n    \
    \  (cond\n        [(odd? i) i]\n        [(member char VOWELS) (add1 i)]\n    \
    \    [else i]))))\n", "  (cond [(empty? s) 0]\n        [(and (even? (length s))\
    \ (vowel? (string-upcase (first s))))\n         (+ 1 (count_upper (rest s)))]\n\
    \        [else (count_upper (rest s))]))\n", "  (cond\n    [(empty? s) 0]\n  \
    \  [(and (char-upcase? (first s)) (vowel? (first s))) (+ 1 (count_upper (rest\
    \ s)))]\n    [else (count_upper (rest s))]))\n", "  (define (is-upper? c)\n  \
    \  (and (member c '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n         c))\n  (define (is-even?\
    \ i)\n    (= (modulo i 2) 0))\n  (for/fold ([acc 0])\n            ([i (in-list\
    \ (range (string-length s)))])\n    (if (and (is-upper? (string-ref s i))\n  \
    \           (is-even? i))\n        (+ acc 1)\n        acc)))\n", "  (let loop\
    \ ([curr-idx 0] [count 0])\n    (cond\n      [(>= curr-idx (string-length s))\
    \ count]\n      [(= (modulo curr-idx 2) 0)\n       (if (regexp-match? #rx\"[AEIOU]\"\
    \ (string-ref s curr-idx))\n           (loop (+ curr-idx 1) (+ count 1))\n   \
    \        (loop (+ curr-idx 1) count))]\n      [else (loop (+ curr-idx 1) count)])))\n",
  "  (cond [(string=? s \"\") 0]\n        [(odd? (string-index s (string-ref s 0)))\n\
    \         (count_upper (substring s 1))]\n        [(not (member (string-ref s\
    \ 0) \"aeiouAEIOU\"))\n         (count_upper (substring s 1))]\n        [else\
    \ (+ 1 (count_upper (substring s 1)))]))\n", "  (define (in-range? i)\n    (and\
    \ (&lt;= i (string-length s)) (&gt;= i 0)))\n  (define (upper-vowel? c)\n    (and\
    \ (char-vowel? c) (char-upper-case? c)))\n  (define (aux i n)\n    (if (not (in-range?\
    \ i))\n        n\n        (if (not (even? i))\n            (aux (+ i 1) n)\n \
    \           (aux (+ i 1) (+ n (if (upper-vowel? (string-ref s i)) 1 0))))))\n\
    \  (aux 0 0))\n</code>\nAnd the test:\n<code>#lang racket\n", "  (let ([str (string-&gt;list\
    \ s)])\n    (for*/fold ([n 0]) ([i (in-naturals 2)])\n      (if (and (char-upper-case?\
    \ (list-ref str i))\n               (or (eq? (char-&gt;integer #\\a) (char-&gt;integer\
    \ (list-ref str i)))\n                   (eq? (char-&gt;integer #\\e) (char-&gt;integer\
    \ (list-ref str i)))\n                   (eq? (char-&gt;integer #\\i) (char-&gt;integer\
    \ (list-ref str i)))\n                   (eq? (char-&gt;integer #\\o) (char-&gt;integer\
    \ (list-ref str i)))\n                   (eq? (char-&gt;integer #\\u) (char-&gt;integer\
    \ (list-ref str i)))))\n          (add1 n)\n          n))))\n</code>", "  (cond\n\
    \    [(empty? s) 0]\n    [(not (char-alphabetic? (car s))) (count_upper (cdr s))]\n\
    \    [(and (char-uppercase? (car s)) (char-vowel? (car s))) (+ 1 (count_upper\
    \ (cdr s)))]\n    [else (count_upper (cdr s))]))\n</code>\nRacket is a very powerful\
    \ language, however the downside is that there are many ways to accomplish the\
    \ same task, and it can be a bit overwhelming at first. There are lots of features\
    \ which will not be covered by the course, but are very useful. One of these features\
    \ which would be helpful here is <code>indexed</code> which will return an enumerable/indexable\
    \ collection.\nI hope this helps, and good luck!\n", "  (define (count_upper s\
    \ i n)\n    (cond\n      [(< i (string-length s))\n       (if (and (vowel? (string-ref\
    \ s i))\n                (upper? (string-ref s i)))\n           (count_upper s\
    \ (+ i 2) (+ n 1))\n           (count_upper s (+ i 2) n))]\n      [else n]))\n\
    \  (count_upper s 0 0))\n", "  (local [\n   (define (count-upper-help s n)\n \
    \    (cond\n       [(= n (string-length s)) 0]\n       [(string-upper-case? (string-ref\
    \ s n)) (+ 1 (count-upper-help s (+ n 2)))]\n       [else (count-upper-help s\
    \ (+ n 2))]))])\n  (count-upper-help s 0))\n", "  (define (c-inner s i acc)\n\
    \    (cond ((= i (string-length s)) acc)\n          ((and (vowel? (string-ref\
    \ s i))\n                (char-upper-case? (string-ref s i)))\n           (c-inner\
    \ s (+ i 2) (+ acc 1)))\n          (else (c-inner s (+ i 2) acc))))\n  (c-inner\
    \ s 0 0))\n", "  (cond\n    [(or (string=? s \"\") (string=? s #f)) 0]\n    [(and\
    \ (even? (string-index s 0))\n          (vowel? (string-ref s 0))) (+ 1 (count_upper\
    \ (substring s 1)))]\n    [else (count_upper (substring s 1))]))\n", "  (define\
    \ vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (define (is-vowel c)\n    (memq c vowels))\n\
    \  (cond\n    [(empty? s) 0]\n    [(is-vowel (car s))\n     (if (odd? (modulo\
    \ (count s) 2))\n         (count_upper (cdr s))\n         (+ 1 (count_upper (cdr\
    \ s))))]\n    [else (count_upper (cdr s))]))\n", "  (cond\n    [(= (string-length\
    \ s) 0) 0]\n    [(char-numeric? (string-ref s 0))\n     (count_upper (substring\
    \ s 1))]\n    [(= (modulo (string-length s) 2) 0)\n     (if (char-upcase? (string-ref\
    \ s 0))\n         (+ 1 (count_upper (substring s 1)))\n         (count_upper (substring\
    \ s 1)))]\n    [else (count_upper (substring s 1))]))\n</code>\nI think the problem\
    \ is that I'm using the wrong function to check if a character is uppercase, but\
    \ I'm not sure what that function is. Here's the test output I'm getting:\n<code>&gt;\
    \ (count_upper \"aBCdEf\")\n0\n&gt; (count_upper \"abcdefg\")\n0\n&gt; (count_upper\
    \ \"dBBE\")\n0\n</code>\nAnd here's the output I should be getting:\n<code>&gt;\
    \ (count_upper \"aBCdEf\")\n1\n&gt; (count_upper \"abcdefg\")\n0\n&gt; (count_upper\
    \ \"dBBE\")\n0\n</code>\nThanks for your help!\n\n\nA:\n\nAs @Grandad already\
    \ said, you're using the wrong predicate. The correct one is <code>char-upper-case?</code>,\
    \ but your solution has another issue as well, you're testing <code>(char-numeric?\
    \ (string-ref s 0))</code> in the first branch of the <code>cond</code> expression,\
    \ this should be tested before invoking <code>string-ref</code>.\nWhen trying\
    \ to solve this problem I noticed a pattern - you're doing the same thing to all\
    \ the clauses, going over a string, using <code>string-ref</code> and <code>substring</code>,\
    \ this is a good time to use recursion. Here's my solution:\n<code>(define (count-upper\
    \ s)\n  (define (helper s acc i)\n    (if (null? s)\n        acc\n        (if\
    \ (char-upper-case? (string-ref s i))\n            (helper (substring s 1", " \
    \ (define (is_upper c)\n    (and\n     (= (string-upcase c) c)\n     (member c\
    \ '(\"A\" \"E\" \"I\" \"O\" \"U\"))))\n  (define (is_even_index i)\n    (= (modulo\
    \ i 2) 0))\n  (cond [(string=? s \"\") 0]\n        [else (define i 0)\n      \
    \        (define n (string-length s))\n              (cond [(and (is_even_index\
    \ i) (is_upper (string-ref s i))) (+ 1 (count_upper (substring s 1 n)))]\n   \
    \                 [else (count_upper (substring s 1 n))])]))\n</code>\nThis is\
    \ an example solution.  There are many other ways to solve this problem.\n", " \
    \ (let ((count 0))\n    (for ((chr (in-string s)))\n      (when (and (vowel? chr)\n\
    \                 (even? (string-index s chr)))\n        (set! count (+ count\
    \ 1))))\n    count))\n", "  (define (f (s c) (if (equal? s '()) c (if (or (equal?\
    \ (list-ref s 0) 'a) (equal? (list-ref s 0) 'e) (equal? (list-ref s 0) 'i) (equal?\
    \ (list-ref s 0) 'o) (equal? (list-ref s 0) 'u)) (f (cdr s) (+ c 1)) (f (cdr s)\
    \ c))))\n  (f (string->list s) 0))\n", "  (foldl (lambda (a b) (+ b (if (and (vowel?\
    \ a) (even? b)) 1 0)))\n         0\n         (string->list s)))\n", "  (if (string-empty?\
    \ s)\n      0\n      (if (and (char-upper-case? (string-ref s 0))\n          \
    \     (member (string-ref s 0) (string-&gt;list \"AEIOU\")))\n          (+ 1 (count_upper\
    \ (substring s 2)))\n          (count_upper (substring s 2)))))\n</code>\n", " \
    \ (define (is-vowel x)\n    (cond\n      [(equal? x #\\a) #t]\n      [(equal?\
    \ x #\\e) #t]\n      [(equal? x #\\i) #t]\n      [(equal? x #\\o) #t]\n      [(equal?\
    \ x #\\u) #t]\n      [else #f]))\n  (define (is-upper x)\n    (and (char-upper-case?\
    \ x) (is-vowel x)))\n  (define (loop s i)\n    (if (&lt; i (string-length s))\n\
    \        (cond\n          [(is-upper (string-ref s i)) (+ 1 (loop s (+ i 2)))]\n\
    \          [else (loop s (+ i 2))])\n        0))\n  (loop s 0))\n</code>\nThere's\
    \ nothing wrong with the code, it works perfectly. It does exactly what the problem\
    \ asks for: count the number of uppercase vowels in the even indices of a string.\
    \ However, I'm looking for more advanced ways to do this.\nI'm looking for any\
    \ new techniques, ways to further simplify the code (if possible), and ways to\
    \ make the code more idiomatic.\nI know about <code>for/fold</code>, but I'm not\
    \ sure how it can be applied to this problem.\n\n\nA:\n\n<code>for/fold</code>\
    \ is a nice way to simplify this, but I don't see how it changes the fundamental\
    \ approach.\nI'd say the main issue with this implementation is that it doesn't\
    \ convey that you're doing the same thing for each character in the string.  You\
    \ do this in the recursion, but it's harder to see that if you're using recursion.\
    \  You could replace the recursion with a loop.  (And then you'd want to replace\
    \ the <code>loop</code> with a <code>for/fold</code>.)\nYou could also replace\
    \ the <code>cond</code> with an <code>andmap</code> of boolean functions.  The\
    \ function might look like this:\n<code>(define (is-even-upper-vowel? s i)\n \
    \ (andmap (\u03BB (pred) (pred (string-ref s i)))\n          (list even?", " \
    \ (cond\n    [(string-empty? s) 0]\n    [(and (char-upper-case? (string-ref s\
    \ 0))\n          (member (string-ref s 0) '(#\\A #\\E #\\I #\\O #\\U))) (+ 1 (count_upper\
    \ (string-drop s 2)))]\n    [else (count_upper (string-drop s 2))]))\n", "  (cond\n\
    \    [(or (eq? s \"\") (eq? s '())) 0]\n    [(and (vowel? (string-ref s 0)) (even?\
    \ (string-index (string-downcase s) (string-ref s 0))))\n     (+ 1 (count_upper\
    \ (substring s 1)))]\n    [else (count_upper (substring s 1))]))\n", "  (let ((len\
    \ (string-length s))\n        (idx 0)\n        (count 0))\n    (while (< idx len)\n\
    \      (when (and (string-ref s idx) (vowel? (string-ref s idx)))\n        (set!\
    \ count (+ count 1)))\n      (set! idx (+ idx 2)))\n    count))\n", "  (cond\n\
    \    [(empty? s) 0]\n    [(and (is-vowel (list-ref s 0))\n          (is-uppercase\
    \ (list-ref s 0)))\n     (+ 1 (count_upper (rest s)))]\n    [else (count_upper\
    \ (rest s))]))\n", "  (define (count-iter s counter)\n    (if (= (string-length\
    \ s) 0)\n        counter\n        (if (and (char-upper-case? (string-ref s 0))\n\
    \                 (even? (modulo counter 2)))\n            (count-iter (substring\
    \ s 1) (+ counter 1))\n            (count-iter (substring s 1) (+ counter 1)))))\n\
    \  (count-iter s 0))\n", "  (accumulate string-length\n              (filter (compose\
    \ even? string-position (curry string-ci=? #\\a))\n                      (filter\
    \ char-upcase? (string->list s)))))\n", "  (cond\n    [(empty? s) 0]\n    [(and\
    \ (vowel? (char-upcase (first s))) (even? (car (string-index s)))) (+ 1 (count_upper\
    \ (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (cond [(empty? s) 0]\n\
    \        [(even? (car s)) (count_upper (cdr s))]\n        [(eq? (char-upcase (car\
    \ s)) (car s)) (+ 1 (count_upper (cdr s)))]\n        [else (count_upper (cdr s))]))\n",
  "  (letrec\n      ((count_upper_even (lambda (s)\n                           (if\
    \ (and (not (null? s)) (odd? (string-length s)))\n                           \
    \    (count_upper_even (string-drop s 1))\n                               (count_upper_even_aux\
    \ s 0))))\n       (count_upper_even_aux (lambda (s count)\n                  \
    \             (if (null? s)\n                                   count\n      \
    \                             (if (or (= (string-upcase (string-ref s 0)) (string-ref\
    \ s 0))\n                                           (= (string-ref s 0) #\\a)\n\
    \                                           (= (string-ref s 0) #\\e)\n      \
    \                                     (= (string-ref s 0) #\\i)\n            \
    \                               (= (string-ref s 0) #\\o)\n                  \
    \                         (= (string-ref s 0) #\\u))\n                       \
    \                (count_upper_even_aux (string-drop s 1) (+ count 1))\n      \
    \                                 (count_upper_even_aux (string-drop s 1) count))))))\n\
    \    (count_upper_even s)))\n", "  (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n\
    \  (define up-vowels '(#\\A #\\E #\\I #\\O #\\U))\n  (define (char-to-lower ch)\n\
    \    (char-downcase ch))\n  (define (upper-list list)\n    (map char-to-lower\
    \ list))\n  (define (is-even n)\n    (= (remainder n 2) 0))\n  (define (count-vowels\
    \ str)\n    (cond\n      [(null? str) 0]\n      [(member (car str) vowels) (+\
    \ 1 (count-vowels (cdr str)))]\n      [else (count-vowels (cdr str))]))\n  (define\
    \ (is-even-index list)\n    (cond\n      [(null? list) (quote ())]\n      [(is-even\
    \ (car list)) (cons (car list) (is-even-index (cdr list)))]\n      [else (is-even-index\
    \ (cdr list))]))\n  (define (get-even-index str)\n    (define (counter str index)\n\
    \      (cond\n        [(null? str) (quote ())]\n        [else (cons index (counter\
    \ (cdr str) (+ index 1)))]))\n    (counter str 0))\n  (define (get-even-upper\
    \ str)\n    (is-even-index (get-even-index str)))\n  (define (get-chars str)\n\
    \    (cond\n      [(null? str) (quote ())]\n      [else (cons (string-ref str\
    \ (car str)) (get-chars (cdr str)))]))\n  (define (get-even-upper-chars str)\n\
    \    (get-chars (get-even-upper str)))\n  (count-vowels (get-even-upper-chars\
    \ s)))\n</code>\nI'm aware that my code is rather verbose and there's probably\
    \ a more efficient way to do the same thing.\n\n\nA:\n\nMy approach to this problem\
    \ would be to write a <code>count-even-vowels</code> procedure that traverses\
    \ a string and counts the", "  (let loop ([s s] [index 0] [result 0])\n    (cond\n\
    \      [(empty? s) result]\n      [(odd? index) (loop (rest s) (+ index 1) result)]\n\
    \      [(is-upper? (first s)) (loop (rest s) (+ index 1) (+ result 1))]\n    \
    \  [else (loop (rest s) (+ index 1) result)])))\n", "  (define (is-vowel c)\n\
    \    (or (equal? c #\\a)\n        (equal? c #\\e)\n        (equal? c #\\i)\n \
    \       (equal? c #\\o)\n        (equal? c #\\u)))\n  (cond [(empty? s) 0]\n \
    \       [(is-vowel (char-upcase (first s)))\n         (+ (if (even? (length s))\
    \ 1 0)\n            (count_upper (rest s)))]\n        [else (count_upper (rest\
    \ s))]))\n", "  (let ([vowels (string-&gt;list \"AEIOU\")])\n    (for/sum ([ch\
    \ (in-string s)])\n      (and (member ch vowels)\n           (even? (string-index\
    \ s ch))\n           1))))\n</code>\n<code>#lang racket\n", "  (cond\n    [(null?\
    \ s) 0]\n    [(and (char-uppercase? (string-ref s 0)) (char-vowel? (string-ref\
    \ s 0))) (+ 1 (count_upper (substring s 2)))]\n    [else (count_upper (substring\
    \ s 2))]))\n", "  (define (get-evens lst)\n    (if (null? lst)\n        '()\n\
    \        (cons (car lst) (get-evens (cddr lst)))))\n  (define (is-vowel c)\n \
    \   (define vowels '(#\\a #\\e #\\i #\\o #\\u))\n    (member c vowels))\n  (length\
    \ (filter is-vowel (get-evens (string->list s)))))\n\n```\n\n```\nscheme@(guile-user)>\
    \ (count_upper \"aBCdEf\")\n$1 = 1\nscheme@(guile-user)> (count_upper \"abcdefg\"\
    )\n$2 = 0\nscheme@(guile-user)> (count_upper \"dBBE\")\n$3 = 0\n```\n\n### Write\
    \ a function nth_vowel that returns the nth vowel in a string\n\n```#lang racket\n",
  "  (define (isupper c)\n    (or (char=? c #\\A)\n        (char=? c #\\E)\n     \
    \   (char=? c #\\I)\n        (char=? c #\\O)\n        (char=? c #\\U)))\n  (let\
    \ loop ([s s] [count 0])\n    (cond\n      [(empty? s) count]\n      [(and (isupper\
    \ (first s)) (even? (length s))) (loop (rest s) (+ count 1))]\n      [else (loop\
    \ (rest s) count)])))\n", "  (define (uc-vowel? c)\n    (member c '(#\\A #\\E\
    \ #\\I #\\O #\\U)))\n  (define (count-uc-vowels s)\n    (cond [(empty? s) empty]\n\
    \          [(and (even? (first s)) (uc-vowel? (second s))) 1]\n          [else\
    \ 0]))\n  (cond [(empty? s) 0]\n        [else (+ (count-uc-vowels s) (count_upper\
    \ (rest s)))]))\n", "  (count-if (lambda (x) (and (char-upcase? x) (vowel? x)))\n\
    \            (filter even? (index-list s))))\n", "  (let loop ([i 0] [len (string-length\
    \ s)] [count 0])\n    (cond [(>= i len) count]\n          [(and (char-numeric?\
    \ (string-ref s i))\n                (odd? (string->number (string (string-ref\
    \ s i)))))\n           (loop (+ i 1) len count)]\n          [(and (char-upper-case?\
    \ (string-ref s i))\n                (vowel? (string-ref s i)))\n           (loop\
    \ (+ i 1) len (+ count 1))]\n          [else (loop (+ i 1) len count)])))\n",
  "  (define (is-vowel c)\n    (or (= c #\\a) (= c #\\e) (= c #\\i) (= c #\\o) (=\
    \ c #\\u)))\n  (define (count_upper-sub s i count)\n    (if (&gt;= i (string-length\
    \ s))\n        count\n        (if (and (is-vowel (string-ref s i))\n         \
    \        (char-upcase? (string-ref s i)))\n            (count_upper-sub s (+ i\
    \ 1) (+ count 1))\n            (count_upper-sub s (+ i 1) count))))\n  (count_upper-sub\
    \ s 0 0))\n", "  (cond\n    [(empty? s) 0]\n    [(char-uppercase? (first s)) (+\
    \ 1 (count_upper (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (define\
    \ (count-helper s i)\n    (cond ((= i (string-length s)) 0)\n          ((and (vowel?\
    \ (string-ref s i))\n                (upper? (string-ref s i)))\n           (+\
    \ 1 (count-helper s (+ i 2))))\n          (else (count-helper s (+ i 2)))))\n\
    \  (count-helper s 0))\n", "  (cond [(string=? s \"\") 0]\n        [(and (char-upper-case?\
    \ (string-ref s 0))\n              (member (string-ref s 0) '(#\\A #\\E #\\I #\\\
    O #\\U)))\n         (+ 1 (count_upper (substring s 2)))]\n        [else (count_upper\
    \ (substring s 2))]))\n</code>\n", "  (cond\n    [(empty? s) 0]\n    [(equal?\
    \ (rest s) \"\") 0]\n    [(equal? (rest (rest s)) \"\")\n     (if (member (first\
    \ s) '(\"A\" \"E\" \"I\" \"O\" \"U\")) 1 0)]\n    [else\n     (+ (if (member (first\
    \ s) '(\"A\" \"E\" \"I\" \"O\" \"U\")) 1 0)\n        (count_upper (rest (rest\
    \ s))))]))\n", "  (foldl\n   (lambda (str acc)\n     (cond\n       [(and (char-alphabetic?\
    \ str)\n             (char-upper-case? str)\n             (even? acc))\n     \
    \   (+ acc 1)]\n       [else acc]))\n   0\n   (string->list s)))\n", "  (local\n\
    \      ([define s (string-upcase s)]\n       [define vowels (string-&gt;list \"\
    AEIOU\")]\n       [define split (string-split s (regexp #rx\"[^AEIOU]\"))]\n \
    \      [define evens (for/list ([i (in-range (length split))]\n              \
    \                  #:when (even? i))\n                       (list-ref split i))]\n\
    \       [define upper (for/sum ([i (in-range (length evens))])\n             \
    \          (string-length (list-ref evens i)))])\n    upper))\n</code>\nI have\
    \ a few questions:\n\nIs this a good way to solve the problem? (I'm not sure whether\
    \ I should be using a regexp to split the string.)\nIs there a better way to split\
    \ the string so as to count the number of vowels in odd indices as well?\nIs there\
    \ a way to combine the <code>split</code> and <code>evens</code> steps?\n\nThanks!\n\
    \n\nA:\n\nHere's an alternative solution:\n<code>(define (count-upper s)\n  (define\
    \ vowels '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n  (for/sum ([i (in-range (string-length\
    \ s))]\n            #:when (even? i)\n            #:when (member (string-upper-case\
    \ (string-ref s i)) vowels))\n    1))\n</code>\nIt simply iterates over the letters\
    \ in the string and increments a counter every time a vowel is found in an even\
    \ position.\n", "  (for/sum ([c (in-string s)])\n            (and (= (modulo (string-index\
    \ s c) 2) 0)\n                 (char-upper-case? c)\n                 1)))\n\n\
    ```\n\n```racket\n\n#lang racket\n", "  (cond [(empty? s) 0]\n        [(even?\
    \ (string-index s))\n         (+ (cond [(char-upper-case? (string-ref s 0)) 1]\n\
    \                  [else 0])\n            (count_upper (substring s 1)))]\n  \
    \      [else (count_upper (substring s 1))]))\n</code>\nSome notes:\n\nThe <code>cond</code>\
    \ macro is analogous to the <code>if ... elif ... elif ... else</code> idiom in\
    \ Python. See the Racket guide for more details.\nI prefer to use the <code>#lang\
    \ racket</code> language (as opposed to <code>#lang scheme</code> or <code>#lang\
    \ typed/racket</code>) whenever possible, as the Racket language is more modern,\
    \ has more features, and is generally easier to use. For more details, see this\
    \ answer.\n\n", "  ;; Return #t if the character is a vowel\n  (define (is_vowel\
    \ c)\n    (or (eq? c #\\a)\n        (eq? c #\\e)\n        (eq? c #\\i)\n     \
    \   (eq? c #\\o)\n        (eq? c #\\u)))\n  ;; Return #t if the character is a\
    \ vowel and is uppercase\n  (define (is_upper-vowel c)\n    (and (is_vowel c)\n\
    \         (char-upper-case? c)))\n  ;; Return #t if the index is even\n  (define\
    \ (is_even i)\n    (= (modulo i 2) 0))\n  ;; Return the sum of all vowels if the\
    \ index is even\n  (let loop ([s s] [counter 0])\n    (if (empty? s)\n       \
    \ counter\n        (if (and (is_even (string-length s))\n                 (is_upper-vowel\
    \ (string-ref s 0)))\n            (loop (string-drop s 1) (+ counter 1))\n   \
    \         (loop (string-drop s 1) counter)))))\n</code>\nI want to refactor this\
    \ function to use higher-order functions. I haven't had much success, so I'm wondering\
    \ if there's a higher-order function or an existing approach to this problem that\
    \ would make it easier to refactor. \nThanks for any tips.\n\n\nA:\n\nHere's an\
    \ answer that uses <code>for/fold</code> and <code>fold</code> to reduce the number\
    \ of loops:\n<code>#lang racket\n", "  (define (check_even i)\n    (if (= i 0)\n\
    \        #t\n        (if (= (remainder i 2) 0)\n            #t\n            #f)))\n\
    \  (define (is_vowel c)\n    (member c '(\"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define\
    \ (count_upper_helper s i)\n    (if (equal? i (string-length s))\n        0\n\
    \        (if (and (check_even i) (is_vowel (string-ref s i)))\n            (+\
    \ 1 (count_upper_helper s (+ i 1)))\n            (count_upper_helper s (+ i 1)))))\n\
    \  (count_upper_helper s 0))\n", "  (define (number? c)\n    (string-&gt;number\
    \ (string c) 16))\n  (define (isVowel? c)\n    (or (= c (number? 'a))\n      \
    \  (= c (number? 'e))\n        (= c (number? 'i))\n        (= c (number? 'o))\n\
    \        (= c (number? 'u))))\n  (for/sum ([i (in-range (string-length s))]\n\
    \            [c (in-string s)])\n    (and (isVowel? c)\n         (= 1 (modulo\
    \ i 2)))))\n</code>\nBut I don't understand why the same code doesn't work with\
    \ <code>racket/base</code> language.\n<code>#lang racket/base\n", "  (if (string-empty?\
    \ s)\n      0\n      (if (char-vowel? (string-ref s 0))\n          (if (char-upper-case?\
    \ (string-ref s 0))\n              (+ 1 (count_upper (string-tail s 2)))\n   \
    \           (count_upper (string-tail s 2)))\n          (count_upper (string-tail\
    \ s 2)))))\n", "  (cond\n    [(= (string-length s) 0) 0]\n    [(= (modulo (string-length\
    \ s) 2) 0)\n     (cond\n       [(member (string-ref s 0) '(\"A\" \"E\" \"I\" \"\
    O\" \"U\")) (+ 1 (count_upper (substring s 1)))]\n       [else (count_upper (substring\
    \ s 1))])]\n    [else (count_upper (substring s 1))]))\n", "  (define (aux n res)\n\
    \    (if (= n (- (string-length s) 1))\n        res\n        (if (and (string-ref\
    \ s n)\n                 (char-upper-case? (string-ref s n))\n               \
    \  (or (= (remainder n 2) 0)\n                     (= n 0)))\n            (aux\
    \ (+ n 1) (+ res 1))\n            (aux (+ n 1) res))))\n  (aux 0 0))\n", "  (cond\
    \ ((not (string? s)) (error \"count_upper: expects a string\"))\n        ((= (string-length\
    \ s) 0) 0)\n        ((and (vowel? (string-ref s 0))\n              (even? (string-length\
    \ s)))\n         (count_upper (substring s 1))\n         1)\n        (else (count_upper\
    \ (substring s 1)))))\n", "  (if (empty? s)\n      0\n      (let ([letter (first\
    \ s)])\n        (if (and (= (modulo (string-length s) 2) 0)\n                \
    \ (string-contains \"AEIOU\" letter))\n            (+ 1 (count_upper (rest s)))\n\
    \            (count_upper (rest s))))))\n", "  (if (string=? s \"\")\n      0\n\
    \      (if (and (char-lower-case? (string-ref s 0))\n               (member (string-ref\
    \ s 0) '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n          (count_upper (substring s\
    \ 2))\n          (count_upper (substring s 1)))))\n", "  (cond\n    [(empty? s)\
    \ 0]\n    [(and (character-upcase? (first s))\n          (vowel? (first s))\n\
    \          (even? (position (first s) s)))\n     (+ 1 (count_upper (rest s)))]\n\
    \    [else (count_upper (rest s))]))\n", "  (let loop ([acc 0] [s s])\n    (if\
    \ (null? s)\n        acc\n        (if (and (= (even? (string-index s 0)) #t) (vowel?\
    \ (string-upcase (string s 0))))\n            (loop (+ acc 1) (substring s 1))\n\
    \            (loop acc (substring s 1))))))\n", "  (cond ((empty? s) 0)\n    \
    \    ((and (member (first s) '#(#\\a #\\e #\\i #\\o #\\u))\n              (even?\
    \ (string-length s)))\n         (+ 1 (count_upper (rest s))))\n        (else (count_upper\
    \ (rest s)))))\n", "  ;; your code here\n  )\n", "  (let ((res 0))\n    (define\
    \ (count_upper-helper s)\n      (cond\n        [(empty? s) res]\n        [(and\
    \ (char-upcase? (first s))\n              (char-vowel? (first s))\n          \
    \    (even? (add1 (length s))))\n         (set! res (add1 res))\n         (count_upper-helper\
    \ (rest s))]\n        [else (count_upper-helper (rest s))]))\n    (count_upper-helper\
    \ s)))\n", "  (letrec ([even-indices (lambda (s)\n                           (cond\n\
    \                             [(empty? s) empty]\n                           \
    \  [(empty? (rest s)) empty]\n                             [else (cons (first\
    \ s) (even-indices (rest (rest s))))]))]\n           [is-vowel (lambda (c)\n \
    \                      (or (char=? c #\\a)\n                           (char=?\
    \ c #\\e)\n                           (char=? c #\\i)\n                      \
    \     (char=? c #\\o)\n                           (char=? c #\\u)))]\n       \
    \    [is-upper (lambda (c)\n                       (and (char-alphabetic? c)\n\
    \                            (char-upper-case? c)))])\n    (cond\n      [(empty?\
    \ s) 0]\n      [(is-upper (first s)) (+ 1 (count_upper (rest s)))]\n      [else\
    \ (count_upper (rest s))])))\n</code>\nThe <code>count_upper</code> function should\
    \ essentially be\n<code>(define (count_upper s)\n  (cond\n    [(empty? s) 0]\n\
    \    [(is-upper (first s)) (+ 1 (count_upper (rest s)))]\n    [else (count_upper\
    \ (rest s))]))\n</code>\n", "  (cond [(string-empty? s) 0]\n        [(even? (string-length\
    \ s)) (count_upper (substring s 1))]\n        [(vowel? (string-ref s 0)) (+ 1\
    \ (count_upper (substring s 1)))]\n        [else (count_upper (substring s 1))]))\n",
  "  (define (is_upper c)\n    (and (char-alphabetic? c) (char-upper-case? c)))\n\
    \  (define (is_vowel c)\n    (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\\
    i) (char=? c #\\o) (char=? c #\\u)))\n  (define (is_even-index idx)\n    (= (remainder\
    \ idx 2) 0))\n  (define (accumulate s count idx)\n    (if (string-empty? s)\n\
    \        count\n        (if (and (is_even-index idx) (is_upper (string-ref s 0))\
    \ (is_vowel (string-ref s 0)))\n            (accumulate (string-drop s 1) (+ count\
    \ 1) (+ idx 1))\n            (accumulate (string-drop s 1) count (+ idx 1)))))\n\
    \  (accumulate s 0 0))\n```\n\nRun the tests with `raco test solutions.rkt`.\n\
    \n### JavaScript\n\n```javascript\nfunction countUpper(str) {\n  return str.split('').reduce((count,\
    \ c, idx) => {\n    if (idx % 2 !== 0) return count;\n    if (!/[a-z]/.test(c))\
    \ return count;\n    if (!/[aeiou]/.test(c)) return count;\n    return count +\
    \ 1;\n  }, 0);\n}\n```\n\nRun the tests with `node solutions.js`.\n\n## Solution\n\
    \nThe first solution that comes to mind is:\n\n```\ncount = 0\nfor each letter\
    \ in s, at even index i:\n  if letter is uppercase:\n    count += 1\n```\n\nThis\
    \ solution is written in a functional style, with a `count` accumulator.\n\nThe\
    \ solution is:\n\n```\ncount = 0\nfor each letter in s, at even index i:\n  if\
    \ letter is uppercase AND letter is a vowel:\n    count += 1\n```\n\nThe code\
    \ is modified by adding an `is_vowel` check.\n\n", "  (cond [(empty? s) 0]\n \
    \       [(and (char-uppercase? (first s)) (odd? (position (first s) s)))\n   \
    \      (+ 1 (count_upper (rest s)))]\n        [else (count_upper (rest s))]))\n",
  "  (define (vowel? c)\n    (member c '(\"A\" \"E\" \"I\" \"O\" \"U\")))\n  (define\
    \ (get-evens lst)\n    (define (get-evens-helper lst res ct)\n      (if (null?\
    \ lst)\n          res\n          (if (= 0 (modulo ct 2))\n              (get-evens-helper\
    \ (cdr lst) (cons (car lst) res) (+ ct 1))\n              (get-evens-helper (cdr\
    \ lst) res (+ ct 1)))))\n    (reverse (get-evens-helper lst '() 0)))\n  (length\
    \ (filter vowel? (get-evens (string->list s)))))\n```\n\n## 2: Combinator\n\n\
    **Combinator** is a function that takes in only one argument.\n\n```racket\n#lang\
    \ racket\n", "  (length (filter even? (map (lambda (char) (char-upcase char))\
    \ (filter vowel? (string-&gt;list s))))))\n", "  (let loop ([i 0] [x 0])\n   \
    \ (cond\n      [(= i (string-length s)) x]\n      [(= (modulo i 2) 0)\n      \
    \ (if (member (string-ref s i) \"AEIOU\")\n           (loop (+ i 1) (+ x 1))\n\
    \           (loop (+ i 1) x))]\n      [else (loop (+ i 1) x)])))\n", "  (define\
    \ (helper s count)\n    (cond\n      [(empty? s) count]\n      [(vowel? (char-upcase\
    \ (first s)))\n       (helper (rest s) (+ count (odd? (length s))))]\n      [else\
    \ (helper (rest s) count)]))\n  (helper s 0))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(odd? (length s)) (count_upper (rest s))]\n    [(char-upcase? (first s))\
    \ (add1 (count_upper (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (if\
    \ (empty? s)\n      0\n      (if (and (char-ci=? (string-ref s 0) #\\a) (even?\
    \ (string-length s)))\n          (+ 1 (count_upper (string-drop s 1)))\n     \
    \     (count_upper (string-drop s 1)))))\n</code>\n", "  (if (equal? s \"\") 0\n\
    \      (if (equal? (rest s) \"\") 0\n          (if (equal? (rest (rest s)) \"\"\
    ) 0\n              (if (equal? (rest (rest (rest s))) \"\") 0\n              \
    \    (if (and (or (equal? (char-upcase (string-ref s 0)) (string-ref s 0))\n \
    \                              (or (equal? (char-upcase (string-ref s 2)) (string-ref\
    \ s 2))\n                                   (or (equal? (char-upcase (string-ref\
    \ s 4)) (string-ref s 4))\n                                       (equal? (char-upcase\
    \ (string-ref s 6)) (string-ref s 6))))))\n                      (+ 1 (count_upper\
    \ (rest (rest (rest (rest s))))))\n                      (count_upper (rest (rest\
    \ (rest (rest s)))))))))))\n</code>\nBut that seems really convoluted and not\
    \ elegant at all.\n\n\nA:\n\nHere's how I would write it:\n<code>(define (upper-vowel?\
    \ s)\n  (let ([c (string-ref s 0)])\n    (char-vowel? c)\n    (char-upcase? c)))\n",
  "  (cond\n    [(empty? s) 0]\n    [(and (char-upper-case? (first s))\n         \
    \ (vowel? (first s)))\n     (+ 1 (count_upper (rest s)))]\n    [else (count_upper\
    \ (rest s))]))\n", "  (cond [(= (remainder (string-length s) 2) 0) (count-vowels-in-string\
    \ s)]\n        [else 0]))\n", "  (if (empty? s)\n      0\n      (if (and (char-numeric?\
    \ (char-upcase (first s)))\n               (even? (char->integer (char-upcase\
    \ (first s)))))\n          (+ 1 (count_upper (rest s)))\n          (count_upper\
    \ (rest s)))))\n", "  (for/sum ((i (in-range (string-length s)))\n           \
    \ (char (in-string s)))\n    (and (even? i)\n         (char-upper-case? char)\n\
    \         (member char '#(#\\A #\\E #\\I #\\O #\\U))\n         1\n         0)))\n",
  "  (cond [(string-upper-case? s) 1]\n        [else 0]))", "  (cond [(null? s) 0]\n\
    \        [(and (char-upper-case? (string-ref s 0))\n              (or (eq? (string-ref\
    \ s 0) #\\A)\n                  (eq? (string-ref s 0) #\\E)\n                \
    \  (eq? (string-ref s 0) #\\I)\n                  (eq? (string-ref s 0) #\\O)\n\
    \                  (eq? (string-ref s 0) #\\U))) (+ 1 (count_upper (substring\
    \ s 2)))]\n        [else (count_upper (substring s 2))]))\n</code>\nI believe\
    \ the problem is in the <code>substring</code> part and how I'm referencing it\
    \ in the <code>count_upper</code> statement. I don't quite understand how to read\
    \ the documentation that is provided. I've also tried using <code>(string-drop\
    \ s 2)</code>, but with the same result.\nUPDATE:\nI've changed the code to what\
    \ is below, but I keep getting 0.\n<code>#lang racket\n", "  (count-if\n   (compose\
    \ even?\n            (string-index s))\n   (lambda (c)\n     (and (char-upcase?\
    \ c)\n          (member c '#(#\\A #\\E #\\I #\\O #\\U))))\n   (string->list s)))\n",
  "  (let loop ([s s] [acc 0])\n    (if (string-empty? s)\n        acc\n        (if\
    \ (and (elem? (string-ref s 0) '(\"A\" \"E\" \"I\" \"O\" \"U\"))\n           \
    \      (even? (string-length s)))\n            (loop (substring s 1) (+ acc 1))\n\
    \            (loop (substring s 1) acc)))))\n", "  (let loop ([s s] [count 0])\n\
    \    (cond\n      [(null? s) count]\n      [(and (even? (string-index s))\n  \
    \          (char-upper-case? (string-ref s 0)))\n       (loop (substring s 1)\
    \ (+ count 1))]\n      [else (loop (substring s 1) count)])))\n</code>\n", " \
    \ (cond [(empty? s) 0]\n        [(and (vowel? (first s)) (is-upper? (first s)))\n\
    \         (+ 1 (count_upper (rest s)))]\n        [else (count_upper (rest s))]))\n\
    </code>\nI can't figure out how to get it to count only if the vowel is uppercase\
    \ on an even index.\nAlso, I understand that this is not the best way to do it.\n\
    \n\nA:\n\nThe problem statement is a bit unclear. It asks to count the number\
    \ of vowels in even indices and the vowel has to be uppercase. Does that mean\
    \ that the indices start at 0 or 1? Suppose we start at 0. Then <code>aBCdEf</code>\
    \ has a vowel at indices 0, 2, 4. You can see that the vowel at index 2 is lowercase.\
    \ So, the expected result should be 2. If we start counting at 1, then the answer\
    \ is 1. I think that we are supposed to start at 0. Here is a solution that starts\
    \ at 0:\n<code>(define (count-upper s)\n  (count (compose not even? string-ref)\n\
    \         (filter vowel? s)))\n</code>\nHere is another solution that starts at\
    \ 1:\n<code>(define (count-upper s)\n  (count (compose even? string-ref)\n   \
    \      (filter (compose is-upper? vowel?) s)))\n</code>\nBoth solutions can be\
    \ made more efficient using <code>vector-count</code>:\n<code>(define (count-upper\
    \ s)\n  (vector-count (compose (\u03BB (i) (and (even? i) (vowel? (string-ref\
    \ s i))))\n                         string-ref)\n                s))\n</code>\n",
  "  (cond [(empty? s) 0]\n        [(and (even? (string-length s)) (vowel? (string-ref\
    \ s 0)) (char-upcase? (string-ref s 0)))\n         (+ 1 (count_upper (substring\
    \ s 1)))]\n        [else (count_upper (substring s 1))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(char-ci=? (first s) #\\a) (+ (count_upper (rest s)) (even? (char->integer\
    \ (first s))))]\n    [(char-ci=? (first s) #\\e) (+ (count_upper (rest s)) (even?\
    \ (char->integer (first s))))]\n    [(char-ci=? (first s) #\\i) (+ (count_upper\
    \ (rest s)) (even? (char->integer (first s))))]\n    [(char-ci=? (first s) #\\\
    o) (+ (count_upper (rest s)) (even? (char->integer (first s))))]\n    [(char-ci=?\
    \ (first s) #\\u) (+ (count_upper (rest s)) (even? (char->integer (first s))))]\n\
    \    [else (count_upper (rest s))]))\n", "  (letrec ([n (string-length s)]\n \
    \          [l (- n 1)]\n           [f (lambda (i acc)\n                (cond [(=\
    \ i l) acc]\n                      [(> (modulo i 2) 0) (f (+ i 1) acc)]\n    \
    \                  [(eq? (char-upcase (string-ref s i)) (string-ref s i)) (f (+\
    \ i 1) (+ acc 1))]\n                      [else (f (+ i 1) acc)]))])\n    (f 0\
    \ 0)))\n", "  (define (is-vowel c)\n    (or (equal? c #\\a)\n        (equal? c\
    \ #\\e)\n        (equal? c #\\i)\n        (equal? c #\\o)\n        (equal? c #\\\
    u)))\n  (define (count-even-uppercase-vowels s i)\n    (if (or (&lt; i 0) (&gt;=\
    \ i (string-length s)))\n        0\n        (if (and (is-vowel (string-ref s i))\n\
    \                 (char-upper-case? (string-ref s i)))\n            (+ 1 (count-even-uppercase-vowels\
    \ s (+ i 2)))\n            (count-even-uppercase-vowels s (+ i 2)))))\n  (count-even-uppercase-vowels\
    \ s 0))\n</code>\nHere is a DrRacket screenshot:\n\nNote: I am using the #lang\
    \ racket language in DrRacket.\n\n\nA:\n\nThe tail call optimization is not used\
    \ in your code because the recursive call is inside a <code>if</code> expression\
    \ which is not a tail position. Try to move the recursive call to the last expression\
    \ of the <code>if</code> body:\n<code>(define (count-even-uppercase-vowels s i)\n\
    \  (if (or (&lt; i 0) (&gt;= i (string-length s)))\n      0\n      (if (and (is-vowel\
    \ (string-ref s i))\n               (char-upper-case? (string-ref s i)))\n   \
    \       (+ 1 (count-even-uppercase-vowels s (+ i 2)))\n          (count-even-uppercase-vowels\
    \ s (+ i 2)))))\n</code>\n", "  (let loop ([i 0] [count 0])\n    (if (= i (string-length\
    \ s))\n        count\n        (let ([c (string-ref s i)])\n          (if (and\
    \ (char-upper-case? c)\n                   (in-set (char-downcase c) \"aeiou\"\
    ))\n              (loop (+ i 2) (+ count 1))\n              (loop (+ i 2) count))))))\n\
    </code>\nEDIT:\nYou may not need to check for even indices, since <code>string-ref</code>\
    \ will automatically return the appropriate letter at the index.\n<code>#lang\
    \ racket\n", "  (let ([upper-vowels (list #\\A #\\E #\\I #\\O #\\U)])\n    (map\n\
    \     (lambda (x)\n       (member (car x) upper-vowels))\n     (filter\n     \
    \ (lambda (x)\n        (equal? 0 (modulo (cdr x) 2)))\n      (let loop ([s s]\
    \ [i 0])\n        (if (null? s)\n            '()\n            (cons (cons (car\
    \ s) i) (loop (cdr s) (+ i 1)))))))))\n", "  (define (every-other lst)\n    (cond\n\
    \      [(empty? lst) empty]\n      [(empty? (rest lst)) empty]\n      [else (cons\
    \ (first lst) (every-other (rest (rest lst))))]))\n  (define (is-vowel? s)\n \
    \   (member s '(#\\A #\\E #\\I #\\O #\\U)))\n  (define (is-lower? s)\n    (char-lower-case?\
    \ s))\n  (define (is-upper? s)\n    (char-upper-case? s))\n  (cond\n    [(empty?\
    \ s) 0]\n    [(is-vowel? (first s)) (if (is-upper? (first s))\n              \
    \                 (+ 1 (count_upper (rest s)))\n                             \
    \  (count_upper (rest s)))]\n    [else (count_upper (rest s))]))\n", "  (let count\
    \ ([s s] [n 0])\n    (cond\n      [(null? s) n]\n      [(= 1 (remainder (string-length\
    \ s) 2))\n       (count (substring s 1) n)]\n      [(string-contains? \"AEIOU\"\
    \ (string-ref s 0))\n       (count (substring s 1) (+ n 1))]\n      [else (count\
    \ (substring s 1) n)])))\n</code>\n", "  (let loop ([i 0] [acc 0])\n    (cond\
    \ [(eq? i (string-length s)) acc]\n          [(and (char-vowel? (string-ref s\
    \ i)) (char-upper-case? (string-ref s i)))\n           (loop (+ i 2) (+ acc 1))]\n\
    \          [else (loop (+ i 2) acc)])))\n", "  (define (help s acc i)\n    (cond\
    \ [(empty? s) acc]\n          [(and (= i 0) (member (first s) '(#\\A #\\E #\\\
    I #\\O #\\U)))\n           (help (rest s) (+ acc 1) 1)]\n          [else (help\
    \ (rest s) acc (+ i 1))]))\n  (help s 0 0))\n", "  (let ([count 0])\n    (define\
    \ (indices_str s)\n      (list-index (string->list s)))\n    (define (vowels_str\
    \ s)\n      (filter (lambda (x) (or (char=? x #\\a) (char=? x #\\e) (char=? x\
    \ #\\i) (char=? x #\\o) (char=? x #\\u))) (string->list s)))\n    (define (indices_vowels\
    \ s)\n      (list-index (vowels_str s)))\n    (define (filter_even_indices lst)\n\
    \      (filter (lambda (x) (even? x)) lst))\n    (define (even_indices_vowels\
    \ s)\n      (filter_even_indices (indices_vowels s)))\n    (define (even_indices_upper\
    \ s)\n      (filter_even_indices (indices_str s)))\n    (define (intersect lst1\
    \ lst2)\n      (filter (lambda (x) (member x lst2)) lst1))\n    (define (length_intersect\
    \ s)\n      (length (intersect (even_indices_upper s) (even_indices_vowels s))))\n\
    \    (length_intersect s)))", "  (let loop ([i 0] [count 0])\n    (cond\n    \
    \  [(null? s) count]\n      [(and (even? i) (vowel? (string-ref s 0))) (loop (add1\
    \ i) (add1 count))]\n      [else (loop (add1 i) count)])))\n", "  (if (string=?\
    \ s \"\")\n      0\n      (if (and (= (remainder (string-length s) 2) 0)\n   \
    \            (member (substring s 0 1) (list \"A\" \"E\" \"I\" \"O\" \"U\")))\n\
    \          (+ 1 (count_upper (substring s 1)))\n          (count_upper (substring\
    \ s 1)))))\n</code>\n", "  (cond\n    [(empty? s) 0]\n    [(is-upper? (first s))\
    \ (if (even? (count s)) 1 0)]\n    [else 0]))\n", "  (for/sum ([ch (in-string\
    \ s)])\n    (if (or (= #\\A ch) (= #\\E ch) (= #\\I ch) (= #\\O ch) (= #\\U ch))\n\
    \        (even? (string-index s ch))\n        0)))\n", "  (letrec ([even-index?\
    \ (lambda (i) (= (remainder i 2) 0))]\n           [vowel? (lambda (c) (or (equal?\
    \ c #\\a)\n                                   (equal? c #\\e)\n              \
    \                     (equal? c #\\i)\n                                   (equal?\
    \ c #\\o)\n                                   (equal? c #\\u)))]\n           [acc\
    \ (lambda (lst total)\n                   (cond [(empty? lst) total]\n       \
    \                  [(even-index? (car lst))\n                          (acc (cdr\
    \ lst)\n                               (if (vowel? (string-ref s (car lst)))\n\
    \                                   (+ total 1)\n                            \
    \       total))]\n                         [else (acc (cdr lst) total)]))])\n\
    \    (acc (range (string-length s)) 0)))\n", "  (local\n    ;; This 'consumes'\
    \ the string that was passed in.\n    ;; For example:\n    ;; (loop str 0) consumes\
    \ (car str) and returns the tail of the string.\n    ;; (loop (cdr str) 0) consumes\
    \ all but the first character of the string.\n    ;; (loop (cdr (cdr str)) 0)\
    \ consumes all but the first 2 characters of the string.\n    ;; etc.\n    ;;\
    \ In each loop, (car str) is the current character to test.\n    (define (loop\
    \ str result)\n      (cond\n        ;; if the string is empty, then we are done\n\
    \        [(null? str) result]\n        ;; otherwise, if we have an odd character\
    \ index and the current character is upper case, then add 1 to the result\n  \
    \      [else (loop (cdr str) (+ (if (even? (length str)) (if (char-upper-case?\
    \ (car str)) 1 0) 0) result))]))\n    ;; start off the loop by calling (loop s\
    \ 0)\n    (loop s 0)))\n", "  (define (vowel-char? c)\n    (or (char=? c #\\a)\n\
    \        (char=? c #\\e)\n        (char=? c #\\i)\n        (char=? c #\\o)\n \
    \       (char=? c #\\u)))\n  (define (upper-vowel-char? c)\n    (and (char-upcase?\
    \ c)\n         (vowel-char? c)))\n  (define (even? n)\n    (= (remainder n 2)\
    \ 0))\n  (define (upper-vowel-even-index-count s index count)\n    (if (empty?\
    \ s)\n        count\n        (if (even? index)\n            (if (upper-vowel-char?\
    \ (first s))\n                (upper-vowel-even-index-count (rest s) (+ index\
    \ 1) (+ count 1))\n                (upper-vowel-even-index-count (rest s) (+ index\
    \ 1) count))\n            (upper-vowel-even-index-count (rest s) (+ index 1) count))))\n\
    \  (upper-vowel-even-index-count s 0 0))\n", "  (define (count-even-uppers s i)\n\
    \    (cond\n      [(= i (string-length s)) 0]\n      [(and (char-uppercase? (string-ref\
    \ s i))\n            (vowel? (string-ref s i)))\n       (+ 1 (count-even-uppers\
    \ s (+ i 2)))]\n      [else (count-even-uppers s (+ i 2))]))\n  (count-even-uppers\
    \ s 0))\n", "  (define (f n)\n    (cond\n      ((= n 0)\n       0)\n      ((string-upper-case?\
    \ (string-ref s n))\n       (+ 1 (f (- n 2))))\n      (else\n       (f (- n 2)))))\n\
    \  (f (- (string-length s) 1)))\n", "  (cond\n    [(string-null? s) 0]\n    [(even?\
    \ (string-index s)) (+ (if (vowel? (string-ref s 0)) 1 0) (count_upper (string-tail\
    \ s)))]\n    [else (count_upper (string-tail s))]))\n", "  (let ([indices (range\
    \ 2 (string-length s) 2)])\n    (list-count (lambda (i) (char-upper-case? (string-ref\
    \ s i))) indices)))\n", "  (cond ((null? s) 0)\n        ((and (vowel? (car s))\
    \ (odd? (position (car s) (string->list s))))\n         (+ 1 (count_upper (cdr\
    \ s))))\n        (else (count_upper (cdr s)))))\n", "  (let ([upper-vowels '(#\\\
    A #\\E #\\I #\\O #\\U)])\n    (count-if (lambda (x) (and (vowel? x) (upper-vowel?\
    \ x)))\n              (even-indices s))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
