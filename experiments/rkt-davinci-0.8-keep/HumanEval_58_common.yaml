name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n;; [1, 5, 653]\n\
  ;; >>> common([5, 3, 2, 8], [3, 2])\n;; [2, 3]\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (sort (filter (lambda (x) (member x l1)) l2) <))\n", "  (unique (list-sort\
    \ < (append l1 l2))))\n", "  (define (sorted-unique l)\n    (sort (remove-duplicates\
    \ l) <))\n  (let loop ([l1 l1] [l2 l2])\n    (cond [(empty? l1) empty]\n     \
    \     [(member (first l1) l2) (cons (first l1) (loop (rest l1) l2))]\n       \
    \   [else (loop (rest l1) l2)])))\n", "  (sort (remove-duplicates (set-intersection\
    \ l1 l2)) <))\n", "  (cond [(empty? l1) empty]\n        [(member (first l1) l2)\
    \ (cons (first l1) (common (rest l1) l2))]\n        [else (common (rest l1) l2)]))\n",
  "  (define (uniq l)\n    (if (null? l)\n        '()\n        (cons (car l) (remove\
    \ (car l) (uniq (cdr l))))))\n  (sort (uniq (append l1 l2)) <))\n", "  (sort (remdup\
    \ (append l1 l2)) #&lt;))\n", "  (define (common-iter l1 l2 acc)\n    (cond [(null?\
    \ l1) acc]\n          [(null? l2) acc]\n          [(equal? (car l1) (car l2))\
    \ (common-iter (cdr l1) (cdr l2) (cons (car l1) acc))]\n          [(< (car l1)\
    \ (car l2)) (common-iter (cdr l1) l2 acc)]\n          [else (common-iter l1 (cdr\
    \ l2) acc)]))\n  (sort (common-iter l1 l2 '()) <))\n", "  (sort\n   (remdup\n\
    \    (filter (\u03BB (x) (member x l2)) l1))\n   &lt;))\n</code>\nTests:\n<code>&gt;\
    \ (common '(1 4 3 34 653 2 5) '(5 7 1 5 9 653 121))\n'(1 5 653)\n&gt; (common\
    \ '(5 3 2 8) '(3 2))\n'(2 3)\n</code>\n", "  (cond\n    [(null? l1) '()]\n   \
    \ [(member (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common\
    \ (cdr l1) l2)]))\n", "  (sort (unique (filter (lambda (x) (member x l2)) l1))\
    \ <))\n\n", "  (define (f l1 l2 acc)\n    (cond\n      [(empty? l1) acc]\n   \
    \   [(empty? l2) acc]\n      [(member (first l1) l2) (f (rest l1) l2 (cons (first\
    \ l1) acc))]\n      [else (f (rest l1) l2 acc)]))\n  (sort (f l1 l2 '()) string<?))\n",
  "  (sort l1 #:key identity #:compare <))\n", "  (define l1-unique (unique l1))\n\
    \  (define l2-unique (unique l2))\n  (define common-uniq\n    (filter (lambda\
    \ (e) (member e l2-unique)) l1-unique))\n  (sort common-uniq <))\n", "  (sort\
    \ (remove-duplicates (append l1 l2)) <))\n\n", "  (set-subtract (sort l1 #:key\
    \ identity #:comparator string<?=?)\n                (sort l2 #:key identity #:comparator\
    \ string<?=?)))\n```\n\n```\n#lang racket\n", "  (set! l1 (sort l1 <))\n  (set!\
    \ l2 (sort l2 <))\n  (for/list ([x (in-list l1)]\n             #:when (member\
    \ x l2))\n    x))\n```\n\n[\u2191 top](#racket-language)\n<br><br><br><br><hr>\n\
    \n\n##### compute the sum of all items in a list\n\n```racket\n#lang racket\n",
  "  (cond\n    [(empty? l1)\n     '()]\n    [(empty? l2)\n     '()]\n    [(= (first\
    \ l1) (first l2))\n     (cons (first l1) (common (rest l1) (rest l2)))]\n    [(<\
    \ (first l1) (first l2))\n     (common (rest l1) l2)]\n    [(> (first l1) (first\
    \ l2))\n     (common l1 (rest l2))]))\n```\n\n```\n#lang racket\n", "  (cond [(null?\
    \ l1) '()]\n        [(null? l2) '()]\n        [(memq (car l1) l2) (append (list\
    \ (car l1)) (common (cdr l1) l2))]\n        [else (common (cdr l1) l2)]))", " \
    \ (sort (unique (append l1 l2)) <))\n", "  (sort (delete-duplicates (append l1\
    \ l2)) &lt;))\n", "  (sort (for/list ([i l1] [j l2])\n           (and (in-list?\
    \ i l2) (in-list? j l1) i))\n        &lt;))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) (comparator &lt;)))\n", "  (sort (remove-duplicates (append l1 l2))\
    \ <))\n", "  (let loop ([l1 l1] [l2 l2] [acc '()])\n    (cond [(or (empty? l1)\
    \ (empty? l2)) (sort acc <)]\n          [(equal? (first l1) (first l2))\n    \
    \       (loop (rest l1) (rest l2) (cons (first l1) acc))]\n          [(< (first\
    \ l1) (first l2)) (loop (rest l1) l2 acc)]\n          [else (loop l1 (rest l2)\
    \ acc)])))\n```\n\n```scheme", "  (sort (unique (flatten (list-intersect l1 l2)))\
    \ <))\n", "  (list-set (list-intersect l1 l2)))\n", "  (define (inner l1 l2)\n\
    \    (cond [(empty? l1) '()]\n          [(member (first l1) l2) (cons (first l1)\
    \ (inner (rest l1) l2))]\n          [else (inner (rest l1) l2)]))\n  (list-set\
    \ (inner l1 l2)))\n", "  (cond\n    [(empty? l1) '()]\n    [(empty? l2) '()]\n\
    \    [(in? (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n    [else\
    \ (common (rest l1) l2)]))\n", "  (sort (unique (append l1 l2)) #:key (lambda\
    \ (x) (member x l1))))\n", "  (cond\n    [(empty? l1) '()]\n    [(contains? l2\
    \ (first l1))\n     (cons (first l1) (common (rest l1) l2))]\n    [else (common\
    \ (rest l1) l2)]))\n```\n\n## Uniquify a list\n\n```racket\n#lang racket\n", " \
    \ (sort (remove-duplicates (append l1 l2)) #&lt;))\n", "  (define l3 (list))\n\
    \  (for ([el1 l1]\n        [el2 l2])\n    (when (and (member el1 l2) (not (member\
    \ el1 l3)))\n      (set! l3 (append l3 (list el1)))))\n  (sort l3 <))\n", "  (cond\
    \ [(and (empty? l1) (empty? l2)) empty]\n        [(empty? l1) empty]\n       \
    \ [(empty? l2) empty]\n        [(and (equal? (first l1) (first l2))\n        \
    \      (memq (first l1) (rest l1))\n              (memq (first l1) (rest l2)))\n\
    \         (cons (first l1) (common (rest l1) (rest l2)))]\n        [(and (equal?\
    \ (first l1) (first l2))\n              (memq (first l1) (rest l1)))\n       \
    \  (cons (first l1) (common (rest l1) (rest l2)))]\n        [(and (equal? (first\
    \ l1) (first l2))\n              (memq (first l1) (rest l2)))\n         (cons\
    \ (first l1) (common (rest l1) (rest l2)))]\n        [else (common (rest l1) (rest\
    \ l2))]))\n", "  (sort (unique (append l1 l2)) (\u03BB (a b) (&lt; a b))))\n",
  "  (sort\n   (set-intersection l1 l2)\n   <))\n\n", "  (cond [(null? l1) null]\n\
    \        [(member (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n       \
    \ [else (common (cdr l1) l2)]))\n", "  (sort l1 <)\n  (sort l2 <)\n  (let loop\
    \ ([l1 l1] [l2 l2] [l3 '()])\n    (cond [(empty? l1) (reverse l3)]\n         \
    \ [(empty? l2) (reverse l3)]\n          [(and (member (first l1) l2) (not (member\
    \ (first l1) l3)))\n           (loop (rest l1) l2 (cons (first l1) l3))]\n   \
    \       [else (loop (rest l1) l2 l3)])))\n", "  (sort\n   (remove-duplicates\n\
    \    (append\n     (filter\n      (lambda (x) (member x l2))\n      l1)\n    \
    \ (filter\n      (lambda (x) (member x l1))\n      l2)))\n   &lt;))\n</code>\n\
    In Julia, the following function does the same:\n<code>\"\"\"\n  common(l1, l2)\n\
    \n  Return sorted unique common elements for two lists.\n  Example:\n  julia&gt;\
    \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n\
    \  julia&gt; common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\"\"\"\nfunction common(l1,\
    \ l2)\n  sort([x for x in l1 if x in l2])\nend\n</code>\nIs there a more \"idiomatic\"\
    \ way to write this function in Julia?\n\n\nA:\n\nYou should use <code>intersect</code>\
    \ from standard library:\n<code>julia&gt; intersect([1, 4, 3, 34, 653, 2, 5],\
    \ [5, 7, 1, 5, 9, 653, 121])\n3-element Array{Int64,1}:\n   1\n   5\n 653\n</code>\n\
    It returns sorted array that is what you need.\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (sort (removedups (intersection l1 l2)) <))\n",
  "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (cond\n    [(empty? l1) '()]\n    [(empty?\
    \ l2) '()]\n    [(= (first l1) (first l2))\n     (cons (first l1) (common (rest\
    \ l1) (rest l2)))]\n    [(< (first l1) (first l2))\n     (common (rest l1) l2)]\n\
    \    [(> (first l1) (first l2))\n     (common l1 (rest l2))]))\n", "  (define\
    \ (common-helper l1 l2 acc)\n    (if (or (null? l1) (null? l2))\n        acc\n\
    \        (let ([h1 (car l1)]\n              [h2 (car l2)])\n          (if (= h1\
    \ h2)\n              (common-helper (cdr l1) (cdr l2) (cons h1 acc))\n       \
    \       (if (&lt; h1 h2)\n                  (common-helper (cdr l1) l2 acc)\n\
    \                  (common-helper l1 (cdr l2) acc))))))\n  (sort (common-helper\
    \ l1 l2 '()) &lt;))\n</code>\nNote that I renamed the input lists as <code>l1</code>\
    \ and <code>l2</code> because it's very poor practice to overwrite <code>list</code>\
    \ (and because you do it again with <code>acc</code>!).\nThis version is similar\
    \ to the code in your question, but is more idiomatic Racket.\n", "  (remove-duplicates\
    \ (sort (append l1 l2))))\n", "  (cond [(empty? l1) empty]\n        [(empty? l2)\
    \ empty]\n        [(member (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n\
    \        [else (common (rest l1) l2)]))\n", "  (sort (remove-duplicates (intersection\
    \ l1 l2)) <))\n", "  (cond [(or (null? l1) (null? l2)) empty]\n        [else (if\
    \ (equal? (car l1) (car l2))\n                 (cons (car l1) (common (cdr l1)\
    \ (cdr l2)))\n                 (if (&lt; (car l1) (car l2))\n                \
    \     (common (cdr l1) l2)\n                     (common l1 (cdr l2))))]))\n</code>\n\
    This works fine as long as both lists are sorted and unique.\n<code>(common '(1\
    \ 4 3 34 653 2 5) '(5 7 1 5 9 653 121))\n=&gt; '(1 5 653)\n</code>\nWhat if both\
    \ lists are not sorted and contain duplicate elements?\n<code>(common '(5 3 2\
    \ 8) '(3 2))\n=&gt; '(2 3)", "  (sort (remove-duplicates (intersection l1 l2 #:test-equal?\
    \ #t)) #:key car))\n", "  (match l1\n    [(list) empty]\n    [(cons hd tl)\n \
    \    (if (memq hd l2)\n         (cons hd (common tl l2))\n         (common tl\
    \ l2))]))\n", "  (filter\n   (lambda (x) (member x l2))\n   (sort (append l1 l2)\
    \ <)))\n", "  (sort (remove-duplicates (intersection l1 l2)) #&lt;))\n", "  (sort\
    \ (remove-duplicates (append l1 l2)) <))\n", "  (cond ((or (empty? l1) (empty?\
    \ l2)) empty)\n        ((= (first l1) (first l2)) (cons (first l1) (common (rest\
    \ l1) (rest l2))))\n        ((&lt; (first l1) (first l2)) (common (rest l1) l2))\n\
    \        ((&gt; (first l1) (first l2)) (common l1 (rest l2)))))\n</code>\nBut\
    \ I wish it was more functional. Is there a way to rewrite it using <code>foldr</code>\
    \ or some functional concepts to make it a true functional form, or is this the\
    \ best that can be done with lists?\n\n\nA:\n\nI would use a <code>for/fold</code>\
    \ with a hash table. This avoids sorting two lists, it's quite efficient and uses\
    \ a technique that's known as a \"bag\" in many functional languages.\n<code>(define\
    \ (common l1 l2)\n  (for/fold ([h (make-hash)])\n            ([elem l1])\n   \
    \         (hash-update elem (\u03BB (x) (+ 1 x)) 1 h))\n  (for/fold ([common '()])\n\
    \            ([elem l2])\n            (if (&gt; (hash-ref h elem 1) 0)\n     \
    \           (begin\n                  (hash-update elem (\u03BB (x) (- x 1)) h)\n\
    \                  (cons elem common))\n                common)))\n</code>\nExamples:\n\
    <code>(common '(1 4 3 34 653 2 5) '(5 7 1 5 9 653 121))\n=&gt; '(1 5 653)\n",
  "  (define (unique l1 l2)\n    (cond [(empty? l1) l2]\n          [(member (first\
    \ l1) l2) (unique (rest l1) l2)]\n          [else (cons (first l1) (unique (rest\
    \ l1) l2))]))\n  (sort < (unique l1 l2)))\n", "  (let loop ([l1 l1] [l2 l2] [common\
    \ '()])\n    (cond [(or (null? l1) (null? l2)) (sort common <)]\n          [(=\
    \ (car l1) (car l2)) (loop (cdr l1) (cdr l2) (cons (car l1) common))]\n      \
    \    [(< (car l1) (car l2)) (loop (cdr l1) l2 common)]\n          [else (loop\
    \ l1 (cdr l2) common)])))\n", "  (define l3\n    (sort (remove-duplicates (append\
    \ l1 l2)) <))\n  (define l4\n    (sort l3 <))\n  (define l5\n    (cond [(equal?\
    \ l4 (list)) empty]\n          [(equal? l4 (list 1)) empty]\n          [else\n\
    \           (define min (car l4))\n           (define max (last l4))\n       \
    \    (filter (lambda (x)\n                     (member x l4))\n              \
    \     (range min max))]))\n  (cond [(empty? l5) empty]\n        [else\n      \
    \   (filter (lambda (x)\n                   (member x l1))\n                 l5)]))\n\
    ```\n\n```racket\n#lang racket\n", "  (sort (unique (filter (lambda (x) (member\
    \ x l2)) l1)) <))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort\
    \ l1 <)\n  (sort l2 <)\n  (cond [(null? l1) '()]\n        [(member (car l1) l2)\
    \ (cons (car l1) (common (cdr l1) l2))]\n        [else (common (cdr l1) l2)]))\n",
  "  (define (intersect l1 l2)\n    (cond\n      [(empty? l1) l2]\n      [(member\
    \ (first l1) l2) (cons (first l1) (intersect (rest l1) l2))]\n      [else (intersect\
    \ (rest l1) l2)]))\n  (sort (intersect l1 l2) <))\n```\n\n```Racket\n#lang racket\n",
  "  (cond ((null? l1) '())\n        ((member (car l1) l2) (cons (car l1) (common\
    \ (cdr l1) l2)))\n        (else (common (cdr l1) l2))))\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (sort (hash-set-intersection (hash l1) (hash\
    \ l2)) <))\n", "  (let ([s1 (sort l1 <)]\n        [s2 (sort l2 <)])\n    (cond\
    \ [(or (null? s1) (null? s2)) '()]\n          [(< (car s1) (car s2)) (common (cdr\
    \ s1) s2)]\n          [(> (car s1) (car s2)) (common s1 (cdr s2))]\n         \
    \ [else (cons (car s1) (common (cdr s1) (cdr s2)))])))\n```\n\n<br>\n\n### 5.1b\n\
    \n```racket\n#lang racket\n", "  (sort (uniq (filter (lambda (x) (member x l2))\
    \ l1)) <))\n\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (remove-duplicates\
    \ (sort l1 #:key (cut < <>)) (sort l2 #:key (cut < <>))))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) #:key #'car #:cmp (compose < car <)))\n", "  (sort (filter (lambda\
    \ (x) (member x l1)) l2) &lt;))\n", "  (let loop ([elements l1] [common-elements\
    \ '()])\n    (cond [(empty? elements) (sort common-elements #:key car)]\n    \
    \      [(member (car elements) l2)\n           (loop (cdr elements) (cons (car\
    \ elements) common-elements))]\n          [else (loop (cdr elements) common-elements)])))\n",
  "  (let loop ([l1 l1] [l2 l2] [out '()])\n    (cond\n      [(null? l1) out]\n  \
    \    [(null? l2) out]\n      [(equal? (car l1) (car l2))\n       (loop (cdr l1)\
    \ (cdr l2) (cons (car l1) out))]\n      [(< (car l1) (car l2)) (loop (cdr l1)\
    \ l2 out)]\n      [else (loop l1 (cdr l2) out)])))", "  (sort (unique (intersect\
    \ l1 l2)) <))\n", "  (define (less? a b) (< a b))\n  (define (insert-sort l)\n\
    \    (for/fold ([sorted '()]) ([x l])\n      (for/fold ([acc '()]) ([y sorted])\n\
    \        (if (less? x y)\n            (cons x (cons y acc))\n            (cons\
    \ y acc)))))\n  (define (take-once l)\n    (for/fold ([acc '()]) ([x l])\n   \
    \   (if (member x acc)\n          acc\n          (cons x acc))))\n  (define (is-common?\
    \ x l1 l2)\n    (and (member x l1) (member x l2)))\n  (define (intersection l1\
    \ l2)\n    (for/fold ([acc '()]) ([x l1])\n      (if (is-common? x l1 l2)\n  \
    \        (cons x acc)\n          acc)))\n  (intersection (insert-sort l1) (insert-sort\
    \ l2)))\n```\n## \u0423\u0441\u043B\u043E\u0432\u0438\u0435 \u0437\u0430\u0434\
    \u0430\u0447\u0438\n\n\u0414\u0430\u043D\u044B \u0434\u0432\u0430 \u0441\u043F\
    \u0438\u0441\u043A\u0430. \u0412\u044B\u0432\u0435\u0441\u0442\u0438 \u0441\u043F\
    \u0438\u0441\u043E\u043A \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0449\u0438\
    \u0439 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B, \u043A\u043E\u0442\u043E\
    \u0440\u044B\u0435 \u0435\u0441\u0442\u044C \u0438 \u0432 \u043F\u0435\u0440\u0432\
    \u043E\u043C, \u0438 \u0432\u043E \u0432\u0442\u043E\u0440\u043E\u043C \u0441\u043F\
    \u0438\u0441\u043A\u0435. \u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u043A\
    \u0430 \u043D\u0435 \u0438\u043C\u0435\u0435\u0442 \u0437\u043D\u0430\u0447\u0435\
    \u043D\u0438\u044F.\n\n## \u041F\u0440\u0438\u043C\u0435\u0440 \u0440\u0430\u0431\
    \u043E\u0442\u044B \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B\n```\n\
    > (common '(1 4 3 34 653 2 5) '(5 7 1 5 9 653 121))", "  (sort (uniq (flatten\
    \ (map (\u03BB (x) (if (member x l2) (list x))) l1))) <))\n", "  (sort (remove-duplicates\
    \ (filter (lambda (x) (memq x l1)) l2)) <))\n\n", "  (sort (remove-duplicates\
    \ (intersection l1 l2)) <))\n", "  (sort (unique (intersect (unique l1) (unique\
    \ l2))) &lt;))\n</code>\nHow can I make it a one-liner?\n\n\nA:\n\nSince <code>unique</code>\
    \ and <code>intersect</code> return lists, you can just <code>sort</code> their\
    \ result by using the <code>apply</code> function:\n<code>(sort (apply intersect\
    \ (map unique '(list-1 list-2))) &lt;)\n</code>\n", "  (sort (unique (append l1\
    \ l2)) #:key identity #:cmp <))\n```\n\n#### Sorting (possible Python solution)\n\
    \n```python\n#lang python\n\n# Return sorted unique common elements for two lists.\n\
    # >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n\
    # >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2):\n    return\
    \ sorted(list(set(l1 + l2)))\n```\n\n## Run tests\n\n```bash\npython3 -m doctest\
    \ ./path/to/file.rkt\nracket ./path/to/file.rkt\n```", "  (sort (for/list ([i\
    \ l1] [j l2])\n            (when (equal? i j) i)) <))\n", "  (sort (uniq (intersect\
    \ l1 l2)) <))\n", "  (sort (remove-duplicates (flatten (list (intersect l1 l2))))\
    \ <))\n", "  (define (sort_uniq xs)\n    (cond [(null? xs) '()]\n          [(null?\
    \ (cdr xs)) xs]\n          [else (sort (uniq (car xs) (cdr xs)) <)]))\n  (sort_uniq\
    \ (intersection l1 l2 <)))\n", "  (cond\n    [(null? l1) '()]\n    [(member (car\
    \ l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common (cdr l1) l2)]))\n\
    ```\n\n```racket\n#lang racket\n", "  (sort (remove-duplicates (append l1 l2))\
    \ #&lt;))\n", "  (sort (set-intersection l1 l2) #:key (lambda (x) x)))\n", " \
    \ (sort (remove-duplicates (append l1 l2)) <))\n", "  (set! l1 (sort l1 <))\n\
    \  (set! l2 (sort l2 <))\n  (let loop ([acc '()] [l1 l1] [l2 l2])\n    (cond\n\
    \      [(empty? l1) (reverse acc)]\n      [(empty? l2) (reverse acc)]\n      [(=\
    \ (first l1) (first l2))\n       (loop (cons (first l1) acc) (rest l1) (rest l2))]\n\
    \      [else\n       (if (< (first l1) (first l2))\n           (loop acc (rest\
    \ l1) l2)\n           (loop acc l1 (rest l2)))])))\n", "  (sort (set-intersection\
    \ (set l1) (set l2)) <))\n</code>\n", "  (define (iter acc l)\n    (if (null?\
    \ l)\n        acc\n        (if (member (car l) l2)\n            (iter (cons (car\
    \ l) acc) (cdr l))\n            (iter acc (cdr l)))))\n  (sort (iter '() l1) &lt;))\n\
    </code>\n", "  (sort (remove-duplicates (append l1 l2)) <))\n```\n\n```py\ndef\
    \ common(l1, l2):\n    return sorted(set(l1 + l2))\n```\n\n```js\nfunction common(l1,\
    \ l2) {\n  const all = [...l1, ...l2]\n  return [...new Set(all)].sort((a, b)\
    \ => a - b)\n}\n```\n\n## Use\n\n```racket", "  (define (common' l1 l2 out)\n\
    \    (cond\n      [(or (null? l1) (null? l2)) (sort out #:key car #:cmp <)]\n\
    \      [(equal? (car l1) (car l2)) (common' (cdr l1) (cdr l2) (cons (car l1) out))]\n\
    \      [(> (car l1) (car l2)) (common' l1 (cdr l2) out)]\n      [else (common'\
    \ (cdr l1) l2 out)]))\n  (common' (sort l1 #:key car #:cmp <) (sort l2 #:key car\
    \ #:cmp <) '()))\n", "  (list-set (intersection l1 l2)))\n", "  (cond\n    [(or\
    \ (empty? l1) (empty? l2)) (list)]\n    [(member (first l1) l2) (cons (first l1)\
    \ (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (define uniq-l1\
    \ (remove-duplicates l1))\n  (define uniq-l2 (remove-duplicates l2))\n  (cond\
    \ [(null? uniq-l1) '()]\n        [(member (car uniq-l1) uniq-l2) (cons (car uniq-l1)\
    \ (common (cdr uniq-l1) uniq-l2))]\n        [else (common (cdr uniq-l1) uniq-l2)]))\n",
  "  (sort\n   (list-set\n    (append l1 l2))\n   <))\n", "  (set-intersection (set\
    \ l1) (set l2)))\n", "  (define (unique l)\n    (let loop ([seen '()] [l l])\n\
    \      (if (null? l)\n          seen\n          (if (member (car l) seen)\n  \
    \            (loop seen (cdr l))\n              (loop (cons (car l) seen) (cdr\
    \ l))))))\n  (sort (unique (append l1 l2)) <))\n", "  (cond\n    [(empty? l1)\
    \ '()]\n    [(empty? l2) '()]\n    [(empty? (member (first l1) l2)) (common (rest\
    \ l1) l2)]\n    [else (cons (first l1) (common (rest l1) l2))]))", "  (let ([l1-set\
    \ (set l1)]\n        [l2-set (set l2)])\n    (sort (intersection l1-set l2-set)\
    \ <)))\n", "  (sort (remove-duplicates (intersection l1 l2)) <))\n", "  (set-difference\
    \ l1 l2))\n", "  (unique-sorted (set-intersection (unique-sorted l1) (unique-sorted\
    \ l2))))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (cond\n  \
    \  [(empty? l1) '()]\n    [(empty? l2) '()]\n    [(member (first l1) l2) (cons\
    \ (first l1) (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", " \
    \ (sort (dedup (append l1 l2)) <))\n", "  (sort (remove-duplicates (intersection\
    \ l1 l2))))\n", "  (sort (for/set ([e (in-list l1)]\n                  #:when\
    \ (member e l2))\n         e)\n        <))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) #&lt;))\n", "  (sort (uniq (append l1 l2)) #:key (compose car id) #:cmp\
    \ >))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort (delete-duplicates\
    \ (append l1 l2)) <))\n", "  (cond\n    [(empty? l1) empty]\n    [(empty? l2)\
    \ empty]\n    [(equal? (first l1) (first l2))\n     (cons (first l1) (common (rest\
    \ l1) (rest l2)))]\n    [(< (first l1) (first l2)) (common (rest l1) l2)]\n  \
    \  [else (common l1 (rest l2))]))\n", "  (sort (remove-duplicates (append l1 l2))\
    \ <))\n", "  (cond [(or (empty? l1) (empty? l2)) empty]\n        [else (if (memq\
    \ (first l1) l2)\n                 (cons (first l1) (common (rest l1) l2))\n \
    \                (common (rest l1) l2))]))\n", "  (sort (uniq (intersect l1 l2))))\n",
  "  (cond ((and (null? l1) (null? l2)) '())\n        ((or (null? l1) (null? l2))\
    \ '())\n        ((equal? (car l1) (car l2))\n         (cons (car l1) (common (cdr\
    \ l1) (cdr l2))))\n        ((> (car l1) (car l2)) (common l1 (cdr l2)))\n    \
    \    ((< (car l1) (car l2)) (common (cdr l1) l2))))\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) #&lt;))\n", "  (filter (\u03BB (e) (member e l2)) (set (sort\
    \ l1 compare))))\n", "  (let ([s1 (sort l1 <)]\n        [s2 (sort l2 <)])\n  \
    \  (cond [(empty? s1) '()]\n          [(empty? s2) '()]\n          [(or (< (first\
    \ s1) (first s2))\n               (> (first s1) (first s2)))\n           (cond\
    \ [(< (first s1) (first s2))\n                  (common (rest s1) s2)]\n     \
    \            [(> (first s1) (first s2))\n                  (common s1 (rest s2))])]\n\
    \          [(= (first s1) (first s2))\n           (cons (first s1) (common (rest\
    \ s1) (rest s2)))])))\n", "  (define (unique . l)\n    (let loop ((l l) (r '()))\n\
    \      (cond ((null? l) r)\n            ((member (car l) r) (loop (cdr l) r))\n\
    \            (else (loop (cdr l) (cons (car l) r))))))\n  (define (intersect l1\
    \ l2)\n    (let loop ((l1 l1) (r '()))\n      (cond ((null? l1) r)\n         \
    \   ((member (car l1) l2) (loop (cdr l1) (cons (car l1) r)))\n            (else\
    \ (loop (cdr l1) r)))))\n  (sort (unique (intersect l1 l2)) <))\n", "  (sort (delete-duplicates\
    \ (append l1 l2)) <))\n", "  (sort (uniq (list-intersect l1 l2))))\n", "  (sort\
    \ (remq-duplicates (intersection l1 l2)) <))\n", "  (remove-duplicates (append\
    \ l1 l2)))\n</code>\nStep 2: Flatten\n<code>#lang racket\n", "  (sort (remove-duplicates\
    \ (append l1 l2)) <))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n",
  "  (foldl (lambda (cur acc)\n           (if (member cur l2)\n               (cons\
    \ cur acc)\n               acc))\n         '()\n         (sort l1 <)))\n", " \
    \ (cond [(and (null? l1) (null? l2)) '()]\n        [(or (null? l1) (null? l2))\
    \ '()]\n        [(and (member (car l1) l2) (member (car l1) (common (cdr l1) l2)))\n\
    \         (cons (car l1) (common (cdr l1) l2))]\n        [else (common (cdr l1)\
    \ l2)]))\n", "  (sort (remove-duplicates (filter (lambda (x) (member x l2)) l1))\
    \ &lt;))\n</code>\nIf it is the intersection of two sets that you want, you could\
    \ use <code>set-intersection</code> from <code>rackunit</code>:\n<code>#lang racket\n",
  "  (sort (remove-duplicates (append l1 l2)) #&lt;)\n  )\n", "  (sort (uniq (append\
    \ l1 l2)) <))\n", "  (define (set_has_next lst)\n    (if (null? lst)\n       \
    \ false\n        (define nxt (car lst))\n        (if (member nxt (cdr lst))\n\
    \            (set_has_next (cdr lst))\n            true)))\n  (if (set_has_next\
    \ l1)\n      (common (remove-duplicates l1) l2)\n      (if (set_has_next l2)\n\
    \          (common l1 (remove-duplicates l2))\n          (remove-duplicates (intersect\
    \ l1 l2)))))\n", "  (cond\n    [(null? l1) '()]\n    [(null? l2) '()]\n    [(memq\
    \ (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n    [else (common (cdr l1)\
    \ l2)]))\n", "  (define (inner l1 l2 l3)\n    (cond [(null? l1) l3]\n        \
    \  [(null? l2) (inner (cdr l1) l2 l3)]\n          [(equal? (car l1) (car l2))\
    \ (inner (cdr l1) (cdr l2) (cons (car l1) l3))]\n          [(< (car l1) (car l2))\
    \ (inner (cdr l1) l2 l3)]\n          [else (inner l1 (cdr l2) l3)]))\n  (inner\
    \ (sort l1 <) (sort l2 <) '()))\n", "  (sort (remove-duplicates (append l1 l2))\
    \ &lt;))\n", "  (cond\n    [(empty? l1) empty]\n    [(in? (first l1) l2) (cons\
    \ (first l1) (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", " \
    \ (define (find-matches l1 l2 matches)\n    (cond ((empty? l1) matches)\n    \
    \      ((member (first l1) l2)\n           (find-matches (rest l1) l2 (cons (first\
    \ l1) matches)))\n          (else (find-matches (rest l1) l2 matches))))\n  (sort\
    \ (find-matches l1 l2 (list)) <))\n", "  (set! l1 (remove-duplicates (sort l1\
    \ <)))\n  (set! l2 (remove-duplicates (sort l2 <)))\n  (cond [(empty? l1) empty]\n\
    \        [(empty? l2) empty]\n        [(eq? (first l1) (first l2))\n         (cons\
    \ (first l1) (common (rest l1) (rest l2)))]\n        [(< (first l1) (first l2))\
    \ (common (rest l1) l2)]\n        [else (common l1 (rest l2))]))\n", "  (let ([x\
    \ (set-intersection (set l1) (set l2))])\n    (cond [(empty? x) '()]\n       \
    \   [else (sort < x)])))\n```\n\n```python\n#!/usr/bin/env python\n# -*- coding:\
    \ utf-8 -*-\n\n# Return sorted unique common elements for two lists.\n# >>> common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
    \ 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2):\n    x = set(l1) & set(l2)\n\
    \    if not x:\n        return []\n    return sorted(x)\n```\n\n## One line solution\n\
    ```scheme\n#lang racket\n", "  (filter-map (lambda (x) (if (memq x l2) x #f))\
    \ l1))\n", "  (match (list l1 l2)\n    [(list l1 l2)\n     (cond\n       [(null?\
    \ l1) '()]\n       [(member (car l1) l2) (cons (car l1) (common (cdr l1) l2))]\n\
    \       [else (common (cdr l1) l2)])]))\n", "  (cond [(or (empty? l1) (empty?\
    \ l2)) empty]\n        [else (cond [(member (first l1) l2) (cons (first l1) (common\
    \ (rest l1) l2))]\n                    [else (common (rest l1) l2)])]))\n", " \
    \ (if (null? l1)\n      '()\n      (if (member (car l1) l2)\n          (cons (car\
    \ l1) (common (cdr l1) l2))\n          (common (cdr l1) l2))))\n", "  (sort (uniq\
    \ (intersect l1 l2)) <))\n", "  (filter (lambda (e) (member e l2)) (sort l1 <)))\n\
    ```\n\n## common_two\n\n```racket\n#lang racket\n", "  (remove-duplicates (sort\
    \ (intersection l1 l2) &lt;)))\n</code>\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) <))\n", "  (remove-duplicates\n   (sort (append l1 l2))\n   #:key (lambda\
    \ (a) a)))\n", "  (sort (remove-duplicates (append l1 l2)) #&lt;))\n", "  (cond\n\
    \    [(empty? l1) l2]\n    [(memq (first l1) l2) (cons (first l1) (common (rest\
    \ l1) l2))]\n    [else (common (rest l1) l2)]))\n", "  (define (common-helper\
    \ l1 l2)\n    (cond [(or (null? l1) (null? l2)) (list)]\n          [(and (not\
    \ (null? l1)) (not (null? l2)) (equal? (car l1) (car l2)))\n           (append\
    \ (list (car l1)) (common-helper (cdr l1) (cdr l2)))]\n          [(not (member\
    \ (car l1) l2)) (common-helper (cdr l1) l2)]\n          [(not (member (car l2)\
    \ l1)) (common-helper l1 (cdr l2))]))\n  (sort (common-helper l1 l2) <))\n", " \
    \ (sort (remove-duplicates (intersection l1 l2)) <))\n", "  (sort (remove-duplicates\
    \ (flatten (list l1 l2))) <))\n", "  (cond\n    [(empty? l1) empty]\n    [(empty?\
    \ l2) empty]\n    [(member (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n\
    \    [else (common (rest l1) l2)]))\n", "  (sort (remove-duplicates (append l1\
    \ l2)) <))\n", "  (sort (remove-duplicates (append l1 l2)) #:key identity))\n",
  "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort (remove-duplicates\
    \ (append l1 l2))\n        <))\n", "  (sort (unique (append l1 l2)) #:key identity))\n",
  "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (define (common-aux l1 l2\
    \ acc)\n    (cond [(empty? l1) acc]\n          [(empty? l2) acc]\n          [(member\
    \ (first l1) l2)\n           (common-aux (rest l1)\n                       l2\n\
    \                       (append (list (first l1)) acc))]\n          [else (common-aux\
    \ (rest l1) l2 acc)]))\n  (cond [(empty? l1) '()]\n        [(empty? l2) '()]\n\
    \        [else (common-aux l1 l2 '())]))\n", "  (define (helper l1 l2 acc)\n \
    \   (if (null? l1)\n        acc\n        (if (member (car l1) l2)\n          \
    \  (helper (cdr l1) l2 (cons (car l1) acc))\n            (helper (cdr l1) l2 acc))))\n\
    \  (sort (helper l1 l2 '()) <))\n", "  (let loop ([l1 l1] [l2 l2] [acc '()])\n\
    \    (if (empty? l1)\n        acc\n        (if (empty? l2)\n            acc\n\
    \            (let ([fst (first l1)])\n              (if (member fst l2)\n    \
    \              (if (member fst acc)\n                      (loop (rest l1) l2\
    \ acc)\n                      (loop (rest l1) l2 (cons fst acc)))\n          \
    \        (loop (rest l1) l2 acc)))))))\n", "  (define (helper l1 l2)\n    (if\
    \ (null? l1)\n        '()\n        (if (elem l2 (car l1))\n            (cons (car\
    \ l1) (helper (cdr l1) l2))\n            (helper (cdr l1) l2))))\n  (sort (helper\
    \ l1 l2) <))\n", "  (define s1 (sort l1))\n  (define s2 (sort l2))\n  (define\
    \ (loop res)\n    (if (or (null? s1) (null? s2))\n        res\n        (define\
    \ h1 (car s1))\n        (define h2 (car s2))\n        (cond\n          ((= h1\
    \ h2) (loop (cons h1 res)))\n          ((&lt; h1 h2) (loop res))\n          (else\
    \ (loop res)))))\n  (reverse (loop '())))\n</code>\nThanks!\n\n\nA:\n\nTo get\
    \ rid of the <code>reverse</code> call, you can use the following implementation\
    \ of <code>common</code>:\n<code>(define (common l1 l2)\n  (define s1 (sort l1))\n\
    \  (define s2 (sort l2))\n  (define (loop res)\n    (if (or (null? s1) (null?\
    \ s2))\n        res\n        (define h1 (car s1))\n        (define h2 (car s2))\n\
    \        (cond\n          ((= h1 h2) (loop (cons h1 res)))\n          ((&lt; h1\
    \ h2) (loop res))\n          (else (loop res)))))\n  (loop '()))\n</code>\nIf\
    \ you want to eliminate the <code>define</code>s of <code>s1</code> and <code>s2</code>,\
    \ you can use the following implementation:\n<code>(define (common l1 l2)\n  (define\
    \ (loop res s1 s2)\n    (if (or (null? s1) (null? s2))\n        res\n        (define\
    \ h1 (car s1))\n        (define h2 (car s2))\n        (cond\n          ((= h1\
    \ h2) (loop (cons h1 res) (cdr s1) (cdr s2)))\n          ((&lt; h1 h2) (loop res\
    \ (cdr s1) s2))\n          (else (loop res s1 (cdr s2))))))\n  (loop '() (sort\
    \ l1) (sort l2)))\n</code>\n", "  (sort (remove-duplicates (append l1 l2)) <))\n",
  "  (sort\n   (set-intersection\n    (set l1)\n    (set l2))\n   <))\n", "  (sort\
    \ (uniq (append l1 l2)) &lt;))\n", "  (cond [(empty? l1) empty]\n        [(member\
    \ (first l1) l2) (cons (first l1) (common (rest l1) l2))]\n        [else (common\
    \ (rest l1) l2)]))\n", "  (sort (delete-duplicates (intersection l1 l2)) <))\n",
  "  (sort (remove-duplicates (filter (lambda (x) (member x l2)) l1)) <))\n", "  (define\
    \ (inner l1 l2 al)\n    (cond\n      [(null? l1) al]\n      [(member (car l1)\
    \ l2) (inner (cdr l1) l2 (cons (car l1) al))]\n      [else (inner (cdr l1) l2\
    \ al)]))\n  (sort (inner l1 l2 '()) <))\n", "  (sort (remove-duplicates (append\
    \ l1 l2)) #&lt;))\n", "  (define (collect? x)\n    (and (member x l1) (member\
    \ x l2)))\n  (sort (remove-duplicates (filter collect? (append l1 l2))) &lt;))\n\
    </code>", "  (let ([common-elts (for/list ([el1 l1]\n                        \
    \        [el2 l2])\n                        (if (member el1 l2)\n            \
    \                el1))])\n    (apply sorted-merge (map quicksort (list common-elts)))))",
  "  (sort (uniq (intersect l1 l2))))\n", "  (sort (remove-duplicates (intersection\
    \ l1 l2)) <))\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", "  (sort\
    \ (remove-duplicates (append l1 l2)) <))\n```\n\n```racket\n#lang racket\n", " \
    \ (sort (remove-duplicates (intersection l1 l2)) <))\n", "  (define (helper l1\
    \ l2)\n    (cond\n      [(or (empty? l1) (empty? l2)) (list)]\n      [(equal?\
    \ (first l1) (first l2)) (cons (first l1) (helper (rest l1) (rest l2)))]\n   \
    \   [(< (first l1) (first l2)) (helper (rest l1) l2)]\n      [else (helper l1\
    \ (rest l2))]))\n  (helper (sort l1) (sort l2)))\n```\n\n```python\ndef common(a,\
    \ b):\n    la, lb = len(a), len(b)\n    i, j = 0, 0\n    result = []\n    while\
    \ i < la and j < lb:\n        ai, bj = a[i], b[j]\n        if ai == bj:\n    \
    \        result.append(ai)\n            i += 1\n            j += 1\n        elif\
    \ ai < bj:\n            i += 1\n        else:\n            j += 1\n    return\
    \ result\n```\n\n### \u96BE\u5EA6\u7CFB\u6570\n\n```\ndef difficulty_rating\n\
    \  3\nend\n```\n\n---\n\n## Remove all elements from a linked list of integers\
    \ that have value val.\n\nExample\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 -->\
    \ 6, val = 6\nReturn: 1 --> 2 --> 3 --> 4 --> 5\n\n```ruby\nclass Node\n  attr_accessor\
    \ :val, :next\n\n  def initialize(val)\n    @val = val\n    @next = nil\n  end\n\
    end\n\ndef remove_elements(head, val)\n  return nil if head.nil?\n  return remove_elements(head.next,\
    \ val) if head.val == val\n  head.next = remove_elements(head.next, val)\n  head\n\
    end\n```\n\n```javascript\nvar removeElements = function(head, val) {\n  if (head\
    \ === null) return null;\n  head.next = removeElements(head.next, val);\n  return\
    \ head.val === val ? head.next : head;\n", "  (sort\n   (delete-duplicates\n \
    \   (intersection l1 l2))\n   <))\n", "  (sort (remv-dups (append l1 l2)) <))\n\
    \n", "  (sort (removedup (append l1 l2)) <))\n", "  (define l1-sorted (remove-duplicates\
    \ (sort l1 <)))\n  (define l2-sorted (remove-duplicates (sort l2 <)))\n  (define\
    \ result (list))\n  (define i 0)\n  (define j 0)\n  (while (< i (length l1-sorted))\n\
    \    (cond [(= (list-ref l1-sorted i) (list-ref l2-sorted j))\n           (append!\
    \ result (list (list-ref l1-sorted i)))\n           (set! i (+ i 1))\n       \
    \    (set! j (+ j 1))]\n          [(&lt; (list-ref l1-sorted i) (list-ref l2-sorted\
    \ j))\n           (set! i (+ i 1))]\n          [else\n           (set! j (+ j\
    \ 1))]))\n  result)\n", "  (sort (remove-duplicates (append l1 l2)) <))\n", " \
    \ (let ([res (list)])\n    (for ([x l1])\n      (for ([y l2])\n        (when (equal?\
    \ x y)\n          (push x res))))\n    (delete-duplicates (sort res &lt;))))\n\
    </code>\n", '  (set-union (sort l1 <) (sort l2 <)))', "  (sort (hash-intersection\
    \ (list->hash l1) (list->hash l2)) <))\n", "  (cond ((and (empty? l1) (empty?\
    \ l2)) empty)\n        ((and (empty? l1) (not (empty? l2))) l2)\n        ((and\
    \ (not (empty? l1)) (empty? l2)) l1)\n        ((and (not (empty? l1)) (not (empty?\
    \ l2)))\n         (cond ((memq (car l1) l2) (cons (car l1) (common (cdr l1) l2)))\n\
    \               (else (common (cdr l1) l2))))))\n", "  (sort (cond [(null? l1)\
    \ '()]\n              [(null? l2) '()]\n              [(= (car l1) (car l2)) (cons\
    \ (car l1) (common (cdr l1) (cdr l2)))]\n              [(< (car l1) (car l2))\
    \ (common (cdr l1) l2)]\n              [else (common l1 (cdr l2))]) <))\n", " \
    \ (sort (uniq (filter (curry list-member? l1) l2)) &lt;=))\n", "  (sort (distinct\
    \ (append l1 l2)) #&lt;))\n", "  (sort (remove-duplicates (append l1 l2)) (lambda\
    \ (x y) (< x y))))\n", "  (sort (set-intersection eq? (set l1) (set l2)) <))\n",
  "  (sort (remove-duplicates (intersection l1 l2)) <))\n", "  (sort\n   (remq* (set-intersection\
    \ (set l1) (set l2))\n          (append l1 l2))\n   <))\n```\n\n```Racket\n#lang\
    \ racket\n", "  (sort (filter (lambda (x) (member x l1)) l2) <))\n\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
