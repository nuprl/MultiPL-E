name: HumanEval_119_match_parens
language: rkt
prompt: "#lang racket\n\n;; You are given a list of two strings, both strings consist\
  \ of open\n;; parentheses '(' or close parentheses ')' only.\n;; Your job is to\
  \ check if it is possible to concatenate the two strings in\n;; some order, that\
  \ the resulting string will be good.\n;; A string S is considered to be good if\
  \ and only if all parentheses in S\n;; are balanced. For example: the string '(())()'\
  \ is good, while the string\n;; '())' is not.\n;; Return 'Yes' if there's a way\
  \ to make a good string, and return 'No' otherwise.\n;; Examples:\n;; match_parens(['()(',\
  \ ')']) == 'Yes'\n;; match_parens([')', ')']) == 'No'\n(define (match_parens lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate match_parens))\n\
  \    (check-equal? (candidate (list \"()(\" \")\")) \"Yes\")\n    (check-equal?\
  \ (candidate (list \")\" \")\")) \"No\")\n    (check-equal? (candidate (list \"\
  (()(())\" \"())())\")) \"No\")\n    (check-equal? (candidate (list \")())\" \"(()()(\"\
  )) \"Yes\")\n    (check-equal? (candidate (list \"(())))\" \"(()())((\")) \"Yes\"\
  )\n    (check-equal? (candidate (list \"()\" \"())\")) \"No\")\n    (check-equal?\
  \ (candidate (list \"(()(\" \"()))()\")) \"Yes\")\n    (check-equal? (candidate\
  \ (list \"((((\" \"((())\")) \"No\")\n    (check-equal? (candidate (list \")(()\"\
  \ \"(()(\")) \"No\")\n    (check-equal? (candidate (list \")(\" \")(\")) \"No\"\
  )\n    (check-equal? (candidate (list \"(\" \")\")) \"Yes\")\n    (check-equal?\
  \ (candidate (list \")\" \"(\")) \"Yes\")\n))\n\n(test-humaneval)"
completions: []
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
