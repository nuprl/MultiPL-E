name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n;; >>> (circular_shift 12 1)\n;; \"21\"\n\
  ;; >>> (circular_shift 12 2)\n;; \"12\"\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (if (< shift (length x))\n      (cons (substring x 0 (- shift (length\
    \ x))) \n            (circular_shift (substring x (length x) shift) shift))\n\
    \      (substring x 0 (- shift (length x)))))\n", "  (define (shift_digits x shift\
    \ acc)\n    (cond\n      [(< shift (length acc)) (shift_digits x (- shift (length\
    \ acc)) (append acc (list x)))]\n      [(= shift 0) (append acc (list x))]\n \
    \     [(> shift 0) (shift_digits x (- shift (length acc)) (cons (% x 10) (append\
    \ acc (list (quotient x 10))))))]\n      [(> shift (length acc)) (shift_digits\
    \ x (- shift (length acc)) (cons (% x 10) acc))]\n      [else (shift_digits x\
    \ (- shift (length acc)) acc)]))\n  (shift_digits x (- shift (length x)) (list\
    \ x)))\n", "  (let ([digits (string-length x)])\n    (cond\n      [(> digits shift)\
    \ x]\n      [else (list->string\n             (append (subseq x 0 (- digits shift))\n\
    \                    (subseq x (+ shift digits) (+ shift digits)))]\n        \
    \     )])\n  )\n", "  (if (< shift (length x))\n      (let ([shift (- shift (length\
    \ x))])\n        (string-append (string-ref x shift) (string-ref x (+ shift 1))))\n\
    \      (string-reverse x)))\n", "  (let loop ([n x] [d '()])\n    (cond\n    \
    \  [(< shift (length n)) (cons (reverse d) (reverse (loop (sub1 n) (d))))]\n \
    \     [else (loop (sub1 n) (append d (list (modulo n 10))))]))\n</code>\n<|/ a\
    \ |>\n<| a tags=scheme,racket,functional-programming |>\nTo do it for 3 digit\
    \ integers, you can do\n<code>", "  (define (shift_string start end)\n    (if\
    \ (< end start) (substring x start end) (substring x (- start end) (- end start))))\n\
    \  (let loop ((n x) (shift shift))\n    (if (zero? shift)\n        (shift_string\
    \ 0 (- n shift))\n        (if (< n 0)\n            (shift_string 0 (- n shift))\n\
    \            (loop (- n shift) (- shift 1))))))\n</cell>\n<code language=racket-language>",
  "  (cond\n    [(zero? x) (let ([digits (reverse (digit-rev (digit-x x)))])\n   \
    \               (if (= shift 0)\n                      (number->string digits)\n\
    \                      (concat (reverse (number->string digits)) (number->string\
    \ (sub1 digits (+ shift 1))))))]\n    [(>= shift (digit-count x))\n     (let ([digits\
    \ (digit-rev (digit-x x))])\n       (if (= shift 0)\n           (number->string\
    \ digits)\n           (concat (reverse (number->string digits)) (number->string\
    \ (sub1 digits (+ shift 1))))))]\n    [else (error (char->string #\\newline)\n\
    \            (char->string #\\space (- shift (digit-count x)))))]))\n", "  (let\
    \ loop ((n x) (c '()))\n    (if (< shift (length n))\n        (loop (substring\
    \ n 0 (- (length n) shift)) (concat c n))\n        (reverse c))))\n</cell>\n<text>\n\
    Exercises\n1. Write a function called count_digits which takes a positive integer\
    \ and returns how many digits it has. \nWrite a test function for count_digits,\
    \ passing in a few different test cases, and print the results. Try calling the\
    \ function with both positive and negative integers.\n\n\n</text>\n<cell>", " \
    \ (if (zero? shift)\n      '()\n      (let ((result (make-string (string-length\
    \ x))))\n        (string-set! result 0 (string-length x)\n                   \
    \    (string-ref x 0)\n                       (string->number (string-reverse\
    \ result))\n                       (+ shift (string-length result))))))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nHi , thank you for your answer. Do you know how I\
    \ can implement this in scheme/racket?\n<|/ c |>\n<| c |>\nI have updated my answer.\
    \ I'm not a Scheme expert, so there might be a better way.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n (define (circular_shift x) (cond \n    ((= x 0) '())\n    ((< x\
    \ 10) \n     (if (= (quotient x 10) 0) (cons x 0) \n         (cons (+ (modulo\
    \ x 10) (quotient x 10)) (circular_shift (quotient x 10)))))\n    ((= (quotient\
    \ x 10) 0) \n     (cons (modulo x 10) \n           (circular_shift (quotient x\
    \ 10))))\n    (else (cons (modulo x 10) (circular_shift (quotient x 10))))))\n\
    </code>\n<|/ a tags=scheme,racket,circular-list |>\n<| c |>\nWhile this code snippet\
    \ may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (if\
    \ (< shift (length x))\n      (cons x (circular_shift (sub1 x) (add1 shift)))\n\
    \      (cons (reverse x)\n            (circular_shift (reverse (sub1 x)) (add1\
    \ shift))))))\n", "  (let ((len (length x)))\n    (if (< shift len)\n        (string-reverse\
    \ (take-right x len))\n        (string-reverse (take-left (take-right x len) shift)))))\
    \ ;; #lang racket\n", "  (cond ((< shift (number->digits-of-number x))\n     \
    \    (string->number\n          (string->chars (digits-to-string (remainder (remainder\
    \ x 10)\n                                                 (modulo (+ shift 1)\n\
    \                                                       10)\n                \
    \                                 )))))\n        ((< shift (number->digits-of-number\
    \ x))\n         (string->number\n          (string->chars (digits-to-string (remainder\
    \ (remainder x (modulo x 10))\n                                              \
    \   (modulo (+ shift 1)\n                                                    \
    \   10)\n                                                 )))))\n        (else\n\
    \         (string->number\n          (string->chars (digits-to-string (modulo\
    \ (+ shift 1)\n                                                 (remainder x (modulo\
    \ x 10))\n                                                 )))))\n        (else\n\
    \         (error \"Invalid shift ~d.\" shift)))\n", "  (if (or (< shift 0)\n \
    \         (< shift (length x)))\n      (cond [(< shift 0)\n               (list\
    \ x '())]\n            [(< shift 1)\n             list((substring x 0 shift) '())]\n\
    \            [else\n             (list x\n                  (substring x (+ shift\
    \ (length x))\n                            (length x))]))\n      (cond [(< shift\
    \ 0)\n               (list '() '())]\n            [(< shift 1)\n             (cons\
    \ (substring x 0 (- shift (length x))) '())]\n            [else\n            \
    \ (cons (substring x (+ shift (length x))\n                              (- shift\
    \ (length x)))\n                  (circular_shift x (- shift (length x))))])))\n",
  "  (cond ((> shift (length x)) (reverse (list-ref x shift)))\n        (else (list-ref\
    \ x (- shift (length x))))))\n", "  (if (= shift 0)\n      (list-ref x 0)\n  \
    \    (cons (string-append (circular_shift (list-ref x shift) (- shift 1))\n  \
    \                       (string-append (list-ref x shift) \"\")))))\n", "  (let\
    \ loop ((x x) (r '())\n             (shift shift))\n    (if (< shift (length x))\n\
    \        (loop (digit-rev (char->int (car x))) (rest x) (- shift 1))\n       \
    \ r)))", "  (cond [(< shift (length x))\n         (string-reverse (string-append\
    \ (take-digits x (- shift (length x)))))]\n        [else\n         (string-append\
    \ (take-digits x (- shift (length x)))\n                        (take-digits x\
    \ (+ shift (length x))))]))\n", "  (cond [(< shift (length x))\n         x]\n\
    \        [(= shift 0)\n         x]\n        [else\n         (cons (mod x (expt\
    \ 10 shift)) (circular_shift (quotient x 10) shift))]))\n", "  (if (zero? shift)\n\
    \      '()\n      (let ([digits '(()())])\n        (cond\n          ((zero? (car\
    \ x))\n           (cond\n             ((equal? (remainder x 10) 0)\n         \
    \     (append (digits (list 0 (remainder x 10))))\n             (else\n      \
    \        (append (digits (list 1 (remainder x 10))))\n             ))\n      \
    \     ((zero? (cdr x))\n            (cond\n              ((equal? (remainder x\
    \ 10) 0)\n               (append (digits (list 2 (remainder x 10))))\n       \
    \        (else\n                (append (digits (list 3 (remainder x 10))))\n\
    \               ))\n           (else\n            (append (digits (list 4 (remainder\
    \ x 10))))\n            )))\n         (cond\n           ((< shift (length digits))\n\
    \            (let ([left (car x)])\n              (cond\n                ((zero?\
    \ (car digits))\n                 (append (digits (list left (car x))))\n    \
    \             (else\n                  (append (digits (list (- left shift))))\n\
    \                  ))\n              (else\n                (append (digits (list\
    \ left))\n                         (circular_shift (- left shift) shift)\n   \
    \                      )\n                ))\n           (else\n            (append\
    \ (digits (list (car x))))\n            (circular_shift (cdr x) shift)\n     \
    \       )))\n        )))\n", "  (if (zero? x)\n      (make-string x '#\\0)\n \
    \     (let ((digits (cycle x)))\n        (string->list digits)\n        (let ((result\
    \ (make-string (car digits) '#\\0)))\n          (let ((shift (cdr shift)))\n \
    \           (if (< shift (length digits))\n                ;; If shift > number\
    \ of digits, return digits reversed.\n                (set! x (- (- (car (last\
    \ digits)) shift))\n                      (append\n                       (string->list\
    \ digits)\n                       (string->list (reverse (digits)))))\n      \
    \          (begin\n                  (set! x (- (- (car (last digits)) shift))\n\
    \                         (append\n                         (string->list digits)\n\
    \                         (string->list (reverse (digits)))))\n              \
    \    result)))\n          (set! x (- (- (car (last digits)) shift))\n        \
    \        (car digits)\n                (append\n                 result\n    \
    \             (string->list digits))))))\n", "  (let ([m (quotient x 10)] \n \
    \       [res (string->list \"\")]\n        [s (string->list \"\")]\n        [shift\
    \ (- shift 1)])\n    (if (= shift 0)\n        (reverse res)\n        (if (= m\
    \ 0)\n            (reverse s)\n            (let ([c (char->integer x)]\n     \
    \             [s (string->list \"\")]\n                  [res (string->list \"\
    \")])\n              (if (< c 10)\n                  (reverse res)\n         \
    \         (let ([i (floor (/ c 10))])\n                    (if (= i 0)\n     \
    \                   (reverse s)\n                        (set! s (string->list\
    \ \"\"))\n                        (set! m (quotient i 10))\n                 \
    \       (set! i (- i 1))\n                        (set! res (string->list \"\"\
    ))\n                        (set! s (list->string (* 10 i)))\n               \
    \         (set! m (quotient i 10))\n                        (set! i (- i 1))\n\
    \                        (set! res (string->list \"\" s res)))\n             \
    \       (if (= i 0)\n                        (set! s (list->string c))\n     \
    \                   (set! m (quotient i 10))\n                        (set! i\
    \ (- i 1))\n                        (set! res (string->list \"\" s res)))\n  \
    \                  (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set! i (- i 1))\n                        (set! res (string->list \"\" s\
    \ res)))\n                    (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set! i (- i 1))\n                        (set! res (string->list \"\" s\
    \ res)))\n                    (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set! i (- i 1))\n                        (set! res (string->list \"\" s\
    \ res)))\n                    (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set! i (- i 1))\n                        (set! res (string->list \"\" s\
    \ res)))\n                    (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set! i (- i 1))\n                        (set! res (string->list \"\" s\
    \ res)))\n                    (if (= i 0)\n                        (set! s (list->string\
    \ c))\n                        (set! m (quotient i 10))\n                    \
    \    (set", "  (let loop ((x (mod x 10)) (shift (- shift 1))\n             (str\
    \ (cons x (string-append (make-string (1- shift) '#\\0))))\n             (count\
    \ (- shift 1))\n             (ret (cons (char->int (first str)) ret)))\n    (if\
    \ (< shift (- length (string->list str)))\n        (loop (first str) (- shift\
    \ 1) str count ret)\n        (loop (first str) shift str count ret)))\n", "  (define\
    \ (shift_digits x shift)\n    (cond\n      [(= (modulo x 10) (modulo x (+ shift\
    \ 1)))\n       (digits-of-number x)\n       ;; Return digits reversed\n      \
    \ ]\n      [(< shift (digits-of-number x))\n       ;; Shift right\n       (let*\
    \ ((digits (digits-of-number x))\n               (new_digits (subseq digits 0\
    \ shift))\n               (x (- x shift)))\n         new_digits)\n       ;; Shift\
    \ left\n       (let* ((digits (digits-of-number x))\n               (new_digits\
    \ (subseq digits shift (+ shift 1)))\n               (x (+ x shift)))\n      \
    \   new_digits)\n      ]\n      [else\n       (digits-of-number x)\n       ]))\n\
    \  (let* ((digits (digits-of-number x))\n         (new_digits '()))\n    (cond\n\
    \      [(< shift (length digits))\n       (let* ((new_digits (shift_digits digits\
    \ shift))\n               (x (- x shift)))\n         new_digits)\n      ]\n  \
    \    [else\n       (append new_digits (reverse digits))\n       ]))\n  )\n", " \
    \ (cond\n    [(> shift (length x))\n      (let [res (reverse (take x shift))]\n\
    \        (cond\n          [(< shift (length x))\n           res]\n          [else\n\
    \           (cons (- shift (length res)) res)]\n          ))]\n    [else\n   \
    \   (take x shift)]\n    )\n  )", "  (cond [(< shift (length x))\n         (string-append\
    \ (substring x 0 shift) (substring x shift))\n         (string-append (substring\
    \ x shift) (substring x 0))]\n        [(eq? shift 0)\n         (string-append\
    \ (substring x 0 shift) \"\")]\n        [else\n         (string-append (substring\
    \ x 0 shift) (substring x 0))]))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (cond ((= shift 0) (list-reverse digits))\n          ((> shift (length\
    \ digits)) (list-reverse digits))\n          (else (loop (quotient x 10) (quotient\
    \ shift 10))\n                (set! digits (append (substring digits 0 (- (length\
    \ digits) shift))\n                                   (list digit)))\n       \
    \         (recur x (substring shift (length digits))))))))\n", "  (let loop ((x\
    \ x) (shift shift))\n    (cond ((zero? shift) (string-reverse (string-append (number->string\
    \ x) (number->string shift))))\n          ((= shift (quotient x 10)) (number->string\
    \ (cons shift x)))\n          ((zero? (remainder x 10)) (loop (quotient x 10)\
    \ (- shift 1)))\n          ((< shift (quotient x 10)) (loop (quotient x 10) (+\
    \ shift 1)))\n          (else (loop (quotient x 10) shift))))\n  x)\n", "  (define\
    \ (helper)\n    (cond\n      [(zero? shift) \"\"]\n      [(zero? (remainder x\
    \ 10)) (helper (remainder x 10))]\n      [else (helper (quotient x 10) (sub1 shift))]))\n\
    \  (helper (quotient x 10) (sub1 shift)))\n</cell>\n<text>\nTests\nWe can now\
    \ test our implementations with some example inputs.\n\n\n</text>\n<cell>", " \
    \ (let* ([d (length x)]\n         [msb-d (floor d 8)]\n         [rem-d (- d (*\
    \ msb-d 8))]\n         [msb (bitwise-and x 255)])\n    (let ([digit-count (floor\
    \ (+ shift rem-d)) ])\n      (cond\n        ((>= digit-count 0) \"\")\n      \
    \  ((zero? (modulo x 1000))\n         (cond\n           ((zero? (modulo msb 1000))\n\
    \            (string-append (bitwise-and (modulo msb 10000000) (- shift 8)) \"\
    .\"))\n           ((zero? (modulo msb 100))\n            (string-append (bitwise-and\
    \ (modulo msb 10000000) (- shift 8)) \".\"))\n           ((zero? (modulo msb 10))\n\
    \            (string-append (bitwise-and (modulo msb 10000000) (- shift 8)) \"\
    .\"))\n           ((zero? (modulo msb 1))\n            (string-append (bitwise-and\
    \ (modulo msb 10000000) (- shift 8)) \".\"))\n           ((zero? (modulo msb 0))\n\
    \            (string-append (bitwise-and (modulo msb 10000000) (- shift 8)) \"\
    .\"))\n           (else\n            (string-append (bitwise-and (modulo msb 10000000)\
    \ (- shift 8)) \".\"))))))\n    (cond\n      ((or (zero? rem-d) d)\n       (string-append\
    \ x \"\"))\n      ((or (< shift shift) digit-count)\n       (let* ([digits (string-split\
    \ (number->string x) \"d\")]\n              [left-digits (take (- digit-count)\
    \ digits)]\n              [right-digits (drop (- digit-count) digits)])\n    \
    \     (let* ([left (take (- digit-count) left-digits)]\n                [right\
    \ (drop (- digit-count) right-digits)])\n           (cond\n             ((= digit-count\
    \ 0) \"\")\n             ((zero? (modulo right 1000))\n              (string-append\
    \ (bitwise-and (modulo right 10000000) (- shift 8)) \".\"))\n             ((zero?\
    \ (modulo right 100))\n              (string-append (bitwise-and (modulo right\
    \ 10000000) (- shift 8)) \".\"))\n             ((zero? (modulo right 10))\n  \
    \            (string-append (bitwise-and (modulo right 10000000) (- shift 8))\
    \ \".\"))\n             ((zero? (modulo right 1))\n              (string-append\
    \ (bitwise-and (modulo right 1000000", "  (let* ((length (length x))\n       \
    \  (carry (modulo-arithmetic-product x length shift)))\n    (cond [(> shift length)\n\
    \           (number->string (list->vector (reverse x)))]\n          [else\n  \
    \         (string->number x (+ shift length) carry \"0\")])))\n", "  (cond\n \
    \   ((< shift (length x))\n     (reverse (take (- shift (length x)) x)))\n   \
    \ ((< shift 0)\n     (list x))\n    ((= shift (length x))\n     (reverse x))\n\
    \    ((= shift 0)\n     (list x))\n    (else (cons (car x) (circular_shift (cdr\
    \ x) shift))))))\n", "  (cond\n    ((< shift (- 3 (length x)))\n     (string-append\
    \ (substring x 0 (+ shift (length x))) \"0\")))\n    (else\n     (string-append\
    \ (substring x (+ shift 1) (+ shift (length x)))\n                    (substring\
    \ x 0 (+ shift (- shift 1))))))\n", "  (cond\n    [(> shift (- x (digits (- x\
    \ 1)))) (list-reverse (list-copy (digits x))\n                               \
    \  (+ shift (digits (- x 1))))]\n    [else (list-copy (list-copy (digits x))\n\
    \                     (+ shift (digits (- x 1)))]\n    [else (error \"not implemented\"\
    )]))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe code from John Lindsay\
    \ was very helpful. Here is a solution that uses the built in lists rather than\
    \ a custom function. In addition, it's possible to reverse the list by reversing\
    \ the tail.\n<code>", "  (let loop ([n x]\n             [result '()])\n    (if\
    \ (zero? n)\n        result\n        (loop (quotient n 10)\n              (cons\
    \ n\n                    (cons result '())))\n        (loop (quotient n 10)\n\
    \              result))))\n", "  (let ([count (length x)])\n    (cond [(= count\
    \ 0) \"\"]\n          [(> count shift) (cond [(eq? count 1) (append (list (car\
    \ x)) (list (cdr x)))]\n                                   [(eq? count (- shift\
    \ 1)) (cond [(eq? (car x) '()) (append (cdr x) (list (car x)))]\n            \
    \                               [else (cons x (list (car x))) ]))]\n         \
    \ [(< count shift) (cond [(eq? count (- shift 1)) (cdr x)]\n                 \
    \                  [else (cons (car x) (cdr x)) ]))]))))\n", "  (let loop ((x\
    \ x) (shift shift))\n    (cond\n      [(< shift (- x 10)) (cons (mod x 10) '())]\n\
    \      [(zero? x) (cons 0 (reverse (cons x (reverse '()))))]\n      [else (cons\
    \ x (loop x (- shift 1)))])))\n", "  (let ((digits x))\n    (cond ((= shift 0)\
    \ digits)\n          ((> (% shift 10) 0) (circular_shift (/ digits 10) (- shift\
    \ 1)))\n          ((= shift 1) (append (reverse digits) '()))\n          (else\
    \ (append (circular_shift (/ digits 10) (- shift 1)) (list (% shift 10)))))))\n",
  "  (if (> shift (length x))\n      (let ([left (substr x 0 (+ shift (length x)))])\n\
    \        (reverse (cons left (circular_shift left (- shift 1)))))\n      (cons\
    \ (char (modulo x 10)) (circular_shift (/ x 10) shift))))\n", "  (let loop ([x\
    \ x] [shift shift])\n    (cond ((<= shift (length x)) (reverse x))\n         \
    \ ((not (= x (zero? (remainder x 10)))) (loop (quotient x 10) shift))\n      \
    \    (else (loop (quotient x (remainder x 10)) (- shift 1))))))\n", "  (letrec\n\
    \    ([helper (lambda (x) (first x))]\n     (define (helper x)\n       (if (zerop\
    \ x)\n           \"\"\n           (+ (first (quotient x 10))\n              (helper\
    \ (quotient x 10)))))\n     (helper x)))\n", "  (cond [(< shift (length x))\n\
    \         (string-append (string-reverse (string x))\n                       \
    \ (substring x 0 (- shift (length x))))]\n        [else (cons x (circular_shift\
    \ (string x) shift))]))\n", "  (define (helper)\n    (cond\n      [(or (= shift\
    \ 0) (= x 0)) \"\"]\n      [else (append (helper (- shift (modulo x 10)))\n  \
    \                  (reverse (modulo x 10)))]))\n  (helper))\n", "  (let loop ([i\
    \ x]\n             [result '()])\n    (cond\n      [(= i 0) (append result (list\
    \ '0))]\n      [(< i 0) (append result (list '0))]\n      [else (loop (quotient\
    \ i 10)\n                (cons ((quotient i 10) (car (cdr result))) result))])))\n",
  "  (cond [(< shift (length x))\n         string-reverse (string-chars (string-to-int-x\
    \ (string-slice x 0 shift)))]\n        [else\n         (string-chars (string-to-int-x\
    \ (string-slice x (+ shift (length x)))))]\n        )\n)\n", "  (let loop ((result\
    \ #\"\")\n             (x (string->number x)) (shift (if (< shift (length x))\
    \ shift (length x))) (length x))\n    (if (< shift 0)\n        result\n      \
    \  (loop (substring result 0 shift) (floor x) (- shift 1)))\n    (loop (reverse\
    \ (substring result 0 shift)) (floor x) shift (- shift 1))))\n", "  (let loop\
    \ ((x x) (shift shift) (digits '()))\n    (if (zerop shift)\n        (reverse\
    \ digits)\n        (let ((result (make-string (- (length digits) shift) (digit-char)))\n\
    \              (len (length digits)) (i 0))\n          (loop (remainder-with-precision\
    \ (quotient x 10) 10) shift \n                (+ i 1)\n                (+ len\
    \ i)\n                (set! digits (append (substring digits i len) \n       \
    \                           (substring digits 0 i))))\n          (set! result\
    \ (format #t \"~S\" result))\n          (set! digits (append (substring digits\
    \ i len) \n                            (substring digits 0 i))))\n        (loop\
    \ (remainder x 10) shift 0 0\n               (set! result (format #t \"~S\" result))\n\
    \               (set! digits result)))))\n", "  (cond [(= shift 0)\n         (reverse\
    \ (modulo x 10)))\n         (zero? (modulo x 10))]\n        [else\n         (cond\
    \ [(< shift (length (modulo x 10)))\n                (append (modulo x 10)\n \
    \                       (circular_shift (* x 10) shift))\n                (zero?\
    \ (modulo x 10))]\n               [else\n                (append (circular_shift\
    \ (* x 10) shift)\n                        (modulo x 10)))]]))\n", "  (cond [(zero?\
    \ x) (cons \"0\" '())]\n        [(= shift (length x))\n         (string-reverse\
    \ (digits-to x (- shift (length x))))]\n        [else\n         (string-append\
    \ (digits-to x (- shift (length x)))\n                         (circular_shift\
    \ (modulo x 10) shift))]))\n", "  (let ([len (length x)]\n        [n (modulo x\
    \ 10)]\n        [m (modulo (- n 1) 10)]\n        [s (- n shift)]\n        [d (remainder\
    \ x 10)])\n    (if (= s 0)\n        (cons d x)\n        (let ([d (if (= shift\
    \ 0) (cons d '()) (cons d '()) (cons d '()))]\n              [m (if (< shift len)\
    \ (+ m 1) m)])\n          (cond [(> shift len) (cons d x)]\n                [else\
    \ (cond [(< m 1) (cons d '())]\n                           [(< m len) (cons d\
    \ '())]\n                           [else (cond [(< (- m len) shift) (cons d '())]\n\
    \                                      [(< (- m (- m len)) shift) (cons d '())]\n\
    \                                      [(< (- m (- m (- m len))) shift) (cons\
    \ d '())]\n                                      [(< (- m (- m (- m (- m len))))\
    \ shift) (cons d '())]\n                                      [(< (- m (- m (-\
    \ m (- m (- m len))))) shift) (cons d '())]\n                                \
    \      [(< (- m (- m (- m (- m (- m (- m len))))) shift) (cons d '())]\n     \
    \                                 [(< (- m (- m (- m (- m (- m (- m (- m len)))))\
    \ shift) (cons d '())]\n                                      [(< (- m (- m (-\
    \ m (- m (- m (- m (- m (- m (- m len))))) shift) (cons d '())]\n            \
    \                          [(< (- m (- m (- m (- m (- m (- m (- m (- m (- m (-\
    \ m (- m len))))) shift) (cons d '())]\n                                     \
    \ [(< (- m (- m (- m (- m (- m (- m (- m (- m (- m (- m (- m (- m len))))) shift)\
    \ (cons d '())]\n                                      [(< (- m (- m (- m (- m\
    \ (- m (- m (- m (- m (- m (- m (- m (- m (- m len))))", "  (let loop ((x x) (shift\
    \ shift) (s 0))\n    (cond\n      [(or (= shift 0) (= shift (length x)))\n   \
    \    (reverse (list x))]\n      [(= shift 0)\n       (reverse (list x))]\n   \
    \   [else\n       (loop (quotient x 10) (quotient shift 10))\n       (loop (quotient\
    \ x (remainder shift 10)) (- shift 1))])))", "  (let loop ((x x) (shift shift)\
    \ (s 0) (s 0))\n    (cond ((< shift (length x))\n           (string-reverse (list\
    \ x)))\n          ((even? shift) (cond ((even? s)\n                          \
    \     (string-append (list x) \"0\"))\n                              (else (string-append\
    \ (list x) \"0\"))))\n          ((odd? shift) (cond ((odd? s)\n              \
    \                 (string-append (list x) \"1\"))\n                          \
    \    (else (string-append (list x) \"0\"))))\n          (else (loop (string-append\
    \ (list x) (reverse (digit-chars (- x s))))\n                     (+ s 1) (+ shift\
    \ (length (digit-chars (- x s)))))))) ))\n</code>\n<code>\n#lang racket", "  (define\
    \ (shift_digits x shift)\n    (string->list\n     (let ((digits (string->list\
    \ x)))\n       (if (= shift 0)\n           (reverse digits)\n           (shift_digits\
    \ ((first digits) (add1 shift)) (sub1 shift)))))\n  (shift_digits x (- shift (length\
    \ x))))\n", "  (if (< shift (- x))\n      (cons (mod x 10) (reverse-string (circular_shift\
    \ (quotient x 10) shift))\n           (circular_shift (quotient x 10) shift))\n\
    \      (cons (mod x 10) (circular_shift (quotient x 10) shift)))) ; else x\n</code>\n\
    <|/ a dscore=1 tags=recursion,scheme,racket,list |>\n<| c |>\nI didn't know about\
    \ `reverse-string-tail`, very helpful.  However, I cannot get your `circular_shift`\
    \ function working...\n\n> > (circular_shift 12 1)", "  (cond [(zero? x) (list\
    \ '())]\n        [(or (= shift 0) (= shift (length x)))\n           (reverse (list\
    \ x))]\n        [(or (= shift 0) (< shift (length x)))\n           (append (list\
    \ (modulo (modulo x 10) (expt 2 shift)))\n                   (circular_shift (modulo\
    \ x 10) (sub1 shift)))]\n        [else\n          (append (list (modulo (modulo\
    \ x 10) (expt 2 shift)))\n                   (circular_shift (modulo x 10) (sub1\
    \ shift)))]))\n", "  (define (shift x shift) (mod x shift))\n  (define (digits\
    \ x) (quotient x 10))\n  (define (reverse x) (mod x 10))\n  (define (shift x shift)\
    \ (quotient x 10))\n  (define (shift x shift) (mod x shift))\n  (define (shift\
    \ x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n  (define\
    \ (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n \
    \ (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))\n\
    \  (define (shift x shift) (mod x shift))\n  (define (shift x shift) (mod x shift))",
  "  (cond\n    [(= shift 0) x]\n    [(>= shift (length (modulo x 10)) 0)\n     (cons\
    \ (modulo x 10) '())]\n    [else\n     (let ([res (quotient x 10)]\n         \
    \  [shift (- shift 1)])\n       (cond\n         [(= shift 0) res]\n         [(and\
    \ (= shift (- shift 1))\n              (eql (modulo x 10) (modulo (+ res 1) 10))\n\
    \              (= (length (modulo x 10)) (length (modulo (+ res 1) 10)))\n   \
    \          (circular_shift (rest x) shift)]\n         [(not (= shift 0)) (reverse\
    \ (circular_shift (rest x) shift))]\n         [else (cons (modulo x 10) (reverse\
    \ (circular_shift (rest x) shift)))]))]))\n", "  (if (< shift (length x))\n  \
    \    (append (substring x 0 (- (length x) (* shift (length x))))\n           \
    \   (substring x (- (* shift (length x)) (* shift (length x)))\n             \
    \           (+ (* shift (length x)) (length x))\n                        )\n \
    \             )\n      (substring x 0 (+ (* shift (length x)) (* shift (length\
    \ x)))))\n)\n", "  (cond\n    [(< shift (length x))\n     x (reverse x)]\n   \
    \ [else\n     (append x (reverse (take (+ shift (length x)) x)))))\n", "  (if\
    \ (zero? shift)\n      '()\n      (if (= (- shift (floor shift)) (floor (abs x)))\n\
    \          (cons (mod x 10) (circular_shift (/ x 10) (- shift 1)))\n         \
    \ (cons (modulo a 10) (reverse\n                             (circular_shift (/\
    \ x 10) (- shift 1))))))))\n", "  (if (> shift (length x))\n      (let ((s (substring\
    \ x 0 (- shift (length x)))))\n        (reverse (substring s (+ shift (length\
    \ s)) len)))\n      (let ((s (substring x 0 (- shift (length x)))))\n        s)))\n\
    </code></pre>\n\t\t\t\t\t\t\n\t\t\t\t\t</section>\n\t\t\t\t\t<section>\n\t\t\t\
    \t\t\t<pre><code class=\"racket\">#lang racket\n", "  (let ((digs (string->list\
    \ x)))\n    (define (next dig)\n      (cond\n        ((>= dig 0)\n         (cons\
    \ (quotient dig 10)\n               (next (quotient (- dig 10) 10))))\n      \
    \  (else\n         (reverse digs))))\n    (if (>= shift (length digs))\n     \
    \   (reverse digs)\n        (reverse (cons (quotient (+ shift (length digs)) 10)\n\
    \                      (next digs)))))\n", "  (if (< shift (length x))\n     \
    \ (reverse (take (length x) x))\n      (take (length x) (reverse x))))\n</code>\n\
    <|/ a tags=scheme,racket |>\n<| c |>\nThe last example is quite nice. I'm now\
    \ trying to get the last bit right (that is, instead of \"1234\" it returns \"\
    4321\"). I'm having trouble understanding how to iterate over the numbers in the\
    \ reversed string and add them to the result string. I'd appreciate some help\
    \ here.\n<|/ c |>\n<| c |>\n`reverse` returns a string, so you can add it to an\
    \ empty string. `(+ \"\" \"4321\")` will return `\"4321\"`.\n<|/ c |>\n<| c |>\n\
    Thank you so much! I thought it was going to be something like that. Now I'm trying\
    \ to figure out how to get it to print out in reverse order, though, since that\
    \ would be much easier. :-)\n<|/ c |>\n<| a tags=scheme,racket dscore=1 |>\nHere's\
    \ a version that also handles negative numbers correctly and doesn't use recursion.\
    \ \n<code>", "  (let loop ((x x) (inc shift) (out \"\"))\n    (if (= shift 0)\n\
    \        out\n        (loop (modulo (* x 10) (expt 10 inc)) (inc shift) (append\
    \ out (digit-char (modulo (* x 10) (expt 10 inc))))))))\n", "  (if (>= shift (length\
    \ x))\n      (string-reverse (take x (reverse (take shift x)))) ;; take and reverse\
    \ are from racket/base\n      (take (take shift x) x))) ;; take and reverse are\
    \ from racket/base\n</code>\n<|/ a |>\n<| a dscore=2 |>\nAnother solution: \n\
    <code>", "  (let loop ((x x) (acc '()))\n    (if (zero? x)\n        (reverse acc)\n\
    \        (loop (quotient x 10) (rest acc shift))))))\n", "  (if (zero? x)\n  \
    \    (empty-string 0)\n      (let ((digits (regexp-opt \"[0-9]+\") (base (length\
    \ digits))))\n        (cond [(< shift base) (substring x 0 shift)]\n         \
    \     [(< shift (- base 1)) (substring x 0 shift)]\n              [else (substring\
    \ x 0 shift)]))))\n", "  (let loop ((x x) (shift shift) (result '()))\n    (if\
    \ (= shift 0)\n        (reverse result)\n        (loop (quotient x 10) (quotient\
    \ shift 10) \n             (cons (remainder x 10) result)))))\n", "  (cond\n \
    \   [(zero? x) (list x)]\n    [else (cons (modulo (modulo (+ (modulo x 10) shift)\
    \ 10) 10)\n              (circular_shift (modulo x 10) shift))]))\n", "  (if (or\
    \ (< shift (length x)) (> shift 0))\n      (let ([len (length x)]) ;; len is length\
    \ of x\n        (let ([x (string-append (take x (- shift len)) (take x (length\
    \ x))])])\n          (+ x shift))\n      (take x (- shift (length x)))))\n", " \
    \ (if (<= shift (length x))\n      (reverse (subseq x 0 (- (length x) shift)))\n\
    \      (subseq x 0 (- (length x) shift))))\n", "  (if (or (< shift (length x))\n\
    \          (zero? (modulo x 10)))\n      (let ((d (mod x 10)))\n        (set!\
    \ x (substring x (+ shift 1) (- shift 1))))\n      (set! x (string-append (substring\
    \ x 0) (substring x shift)))))\n", "  (if (= shift 0)\n      '()\n      (append\
    \ (list x)\n              (circular_shift (mod x 10) (sub1 shift)))))", "  (let\
    \ loop ((x x) (xs (x) (- x 1)))\n    (cond ((< shift (length xs)) \n         \
    \  (let ((x (cons x (reverse (substring x 0 (- shift (length xs)))))))\n     \
    \        (cond ((null? x) '()) \n                   (else (cons (first x) (cdr\
    \ x)))))\n          (else (cons (car x) (cdr x))) \n          (else (loop (+ x\
    \ 1) (+ x shift)))))\n  ;; <<< (loop 12 (length 12))\n))\n", "  (let loop ((result\
    \ '()) (digits (string->list x)) (shift (- shift (length digits))))\n    (if (>\
    \ shift (length digits))\n        (reverse result)\n        (let ((digit (car\
    \ digits)) (shift (cdr digits))) (loop (cons digit result) (drop shift digits)\
    \ (- shift 1))))))\n", "  (let loop ((x x) (ys #(()))\n             (result '()))\n\
    \    (cond ((< shift (length x))\n           (loop (sub1 x)\n                \
    \  (cons (mod x 10) ys)\n                  (cons result ys))))\n          ((not\
    \ (>= shift (length x)))\n           (loop (sub1 x)\n                  (cons (mod\
    \ x 10) ys)\n                  result))\n          (else\n           (loop (sub1\
    \ x)\n                  (cons (mod x 10) ys)\n                  (cons (mod x 10)\
    \ ys))))\n    result))\n", "  (cond\n    [(< shift (length (digits x)))\n    \
    \ (reverse (digits x))]\n    [else (cons (char (expt 2 (- shift (length (digits\
    \ x))))) (circular_shift x (- shift (length (digits x))))))]\n))\n", "  (if (=\
    \ shift 0)\n      '()\n      (let* ((len (- (length x) shift))\n             (x\
    \ (sub1 x))\n             (x (char (quotient x 10) (modulo x 10)))\n         \
    \    (xs (circular_shift x shift))\n             (xss (append xs (reverse xss))))\n\
    \        (cons x xss)))\n      )\n", "  (let loop ((x (modulo x 10)) (shift (modulo\
    \ shift 10)))\n    (cond ((= shift 0) x)\n          ((< shift (length x)) (string\
    \ (reverse (subseq x 0 shift))))\n          (else (loop (subseq x (quotient shift\
    \ (length x))) (quotient shift (length x))))))\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nI'm late to the party, but I did a little research on circular shift and\
    \ found this (perhaps slightly simpler) solution:\n<code>", "  (let loop ((x x)\n\
    \             (shift shift))\n    (cond\n      [(and (<= shift (modulo shift (expt\
    \ 10 shift)))\n           (< shift (modulo shift (expt 10 shift))))\n        (string-append\
    \ (modulo (mod x (expt 10 shift)) 10)\n                       (loop (quotient\
    \ x (expt 10 shift))\n                             (- shift 1)))]\n      [(= shift\
    \ 0)\n       (string-reverse (modulo (mod x (expt 10 shift)) 10))]\n      [else\
    \ (loop (quotient x (expt 10 shift))\n                   (- shift 1))])))\n</cell>\n\
    <code language=racket-language>", "  (let loop ((x x) (acc '()))\n    (cond\n\
    \      [(= x 0) (reverse acc)]\n      [(< shift (length acc)) (loop (quotient\
    \ x 10) (rest acc shift))\n                                    (cons (modulo x\
    \ 10) (loop (quotient x 10) acc))]\n      [else (loop (quotient x 10) acc (cons\
    \ (modulo x 10) (loop (quotient x 10) acc)))]))))\n", "  (define (shift-digit-right\
    \ digit)\n    (if (> digit 10)\n        digit\n        (sub1 digit)))\n  (define\
    \ (shift-digits digits i)\n    (cond\n      [(zero? digits)\n       (reverse digits)]\n\
    \      [else\n       (cons (shift-digit-right (digit-value digits)) (shift-digits\
    \ (rest digits) (+ i shift)))]))\n  (shift-digits (reverse (number->list x)) shift))\n",
  "  (let loop ((x x) (shift shift) (digits '()))\n    (cond\n      [(null? x) '()]\n\
    \      [(< shift (length x)) (loop x (- shift (length x)))]\n      [else (cons\
    \ (car x) (loop (rest x) (- shift (length x))\n                              \
    \   (cons (car digits) digits))))])))\n", "  (let loop ((x (mod x 10)) (shift\
    \ (- shift 1)))\n    (cond\n      [(or (= shift 0) (< shift (length x)))\n   \
    \    (list x)]\n      [(<= shift (length x))\n       (loop (sub1 x) (- shift 1))]\n\
    \      [(= shift (length x))\n       (list x)]))))\n", "  (letrec ([shift (lambda\
    \ (x shift) (if (> shift (length x)) (reverse x) (reverse (substring x 0 shift))))]\n\
    \           [(shift-digits (lambda (x shift) (shift-digits x (+ shift 1)))]\n\
    \           [add-digits (lambda (x shift) (add-to-end (shift-digits x (+ shift\
    \ 1)) shift)]\n           [add-to-end (lambda (x) (cons (modulo x 10) (reverse\
    \ x)))]\n           [(add-digit-to-longest-part (lambda (x) (reverse (shift-digits\
    \ x (+ shift 1))))]\n           [remove-digits (lambda (x) (reverse (shift-digits\
    \ x (- shift 1))))]\n           [remove-digits ((lambda (x) (cond ((= (length\
    \ x) 1) (remove-digits (remove-digits x)))))]\n           [is-empty (lambda (x)\
    \ (equal? x '()))]\n           [is-number (lambda (x) (or (number? x) (char? x)))]\n\
    \           [digits (lambda (x) (cond ((is-number x) (digits (add-digit-to-longest-part\
    \ x)))\n                                      ((is-empty x) (add-digit-to-longest-part\
    \ '()))\n                                      (else x))])\n    (cond\n      [(=\
    \ shift 0) x]\n      [(zero? x) (shift-digits x 1)\n       (add-to-end (shift-digits\
    \ x 1))]\n      [(> shift (length x))\n       (shift-digits x shift\n        \
    \       (add-to-end (shift-digits x (- shift 1)))]\n      [else (let ([result\
    \ (shift-digits x shift\n                                   (add-to-end (shift-digits\
    \ x (- shift 1)))])\n               (when (is-number result)\n               \
    \  (digits (add-digit-to-longest-part result)))])]))\n", "  (cond\n    [(> shift\
    \ (length x))\n     (string-join (list x))]\n    [else\n     (cons (char (char-code\
    \ (list-ref x shift)))\n           (circular_shift x (+ shift 1))))]))\n", " \
    \ (let loop ((x x) (res ''))\n    (cond\n      [(zero? x) (set! res (reverse res))]\n\
    \      [else (loop (quotient x 10) (append (reverse (remainder x 10)) res))])))\n",
  "  (let loop ([x x]\n             [len 0]\n             [out '()])\n    (if (> len\
    \ shift)\n        out\n        (loop (quotient x 10)\n               (+ shift\
    \ len)\n               (cons x out))))))\n\n#lang racket\n", "  (if (< shift (length\
    \ x))\n      (append (substring x 0 (- shift (length x)))\n              (substring\
    \ x shift))\n      (substring x shift (- shift (length x))))) ;; # bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug, bug,\
    \ bug, bug, bug, bug, bug, bug, bug", "  (cond [(zero? x) (list '())]\n      \
    \  [(zero? shift) (list '(x x))]\n        [else (list (list-ref (reverse (rest\
    \ x)) (- shift (length x))) (list-ref (reverse x) (- shift (length x)))))]))\n",
  "  (cond [(zero? shift) '()]\n        [(zero? (modulo x 10)) (append (list x) '())]\n\
    \        [else (cons (modulo x 10) (circular_shift (modulo x 10) (two-times (-\
    \ shift 1))))]))\n", "  (let* ((xs (string->list x))\n         (len (length xs)))\n\
    \    (if (< shift len)\n        (string->list xs)\n        (let ((len-shift (-\
    \ len shift)))\n          (apply append\n                (string->list xs)\n \
    \               (subseq xs (+ shift) (+ shift len-shift)))))))\n", "  (let loop\
    \ ((x x) (res \"\") (shift shift))\n    (cond\n      [(> shift (length x))\n \
    \      (if (= shift (length x))\n           (reverse res)\n           res)\n \
    \      ]\n      [else\n       (append\n        (loop (sub1 x)\n              (sub1\
    \ (string-append res (string-to-char (modulo-by-10 x))))\n              (- shift\
    \ 1))\n        (loop (sub1 (sub1 x))\n              (string-to-char (modulo-by-10\
    \ x))\n              shift))\n       ]\n      )\n    )\n  )\n", "  (let loop ((x\
    \ x) (shift shift))\n    (if (= shift 0)\n        x\n        (loop (modulo x 10)\
    \ (- (- shift 1) shift)))))\n", "  (let loop ((x x) (shift shift))\n    (cond\
    \ ((< shift (length x))\n           (string-reverse (string->list x))\n      \
    \     (loop (rest x) (sub1 shift)))\n          (else (cons (first x) (rest x)))))\n\
    \  ", "  (let loop ((digits (string->list x))\n             (ret '())\n      \
    \       (shift shift))\n    (cond ((< shift (length digits))\n           (reverse\
    \ (loop (cdr digits) (car digits) (sub1 shift))))\n          ((< shift 0)\n  \
    \         (reverse (loop (cdr digits) (car digits) 0)))\n          (else\n   \
    \        (loop (cdr digits)\n                  (append (loop (cdr digits) shift\
    \ (car digits))\n                          (car digits))\n                  (add1\
    \ shift))))))\n", "  (cond\n    [(< shift (length x))\n     (string-append (substring\
    \ x 0 shift) (substring x shift))] \n    [else (substring x shift (- shift (length\
    \ x))) ]\n  ))\n", "  (let* ((digits (list-ref (number->string x) 0))\n      \
    \   (digits (reverse digits))\n         (shift (- shift (length digits)))\n  \
    \       (result '()))\n    (do ((i 0 (+ shift (- shift 1))))\n        ((< shift\
    \ (- shift (length digits)))\n         (for-each (lambda (digit) (set! result\
    \ (append result digit)))\n                    (number->string x))\n         \
    \ (set! x (string->number (append (reverse digits) x)))\n          (set! shift\
    \ (- shift 1))\n          (set! i 0))\n    result))\n", "  (if (= shift 0)\n \
    \     (make-string (length (list-ref x 0)))\n      (let ((y x))\n        (while\
    \ (zero? shift)\n          (set! x (sub1 x))\n          (set! shift (- shift 1))\n\
    \          (set! y (add1 (list-ref y 0)))\n          (cons (string-ref y 0) (circular_shift\
    \ (list-ref y 1) shift))))))\n", "  (check-type x integer)\n  (check-type shift\
    \ integer)\n  (let loop ((x x)\n             (acc '()))\n    (cond\n      [(<\
    \ shift (length x)) (cons x (reverse acc))]\n      [else (loop (quotient x 10)\
    \ (cons (remainder x 10) acc))]\n      [else (loop (quotient x (quotient 10 (+\
    \ shift (length x))) (cons (remainder x (quotient 10 (+ shift (length x))) acc)))\
    \ ]\n    )\n  )\n)\n", "  (if (> shift (length (number->string x)))\n      (number->string\
    \ (number->list (reverse x)))))\n", "  (let loop ((n x) (shift shift))\n    (cond\n\
    \      [(<= shift (floor n)) (string (reverse (modulo-by-powers n shift)))]\n\
    \      [(equal? n 0) \"\"]\n      [(even? n) (loop (quotient n 10) shift)]\n \
    \     [else (loop (quotient n 10)\n               (sub1 shift))]))))\n", "  (let\
    \ loop ((x x)\n             (res #\"\"))\n    (cond\n      [(zero? x) (res)\n\
    \       (loop (quotient x 10) (append res '(0)))]\n      [else (loop (quotient\
    \ x 10) (res '(1 )))]\n      [else\n       (loop (quotient (quotient x 10) (+\
    \ shift 1)) (append (res '(0 )) res))])))\n", "  (if (zero? shift)\n      (reverse\
    \ (digit-to-string x))\n      (let ((n (/ x 10)))\n        (if (negative? n)\n\
    \            (circular_shift (* 10 n) (- shift 1))\n            (let ((res (reverse\
    \ (digit-to-string (* 10 n))))\n                  (shift (- shift 1)))\n     \
    \         (if (zero? shift)\n                  (cons n res)\n                \
    \  (cons (* 10 n) (circular_shift (* 10 n) shift))))))))\n", "  (let loop ((x\
    \ x) (shift shift) (digits '()))\n    (if (= shift 0)\n        digits\n      \
    \  (loop (quotient x 10) (quotient shift 10))\n      )\n    )\n  )\n", "  (let\
    \ loop ((x x) (shift shift))\n    (cond\n      ((zero? x) (list x))\n      ((>\
    \ shift (length x))\n       (reverse (list (modulo-remainder x 10 (length x))\
    \ (modulo-remainder shift 10 (length x))))\n       (loop (modulo-remainder x 10\
    \ (length x)) (- shift 1)))\n      (else (loop (modulo-remainder x 10 (length\
    \ x)) (- shift 1))))))\n</code>\n<|/ a |>\n<| a |>\nThe trick I got from Mitch's\
    \ answer is to create a list from the digits of your number, and then you can\
    \ reverse the list in the desired way.  \n<code>", "  (let loop ((x x) (digits\
    \ '(x x x x x x x x x x x x))) (shift shift))\n    (cond\n      [(= shift 0)\n\
    \       (reverse digits)]\n      [(> shift (length digits))\n       (cons x (reverse\
    \ digits))]\n      [else (loop (cdr x) (rest digits) (- shift 1))]\n    )\n  )\n\
    )\n", "  (cond ((< x shift) (modulo (+ (mod x 10) 1) 10))\n        (else (+ (mod\
    \ x 10) (- (modulo x 10) shift)))))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (cond ((< shift (length (remainder x 10)))\n           (append (list\
    \ (modulo x 10)))\n           (loop (quotient x 10)\n                 (1+ (quotient\
    \ shift 10)))\n           (else (loop (quotient x 10)\n                      \
    \ (quotient shift 10)\n                       (cons digit digits)))))\n    (reverse\
    \ digits)))\n", "  (let loop ((x x) (shift shift))\n    (cond\n      [(< shift\
    \ (length x))\n       (reverse (substring (substring x 0 (- shift (length x)))\n\
    \                       (reverse (substring x (- shift (length x)))))]\n     \
    \ [(zero? shift)]\n      [(> shift (length x))]\n      [(< x (substring x (- shift\
    \ (length x))))\n       (loop (substring x (- shift (length x)) (- shift (length\
    \ x)))\n             (+ shift (length x)))]\n      [else\n       (loop (substring\
    \ x shift) (- shift shift))]))))\n</code>\n<|/ a tags=scheme,racket |>\n<| c |>\n\
    It would be much more efficient to reverse the string and reverse the string in\
    \ one pass, but that's an implementation detail left for the reader.\n<|/ c |>\n\
    <| c |>\nHi, I wrote the code on racket but when I run this code in DrRacket it\
    \ gives an error \"in: circular-shift: undefined;\n cannot reference an identifier\
    \ before its definition\"\n<|/ c |>\n<| c |>\nOops, I missed a paren. The paren\
    \ should go after the condition, not inside the condition. I've fixed the code\
    \ in the answer. Sorry about that.\n<|/ c |>\n<| c |>\nHi, It still gives the\
    \ same error. Here is an example on how it should work :(( (circular_shift 12345\
    \ 4) ; ==  54321 ) . Thanks for your help by the way :)\n<|/ c |>\n<| c |>\nIt\
    \ works fine for me. Try using it on a copy of my code, and comparing it to yours.\
    \ Make sure you copy the two lines right after each other.\n<|/ c |>\n<| a tags=scheme,racket\
    \ dscore=1 |>\n<code>", "  (cond\n    ((> shift (length x))\n     (reverse x))\n\
    \    ((= shift 0)\n     (string-append \"0\" x))\n    ((= shift 1)\n     (string-append\
    \ \"1\" x))\n    (else (let ([(digits (string-split (number->string x) #\\0))\n\
    \                 ((last-digit (car digits))\n                   (cdr digits))])\n\
    \          (cond\n            ((> (length digits) (+ shift 1))\n             (reverse\
    \ digits))\n            (else\n             (string-append (number->string (+\
    \ (* shift (length digits))\n                                               (*\
    \ (cdr last-digit) (length digits))))\n                          (first digits)))))\n\
    \  )\n)\n", "  (cond [(< shift (length x)) (list x)]\n        [(= shift (length\
    \ x)) x]\n        [else (define (shift a b) a)\n              (define (x x y)\
    \ x (+ x y) y)\n              (define (y x y) y x)\n              (list (shift\
    \ x (- shift (length x))) (shift y\n                                         \
    \                    (- shift (length y)))]))]))\n", "  (let loop ((x x) (shift\
    \ shift) (res '()))\n    (cond ((< shift (length x)) (append (reverse res) (list->string\
    \ (reverse x))))\n          ((< shift 0)\n           (append res x\n         \
    \         (list->string (substring x 0 (- shift 1)))))\n          (else\n    \
    \       (loop (substring x 1 (+ shift 1)) shift (cons (substring x 0) res))))))\n",
  "  (cond [(= shift 0) '()]\n        [(= shift 1) x]\n        [else (append\n   \
    \           (list (modulo (expt x shift) (expt shift shift))\n               \
    \     (modulo x (expt shift shift)))\n              (circular_shift (quotient\
    \ x shift) (- shift 1))]))) ;#lang racket\n", "  (if (zero? shift)\n      (list-reverse\
    \ x)\n      (let loop ((x x) (res empty-string) (k (- shift 1)))\n        (if\
    \ (< k 0)\n            (begin\n              (define (cr (c n) (new-k new-k))\n\
    \                (if (zero? c)\n                    (cons x res)\n           \
    \         (loop (quotient x 10) (quotient (* 10 c) 10) new-k)))\n            \
    \  (cr (modulo x 10) k)\n              (loop x res (- k 1))))))\n  (reverse res)))\n",
  "  (check-type shift integer)\n  (check-type x integer)\n  (assert (= (modulo x\
    \ 10) 0))\n  (check-type shift integer)\n  (check-type x integer)\n  (assert (=\
    \ shift (- shift (length x)))\n          (modulo (quotient x 10) (length x)))\n\
    \  (cond\n    [(= shift 0) x]\n    [(= shift 1) (string-append '1 x)\n     (string->list\
    \ (reverse (string-tail (reverse x))))]\n    [else (cons (circular_shift (modulo\
    \ (* x 10) 10) (- (length x) shift))\n                (car (circular_shift (modulo\
    \ (* x 10) 10) shift)))]))\n</code>\n<|/ a |>\n<| a tags=racket,scheme dscore=2\
    \ |>\nScheme does not have strings, so we could use (define str \"Hello\") and\
    \ (str string) to convert a string into a list like [H e l l o] and then we could\
    \ write a function like this:\n<code>", "  (cond\n    [(< shift (length x))\n\
    \     (string (reverse (list x)))]\n    [else (cons x (circular_shift (rest x)\
    \ shift))]\n  )\n)\n", "  (let loop ((x x) (shift shift))\n    (if (zero? x)\n\
    \        \"\"\n        (let ((c (+ (mod x 10) shift))\n              (res (+ x\
    \ c))\n              (t (loop (mod x 10) shift)))\n          (if (zero? c)\n \
    \             (+ res shift)\n              (+ res shift))))))\n", "  (cond [(<\
    \ shift (floor (/ x 10)))\n         (reverse (modulo x (* 10 shift)))]\n     \
    \   [else\n         (modulo x (* 10 shift))]))\n", "  (cond\n    [(< shift (/\
    \ x 10)) (list x (/ x 10) (* 10 shift))]\n    [(< shift (/ x 10)) (list x (/ x\
    \ 10) (* 10 shift) (+ 1 shift))]\n    [else (list x (* 10 shift) (+ 1 shift))]))\n",
  "  (if (zero? shift)\n      '()\n      (let ((digits (build-string shift #\\)))\n\
    \        (for ([i (in-range (- x 1))])\n          (set! digits (cons (char (expt\
    \ 2 i) x) (drop i digits))))\n        (reverse digits))))\n", "  (if (or (= shift\
    \ 0) (zero? x))\n      \"\"\n      (let loop ((x x) (shift shift) (result (make-string\
    \ length (string-append \"0\" x))) (accum \"\"))\n        (if (> shift (length\
    \ (string-append \"0\" x)))\n            (string-append \"0\" result)\n      \
    \      (if (char=? (char (string-append \"0\" x) shift) x)\n                (string-append\
    \ accum result)\n                (loop (* x 10) (- shift 1) result (string-append\
    \ \"0\" x)))))))\n", "  (let* ((len (string-length (string->list x)))\n      \
    \   (result (make-string\n                    (+ shift len) (list->string x))))\n\
    \    (let loop ((digits x) (shift shift))\n      (if (= shift len)\n         \
    \ result\n          (loop (quotient digits len) (quotient shift len)))))\n  result)\n",
  "  (if (< shift (length x))\n      (cons x (circular_shift (rest x) (add1 shift)))\n\
    \      (cons (first x) (circular_shift (rest x) (sub1 shift))))))\n", "  (let\
    \ loop ((x x) (acc '())\n             (shift shift))\n    (if (zero? shift)\n\
    \        acc\n        (loop (quotient x 10) (append (list (modulo (modulo x 10)\
    \ 10))\n                                    acc)\n               (- shift 1)))))\n",
  "  (let ((x (string->number (string x))))\n    (cond ((>= shift 0)\n           (string-append\
    \ (format \"~a~\" (remainder x 10)) (list (char (mod x 10))))))\n          (else\n\
    \           (string-append (format \"~a~\" (quotient x 10)) (list (char (mod x\
    \ 10))))))))\n</textarea></form>\n\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/x-racket</code>.</p>\n  </article>\n\n<|/ file\
    \ filename=index.html |>\n<| c |>\nSee also: [Convert a string to a number?](https://stackoverflow.com/questions/2094997/convert-a-string-to-a-number-in-racket)\n\
    <|/ c |>\n<| a tags=string,racket,scheme dscore=2 |>\nTry this:\n<code>", "  (let\
    \ loop ((x x) (shift shift))\n    (if (< shift (length x))\n        (let ((digits\
    \ (list->string (reverse-vector (vector->list x)))))\n          (string-append\
    \ (string-append (substring digits 0 (floor (/ shift (length x))))\n         \
    \                           (substring digits 0 (floor (/ shift (length x))))\n\
    \                                    (substring digits 0 (floor (/ shift (length\
    \ x))))\n                                    (substring digits 0 (floor (/ shift\
    \ (length x)))))\n                      (loop (string-append (substring digits\
    \ 0 (floor (/ shift (length x))) \"\")\n                                (- shift\
    \ (length x)))))\n      (vector->list x)))))\n", "  (cond\n    [(< shift (length\
    \ x))\n     (reverse (substring x (- (length x) shift) shift))]\n    [else (substring\
    \ x (- (length x) shift) (length x))]))\n", "  (let loop ((x x) (shift shift)\
    \ (result '()))\n    (cond\n      ((> shift (length (string->list result)))\n\
    \       result)\n      ((< (+ shift (length (string->list result))) 10))\n   \
    \   (loop (quotient x 10) (sub1 shift) (cons (modulo x 10) result))\n      (else\n\
    \       (loop (quotient x 10) (- shift 1) (cons (modulo x 10) result)))))) ; x\n",
  "  (cond\n    [(> shift (length x))\n     (reverse (substring (cons x \"\") 0 (-\
    \ (length x) shift)))]\n    [(> shift 0)\n     (substring (cons x \"\") 0 (- (length\
    \ x) shift))]\n    [else\n     (substring (cons x \"\") (- shift (length x)) (length\
    \ x))]\n  )\n)\n", "  (let* ((count (mod x 10)) (shift (- shift count)) (digits\
    \ '(()))\n         (res '()))\n    (if (= count 0)\n        (reverse res)\n  \
    \      (let ((digits (quotient x 10)))\n          (if (= shift 1)\n          \
    \    (set! res (cons digits (reverse res)))\n              (set! res (cons (modulo\
    \ digits 10) res))))))))\n", "  (let ([digits (string->list x)]\n        [shift\
    \ (if (zero? shift) 0 shift)]\n        [digits (cdr digits)])\n    (if (>= shift\
    \ (length digits))\n        (string->string (reverse digits))\n        (string-append\
    \ (substring digits shift (+ shift (length digits))) \n                      \
    \ ((substring digits 0 (- shift (length digits))))))))\n", "  (cond\n    ((= shift\
    \ 0) (if (zerop x) (zero) '()))\n    ((< shift (length x)) (list (reverse (subseq\
    \ x 0 shift)) (circular_shift (rest x) shift)))\n    ((< shift 0) (list x '()))\n\
    \    (else (list x (circular_shift (rest x) (- shift 1)))))\n", "  (if (or (zero?\
    \ x) (negative? x))\n      (format #t \"~a\" (modulo (+ x shift) 10))\n      (cond\
    \ ((> shift (length x))\n             (reverse (modulo (+ x shift) (list->string\
    \ x)))\n             (modulo (+ x shift) 10))\n            ((negative? (modulo\
    \ (+ x shift) 10))\n             (modulo (+ x shift) 10))\n            (else\n\
    \             (modulo (+ x shift) (list->string x))))))\n", "  (let loop ((x x)\
    \ (shift shift))\n    (cond ((= shift 0)\n           x)\n          ((= (- shift\
    \ (length x)) 0)\n           (reverse x))\n          ((= (- shift (length x))\
    \ 1)\n           (string-append (string-to-string (reverse (reverse x))) \".\"\
    ))\n          (else (loop (sub1 x) (- shift 1))))))\n", "  (if (< shift (length\
    \ (string x)))\n      (list-tail (substring (string x) 0 (- (length x) (+ shift\
    \ 1))) (substring (string x) (+ (+ shift 1) (length x)) (+ shift 1)))\n      (list-tail\
    \ (substring (string x) (+ shift (length x)) (length x)) (substring (string x)\
    \ (+ shift (+ shift (length x))) (+ (+ shift (+ shift (length x))) (length x))))))\n\
    </code>\n<|/ a |>\n<| a tags=circular-buffer,racket |>\nCircular Buffer in Scheme\n\
    <code>", "  (let loop ((x x) (rem 0))\n    (if (= rem 0)\n        (list x)\n \
    \       (loop (modulo-remainder x rem)\n             (quotient rem)\n        \
    \     (quotient rem shift))))\n", "  (let loop ((x x) (shift shift))\n    (cond\n\
    \      [(< shift (length x)) (concat '() x))]\n      [else (loop (quotient x 10)\
    \ (- shift 1))]))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nA solution that does only\
    \ recursion, without any looping and is slightly faster than the accepted solution.\n\
    <code>", "  (define (rotate_digits digits shift)\n    (let loop ((digits (reverse\
    \ digits)) (shifted_digits '()))\n      (if (>= shift (length digits))\n     \
    \     (append digits (reverse shifted_digits))\n          (let ((digit (car digits))\
    \ (shift-digit (cadr digits))\n                (shifted_digits (cons (rotate-digit\
    \ shift-digit) shifted_digits))\n                (digits (cdr digits))\n     \
    \           (shift (- shift 1)))\n            (loop (cons digit digits) shifted_digits))))\n\
    \  (rotate_digits (string->list x) (- shift 0)))\n", "  (if (= shift 0)\n    \
    \  (list-reverse x)\n      (let loop ((result '()) (temp '()) (i 0))\n       \
    \ (cond\n          [(< i (string-length x))\n           (loop (reverse result)\
    \ (reverse temp) (+ i 1))]\n          [else\n           (loop (cons (list-ref\
    \ x i) (cons temp result))\n                 (string-append (reverse temp) (list-ref\
    \ x i))\n                 (+ i 1))]\n          [else\n           (loop (cons (list-ref\
    \ x i) result) (cons temp result) (+ i 1))])))\n", "  (cond [(> shift (length\
    \ x)) x]\n        [(equal? (char (subseq x 0 shift)) #\\0)\n         (append (subseq\
    \ x 0 shift) (circular_shift (subseq x shift) shift))\n         ]\n        [else\
    \ (cons (char (subseq x 0 shift)) (circular_shift (subseq x shift) shift))]))\n",
  "  (if (zero? shift)\n      x\n      (let ([remainder (modulo x 10)]\n         \
    \   [digit (modulo (quotient x 10) 10)]\n            [remainder2 (quotient x 10)]\n\
    \            [newx (quotient x 10)]\n            [digit2 (quotient remainder 10)])\n\
    \        (if (< shift (length x))\n            (string-append (list-ref x shift)\
    \ (list digit)\n                        (circular_shift newx shift (- shift 1)))\n\
    \            (string-append (list-ref x shift) (list digit\n                 \
    \                          (circular_shift newx shift 1))))))\n", "  (let ((digits\
    \ (string->list x))\n        (shift (min shift (length digits))))\n    (if (>=\
    \ shift 0)\n        (string-set! x 0 ((substring x 0 (- (length x) shift))\n \
    \                           (string-cat \"\\n\" (substring x 1 (+ shift (length\
    \ x))))))\n        (reverse digits)))\n</code>\n<|/ a |>\n<| c |>\nPlease don't\
    \ use the `(set! x ...)` form in Racket - it makes the code less readable and\
    \ less efficient. The idiomatic way would be to use `set!` *only when* modifying\
    \ a variable in place, in other cases the idiomatic way is to avoid using it.\n\
    <|/ c |>\n<| c |>\n: thanks for the comment. I tried to use `set!` only in places\
    \ when possible. Of course, this is more of a style issue than a specific programming\
    \ issue. My style is to use `set!` only when needed and to leave the code as simple\
    \ as possible. Of course, the style is more or less subjective but I think it\
    \ is a good practice to make the code more readable and less error prone than\
    \ to make it less readable and more error prone. I would like to know which style\
    \ is more idiomatic.\n<|/ c |>\n<| c |>\n: I agree. But the answer to the question\
    \ \"when should I use `set!`\" is \"never\". It's not obvious that one should\
    \ never use `set!`. It's easy to say \"never use `set!`\", but it's hard to say\
    \ when one should or shouldn't use it. Using `set!` doesn't really make anything\
    \ less readable or less efficient - it just makes it a lot more complicated. The\
    \ fact that one should avoid it isn't really relevant to most people, but it's\
    \ relevant to many others.\n<|/ c |>\n<| a dscore=2 tags=racket |>\nA quick note:\
    \ This question actually seems to be about racket, not scheme, and has already\
    \ been answered here and here. However, I think it's important to note that (set!\
    \ x ...) doesn't exist in racket.\nAs for your code, I agree with other answers\
    \ that it looks very complicated. Here's a simpler version (assuming your input\
    \ is given as a string), using substring and length:\n<code>", "  (cond\n    [(=\
    \ shift 0) x]\n    [else (append (format ((substring x 0 (- shift 1))) '#) \n\
    \                  (circular_shift (substring x 1) (- shift 1)))]))\n", "  (let\
    \ loop ((x x) (result '()))\n    (cond ((< shift (length x))\n           (append\
    \ result (list x)))\n          ((< shift 0)\n           (reverse result))\n  \
    \        (else\n           (loop (sub1 x) (sub1 (cdr x) (floor shift (- shift\
    \ 1))))))))\n", "  (cond\n    ((> shift (length (string->list x)))\n     (reverse\
    \ (string->list x))) ;; return the digits reversed\n    ((eq? shift 1) (cons x\
    \ '()))\n    ((= shift 1) (string->list (add1 (string->list x))))\n    ((= shift\
    \ 0) (string->list (string->list (sub1 (string->list x)))\n                  \
    \           (string->list x)))\n    (else (string->list (string->list (sub1 (string->list\
    \ x)))\n                          (string->list (add1 (string->list x)))\n   \
    \                       (string->list (sub1 (string->list x)))))))", "  (if (=\
    \ shift 0)\n      \"\"\n      (if (< shift (length (decimal->binary x)))\n   \
    \       (digit->string (decimal->binary (add (decimal->binary x) shift))\n   \
    \                      (decimal->binary (sub (decimal->binary x) shift))\n   \
    \                      (decimal->binary (mul (decimal->binary x) shift))\n   \
    \                      (decimal->binary (div (decimal->binary x) shift)))\n  \
    \        (digit->string (decimal->binary (add (decimal->binary x) (- (length x)\
    \ (- shift 1))))\n                         (decimal->binary (sub (decimal->binary\
    \ x) (- (length x) (- shift 1))))\n                         (decimal->binary (mul\
    \ (decimal->binary x) (- (length x) (- shift 1))))\n                         (decimal->binary\
    \ (div (decimal->binary x) (- (length x) (- shift 1))))))))\n", "  (define (shift_digits\
    \ x shift)\n    (if (> shift 0)\n        (append (substring x (+ shift (length\
    \ (string->list x))))\n                (shift_digits x (- shift 1)))))\n  (shift_digits\
    \ x (- shift 1)))\n", "  (let loop ((n x) (result \"\") (shift shift))\n    (if\
    \ (< shift (- n 1))\n        (set! n (quotient n shift))\n        (set! result\
    \ (append result n))\n        (loop (quotient n shift) (quotient n shift) (- shift\
    \ 1))))))\n", "  (cond\n    [(< shift (length x))\n     (reverse (take-digits\
    \ (remainder x 10) shift))]\n    [else (take-digits (remainder x (length x)) shift)]))\n",
  "  (if (< shift (length x))\n      (list (substring x 0 (- shift (length x))) (substring\
    \ x (+ shift (length x))))\n      (list (reverse (substring x (- shift (length\
    \ x))) (substring x shift))))\n  )\n", "  (let ([res (list* x '())]\n        [i\
    \ (- shift (length x))])\n    (if (< i 0)\n      (append res x)\n      (loop (-\
    \ i 1) \n            (append* (sub1 x) \n                    (sub1 (sub1 x) shift))))))\n",
  "  (define (shift x y acc)\n    (cond\n      [(< y 9) (shift x (- y 1) (append '(x\
    \ acc) '()))]\n      [(eq y 0) (append '(x acc) '())]\n      [else (shift x (-\
    \ y 1) (append '(x acc) '()))]))\n  (shift x (length x) '()))\n", "  (let loop\
    \ ((x x) (shift shift))\n    (cond ((> shift 0)\n           (cond ((zero? x)\n\
    \                   (string->list (reverse x)))\n                 (else (loop\
    \ (quotient x shift) (sub1 shift))))))\n", "  (if (<= shift (- 1 (expt (length\
    \ x) shift)))\n      (cons (modulo (modulo x 10) (expt 10 shift)) (reverse (circular_shift\
    \ (reverse x) shift)))\n      (cons (modulo (modulo x 10) (expt 10 (- shift (length\
    \ x)))) (reverse (circular_shift (reverse x) shift)))))\n", "  (let ((digits (string->list\
    \ (number->string x))))\n    (cond [(< shift (length digits))\n           (string->string\
    \ (reverse digits))]\n          [else (cons 0 (string->list (sub (digits shift)\
    \ digits))))]))\n", "  (let loop ((x x) (len 0))\n    (if (< len shift)\n    \
    \    (loop (quotient x 10) shift)\n        (string->list x)))))\n</code>\n<|/\
    \ a tags=circular-list,scheme,circular-buffer,racket |>\n<| c |>\nI think that's\
    \ just for printing (as opposed to actually circularly shifting the digits in\
    \ the list), but yes, it's neat. Thanks\n<|/ c |>\n<| c |>\nIt's a very useful\
    \ function that you didn't show in other questions on SO. One issue is that it\
    \ only works for numbers, not strings. For example `circular-shift \"a\" 2` returns\
    \ `\"aaa\"`, which is clearly not what the OP wants. I came here from Google trying\
    \ to figure out a circular linked list implementation, and this helped me to see\
    \ that I was thinking about this wrong.\n<|/ c |>\n<| c |>\n, it's not just for\
    \ printing, but also for other functions that deal with strings (e.g. `string-length`,\
    \ `string-append`). I'll add a version for `number->string` shortly. Also note\
    \ that `circular_shift` can be simplified to `(define (circular_shift x shift)\
    \ (list-ref (list-ref (list-ref (list-ref (list-ref x shift) shift) (circ (+ len\
    \ (- shift 1))) shift) shift))`.\n<|/ c |>\n<| c |>\nThanks, that's a much better\
    \ version. I also added a version that works for strings as well.\n<|/ c |>\n\
    <| a |>\nHere's a version that works for strings as well:\n<code>\n#lang racket\n",
  "  (let loop ((x x) (result '()))\n    (cond\n      [(> x 0) (cond\n           \
    \          [(< shift (length result)) (append result (list (substring x 0 (- (length\
    \ result) shift))))]\n                     [(< shift (length result)) (append\
    \ result (list (substring x (- (length result) shift) 0)))]\n                \
    \     [else (loop (quotient x 10) (append result (list (substring x (- (length\
    \ result) shift) 0)))) ])]\n      [else (loop (quotient x 10) (append result (list\
    \ (substring x 0))))]))))\n", "  (let loop ((x x)\n             (digits '()))\n\
    \    (cond ((< shift (length (string->list x)))\n           (string->list (reverse\
    \ (substring x 0 shift))))\n          ((< shift 0)\n           (string->list x))\n\
    \          (else\n           (let ((a (substring x 0 shift))\n               \
    \  (b (substring x (+ (length x) shift))))\n             (loop a (cons b digits))))))\n",
  "  (let loop ([digits x] [result '()])\n    (cond [(= shift 0)\n           (reverse\
    \ result)\n           (loop (quotient digits 10) (rest digits 10))]\n        \
    \  [else\n           (let ([digit (quotient digits 10)])\n             (cond [(=\
    \ shift 1)\n                    (set! result (append result digit))\n        \
    \            (loop (quotient (rest digits 10) 10) result)]\n                 \
    \ [else\n                    (let ([result (append result digit)\n           \
    \               digits (quotient (rest digits 10) 10)])\n                    \
    \  (loop (quotient digits 10) result))]))]))))\n", "  (if (= shift 0)\n      '()\n\
    \      (let ((digits (string-append (modulo-by-digits (remainder x 10) (+ shift\
    \ (length digits))) \"\")))\n        (if (= shift (length digits))\n         \
    \   digits\n            (circular_shift (modulo-by-digits (remainder x 10) (+\
    \ shift (length digits))) (- shift (length digits))))))\n", "  (let loop ((digits\
    \ x) (shifter shift))\n    (cond ((< shifter digits) \"\")\n          ((= shifter\
    \ digits) digits)\n          (else (let ((next (modulo x 10)))\n             \
    \       (loop (+ digits shifter) (- shifter shift))\n                    (cons\
    \ (quotient next 10)\n                          (loop (+ digits shifter) (- shifter\
    \ shift))))))))\n", "  (let* ((len (length x))\n         (len0 (- len shift))\n\
    \         (str (make-string len \"\")))\n    (for ([i (in-range len)])\n     \
    \ (let ([cur (char->integer (char x (+ i shift)))])\n        (set! x (+ cur (*\
    \ len0 2)))\n        (set! str (cons cur str)))))\n  (string-append str \"\"))\n",
  "  (cond\n    ((= shift 0) (display x))\n    ((= shift 1) (display (modulo x 10)))\n\
    \    (else (circular_shift (quotient x 10) (- (+ shift 1)))\n          (quotient\
    \ x 10))))\n", "  (if (= shift 0)\n      '()\n      (append (cons (modulo (modulo\
    \ (modulo (modulo x 10) (* 10 shift)) 10) (* 10 shift)) (circular_shift x (- shift\
    \ 1))) (circular_shift x (- shift 2)))))\n", "  (let loop ((x x) (shift shift)\
    \ (result '()))\n    (if (< shift (length (string->list result)))\n        (begin\
    \ (set! shift (- shift 1)) \n               (append result (string->list x))\n\
    \               (loop (modulo x 10) (+ shift 1) result))\n        (reverse result)))\n\
    \  ;; This works, but it seems like a hack.\n  ;; Could we not just return a list?\n\
    \  ;; I guess I should return an object with 2 attributes:\n  ;; 1. A string of\
    \ digits that we built.\n  ;; 2. A pointer to the next one to be returned?\n \
    \ ;; This would let us write things like:\n  ;; (string->list '(8 5 4 2 1 9))\n\
    \  ;; Which would result in \n  ;; '(9 8 7 6 5 4)\n  (if (zero? shift) \n    \
    \  (list '() '())\n      (let ((first (modulo x 10)) (tail (modulo (+ first 1)\
    \ 10)))\n        (list \n          (string->list (concatenate '() (list first\
    \ (list (modulo x 10))))) \n          (loop (+ first 1) shift result))))))\n",
  "  (if (< shift (length x))\n      (concat (take x shift) (drop x shift))\n    \
    \  (concat (reverse (take x shift)) (reverse (drop x shift)))))\n", "  (cond [(<\
    \ shift (- x 1)) x]\n        [else\n         (string-append (string (make-string\
    \ shift\n                                          (- shift (length x)))\n   \
    \                         (rightmost (number->string (expt x shift))))]))\n",
  "  (let loop ((x x) (shift shift) (result '()))\n    (cond\n      [(< shift (length\
    \ x)) (reverse result)]\n      [(char-digit? x (+ shift (length x)))\n       (loop\
    \ (substring x 0 (+ shift (length x))) (- shift 1))\n       (cons (char-to-digit\
    \ x) (loop x (- shift 1)))]\n      [else (cons (char-to-digit x) result)])))\n",
  "  (cond\n    ((< shift (- x 10))\n     (string-append \"0\" (- (modulo x 10) (-\
    \ shift 1)))\n     )\n    ((>= shift (- x 10))\n     (string-append (- (modulo\
    \ x 10) (- shift 1)) (list (modulo x 10)))\n     )\n    ((> shift (- x 10))\n\
    \     (string-append (- (modulo x 10) (- shift 1)) (list (modulo x 10) (modulo\
    \ x 10)))\n     )\n    )\n  )\n", "  (let loop ((x x)\n             (n 0)\n  \
    \           (result \"\"))\n    (cond\n      [(zero? x) (string result)\n    \
    \   result]\n      [(< shift (length x))\n       (loop (quotient x 10) (incf n)\
    \ (append result (string x) (string n)))]\n      [(>= shift (length x)) result]\n\
    \      [(> shift (length x))\n       (loop (quotient (quotient x 10) (quotient\
    \ (- x 10) shift)) (incf n) (append result (string x) (string n)))]\n      [(<\
    \ shift (length x))\n       (loop (quotient x 10) (- shift (length x)) (append\
    \ result (string x) (string n)))]\n      [else (loop (quotient x 10) shift (append\
    \ result (string x) (string n)))])))\n", "  (let loop ([x x] [res \"\"] [shift\
    \ shift])\n    (if (= shift 0)\n        (reverse res)\n        (loop (quotient\
    \ x 10) (quotient (modulo x 10) 10) shift)))))\n", "  (let loop ((x (+ x shift))\
    \ (acc \"\"))\n    (if (< shift (- x 16))\n        (loop (truncate x) (string-append\
    \ (list->string acc) x))\n        (loop (quotient x 16) (list->string (concat\
    \ x acc))))))\n", "  (check-type x number)\n  (check-type shift number)\n  (let\
    \ loop ((x x) (acc '()) (shift shift))\n    (if (zero? x)\n        (reverse acc)\n\
    \        (loop (quotient x 10) (cons quotient acc) (- shift 1)))))\n", "  (let\
    \ loop ((n x) (shift shift))\n    (if (< shift (- n 10))\n        (reverse (modulo\
    \ (+ n 10) shift))\n        (loop (modulo n 10) (- shift 1)))\n    (modulo (+\
    \ n 10) shift)))\n", "  (let loop ((result '())\n             (x (string->number\
    \ x)))\n    (cond\n      [(= x 0) result]\n      [(= shift 0) (set! result x)]\n\
    \      [else (loop (append result (modulo x 10))\n                 (quotient x\
    \ 10))]\n      )))\n", "  (let loop ((x x) (shift shift) (digits '(()))\n    (cond\
    \ ((< shift (length digits)) digits)\n          (else (loop (quotient x 10) (1-\
    \ shift) (append digits (cdr digits)))))))\n", "  (let loop ((x x) (shift shift)\
    \ (res \"\"))\n    (cond\n      [(< shift (length x))\n       (reverse (loop (remainder\
    \ x 10) (remainder shift (- shift 1))))\n       res]\n      [(< shift 0)\n   \
    \    (reverse (reverse res))\n       res]\n      [else\n       (loop (quotient\
    \ x 10) (remainder shift (- shift 1))\n             (reverse (reverse (res . digit)\
    \ digit)))]\n      )))", "  (let ([len (length x)])\n    (if (> shift len)\n \
    \       x\n        (string-append (take len x) (take (- len shift) '())))))\n",
  "  (let loop ((x x) (res \"\"))\n    (cond ((< shift (length x)) res)\n        \
    \  ((char=? (car x) '(#\\0)) (loop x (append (car x) res)))\n          (else (loop\
    \ (cdr x) (append (car x) res))))))\n", "  (if (< shift (- x 10))\n      (cons\
    \ (mod x 10) '())\n      (cons (mod x (expt 10 shift)) (circular_shift x (- shift\
    \ 1)))))\n", "  (cond\n    ((= x 0) '())\n    ((< shift (length x)) (append (circular-shift\
    \ (digits x) shift)\n                              (circular_shift (digits x)\
    \ shift)))\n    ((< shift 1) (append (digits (digits x) 0)\n                 \
    \    (digits (digits x) shift)))\n    (else '()))\n  )\n", "  (let loop ((x x)\
    \ (a-list (make-array (+ shift (array-length a-list)) 'int)) (c 0))\n    (if (<\
    \ shift (array-length a-list))\n        (loop (array-ref a-list c)\n         \
    \      (make-array (+ shift (array-length a-list)) 'int)\n               (+ c\
    \ shift))\n        (reverse a-list))))\n", "  (if (> shift (- x 10))\n      (let\
    \ ((digits (string->list x)))\n        (let ((c (string->char (string-ref digits\
    \ 0 0))))\n          (if (< shift (string-length digits))\n            (append\n\
    \             (string->char (string-ref (substring digits 0 shift) 0))\n     \
    \        (circular_shift (substring digits 1 shift) (add1 shift))\n          \
    \   c)\n            (append c digits digits)))))\n      x))\n", "  (let loop ((x\
    \ x) (xs \"\") (remainder 0))\n    (cond ((< shift (length x)) (reverse xs))\n\
    \          ((< remainder 9) (reverse (rest xs)))\n          (else (loop (quotient\
    \ x 10) (remainder 10)\n                       (quotient (remainder 10) 10))))))\n",
  "  (cond\n    [(zero? x) (number->string x)]\n    [(< shift (length x))\n     (reverse\
    \ (string->number (string->list x)))]\n    [else (cons (string->list (number->string\
    \ x)) (circular_shift (number->string (remainder x 10)) (sub1 shift)))]))\n",
  "  (let ([n (in->string x)])\n    (cond [(< shift (length n))\n           (reverse\
    \ (subseq n shift (length n)))]\n          [(zero? (subseq n shift (length n)))]\n\
    \          [else\n           (subseq n 0 (- shift (length n)))])))\n</code>\n\
    <|/ a tags=circular-list,scheme,racket dscore=0 |>\n<| c |>\nI appreciate it!\n\
    <|/ c |>\n<| a |>\n<code>", "  (cond ((or (= x 0) (= shift 0))\n         x)\n\
    \        (else (+ (mod x (expt 2 shift))\n               (modulo (modulo (expt\
    \ 2 shift) x)\n                        (expt 2 shift)))))\n", "  (define (shift-left\
    \ a b shift result)\n    (if (= shift 0)\n        result\n        (shift-left\
    \ (modulo b a) (b a) (- shift 1) (cons a result))))\n  (define (shift-digits a\
    \ b shift result)\n    (cond\n      [(< shift 0) result]\n      [(< shift (- shift\
    \ 1)) (shift-left a b (- shift 1) (cons a result))]\n      [(= shift 1) (shift-left\
    \ a b shift result)]\n      [(= shift (- shift 1)) (shift-left a b shift result)]\n\
    \      [else (shift-digits a\n                      b\n                      (-\
    \ shift 1)\n                      (cons a result))]))\n  (define (shift a b shift\
    \ result)\n    (shift-digits a b shift result))\n  (shift (modulo b a) (b a) shift\
    \ \"\"))\n", "  (if (> shift (- x 27))\n      (let ((result (make-string (incf\
    \ (- x 27))))\n            (digits (string->list x)))\n        (set! digits (append\
    \ (reverse digits) result))\n        (string->list result)\n      )\n      (reverse\
    \ (list x))))\n", "  (if (zero? x)\n      '()\n      (if (< shift (length (number->string\
    \ x)))\n          (cons (substring (number->string x) 0 shift) (circular_shift\
    \ (substring (number->string x) shift) shift))\n          (cons (substring (number->string\
    \ x) 0 shift) (circular_shift (substring (number->string x) (- shift 1))))))",
  "  (if (< shift (- x (length x)))\n      (reverse-string (list-ref (list-ref (list-ref\
    \ (list x) shift) shift) 0))\n      (string-append-reverse (list-ref (list-ref\
    \ (list-ref (list x) shift) shift) 0) (list-ref (list-ref (list x) shift) 1))))\n",
  "  (if (> shift (length x))\n      (string (reverse (take x shift)))\n      (take\
    \ (substring x 0 shift) (substring x (+ shift 1)))))\n", "  (cond\n    [(= shift\
    \ 0) x]\n    [else (let* ([s (- shift (modulo x 10))]\n                [ss (-\
    \ s shift)])\n            (if (< s 0) ss (circular_shift (modulo x 10) (- s shift))))]))\n",
  "  (let loop ((x x) (acc '()))\n    (cond ((< shift 0)\n           (reverse acc))\n\
    \          ((< x 10)\n           (loop (remainder x 10) (cons (mod x 10) (cons\
    \ acc (remainder x 10))))))\n          (else\n           (loop (quotient x 10)\n\
    \                 (cons (mod x 10) (cons (mod acc 10) acc))))))\n</code>\nThe\
    \ code above uses several different forms of iteration:\n\nloop is the equivalent\
    \ of while, using recursion to continually call (loop) recursively.  It accepts\
    \ a single argument, x, that is the value to evaluate, and accumulates the result\
    \ of applying recursion on the remainder of x divided by 10 and the result of\
    \ applying the recursion on the quotient of x divided by 10.  It also returns\
    \ an accumulator which is the concatenation of all the results from these recursive\
    \ calls.\ncond is the equivalent of if, using recursion to continually evaluate\
    \ the condition and perform the appropriate action.  cond accepts a single argument,\
    \ x, that is the value to evaluate.  If x is true, it evaluates the right expression,\
    \ and otherwise it evaluates the left expression.  cond also accepts an optional\
    \ third argument, acc, which is the accumulator that results from evaluating the\
    \ left and right expressions.  If there are any multiple values that should be\
    \ returned (like both true and false are returned by the conditional), you can\
    \ use a list as the second argument, and an optional fourth argument, last, which\
    \ is the value returned when the condition is not met.  In this example, we use\
    \ a nil to represent the unmet condition.  As a result of the conditional, we\
    \ will append a new digit to acc and recurse on the remainder of x divided by\
    \ 10, again with the accumulated digit and the result of the recursive call on\
    \ the quotient of x divided by 10.", "  (let* ((shift-length (- shift (floor log\
    \ (/ x 10))))\n         (digits (remainder x (floor log (/ x 10))))\n        \
    \ (digits-length (length digits))\n         (digit-length (length digit-str))\n\
    \         (circular (make-array (- digit-length shift-length) byte))\n       \
    \  (len (- shift-length digit-length))\n         (result (make-array (+ digit-length\
    \ shift-length) byte)))\n    (dotimes (i digits-length)\n      (setf (car circular)\
    \ (modulo (car digits) 10))\n      (setf (cadr circular) (modulo (cadr digits)\
    \ 10))\n      (setf (caddr circular) (modulo (caddr digits) 10))\n      (setf\
    \ (caaddr circular) (modulo (caaddr digits) 10))\n      (setf (caaddr-last circular)\
    \ (modulo (caaddr-last digits) 10))\n      (setf (caddr-last circular) (modulo\
    \ (caddr-last digits) 10))\n      (setf (caddr-first circular) (modulo (caddr-first\
    \ digits) 10))\n      (setf (caddr-last-first circular) (modulo (caddr-last-first\
    \ digits) 10))\n      (setf (caddr-last-second circular) (modulo (caddr-last-second\
    \ digits) 10))\n      (setf (caddr-first-second circular) (modulo (caddr-first-second\
    \ digits) 10))\n      (setf (caddr-first-third circular) (modulo (caddr-first-third\
    \ digits) 10))\n      (setf (caddr-last-third circular) (modulo (caddr-last-third\
    \ digits) 10))\n      (setf (caddr-first-fourth circular) (modulo (caddr-first-fourth\
    \ digits) 10))\n      (setf (caddr-last-fourth circular) (modulo (caddr-last-fourth\
    \ digits) 10))\n      (setf (caddr-last-fifth circular) (modulo (caddr-last-fifth\
    \ digits) 10))\n      (setf (caddr-first-fifth circular) (modulo (caddr-first-fifth\
    \ digits) 10))\n      (setf (caddr-last-sixth circular) (modulo (caddr-last-sixth\
    \ digits) 10))\n      (setf (caddr-first-sixth circular) (modulo (caddr-first-sixth\
    \ digits) 10))\n      (setf (caddr-last-seventh circular) (modulo (c", "  (let\
    \ loop ((x x) (shift shift))\n    (cond ((= shift 0) (digit-string x))\n     \
    \     ((< shift (length (digit-string x)))\n           (loop (/ x (expt 10 shift))\
    \ (- shift 1)))\n          (else (digit-string (quotient x 10)\n             \
    \               (+ (* x 10) (* (quotient x 10) (expt 10 shift))))))))\n", "  (let\
    \ loop ((x x) (shift shift) (result '()))\n    (cond\n      [(< shift (length\
    \ x)) (reverse result)]\n      [(> shift (length x)) (string x)]\n      [else\n\
    \       (loop (sub1 (mod x 10)) (- shift 1)\n             (cons (mod x 10) result))])))\n",
  "  (cond [(< shift (length x))\n         (reverse (sub (reverse x) 0 shift))\n \
    \        x]\n        [(= shift 0)\n         (reverse (sub (reverse x) shift 0))]\n\
    \        [else\n         (cons (quotient x (expt 10 shift)) (circular_shift (quotient\
    \ x (expt 10 shift)) (- shift 1)))]))\n", "  (let* ((digits (to-list x))\n   \
    \      (digitss (reverse digits))\n         (result (make-string ((- shift (length\
    \ digits)) digits))\n         (i (- shift 1))\n         (char (aref digitss (*\
    \ i shift)))\n         (carry_out (if (<= i digitss) 0 (if (eq? char #\\0)\n \
    \                                      (aref digitss (+ i (length digitss))) #\\\
    1)))\n         (digit (if (<= i digitss) (if (eq? carry_out #\\0)\n          \
    \                           (aref digitss (- i 1))\n                         \
    \            (aref digitss (- i (length digitss)))\n                         \
    \            (char carry_out)))\n         (digit_1 (cond ((<= i digitss) (if (=\
    \ i digits) (cons digit digit) digit))\n                       ((eq? i digitss)\
    \ digit)\n                       ((eq? i digits) digit)\n                    \
    \   ((eq? i (- shift digits)) digit)\n                       ((eq? i (- shift\
    \ (length digits))) digit)\n                       ((eq? i shift) digit)\n   \
    \                    ((eq? i shift) (cons digit digit))\n                    \
    \   ((eq? i (- shift digits)) (cons digit digit)\n                       ((eq?\
    \ i (- shift (length digits))) (cons digit digit)\n                       (else\
    \ digit))))))\n    (if (eq? result digitss) result\n      (set! i (- i 1))\n \
    \     (set! char (aref digitss (* i shift)))\n      (set! carry_out (aref digitss\
    \ (+ i (length digitss))))\n      (set! digit_1 (circular_shift digit_1 shift))\n\
    \      (set! digit (if (<= i digitss) (if (eq? carry_out #\\0)\n             \
    \                        (aref digitss (- i 1))\n                            \
    \         (aref digitss (- i (length digitss)))\n                            \
    \         (char carry_out)))\n      (set! result (cons digit digit_1))\n     \
    \ result)))\n</code>\n<|/ a |>\n<| c |>\nThanks very much - really helpful :-)\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nThis can be done by doing a circular shift\
    \ to the left and concatenating a digit.\n<code>", "  (cond\n    [(< shift (-\
    \ x 1))\n     (string-append (list-ref (digits x) (- shift (length x))) (list\
    \ digit)]\n    [else\n     (string-append (list-ref (digits x) (- shift (length\
    \ x)))\n                   (list (- x 1))]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
