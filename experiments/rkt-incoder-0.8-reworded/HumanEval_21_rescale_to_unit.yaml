name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0\
  \ 5.0))\n;; (list 0.0 0.25 0.5 0.75 1.0)\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (let ([min (first numbers)]\n        [max (last numbers)])\n    (let\
    \ ([range-min (- min max)]\n          [range-max (- max min)])\n      (set! (first\
    \ numbers) (/ (first numbers) range-max))\n      (set! (last numbers) (/ (last\
    \ numbers) range-min))\n      numbers))\n", "  (let ((max-min (apply max (append\
    \ numbers numbers))))\n    (map (lambda (n) (/ (- n max-min) max-min)) numbers)))\n",
  "  (apply lt-float (map (lambda (x) (/ x 2.0)) numbers)))\n", "  (let* ((min (car\
    \ numbers))\n         (max (cdr numbers)))\n    (if (equal? min max)\n       \
    \ (list 0 1 0 1 1)\n        (let* ((diff (- max min))\n               (scaled\
    \ (/ (- min max) diff)))\n          (list scaled scaled scaled scaled scaled))))))\n",
  "  (let ([smallest (apply min numbers)])\n    (let ([largest (apply max numbers)])\n\
    \      (/ (apply + numbers) (- largest smallest)))))\n", "  (cond [(empty? numbers)\
    \ numbers]\n        [(empty? (rest numbers)) empty]\n        [else (min-max (car\
    \ numbers)\n                       (rescale_to_unit (rest numbers))\n        \
    \               #:key (lambda (x y) (- y x)))))\n", "  (let ((min (min numbers\
    \ numbers)))\n    (/ (- min (max numbers numbers)) 2))))\n", "  (if (or (null?\
    \ numbers) (null? (cdr numbers)))\n      numbers\n      (let ((smallest (car numbers)))\n\
    \        (rescale_to_unit (cons smallest numbers)))))\n", "  (if (= (length numbers)\
    \ 2)\n      (cons (/ (car numbers) (cdr numbers))\n            (/ (car numbers)\
    \ (cdr numbers))))\n      (cons 0.0 (/ (car numbers) (cdr numbers)))\n  )\n)\n\
    </code>\n<|/ a dscore=0 tags=racket,scheme,lisp |>\n<| a |>\nHere's a recursive\
    \ solution using recursion and lambda expressions:\n<code>", "  (let loop ((numbers\
    \ (rest numbers)) (units (list 1.0))\n             (sum (apply + units)))\n  \
    \  (if (empty? numbers)\n        (reverse units)\n        (loop (rest numbers)\n\
    \               (cons 0 (apply / sum units))\n               (+ sum (apply + units))))))\n\
    </cell>\n<code language=racket-language>\n#lang racket\n", "  (define (rescale\
    \ x)\n    (/ (- x 1) (length numbers)))\n  (map (lambda (x) (rescale x)) numbers))\n",
  "  (let ([min (first numbers)]\n        [max (rest numbers)])\n    (let ([scaled\
    \ (let ([scaled (/ min max)])\n                   (lambda (x) (* x scaled))))]\n\
    \      (map scaled numbers))))\n", "  (let* ((min-max (min numbers numbers))\n\
    \         (min-max 1 (/ min-max 1.0)))\n    (map #(/ % min-max) numbers)))", " \
    \ (if (null? numbers)\n      '()\n      (let ((smallest (car numbers))\n     \
    \       (largest (caddr numbers)))\n        (cons (/ (- smallest largest) 2) (list\
    \ smallest largest))))))\n", "  (let* ((m (minimum numbers))\n         (n (maximum\
    \ numbers)))\n    (list 0.0 0.0 (/ (- n m) 2.0) 1.0)))\n", "  (cond [(empty? numbers)\
    \ '()]\n        [(<= (first numbers) (first numbers)) '()]\n        [else (cons\
    \ (/ (first numbers) (first numbers)) (rescale_to_unit (rest numbers)))]))\n",
  "  (let ([min (apply min numbers)\n        max-min\n        (apply max (reverse\
    \ numbers))\n        max-numbers (apply max numbers)])\n    (apply append\n  \
    \        [ (/ (- max-numbers) max-min) min\n            (/ (- max-numbers) max-min)\
    \ max-min\n            (/ (- max-numbers) max-min) max-min\n            (/ (-\
    \ max-numbers) max-min) max-min\n            (/ (- max-numbers) max-min) max-min\n\
    \            (/ (- max-numbers) max-min) max-min]\n          numbers)))\n", " \
    \ (let ([min-number (first numbers)])\n    (apply append\n          (map #(/ %\
    \ max-number) numbers)\n          (map #(* min-number %) (range)))\n  )\n)\n",
  "  (if (null? numbers)\n      '()\n      (cons (/ (- first (first numbers)) (- first\
    \ numbers)) \n            (rescale_to_unit (rest numbers)))))\n", "  (cond [(null?\
    \ numbers) '()]\n        [(< 0 (first numbers)) (cons (first numbers) (rescale_to_unit\
    \ (rest numbers)))]\n        [else (rescale_to_unit (rest numbers))]))\n", " \
    \ (if (< (length numbers) 2)\n      '()\n      (let ((min (car numbers))\n   \
    \         (max (cadr numbers)))\n        (cons 0 (- min max)\n              (/\
    \ max 1)\n              (apply (lambda (x) (* x max)) numbers)\n             \
    \ (apply (lambda (x) (* x max)) numbers)))))\n</cell>\n<code language=racket-student>\n\
    #lang racket\n", "  (let ((min-max-lengths (map (lambda (number) (- (min number)\
    \ max)) numbers)))\n    (apply (lambda (min-max-lengths)\n            (map divide-by-sum-of-largest-numbers\
    \ (append (take min-max-lengths 2) min-max-lengths))))))\n", "  (define (rescale\
    \ number)\n    (/ number 1.0))\n  (if (null? numbers)\n      '()\n      (if (<\
    \ (car numbers) (cadr numbers))\n          (cons (rescale (car numbers)) (recur\
    \ (cdr numbers)))\n          (cons (rescale (car numbers)) (rescale (cdr numbers))))))\n\
    \  \n  ;; Given list of numbers (of at least two elements), apply a linear transform\
    \ to that list,\n  ;; such that the smallest number will become 0 and the largest\
    \ will become 1\n  ;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0 5.0))\n  ;; (list\
    \ 0.0 0.25 0.5 0.75 1.0)\n  (rescale_to_unit numbers)\n", "  (define (helper numbers\
    \ accum min_x max_x)\n    (cond ((null? numbers) (list accum))\n          ((<\
    \ (first numbers) min_x) (helper (rest numbers) (cons accum (first numbers)) min_x\
    \ max_x))\n          ((> (first numbers) max_x) (helper (rest numbers) (cons accum\
    \ (first numbers)) (first numbers) max_x))\n          (else (helper (rest numbers)\
    \ (cons accum (first numbers)) (first numbers) (max min_x max_x)))))\n  (helper\
    \ numbers nil min max))\n", "  (apply (list min)\n         (map (lambda (n)\n\
    \                (/ (- n min) max min 1))\n              numbers)))\n", "  (cond\
    \ [(or (< 1 (car numbers)) (< 1 (cdr numbers)) (< (car numbers) (car numbers)))\
    \ (list (map min numbers) (map max numbers))]\n        [else (cons (/ (- (car\
    \ numbers) (min (car numbers))) (car numbers)) (remainder numbers (min (car numbers))))]))\n",
  "  (rescale_numbers (min-number) (max-number) numbers))\n", "  (apply append\n \
    \        (map (lambda (x) (min x 1.0) x)) numbers))\n", "  (let ((min (min numbers\
    \ numbers))\n        (max (max numbers numbers)))\n    (cond\n      [(null? min)\
    \ #true]\n      [(null? max) #false]\n      [(< min max) #false]\n      [(> min\
    \ max) #true]\n      [(< min min) #true]\n      [(> min min) #false]\n      [else\
    \ (map lcm/l (map - min max))]))", "  (let loop ([min-value min-element]\n   \
    \          [max-value max-element]\n             [list numbers])\n    (cond\n\
    \      ((null? list) list)\n      ((< (car list) min-element) \n       (loop (car\
    \ list) (min-value (car list)) max-value (cdr list)))\n      (else (loop (car\
    \ list) min-value (max max-element (car list)))\n             (loop (cdr list)\
    \ (max min-value (cdr list)) max-value (cdr list))))))\n", "  (let ([min (min\
    \ numbers)\n        max-min (- max (min numbers))]\n        [result (make-array\
    \ numbers (lambda (a b) (/ a b))))])\n    (for ([i numbers]\n          [a (i)]\n\
    \          [-b (- i)])\n      (set! (aref result a) (/ a b)\n            (= a\
    \ (min numbers))\n            (= b (max-min)))\n    result))\n", "  (/ (apply\
    \ + (map min-max-to-0-1 numbers)) 2))\n", '  (rescale_to_unit numbers (car numbers)
    (cadr numbers) (caddr numbers) (caddr (caddr numbers)) (caddr numbers) (cadr (caddr
    numbers))))', "  (let ((min (minimum numbers))\n        (max (maximum numbers)))\n\
    \    (/ min (- max min))\n    (map (fn n -> (- (/ n max) min)) numbers)))\n",
  "  (let ((min-value (min numbers))\n        (max-value (max numbers)))\n    (map\
    \ #(/ % max-value) numbers)))\n", "  (let ([min-number (first numbers)]\n    \
    \    [max-number (rest numbers)])\n    (if (empty? min-number) (list 0.0 1.0)\n\
    \        (let ([min-number (min-number)]\n              [max-number (max-number)])\n\
    \          (if (>= min-number max-number) (list (list 0.0 1.0) (list 1.0 1.0))\n\
    \              (let ([newmin (if (< max-number min-number) min-number max-number)]\n\
    \                    [newmax (- newmin min-number)])\n                (cons (list\
    \ 0.0 1.0) (rescale_to_unit (map #(* % newmin) numbers))))))))\n", "  (let ((min-value\
    \ (first numbers))\n        (max-value (last numbers)))\n    (check-type min-value\
    \ real)\n    (check-type max-value real)\n    (min-value / max-value))\n)\n",
  "  (let loop ((min-max (car numbers)) (result (car numbers))\n             (rest\
    \ (cdr numbers))\n             (max-min (min min min))\n             (result (min\
    \ (/ max-min 1) (min (/ max-min 2) (min (/ max-min 3) (min (/ max-min 4) max-min))))))\n\
    \    (if (null? rest)\n        result\n        (loop (min (min min-max max) max)\
    \ (min result (/ min-max result)) rest))))\n", "  (let ((max-val (foldr (lambda\
    \ (a b) (max a b)) (first numbers) (second numbers))))\n    (map (lambda (x)\n\
    \           (/ (- x max-val) max-val))\n         numbers)))\n", "  (cond [(number?\
    \ (car numbers))\n         (rescale_to_unit (map #(/ % 1) numbers))]\n       \
    \ [else\n         (cons (min (map #(/ % 1) numbers)) (rest (map #(* % 1.0) numbers)))]))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=scheme,racket,functional-programming dscore=0\
    \ |>\n<code>", "  (let* ((minimum (first numbers))\n         (maximum (last (rest\
    \ numbers)))\n         (step (/ 1 maximum)))\n    (map step\n         (lambda\
    \ (x)\n           (/ (- x minimum) step))\n         numbers)))\n", "  (if (< (length\
    \ numbers) 2)\n      (cons (car numbers)\n            (rescale_to_unit (cdr numbers)))\n\
    \      (cons (- 0 (car numbers))\n            (rescale_to_unit (cdr numbers)))))\n\
    </code>\n<code>\n#lang racket\n", "  (let ((min (first numbers))\n        (max\
    \ (last numbers)))\n    (if (and (null? (rest numbers)) (= min max))\n       \
    \ (list 0.0 1.0)\n        (if (< min max) (list 0.0 1.0)\n               (list\
    \ (- min) 1.0)))))\n", "  (if (null? (rest numbers))\n      (cons (car numbers)\
    \ (list (/ (car numbers) (min numbers))))\n      (let ((smallest (min numbers))\n\
    \            (largest (max numbers)))\n        (cons (car numbers)\n         \
    \     (list smallest (/ (car numbers) largest)\n                    (/ (car numbers)\
    \ smallest)\n                    (/ (car numbers) largest)\n                 \
    \   (/ (car numbers) smallest)\n                    (/ (car numbers) largest)))))\n\
    \      numbers))\n", "  (let ([min (min numbers)\n         max (max numbers)])\n\
    \    (map #(/ % 1.0) numbers\n         (listof min max))))\n", "  (define (helper\
    \ numbers)\n    (let loop ((numbers (reverse numbers))\n              (remainder\
    \ (reverse (modulo-remainder numbers 1)))\n              (temp 1))\n      (cond\
    \ ((null? (rest numbers)) (reverse (reverse remainder)))\n            ((null?\
    \ remainder)\n             (helper (rest numbers) (reverse (reverse (rest numbers)))))\n\
    \            (else\n             (loop (rest numbers)\n                    (rest\
    \ remainder)\n                    (* temp remainder))))))\n  (helper numbers))\n\
    </cell>\n<cell>\n#lang racket\n", "  (let ([min (first numbers)\n        * (apply\
    \ min numbers)]\n        (numbers (rest numbers)))\n    (apply append (map min\
    \ numbers)\n            (map / numbers))))\n", "  (if (null? numbers)\n      '()\n\
    \      (cons (min numbers)\n            (rescale_from numbers (- max numbers)))))\n",
  "  (apply append (map make-unit numbers numbers)))\n", "  (cond [(empty? numbers)\
    \ '()]\n        [(and (number? (car numbers)) (> (min numbers) 0)) '()]\n    \
    \    [else (cons 0 (map rescale_to_unit (rest (map number->double numbers))))]))",
  "  (let ((largest (car numbers)))\n    (let ((smallest (car numbers)))\n      (let\
    \ loop ((numbers (reverse numbers)))\n        (if (null? numbers)\n          \
    \  (list smallest largest)\n            (let ((x (car numbers)))\n           \
    \   (cond ((<= x largest) (loop (rest numbers)))\n                    (else (loop\
    \ (cons x (first numbers))))))))))\n", "  (rescale numbers (min numbers)\n   \
    \          (max numbers)))\n", "  (let ((min (apply min numbers))\n        (max\
    \ (apply max numbers)))\n    (cond [(< (abs min) 1.0)\n           (set! min 0.0)\n\
    \           (set! max 1.0)]\n          [(< (abs max) 1.0)\n           (set! min\
    \ 1.0)\n           (set! max 0.0)]\n          [(< min max)\n           (set! min\
    \ (abs min))\n           (set! max (abs max))]\n          [(< max min)\n     \
    \      (set! min (abs max))\n           (set! max (abs min))]\n          [(<=\
    \ max 1.0)\n           (set! min 0.0)\n           (set! max 1.0)]\n          [(<=\
    \ max 1.0)\n           (set! min 1.0)\n           (set! max 1.0)]\n          [else\n\
    \           (set! min (/ min max))\n           (set! max (/ max min))]\n     \
    \     [(<= min max)]\n          [else\n           (set! min (/ max min))\n   \
    \        (set! max (/ min max))]\n          [(> min max)]\n          [else\n \
    \          (set! min (/ max min))\n           (set! max (/ min max))]))\n  (apply\
    \ map 'list numbers))\n", "  (let ((smallest (min numbers)))\n    (map (lambda\
    \ (x)\n           (/ (- x smallest) largest))\n         numbers)))\n", "  (let\
    \ loop ((numbers (append numbers [number]))\n             (output (append output\
    \ (append (list 0) (list (- (car numbers) (car output)))))))\n    (if (< (length\
    \ numbers) 2)\n        (loop (cdr numbers) (cdr output))\n        (loop (cdr numbers)\
    \ output))))\n", "  (let loop ((min (min numbers)) (max (max numbers)))\n    (if\
    \ (< (min numbers) max)\n        (cons 0 numbers)\n        (cons 1 (loop (min\
    \ max) (max min)))))) ; recurse to get next interval\n", "  (if (null? numbers)\
    \ (list 1.0)\n      (let ((smallest (car numbers))\n            (largest (cdr\
    \ numbers)))\n        (append (cons 0.0 smallest)\n                (rescale_to_unit\
    \ (sub1 numbers))\n                (cons 1.0 largest))))))\n", "  (let ((min-max\
    \ (min numbers numbers)))\n    (map (\u03BB (x) (/ (- x min-max) max-min))\n \
    \        numbers)))\n", "  (if (null? numbers) '()\n      (let ((smallest (car\
    \ numbers))\n            (largest (caddr numbers)))\n        (cons (/ smallest\
    \ largest)\n               (rescale_to_unit (cdr numbers))))))\n", "  (cond [(null?\
    \ numbers) '()]\n        [(< (car numbers) 0) (cons (- 0 (car numbers)) (reverse\
    \  (rest (cdr numbers))))]\n        [else (reverse (cons (/ (car numbers) (car\
    \ numbers)) (reverse (rest (cdr numbers)))))]))\n", "  (rescale 1.0 numbers))\n",
  "  (let ([min (min numbers)\n        max (max numbers)])\n    (cond\n      [(= min\
    \ max) (numbers)]\n      [(not (= min max)) (cons 0 (map #(/ % 1) numbers))])))\n",
  "  (apply append (map (lambda (x) \n                       (map (lambda (y) (/ (-\
    \ y x) 1.0))\n                            numbers))\n                       numbers)))\n\
    \  ", '  (map rescale_to_unit numbers))', "  (define (rescale-min min)\n    (cond\
    \ ((< min 0)\n           (error \"Cannot rescale to zero\")))\n    (/ (min (first\
    \ numbers)) (+ (second numbers) (first numbers)))))\n  (define (rescale-max max)\n\
    \    (cond ((< max 0)\n           (error \"Cannot rescale to zero\")))\n    (/\
    \ (max (first numbers)) (+ (second numbers) (first numbers)))))\n  (cond ((empty?\
    \ numbers)\n         (error \"Cannot rescale empty list\"))\n        ((= (length\
    \ numbers) 1)\n         (rescale-max (first numbers)))\n        (else\n      \
    \   (let ((max-number (rescale-max (first numbers))))\n           (let ((min-number\
    \ (rescale-min (first numbers))))\n             (cons (/ (first numbers) max-number)\n\
    \                   (rescale-max numbers))))))))\n", "  (let loop ((numbers numbers)\
    \ (result '()))\n    (cond ((null? numbers) (reverse result))\n          ((< (first\
    \ numbers) 0) (loop (rest numbers) (cons (first numbers) result)))\n         \
    \ ((>= (first numbers) 1) (loop (rest numbers) (cons (first numbers) result)))\n\
    \          (else (loop (rest numbers)\n                     (cons (/ (first numbers)\
    \ (first result))\n                          result))))))\n", "  (let ((min-val\
    \ (min numbers)))\n    (map #(/ (- number min-val) max-val) numbers)))\n</code>\n\
    <|/ a tags=scheme,racket |>\n<| a |>\nA recursive solution:\n<code>", "  (let\
    \ ((min_int (car numbers))\n        (max_int (cdr numbers)))\n    (check-expect\
    \ (>= min_int 0)\n                 (= min_int 0))\n    (check-expect (>= max_int\
    \ 1)\n                 (= max_int 1))\n    (let loop ((nums numbers)\n       \
    \        (new-min (if (< nums min-int) (- min_int nums) min-int))\n          \
    \     (new-max (if (> nums max-int) (+ max_int nums) max-int))\n             \
    \  (ret '()))\n      (if (null? nums) (ret ret)\n          (let ((n (car nums))\n\
    \                (new-nums (if (< n new-min) (- n new-min) n))\n             \
    \   (new-nums (if (> n new-max) (+ n new-max) new-nums)))\n            (loop (cdr\
    \ nums) new-min new-max ret)\n            (loop new-nums new-min new-max ret))))))\n\
    \n", "  (if (null? numbers)\n      numbers\n      (let ((min (min numbers))\n\
    \            (max (max numbers)))\n        (map #'(lambda (x) (cond ((< x min)\
    \ 0) ((> x max) 1)) x)) numbers)))\n", "  (apply append (map #(/ % 1.0) (rescale\
    \ numbers))))\n", "  (/ (apply min numbers) (apply max numbers)))\n", '  (apply
    minmax numbers (min 0 (max 1 (apply min numbers)))))', "  (define (helper min\
    \ max current)\n    (if (> max min)\n        (cons 0 (helper (min max) current\
    \ current))\n        (cons current (helper (min max) (max min) current))))\n \
    \ (helper (min max) numbers (first numbers)))\n", "  (let ((smallest (first numbers))\n\
    \        (largest (rest numbers)))\n    (for/list ([num numbers]\n           \
    \   [smallest smallest]\n              [largest largest])\n      (if (< num largest)\n\
    \          (set! smallest 0)\n          (set! largest 1)))\n    (map #(/ num largest)\
    \ numbers)))\n", "  (let loop ((numbers (reverse numbers)) (result '()))\n   \
    \ (cond ((null? numbers) (reverse result))\n          ((< (car numbers) (min numbers))\n\
    \           (loop (cdr numbers) (cons (car numbers) result)))\n          (else\
    \ (loop (cdr numbers) (cons (car numbers) result))))))\n", "  (apply append\n\
    \         (map (lambda (x)\n                 (/ (- x 1) (- x 0) x))\n        \
    \      (map min numbers))))\n</code>\nThe last thing you might want to do is wrap\
    \ this in a function like so:\n<code>", "  (let ((min_num (first numbers))\n \
    \       (max_num (second numbers)))\n    (cond [(< min_num 0) 0]\n          [(>\
    \ max_num 1) 1]\n          [else (/ (- max_num min_num) 2)]))\n", "  (if (empty?\
    \ numbers)\n      (list 0.0)\n      (let ((smallest (car numbers))\n         \
    \   (rest (cdr numbers)))\n        (if (< smallest 1.0)\n            (cons (-\
    \ smallest 1.0) (rest))\n            (append (rest (map #(/ (- number 1.0) 2.0)\
    \ rest)))\n            (cons (- smallest 1.0) (rest))\n            (append (rest\
    \ (map #(/ number 2.0) rest)))\n            (cons (- smallest 1.0) (rest))\n \
    \           (append (rest (map #(/ number 2.0) rest)))))))\n", "  (assert (< (length\
    \ numbers) 2))\n  (define (loop (xs ys)\n             (when (> (length xs) 1)\n\
    \               (if (> (first xs) (first ys))\n                   (loop (rest\
    \ xs) (cons (first xs) ys))\n                   (loop (cons (first xs) ys) (rest\
    \ xs)))))\n    (loop numbers numbers))\n  (reverse\n   (map add1 \n        (map\
    \ modulo\n             (map max numbers)\n             (map min numbers))))\n",
  "  (let loop ((numbers (reverse numbers)) ; remember numbers in reverse order\n\
    \             (sum (first numbers))) ; current sum\n    (if (null? numbers) ;\
    \ base case\n        (list sum)\n        (loop (rest numbers) (+ (first numbers)\
    \ sum)))))\n", "  (cond [(null? (rest numbers)) numbers]\n        [(< (first numbers)\
    \ (first rest))\n         (rescale_to_unit (rest numbers))]\n        [else (cons\
    \ (/ (first numbers) (first rest)) (rescale_to_unit (rest numbers)))]\n      \
    \  )\n  )\n", "  (cond [(null? numbers) 0]\n        [else (min 0 (/ (reduce (lambda\
    \ (x y) (* (- x y) y)) numbers) 1.0))]))\n", "  (let ((smallest (min numbers))\n\
    \        (largest (max numbers)))\n    (cond ((< (- largest smallest) 0.0) (map\
    \ (\u03BB (n) (- n smallest)) numbers))\n          ((< smallest 0.0) (map (\u03BB\
    \ (n) (- n smallest)) numbers))\n          ((< largest 0.0) (map (\u03BB (n) (-\
    \ n smallest)) numbers))\n          (else (map (\u03BB (n) (/ (- n smallest) largest))\
    \ numbers)))))\n", "  (if (null? numbers)\n      numbers\n      (if (< (first\
    \ numbers) (last numbers))\n          (cons (/ (first numbers) (first numbers))\
    \ (rest (rescale_to_unit (rest numbers))))\n          (cons (/ (last numbers)\
    \ (first numbers)) (rest (rescale_to_unit (rest numbers))))))))\n", "  (cond [(null?\
    \ numbers) numbers]\n        [(< (car numbers) 1.0) (cons (car numbers) (rescale_to_unit\
    \ (rest numbers)))]\n        [(> 1.0 (car numbers)) (rescale_to_unit (rest numbers))]\n\
    \        [else (cons (car numbers) (rescale_to_unit (rest numbers)))]))\n", " \
    \ (apply apply (map (lambda (n) (/ n 2.0))\n                     (remove-duplicates\
    \ numbers))))\n", "  (let ((min-number min))\n    (let ((max-number max))\n  \
    \    (cond\n        (<?  numbers (list min-number max-number))\n        (<?  min-number\
    \ 0)\n        (<?  max-number 1))\n      (cond ((>= min-number 0)\n          \
    \   (/ (- min-number max-number) min-number))\n            (else 1))))))\n", " \
    \ (let ([x (reduce lambda (a b) (min a b)))]\n        (if (not (null? numbers))\n\
    \            (map + (map - numbers x))\n            (list 1.0))\n    (map / numbers)))\n",
  "  (cond [(null? numbers) numbers]\n        [(> (car numbers) (min numbers))\n \
    \        (map (lambda (x) (/ (- x 1.0) (min numbers))) numbers)]\n        [else\
    \ (cons (- (car numbers) (min numbers)) (reverse\n                           \
    \                 (rescale_to_unit (rest numbers))))]\n        ))\n", "  (define\
    \ x numbers)\n  (let loop ((acc '())\n             (numbers numbers))\n    (if\
    \ (null? numbers)\n        acc\n        (loop (append acc (list (min-of-infinity\
    \ (first numbers)) 0))\n               (rest numbers)))))\n", "  (rescale_minus_minus_one\
    \ (sub1 numbers)))\n", "  (let ((x (car numbers))\n        (y (/ 1.0 x)))\n  \
    \  (cond\n      [(null? numbers)\n       (list 1.0)]\n      [(< x y)\n       (list\
    \ (- x) 0)]\n      [(> x y)\n       (list x 1)]))))\n", "  (let ((minimum (reduce\
    \ min numbers))\n        (maximum (reduce max numbers)))\n    (map (\u03BB (n)\
    \ (/ (- n minimum) (- maximum))) numbers)))\n", "  (if (empty? numbers)\n    \
    \  numbers\n      (let ((smallest (car numbers)))\n        (rescale_to_unit (map\
    \ #(* smallest %) numbers)))))\n", "  (let ((min (if (null? (first numbers)) \n\
    \                   (first numbers) \n                   (first numbers))))\n\
    \    (map \n     (lambda (x) (/ (- x min) \n                     (- 1 (* min (first\
    \ numbers)))))\n     numbers)))\n", "  (cond [(empty? numbers) empty]\n      \
    \  [else (cons (min numbers)\n                   (rescale_to_unit\n          \
    \          (map (fn [n] (/ n 2.0))\n                           (take-last numbers\
    \ 2)))]))\n", "  (cond [(empty? numbers) numbers]\n        [(zero? first) numbers]\n\
    \        [(> first second) (cons 0 (rescale_to_unit (second)))]\n        [else\
    \ (cons first rescale_to_unit (second))]))\n", "  (if (= 1 (length numbers))\n\
    \      (first numbers)\n      (let ((min (car numbers))\n            (max (cdr\
    \ numbers)))\n        (apply (lambda (number)\n                 (/ number max))\n\
    \                (map #(* min (expt number %))\n                     numbers)))))\n",
  "  (cond [(null? numbers) numbers]\n        [(> (car numbers) 0.0) (map (lambda\
    \ (x) (- x 1.0)) numbers)]\n        [else (map (lambda (x) (- x 1.0)) numbers)]))\n",
  "  (if (null? numbers)\n      '()\n      (cons (min (map - numbers)) (map / numbers))))\n",
  "  (if (null? numbers)\n      '()\n      (let ([m (min-x numbers)])\n        (append\n\
    \         (map (lambda (x) (/ (- x m) m)) numbers)\n         (rescale_to_unit\
    \ (subseq numbers 1 (- (length numbers) 1)))))))\n", "  (define l (min numbers))\n\
    \  (define r (max numbers))\n  (map (lambda (x) (+ (/ x l) .5))) (cons l numbers))\n\
    )\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n    (cond\n\
    \      [(empty? numbers) (list 0.0 1.0)]\n      [(zero? min) (list 0.0 1.0)]\n\
    \      [(zero? max) (list 1.0 0.0)]\n      [(> min max) (list 1.0 0.0)]\n    \
    \  [else (list 0 1) (append (list (* (- max min) 0.5) (* (/ min max) 0.5)) numbers)])))\n",
  "  (define (iter xs x) (cond ((null? xs) (list->vector 0.0))\n                 \
    \             ((< (first xs) x) (iter (rest xs) x))\n                        \
    \      (else (iter (rest xs) (first xs))))))\n  (iter numbers numbers))\n", " \
    \ (let ((smallest (first numbers))\n        (largest (last numbers)))\n    (if\
    \ (< (length numbers) 2)\n        (append (map round numbers) (list 1))\n    \
    \    (append (map round (cons (- largest smallest) numbers)) (list 0)))))\n</code>\n\
    <|/ a |>\n<| a tags=lisp,scheme,math,algorithm,racket dscore=1 |>\nHere's an Racket\
    \ implementation:\n<code>\n#lang racket\n", "  [(min-max numbers min max) \n \
    \  (map (lambda (n) (/ n max-min)) numbers)])\n</code>\nAs you can see, this approach\
    \ gives the expected results:\n<code>\n> (rescale_to_unit (list 1.0 2.0 3.0 4.0\
    \ 5.0))", "  (apply map vector numbers))\n", "  (let ((min-value (car numbers))\n\
    \        (max-value (car (cdr numbers))))\n    (if (< min-value 0) (- min-value\
    \ 1) (/ max-value 2))))\n", "  (cond [(> (length numbers) 1) '()]\n        [(<\
    \ 1 (cadr numbers)) '()]\n        [else (map (lambda (n) (/ (min n 1) (max n 1)))\
    \ (rescale_to_unit (cddr numbers))))))\n", "  (let loop ((numbers numbers)\n \
    \            (result '()))\n    (if (null? numbers)\n        result\n        (let\
    \ ((smallest (car numbers))\n               (largest (cadr numbers)))\n      \
    \    (loop (cdr numbers)\n                (cons (/ (- smallest largest) 1.0) result)))))\n\
    </code>\n<|/ a dscore=2 tags=scheme,racket |>\n<| a tags=scheme,racket dscore=1\
    \ |>\nHere's another possible solution (without using any extra functions):\n\
    <code>", "  (min-max numbers (lambda (x) (/ x 1.0))))\n", "  (let ((x min-number\
    \ (rest numbers)))\n    (if (> x max-number) max-number x)))\n", "  (rescale_min_max\
    \ numbers (min (first numbers) max (first numbers)) (max (first numbers) (first\
    \ numbers))))\n", "  (cond\n    [(empty? numbers) empty]\n    [else (cons\n  \
    \         (/ (first numbers) max-value\n             (first numbers))\n      \
    \     (rescale_to_unit (rest numbers)))]))\n", "  (let loop ((numbers numbers)\n\
    \             (min (first numbers))\n             (max 1))\n    (if (null? numbers)\n\
    \        (reverse (list min))\n        (let ((n (first numbers)))\n          (if\
    \ (<= n max)\n              (loop (rest numbers) n max)\n              (loop (rest\
    \ numbers) min (- n max)))))))\n", "  (rescale_to_unit' numbers 1 0))\n", "  (if\
    \ (null? numbers)\n      '()\n      (cons (min numbers 1.0) (/ (max numbers 1.0)\
    \ 1.0) numbers)))\n", "  (cond\n    ((empty? numbers) nil)\n    ((= (length numbers)\
    \ 2) numbers)\n    (else\n     (let ([smallest (first numbers)\n             largest\
    \ (first numbers)])\n       (let ([newLargest (* (* (first numbers) (first numbers))\
    \ largest)\n              newSmallest (- (* (first numbers) (first numbers)) smallest)])\n\
    \        (cons (/ newSmallest newLargest) (rescale_to_unit (rest numbers)))))))))\n",
  "  (apply append (map min-max numbers numbers)))\n", "  (define (helper acc x)\n\
    \    (cond\n      [(empty? x) (list (cons 0 (min acc (max acc 1.0))) (max acc))]\n\
    \      [(< (first x) acc) (cons (first x) (helper (first x) (first x)))]\n   \
    \   [else (cons (first x) (helper (second x) (first x)))]\n      ))\n  (helper\
    \ numbers numbers))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (map #(/ (- %1 min) max) numbers)))", "  (if (empty? numbers) '()\n     \
    \ (cons (min numbers) (rescale_to_unit (map max numbers)))))\n", "  (let* ([minval\
    \ (min numbers)\n         maxval (max numbers)])\n    (if (zero? minval)\n   \
    \     minval\n        (/ minval maxval))))\n", "  (cond\n    ((null? numbers)\
    \ '())\n    ((null? (cdr numbers)) numbers)\n    ((< (first numbers) (first numbers))\
    \ numbers)\n    ((> (first numbers) (first numbers)) (list (first numbers)) numbers)\n\
    \    (else (cons (/ (- first (first numbers)) (first numbers)) numbers))))\n",
  "  (cond ((null? numbers) numbers)\n        ((>= (first numbers) 0) (map (lambda\
    \ (n) (/ n 2)) numbers))\n        (else (map #(* 0.5 #) numbers))))\n", "  (map\
    \ + (map min numbers) (map max numbers)))\n</code>\n<|/ a |>\n<| a |>\nAs was\
    \ already said in the comments, you can simply map a pair of min and max to the\
    \ list, and use that to map a function to each element in the list, and get a\
    \ new list.\n<code>", "  (let loop ((numbers numbers)\n             (current (car\
    \ numbers))\n             (current (* current 1.0))\n             (count (cdr\
    \ numbers)))\n    (if (null? numbers)\n        (list current)\n        (let ((next\
    \ (loop (cdr numbers) (* current 1.0) (add1 count))))\n          (cons next numbers)))))\n",
  "  (let loop ((min (min numbers)) (max-min (max numbers)))\n    (cond ((<= min max-min)\
    \ (list min))\n          ((< max-min min) (list max-min))\n          ((<= min\
    \ max) (list max))\n          ((> max-min min) (list min))\n          ((< max-min\
    \ max) (list max-min))\n          (else (cons (- min max-min) (loop (- max-min\
    \ min) max))))))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (rescale_list (lambda (x y)\n                    (/ (- (- x min) (- y min))\
    \ (- max max))))\n                 numbers\n                 min\n           \
    \      max)))", "  (let ((min (car numbers))\n        (max (caddr numbers)))\n\
    \    (map (lambda (x) (/ x max))\n         (map - numbers))\n    (map + (map -\
    \ numbers))\n    (* min (/ 1.0 max))))\n", "  (apply + (map lcm (map - numbers\
    \ numbers))))\n</code>\n<|/ a tags=scheme,racket,math |>\n<| a dscore=0 |>\nHere\
    \ is a solution using foldl and gcd.\n<code>", "  (apply append\n         (map\
    \ (lambda (x) (/ x 100)) (min_max numbers))))\n", "  (let ((max-val (car numbers)))\n\
    \    (let ((min-val (car numbers)))\n      (map #(/ % max-val) numbers)\n    \
    \  (map #(* % max-val) numbers)\n      numbers))\n</cell>\n<cell>\n#lang racket\n",
  "  (cond [(null? numbers)\n         numbers]\n        [(< (first numbers) (first\
    \ numbers))\n         (cons (first numbers) (rescale_to_unit (rest numbers)))]\n\
    \        [(> (first numbers) (first numbers))\n         (cons (first numbers)\
    \ (rescale_to_unit (rest numbers)))]\n        [else (cons (first numbers) (rescale_to_unit\
    \ (rest numbers)))]\n  )\n)\n", "  (let ([min-value (first numbers)\n        \
    \ max-value (second numbers)])\n    (lambda (n)\n      (let ([diff (- n min-value)])\n\
    \        (if (< diff max-value)\n            (/ diff max-value)\n            (/\
    \ diff min-value))))))\n", "  (/ (apply min numbers) (apply max numbers)))\n",
  "  (map (lambda (n)\n         (min 0.0 1.0 (/ n 2.0)))\n       numbers))\n", " \
    \ (let ((min (first numbers))\n        (max (second numbers)))\n    (map + (map\
    \ '/ numbers (- max min)) numbers)))\n", "  (if (empty? numbers) numbers\n   \
    \ (let ([min (min numbers)])\n      (cons (/ (- min (first numbers)) 1.0) \n \
    \           (rescale_to_unit (rest numbers))))))\n", "  (define min-number (car\
    \ numbers))\n  (define max-number (cadr numbers))\n  (define (rescale-to-unit\
    \ n)\n    (if (= n min-number) (/ n max-number)\n        (/ 1 n)))\n  (map rescale-to-unit\
    \ numbers))\n", "  (if (list? numbers)\n      (let ((min-value (min numbers numbers))\n\
    \            (max-value (max numbers numbers)))\n        (map (fn [x] [(- x min-value)\
    \ (/ x max-value)])\n             numbers))\n    (let ([min-value (min numbers\
    \ numbers)]\n          [max-value (max numbers numbers)])\n      (map #(/ (- %\
    \ min-value) (- % max-value)) numbers))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    What if I have a list of numbers? For example: `(map #(/ (- % 0.0) (- % 1.0))\
    \ [1.0 2.0 3.0 4.0 5.0])` => `[-0.0 0.25 0.5 0.75 1.0]`\n<|/ c |>\n<| c |>\nThe\
    \ function I gave you converts *any* list of numbers to an array of scaled numbers.\
    \ Your example is a list of numbers. `map` applies a function to each element\
    \ of a list, so `(map #(/ (- % 0.0) (- % 1.0) numbers numbers)` converts a list\
    \ of numbers to an array of scaled numbers.\n<|/ c |>\n<| c |>\n: It would be\
    \ nice if you could provide a solution that doesn't rely on [the function I gave\
    \ you](http://stackoverflow.com/questions/16591472/converting-from-absolute-to-relative-position-on-a-graph-in-racket).\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is an answer to an earlier question, that has\
    \ received some interesting answers. It is meant to be an alternative to the solution\
    \ offered by Chris Dillon - a solution using mutability. However, it can be easily\
    \ made to work in place:\n<code>", "  (let ((min (apply min numbers))\n      \
    \  (max (apply max numbers)))\n    (cond ((< min max) numbers)\n          ((>\
    \ (+ min (* 0.6 max)) max) numbers)\n          ((> (+ min (* 0.7 max)) max) numbers)\n\
    \          ((> (+ min (* 0.8 max)) max) numbers)\n          ((> (+ min (* 0.9\
    \ max)) max) numbers)\n          (else (cons (/ (- max min) max) (rescale_to_unit\
    \ (- numbers min)))) ) ) ) ;; #lang racket\n", "  (if (null? numbers)\n      '()\n\
    \      (cons (/ (apply min numbers) (apply max numbers)) (rescale_to_unit (map\
    \ #(* 1.0 %) numbers)))))\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI believe that\
    \ a simple solution to this, is to use map and map.\nThis would look like this:\n\
    <code>", "  (cond\n    [(empty? numbers) '()]\n    [(= (first numbers) 0.0) (cons\
    \ (first numbers) (rescale_to_unit (sub1 numbers)))]\n    [else (cons (/ (first\
    \ numbers) (first numbers)) (rescale_to_unit (sub1 numbers)))]))\n</code>\nThe\
    \ above uses only standard Racket features: cond, map, fold, if, and, or, not,\
    \ eq? and assoc, so they're all available in Racket and any modern programming\
    \ language.  For those that don't have these, here are the implementations for\
    \ cond, map and fold in Racket as well.\n<code>\n#lang racket\n", "  (rest\n \
    \  (min (map first numbers)\n        (map last numbers))))", "  (if (or (number?\
    \ numbers) (< 0 (length numbers)))\n      '()\n      (if (< (length numbers) 1)\n\
    \          (cons (/ (car numbers) (min (length numbers) 2))\n                (rescale_to_unit\
    \ (rest numbers)))\n          (cons (/ (car numbers) (length (rest numbers)))\n\
    \                (rescale_to_unit (rest numbers))))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThe question wasn't about finding a way to multiply the numbers\
    \ in a list by 10, but rather how to divide the smallest number in a list by 10\
    \ when the list contains at least two numbers. The question also doesn't specify\
    \ what the result should look like.\n<|/ c |>\n<| c |>\nAh sorry about that. Thought\
    \ the question was more like \"How do I divide by a factor of ten when the numbers\
    \ don't sum to one\"\n<|/ c |>\n<| c |>\nBut it turns out that the example given\
    \ does actually add up to one, so I guess it wasn't the question that was asked.\n\
    <|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nI think this should work:\n<code>",
  "  (let ((min-value (minimum numbers))\n        (max-value (maximum numbers))\n\
    \        (diff max-value min-value))\n    (cond\n      [(<= min-value 0.0) 0.0]\n\
    \      [(<= diff 0.0) 1.0]\n      [else (/ (- (- (/ (- max-value min-value) diff)\
    \ 1.0) 1.0) 2.0)]\n      )))\n</code>\n<|/ a tags=racket,scheme,math dscore=2\
    \ |>\n<| a tags=racket,scheme,math dscore=1 |>\nIf you have a Scheme implementation\
    \ that includes R6RS, you can use the following code:\n<code>\n#lang racket",
  "  (define min-max min/max numbers)\n  (if (and (null? numbers) (null? min-max))\n\
    \      '()\n      (cons (+ (/ (- min-max min) 2) 0)\n            (rescale_to_unit\
    \ (- numbers min-max))))))\n", "  (let ((min (if (< (car numbers) (cadr numbers))\
    \ (cadr numbers) (car numbers))))\n        (max (if (> (cadr numbers) (cadr numbers))\
    \ (cadr numbers) (car numbers))))\n    (if (= min max) numbers\n        (append\
    \ (list (/ (car numbers) (- max min)) (- min max))\n                (rescale_to_unit\
    \ (rest numbers))))))\n", "  (if (empty? numbers)\n      '()\n      (cons (* (floor\
    \ (car numbers))\n               (max (- (cdr numbers) (min (list (car numbers))))\n\
    \                    1.0))\n            (rescale_to_unit (cdr numbers)))))\n",
  "  (define (helper xs acc)\n    (cond [(empty? xs) acc]\n          [(< (first xs)\
    \ (first acc)) (helper (rest xs) (cons (first acc) (first xs)))]\n          [else\
    \ (helper (rest xs) (cons (first xs) acc))]))\n  (helper (reverse numbers) '()))\n",
  "  (define (find min max (numbers))\n    (cond\n      [(empty? numbers) min]\n \
    \     [(<= (first numbers) min) min]\n      [(< max (first numbers)) max]\n  \
    \    [else (min (/ (first numbers) max) (find min max (rest numbers))) ]))\n \
    \ (define (rescale numbers min max)\n    (cond\n      [(empty? numbers) numbers]\n\
    \      [(<= (first numbers) min) min]\n      [(<= (first numbers) max) (rescale\
    \ (rest numbers) (min (first numbers)) (max (first numbers))) ]\n      [else (rescale\
    \ (rest numbers) (min (first numbers)) (max (first numbers))) (+ (first numbers)\
    \ (min (first numbers)) ) ]))\n  (rescale numbers 0.0 1.0))\n", "  (apply append\n\
    \         (map (lambda (x) (/ x 2.0))\n              (min_max_element numbers\n\
    \                             (lambda (x) (/ x 2.0))))))\n", "  (let ((smallest\
    \ #f))\n    (if (null? numbers)\n        (list numbers)\n        (let ((smallest\
    \ (car numbers)))\n          (define (helper numbers smallest largest)\n     \
    \       (if (null? numbers)\n                (list smallest)\n               \
    \ (let ((next (car numbers)))\n                  (if (< smallest largest)\n  \
    \                    (helper (cdr numbers) smallest next)\n                  \
    \    (helper (cdr numbers) next largest))))\n              (helper (cdr numbers)\
    \ smallest largest)))))\n    (rescale_to_unit (helper numbers smallest smallest)\
    \ smallest smallest)))\n</code>\nEDIT: This answer has been posted after this\
    \ question was answered. It has now been updated to account for both ascending\
    \ and descending scaling.\n<|/ a dscore=4 tags=functional-programming,scheme,racket,lisp,lispwork\
    \ |>\n<| a tags=functional-programming,scheme,racket,lisp,lispwork dscore=3 |>\n\
    If you want a more generalized function that will work with any function which\
    \ has a zero return and whose domain is non-negative, you could try the following:\n\
    <code>", "  (let loop ([minval numbers '()] result)\n    (if (empty? numbers)\n\
    \        result\n        (loop\n           (first numbers)\n           (cons (min\
    \ 0 (/ (first numbers) (first minval))) (loop (rest numbers) (cons (max 0 (/ (first\
    \ numbers) (first minval))) result)))))))\n", "  (let loop ([numbers numbers]\n\
    \             [min (apply min numbers)]\n             [max (apply max numbers)])\n\
    \    (if (empty? numbers)\n        (list min) (append (reverse(loop (rest numbers)\
    \ min max)) (list max)))))\n", "  (let ((min (car (min numbers))))\n    (let ((max\
    \ (cadr (max numbers))))\n      (apply append (map (lambda (n) (/ n max)) numbers)))))\n",
  "  (let ((smallest (car numbers))\n        (largest (cdr numbers)))\n    (cond ((<\
    \ smallest largest)\n           (cons smallest numbers))\n          ((> smallest\
    \ largest)\n           (cons largest (rescale_to_unit numbers)))))\n  ", "  (rescale_to_include\
    \ numbers (min numbers) (max numbers)))\n", "  (let ([min-number (min numbers\
    \ numbers)\n         max-number (max numbers numbers)])\n    (map (\u03BB (x)\
    \ (/ (- x min-number) max-number)) numbers)))\n", "  (let ([min-number (min numbers)\n\
    \        max-number (max numbers)])\n    (if (= min-number max-number)\n     \
    \   (cons 0.0 numbers)\n        (cons (- max-number) (reverse-map min-number numbers)))))",
  "  (if (empty? numbers)\n      (cons 0.0 1.0)\n      (let ((smallest (car numbers))\n\
    \            (largest (car numbers)))\n        (cons (/ (- smallest largest) 1)\
    \ (rescale_to_unit (rest numbers))))))\n", "  (apply map numbers (map minmax (map\
    \ max numbers) (map min numbers))))\n", "  (let loop ((res numbers) (min numbers)\n\
    \             (max numbers))\n    (if (null? res)\n        res\n        (loop\
    \ (cdr res) (min (car res)) max))))\n", "  (/ (apply + (map min numbers)) (apply\
    \ + (map max numbers))))\n", "  (let ([smallest (min-number numbers)\n       \
    \  largest (max-number numbers)\n         zero-point])\n    (if (< (- largest\
    \ smallest) zero-point)\n        (list zero-point)\n        (let ([x (- (/ smallest\
    \ zero-point) zero-point)\n              y (/ smallest zero-point)])\n       \
    \   (list (- x zero-point) (- y zero-point))))))\n", "  (let loop ([numbers numbers]\n\
    \             [min (apply min numbers)]\n             [max (apply max numbers)])\n\
    \    (cond\n      [(empty? numbers) (list 0.0 1.0)]\n      [(< min max) (list\
    \ 0.0 1.0)]\n      [else (cons (/ (- min max) 1.0) (loop (rest numbers) (* min\
    \ max) max))])))\n", "  (define (min-max x)\n    (min x max))\n  (define (scale-map\
    \ map from to)\n    (apply map from))\n  (scale-map (lambda (x y)\n          \
    \    (min (min-max x) (min-max y)))\n             numbers\n             (map numbers\n\
    \                  numbers\n                  numbers\n                  numbers)\n\
    \             numbers))\n", "  (cond [(zero? numbers)\n         numbers]\n   \
    \     [(list? numbers)\n         (cons (rescale_to_unit (first numbers))\n   \
    \            (rescale_to_unit (rest numbers)))]\n        [(< numbers (first numbers))\n\
    \         (cons (first numbers)\n               (rescale_to_unit (- numbers numbers)))]\n\
    \        [else\n         (cons (/ numbers 1.0)\n               (rescale_to_unit\
    \ (- numbers 1.0)))]))\n", "  (if (empty? numbers)\n      '()\n      (let ((min\
    \ (car numbers)))\n        (if (< min (first numbers))\n            (rescale_to_unit\
    \ (cons min (rest (reverse numbers))))\n            (rescale_to_unit (cons 0 (reverse\
    \ (cons (first numbers) numbers)))))))\n", "  (cond [(null? numbers)\n       \
    \  (error \"Expected a non-empty list.\")]\n        [else\n         (let ([(smallest\
    \ . largest) (min-max numbers)])\n           (cond (min-max? smallest largest)\n\
    \                   (map normalize numbers)\n                   (cons smallest\
    \ numbers)\n                   (cons largest numbers)\n                   (rescale_to_unit\
    \ (map normalize (subseq numbers 1 (length numbers))))))])\n        ))", "  (let\
    \ ((min (min numbers numbers))\n        (max (max numbers numbers)))\n    (cond\n\
    \      [(> min max) 0]\n      [else 1])))\n", "  (rescale_to_unit numbers 1.0\
    \ 1.0))\n", "  (let loop ((numbers numbers)\n             (units ()\n        \
    \      (if (null? numbers)\n                  0\n                  (let ((number\
    \ (car numbers)))\n                    (cons number (loop (cdr numbers)\n    \
    \                                (cons (+ (min number) (max number)) units)))))))\n\
    \    (loop numbers units)))\n", "  (let loop ((min (first numbers)) (max (second\
    \ numbers))\n             (result (rest (rest numbers))))\n    (if (null numbers)\n\
    \        result\n        (loop (min (first result)) max (rest result)\n      \
    \         (cons (/ (first result) max) result)))))\n", "  (let ([min-number (min-element\
    \ numbers)\n        max-number (max-element numbers)])\n    (map (lambda (n) (/\
    \ (+ 0.0 n) max-number)) numbers)))\n", "  (let ((min-num (first numbers))\n \
    \       (max-num (second numbers)))\n    (cond\n      [(< min-num (/ max-num 1.0))\n\
    \       (/ min-num 1.0)]\n      [else (/ max-num 1.0)]\n      )))\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nPlease consider adding comments or explanation to your\
    \ code. Code-only answers are generally not very useful.\n<|/ c |>\n<| c |>\n\
    I added some explanation, thanks for that.\n<|/ c |>\n<| c |>\nI suggest you add\
    \ some explanation to your answer, to show how it answers the question.\n<|/ c\
    \ |>\n<| a tags=scheme,racket |>\nI came up with the following solution. It uses\
    \ Racket's list-min and list-max. This will work with any sequence of numbers\
    \ with at least two elements. It just takes the minimum of the first and second\
    \ elements and divides everything by the minimum of the list.\n<code>", "  (apply\
    \ map (lambda (x) (x * (/ 1 x))) numbers))\n", "  (rescale numbers min-num max-num))\n",
  "  (define (rescale number amount)\n    (/ number amount))\n  (define (min a b)\n\
    \    (if (< a b)\n        a\n        b))\n  (define (max a b)\n    (if (< a b)\n\
    \        b\n        a))\n  (define (rescale-list l)\n    (if (> (length l) 2)\n\
    \        numbers)\n    (let ((min (min (car l) (min (cdr l) 0))))\n      (let\
    \ ((max (max (car l) (max (cdr l) 1))))\n        (map (lambda (x) (rescale x 1.0\
    \ / (max-min))))\n        (rescale-list (cdr l)))))\n  (rescale-list numbers))\n",
  "  (car (apply append\n             (map (lambda (x) (/ x 100.0))\n            \
    \      (take (length numbers) numbers))\n             numbers)))\n", "  (rescale_helper\
    \ (min numbers 1) (max numbers 1)))\n", "  (let loop ((min-max '(min -inf)) (min/max-delta\
    \ '(-inf 0))\n            (found #f) (min -inf) (max +inf) (lst numbers))\n  \
    \  (cond\n      ((null? lst) lst)\n      ((<= (length lst) 2) (list lst '() '()))\n\
    \      ((not (< min max)) (error \"out of range!\"))\n      (else\n        (let\
    \ ((l1 (car lst))\n              (l2 (cadr lst)))\n          (if (null? l1) (error\
    \ \"empty list!\")\n              (let ((delta 0)\n                    (x 0))\n\
    \                (cond\n                  ((> (car min) (car max)) (error \"out\
    \ of range!\"))\n                  ((< car min) (error \"negative numbers not\
    \ allowed!\"))\n                  ((< car max) (loop (cons (car min) min/max-delta)\
    \ (car min) max l1))\n                  ((= (car min) (car max)) (error \"cannot\
    \ divide by zero!\"))\n                  ((< (car min) l1) (loop (cons (- delta)\
    \ (/ (car min) l1)\n                                               (* (car min)\
    \ l1) (car max) l2))\n                  ((= (car min) l1) (loop (cons (- delta)\
    \ (/ (car min) l1) (car max) l2)\n                                          (cons\
    \ l1 min/max-delta))\n                  ((> (car max) l1) (loop (cons (- delta)\
    \ (/ (car min) l1) (car max) l2)\n                                          (cons\
    \ l1 min/max-delta) (cons l2 min/max-delta))\n                  ((< (car max)\
    \ l1) (loop (cons (- delta) (/ (car max) l1) (car min) l2)\n                 \
    \                         (cons l1 min/max-delta) (car min) l2))\n           \
    \       ((= (car max) l1) (loop (cons (- delta) (/ (car max) l1) (car min) l2)\n\
    \                                          (cons l1 min/max-delta) (car min) l2)\n\
    \                  ((< (car max) l1) (loop (cons (- delta) (/ (car min) l1) (car\
    \ max) l2)\n                                          (cons l1 min/max-delta)\
    \ (cons l2 min/max-delta))\n                  ((= (car max) ", "  (define (rescale-to-unit\
    \ numbers)\n    (let* ((smallest (first numbers))\n           (largest (last numbers))\n\
    \           (minus largest)\n           (divided largest))\n      (if (< smallest\
    \ minus)\n          (rescale-to-unit (remove smallest numbers))\n          (rescale-to-unit\
    \ (cons minus divided)))))\n  (rescale-to-unit numbers))\n", "  (let ((min (first\
    \ numbers)))\n    (apply (lambda (numbers)\n             (map (lambda (x) (/ x\
    \ max))\n                  (filter (lambda (x) (< x min)) numbers)))\n       \
    \    numbers)))\n", "  (let loop ((numbers numbers) (min 0) (max 1))\n    (if\
    \ (null? numbers)\n        (list max)\n        (if (< (first numbers) min)\n \
    \           (loop (rest numbers) (first numbers) max)\n            (loop (rest\
    \ numbers) min (max max)))))\n  (values (loop (rest numbers) min max)))\n", " \
    \ (naive-min-max (map natural-ratio numbers) numbers))\n", "  (rest (reduce +\
    \ (map min/max numbers))))\n", "  (let ([min (min numbers)\n        scale (/ 1.0\
    \ max (max numbers))])\n    (map (\u03BB (n) (* n scale)) numbers)))\n", "  (apply\
    \ rescale numbers 1.0 (lambda (x) (/ x 1.0))))\n", "  (if (empty? numbers)\n \
    \     '()\n      (let ((smallest (min numbers)))\n        (rescale_to_unit (map\
    \ #(- % smallest) numbers)))))\n", "  (let loop ((min-max min-max) (numbers numbers)\n\
    \           (result (list 0.0 0.0)))\n    (cond\n      [(empty? numbers)\n   \
    \    result]\n      [(< (first numbers) (first min-max))\n       (loop (first\
    \ min-max)\n             (rest numbers)\n             (cons (first min-max) result))]\n\
    \      [else\n       (loop (first min-max)\n             (rest numbers)\n    \
    \         (cons (/ (first numbers) (first min-max))\n                    (loop\
    \ (first min-max)\n                          (rest numbers)\n                \
    \          (cons (first min-max) result))))])))\n</code>\nThe trick is that we\
    \ use the minimum and maximum elements as the limits of our linear transform.\n\
    Then we keep recursing on the list with the numbers in between.\nNote that the\
    \ smallest number will become 0 and the largest will become 1\n<|/ a dscore=4\
    \ |>\n<| c |>\nI think you can use the min and max functions to get the min and\
    \ max values, as shown in the code above. Also I think the second `cond` should\
    \ be `[else` (or maybe `elseif` since the first branch is always reached)\n<|/\
    \ c |>\n<| c |>\n, yes, thanks! I updated the answer accordingly.\n<|/ c |>\n\
    <| a tags=scheme,racket |>\nYou can use the built-in min and max functions in\
    \ Racket. Try this:\n<code>", "  (min-max\n   (map (lambda (num)\n          (if\
    \ (less-than 0 num) (/ num 2))\n          (- num 1))\n       numbers)))", "  (let\
    \ ((min (car numbers))\n        (max (cdr numbers)))\n    (map \n     (lambda\
    \ (x) (* x (min max)))\n     numbers)))\n", "  (let*\n      ((min (minimum numbers))\n\
    \       (max (maximum numbers)))\n    (map (lambda (x) (- x min)) numbers)))\n",
  "  (let ((min-value (min numbers)))\n    (let ((max-value (max numbers)))\n    \
    \  (cond ((< min-value max-value) (cons min-value (map #(- % 1) numbers)))\n \
    \           ((> min-value max-value) (cons max-value (map #(+ % 1) numbers)))\n\
    \            (else numbers)))))\n", "  (let loop ((min (min numbers))\n      \
    \       (max (max numbers)))\n    (cond ((< min max) numbers)\n          ((< max\
    \ min) (cons min (rescale_to_unit (- max min)))) ; min\n          ((>= min max)\
    \ (cons max (rescale_to_unit (- min max))))) ; max\n    (loop (min max))))\n</code>\n\
    <|/ a dscore=2 tags=racket,list,recursion,scheme |>\n<| c |>\nThis answer looks\
    \ very close to mine, +1.\n<|/ c |>\n<| a dscore=1 tags=racket,list,recursion,scheme\
    \ |>\nThis is an alternative solution that uses foldr instead of recursion, which\
    \ is sometimes more efficient:\n<code>", "  (let ((min (min numbers))\n      \
    \  (max (max numbers)))\n    (map (lambda (n)\n           (/ (- n min) max))\n\
    \         numbers)))\n", "  (if (null? numbers)\n      '()\n      (let ((smallest\
    \ (first numbers))\n            (largest (last numbers)))\n        (cons (/ (-\
    \ smallest largest) 2)\n              (rescale_to_unit (rest numbers))))))\n",
  "  (let ([(min (car numbers)) 0]\n        [(max (car numbers)) 1]\n        [(sum\
    \ (cdr numbers)) 0]\n        [(product (cdr numbers)) 1])\n    (cons (/ (- sum\
    \ max) product)\n          (for ([i numbers]\n                 [sum (+ (* i sum)\
    \ (* i max))\n                  product (* i product)])\n            (cons (-\
    \ sum min) i)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
