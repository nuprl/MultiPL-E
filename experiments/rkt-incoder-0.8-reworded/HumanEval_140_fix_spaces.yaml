name: HumanEval_140_fix_spaces
language: rkt
prompt: "#lang racket\n\n;; Given a string text, replace all spaces in it with underscores,\
  \ \n;; and if a string has more than 2 consecutive spaces, \n;; then replace all\
  \ consecutive spaces with - \n;; >>> (fix_spaces \" Example\")\n;; \"Example\"\n\
  ;; >>> (fix_spaces \" Example 1\")\n;; \"Example_1\"\n;; >>> (fix_spaces \" Example\
  \ 2\")\n;; \"_Example_2\"\n;; >>> (fix_spaces \" Example 3\")\n;; \"_Example-3\"\
  \n(define (fix_spaces text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fix_spaces))\n\
  \    (check-equal? (candidate \"Example\") \"Example\")\n    (check-equal? (candidate\
  \ \"Mudasir Hanif \") \"Mudasir_Hanif_\")\n    (check-equal? (candidate \"Yellow\
  \ Yellow  Dirty  Fellow\") \"Yellow_Yellow__Dirty__Fellow\")\n    (check-equal?\
  \ (candidate \"Exa   mple\") \"Exa-mple\")\n    (check-equal? (candidate \"   Exa\
  \ 1 2 2 mple\") \"-Exa_1_2_2_mple\")\n))\n\n(test-humaneval)"
completions: ["  (let ([result (make-string-builder text 10)])\n    (cond [(empty?\
    \ text) result]\n          [(string=? (car text) \" \")\n           (cond\n  \
    \            [(< (length (car text)) 2)\n               (cond [(< (length (cadr\
    \ text)) 2)\n                      (append-builder (string->char (string->list\
    \ \" -\")\n                                          (cadr text) result)]\n  \
    \                      [else result])]\n              [else (append-builder (string->char\
    \ (string->list \" -\")\n                                           (car text)\
    \ result)]\n                        [fix_spaces (cdr text)])])]\n          [else\
    \ (append-builder (string->char (string->list \"-\")\n                       \
    \                  (car text) result)]\n                    [fix_spaces (cdr text)])]\n\
    \    [else result]))\n", "  (define (helper text space index)\n    (cond\n   \
    \   [(empty? space) text]\n      [(= index 0) (if (string=? (car space) #\\Space)\
    \ (car space) (cons (car space) (helper (cdr text) space (+ 1 index))))]\n   \
    \   [else\n       (helper (cdr text) space (+ 1 index))]))\n  (helper (string->list\
    \ text) #\\Space 0))\n", "  (define (loop (text string result)\n    (cond\n  \
    \    [(string-length? string 0) result]\n      [(equal? text (string 0 0))\n \
    \      (cond\n         [(equal? result \"\")\n          (cond\n            [(string-length\
    \ string > 2)\n             (loop (string \"-\" (substring string 1 2))\n    \
    \            (cond\n                  [(equal? result \"\") (loop (string \"-\"\
    \ text) result)]\n                  [(equal? result \"_\") (loop (string \"-\"\
    \ text) result)]\n                  [(equal? result \"_Example\") (loop (string\
    \ \"-\" text) result)]\n                  [(equal? result \"Example\") (loop (string\
    \ \"-\" text) result)]\n                  [(equal? result \"Example1\") (loop\
    \ (string \"-\" text) result)]\n                  [(equal? result \"Example2\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example3\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example4\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example5\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example6\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example7\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example8\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example9\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example10\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example11\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example12\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example13\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example14\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example15\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example16\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example17\"\
    ) (loop (string \"-\" text) result)]\n                  [(equal? result \"Example18",
  "  (cond\n    [(empty? text)  '()]\n    [(= (length text) 1) (list text)]\n    [(=\
    \ (length text) 2) (cons (substring (text 0) 1) (list (substring (text 1) 0)))]\n\
    \    [(substring (text 0) 0) (cons (substring (text 0) 0) (list (substring (text\
    \ 0) 1)))]\n    [else (cons (substring (text 0) 0) (fix_spaces (substring (text\
    \ 1) 0)))]))\n</code>\n<|/ a tags=racket,scheme,functional-programming |>\n<|\
    \ a tags=racket,scheme,functional-programming |>\nThe simplest solution is to\
    \ use the \"cons\" operator:\n<code>", "  (cond\n    [(empty? text) \"\"]\n  \
    \  [(or (char=? #\\Space (first text))\n          (char=? #\\Newline (first text)))\
    \ (cons (first text) (fix_spaces (rest text)))]\n    [else\n     (let ([s (split-string\
    \ (first text) #\\Space)]\n           [s1 (split-string (first s) #\\Space)]\n\
    \           [s2 (split-string (first s1) #\\Space)])\n       (cond [(> (length\
    \ (rest s1)) 2)\n              (concat '_ (fix_spaces (rest s)))]\n          \
    \   [else\n              (concat '_ (fix_spaces (rest s1))\n                 \
    \    ((null? (rest s2)) \"\")\n                     ((null? (rest s)) \"\")]))]))\n",
  "  (define (helper text current)\n    (if (null? current)\n        text\n      \
    \  (helper (substring text 1 (car current)) (cdr current))\n    )\n  )\n  (helper\
    \ (reverse text) '(#f #f #f))\n)\n", "  (cond\n    [(empty? text) empty]\n   \
    \ [else (cond \n              [(equal? (first text) ' ')\n               (cons\
    \ (replace-all \" \" '_' text))\n               ]\n              [(equal? (rest\
    \ text) ' ')\n               (cons (replace-all \" \" '-' text))\n           \
    \    ]\n              [else (cons (first text) (fix_spaces (rest text)))]\n  \
    \            )])) \n", "  (if (string-length text)\n      (cond ((or (string=?\
    \ (substring text 0 (string-length text)) \" \")\n                 (string=? (substring\
    \ text 0 (string-length text)) \"\\t\"))\n             (cond ((or (string=? (substring\
    \ text 0 (string-length text)) \" \")\n                      (string=? (substring\
    \ text 0 (string-length text)) \"\\t\"))\n                    (cond ((or (string=?\
    \ (substring text 0 (string-length text)) \" \")\n                           \
    \ (string=? (substring text 0 (string-length text)) \"\\t\"))\n              \
    \             (string-append \"-\" (substring text 0 (string-length text))))\n\
    \                        (string-append \"_\" (substring text 0 (string-length\
    \ text))))\n                    (string-append \"-\" (substring text 0 (string-length\
    \ text))))\n                   (string-append \"_\" (substring text 0 (string-length\
    \ text)))))\n            (string-append \"_\" (substring text 0 (string-length\
    \ text))))\n      (cond ((or (string=? (substring text 0 (string-length text))\
    \ \" \")\n                 (string=? (substring text 0 (string-length text)) \"\
    \\t\"))\n             (cond ((or (string=? (substring text 0 (string-length text))\
    \ \" \")\n                      (string=? (substring text 0 (string-length text))\
    \ \"\\t\"))\n                    (cond ((or (string=? (substring text 0 (string-length\
    \ text)) \" \")\n                            (string=? (substring text 0 (string-length\
    \ text)) \"\\t\"))\n                           (string-append \"_\" (substring\
    \ text 0 (string-length text))))\n                        (string-append \"_\"\
    \ (substring text 0 (string-length text))))\n                    (string-append\
    \ \"_\" (substring text 0 (string-length text))))\n                   (string-append\
    \ \"_\" (substring text 0 (string-length text)))))\n        (string-append \"\
    _\" (substring text 0 (string-length text)))))\n</code>\n<|/ a |>\n<| a tags=scheme,string,racket,replace\
    \ |>\nA simple solution:\n<code>", "  (if (null? text) \n      '()\n      (cond\
    \ [(= (length text) 2)\n             (string-append \"_\" (sub-string (substring\
    \ text 0 1) (substring text 1 2)))]\n            [(= (length text) 3)\n      \
    \       (string-append \"_\" (sub-string (substring text 0 1) (substring text\
    \ 1 2) \"_\"))]\n            [else\n             (append (sub-string (substring\
    \ text 0 1) (substring text 1 2))\n                    (sub-string (substring\
    \ text 0 1) (substring text 1 2))\n                    (sub-string (substring\
    \ text 0 1) (substring text 1 2)))])))\n", "  (cond\n    [(empty? text)\n    \
    \ (error \"fix_spaces: empty text\")] \n    [(equal? (first text) \" \")\n   \
    \  (cons (car text) \n           ((fix_spaces (rest text)) \n            (cons\
    \ (car text) empty)))] \n    [else \n     (cons (car text) \n           ((fix_spaces\
    \ (rest text)) \n            (cons (car text) empty)))]))\n", "  (let ([s (string-split\
    \ text #\\Space)])\n    (let [news (make-string (string-length text))\n      \
    \    i 0]\n      (loop [s s, i 0]\n        (cond [(null? (string-ref s i))\n \
    \             (set! news (string-append news (string-ref s i)))]\n           \
    \   [(not (= (number->string (number->byte))\n                      (number->string\
    \ (number->char)))\n               (set! news (string-append news \" \"))]\n \
    \             [(or (string=? (string-ref s i) #\\Space)\n                  (string=?\
    \ (string-ref s i) #\\Newline)\n                  (string=? (string-ref s i) #\\\
    Tab)\n                  (string=? (string-ref s i) #\\Newline)\n             \
    \     (string=? (string-ref s i) #\\Newline)\n                  (string=? (string-ref\
    \ s i) #\\Space)\n                  (string=? (string-ref s i) #\\Space))\n  \
    \             (set! news (string-append news (string->symbol (string-ref s i))))]\n\
    \              [else\n               (set! news (string-append news \" \"))]\n\
    \              [else\n               (set! news (string-append news (string->symbol\
    \ (string-ref s i))))]\n              [else\n               (set! news (string-append\
    \ news (string->symbol (string-ref s i))))]\n              [else\n           \
    \    (set! news (string-append news (string->symbol (string-ref s i))))]\n   \
    \           [else\n               (set! news (string-append news (string->symbol\
    \ (string-ref s i))))]\n              [else\n               (set! news (string-append\
    \ news (string->symbol (string-ref s i))))]\n              [else\n           \
    \    (set! news (string-append news (string->symbol (string-ref s i))))]\n   \
    \           [else\n               (set! news (string-append news (string->symbol\
    \ (string-ref s i))))]\n              [else\n               (set! news (string-append\
    \ news (string->symbol (string-ref s i))))]\n              [else\n           \
    \    (set! news (string-append news (string->symbol (string-ref s i))))]\n   \
    \           [else\n               (set! news (string-append news (string->symbol\
    \ (string-ref s i))))]\n              [else\n               (set! news (string-append\
    \ news (string->symbol (string-ref s i))))]\n              [else", "  (define\
    \ (fix-space char-c)\n    (cond\n      [(char-c = ' ') '_']\n      [(char-c =\
    \ #\\Newline) '-']\n      [else (char-c)]))\n\n  (define (recursive-fix-spaces\
    \ text)\n    (cond\n      [(string? text) text]\n      [(empty? text) '()]\n \
    \     [(not (space? text)) text]\n      [else (string-append (recursive-fix-spaces\
    \ (first text))\n                       (fix-space (first text)) (recursive-fix-spaces\
    \ (rest text)))]))\n\n  (define (newline-to-space char)\n    (cond\n      [(char=\
    \ char #\\Newline) '_']\n      [else char]))\n\n  (define (space-char-to-space\
    \ char)\n    (cond\n      [(char= char #\\Space) ' ']\n      [else char]))\n\n\
    \  (define (fix-all-spaces text)\n    (cond\n      [(string? text) text]\n   \
    \   [(empty? text) '()]\n      [(not (space? text)) text]\n      [else (string-append\
    \ (fix-all-spaces (first text))\n                         (fix-all-spaces (rest\
    \ text)))]))\n\n  (define (fix-space-chars text)\n    (cond\n      [(string? text)\
    \ text]\n      [(empty? text) '()]\n      [(not (space? text)) text]\n      [else\
    \ (string-append (fix-space-chars (first text))\n                         (fix-space\
    \ (first text)) \n                         (fix-space-chars (rest text)))]))\n\
    \n  (define (fix-all-space-chars text)\n    (cond\n      [(string? text) text]\n\
    \      [(empty? text) '()]\n      [(not (space? text)) text]\n      [else (string-append\
    \ (fix-all-space-chars (first text))\n                         (fix-all-spaces\
    \ (rest text)))]))\n\n  (define (fix-all-spaces-chars text)\n    (cond\n     \
    \ [(string? text) text]\n      [(empty? text) '()]\n      [(not (space? text))\
    \ text]\n      [else (string-append (fix-all-spaces-chars (first text))\n    \
    \                     (fix-all-space-chars (rest text)))]))\n\n  (recursive-fix-spaces\
    \ text))\n", "  (cond [(string-length (string-trim-whitespace text)) (cond [(=\
    \ (string-length (string-trim-whitespace text)) 1)\n                         \
    \                                             (cons (string-append \"-\" (string-trim-whitespace\
    \ text))\n                                                                   \
    \ (string-trim-whitespace text))])\n        (else (cons (string-append \"_\" (string-trim-whitespace\
    \ text))\n                    (fix_spaces (string-trim-whitespace text))))])\n",
  "  (if (string-length? text)\n      (if (string-repeat? \"^ \" text 2)\n       \
    \   (replace text \" \" \"-\")\n          (replace text \" \" \"_\"))\n      text))\n",
  "  (cond\n    ((string-length text) text)\n    ((equal? (ascii-code (first text)))\
    \ text)\n    ((not (equal? (ascii-code (first text))) (ascii-code (first text)))\
    \ text)\n    ((equal? (ascii-code (first text))) (fix_spaces (rest text))\n  \
    \  (#t (cons (string->symbol (first text)) (fix_spaces (rest text)))))\n  )\n\
    )\n", "  (letrec\n    ([fix-first-space (lambda (text)\n                     \
    \ (cond\n                       ((null? text) text)\n                       (else\n\
    \                        (cond\n                         ((equal? (first text)\
    \ \" \") (first text))\n                         ((equal? (first text) (substring\
    \ (first text) 1) \" \"))\n                         (else\n                  \
    \        (cond\n                           ((equal? (second text) \" \") (second\
    \ text))\n                           ((equal? (second text) (substring (second\
    \ text) 1) \" \"))\n                           (else\n                       \
    \    (cond\n                            ((equal? (third text) \" \") (third text))\n\
    \                            ((equal? (third text) (substring (third text) 1)\
    \ \" \"))\n                            (else\n                             (cond\n\
    \                               ((equal? (fourth text) \" \") (fourth text))\n\
    \                               ((equal? (fourth text) (substring (fourth text)\
    \ 1) \" \"))\n                               (else\n                         \
    \      (cond\n                                ((equal? (fifth text) \" \") (fifth\
    \ text))\n                                ((equal? (fifth text) (substring (fifth\
    \ text) 1) \" \"))\n                                (else\n                  \
    \               (cons text\n                                      (fix-first-space\
    \ (substring (fifth text) 2 text)))))\n                               (else (cons\
    \ text (fix-first-space (substring (fifth text) 2 text))))))))))\n           \
    \            (else (cons text (fix-first-space (substring (second text) 2 text))))))))])\n\
    \    (fix-first-space text)))\n", "  (cond\n    ((null? text) \"\")\n    ((= (length\
    \ text) 2)\n     (string-append \"-\" text))\n    ((string=? (substring text 0\
    \ (string-length text)) \" \") (fix_spaces (substring text 1 )))\n    ((string=?\
    \ (substring text 0 (string-length text)) \" \") (fix_spaces (substring text 1\
    \ (string-length text))))\n    (else (string-append \"_\" (fix_spaces (substring\
    \ text 0 (string-length text)))))))\n", "  (if (space? text)\n      (make-string\
    \ (string-append text \"-\"))\n      (make-string (string-append text \"_\"))))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) \" \") (cons (first\
    \ text) (fix_spaces (rest text)))]\n    [else (cons (first (first text)) (fix_spaces\
    \ (rest text)))]))\n", "  (cond\n    [(empty? text) (empty?)]\n    [(= (length\
    \ text) 2) (cons (car text) (cons (car text) (empty?)))]\n    [else (cons (car\
    \ text) (fix_spaces (cdr text)))]))", "  (cond\n    [(string=? (string-length\
    \ (string-trim text))) text]\n    [(string-match \" \" text)\n     (let-values\
    \ ([(x y) (remove-duplicates text)]\n                  [(space-pos x) (space-pos\
    \ y)]\n                  [(space-pos x) (space-pos y)])\n       (cond\n      \
    \   [(> x y)\n          (let [y (+ x y)\n                tmp (make-string x #\\\
    _ y)\n                space-pos\n                tmp (map string-length tmp)]\n\
    \            (cond\n             [(> space-pos 2) \n              (make-string\n\
    \               (string-length text)\n               #\\- (substring text 0 x))\n\
    \             (space-pos\n             (+ x space-pos))]\n             [else\n\
    \              (make-string\n               (string-length text)\n           \
    \    #\\- (substring text x space-pos))])))]\n    [else\n     (make-string\n \
    \     (string-length text)\n      #\\- (substring text 0 (string-length text)))]))))\n",
  "  (cond\n    ((string= text \"\")\n     '\"\")\n    ((string= text \" \")\n   \
    \  \"_\")\n    ((string= text \"   \")\n     \"-\")\n    (else\n     (string-replace\n\
    \      (replace\n       (string->chars\n        text)\n      '(\" \" \" \" \"\
    \ \" \" \")\n      (lambda (m n)\n        (if (string= (substring m 2) \"   \"\
    )\n            (substring m 3)\n            (substring m 1)\n          m)))))))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (char-type (car text)) #\\Space)\n\
    \     (concat (map \n                ((lambda (x) (concat (string->char (string->string\
    \ x))))\n                 (string-split (string \" \")\n                     \
    \          (substring (string (length text) 2)\n                             \
    \          (length text))))\n                 (fix_spaces (substring (string text)\
    \ (length text) 2)))]\n    [else (concat (map \n                    ((lambda (x)\
    \ (concat (string->char (string->string x))))\n                     (string-split\
    \ (string \" \")\n                                   (substring (string (length\
    \ text) 1)\n                                           (length text))))\n    \
    \                (fix_spaces (substring (string text) (length text) 1)))])))\n\
    \            \n", "  (cond\n    [(or (equal? text \"\")\n          (equal? text\
    \ \"-\"))\n     (text)\n     (let ([newstr (string->symbol (string-replace text\
    \ \" \" \"_\" '()))])\n       (cond\n         [(< (string-length newstr) 2)\n\
    \          (newstr)]\n         [else\n          (append\n           (cond\n  \
    \           [(equal? text \"_\")\n              (append newstr (string->symbol\
    \ \"-\"))]\n             [else\n              (append newstr (string->symbol \"\
    -\"))]\n             (string-append \"-\" (string->symbol \"-\")))]))]\n    [else\n\
    \     (string->symbol (string-replace text \" \" \"_\" '()))]))\n", "  (if (string-length\
    \ text <= 2)\n      text\n      (let ((fix (make-regex \"\\\\s\" (list ?\\\\s\
    \ ?-) '())))\n        (replace-regexp fix text (substring text 0 (string-length\
    \ text)))))) ; replace spaces with underscores\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is much better. Using regexes is actually a very good way to solve this problem.\n\
    <|/ c |>\n<| c |>\nI agree, and I appreciate your answer.  My question was more\
    \ about the `substring text 0 ...` part.\n<|/ c |>\n<| c |>\n- I believe you have\
    \ a misunderstanding of what `(list ?\\\\s ?-)` does. The question mark means\
    \ \"zero or one occurrences of what's inside the list\". It's not a regular subexpression,\
    \ so you can't use it in a regular expression. `?\\\\s` means any whitespace character.\
    \ `(list ?\\\\s ?-)` means \"match a literal backslash or a whitespace character\"\
    . The `(list ?\\\\s ?-)` part is just a list of one or two elements, `?\\s` and\
    \ `?-`. It's not actually \"all whitespace\" or \"all hyphen\".\n<|/ c |>\n<|\
    \ c |>\n- Ah, so you're saying that the `\\\\s` part is the literal characters\
    \ `\\s` and `-`?\n<|/ c |>\n<| c |>\nYes. It's not a regular expression, it's\
    \ just a list. `?\\s` matches a single backslash and `?-` matches a single hyphen.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis one uses only standard Racket and does not use\
    \ regular expressions.\n<code>\n#lang racket\n", "  (let ((res \"\"))\n    (if\
    \ (or (string? text)\n            (char-whitespace? text))\n        res\n    \
    \    (if (or (string? text)\n                (char-whitespace? text))\n      \
    \      (append res (string->symbol (string-replace-all text #\\Space #\\_)))\n\
    \            (append res (string->symbol (string-replace-all text #\\Space #\\\
    -))))))\n", "  (cond\n    ((null? text) '())\n    ((equal? (car text) \" \") \n\
    \      (cons (car text) \n            (fix_spaces (cdr text)))))\n    ((equal?\
    \ (car text) \" \")\n      (cons (car text)\n            (fix_spaces (cdr text))))\n\
    \    ((equal? (car text) \" \")\n      (cons (car text) (fix_spaces (cdr text))))\n\
    \    ((equal? (car text) (substring text (+ 0 (string-length text)) \n       \
    \                              (string-length text)))\n      (cons (car text)\
    \ (fix_spaces (cdr text))))\n    (else (cons (car text) (fix_spaces (cdr text)))))\n\
    \  )\n)\n", "  (let ((fixed (make-string)))\n    (loop for ch in text\n      \
    \    for i = 0 then (length text)\n          for j = i + 1 then (length text)\n\
    \          collect (if (char=? ch space)\n                    (if (char=? (substring\
    \ text i j) space)\n                        \n                        (cond ((and\
    \ (substring text i j) space) (cond ((char=? (substring text i j) space) (cond\
    \ ((and (substring text i j) space) (cond ((char=? (substring text i j) space)\
    \ (cons (\"-\" (substring text i j)))) (\"-\" fixed)))\n                     \
    \                                                              (else fixed)))\n\
    \                                                                          (else\
    \ fixed)\n                                        ))\n                      (else\
    \ fixed)))\n    (cond ((> (length fixed) 2)\n           (cond ((char=? (substring\
    \ text 0 (length fixed)) space) (cons (\"-\" (substring text 0 (length fixed))))\n\
    \                 (else fixed)))\n          (else fixed)\n          )))\n", " \
    \ (if (space? text)\n      (replace-all \" \" '_ (fix-spaces-helper text))\n \
    \     text))\n", "  (let ([\n      (re\n        (let ([\n               (spaces\
    \ (regexp-opt [[:space:]]))\n               (long-spaces\n                (define\
    \ (match-groups)\n                  (regexp-opt\n                   ([[:space:]]+))\n\
    \                   ([[:space:]][[:space:]]*))\n               (long-spaces-1\
    \ \n                (define (match-groups)\n                  (regexp-opt \n \
    \                  ([[:space:]][[:space:]]*))\n                   ([[:space:]][[:space:]]*[[:space:]][[:space:]]*))])\n\
    \          (re\n            (let ([\n                   (spaces (regexp-opt [[:space:]]+))\n\
    \                   (long-spaces\n                    (define (match-groups)\n\
    \                      (regexp-opt\n                       ([[:space:]]+))\n \
    \                      ([[:space:]][[:space:]]*))\n                   (long-spaces-1\
    \ \n                    (define (match-groups)\n                      (regexp-opt\n\
    \                       ([[:space:]]+))\n                       ([[:space:]][[:space:]]*[[:space:]][[:space:]]*))])])\n\
    \              (re\n                (let ([\n                       (spaces (regexp-opt\
    \ [[:space:]]+))\n                       (long-spaces\n                      \
    \  (define (match-groups)\n                          (regexp-opt\n           \
    \                ([[:space:]]+))\n                           ([[:space:]][[:space:]]*))\n\
    \                       (long-spaces-1 \n                        (define (match-groups)\n\
    \                          (regexp-opt\n                           ([[:space:]]+))\n\
    \                           ([[:space:]][[:space:]]*[[:space:]][[:space:]]*))])])\n\
    \                      (re\n                        (let ([\n                \
    \               (spaces (regexp-opt [[:space:]]))\n                          \
    \     (long-spaces\n                                (define (match-groups)\n \
    \                                 (regexp-opt\n                              \
    \     ([[:space:]]))\n                                   ([[:space:]][[:space:]]*))\n\
    \                               (long-spaces-1 \n                            \
    \    (define (match-groups)\n                                  (regexp-opt\n \
    \                                  ([[:space:]][[:space:]]*))\n              \
    \                     ([[:space:]][[:space:]]*[[:space:]][[:space:]]*))])])\n\
    \              (re\n                (let ([\n                       (spaces (regexp-opt\
    \ [[:space:]]+))", "  (cond\n    [(null? text) text]\n    [(= (length text) 0)\
    \ \"\"]\n    [(or (string=? \" \" (substring text 0 (string-length text)))\n \
    \         (string=? \" \" (substring text 1 (string-length text))))\n      (substring\
    \ text 0 string-length text)]\n    [(or (string=? \" \" (substring text 0 (string-length\
    \ text)))\n          (string=? \" \" (substring text 1 (string-length text)))\n\
    \          (string=? \" \" (substring text 2 (string-length text))))\n      (substring\
    \ text 0 string-length text)\n      (append \"-\" (substring text 0 (string-length\
    \ text)))]\n    [else (cond \n            [(string=? \" \" (substring text 0 (string-length\
    \ text)))\n             (substring text 0 string-length text)\n             (append\
    \ \"-\" (substring text 0 (string-length text)))]\n            [else\n       \
    \      (append text \"_\")]]))\n", "  (cond [(string=? text \" \")\n         (string-append\
    \ \"_\" (replace-all \"[ ]{2,}\" \"_\" \"_\" text))\n         text]\n        [(or\
    \ (string=? text \" \")\n             (or (string=? text \"\")\n             \
    \    (string=? (string-append \"_\" (replace-all \"[ ]{2,}\" \"_\" \"_\" text))\
    \ \"\")))\n         (string-append \"_\" (replace-all \"[ ]{2,}\" \"_\" \"_\"\
    \ text))\n         text]\n        [(string=? text \"\")\n         text]\n    \
    \    [else\n         (replace-all \"[ ]{2,}\" \"_\" \"_\" text)]))\n", "  (let\
    \ ((chars (string->list text)))\n    (cond\n      [(empty? chars) \"\"]\n    \
    \  [(list? (first chars)) (first (fix_spaces (rest chars)))]\n      [(equal? #\\\
    space (first chars)) (\n        (cond\n          [(< 2 (length chars)) (\n   \
    \         (string->list (string->symbol (concat (symbol->string #\\space) \n \
    \                                             (symbol->string (first chars)))))]\n\
    \          [(= 2 (length chars)) (\n            (string->list (string->symbol\
    \ (concat (symbol->string #\\space) \n                                       \
    \       (symbol->string (first chars)))))]\n          [else (\n            (string->list\
    \ (string->symbol (concat (symbol->string #\\space) \n                       \
    \                       (symbol->string (first chars)))))]))]\n      [else (\n\
    \        (cond\n          [(< 1 (length chars)) (\n            (string->list (string->symbol\
    \ (symbol->string (first chars)))))]\n          [(= 1 (length chars)) (\n    \
    \        (string->list (string->symbol (symbol->string (first chars)))))]\n  \
    \        [else (\n            (string->list (string->symbol (symbol->string (first\
    \ chars)))))]))])))\n", "  (let ((result-text))\n    (for ([i (in-string text\
    \ #\\Space)])\n      (set! result-text (replace-all i \"_ \" result-text))\n \
    \     (set! result-text (replace-all i \"- \" result-text)))\n    result-text))\n",
  "  (cond\n    [(= (length text) 0) \"\"]\n    [(= (length text) 1) text]\n    [(=\
    \ (length text) 2) (substring (text 0 1)\n                              (substring\
    \ (text 0 1) (length text) 2))\n     (fix_spaces (substring (text 0 1) (substring\
    \ (text 0 1) (length text) 2)))]\n    [else (cons (if (substring text 0 (substring\
    \ text 0 (length text)) \n                            (substring text 0 (length\
    \ text)) \"-\")\n                        (substring text 0 (substring text 0 (length\
    \ text)) \n                            \"-\")\n                    (fix_spaces\
    \ (substring text 0 (substring text 0 (length text)) \n                      \
    \                   (substring text 0 (length text)) 2)))]))\n", "  (cond\n  \
    \  ((empty? text) empty) \n    ((= (length text) 2)\n     (if (space? (car text))\n\
    \     (car text) \n     (if (space? (car text))\n     ((cons (car text) (list\
    \ (car text))))\n     ((cons (car text) (list (car text)))) \n     (list (car\
    \ text) (car text))) \n     (if (space? (car text))\n     ((cons (car text) (list\
    \ (car text)))) \n     (list (car text) (car text)))) \n    (else\n     (let ((fix_spaces\
    \ (fix_spaces (cdr text))))\n     (if (null? fix_spaces)\n     (list (car text)\
    \ (car text))\n     (cons (car text) fix_spaces)))\n   )\n  )\n)\n", "  (cond\n\
    \    ((string-length text) text)\n    ((= (string-length text) 2) (append text\
    \ text))\n    (else\n     (let* ((split (string-split text #\\Space #\\Newline))\n\
    \            (fixed (map #(if (string=? #\\Space\n                           \
    \             (substring split 0 i))\n                                (append\
    \ #\\- #\\Space)\n                               (substring split 0 i))\n    \
    \                   (range 0 (string->number text))))\n           (result (append\
    \ (join fixed)\n                          (join (subseq split 1 )))))))\n</cell>\n\
    <text>\nA little more complicated example in Racket, with regular expressions:\n\
    \n\n</text>\n<cell>\n#lang racket", "  (cond\n    [(empty? text)\n     \"\"]\n\
    \    [(and (space?) (space?))\n     (append \"_\" (fix_spaces (substring text\
    \ 0 (- (length text) 1)))]\n    [else\n     (append \"_\" (substring text 0 (-\
    \ (length text) 1)))]\n  )\n)\n", "  (cond\n    [(empty? text)       (empty? text)]\n\
    \    [(equal? (first text) \" \")    (replace text \" \" \"_\")]\n    [(equal?\
    \ (first text) \" \")    (fix_spaces (replace text \" \" \"\"))])\n  )\n)\n",
  "  (cond\n    [(empty? text) empty]\n    [(equal? (first text) \" \")\n     (if\
    \ (> (count (rest text)) 2)\n       (fix-spaces-replace\n        (replace-all\
    \ (first text) \" \" \"_\"))\n       (fix-spaces-replace\n        (replace-all\
    \ (first text) \" \" \"-\")))]\n    [else (cons (first text) (fix_spaces (rest\
    \ text)))]))", "  (if (string-blank? text)\n      text\n      (let ([head (car\
    \ text)])\n        (if (string= head \" \")\n            (let ([tail (cadr text)])\n\
    \              (if (string-blank? tail)\n                  (let ([tail (car text)]\n\
    \                        [head (cadr text)])\n                    (cons head (cons\
    \ tail \"-\")))\n                  (cons head (cons tail (cons \"-\" tail))))))\n\
    \            (cons head (cons (fix_spaces (cadr text)) \"-\"))))))\n", "  (let\
    \ ((len (string-length text)))\n    (cond ((= len 0)  \"\")\n          ((= len\
    \ 1)  text)\n          ((= len 2)  (string-append \"-\" (substring text 1)))\n\
    \          ((= len 3)  (string-append \"_\" (substring text 1)))\n          ((=\
    \ len 4)  (string-append \"-\" \n                             (substring text\
    \ 1 2)\n                             (substring text 3)))\n          ((= len 5)\
    \  (string-append \"_\" \n                             (substring text 1 2)\n\
    \                             (substring text 3)\n                           \
    \  (substring text 4)))\n          ((= len 6)  (string-append \"_\" \n       \
    \                      (substring text 1 2)\n                             (substring\
    \ text 3)\n                             (substring text 4)\n                 \
    \            (substring text 5)))\n          ((= len 7)  (string-append \"_\"\
    \ \n                             (substring text 1 2)\n                      \
    \       (substring text 3)\n                             (substring text 4)\n\
    \                             (substring text 5)\n                           \
    \  (substring text 6)))\n          (else          (string-append \"_\" \n    \
    \                         (substring text 1 2)\n                             (substring\
    \ text 3)\n                             (substring text 4)\n                 \
    \            (substring text 5)\n                             (substring text\
    \ 6)\n                             (substring text 7))))))\n", "  (let ((re (string-repeat\
    \ \"[ ]{2,}\" 2))\n        (retain (reverse (interleave (reverse (regexp-replace\n\
    \                                          re \"[ ]{2,}\" \" -\"))\n         \
    \                       (reverse (regexp-replace\n                           \
    \               re \" -\" \"-\"))))\n        (result (reverse (interleave (reverse\
    \ (regexp-replace\n                                             re \"[ ]{2,}\"\
    \ \" -\"))\n                                (reverse (regexp-replace\n       \
    \                                      re \" -\" \"-\")))))\n    (cond [(string=\
    \ text (first result))\n           text]\n          [(< (length result) 2)\n \
    \          (cond [(string= (second result) \" -\")\n                  (reverse\
    \ result)\n                  text]\n                    [else (reverse result)\n\
    \                     (reverse (regexp-replace (rest result) \" -\" \"-\"))]]))\n",
  "  (cond\n    [(equal? (length (filter #(space? %) #(make-string-iter text #\\Space)))\
    \ 0) text]\n    [(equal? (length (filter #(space? %) #(make-string-iter text #\\\
    Space))) 1) (concat \"_\" (concat \"\" (filter #(space? %) #(make-string-iter\
    \ text #\\Space))))]\n    [else (concat \"_\" (concat \"\" (filter #(space? %)\
    \ #(make-string-iter text #\\Space))))]))\n", "  (cond [(empty? text) '()]\n \
    \       [(space? (rest text)) \n         (cons (first (rest text)) \n        \
    \       (fix_spaces (rest text)))]\n        [else\n         (cons (first (rest\
    \ text))\n              (fix_spaces (rest text)))]))\n</code>\n<|/ a dscore=2\
    \ tags=scheme |>\n<| c |>\nThe original question was about a function that takes\
    \ one argument - a string. Your `string-trim-spaces` seems to expect a list. Why\
    \ is that?\n<|/ c |>\n<| c |>\nThe original question is about `remove-char`. What\
    \ was the purpose of adding `string-trim-spaces` when I already have `remove-char`?\n\
    <|/ c |>\n<| c |>\nI thought that string-trim-spaces was a helper function, but\
    \ now I see that's a typo :)\n<|/ c |>\n<| a tags=scheme |>\nThis remove-char\
    \ is straight forward and easy to implement:\n<code>", "  (cond\n    [(string?\
    \ text)\n     (string-replace\n      (map \n       (lambda (s) (if (string? s)\
    \ \n                          (replace-all s \" \" \"_\") \n                 \
    \         s))\n       text))\n     (string? text)\n     (replace-all text \" \"\
    \ \"_\")\n     (string? text)\n     (replace-all text (substring (text 0 0) 1)\
    \ \"_\")\n     (string? text)\n     (replace-all text (substring (text 0 (string-length\
    \ text)) 0) \"_\")]\n    [else text]))\n", "  (let loop ((remainder text)\n  \
    \           (new-text (replace (regex \" \" (regex-quote \" \")) \"_\" remainder)))\n\
    \    (cond\n      [(null? remainder) new-text ]\n      [(string=? (length remainder)\
    \ 2)\n       (loop (replace (regex \" \" (regex-quote \" \")) \"-\" remainder))]\n\
    \      [(string=? (length remainder) 3)\n       (loop (replace (regex \"( ){2,}\"\
    \ (regex-quote \"( ){2,}\") \"-\" remainder))]\n      [else (recur new-text)]))))\n",
  "  (let ([result (make-string text)])\n    (for [i [0 -1]]\n      (when (and (>\
    \ i (string-length text))\n                 (string=? text (substring text i i)))\n\
    \        (set! result (substring result i (+ i 2))))\n      (when (and (= i (string-length\
    \ text))\n                 (string=? (substring text 0 i) (substring text i i)))\n\
    \        (set! result (substring result 0 (+ i (string-length text))))))\n   \
    \ (replace-all \" \" \"_\" result)))\n", "  (cond\n   ((= text \"\")\n    \"\"\
    )\n   ((symbolp (first text))\n    (fix_spaces (first text)))\n   ((charp (first\
    \ text))\n    (cond\n     ((char= (first text) #\\Space)\n      (if (string=?\
    \ (second text) #\\Space)\n          (cons (second text) (cons #\\- \n       \
    \                              (fix_spaces (rest text))))\n          (cons (second\
    \ text) #\\Space)))\n     ((char= (first text) #\\Newline)\n      (cons (second\
    \ text) #\\Space))\n     ((char= (first text) #\\Tab)\n      (cons (second text)\
    \ (cons #\\- \n                                   (fix_spaces (rest text))))))))\n\
    \  (cons text \n        (if (> (string-length text) 2)\n            (fix_spaces\
    \ (rest text))\n            text)))\n", "  (let ([count (length text)])\n    (if\
    \ (= count 0) text\n      (if (or (= count 2) (= count 3))\n          (cond [(or\
    \ (char= text #\\Space) (char= text #\\Newline) (char= text #\\Tab))\n       \
    \          (make-string (substring text 0 1))\n               (else text)]\n \
    \             [else\n               (cond [(or (char= text #\\Space) (char= text\
    \ #\\Newline) (char= text #\\Tab))\n                       (make-string (substring\
    \ text 0 0))\n                       (else (make-string (substring text 0 1)))])))))\n\
    </code>\n<|/ a dscore=3 tags=scheme,racket,string,whitespace |>\n<| c |>\n`count`\
    \ can be written `(length text)`\n<|/ c |>\n<| c |>\nThank you for the comments,\
    \ I have updated my answer\n<|/ c |>\n<| a |>\nUsing regex's \\s instead of plain\
    \ spaces.\n<code>", "  (cond\n    [(or (char-blank? text)\n          (char-whitespace?\
    \ text))\n     (string-append \"_\" text)]\n    [else\n     (string-append text\
    \ \"_\")]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(subseq? text 0) \"\"\
    ]\n    [else (if (char-whitespace? char-code text)\n              (concat\n  \
    \             (concat (substring text 0 (char-index (first text) text)))\n   \
    \            (fix_spaces (substring text (char-index (first text) text) \n   \
    \                                (string-length text))))])\n  )\n", "  ;; Split\
    \ text into words and fix spaces\n  (define (fix-split words)\n    ;; Fix spaces\
    \ in words\n    (if (null? words)\n        ;; Return empty list if there are no\
    \ words\n        '()\n        (if (and (not (member #\\Space (first words))) (empty?\
    \ (rest words)))\n            ;; Return words unchanged if there are no spaces\
    \ or \n            ;; there is only one word\n            (list words)\n     \
    \       (if (and (not (member #\\Space (first words))) (empty? (rest words)))\n\
    \                (list (cons #\\Space\n                            (cons (first\
    \ words)\n                                  (fix-split (rest words))))\n     \
    \                (cons #\\Space\n                            (cons (first words)\n\
    \                                  (fix-split (rest words)))))\n             \
    \   (list (cons #\\Space\n                            (cons (first words)\n  \
    \                                (fix-split (rest words)))))))\n    ;; Return\
    \ words split into words with spaces fixed\n    (map (lambda (word)\n        \
    \   (fix-split (remove-if-not (lambda (w)\n                                  \
    \     (or (= 0 (string-length word))\n                                       \
    \     (string-equal word #\\Space))) \n                                  word)))\n\
    \          (remove-if-not (lambda (w)\n                           (and (not (string-length\
    \ word))\n                                (not (string-equal w #\\Space)))) \n\
    \                           text))\n          ;; Sort words alphabetically (to\
    \ handle \"Example\" before \"Example 1\")\n          (sort-by (lambda (w)\n \
    \                      (string< w #\\Space))\n                    text)))\n  ;;\
    \ Convert words into string\n  (define (fix-string words)\n    (if (null? words)\n\
    \        \"\"\n        (string-append (first words) \"_\" (fix-string (second\
    \ words)))))\n  ;; Rebuild text with spaces fixed\n  (define (rebuild-string text)\n\
    \    (if (string= \"\" text)\n        text\n        (fix-string (rebuild-string\
    \ (remove-if-not (lambda (w)\n                                               \
    \    (string=? w #\\Space)) text)))))\n  ;; Rebuild text with spaces fixed\n \
    \ (define (rebuild-string text)\n    (if (string= \"\" text)\n        text\n \
    \       (fix-string (rebuild-string (remove-if-not (lambda (w)\n             \
    \                                      (string=? w #\\Space)) text)))))\n  ;;\
    \ Rebuild text with spaces fixed\n  (define (rebuild-string text)\n    (if (string=\
    \ \"\" text)\n        text", "  (cond [(equal? text \"\")\n         \"\"]\n  \
    \      [(equal? (char-after text) \" \")\n         (string-append \"-\" (fix_spaces\
    \ (string-after text)))]\n        [else\n         (string-append \"_\" (fix_spaces\
    \ (string-after text)))]))\n", "  (let ((result (string \"\" \"\" \"\" text)))\n\
    \    (if (null? result)\n        text\n        (if (char? result)\n          \
    \  (let ((char (string->char-sequence result))\n                  (spaces (remove-if\
    \ #(if (string? %) (length %) 0) char)))\n              (cond ((or (= 0 spaces)\
    \ (string-length (string->char-sequence result)) 1)\n                     (set!\
    \ result (replace (subseq char 0 (+ 0 (- (length spaces) 1))) \"-\") \n      \
    \               (cons (string->char-sequence result) (append (subseq char 0 (-\
    \ (length spaces) 1))\n                                                      \
    \     (fix_spaces (subseq char 1 (- (length spaces) 2))))))\n                \
    \     ;; Only one space\n                     (set! result (replace (subseq char\
    \ 0 spaces) \"-\") \n                              (cons (string->char-sequence\
    \ result) (append (subseq char 0 spaces)\n                                   \
    \                               (fix_spaces (subseq char 1 (- (length spaces)\
    \ 2))))))\n                     ;; More than two spaces\n                    \
    \ (set! result (replace (subseq char 0 (+ 0 (- spaces 1))) \"-\") \n         \
    \                     (cons (string->char-sequence result) (append (subseq char\
    \ 0 spaces)\n                                                                \
    \  (fix_spaces (subseq char 1 (- (length spaces) 2))))))\n                   \
    \  ;; More than one space \n                     (set! result (replace (subseq\
    \ char 0 spaces) \"-\") \n                              (cons (string->char-sequence\
    \ result) (append (subseq char 0 spaces)\n                                   \
    \                               (fix_spaces (subseq char 1 (- (length spaces)\
    \ 2))))))\n                     ;; Only two spaces\n                     (set!\
    \ result (replace (subseq char 0 spaces) \"-\") \n                           \
    \   (cons (string->char-sequence result) (append (subseq char 0 spaces)\n    \
    \                                                              (fix_spaces (subseq\
    \ char 1 (- (length spaces) 2))))))\n                     ;; No spaces\n     \
    \                (set! result (replace (subseq char 0 spaces) \"-\") \n      \
    \                        (cons (string->char-sequence result) (append (subseq\
    \ char 0 spaces)\n                                                           \
    \       (fix_spaces (subseq char 1 (- (length spaces) 2)))))))))))\n", "  (cond\n\
    \    [(empty? text) text]\n    [(equal? text #\\space) text]\n    [(= (length\
    \ text) 1) (cons #\\_ (cons text empty))]\n    [(= (length text) 2) (append (cons\
    \ #\\_ (cons text empty))\n                              (cons #\\- (cons text\
    \ empty)))]))", "  (cond\n    ((= (length text) 0) \"\")\n    ((string=? (car\
    \ text) \" \")\n     (string->symbol (string->string (car text))))\n    ((= (length\
    \ text) 1)\n     (string->string (symbol->string text)))\n    ((string=? (car\
    \ text) \" \")\n     (let ((a (substring (text 1) (+ 1 2))))\n       (cond\n \
    \        ((string=? a \" \") \n          (string->string (a)))\n         ((= (length\
    \ a) 2)\n          (cond \n            ((string=? (cdr a) \" \") \n          \
    \   (fix_spaces (string->string (cdr a))))\n            (else (cons (string->string\
    \ (car a)) \n                      (fix_spaces (string->string (cdr a)))))))\n\
    \         (else (cons (string->string (cons a \"-\"))\n                    (fix_spaces\
    \ (string->string (substring (cdr a) 1)))\n                    (fix_spaces (string->string\
    \ (car a))))))))\n    (else\n     (let ((a (substring (text 1) (+ 1 2))))\n  \
    \     (cond\n         ((string=? a \" \") \n          (string->string (a)))\n\
    \         ((= (length a) 2)\n          (cond \n            ((string=? (cdr a)\
    \ \" \") \n             (fix_spaces (string->string (cdr a))))\n            (else\
    \ (cons (string->string (car a)) \n                      (fix_spaces (string->string\
    \ (cdr a)))))))\n         (else (cons (string->string (cons a \"-\"))\n      \
    \              (fix_spaces (string->string (substring (cdr a) 1)))\n         \
    \           (fix_spaces (string->string (car a))))))))))\n", "  (if (string? text)\n\
    \    (cond\n      [(string=? (char-before-first (string->char-sequence text) \"\
    \ \")) #(cons (string->char-sequence text) (list (char-after-first (string->char-sequence\
    \ text) \" \")) (list (char-before-first (string->char-sequence text) \" \"))]\n\
    \      [(string-length text) >= 3\n       (cond\n         [(string=? (char-before-first\
    \ (string->char-sequence text) \" \") #\\Space)\n          (cond\n           \
    \ [(string=? (char-after-first (string->char-sequence text) \" \") #\\Space)\n\
    \             (cons (string->char-sequence text) (list (char-after-first (string->char-sequence\
    \ text) \" \"))\n             (list (char-before-first (string->char-sequence\
    \ text) \" \")))]\n            [(not(string=? (char-before-first (string->char-sequence\
    \ text) \" \") #\\Space))\n             (cons (string->char-sequence text) (list\
    \ (char-after-first (string->char-sequence text) \" \"))]\n            [else\n\
    \             (cons (string->char-sequence text) (list (char-after-first (string->char-sequence\
    \ text) \" \")))]\n         [(string=? (char-before-first (string->char-sequence\
    \ text) \" \") #\\Space)\n          (cond\n            [(string=? (char-after-first\
    \ (string->char-sequence text) \" \") #\\Space)\n             (cons (string->char-sequence\
    \ text) (list (char-after-first (string->char-sequence text) \" \"))\n       \
    \      (list (char-before-first (string->char-sequence text) \"-\")))]\n     \
    \       [(not(string=? (char-before-first (string->char-sequence text) \" \")\
    \ #\\Space))\n             (cons (string->char-sequence text) (list (char-after-first\
    \ (string->char-sequence text) \" \"))]\n            [else\n             (cons\
    \ (string->char-sequence text) (list (char-after-first (string->char-sequence\
    \ text) \"-\")))]\n         [(not(string=? (char-before-first (string->char-sequence\
    \ text) \" \") #\\Space))\n          (cond\n            [(string=? (char-after-first\
    \ (string->char-sequence text) \" \") #\\Space)\n             (cons (string->char",
  "  (let ([fixed (replace-all \" \" \"_\" text)]\n        [more (= #(= (length %)\
    \ 1) 2)])\n    (if (and fixed more)\n      (replace-all \" \" \"-\" fixed)\n \
    \     fixed)))\n", "  (let loop ((res text) (i 0))\n    (if (equal? i 0)\n   \
    \     (reverse res)\n        (loop (append (replace-all? #\\space #\\_) (reverse\
    \ (substring res i (string-length res))))\n               (1+ i))))) ; loop\n",
  "  (cond\n    [(empty? text) text]\n    [(eq? (first text) \" \") (cond\n      \
    \                   [(empty? (rest text)) (append text \"_\")]\n             \
    \            [else (append (substring text 1) \"_\")])]\n    [else\n     (append\
    \ (substring text 1) (fix_spaces (rest text))\n             (list (first text))]))])\n\
    </cell>\n<text>\nExercise 3\nThis code solves exercise 3 in chapter 2 of HtDP\
    \ in Racket by writing a program that prints the word with the most vowels (a\
    \ vowel is any letter other than a vowel and the letter \"e\"). The function vowel-count\
    \ takes a list of words as its argument. It returns a list of the vowel counts\
    \ of each word in the list, with the highest vowel count coming first.\n\nTest\
    \ your program by running the following code in a scratch buffer:\n\n\n</text>\n\
    <code language=racket-language>", "  (let ((result '()))\n    (loop for c in text\n\
    \         collect (cond [(or (char=? c #\\Space) (char=? (char c #\\Space) \n\
    \                                    (char=? (char c #\\Space) (char c #\\Space))\
    \ \n                                    (char=? (char c #\\Space) \n         \
    \                           (char=? (char c #\\Space) (char c #\\Space)))]\n \
    \                           [(char=? (char c #\\Space) (char c #\\Space))\n  \
    \                           (cons c result)\n                             (else\
    \ (cons (- c 1) result))]))))\n  (if (< (length result) 2)\n      (let ((spaces\
    \ '(#\\Space #\\Space #\\Space)))\n        (cond [(find spaces result) '()]\n\
    \              [else (cons (- result 1) result)]))\n    (reverse result)))\n  ",
  "  (cond\n    [(empty? text) \"\"]\n    [(space? (car text)) (cond \n          \
    \                [(not (space? (cdr text))) (cons (car text) text)]\n        \
    \                  [(space? (cdr text)) (cons (car text) (fix_spaces (cdr text)))]\n\
    \                          [else (cons (car text) (fix_spaces (cdr text)))]))\n\
    \    (else (cons (car text) (fix_spaces (cdr text))))]))\n", "  (cond\n    ((empty?\
    \ text) text)\n    ((equal? (first text) #\\s) (append (fix_spaces (rest text))\
    \ #\\_))\n    ((equal? (first text) #\\space) (append (fix_spaces (rest text))\
    \ #\\-))\n    ((> (string-length text) 2) (append (fix_spaces (rest text)) #\\\
    -))\n    (else (append (fix_spaces (rest text)) #\\-))))\n", "  (if (string-blank?\
    \ text)\n      text\n      (append (cons (string-replace (string \" \" #(#\\-\
    \ #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces\
    \ (string-replace (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #)\
    \ #\\space)\n               (fix_spaces (string-replace (string \" \" #(#\\- #\\\
    _ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces (string-replace\
    \ (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n  \
    \             (fix_spaces (string-replace (string \" \" #(#\\- #\\_ #\\space))\
    \ #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces (string-replace\
    \ (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n  \
    \             (fix_spaces (string-replace (string \" \" #(#\\- #\\_ #\\space))\
    \ #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces (string-replace\
    \ (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n  \
    \             (fix_spaces (string-replace (string \" \" #(#\\- #\\_ #\\space))\
    \ #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces (string-replace\
    \ (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n  \
    \             (fix_spaces (string-replace (string \" \" #(#\\- #\\_ #\\space))\
    \ #(#\\- #\\_ #\\space) #) #\\space)\n               (fix_spaces (string-replace\
    \ (string \" \" #(#\\- #\\_ #\\space)) #(#\\- #\\_ #\\space) #) #\\space)\n  \
    \             (fix_spaces (string-replace (string \" \" #(#\\- #\\_ #\\space",
  "  (cond ((string=? text \" \") \"_\") \n        ((string=? text \" \\t\") \"-\"\
    )\n        ((string=? text \"\\t\") \"_\") \n        ((string=? text \"\\n\")\
    \ \"_\") \n        ((string=? text \"\\r\") \"_\") \n        (else text))\n)\n",
  "  (let ([result (copy-string text)]\n        [i (- 1 result)])\n    (while (string=?\
    \ result \"\")\n      (set! i (+ i 1))\n      (set! result (substring result 0\
    \ (+ i 2))))\n    (cond [(and (char=? (substring result i) \" \") (char=? (substring\
    \ result (+ i 1)) \" \"))\n          (set! result (substring result (+ i 1) (-\
    \ i 2)))]\n          [else \n          (set! result (substring result 0 i) (substring\
    \ result (+ i 1) (- i 1)))]))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    <code>", "  ;; Replace multiple spaces with a single underscore.\n  (cond [(=\
    \ (length text) 0)\n         text]\n        [(= (substring text 0 (- 1 (length\
    \ text))) \" \")\n         (string \"_\" (reverse (substring text 0 (- 1 (length\
    \ text))))]\n        [(> 1 (substring text 0 (- (length text) 1)))\n         (string\
    \ \"_\" (reverse (substring text 0 (- (length text) 1))))\n         (string (reverse\
    \ (substring text 0 (- (length text) 1)))\n                 (reverse (substring\
    \ text 0 (- (length text) 1))))]))\n", "  \n  (define (remove_consecutive-blanks\
    \ text)\n    (define (iter text index)\n      (cond (empty? text)\n          \
    \  (if (= index 0)\n                text\n                (iter (rest text) (sub1\
    \ index)))\n            (if (char=? (first text) \" \")\n                (iter\
    \ (rest text) (sub1 index))\n                (iter (rest text) index)))\n    \
    \  (iter text 0))\n    \n    (remove_consecutive-blanks (string-trim text))\n\
    \    \n    (if (char=? (first text) \" \")\n        (let ((index (sub1 text)))\n\
    \          (if (= index 0)\n              (first text)\n              (iter (rest\
    \ text) index)))\n      text))\n  \n  (define (count_consecutive-blanks text)\n\
    \    (define (iter text index)\n      (cond (empty? text)\n            (if (=\
    \ index 0)\n                (+ 1 (sub1 index))\n                (iter (rest text)\
    \ index)))\n      (iter text 0))\n    \n    (iter (reverse text) 0))\n  \n  (if\
    \ (empty? text)\n      '()\n      (if (= (count_consecutive-blanks text) 1)\n\
    \          (list text)\n          (cons (first text)\n                (fix_spaces\
    \ (rest text))))))\n", "  (string-replace text (lambda (x y)\n\t\t\t       (match\
    \ x\n\t\t\t         [#\\Space#\\s #\\- #\\Space#\\s #\\- #\\Space#\\s #\\- #\\\
    Space#\\s]\n\t\t\t         [#\\Space#\\s #\\- #\\Space#\\s]\n\t\t\t         [#\\\
    Space#\\s]\n\t\t\t         [#\\Space#\\s #\\- #\\Space#\\s]\n\t\t\t         [#\\\
    Space#\\s]\n\t\t\t         [#\\Space#\\s #\\- #\\Space#\\s]\n\t\t\t         [#\\\
    Space#\\s]\n\t\t\t         [#\\Space#\\s #\\- #\\Space#\\s]\n\t\t\t         [#\\\
    Space#\\s]))))\n", "  (let ([spaces (subseq text (- text 1)))]\n    (cond [(null?\
    \ spaces) text]\n          [(string= text (trim text)) text]\n          [else\
    \ (replace-all spaces '(#\\s) '_)])))\n", "  (cond (string-blank? text) text\n\
    \        (string-length (string-to-list text)) (string-to-list text)\n       \
    \ (else (let ((l (string-to-list text))\n                    (t (make-string (string-length\
    \ l) #\\_)))\n              (loop for i from 0 to (string-length l)\n        \
    \            collect (char (string->char (string-ref l i))\n                 \
    \             (string->char (string-ref l i)))\n              (set-string! t l))))))\n\
    </cell>\n<text>\nThe above implementation of fix_spaces function will throw an\
    \ error if a string is blank. If we want to return a string as we do in the second\
    \ cell of the above section, we should use the following version of the fix_spaces\
    \ function instead:\n\n\n</text>\n<code language=ocaml-jupyter>", "  (cond\n \
    \   ((equal? text \"\")\n     (cond \n       ((equal? (prev text) \" \") (cons\
    \ \" _\" (next text)))\n       ((equal? (prev text) \"\") (cons \" \" (next text)))\n\
    \       (else (cons text \"\"))))\n    ((equal? text \"-\") (cons text \"\"))\n\
    \    ((equal? text \" \")\n     (cond\n       ((equal? (prev text) \" \") (cons\
    \ \"_\" (next text)))\n       ((equal? (prev text) \"\") (cons \"_\" (next text)))\n\
    \       (else (cons text \"_\"))))\n    ((equal? text \"_\")\n     (cond\n   \
    \    ((equal? (prev text) \" \") (cons \"-\" (next text)))\n       ((equal? (prev\
    \ text) \"\") (cons \"-\" (next text)))\n       (else (cons text \"_\"))))\n \
    \   ((equal? text \"-\")\n     (cond\n       ((equal? (prev text) \" \") (cons\
    \ \"_\" (next text)))\n       ((equal? (prev text) \"\") (cons \"_\" (next text)))\n\
    \       (else (cons text \"-\"))))\n    (else (cons text \"\"))))\n", "  (cond\n\
    \    [(empty? text)\n     empty]\n    [(equal? text #\\space)\n     (string)\n\
    \     (replace-substring text #\\space #\\_)\n     (fix_spaces (string text))\n\
    \     ]\n    [else\n     (string\n      (replace-substring text #\\space #\\_)\n\
    \      (fix_spaces (string text)))]\n    )\n  )\n", "  (match text\n    [(_) (replace-all\
    \ (set! text \" \" \"_\") \"_\")]\n    [(x #\\Space) (replace-all (set! text #\\\
    Space \"-\") \"_\")]\n    [(x #\\Newline)\n      (if (char=? (char-code x) 10)\n\
    \          (replace-all (set! text #\\Newline \"\")\n                       \"\
    \\n\"))\n      (replace-all (set! text #\\Newline \"\")\n                   \"\
    \")]))\n", "  (if (= 0 (length text))\n      text\n      (if (= 1 (length text))\n\
    \          (replace-all \" \" \"_\" text)\n          (if (char= (first text) \"\
    \ \")\n              (if (string= (second text) \" \")\n                  (replace-all\
    \ \" \" \"\" text)\n                  (replace-all \" \" \"\" text))\n       \
    \       (replace-all \" \" \"-\" text)))))\n", "  (cond\n    [(equal? text \"\"\
    )\n     (error \"fix_spaces: empty string\")\n     text]\n    [else\n     (cond\n\
    \       [(equal? (string-match #regex \"[\\\\s\\\\n]+\") text)\n        (replace-all\
    \ #regex #{\\ } #{\\_} text)\n        (replace-all #regex #{\\ } #\\- text)\n\
    \        text]\n       [(equal? (string-match #regex \"[\\\\s\\\\n]+\\s\") text)\n\
    \        (replace-all #regex #{\\ } #{\\_} text)\n        (replace-all #regex\
    \ #\\s #\\- text)\n        (replace-all #regex #{\\ } #\\- text)\n        text]\n\
    \       [else\n        (replace-all #regex #{\\ } #{\\_} text)\n        text]\n\
    \       )])) \n</cell>\n<text>\nExercise 7: Fix the spaces in all words in a string\n\
    Given a string, fix all the spaces in it\n\n\n</text>\n<code language=dyalog-kernel>\n\
    'Example 1 Example    2 Example\n</cell>\n<code language=dyalog-kernel>\n'Example-1Example-2Example-3'\n\
    </cell>\n<code language=dyalog-kernel>", "  (let ([i (string-length text)]) \n\
    \    (let loop ([i i])\n      (cond ((zero? i)\n             (string->list\n \
    \              (string-replace\n                '\" \" #(- #\\Space #\\_) #\\\
    Space)\n               (make-vector i 1)))\n            (else\n             (let\
    \ [current (substring text i 1)]\n               (string-replace\n           \
    \     \" \" #(if (string= current #\\Space)\n                         (- #\\Space)\
    \ #\\_)\n                 (make-vector i (+ i 1)))))))))\n", "  (cond [(empty?\
    \ text) empty]\n        [(equal? (first text) \" \") (cons (first text) (fix_spaces\
    \ (rest text)))]\n        [else (cons (append (if (and (not (equal? (first text)\
    \ \" \") (not (equal? (first text) (first text))) ) \n                       \
    \         (cons (first text) (fix_spaces (rest text)))\n                     \
    \           (cons (first text) empty))\n                          (fix_spaces\
    \ (rest text)))]))))\n", "  (let ((fix-space #\\Space))\n    (define (helper (text\
    \ start prev)\n      (if (eq? start 1)\n          text\n          (helper (substring\
    \ text start) (+ start 1) (if (eq? prev fix-space) (- prev 1) prev))))\n     \
    \ (helper text 0 (if (eq? text \" \") fix-space fix-space)))\n    (helper (reverse\
    \ text) (length text) 0))\n", "  (cond\n    [(empty? text) empty]\n    [(or (string=?\
    \ (first text) (first text))\n          (string-contains? text \" \"))\n     (cons\
    \ (first text) (fix_spaces (rest text)))]\n    [(string=? text (first text))\n\
    \     (fix_spaces (rest text))]\n    [(string-contains? text \" \")\n     (cons\
    \ (first text) (fix_spaces (rest text)))]\n    [else\n     (cons (first text)\
    \ (fix_spaces (rest text)))]\n  )\n)\n", "  (cond\n    [(empty? text) text]\n\
    \    [(equal? (substring text 0 1) #\\Space) text]\n    [(equal? (substring text\
    \ 0 1) #\\Tab) text]\n    [else (cond \n           [(equal? (substring text 0\
    \ 1) #\\Newline) text]\n           [else (let ([l (substring text 1 -1)])\n  \
    \                  (cond\n                     [(empty? l) text]\n           \
    \          [(equal? (substring l 0 1) #\\Space) text]\n                     [(equal?\
    \ (substring l 0 1) #\\Tab) text]\n                     [(= (length l) 2) text]\n\
    \                     [(else (let ([r (substring l 1 -1)])\n                 \
    \             (cond\n                                [(empty? r) text]\n     \
    \                           [(equal? (substring r 0 1) #\\Space) text]\n     \
    \                           [(equal? (substring r 0 1) #\\Tab) text]\n       \
    \                         [(= (length r) 2) (concat '-' text)]\n             \
    \                   [(else (concat '_' text))]))\n                           \
    \     ]))]))]))\n</code>\n<|/ a |>\n<| c |>\nThank you for posting this -- I appreciate\
    \ the code example. I ran it in a small test case, but I am getting an error with\
    \ the (= (length l) 2) test. The error says \"string: undefined;\" I assume it\
    \ means the length test is failing because l is undefined. \n\nCan you help me\
    \ see why that is happening?\n<|/ c |>\n<| c |>\nSorry for the delayed response.\
    \ There was a small bug in my code; I have fixed it. In any case, the `(= (length\
    \ l) 2)` test is fine. The error you are getting is probably due to an unmatched\
    \ `)`; I've corrected this in the answer.\n<|/ c |>\n<| c |>\nThank you for taking\
    \ the time to help me. Your correction is working perfectly now.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nTo find longest substring with space you can use following algorithm:\n\
    <code>\nstring s = \" This is sample string with spaces \";\nint maxLength = 0;\n\
    int curLength = 0;\nfor (int i = 0; i < s.length(); i++)\n{\n    if (s[i] == '\
    \ ' && curLength > maxLength)\n    {\n        maxLength = curLength;\n    }\n\
    \    else\n    {\n        curLength++;\n    }\n}\n</code>\nTo find longest substring\
    \ without space you can use following algorithm:\n<code>\nstring s = \" This is\
    \ sample string with spaces \";\n", "  (cond\n    ((empty? text)\n      \"\")\n\
    \    ((equal? (first text) \" \")\n      (cons (car text) (fix_spaces (rest text))))\n\
    \    ((equal? (first text) (second text))\n      (cons (car text) (fix_spaces\
    \ (rest text))))\n    ((equal? (first text) (third text))\n      (cons (car text)\
    \ (fix_spaces (rest text))))\n    (else\n      (cons (car text)\n            (fix_spaces\
    \ (rest text)))))\n", "  (cond [(empty? text)\n         (error \"fix_spaces: given\
    \ string is empty.\")\n         text]\n        [(empty? (rest text))\n       \
    \  (error \"fix_spaces: given string is empty.\")\n         text]\n        [(not\
    \ (space? (car text)))\n         (error \"fix_spaces: given string has no spaces.\"\
    )\n         text]\n        [else\n         (let ([new-text (reverse\n        \
    \                     (map (lambda (c)\n                                    (cond\n\
    \                                     [(equal? c \" \")\n                    \
    \                  (append (substring text 0 (- (length text) 1))\n          \
    \                                    (substring text 1))\n                   \
    \                   (c)]\n                                     [(equal? (rest\
    \ text) \"\")\n                                      (car text)])\n          \
    \                   (remove-duplicates text))))]\n           (if (> (length new-text)\
    \ 2)\n               (fix_spaces (substring new-text 0 (- (length new-text) 1)))\
    \ \n               (append (substring new-text) \"_\"))))]))\n", "  (cond\n  \
    \  ((string-length? text 0)\n     \"\")\n    ((= (string-length text) 2)\n   \
    \  text)\n    ((= (string-length text) 3)\n     (string-append text \"-\")\n \
    \    (fix_spaces (substring text 0 (string-length text))))))\n", "  (cond ((empty?\
    \ text) text)\n        ((eq? (first text) #\\Space) (cons (second text) #\\Space))\n\
    \        ((and (empty? (rest text)) (> (length text) 2)) (cons (second text) #\\\
    Space))\n        (else (cons (second text) (fix_spaces (rest text))))))\n", " \
    \ (cond\n    [(empty? text) text]\n    [(equal? (first text) #\\Space) (cons (car\
    \ text) (rest_of_string text))] \n    [(equal? (first text) #\\Newline) (cons\
    \ (car text) (rest_of_string text))] \n    [else (cons (cons (car text) (fix_spaces\
    \ (rest text))) (fix_spaces (rest_of_string text)))]))\n", "  (if (string=? text\
    \ \"\")\n      \"\"\n      (if (string-length text > 1)\n          (if (or (string=?\
    \ text (substring text 1 1)) (string=? text (substring text (length text) 1)))\n\
    \              (replace-regexp-in-string \"[ ]{2,}\" '- text)\n              (replace-regexp-in-string\
    \ \"[ ]+\" '_' text)))))\n", "  (let loop ((text text) (acc '()))\n    (if (string-length\
    \ text)\n        (loop (substring (string text) 0 string-length) (cons (string-replace\
    \ text #{\\ } #{\\-}) acc))\n        acc)))\n", "  (cond\n    [(equal? text #\\\
    Newline)\n     '()]\n    [else\n     (let ([sl \n            (string-split text\
    \ #\\Space)]) \n       (cond\n         [(null? sl)\n          (list text)]\n \
    \        [else\n          (map (lambda (s) (if (equal? (car s) #\\Space) \n  \
    \                               (cons (car s) (cons (car sl) \n              \
    \                                    (cons (cdr s) #\\Space))) \n            \
    \                     (cons (car s) (cdr s)))\n                (cons (car sl)\
    \ (cons (car sl) \n                                   (cons (cdr sl) (cdr s)))))]\n\
    \         ))]))\n</code>\n<|/ a tags=string,list,scheme,racket |>\n<| c |>\nI\
    \ agree that `map` should be a better tool for this job, but I think `filter`\
    \ is more appropriate in this situation.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  (cond [(empty? text) text]\n        [(equal? (substring text 0) \" \")\n    \
    \     (concat (substring text 0 1)\n                 (string->symbol (substring\
    \ text 2)))]\n        [else\n         (cond [(equal? (substring text 0 1) \" \"\
    )\n                (concat (substring text 0 2)\n                        (string->symbol\
    \ (substring text 1)))]\n               [else\n                (concat (substring\
    \ text 0 1)\n                        (string->symbol (substring text 1))\n   \
    \                     (string->symbol (substring text 2)))]))])\n", "  (if (=\
    \ text \"\")\n      \"\"\n      (if (= (length text) 2)\n          (cond (equal?\
    \ (substring text 0) \" \")\n                \"\"\n                (cond (equal?\
    \ (substring text 1) \" \")\n                      (cons (substring text 0 1)\n\
    \                        (fix_spaces (substring text 2)))\n                  \
    \  (equal? (substring text 1) \" \")\n                      (cons (substring text\
    \ 0 1)\n                        (- (substring text 2)))\n                    (equal?\
    \ (substring text 0) \" \")\n                      (- (substring text 1)))\n \
    \               (equal? (substring text 1) \" \")\n                  (- (cons\
    \ (substring text 0 1)\n                        (- (substring text 2)))\n    \
    \                (fix_spaces (substring text 2)))\n                (equal? (substring\
    \ text 0) \" \")\n                  (- (cons (substring text 0 1)\n          \
    \              (- (substring text 1)))\n                    (fix_spaces (substring\
    \ text 1)))\n                (equal? (substring text 1) \" \")\n             \
    \     (- (cons (substring text 0 1)\n                        (substring text 2))\n\
    \                    (fix_spaces (substring text 2)))\n                (equal?\
    \ (substring text 0) \" \")\n                  (- (cons (substring text 0 1)\n\
    \                        (substring text 1))\n                    (fix_spaces\
    \ (substring text 1)))\n                (equal? (substring text 1) \" \")\n  \
    \                (- (cons (substring text 0 1)\n                        (- (substring\
    \ text 1)))\n                    (fix_spaces (substring text 1)))\n          \
    \      (equal? (substring text 0) \" \")\n                  (- (cons (substring\
    \ text 0 1)\n                        (- (substring text 0)))\n               \
    \     (fix_spaces (substring text 0)))\n            (equal? (substring text 1)\
    \ \" \")\n              (- (cons (substring text 0 1)\n                    (fix_spaces\
    \ (substring text 2)))\n                (fix_spaces (substring text 1)))\n   \
    \       (cond (equal? (substring text 0) \" \")\n                (cons (substring\
    \ text 0)\n                      (fix_spaces (substring text 1)))\n          \
    \  (equal? (substring text 1) \" \")\n              (- (cons (substring text 0\
    \ 1)\n                    (fix_spaces (substring text 1)))\n                (fix_spaces\
    \ (substring text 0)))\n          (equal? (substring text 0) \" \")\n        \
    \    (fix_spaces (substring text 1)))\n        (cond (equal? (substring text 0)\
    \ \" \")\n              (- (cons (substring text 0 1)\n                    (fix_spaces\
    \ (substring text 1)))\n                (fix_spaces (substring text 0)))\n   \
    \     (equal? (substring text 1) \" \")\n          (- (cons (substring text 0 ",
  "  (cond\n   ((string=? (string-length text) #\\space) #\\underscore)\n   (string-replace\n\
    \    (string-replace text\n                     (string-match (string-replace\
    \ text #\\space #\\_)\n                                   #\\space #\\-)\n   \
    \                  (string-match (string-replace text #\\_ \\space)\n        \
    \                           #\\space #\\-)\n                     (string-match\
    \ (string-replace text #\\space #\\space)\n                                  \
    \ #\\space #\\-)\n                     (string-match (string-replace text #\\\
    space #\\_)\n                                   #\\space #\\underscore))\n   \
    \ #\\space #\\underscore))\n   (else text)))\n", "  (define (helper text start)\n\
    \    (cond\n      [(char=? text \" \")\n       (cond\n         [(< start (length\
    \ text))]\n         (helper (substring text start) (inc start))\n         (helper\
    \ (substring text (inc start)) (inc start))])\n       (helper (substring text\
    \ start) start)])\n  (helper (string text) 0))", "  (cond [(string=? (trim-left\
    \ text) (trim-left \" \"))\n         (trim-left text)]\n        [(string=? (trim-left\
    \ text) (trim-left \" \"))\n         (trim-left text)]\n        [(string=? (trim-left\
    \ text) (trim-left \" \"))\n         (trim-left text)]\n        [(or (string=?\
    \ (trim-left text) (trim-left \" \"))\n             (string=? (trim-left text)\
    \ (trim-left \"  \")))\n         (cons-string\n          (cons-string (trim-left\
    \ \" \")\n                        (cons-string (trim-left \" \"))\n          \
    \              (cons-string (trim-left \" \"))))\n         (cons-string\n    \
    \      (cons-string (trim-left \" \")\n                        (cons-string (trim-left\
    \ \" \"))\n                        (cons-string (trim-left \" \"))))]))\n</code>\n\
    <code>", "  (let ((spaces '())\n        (counts '()))\n    (cond\n      [(empty?\
    \ text) empty]\n      [(string=? text \"\")\n       (cond [(empty? spaces) (cons\
    \ text empty)]\n             [(< 1 (string-length text)) (cons (first text) empty)]\n\
    \             [else\n              (cond\n                [(string=? (first text)\
    \ \" \")\n                 (if (empty? spaces)\n                     (cons (first\
    \ text) empty)\n                     (cons (first text) spaces))]\n          \
    \      [else (cons (first text) empty)]))]))\n      [(string=? (first text) \"\
    \ \")\n       (cond\n         [(empty? spaces) (cons text empty)]\n         [(<\
    \ 1 (string-length text)) (cons (first text) empty)]\n         [else\n       \
    \   (cond\n            [(string=? (first text) \" \")\n             (if (empty?\
    \ spaces)\n                 (cons (first text) empty)\n                 (cons\
    \ (first text) spaces))]\n            [else (cons (first text) empty)]))]\n  \
    \    [else\n       (let ((new-spaces (remove-if (lambda (s) (string=? s \" \"\
    ))\n                                   (string->list (string->string text))))\n\
    \             (new-text (cons (first text) empty)))\n         (cond\n        \
    \  [(null? new-text) empty]\n          [(null? new-spaces)\n           (cons text\
    \ empty)]\n          [(< 1 (string-length new-text)) (cons (first new-text) empty)]\n\
    \          [(< 1 (string-length new-spaces)) (cons (first new-text) empty)]\n\
    \          [else (cons (first new-text) (fix_spaces (first new-spaces)))]))]))))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (car text) ?space) (substring text\
    \ 1 1)]\n    [else (concat \"_\" (fix_spaces (substring text 1 -1)))]))\n", " \
    \ (let ([last-space null])\n    (cond [(empty? text)\n           (reverse text)\n\
    \           (list)\n           (list text)\n           (list (reverse text))]\n\
    \          [(char=? (car text) ?\" \")\n           (append (list (make-string\
    \ (car text) (char-code ?\" \")\n                                    (+ (length\
    \ text) (char-code ?\" \"))))\n                   (list (make-string (car text)\
    \ (char-code ?\" \")\n                                    (+ (length text) (char-code\
    \ ?\" \")))\n                   (list (make-string (car text) (char-code ?\" \"\
    )\n                                    (+ (length text) (char-code ?\" \")))\n\
    \                   (list (make-string (car text) (char-code ?\" \")))\n     \
    \              (list (make-string (car text) 0 0))\n                   (list (make-string\
    \ (car text) 0 0)))\n           (append (list (make-string (car text) 0 0)))\n\
    \           (list (list (car text) (car text)))\n           (list (reverse text)\n\
    \                   (reverse text)\n                   (reverse text)\n      \
    \             (reverse text)\n                   (reverse text)\n            \
    \       (reverse text))]\n          [(not (empty? (cdr text)))\n           (append\
    \ (list (make-string (car text) (char-code ?\" \")\n                         \
    \           (+ (length text) (char-code ?\" \")))\n                   (list (make-string\
    \ (car text) (char-code ?\" \")\n                                    (+ (length\
    \ text) (char-code ?\" \")))\n                   (list (make-string (car text)\
    \ (char-code ?\" \")))\n                   (list (make-string (car text) 0 0))\n\
    \                   (list (make-string (car text) 0 0)))\n           (append (list\
    \ (make-string (car text) 0 0)))\n           (list (list (car text) (car text)))\n\
    \           (list (reverse text)\n                   (reverse text)\n        \
    \           (reverse text)\n                   (reverse text)\n              \
    \     (reverse text)\n                   (reverse text))]\n          [else\n \
    \          (append (list (make-string (car text) 0 0)))\n           (list (list\
    \ (car text) (car text)))\n           (list (reverse text)\n                 \
    \  (reverse text)\n                   (reverse text)\n                   (reverse\
    \ text)\n                   (reverse text)\n                   (reverse text))])))\n\
    </cell>\n<text>\nExercise: Write a procedure to check if a string is palindrome.\n\
    \n\n</text>\n<cell>\n#lang racket\n", "  (let* ((index-1 (string-position text\
    \ \" \"))\n         (index-2 (string-position text \" \" index-1))\n         (result\
    \ (subseq text 0 index-1)))\n    (if (= index-2 -1)\n        result\n        (let\
    \ ((previous-result (subseq result 0 (+ index-2 1)))\n               (next-result\
    \ (subseq result (+ index-2 1) (length result))))\n          (if (= (length previous-result)\
    \ 2)\n              (subseq next-result 0 (- (length next-result) 2))\n      \
    \        (concat previous-result \"-\" next-result)))))\n", "  (let ((n 0) (cond\
    \ ((string-length (substring-no-properties text 0 (string-length text)))\n   \
    \               (substring-no-properties text 0 (string-length text)))\n     \
    \           (#t (number->string (+ (string-length text) (incf n))))))\n    (if\
    \ (= n 0)\n        text\n        (cond ((string=? \" \" (substring (substring\
    \ text 0 n) 0 1))\n              (substring (substring text 0 n) 1 n-1))\n   \
    \           (#t (substring (substring text 0 n) (incf n) (+ 1 (- n 1)))\n    \
    \             text))))", "  (if (null? text)\n      \"\"\n      (let ([first text])\n\
    \        (if (or (string=? (string-ref text 0) \" \") (string=? (string-ref text\
    \ 0) \"\\n\")) (set! text (replace text 0 (string-length text) \"_\"))\n     \
    \   (if (string=? (string-ref text 0) \" \")\n            (set! text (replace\
    \ text 0 (string-length text) \"_\"))\n        (if (or (string=? (string-ref text\
    \ 0) \" \") (string=? (string-ref text 0) \"\\n\")) (reverse first)\n        (if\
    \ (or (string=? (string-ref text 0) \" \") (string=? (string-ref text 0) \"\\\
    n\")) (set! text (replace text 0 (string-length text) \"_\"))\n        (if (string=?\
    \ (string-ref text 0) \" \")\n            (set! text (replace text 0 (string-length\
    \ text) \"_\"))\n        (if (or (string=? (string-ref text 0) \" \") (string=?\
    \ (string-ref text 0) \"\\n\")) (reverse first)\n        (if (or (string=? (string-ref\
    \ text 0) \" \") (string=? (string-ref text 0) \"\\n\")) (set! text (replace text\
    \ 0 (string-length text) \"_\"))\n        (if (string=? (string-ref text 0) \"\
    \ \")\n            (set! text (replace text 0 (string-length text) \"_\"))\n \
    \       (if (or (string=? (string-ref text 0) \" \") (string=? (string-ref text\
    \ 0) \"\\n\")) (reverse first)\n        (if (or (string=? (string-ref text 0)\
    \ \" \") (string=? (string-ref text 0) \"\\n\")) (set! text (replace text 0 (string-length\
    \ text) \"_\"))\n        (if (string=? (string-ref text 0) \" \")\n          \
    \  (set! text (replace text 0 (string-length text) \"_\"))\n        (if (or (string=?\
    \ (string-ref text 0) \" \") (string=? (string-ref text 0) \"\\n\")) (reverse\
    \ first)\n        (if (or (string=? (string-ref text 0) \" \") (string=? (string-ref\
    \ text 0) \"\\n\")) (set! text (replace text 0 (string-length text) \"_\"))\n\
    \        (if (string=? (string-ref text 0) \" \")\n            (set! text (replace\
    \ text 0 (string-length text) \"_\"))\n        (if (or (string=? (string-ref text\
    \ 0) \" \") (string=? (string-ref text 0) \"\\n\")) (reverse first)\n        (if\
    \ (or (string=? (string-ref text 0) \" \") (string=? (string-ref text 0) \"\\\
    n\")) (set! text (replace text 0 (string-length text) \"_\"))\n        (if (string=?\
    \ (string-ref text 0) \" \")\n            (set! text ", "  (cond [(= (length text)\
    \ 0)\n         \"\"]\n        [(and (equal? (char-code text) 32)\n           \
    \    (not (equal? (char-code (char text 0)) 32)))\n         text]\n        [else\
    \ (let ([chars (remove-duplicates \n                           (cond [(= (length\
    \ text) 0)\n                                (list)\n                         \
    \       [(equal? (char-code text) 32)\n                                 (not (equal?\
    \ (char-code (char text 0)) 32))]\n                               [(equal? (char-code\
    \ text) 32)\n                                (char (char text 0)\n           \
    \                   (char (char text 0)\n                              (char (char\
    \ text 0)\n                              (+ (char (char text 0)\n            \
    \                    (char (char text 0)\n                                (char\
    \ (char text 0)\n                                (char (char text 0)\n       \
    \                         (char (char text 0)\n                              \
    \  (char (char text 0)\n                                (char (char text 0)\n\
    \                                (char (char text 0)\n                       \
    \         (char (char text 0)\n                                (char (char text\
    \ 0)\n                                (char (char text 0)\n                  \
    \              (char (char text 0)\n                                (char (char\
    \ text 0)\n                                (char (char text 0)\n             \
    \                   (char (char text 0)\n                                (char\
    \ (char text 0)\n                                (char (char text 0)\n       \
    \                         (char (char text 0)\n                              \
    \  (char (char text 0)\n                                (char (char text 0)\n\
    \                                (char (char text 0)\n                       \
    \         (char (char text 0)\n                                (char (char text\
    \ 0)\n                                (char (char text 0)\n                  \
    \              (char (char text 0)\n                                (char (char\
    \ text 0)\n                                (char (char text 0)\n             \
    \                   (char (char text 0)\n                                (char\
    \ (char text 0)\n                                (char (char text 0)\n       \
    \                         (char (char text 0)\n                              \
    \  (char (char text 0)\n                                (char (char text 0)\n\
    \                                (char (char text 0)\n                       \
    \         (char (char text 0)\n                                (char (char text\
    \ 0)\n                                (char (char text 0)\n                  \
    \              (char (char text 0)\n                                (char (char\
    \ text 0)\n                                (char (char text 0)\n             \
    \                   (char (char text 0)\n                                (char\
    \ (char text 0)\n                                (char (char text 0)\n       \
    \                         (char (char text 0)\n                              \
    \  (char (char text 0)\n                                (char (char text 0)\n\
    \                                (char (char text 0)\n                       \
    \         (char (char text 0)\n                                (char (char text\
    \ 0)\n                                (char (char text 0)\n                  \
    \              (char (char text 0)\n                                (char (char\
    \ text 0)\n                                (char (char text 0)\n             \
    \                   (char (char text ", "  (let ((replaced-spaces '())\n     \
    \   (current-text text))\n    (if (string? current-text)\n        (if (string-length?\
    \ current-text) (cons current-text replaced-spaces)\n          (if (string-length?\
    \ current-text) (cons current-text replaced-spaces)\n            (cons current-text\
    \ replaced-spaces))\n        replaced-spaces)\n    (if (string-length? current-text)\
    \ (cons current-text replaced-spaces)\n      replaced-spaces)))\n</cell>\n<code\
    \ language=dyalog-kernel>", "  (cond\n    ((string=? text \"\")\n     text)\n\
    \    ((string-length text) \"\")\n    ((string=? text \" \") text)\n    ((string=?\
    \ text \"  \") \"-\")\n    ((string=? text \"  \") \"-\")\n    ((string-length\
    \ text) (if (string=? text \" \")\n                             (string-replace\
    \ text \" \" \"_\" #:count 2)\n                             (string-replace text\
    \ \" \" \"_\" #:count 1)))\n    (else (cons (string=? text \" \")\n          \
    \        (fix_spaces (string-replace text \" \" \"\" #:count 0))))))\n", "  (let\
    \ loop ((text text)\n             (res '()))\n    (cond\n      [(empty? text)\
    \ res]\n      [(char? text) (loop (cdr text) (cons (car text) res))]\n      [else\
    \ (loop (cdr text) (cons (make-string (/ (string-length text) 2) text) res))]\n\
    \      )))\n", "  (cond\n    ((string? text) text)\n    ((= (length text) 1) text)\n\
    \    ((string? (cdr text)) (car text))\n    ((equal? (car text) \" \")\n     (cond\
    \ \n       ((equal? (cdr text) \" \")\n        (set! text (cons (car text) (append\
    \ (fix_spaces (cdr text))\n                                       (list (car text))))))\n\
    \       (else (cons (car text) (fix_spaces (cdr text)))))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=0 |>\nHere's a solution that doesn't use recursion and should\
    \ be slightly faster since it doesn't use recursion in the if clause.\n<code>",
  "  (cond [(string-length = text) text]\n        [(or (char=? (char text 0) #\\Space)\n\
    \             (char=? (char text 0) #\\NewLine))\n         text]\n        [else\n\
    \         (cond [(string-length = \n                     (remove-if-not (lambda\
    \ (x) (char=? (char text 0) x))\n                                  (remove-if\
    \ (lambda (x) (char=? (char x 0) #\\Space))\n                                \
    \           (remove-if (lambda (x) (char=? (char x 0) #\\NewLine))\n         \
    \                                         text)))\n                  (replace-each\
    \ (lambda (x) (if (char=? (char x 0) #\\Space) #\\_ (char x 0))\n            \
    \                     text)]))]))\n", "  (let ([chars (string->chars text)])\n\
    \    (cond\n      [(or (string= text \"\") (string= text \"\\n\")) text]\n   \
    \   [else (cond \n                [\n                  [(string= text \" \") (cons\
    \ _ chars)]\n                  [else (cons _ \n                             (set!\
    \ chars (append chars\n                                                (set! chars\
    \ (append chars (list->string\n                                              \
    \                           (string->list text)))))))]\n                ]\n  \
    \    )]))\n", "  (if (null? text) \n      text\n      (replace-all \"  \" (append\
    \ (substring text 0 2) (substring text 3)))))\n", "  (cond\n    [(= (length text)\
    \ 0) \"\"]\n    [(= (length text) 1) (string text)]\n    [(equal? (car text) \"\
    \ \")\n     (cond\n       [(= (length (rest text)) 2) (cons (substring (string\
    \ text) 0 1) (cons (substring (string text) 1 2) (cons (substring (string text)\
    \ 2 3) \"\"))]\n       [(= (length (rest text)) 1) (cons (substring (string text)\
    \ 0 1) \"\")]\n       [else (cons (substring (string text) 0 1) (cons (fix_spaces\
    \ (substring (string text) 1 -1)) \"\"))]\n       )\n     ]\n    [else (cons (fix_spaces\
    \ (substring (string text) 0 -1)) (cons (string text) \"\"))]))\n", "  (cond [(empty?\
    \ text) empty]\n        [(list? (first text)) (let ([head (first text)]) (fix_spaces\
    \ (rest text)) (cons head (replace (rest (rest text)) \" \" \"-\"))))]\n     \
    \   [else (replace text \" \" \"_\")]))\n", "  (cond [(string-length text) text]\n\
    \        [(equal? text (string-append text \"       \")) (string-append text \"\
    -\")]\n        [(string-length \n         (string->list (string->string text)))\
    \ \n         (let ([current-index (string-length text)])\n           (let ([new-index\
    \ (add1 current-index)])\n             (cond [(equal? new-index 0) (cons (subseq\
    \ text 0 (current-index)) \n                                                 \
    \ (cons (subseq text (current-index) (string-length text)))\n                \
    \                                  (cons (subseq text (current-index) new-index)\
    \ \n                                                      (cons (subseq text (current-index)\
    \ new-index) \n                                                          (subseq\
    \ text (current-index) new-index))))]\n                   [else (cons (subseq\
    \ text 0 (current-index)) \n                                (cons (subseq text\
    \ (current-index) (new-index))\n                                      (cons (subseq\
    \ text (current-index) new-index)\n                                          \
    \  (subseq text (current-index) new-index))\n                                (subseq\
    \ text (current-index) new-index))]))]))\n        [else (cons (subseq text 0 (string-length\
    \ text))\n                    (cons (subseq text 0 0) \n                     \
    \     (subseq text 0 0))\n                    (subseq text 0 (string-length text)))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) \" \") (cons (first\
    \ text) (fix_spaces (rest text)))]\n    [(equal? (first text) (first text))\n\
    \     (cons (first text)\n           ((and (equal? (first text) (second text))\n\
    \                (equal? (rest text) \"\")))]\n    [else \n     (let ([space (first\
    \ text)]\n           [i (+ 1 space)])\n       (cons (first text)\n           \
    \  (cons (first text)\n                  (fix_spaces (cons (first text)\n    \
    \                             (cons (first text)\n                           \
    \           (cons (first text)\n                                            (rest\
    \ text))))))]))\n</code>\n<|/ a tags=scheme,racket,recursion dscore=2 |>\n<| c\
    \ |>\nI love your solution! It makes me think about how I might implement this\
    \ in racket without writing a separate function. That way I could learn a lot,\
    \ and my code would be easier to understand and follow in the future.\n<|/ c |>\n\
    <| c |>\nI love your solution as well! I'm also interested in how to write this\
    \ in racket, since I find writing functions as pure as possible very helpful.\
    \ But it seems to me that Racket already has some really nice ways to handle this\
    \ kind of problem... so maybe I should ask about that instead. I'm still new to\
    \ racket so I'm still trying to figure out how to do things the \"right\" way\
    \ :-)\n<|/ c |>\n<| c |>\n: I agree that Racket has some really nice ways to handle\
    \ this kind of problem, but Racket is a *very* different language from Racket.\
    \  So I wouldn't start thinking of Racket as a *pure functional* language.  I\
    \ would be more inclined to think of it as a *functional* language with very nice\
    \ syntax.  Racket is also a nice functional language, but it is very different\
    \ from Racket's functional programming language.  I would suggest reading [Haskell's\
    \ Wikibook on Monads](http://en.wikibooks.org/wiki/Haskell/Monads) for a good\
    \ introduction to functional programming, and if you really want to understand\
    \ functional programming, perhaps start by looking at [the excellent book _Real\
    \ World Functional Programming_](http://book.realworldhaskell.org/read/), which\
    \ is what I think everyone will use when working with functional languages.  It's\
    \ very easy to understand and very easy to understand...\n<|/ c |>\n<|", "  (cond\n\
    \    ((string? text) text)\n    ((string-length (string->list (string->list text)))\
    \ text)\n    ((string->list (string->list text)) text)\n    ((not (string? text))\n\
    \     (string-replace (lambda (i j)\n                      (if (eq? (string->char\
    \ (car i)) #\\space)\n                          (if (equal? (string->char (car\
    \ i)) #\\space)\n                              (if (equal? (string->char (car\
    \ i)) #\\space)\n                                  (string->char (car i))\n  \
    \                                (string->char (car i)))\n                   \
    \           (string->char (car i)))\n                          (string->char (car\
    \ i)))\n                       (string->list (string->list j)))\n            \
    \       text\n                   #\\space)\n    (else text)))\n", "  (cond\n \
    \   [(empty? text)\n      text]\n    [(space? text)\n      (let_loop\n       \
    \ [(i 0)\n         (prev 'false)\n         (cur 'false)\n         (newtext (cons\
    \ (substring text i (length text)) '_'))]\n        (set! i (+ i 1))\n        (when\
    \ (= i (length text))\n          (set! prev cur)\n          (set! cur 'false))\n\
    \        (when (eq? (space? prev) cur)\n          (set! newtext newtext))\n  \
    \      (when (not cur)\n          (set! newtext newtext)))\n      (cons (substring\
    \ text 0 (- (length text) (+ i (length text))) ) \n            (fix_spaces (substring\
    \ text i)))]\n    [else\n      (cons (substring text 0 (- (length text) (+ i (length\
    \ text))) ) \n            (fix_spaces (substring text i)))]\n    ))\n", "  (cond\n\
    \    [(= (string-length text) 0)\n      \"\"]\n    [else\n     (string->symbol\
    \ (string-replace-all text #{\\ } #{\"_\"}))]))\n", "  (define (fix text)\n  \
    \  (cond\n      [(empty? text) empty]\n      [(string? text) (cons (replace (first\
    \ text) \" \" \"_\") (replace (rest text) \" \" \"_\"))]\n      [else (replace\
    \ text \" \" \"_\")]))\n  (fix text))\n", "  (cond\n    [(empty? text)\n     \
    \ empty]\n    [else\n      (cond\n        [(string-match? \" \" (first text))\n\
    \          (cond\n            [(string-match? \" \" (second text))\n         \
    \     (cond\n                [(string-match? \" \" (third text))\n           \
    \       (cond\n                    [(string-match? \" \" (fourth text))\n    \
    \                  (cond\n                        [(string-match? \" \" (fifth\
    \ text))\n                          (cond\n                            [(string-match?\
    \ \" \" (sixth text))\n                              (cond\n                 \
    \               [(string-match? \" \" (seventh text))\n                      \
    \            (cond\n                                    [(string-match? \" \"\
    \ (eighth text))\n                                      (cond\n              \
    \                          [(string-match? \" \" (nineth text))\n            \
    \                              (cond\n                                       \
    \     [(string-match? \" \" (tenth text))\n                                  \
    \            (cond\n                                                [(string-match?\
    \ \" \" (eleventh text))\n                                                  (cond\n\
    \                                                    [(string-match? \" \" (twelveth\
    \ text))\n                                                      (cond\n      \
    \                                                  [(string-match? \" \" (thirteenth\
    \ text))\n                                                          (cond\n  \
    \                                                          [(string-match? \"\
    \ \" (fourteenth text))\n                                                    \
    \          (cond\n                                                           \
    \     [(string-match? \" \" (fifteenth text))\n                              \
    \                                    (cond\n                                 \
    \                                   [(string-match? \" \" (sixteenth text))\n\
    \                                                                     (cond\n\
    \                                                                       [(string-match?\
    \ \" \" (seventeenth text))\n                                                \
    \                         (cond\n                                            \
    \                               [(string-match? \" \" (eighteenth text))\n   \
    \                                                                         (cond\n\
    \                                                                            \
    \  [(string-match? \" \" (nineteenth text))\n                                \
    \                                                (cond\n                     \
    \                                                             [(string-match?\
    \ \" \" (twentieth-fifth text))\n                                            \
    \                                        (string-append \"_\" (second text))\n\
    \                                                                            \
    \      ]\n                                                                   \
    \               [else\n                                                      \
    \                              (string-append \"_\" (second text))\n         \
    \                                                                         ]\n\
    \                                                                            \
    \    ]\n                                                                     \
    \         )\n                                                                \
    \           ]\n                                                              \
    \             [else\n                                                        \
    \                    (cond\n                                                 \
    \                             [(string-match? \" \" (ten-fifth text))\n      \
    \                                                                          (cond\n\
    \                                                                            \
    \      [(string-match? \" \" (eleven-fifth text))\n                          \
    \                                                          (cond\n           \
    \                                                                           [(string-match?\
    \ \" \" (twelve-fifth text))\n                                               \
    \                                         (string-append \"_\" (third text))\n\
    \                                                                            \
    \          ]\n                                                               \
    \                       [else\n                                              \
    \                                          (string-append \"_\" (third text))\n\
    \                                                                            \
    \          ]\n                                                               \
    \                     ]\n                                                    \
    \                              ]\n                                           \
    \                                       [else\n                              \
    \                                                      (cond\n               \
    \                                                                       [(string-match?\
    \ \" \" (twenty-fifth text))\n                                               \
    \                                         (", "  (cond\n    ((empty? text)\n \
    \    text)\n    ((eq? (first text) \" \")\n     (replace (rest text) \"_\"))\n\
    \    ((eq? (first text) \" \")\n     (fix_spaces (replace (rest text) \"-\")))\n\
    \    ((> (length text) 2)\n     (fix_spaces (replace (rest text) \"_\")))\n  \
    \  (else\n     (fix_spaces (replace (rest text) \"_\")))))\n</code>\n<|/ a dscore=0\
    \ tags=racket,scheme |>\n<| c |>\nThanks so much for this! I'm sorry if my original\
    \ question was vague, but I wasn't sure how to ask it exactly.\n<|/ c |>\n<| c\
    \ |>\nYou're welcome! You might also be interested in the [Racket-specific version\
    \ of the code in the other answer](http://stackoverflow.com/questions/7256517/how-can-i-replace-multiple-spaces-in-a-string-in-racket).\n\
    <|/ c |>\n<| c |>\nIt should also be noted that there are many ways to write this\
    \ code, and many different versions (some with more efficiency than others). You\
    \ might also consider [this other answer](http://stackoverflow.com/a/7256641/849891)\
    \ which contains several variations of this code.\n<|/ c |>\n<| c |>\nAnd here's\
    \ yet another variation that works on any sequence: see [this answer](http://stackoverflow.com/a/7256641/849891).\n\
    <|/ c |>\n<| c |>\nThanks again. I'll take a look at each of those.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's another way using regular expressions:\n<code>", "  (let\
    \ ((i (string-length text))\n        (str (make-string i #\\space)))\n    (when\
    \ (= i 0)\n      (str text))\n    (if (= i 2)\n        (string-set! str (subseq\
    \ str 0 1) #\\underscore)\n        (let ((prev (char-before text)))\n        \
    \  (when (char-equal prev #\\space)\n            (string-set! str (subseq str\
    \ 1 i) #\\space))\n          (when (char-equal prev #\\space)\n            (string-set!\
    \ str (subseq str 1 i) #\\-))\n          (set! str (subseq str 2))\n         \
    \ (str)))))\n", "  (cond\n    [(empty? text) (empty?)] \n    [(equal? (first text)\
    \ \" \")\n     (cons (string->string \"_\") (rest text))] \n    [else (cons (string->string\
    \ \"-\")\n                (rest (fix_spaces (rest text))))]))\n", "  (cond\n \
    \   ((= text \"\")              \"\")\n    ((= text \" \")              \"_\"\
    )\n    ((string-length (substring text 0 1)) 2)\n    ((string-length (substring\
    \ text 0 2)) 1)\n    ((equal? (substring text 0 2) \" \"))\n    (else        \
    \              (substring text 0 2)\n               (fix_spaces (substring text\
    \ 2 string-length (substring text 0 2)))\n               (fix_spaces (substring\
    \ text 0 1))))))\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIt's pretty simple to replace\
    \ all spaces with underscores and hyphens simultaneously. The trick is to first\
    \ replace all spaces with hyphens, then replace all hyphens with underscores.\
    \ Finally, replace all underscores with spaces (since underscores are removed\
    \ above).\n<code>", "  (cond [(< text \" \") text]\n        [(and (spaces (substring\
    \ text 0 2))\n              (spaces (substring text 3)))\n         \n        \
    \ (string->symbol\n          (substring text 0 2)\n          \"-\"\n         \
    \ (substring text 3)\n          \"_\")\n         ]\n        [else\n         (string->symbol\n\
    \          (substring text 0 2)\n          \"_\"\n          \"-\"\n          (substring\
    \ text 3)\n          \"_\")\n         ]\n        [(> text \" \") text]))\n", " \
    \ (define (replace str)\n    (cond\n      [(empty? str) \"\"]\n      [(string=?\
    \ (first str) \" \") (substring (second str) 0 -1)]\n      [else (cons (first\
    \ str) (cons (second str) (replace(rest str))))]))\n  (cond \n    [(empty? text)\
    \ \"\"]\n    [else (cons (replace text) (fix_spaces (rest text)))]))\n", "  (if\
    \ (or (null? text) (string-length (substring text 0 1)) = 0)\n      (substring\
    \ text 0 -1)\n      (let ((space (substring text 0 1)))\n        (cond\n     \
    \     ((equal space \" \")\n           (cons (substring text 0 2)\n          \
    \       (fix_spaces (substring text 2)))\n           (cons (substring text 0 1)\n\
    \                 (fix_spaces (substring text 1)))\n           (else\n       \
    \    (cons (concat space \"_\")\n                 (fix_spaces (substring text\
    \ 2)))\n           (cons (concat space \"_\")\n                 (fix_spaces (substring\
    \ text 1)))\n           (cons (concat space \"-\")\n                 (fix_spaces\
    \ (substring text 2)))\n           (cons (concat space \"-\")\n              \
    \   (fix_spaces (substring text 1)))))))))\n", "  (let ([fix-space #\\s]\n   \
    \     [fix-no-space #\\[space]]\n        [fix-double #\\[space]]\n        [fix-one-space\
    \ #\\[space]]\n        [fix-no-space #\\]]\n        [fix-double #\\]]\n      \
    \  [fix-one #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote #\\\
    ]]\n        [fix-one #\\]]\n        [fix-no-space #\\]]\n        [fix-one-space\
    \ #\\]]\n        [fix-no-space #\\]]\n        [fix-double #\\]]\n        [fix-no-space\
    \ #\\]]\n        [fix-double-quote #\\]]\n        [fix-no-space #\\]]\n      \
    \  [fix-double-quote #\\]]\n        [fix-double-quote #\\]]\n        [fix-one-space\
    \ #\\]]\n        [fix-double #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote\
    \ #\\]]\n        [fix-no-space #\\]]\n        [fix-one #\\]]\n        [fix-double-quote\
    \ #\\]]\n        [fix-double #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote\
    \ #\\]]\n        [fix-one-space #\\]]\n        [fix-no-space #\\]]\n        [fix-double\
    \ #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote #\\]]\n      \
    \  [fix-no-space #\\]]\n        [fix-double-quote #\\]]\n        [fix-double-quote\
    \ #\\]]\n        [fix-double-quote #\\]]\n        [fix-double-quote #\\]]\n  \
    \      [fix-double-quote #\\]]\n        [fix-double-quote #\\]]\n        [fix-no-space\
    \ #\\]]\n        [fix-double-quote #\\]]\n        [fix-double #\\]]\n        [fix-no-space\
    \ #\\]]\n        [fix-double-quote #\\]]\n        [fix-no-space #\\]]\n      \
    \  [fix-double #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote #\\\
    ]]\n        [fix-no-space #\\]]\n        [fix-no-space #\\]]\n        [fix-no-space\
    \ #\\]]\n        [fix-double-quote #\\]]\n        [fix-no-space #\\]]\n      \
    \  [fix-double-quote #\\]]\n        [fix-no-space #\\]]\n        [fix-double-quote\
    \ #", "  (let ([space (subseq text 0 (string-length text) 1)])\n    (if (or (empty?\
    \ space) (string= space \" \"))\n        text\n        (let ([result (subseq text\
    \ 0 (string-length text) 1)])\n          (if (or (empty? space) (string= space\
    \ \" \"))\n              (concat \"-\" (subseq result 1 (string-length result)\
    \ 1))\n              (concat \"-\" (subseq result 0 (string-length result) 1))\n\
    \            )\n        )\n    )\n  )\n)\n", "  (let ([s text])\n    (cond\n \
    \     [(empty? s) \"\"]\n      [else\n       (cond [(or (string=? \" \" (car s))\
    \ (string=? \" \" (cadr s))) (cond [(equal? (substring s 0 (string-length s))\
    \ \" \") (string-append \"_\" (substring s (string-length s)))]\n            \
    \                                   [else (string-append \"_\" (substring s 0\
    \ (string-length s)))])]\n             [(or (string=? \" \" (car s)) (string=?\
    \ \" \" (cadr s)) (equal? (substring s 0 (string-length s)) \" \"))\n        \
    \    (cond [(equal? (substring s 0 (string-length s)) \" \") (string-append \"\
    -\" (substring s (string-length s)))]\n                  [else (string-append\
    \ \"-\" (substring s 0 (string-length s)))])]\n       [else (cond [(equal? (substring\
    \ s 0 (string-length s)) \" \") (string-append \"_\" (substring s (string-length\
    \ s)))]\n                     [else (string-append \"_\" (substring s 0 (string-length\
    \ s)))])]))))\n", "  (cond\n    ((empty? text) #f)\n    ((equal? text #\\s) text)\n\
    \    ((not (equal? (first text) #\\s)) text)\n    ((string=? (second text) #\\\
    s) (string-replace (second text) #\\s #\\_))\n    ((equal? (second text) #\\s)\
    \ (replace-all #\\s #\\- text))\n    ((not (equal? (second text) #\\s)) (replace-all\
    \ #\\s #\\- text))\n    ((not (equal? (second text) #\\s)) (replace-all #\\s #\\\
    _ #\\- text))\n    (else text))\n)\n", "  (let*\n      ([result (join (map char-code\
    \ (split-string text #\"\\s\")) \"_\")]\n       [result (map char-code (split-string\
    \ result #\"\\s\"))]\n       [result (map char-code (split-string result #\"\\\
    s\"))])\n    (if (> (length result) 2)\n        (join (map char-code (split-string\
    \ result #\"\\s\"))\n               (join (map char-code (split-string result\
    \ #\"\\s\"))\n                       (join-string \"-\"))\n        result)))\n",
  "  (let ((s (reverse (map #(char (- 32 #\\Space)) text))) \n        (s2 #(if (and\
    \ (equal? s s2) (char=? (first s) (char=? (second s))) #\\Space #\\-)))\n    (map\
    \ reverse (map #(char (- 32 #\\Space)) text))))\n", "  (cond [(null? text) text]\n\
    \        [(empty? (rest text)) text]\n        [(= 2 (length text)) text]\n   \
    \     [(equal? (first text) \" \") (replace-all \" \" '_' text)]\n        [else\n\
    \         (let ([text (rest text)])\n           (if (= 1 (length text))\n    \
    \         (if (equal? (first text) \" \")\n               (replace-all \" \" '-'\
    \ text)\n               (list text))\n             (list text))]))\n  )\n", " \
    \ (if (empty? text)\n      text\n      (let ((c (first text)))\n        (if (=\
    \ c #\\space)\n            (string \"_\" (second text))\n            (cons (car\
    \ text) \n                  (fix_spaces (cdr text))))))\n", "  (cond\n    [(empty?\
    \ text)\n     empty]\n    [else\n     (string-replace text #\\space #\\_)\n  \
    \   (string-replace-all text #\\_ \"-\")]))\n", "  (match text\n    [_ (return\
    \ text)]\n    [_ \"_\" (replace text \" \")\n     [else (return (fix_spaces (replace\
    \ text \" \" \"_\")))]))\n</code>\n<|/ a tags=scheme dscore=0 |>\n<| c |>\nI like\
    \ your solution as it works and uses built-in functions. It however does not work\
    \ for strings with more than one space between words. I guess it is because you\
    \ use recursion instead of loops. Also, `replace` only replaces the first occurrence\
    \ of a character in a string. In my case, the string is supposed to be treated\
    \ as a single string which is not case sensitive.\n<|/ c |>\n<| c |>\nYou can\
    \ fix that by first replacing all the occurrences of more than one space with\
    \ two spaces. I'll edit my post to show you what I mean.\n<|/ c |>\n<| c |>\n\
    Thank you for updating your answer. My main problem with this answer is that it\
    \ replaces all occurrences of two or more spaces with a single space. My string\
    \ does not contain any two or more spaces. It has spaces between words with different\
    \ lengths. For example: `\" Example\"` should return `\"Example\"` but `\" Example\
    \ 1\"` should return `\"Example_1\"`.\n<|/ c |>\n<| c |>\nI see. I'll fix my code\
    \ to do what you're looking for. I think this is what you're looking for: `(define\
    \ (fix_spaces text)\n  (cond\n    [(empty? text) text]\n    [(equal? (first text)\
    \ ?whitespace) (fix_spaces (rest text))\n     [else (cons (first text) (fix_spaces\
    \ (rest text)))]))`\n<|/ c |>\n<| c |>\nThank you. I changed `whitespace` with\
    \ `(list? (first text))` to make it case insensitive. I added `[elseif (equal?\
    \ (first text) ?whitespace)\n (cons (first text)\n        (fix_spaces (rest text)))]`\
    \ to make it work for strings with no spaces. I changed `return text` to `cons\
    \ text (fix_spaces (rest text))` because in my case, an empty string would return\
    \ `()`.\n<|/ c |>\n<| a tags=scheme |>\nA simpler approach might be to use regex:\n\
    <code>", "  (cond\n    [(= #\\Space (char text)) (cons (char text) (fix_spaces\
    \ (substring (text 1) #\\Space)))]\n    [(> #\\Space (char text)) (cons (char\
    \ text) (fix_spaces (substring (text 1) #\\Space)))]\n    [else (cons (char (char\
    \ (substring text 0 1) (substring text 0 1)) #\\Space) (fix_spaces (substring\
    \ (text 1) #\\Space)))]\n    [else (cons (char (substring text 0 1) (substring\
    \ text 0 1)) (fix_spaces (substring (text 1) #\\Space)))]))\n</code>\n<|/ a dscore=4\
    \ tags=racket,string,lisp,regex |>\n<| a dscore=4 |>\nHere is a solution that\
    \ replaces one or more spaces with _. The second parameter of replace/substring\
    \ is the size of the substring to look for, so you can replace multiple spaces\
    \ at once by providing a positive number for that parameter. \n<code>", "  (cond\n\
    \   ((empty? text) \"\")\n   ((eq? (first text) \" \")(set! text (substring text\
    \ 2 ))))\n   ((> (length text) 2)(set! text (substring text 1 )))))\n", "  (cond\n\
    \    ((string? text) (replace-all text \" \" \"_\"))\n    ((= (string-length text)\
    \ 0) text)\n    ((= (string-length text) 1) text)\n    ((char= (first text) ?#\\\
    Space)\n     (replace-all text ?#\\Space \"_\"))\n    (else (cons (first text)\
    \ (fix_spaces (rest text))))))\n", "  (cond\n    [(string-blank? text) \"\"]\n\
    \    [else\n     (string->string \n      (replace-all text (set->list \" \") \"\
    _\"))\n     ]))\n", "  (define (space-replacement spaces)\n    (if (empty? spaces)\
    \ \n        '_\n        (if (= (length (car spaces)) 2)\n            (cons (car\
    \ spaces) (cons _ car spaces))\n            (cons (car spaces) (car spaces))))\n\
    \  (define (multiple-spaces-replacement spaces)\n    (if (empty? spaces) \n  \
    \      '_\n        (let ([last-char (car spaces)])\n          (if (= last-char\
    \ '_)\n              (cons last-char (car spaces))\n              (cons (car spaces)\
    \ (cons last-char (car spaces))))))\n  (let ([spaces (string->list text)]\n  \
    \      (new-text (space-replacement spaces))\n        (new-spaces (multiple-spaces-replacement\
    \ spaces)))\n    (if (> (length new-spaces) 2)\n        (space-replacement new-spaces)\n\
    \        new-text))\n</code>\n<|/ a tags=racket,scheme,string |>\n<| c |>\nThis\
    \ seems like a great answer, but you also need to explain your algorithm. Just\
    \ posting a block of code isn't going to help.\n<|/ c |>\n<| c |>\nYeah, I wouldn't\
    \ want to give the OP any credit if I had to write an explanation for the algorithm\
    \ since he would have learned nothing from that. I've just added the code snippets\
    \ he asked for. Hope that helps!\n<|/ c |>\n<| c |>\n: Sure :) Thanks for providing\
    \ the code as well. :)\n<|/ c |>\n<| c |>\nThis doesn't actually work: for instance,\
    \ `(space-replacement \" Example\")` yields `\"_Example\"` instead of `\"Example\"\
    `.\n<|/ c |>\n<| c |>\n: I've fixed that now!\n<|/ c |>\n<| a |>\nHere's a slightly\
    \ different approach to John's answer: it converts strings containing spaces to\
    \ strings containing dashes.\n<code>", "  (let ((str (string->list text)))\n \
    \   (if (null? str)\n        '()\n        (let ((first (car str))\n          \
    \    (last (cdr str)))\n          (if (string=? first \" \")\n              (if\
    \ (string=? last \" \")\n                  (cons last '())\n                 \
    \ (cons '_ (cons (string->list (string->string first)) '())))\n              (cons\
    \ '_ (cons (string->list (string->string first)) '()) (fix_spaces (string->string\
    \ last)))))\n    (append (list (string->string (car str))) (fix_spaces (string->string\
    \ (cdr str))))))\n", "  (cond\n    ((empty? text) text)\n    (\n      (= (length\
    \ text) 1)\n      (text '_)\n    )\n    (\n      (equal? (first text) #\\Space)\n\
    \      (cons (first text) (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n\
    \    )\n    (\n      (equal? (first text) #\\Space)\n      (cons (first text)\
    \ (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n    )\n    (\n  \
    \    (= (first text) #\\Space)\n      (cons (first text) (fix_spaces (rest text)))\n\
    \      (fix_spaces (rest text))\n    )\n    (\n      (equal? (first text) #\\\
    Space)\n      (cons (first text) (fix_spaces (rest text)))\n      (fix_spaces\
    \ (rest text))\n    )\n    (\n      (equal? (first text) #\\Space)\n      (cons\
    \ (first text) (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n   \
    \ )\n    (\n      (equal? (first text) #\\Space)\n      (cons (first text) (fix_spaces\
    \ (rest text)))\n      (fix_spaces (rest text))\n    )\n    (\n      (equal? (first\
    \ text) #\\Space)\n      (cons (first text) (fix_spaces (rest text)))\n      (fix_spaces\
    \ (rest text))\n    )\n    (\n      (equal? (first text) #\\Space)\n      (cons\
    \ (first text) (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n   \
    \ )\n    (\n      (equal? (first text) #\\Space)\n      (cons (first text) (fix_spaces\
    \ (rest text)))\n      (fix_spaces (rest text))\n    )\n    (\n      (equal? (first\
    \ text) #\\Space)\n      (cons (first text) (fix_spaces (rest text)))\n      (fix_spaces\
    \ (rest text))\n    )\n    (\n      (equal? (first text) #\\Space)\n      (cons\
    \ (first text) (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n   \
    \ )\n    (\n      (equal? (first text) #\\Space)\n      (cons (first text) (fix_spaces\
    \ (rest text)))\n      (fix_spaces (rest text))\n    )\n    (\n      (equal? (first\
    \ text) #\\Space)\n      (cons (first text) (fix_spaces (rest text)))\n      (fix_spaces\
    \ (rest text))\n    )\n    (\n      (equal? (first text) #\\Space)\n      (cons\
    \ (first text) (fix_spaces (rest text)))\n      (fix_spaces (rest text))\n   \
    \ )\n    (\n      (equal? (first text) #\\", "  (cond\n    ((string-empty? text)\n\
    \      (cond\n        ((string-length (text)) \n         (string->string (make-string\
    \ (string-length (text))))) \n        (else '()))\n    ((string= text (concat\
    \ (substring (text 0 (string-length (text))))\n                         ((substring\
    \ (text 1 string-length (text))))\n                         ((substring (text\
    \ (string-length (text)) \n                                     (string-length\
    \ (text)))))))\n    (string->string (make-string (string-length (text))))\n  \
    \  (else (cond \n           ((string= text \" \") \n            (cond \n     \
    \         ((string-length (text)) \n               (string->string (make-string\
    \ (string-length (text))))) \n              (else (cond \n                   \
    \    ((string= text \"  \") \n                        (cond \n               \
    \           ((string-length (text)) \n                           (string->string\
    \ (make-string (string-length (text))))) \n                          (else (cond\
    \ \n                                   ((string= text \" -\") \n             \
    \                       (cond \n                                      ((string-length\
    \ (text)) \n                                       (string->string (make-string\
    \ (string-length (text))))) \n                                      (else (cond\
    \ \n                                               ((string= text \"--\") \n \
    \                                               (cond \n                     \
    \                             ((string-length (text)) \n                     \
    \                              (string->string (make-string (string-length (text)))))\
    \ \n                                                  (else (cond \n         \
    \                                                  ((string= text \"---\") \n\
    \                                                            (cond \n        \
    \                                                      ((string-length (text))\
    \ \n                                                               (string->string\
    \ (make-string (string-length (text))))) \n                                  \
    \                            (else (cond \n                                  \
    \                                   ((string= text \"----\") \n              \
    \                                                        (cond \n            \
    \                                                            ((string-length (text))\
    \ \n                                                                         (string->string\
    \ (make-string (string-length (text))))) \n                                  \
    \                                      (else (cond \n                        \
    \                                                        (else (cond \n      \
    \                                                                            \
    \     ((> string-length (text) 2) \n                                         \
    \                                              (string->string (make-string (string-length\
    \ (text))))) \n                                                              \
    \                        (else (cond \n                                      \
    \                                                        (else \n            \
    \                                                                            \
    \       ((string= text \"---\") \n                                           \
    \                                                     (cond \n               \
    \                                                                            \
    \        ((string= text \"---\") \n                                          \
    \                                                          (cond \n          \
    \                                                                            \
    \                 ((string= text \"----\") \n                                \
    \                                                                       (cond\
    \ \n                                                                         \
    \                                ((string= text \"-----\") \n                \
    \                                                                            \
    \             (cond \n                                                       \
    \                                                      ((string= text \"--\")\
    \ \n                                                                         \
    \                                    (cond \n                                \
    \                                                                            \
    \     ((string= text \"---\") \n                                             \
    \                   ", "  (cond [(string-length (string-replace-all text \"[ ]+\"\
    \ \" \" '())) > 2]\n        [else\n         (string-replace-all text \"[ ]+\"\
    \ \"_\" \"_\" '())]))\n</code>\n<|/ a |>\n<| c |>\nThank you, this was exactly\
    \ what I needed.\n<|/ c |>\n<| a dscore=3 |>\nThis is an old thread, but I came\
    \ across a similar need and wrote my own function to do it. It may be useful for\
    \ someone else. \n<code>", "  (cond\n    [(string-length text) text]\n    [(or\
    \ (string=? \" \" text)\n          (string=? \"  \" text))\n     (replace text\
    \ \" \" \"_\")]\n    [else (make-string (string-length text) \" _\")]))\n", " \
    \ (let ((fixes ()))\n    (define (backtrack)\n      (cond [(not (empty? fixes))\
    \ (first (first fixes))])\n      (cond\n        ((string-match #rx (first fixes))\
    \ #rx (second (first fixes)))\n        ((string-match #rx (first fixes)) \"\"\
    )\n        (else (set! fixes (cons (first fixes) (first fixes)))\n           \
    \   (set! text (append (first text) (second (first fixes))))\n              (set!\
    \ fixes (list (second (first fixes))))\n              (set! backtrack)\n     \
    \         (set! fixes (list (first fixes))))))\n    (backtrack)\n    (string->symbol\
    \ (string-map #rx (substring text 0 (- (string-length text) 2))))\n    (remove-duplicates\
    \ fixes))\n", "  (if (empty? text)\n      '\n      (let ((x (string->list text)))\n\
    \        (if (= (length x) 1)\n            (if (string=? text \" \")\n       \
    \         (cons (string->symbol '-)\n                      (cons (first x) (if\
    \ (> (length x) 2) (string->list (rest x)))))\n              (cons (first x) (fix_spaces\
    \ (rest x))))\n            (if (string=? text \" \")\n                (cons (string->symbol\
    \ '_) (string->list (rest x)))))\n        (if (> 2 (length x))\n            (cons\
    \ (string->symbol '-) (string->list (rest x)))\n            (cons (first x) (fix_spaces\
    \ (rest x)))))))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (car text)\
    \ \" \") (cons (car text) (fix_spaces (cdr text)))]\n    [else\n      (cond\n\
    \        [(empty? (cdr text)) (cons (car text) (fix_spaces (cdr text)))]\n   \
    \     [(equal? (car text) \" \") (cons (car text) (fix_spaces (cdr text)))]\n\
    \        [else\n          (if (not (equal? (car text) \" \"))\n            (cond\n\
    \              [(equal? (car text) \" \") (cons (car text) (fix_spaces (cdr text)))]\n\
    \              [(equal? (cdr text) \" \") (cons (car text) (fix_spaces (cdr text)))]\n\
    \              [else (cons (car text) (fix_spaces (cdr text)))]\n            \
    \  ))]))))\n", "  (define (helper text index result)\n    (cond ((= index 0) result)\n\
    \          ((char=? text (char \" \" index)) (helper text (1+ index) (append result\
    \ \"_\")))\n          ((char=? text (char \" \" index) (1+ index)) (helper text\
    \ (1+ index) (append result \"-\")))\n          (else (helper text (1+ index)\
    \ result))))\n  (helper text 0 text))", "  (let ([spaces_text (all-spaces text)]\n\
    \        [fixed (make-string text 0)])\n    (if (empty? spaces_text)\n       \
    \ text\n        (if (>= (length (first spaces_text)) 2)\n            (string-replace\
    \ (make-string text 0)\n                            #(space-to-dash '(space))\
    \ #(space-to-dash '(space))\n                            fixed)\n            (let\
    \ ([part (split-at spaces_text 1)]\n                  [rest_part (subseq text\
    \ (+ 1 part))])\n              (string-replace (make-string text 0)\n        \
    \                    (cons (first spaces_text)\n                             \
    \      (split-at #(space-to-dash '(space)) part))\n                          \
    \  fixed)\n              (if (empty? rest_part)\n                  fixed\n   \
    \               (let ([part1 (split-at rest_part 1)]\n                       \
    \ [part2 (split-at rest_part 2)]\n                        [fixed1 (make-string\
    \ text 0)])\n                    (if (empty? part1)\n                        fixed1\n\
    \                        (if (= (length (first part1)) 2)\n                  \
    \          (if (empty? part2)\n                                (if (empty? part1)\n\
    \                                    fixed\n                                 \
    \   (cons (first part1)\n                                           (first part2))\n\
    \                                   (string-replace (make-string text 0)\n   \
    \                                                (cons #(space-to-dash '(space))\
    \ #(space-to-dash '(space)) fixed))\n                                   (fix_spaces\
    \ fixed1))\n                            (string-replace (make-string text 0)\n\
    \                                           (cons (first part1) \n           \
    \                                      (cons (first part2) \n                \
    \                                         (split-at #(space-to-dash '(space))\
    \ (subseq rest_part 0)))\n                                           fixed1)\n\
    \                            (fix_spaces fixed1)))))\n                  fixed))))))\n",
  "  (let ([split-text (split-string (text #\\Space))]\n        [index (length split-text)])\n\
    \    (cond\n      [(empty? split-text)\n       (string-append \"_\" split-text)\n\
    \       ]\n      [(equal? (modulo index 2) 0)\n       (string-append \"_\" split-text)\n\
    \       ]\n      [else\n      (for-each (lambda (char)\n                  (cond\n\
    \                   [(not (char-whitespace? char))\n                    (let [index\
    \ (add1 (modulo index 2))]\n                      (cond\n                    \
    \   [(= index 0)\n                        (string \"_\" char)\n              \
    \         ]\n                       [else\n                        (let [chars\
    \ (split-string (string \"_\" char)\n                                        \
    \   index)]\n                          (cond\n                           [(= (length\
    \ chars) 1)\n                             (string \"_\" char)\n              \
    \             ]\n                           [else\n                          \
    \   (for-each (lambda (c)\n                                        (cond\n   \
    \                                      [(char-whitespace? c)\n               \
    \                           (char-append \"_\" c)\n                          \
    \               ]\n                                         [else\n          \
    \                                (string \"_\" c)\n                          \
    \               ]))\n                             (string \"_\" char)])\n    \
    \                       ])\n                        )\n                      ])\n\
    \                  ]\n                  ))\n       (string-append \"_\" split-text)])))\n",
  "  (cond\n    [(empty? text)\n      empty]\n    [(equal? text #\\Space)\n      text]\n\
    \    [(equal? (car text) #\\Space)\n      (fix_spaces (cdr text))\n      (concat\
    \ (cons (car text) \"_\")\n               (fix_spaces (cdr text)))]\n    [else\n\
    \      (cons (car text)\n            (fix_spaces (cdr text)))]))\n", "  (cond\n\
    \    [(empty? text)\n     empty]\n    [(whitespace? (car text))\n     (cons (car\
    \ text)\n           (fix_spaces (cdr text)))]\n    [else\n     (cond\n       [(not\
    \ (whitespace? (car text)))\n        (cons (car text)\n              (fix_spaces\
    \ (cdr text)))]\n       [(not (whitespace? (cdr text)))\n        (fix_spaces (cons\
    \ (car text)\n                        (cdr text)))]\n       [(whitespace? (car\
    \ text)) \n        (cons (car text)\n              (fix_spaces (cdr text)))]\n\
    \       [(whitespace? (cdr text))\n        (fix_spaces (cons (car text)\n    \
    \                    (cdr text)))]\n       [(not (whitespace? (cdr text)))\n \
    \       (fix_spaces (cons (car text)\n                        (cdr text)))]\n\
    \       [(whitespace? (car text)) \n        (fix_spaces (cons (car text)\n   \
    \                     (cdr text)))]\n       [(whitespace? (cdr text))\n      \
    \  (fix_spaces (cons (car text)\n                        (cdr text)))]\n     \
    \  [else\n        (fix_spaces (cons (car text)\n                        (cdr text)))]\n\
    \       )])", "  (cond\n    ((equal? (length text) 0) text)\n    ((equal? (length\
    \ text) 1) (+ text \"_\"))\n    (else (cond \n          ((equal? (count-consecutive-space\
    \ text) 0) (+ text \"_\"))\n          ((equal? (count-consecutive-space text)\
    \ 1) (+ text \"-\"))\n          ((equal? (count-consecutive-space text) 2) (+\
    \ text \"_\"))\n          (else (error \"Unexpected input text.\"))))))\n", " \
    \ (let ([chars (string->list text)]) \n    (map \n     (lambda (c)\n       (if\
    \ (and (char= c #\\Space)\n                (char= c (cddr chars))) \n        \
    \   ((if (= (cddr chars) #\\Space)\n                (\"-\" (cddr chars))\n   \
    \             (cddr chars))\n           c))\n     chars)))\n", "  (cond\n    [(empty?\
    \ text)\n      (error \"Text can't be empty\" text)\n    ]\n    [(equal? (car\
    \ text) \" \")\n      (cons (car text) (fix_spaces (cdr text)))\n    ]\n    [else\n\
    \      (cons (substring (text 0 (string-length text)) \n                  (cons\
    \ (car text) (fix_spaces (cdr text)))))\n    ]\n    )\n  )\n", "  (let ((chars\
    \ (string-split text #\\space)))\n    (apply (lambda (i x)\n              (if\
    \ (= i (- 1 (string-length chars)))\n                  x\n                  (substring\
    \ x 0 (+ i 1))))\n            chars)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I think your `apply_with_index` is missing a `chars` in its second argument.\n\
    <|/ c |>\n<| c |>\n: Thanks for the suggestion. I have updated my answer accordingly.\n\
    <|/ c |>\n<| c |>\n`apply_with_index` isn't really necessary, since the `for`\
    \ loop is iterating over the indices and can thus work directly on the list. Also,\
    \ if this code is to be used as a function then `map` would be more idiomatic,\
    \ but since it's being used as an infix operator then `map` is fine.\n<|/ c |>\n\
    <| a dscore=2 |>\nA solution with no mutation:\n<code>", "  (cond\n    [(empty?\
    \ text) text]\n    [(equal? (first text) \" \")\n     (make-string (length (first\
    \ text) text) (first text) \"_\")]\n    [(equal? (first text) \" \")\n     (make-string\
    \ (length (first text) text) (first text) \"_\")]\n    [(equal? (first text) \"\
    \ \")\n     (make-string (length (first text) text) (first text) \"_\")]\n   \
    \ [else\n     (make-string (length (first text) text) (first text) (second text))]))\n",
  "  (cond\n    [(or (string=? text \"-\") (string=? text \"-\")) (concat text \"\
    -\")]\n    [(or (string=? text \"\") (string=? text \" \")) text]\n    [(or (string=?\
    \ text \"\") (string=? text \"-\")) \n      (concat \"_\" (fix_spaces (substring\
    \ text 0 (- (string-length text) 1))))]\n    [(string=? text \" \") (concat \"\
    _\" (fix_spaces (substring text 0 (- (string-length text) 1))))]\n    [else (concat\
    \ \"_\" (fix_spaces (substring text 0 (- (string-length text) 1))))]\n  )\n)\n\
    </cell>\n<code language=dyalog-kernel>\n#lang racket\n", "  \n  (if (empty? text)\n\
    \      \"\"\n      (\n        (string-append\n          (\n            (substring\
    \ (first text) 0 (- (length (first text)) 1)) (string \"_\")\n            (substring\
    \ (first text) 1 (- (length (first text)) 1)) \"-\"\n            (substring (first\
    \ text) 2 (- (length (first text)) 1))\n          )\n          (fix_spaces (substring\
    \ (first text) 1 (- (length (first text)) 1)))\n      )\n  )\n)\n", "  (let ([s\
    \ text])\n    (cond\n      [(empty? s) \"\"]\n      [(not (and (char (first s)\
    \ (string #\\Space)) (char (first s) (string #\\Space)))\n           (string-length\
    \ (substring s 0 (string-length (substring s 0 -1)))))\n      (concat \"_\" (substring\
    \ s (string-length (substring s 0 -1))) \"_\")]\n      [(not (and (char (first\
    \ s) (string #\\Space)) (char (first s) (string #\\Space))) \n           (string-length\
    \ (substring s 0 (string-length (substring s 0 -1)))))\n      (concat \"_\" (substring\
    \ s (string-length (substring s 0 -1))) \"_\")]\n      [(not (and (char (first\
    \ s) (string #\\Space)) (char (first s) (string #\\Space))) \n           (string-length\
    \ (substring s 0 (string-length (substring s 0 -1)))))\n      (concat \"_\" (substring\
    \ s (string-length (substring s 0 -1))) \"_\")]\n      [else\n      (concat \"\
    _\" (substring s 0 (string-length (substring s 0 -1))) \"_\")]\n      ]))", " \
    \ (let ((fix-text (remove-all-space text)))\n    (when fix-text\n      (replace-all\
    \ \" \" \"_\" fix-text))))\n</code>\n<|/ a tags=string,replace,scheme,racket |>\n\
    <| a |>\nThe question was \"how do I remove all spaces from a string\"? \nTo remove\
    \ all occurrences of the space character from a string you simply do the following:\n\
    <code>", "  (cond\n    ((string-length text == 0)\n     \"\")\n    ((string-ref\
    \ text 0)\n     text)\n    ((substring text 0 1)\n     (fix_spaces text))\n  \
    \  ((substring text 0 1)\n     (fix_spaces (substring text 0 2)))\n    ((substring\
    \ text 0 1)\n     (fix_spaces (substring text 0 1)))\n    ((string-ref text 0)\n\
    \     (fix_spaces (substring text 0 2)))\n    ((substring text 0 1)\n     (fix_spaces\
    \ (fix_spaces (substring text 0 2))))\n    ((substring text 0 1)\n     (fix_spaces\
    \ (fix_spaces (substring text 0 1)))\n     (fix_spaces (fix_spaces (substring\
    \ text 0 2))))\n    ((substring text 0 1)\n     (fix_spaces (fix_spaces (fix_spaces\
    \ (substring text 0 2))))\n     (fix_spaces (fix_spaces (fix_spaces (substring\
    \ text 0 1)))))\n    ((substring text 0 1)\n     (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (substring text 0 2))))\n     (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (substring text 0 1)))))))\n    ((substring text 0 1)\n     (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (fix_spaces (substring text 0 2))))\n  \
    \   (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (substring text\
    \ 0 1)))))))\n    ((substring text 0 1)\n     (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (substring text 0 2))))\n     (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (substring text\
    \ 0 1)))))))\n     (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (fix_spaces (substring text 0 2))))\n     (fix_spaces (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (substring text\
    \ 0 1)))))))\n     (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (substring text 0 2))))\n     (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces\
    \ (substring text 0 1)))))))\n     (fix_spaces (fix_spaces (fix_spaces (fix_spaces\
    \ (fix_spaces (fix_spaces (fix_spaces (fix_spaces (fix_spaces (substring text\
    \ 0 2))))\n     (fix_spaces (fix_spaces (fix_spaces (", "  (define char (string->list\
    \ (string->symbol text)))\n  (cond [(string= text \"\") \"\"]\n        [(string=\
    \ text \"#\\Space\") \"_\"]\n        [(char= char \"#\\Space\") \"_\"]\n     \
    \   [(empty? char) \"\"]\n        [else (append (char (remove #\\Space char))\n\
    \                      (fix_spaces (remove #\\Space (remove #\\Space char)))))]))\n",
  "  (if (string=? (string text) #\\space)\n      (let ([new-text (replace-all-strings\
    \ '#\\space #\\_ (string text)))]\n        (if (string-length new-text > 2)\n\
    \            (let ([new-text (replace-all-strings '#\\space #\\- new-text)])\n\
    \              new-text)\n            text))\n      text))\n", "  (cond\n    [(empty?\
    \ text) empty]\n    [(= (length text) 1) (text string?)]\n    [(equal? text (text\
    \ string?)) text]\n    [(= (text string?) \" \") text]\n    [(or (equal? (text\
    \ string?) \"\") (equal? (text string?) \" \"))\n     \"\"]\n    [else (cond \n\
    \              [(equal? (text string?) \"  \") (text string?)] \n            \
    \  [(or (equal? (text string?) \"\")\n                    (equal? (text string?)\
    \ \"   \"))\n                (text string?)] \n              [(or (equal? (text\
    \ string?) \"   \") (equal? (text string?) \" \"))\n                (text string?)]\
    \ \n              [(equal? (text string?) \"  \") (text string?)] \n         \
    \     [(or (equal? (text string?) \"\")\n                    (equal? (text string?)\
    \ \"   \"))\n                (text string?)] \n              [(or (equal? (text\
    \ string?) \"   \") (equal? (text string?) \" \"))\n                (text string?)]\
    \ \n              [(equal? (text string?) \"\") (text string?)] \n           \
    \   [(or (equal? (text string?) \"\")\n                    (equal? (text string?)\
    \ \"   \"))\n                (text string?)] \n              [(or (equal? (text\
    \ string?) \"   \") (equal? (text string?) \" \"))\n                (text string?)]\
    \ \n              [else (text string?)] \n            )] \n  )\n)\n", "  (cond\n\
    \    [(or (string-blank? text) (string-equal? text \" \")) (string \"_\")]\n \
    \   [else\n     (cond\n       [(or (string= text \"\") (string= text \" \")) (string\
    \ \"\")]\n       [(or (string= text \"\") (string-contains? text \"  \") (string-contains?\
    \ text \"\\n  \") (string-contains? text \"\\r  \") (string-contains? text \"\\\
    r\\n\")) (string \"\")]\n       [(string= text \" \") (cons (string (make-string\
    \ 2 text) (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n       [(string=\
    \ text \"\\n\") (cons (string \"\\n\" (make-string 1 \"_\")) (list (make-string\
    \ 1 \"_\")))]\n       [(string= text \"\\r\") (cons (string \"\\r\" (make-string\
    \ 1 \"_\")) (list (make-string 1 \"_\")))]\n       [(string= text \"\\r\\n\")\
    \ (cons (string \"\\r\\n\" (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n\
    \       [(string= text \"  \") (cons (string \"  \" (make-string 2 \"_\")) (list\
    \ (make-string 1 \"_\")))]\n       [(string= text \"\\t\") (cons (string \"\\\
    t\" (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n       [(string= text\
    \ \"\\n\\r\") (cons (string \"\\n\\n\" (make-string 1 \"_\")) (list (make-string\
    \ 1 \"_\")))]\n       [(string= text \"\\n\\n\\n\") (cons (string \"\\n\\n\\n\"\
    \ (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n       [(string= text\
    \ \"\\n\") (cons (string \"\\n\" (make-string 2 \"_\")) (list (make-string 1 \"\
    _\")))]\n       [(string= text \"\\r\") (cons (string \"\\r\" (make-string 1 \"\
    _\")) (list (make-string 1 \"_\")))]\n       [(string= text \"\\r\\n\") (cons\
    \ (string \"\\r\\n\" (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n \
    \      [(string= text \"  \") (cons (string \"  \" (make-string 2 \"_\")) (list\
    \ (make-string 1 \"_\")))]\n       [(string= text \"\\t\") (cons (string \"\\\
    t\" (make-string 1 \"_\")) (list (make-string 1 \"_\")))]\n       [(string= text\
    \ \"\\n\\r\") (cons (string \"\\n\\n\" (make-string 1 \"_\")) (list (make-string\
    \ 1 \"_\")))]\n       [(string= text \"\\n\\n\\n\") (cons (string \"\\n\\n\\n\"\
    \ (make-string 1 \"_\")) (list (make-string 1 \"_", "  (if (empty? text)\n   \
    \   \"\"\n      (if (> (string-length text) 2)\n          (cond ((or (char= (first\
    \ text) #\\s)\n                   (char= (second text) #\\s))\n              \
    \   (replace_spaces (first text) (second text))\n                 (replace_spaces\
    \ (second text) (third text))\n                 (replace_spaces (third text) (fourth\
    \ text))\n                 (replace_spaces (fourth text) (fifth text))\n     \
    \            (replace_spaces (fifth text) (sixth text))\n                 (replace_spaces\
    \ (sixth text) (seventh text))\n                 (replace_spaces (seventh text)\
    \ (eighth text))\n                 (replace_spaces (eighth text) (tenth text))\n\
    \                 (replace_spaces (tenth text) (eleventh text))\n            \
    \     (replace_spaces (eleventh text) (twelveth text))\n                 (replace_spaces\
    \ (twelveth text) (thirteenth text))\n                 (replace_spaces (thirteenth\
    \ text) (fourteenth text))\n                 (replace_spaces (fourteenth text)\
    \ (fifteenth text))\n                 (replace_spaces (fifteenth text) (sixteenth\
    \ text))\n                 (replace_spaces (sixteenth text) (seventeenth text))\n\
    \                 (replace_spaces (seventeenth text) (eighteenth text))\n    \
    \             (replace_spaces (eighteenth text) (twentieth text))\n          \
    \       (replace_spaces (twentieth text) (thirtieth text))\n                 (replace_spaces\
    \ (thirtieth text) (fourtieth text))\n                 (replace_spaces (fourtieth\
    \ text) (fiftieth text))\n                 (replace_spaces (fiftieth text) (sixtieth\
    \ text))\n                 (replace_spaces (sixtieth text) (seventieth text))\n\
    \                 (replace_spaces (seventieth text) (eightieth text))\n      \
    \           (replace_spaces (eightieth text) (ninetieth text))\n             \
    \    (replace_spaces (ninetieth text) (twennitieth text))\n                 (replace_spaces\
    \ (twennitieth text) (thirtietieth text))\n                 (replace_spaces (thirtietieth\
    \ text) (fourtietieth text))\n                 (replace_spaces (fourtietieth text)\
    \ (fiftietieth text))\n                 (replace_spaces (fiftietieth text) (sixtietieth\
    \ text))\n                 (replace_spaces (sixtietieth text) (seventietieth text))\n\
    \                 (replace_spaces (seventietieth text) (eightietieth text))\n\
    \                 (replace_spaces (eightietieth text) (ninetietieth ", "  (if\
    \ (or (eof-object? text) (empty? text))\n      '()\n      (cond ((equal? (string-ref\
    \ text 0) \" \")\n             (cons (string->symbol (string-upcase (string-replace\
    \ text \" \" \"_\"))) \n                   (fix_spaces (string->string \n    \
    \                               (string-replace (substring text 1) \n        \
    \                                         \" \" \"-\")))))\n            (else\
    \ (cons (string->symbol (string-upcase (string-replace text \" \" \"_\"))) \n\
    \                      (fix_spaces (string->string \n                        \
    \             (string-replace (substring text 1) \n                          \
    \                        \" \" \"-\")))))))\n", "  (let* ((text (text text))\n\
    \         (spaces 0)\n         (result '()))\n    (if (eq? text '()) result\n\
    \        (if (spaces <= 0)\n            (cons (char ' ')\n                  result)\n\
    \            (cons (char-code (char text)\n                            (char '\
    \ ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (char ' ')\n                            (char\
    \ ' ')\n                            (", "  (cond\n    [(empty? text) empty]\n\
    \    [(equal? (char-whitespace? text) true) (lambda (x) (- x))]\n    [(equal?\
    \ (char-whitespace? text) false) (lambda (x) (make-string (string-length (string-upcase\
    \ x)) #\\_))]\n    [(> (string-length (string-upcase text)) 2) (lambda (x) (make-string\
    \ (string-length (string-upcase x)) #\\-))]\n    [else (lambda (x) (make-string\
    \ (string-length (string-upcase x)) #\\-))]\n    (else (lambda (x) (make-string\
    \ (string-length (string-upcase x)) #\\- )))))\n", "  (cond\n    [(empty? text)\
    \ \"\"]\n    [else (let ([\n              (first (first text))\n             \
    \ (last  (last text))\n              (spaces (length (first text)))])\n      \
    \      (cond\n             [(zero? spaces) text]\n             [(not (member (second\
    \ text) spaces)) (substring text 0 spaces)\n               ((member (second text)\
    \ spaces) (substring text spaces (- spaces 2)))\n               (else (substring\
    \ text 0 (+ spaces (length (first text)))))]\n             [else (cons (first\
    \ text)\n                          (fix_spaces (substring text (1+ spaces) last)))]))]))\n",
  "  (let ((result (make-string (string-length text))))\n    (do ((start 0 (+ start\
    \ 1)))\n        ((= start (string-length text))\n         (string-set! result\
    \ start (char #\\_ result)))\n      (when (string=? (substring text start (+ start\
    \ 1))\n                    (substring text (+ start 1) (+ start 1)))\n       \
    \ (do ((end start (string-length text)))\n            (>= end start)\n       \
    \     (string-set! result end (char #\\- result)))\n      (when (string=? (substring\
    \ text start (+ start 1))\n                    (substring text (+ start 1) (+\
    \ start 1)))\n        (do ((end start (string-length text)))\n            (>=\
    \ end start)\n            (string-set! result end (char #\\- result))))))\n  (string-ref\
    \ result 0))\n", "  (let ((spaces '())\n        (result (copy-list text)))\n \
    \   (loop [i 0]\n      (if (empty? spaces)\n          result\n          (let ((space\
    \ (car spaces)))\n            (if (empty? spaces)\n                (set! spaces\
    \ space)\n                (set! result (replace-once space \"-\" result)))\n \
    \           (set! result (replace-once space \"_\" result))\n            (set!\
    \ i (add1 i))\n            (set! spaces (cdr spaces)))))\n    (reverse result)))\n",
  "  (cond\n   ((string-empty? text) \"\")\n   ((= (string-length text) 2) (replace-chars\
    \ text (substring text 0 (string-length text)) \" \" \"_\"))\n   ((= (string-length\
    \ text) 3) (replace-chars text (substring text 0 (string-length text)) \" \" \"\
    -\"))\n   (else (replace-chars text \" \" \"_\"))))\n", "  (let ((text (replace-all\
    \ text \"[ \\t]\" '_))))\n  (let ((text (replace-all text \"( *)\" '-)))\n  (if\
    \ (> text 2)\n      (replace-all text \"( *)( *)\"\n                  \"_\"))))\n",
  "  (cond\n    [(empty? text)\n     empty]\n    [(substring (last text) 1 (string->int\
    \ (first text)))\n     (append (cons (first text) (fix_spaces (rest text))) (first\
    \ text))\n     (fix_spaces (rest text))\n     ]\n    [else\n     (append (cons\
    \ (first text) (fix_spaces (rest text))) (first text))\n     (fix_spaces (rest\
    \ text))]))\n", "  (cond\n    [(empty? text) empty]\n    [(or (string=? (car text)\
    \ (string-append \" \"))\n          (string=? (car text) (string-append \"_\"\
    ))) \n       (cons (car text) (fix_spaces (cdr text)))]\n    [else (cons (string-append\
    \ \"-\") (fix_spaces (cdr text)))]))\n", "  (cond\n    [(= (length text) 0)\n\
    \     text]\n    [else\n     (replace-each (compose (lambda (x) (if (string= x\
    \ \" \") \"_\" x)) (lambda (x) (if (string= x \"  \") \"-\" x))\n            \
    \        text)]))\n</code>\n<|/ a dscore=1 tags=racket,string |>\n<| a dscore=1\
    \ tags=racket,string |>\nA solution with racket/string/replace\n<code>", "  (cond\n\
    \    [(empty? text) empty]\n    [(equal? (first text) space) (cons (first text)\
    \ (fix_spaces (rest text)))]\n    [else (cons (first text) (fix_spaces (rest text)))]))\n",
  "  (cond\n    [(empty? text)\n     text]\n    [else\n     (if (string=? (string-trim\
    \ text)\n                  \"   \")\n         (replace text\n                \
    \    \"   \" \"_\")\n         (replace\n          text\n          (make-string\n\
    \           (string-length\n            (replace-each\n             (replace-each\n\
    \              text\n              \" \" \"_\")\n              \"   \" \"_\"))\n\
    \          \"_\"))]))\n", "  (let ((result\n         (string-map \n          (\u03BB\
    \ (x)\n            (if (or (char= x (char-code #\\Space))\n                  \
    \   (char= x (char-code #\\Newline))\n                     (char= x (char-code\
    \ #\\Tab))\n                     (char= x (char-code #\\Return)))\n          \
    \      (append x (string-downcase (string-trim\n                             \
    \                  (string-downcase (substring x 0 (string-length x))))))\n  \
    \              x))))\n    (string->list result)\n    (remove-duplicates result)))\n\
    </code>\n<|/ a dscore=3 tags=racket,string,racket-internals,scheme |>\n<| a |>\n\
    I've modified my original answer, I hope this one will help someone else. \n<code>\n\
    #lang racket\n", "  (if (string-empty? text)\n      '()\n      (let* ((result\
    \ (make-string (string-length text)\n                             (string->chars\
    \ text))\n             (i (string-length result))\n             (count 1))\n \
    \       (while i\n          (if (char=? (aref result i) \" \") (add1 count) (add1\
    \ i))\n          (if (> count 2)\n              (set! result (replace \" \" result\
    \ \"-\")\n                       (set! count 0)\n                       (set!\
    \ i (1- i))\n                       (set! count 0)\n                       (set!\
    \ i (1- i)))\n              (set! result (append result (substring result 0 count\
    \ i)\n                                 (substring result i count)))\n        \
    \      (set! i (1- i))))\n        result)))\n", "  (cond\n    ((= (length text)\
    \ 0) text)\n    ((char=? (first text) ' ') (cons (first text) (fix_spaces (rest\
    \ text))))\n    (else (cons (char->string (char->integer ' ') (first text)) \n\
    \              (fix_spaces (rest text)))))) \n", "  (if (= (length text) 0)\n\
    \      '()\n      (let ((new_string (append (make-string-1 text \n           \
    \                          (make-string-1 ' ' '_') \n                        \
    \             (make-string-1 '-' '_'))))\n            (prev_space '())\n     \
    \       (cur_space '()))\n        (cond ((string=? prev_space new_string)\n  \
    \            (make-string-1 text prev_space cur_space))\n              ((not (string=?\
    \ prev_space new_string))\n               (make-string-1 new_string prev_space\
    \ cur_space))\n              ((string=? cur_space new_string)\n              \
    \ (make-string-1 text prev_space cur_space))\n              (else\n          \
    \     (make-string-1 new_string prev_space cur_space)))))\n", "  (replace-with\
    \ spaces underscore\n              (replace-with spaces (char '-) (char '_) text))\n\
    \  )\n", "  (cond\n    [(empty? text) empty]\n    [(or (string=? text \" \")\n\
    \          (string=? (rest text) \" \")\n          (string=? (rest (rest text))\
    \ \" \")) \n     (string=? text \" \") (cons text (fix_spaces (rest text)))]\n\
    \    [else (cons (car text) (fix_spaces (fix_spaces (car text))))]\n  ))\n", " \
    \ (cond\n    ((= (length text) 1)\n     text)\n    ((= (substring (text 0) 0 (car\
    \ text)) \" \")\n     (cond\n       ((> (length-text text) 2)\n        (cond\n\
    \          ((> 2 (string-length text)) \n           (cond\n             ((= 1\
    \ (string-length text))\n              (cons (char->string #\\-) (substring text\
    \ 0 (car text)))\n             (else text))\n           (else \n            (cons\
    \ (char->string #\\_) (substring text 0 (car text))))))\n       (else (cons (char->string\
    \ #\\_) (substring text 0 (car text)))))\n     (else (cons (char->string #\\-)\
    \ (substring text 0 (car text)))))\n    ((> (string-length text) 2)\n     (cond\n\
    \       ((= 1 (string-length text))\n        (cons (char->string #\\-) (substring\
    \ text 0 (car text)))\n       (else \n        (cons (char->string #\\_) (substring\
    \ text 0 (car text))))))\n    (else\n     (cons (char->string #\\_) (substring\
    \ text 0 (car text)))))) \n", "  (cond\n    [(or (string= text \"\")\n       \
    \   (string= text \"   \"))\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat \"_\" text)\n\
    \     (concat \"_\" text)\n     (concat \"_\" text)\n     (concat ", "  (let ([len\
    \ (string-length text)])\n    (cond\n      [(= len 0) text]\n      [(= len 1)\
    \ (string \"_\")]\n      [(string=? (substring text 0 len) \"  \") (string \"\
    _\")]\n      [(= (mod len 2) 0) (string \"_\" (reverse (substring text 0 (- len\
    \ 2))))]\n      [else (string \"\" (reverse (substring text 0 (- len 2))))]))\n\
    )\n", "  (cond [(empty? text)\n         (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons '_ (cons\
    \ '_ (cons '_ (cons '_ (cons '_ (cons '_", "  (let ((result (copy-str text))\n\
    \        (lastws (copy-str (substring result 0 (string-length result)))))\n  \
    \  (unless (eq? text \"\")\n      (let ((newlastws (substring lastws (string-length\
    \ lastws))))\n        (cond\n          ((string=? newlastws \"_\") (cons newlastws\
    \ (cons \"_\" (substring result (string-length result) result)))) (cons newlastws\
    \ result)\n          ((string=? newlastws \" \")\n           (cond \n        \
    \    (\n              (string=? newlastws \"_\") (cons newlastws (cons \"_\" (substring\
    \ result (string-length result) result)))\n              (cons newlastws result)\n\
    \              (else result))\n            (else (cons newlastws (cons \"_\" (substring\
    \ result (string-length result) result))))\n            (else (cons newlastws\
    \ result))))\n      (set! result (cons newlastws result))\n      (set! lastws\
    \ (copy-str newlastws))\n      (set! result (cons newlastws result))\n      (set!\
    \ result (cons (substring result 0 string-length lastws) result))\n      (reverse\
    \ result))) result\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  (let ([chars\
    \ (string->list text)]\n        [counts (build-map #(list->string (count-chars\
    \ % #:key string<->list)) chars)])\n    (map \n      (lambda (pair) \n       \
    \ (if (list? (car pair))\n            (if (= (counts (car pair)) 2)\n        \
    \        (map (lambda (x) (cons (char->string x) \"-\")) (cdr pair))\n       \
    \         (cdr pair))\n            (cdr pair)))\n      (filter (lambda (pair)\
    \ (= (car (car pair)) #\\space)) chars))))\n", "  (let loop ([text text]\n   \
    \          [result '\"\"])\n    (if (not (eq? text \"\"))\n        (append result\
    \ (cons (char->string (car text))\n                           (loop (cdr text)\n\
    \                                 (cons (char->string (car text))\n          \
    \                             (loop (cdr text) '\"\"))))\n        result)))\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  (cond\n    [(string=? text \"\
    \") \"\"]\n    [(string=? text \"    \") text]\n    [(string=? text \"   \") (concat\
    \ text \"-\")]\n    [else (concat \"_\" (fix_spaces (substring text 2))) ]\n \
    \ ))\n", "  (if (string? text)\n      (let ((old-text text))\n        (string->char-list\
    \ (replace-first (string->string \" \" \"_\") old-text #\\Space))\n        (if\
    \ (string? text)\n            (replace-first (string->string \" \" #\\-) text\
    \ #\\Space)\n            text))))\n", "  (cond\n    ((or (string? text)\n    \
    \      (null? text))\n     text)\n    ((string? text)\n     (let ((space (replace-all\
    \ \" \" '_)))\n       (cond\n        ((= (length space) 1)\n         (string-append\
    \ \"-\" space))\n        ((string= space space)\n         (string-append \"-\"\
    \ space \"-\"))\n        ((string= space \"-\")\n         (string-append \"-\"\
    \ space \"-\"))\n        (else \n         (string-append \"_\" space ))))))\n",
  "  (cond [(zero? text) \"\"]\n        [(equal? (string text) \" \")\n          (cond\
    \ [(empty? (substring text 0 1)) (substring text 0 1)]\n                [else\
    \ (substring text 0 (substring-length (string text) 1)))]\n              )]\n\
    \        [else (cond [(empty? (substring text 0 (substring-length (string text)\
    \ 1)))]\n                   [else (substring text 0 (substring-length (string\
    \ text) 1)) \n                           (substring text 0 (substring-length (string\
    \ text) 1))\n                           (substring text 0 (substring-length (string\
    \ text) 1))\n                           (substring text 0 (substring-length (string\
    \ text) 1))\n                           (substring text 0 (substring-length (string\
    \ text) 1))]\n                   )]))\n", "  (if (empty? text)\n      '\n    \
    \  (if (string= (first text) \" \")\n          (cons (string->symbol (string->symbol\
    \ text)) \n                (fix_spaces (sub1 (rest text)))))\n      (cons (string->symbol\
    \ (string->symbol text))\n            (fix_spaces (sub1 (rest text)))))\n  )\n",
  "  (let ([fixed-' (replace (map (lambda (c) (if (string-match \" \" c) (cons (c\
    \ (cdr fixed-')))(cdr (replace (map #(if (string-match \" \" (first %)) (cons\
    \ (first %) (second %)) (cons (first %)(cdr fixed--')) (cdr (replace (map #(if\
    \ (string-match \" \" (first %)) (cons (first %)(cdr fixed--')) (cdr (replace\
    \ (map #(if (string-match \" \" (first %)) (cons (first %)(cdr fixed--')) (cdr\
    \ fixed--')))))))) '(#\\Space #\\Space)) text))])\n    (if (not (empty? fixed--'))\
    \ (cons (first fixed--') (second fixed--')) (cons (first fixed--') (second fixed--')))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
