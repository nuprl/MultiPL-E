name: HumanEval_88_sort_array
language: rkt
prompt: "#lang racket\n\n;; Given a list of non-negative integers, return a corkt\
  \ of the given list after sorting,\n;; you will sort the given list in ascending\
  \ order if the sum( first index value, last index value) is odd,\n;; or sort it\
  \ in descending order if the sum( first index value, last index value) is even.\n\
  ;; Note:\n;; * don't change the given list.\n;; Examples:\n;; >>> (sort_array (list\
  \ ))\n;; (list )\n;; >>> (sort_array (list 5))\n;; (list 5)\n;; >>> (sort_array\
  \ (list 2 4 3 0 1 5))\n;; (list 0 1 2 3 4 5)\n;; >>> (sort_array (list 2 4 3 0 1\
  \ 5 6))\n;; (list 6 5 4 3 2 1 0)\n(define (sort_array array)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_array))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 5)) (list 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5)) (list 0 1 2 3\
  \ 4 5))\n    (check-equal? (candidate (list 2 4 3 0 1 5 6)) (list 6 5 4 3 2 1 0))\n\
  \    (check-equal? (candidate (list 2 1)) (list 1 2))\n    (check-equal? (candidate\
  \ (list 15 42 87 32 11 0)) (list 0 11 15 32 42 87))\n    (check-equal? (candidate\
  \ (list 21 14 23 11)) (list 23 21 14 11))\n))\n\n(test-humaneval)"
completions: ["  (let helper ((arr (sort array)))\n    (cond\n      [(null? arr) arr]\n\
    \      [(odd? (first arr) (last arr)) (append (reverse (rest arr)) (helper (rest\
    \ arr)))]\n      [else (append (reverse (first arr)) (helper (rest arr)))])))\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nIt would be better to do this in constant\
    \ time, as you do now. As your list is sorted, you can find the positions of the\
    \ first and last element with binary search. Then, you can use this positions\
    \ to return the list.\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nThat would\
    \ not work as it is sorted. You will have to either traverse the list more than\
    \ once (which is what you are doing now) or do a search each time you find a sum\
    \ that is even.\n<|/ c |>\n<| c |>\nYes, but if you do the traversal only once\
    \ and keep an O(n) data structure, the algorithm is O(log n).\n<|/ c |>\n<| a\
    \ |>\nTo get O(n) you need to use hash tables to store the sums up to each of\
    \ the numbers in the list.  The hash table is built on the initial list and the\
    \ first element of the list is the key and the value is that number summed.  For\
    \ each successive number the value is the sum of the first element with the number\
    \ added up with the sum of the second element and so on.  \n<code>", "  (cond\
    \ [(null? array) '()]\n        [(< 1 (car array))\n         (sort_array (cdr array))]\n\
    \        [(< 1 (cdr array))\n         (sort_array (cons (car array) (sort_array\
    \ (cdr array))))]\n        [else\n         (sort_array (cons (car array) (sort_array\
    \ (cdr array))))]))\n", "  (define (make-sorted array)\n    (cond\n      [(empty?\
    \ array) (list array)]\n      [else\n       (append (sort (first array) <)\n \
    \              (make-sorted (rest array)))]))\n  (make-sorted array))\n", "  (cond\n\
    \    [(empty? array) array]\n    [(= (sub1 (last array)) 0)\n     (reverse array)]\n\
    \    [(= (sub1 (last array)) (len (last array)))\n     (sort (sort_array (sort_list\
    \ (reverse (sub1 (reverse array)))))]\n    [else (sort_array (sort_list (reverse\
    \ array)))]))\n", "  (let ([length (length array)])\n    (if (< length 2)\n  \
    \      (corkt array)\n        (let ([(x y z) (list-tail array)])\n          (if\
    \ (even? (+ x y))\n              (corkt (cons x (append y (list-tail array)))\
    \ (cons (+ y z) array))\n              (corkt (cons x (append y z)) (cons (+ y\
    \ z) array)))))))\n", "  (if (or (null? array)\n          (null? (cdr array)))\n\
    \      array\n      (sort (cons (car array)\n                  (sort_array (cdr\
    \ array)))\n            >\n            >\n            >\n            >\n     \
    \       >\n            >\n            >\n            >\n            >\n      \
    \      >\n            >\n            >\n            >\n            >\n       \
    \     >\n            >\n            >\n            >\n            >\n        \
    \    >\n            >\n            >\n            >\n            >\n         \
    \   >\n            >\n            >\n            >\n            >\n          \
    \  >\n            >\n            >\n            >\n            >\n           \
    \ >\n            >\n            >\n            >\n            >\n            >\n\
    \            >\n            >\n            >\n            >\n            >\n \
    \           >\n            >\n            >\n            >\n            >\n  \
    \          >\n            >\n            >\n            >\n            >\n   \
    \         >\n            >\n            >\n            >\n            >\n    \
    \        >\n            >\n            >\n            >\n            >\n     \
    \       >\n            >\n            >\n            >\n            >\n      \
    \      >\n            >\n            >\n            >\n            >\n       \
    \     >\n            >\n            >\n            >\n            >\n        \
    \    >\n            >\n            >\n            >\n            >\n         \
    \   >\n            >\n            >\n            >\n            >\n          \
    \  >\n            >\n            >\n            >\n            >\n           \
    \ >\n            >\n            >\n            >\n            >\n            >\n\
    \            >\n            >\n            >\n            >\n            >\n \
    \           >\n            >\n            >\n            >\n            >\n  \
    \          >\n            >\n            >\n            >\n            >\n   \
    \         >\n            >\n            >\n            >\n            >\n    \
    \        >\n            >\n            >\n            >\n            >\n     \
    \       >\n            >\n            >\n            >\n            >\n      \
    \      >\n            >\n            >\n            >\n            >\n       \
    \     >\n            >\n            >\n            >\n            >\n        \
    \    >\n            >\n            >\n            >\n            >\n         \
    \   >\n            >\n            >\n            >\n            >\n          \
    \  >\n            >\n            >\n            >\n            >\n           \
    \ >\n            >\n", "  (if (empty? array)\n      (list empty)\n      (let loop\
    \ ((array array)\n                 (index 0))\n        (if (> index length) \n\
    \            (list empty)\n            (let ((new-array (list empty)))\n     \
    \         (set! index (+ index 1))\n              (cond ((even? (+ array index\
    \ index)) (cons index (loop (cdr array) (+ index 1) new-array)))\n           \
    \         ((odd? (+ array index index)) (cons index (loop (cdr array) (- index\
    \ 1) new-array)))\n                    (else (loop (cdr array) (+ index 1) new-array)))))))\n\
    \            ", "  (cond\n    [(empty? array) (list array)]\n    [(zero? (first\
    \ array)) (list array)]\n    [(even? (sum (first array) (last array)))\n     (sort\
    \ (sort (list (last array) (first array))) #>\n        (list (last array) (first\
    \ array))))\n    [else (sort (list (first array) (last array)) #>\n        (list\
    \ (first array) (last array))))]))\n", "  (cond\n    [(null? array) '()]\n   \
    \ [(null? (cdr array))\n     (cons (car array)\n           (sort_array (cdr array)))]\n\
    \    [else\n     (cond\n       [(even? (cadr array))\n        (append (cons (car\
    \ array)\n                    (sort_array (cdr array)))\n                (sort_array\
    \ (cdr array)))]\n       [(odd? (cadr array))\n        (append (sort_array (cdr\
    \ array))\n                (cons (car array)\n                      (sort_array\
    \ (cdr array))))]\n       [else (sort_array (cdr array))])]))\n", "  (if (null?\
    \ array)\n      (list)\n      (let* ((len (length array))\n             (list\
    \ (append array (list '()))\n                      (head (car array))\n      \
    \                (tail (cdr array)))\n             (result (let loop ((i 0) (acc\
    \ 0))\n                        (if (< i len)\n                            (let*\
    \ ((head (car tail))\n                                  (tail (cdr tail))\n  \
    \                                (first (car head))\n                        \
    \          (last (car tail)))\n                              (if (even? (+ first\
    \ last))\n                                  (loop i (+ acc last))\n          \
    \                        (loop i (+ acc first)))))\n                         \
    \ acc)))\n            (if (odd? result)\n                (loop i result)\n   \
    \             (loop i result))))))\n</code>\n<|/ a tags=scheme,lisp,racket,functional-programming\
    \ |>\n<| a |>\nA simple recursive implementation would look like\n<code>", " \
    \ (sort array (lambda (a b)\n                (if (even? (+ a b)) (- a b) (+ a\
    \ b))))\n  )\n  ", "  (let loop ((l array)\n             (i 0))\n    (if (or (<\
    \ i l) (= i (length l)))\n        l\n        (let ((x (car l)))\n          (loop\
    \ (cdr l) (+ i 1))\n          (cons x (loop l i)))))) ; note this returns the\
    \ original list for empty lists\n</code>\n<|/ a tags=scheme,racket,list |>\n<|\
    \ c |>\nThanks for answering, but I guess this is not what he was looking for\
    \ :)\n<|/ c |>\n<| c |>\nThis does sort the list, but does not return it. You'll\
    \ need to add (list x) to get the correct answer.\n<|/ c |>\n<| c |>\nI realized\
    \ that the OP also wanted the result as a list - I updated the answer to do just\
    \ that and added some test cases.\n<|/ c |>\n<| c |>\nI guess he was actually\
    \ looking for an inplace sorting (which I did not know), so this solution won't\
    \ help him.\n<|/ c |>\n<| a tags=scheme,racket,list |>\nIt's not too hard to make\
    \ a procedure that does this by recursion. First of all we need to find out if\
    \ the first element of the list is greater than the second element. Next we check\
    \ if the sum of the two elements is even or odd. Then, we recursively call the\
    \ procedure with the first element as the second element, and the result of checking\
    \ the first element and the second element is the same as the sum of the first\
    \ element and the first element minus one. Here's a solution:\n<code>", "  (if\
    \ (null? array)\n      '()\n      (let ((pivot (first array)))\n        (if (even?\
    \ pivot)\n            (sort_array (rest array))\n            (sort_array (rest\
    \ array)))))\n", "  (if (null? array)\n      array\n      (let ([head (car array)]\n\
    \            [tail (cdr array)])\n        (if (odd? (+ head tail))\n         \
    \   (sort_array (cons head tail))\n            (sort_array (cons tail head))\n\
    \            (sort_array (cons head tail))))))\n", "  (cork (lambda (l1 l2)\n\
    \          (sort (sort l1 <)\n                (sort l2 <)\n                (lambda\
    \ (x y) (+ (car l1) (car l2))))))\n          array)\n</code>\n<|/ a tags=racket,lisp\
    \ |>\n<| c |>\nThis solution has some nice properties, but it also has some weaknesses.\
    \ For example, consider `(sort_array '(1 5 4 3 2 0 6))`. In the first step it\
    \ swaps 5 and 6. In the second step it swaps 4 and 3. In a third step it swaps\
    \ 2 and 0. In the fourth step it swaps 1 and 6. In the fifth step it swaps 0 and\
    \ 6. In the sixth step it swaps 0 and 6. The result is `(6 5 4 3 2 1 0)`. However,\
    \ if you had the list `(1 2 3 4 5 6 0)` then it would have produced `(6 5 4 3\
    \ 2 1 0)`.\n<|/ c |>\n<| c |>\nYour algorithm is O(n^2) in complexity. Sort algorithms\
    \ generally run in O(n log n).\n<|/ c |>\n<| c |>\nYeah you are right. I missed\
    \ that in the question. My bad\n<|/ c |>\n<| c |>\n: Sorting in ascending order\
    \ is O(n) on average.  Sorting in descending order is O(n^2) on average.  The\
    \ total time complexity is the same in either case.  But if you have already sorted\
    \ the list (as is done by OP), it is worth pointing out that you can skip the\
    \ second sort, because you are already sorting the list.  Also, the O(n^2) is\
    \ usually called \"quadratic time\".  The \"quadratic\" term is usually omitted\
    \ when discussing time complexity.  And yes, you can argue that my sort is O(n^2),\
    \ but it's not; it's actually O(n log n).  Which is the same thing.\n<|/ c |>\n\
    <| c |>\n: Thanks for the comments. I just updated the answer to clarify it a\
    \ bit.\n<|/ c |>\n<| a tags=racket,lisp dscore=2 |>\nThis solution uses tail recursion.\
    \ It is a simple and fast solution which does not require any additional modules\
    \ and uses only basic Racket functions.\n<code>", "  (sort (lambda (x) (+ (first\
    \ array) (last array))) array))\n", "  (let loop ((i 0 (+ (first array) 0)))\n\
    \    (if (< i 10)\n        (let ((x (car array)))\n          (if (odd? (+ x (last\
    \ array)))\n              (loop (+ i 1))\n              (loop i (- i 1)))))))\n",
  "  (if (or (number? array)\n          (null? array))\n      array\n      (apply\
    \ append (sort (list array)\n                         (lambda (x y)\n        \
    \                   (- (car x)\n                              (car y)))\n    \
    \                     (lambda (x y)\n                           (+ (car x)\n \
    \                             (car y))\n                         :key (lambda\
    \ (x y)\n                                 (- (car x)\n                       \
    \             (car y)))\n                         :initial-key (lambda (x y)\n\
    \                                        (car x)))\n                     )))\n",
  "  (corkt (lambda (i j) (if (and (odd (+ i j)) (< i j)) (conj j i) (conj i j)) (+\
    \ i j) 0 array))\n  array)\n", "  (cond\n    ((null? array) '())\n    ((even?\
    \ (length array)) (sort_array (reverse (sort_array (list_sort (append array (list\
    \ '() )))))))\n    (else (sort_array (list_sort (append array (list '() )))))))\n",
  "  (cond ((null? array) '())\n        ((odd-sum? array (length array)) (cons (car\
    \ array) (sort_array (rest array))))\n        (else (cons (car array) (sort_array\
    \ (rest array)))))\n  )\n  ", "  (let ([(index -1) (value 0)]\n        [(result\
    \ '())\n         (current '())]\n        [(tail '())\n         (next  '())]\n\
    \        [(sum '0)\n         (sum '0)])\n    (cond\n      [(empty? array)\n  \
    \     (reverse result)]\n      [(< (car array) value)\n       (cond\n        \
    \ [(= sum (+ value (car array))) (cons value result)]\n         [(= sum (+ value\
    \ (car array)) #t) (cons value result #t)]\n         [else (cons value result)]])\n\
    \      [(>= (car array) value)\n       (cond\n         [(= sum (+ value (car array)))\
    \ (cons value result #t)]\n         [(= sum (+ value (car array)) #t) (cons value\
    \ result #t)]\n         [else (cons value result #t)]])\n      [(< (cdr array)\
    \ value)\n       (cond\n         [(= sum (+ value (car array))) (cons value result\
    \ #t)]\n         [(= sum (+ value (car array)) #t) (cons value result #t)]\n \
    \        [else (cons value result #t)]])\n      [(>= (cdr array) value)\n    \
    \   (cond\n         [(= sum (+ value (car array))) (cons value result #t)]\n \
    \        [(= sum (+ value (car array)) #t) (cons value result #t)]\n         [else\
    \ (cons value result #t)]])\n      [(< (car array) (cdr array))\n       (cond\n\
    \         [(= sum (+ value (car array)) #t) (cons value result #t)]\n        \
    \ [else (cons value result #t)]])\n      [(>= (car array) (cdr array))\n     \
    \  (cond\n         [(= sum (+ value (car array)) #t) (cons value result #t)]\n\
    \         [else (cons value result #t)]])\n      [(< (cdr array) (cdr array))\n\
    \       (cond\n         [(= sum (+ value (car array)) #t) (cons value result #t)]\n\
    \         [else (cons value result #t)]])\n      [(>= (cdr array) (cdr array))\n\
    \       (cond\n         [(= sum (+ value (car array)) #t) (cons ", "  (let ([sorted\
    \ (sort array (lambda (x y) (< (+ x y) 0)))])\n    (cond [(null? sorted) sorted]\n\
    \          [(even? (caar sorted)) (sort_array (reverse sorted))]\n          [(odd?\
    \ (caddr sorted)) (sort_array sorted)]\n          [else (sort_array (reverse sorted))])))\n",
  "  (let ([l (length array)])\n    (let ([sum (+ 0 (first array))])\n      (if (=\
    \ 0 l)\n          (list)\n          (if (even? (modulo-sum sum))\n           \
    \   (corkt array)\n              (corkt (sort_array (corkt array) (- l 1)))))))",
  "  (let loop ((array (cons (car array) array)) (acc '()))\n    (if (null? array)\n\
    \        (reverse acc)\n        (let ((index (length (rest array))) (temp (first\
    \ array)))\n          (if (odd? (+ acc (first array)))\n              (loop (rest\
    \ array) (cons (first array) acc))\n              (loop (rest array) (cons (first\
    \ array) acc))\n              (loop array '())))))\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\n<code>", "  (let loop ((sum 0)\n             (array array)\n\
    \             (sorted (list )))\n    (if (null? array)\n        sorted\n     \
    \   (let ((head-index (length array))\n               (tail-index (- head-index\
    \ 1)))\n          (loop (+ sum (car array))\n                (if (even? sum)\n\
    \                    (append sorted (cdr array))\n                    (append\
    \ sorted (cdr array)))))\n        (loop (+ sum (car array))\n              array\n\
    \              sorted)))))\n</code>\n<|/ a dscore=0 tags=scheme,lisp |>\n<| a\
    \ tags=scheme,lisp |>\nI write my solution in Scheme, and I think the answer is\
    \ the same as Racket's answer.\n<code>", "  (if (null? array)\n      (list '())\n\
    \      (let ([pivot (first array)]\n            [tail (rest array)])\n       \
    \ (if (or (null? tail) (< pivot tail))\n            (sort_array tail)\n      \
    \      (sort_array (cons pivot tail))))))\n", "  (let loop ((array-size array\
    \ (length array))\n             (index (make-array (ceiling (/ array-size 2) #:element-type\
    \ 'int) 0))\n             (sum 0))\n    (cond\n      [(> array-size 2) (return\
    \ array)]\n      [(< index array-size)\n       (loop (sub1 array-size)\n     \
    \        index\n             (+ sum (array-ref array index)))]\n      [else (loop\
    \ (sub1 array-size)\n                   index\n                   (+ sum ((if\
    \ (oddp (- sum (array-ref array index))))\n                            (- (array-ref\
    \ array index))\n                            sum)))]\n    )\n  )\n)\n", "  (let\
    \ loop ((i 0)\n             (result '()))\n    (cond [(null? array) result]\n\
    \          [(even? (first array)) (loop (+ i 1) (cons (first array) (loop (+ i\
    \ 1) (cons (second array) result)))]\n          [else (loop (+ i 1) (cons (first\
    \ array) (loop (+ i 1) (cons (second array) (loop (+ i 1) result))))]\n      \
    \    )\n    ))\n)\n#lang racket\n", "  (if (null? array)\n      '()\n      (let\
    \ ([head (car array)\n            tail (cdr array)\n            even (= (length\
    \ tail) 0)\n            odd (< even (length tail))])\n        (cond [(even? (+\
    \ head tail)) (sort_array (cons head tail))]\n              [(odd? (+ head tail))\
    \ (sort_array (cons head (sort_array (cons (length tail) tail)))]\n          \
    \    [else (cons head tail)])))\n  )\n", "  (if (null? array)\n      array\n \
    \     (sort (cons (first array) array) (lambda (x y) (if (odd (sum (first x) (rest\
    \ x)) (+ y (rest y)) (+ x y)))))))\n", "  (define (corkt l s acc)\n    (if (null?\
    \ l)\n        acc\n        (corkt (cdr l) (+ s ((car l))) \n          (cons s\
    \ (cons (car l) acc))))\n  (corkt array 0 (sort (sort array (lambda (x) (+ x 1))\
    \ <)))\n)", "  (if (null? array)\n      array\n      (let [head (car array)\n\
    \            tail (cdr array)\n            even (< (+ head tail) 2)\n        \
    \    odd (not (even))]\n        (if (even)\n            (sort_array (sort_array\
    \ tail))\n            (append head (sort_array tail)))))\n  ", "  (if (null? array)\
    \ (list array) \n    (let ((sum (apply + array)))\n      (cond\n        ((= (mod\
    \ sum 2) 1)\n          (sort_array (append (list (first array))\n            \
    \               (reverse (sort (append (reverse (second array)) \n           \
    \                                    (list (last array))))))\n        ((= (mod\
    \ sum 2) 0)\n          (sort_array (append (list (first array))\n            \
    \               (reverse (sort (append (reverse (last array)) \n             \
    \                                  (list (first array))))))))))))\n", "  (if (empty?\
    \ array)\n      (list empty)\n      (sort-helper (sub1 array)\n              \
    \    (sub1 (last array))\n                  (cons (first array) (sort_array (rest\
    \ array))))))\n", "  (if (null? array)\n      (list)\n      (let ([head (car array)])\n\
    \        (sort_array (rest array))\n        (cond [(even? sum (first head (last\
    \ head array)) (rest head array))]\n              [(even? (- sum head (last head\
    \ array)) (rest head array))]\n              [else (cons head (sort_array (rest\
    \ head array)))])))) ; odd\n", "  (if (empty? array)\n      (list)\n      (let\
    \ ((head (first array))\n            (tail (rest array)))\n        (if (odd? head)\n\
    \            (cons (cons head tail) (cdr head))\n            (cons (cons head\
    \ (sort-array tail)) (cdr head))))))\n", "  (cond\n    [(empty? array) (corkt\
    \ array)]\n    [(even? (rest array)) (corkt (reverse array))]\n    [(odd? (rest\
    \ array)) (corkt (reverse (reverse array)))]))\n", "  (let ((sum (+ array (first\
    \ array))))\n    (if (odd? sum)\n        (sort (subseq array 0 (- (length array)\
    \ 1)))\n        (sort (subseq array 0 (- (length array) 1) (- sum (first array)))))\n\
    \    array))\n</cell>\n<cell>\n#lang racket\n", "  (sort (lambda (x y)\n     \
    \     (if (odd? (+ x y)) (< x y) (> x y))\n          (if (even? (+ x y)) (< x\
    \ y) (> x y)))\n        array))\n", "  (if (or (not (list? (car array))) (not\
    \ (number? (car array)))) (list array) (car (sort_array (cdr array)))\n    (sort-array\
    \ (list array (sort (first array) (cdr array))))))\n", "  (if (null? array)\n\
    \      array\n      (let ([sum (first array)])\n        (if (oddp (+ sum (length\
    \ array)))\n            (sort (sort (subseq array 0 (- (length array) 1)) sum)\n\
    \                  (subseq array 1 (- (length array) 1) #f)\n                \
    \  #<)\n            (sort (sort (subseq array 0 (- (length array) 1)) sum)\n \
    \                 (subseq array 1 (- (length array) 1) #f)\n                 \
    \ #>)))))\n", "  (if (null? array)\n      '()\n      (cond\n        ((odd? (first\
    \ array) (last array))\n         (sort (first array) (sort_array (last array))))\n\
    \        (else\n         (sort (last array) (sort_array (first array)))))))\n\
    </cell>\n<text>\nExercise 8.5\nWrite a procedure that accepts a list of non-negative\
    \ integers, sorts them, and returns a list of sorted numbers.\n\nExamples:", " \
    \ (cond\n    [(empty? array) array]\n    [(= 0 (rest array) ) (cons (first array)\
    \ (sort_array (rest array)))]\n    [else (cons (first array) (sort_array (rest\
    \ array)))]\n  ))\n", "  (sort_array-helper array (array-length array)))\n", " \
    \ (define (helper i j k)\n    (cond\n      [(or (< i j) (< j k)) (let ([a (list-ref\
    \ array i)\n                                  b (list-ref array j)\n         \
    \                         c (list-ref array k)])\n                          (cond\
    \ \n                            [(= (- a (+ b c)) (+ a b c)) (helper i j (+ a\
    \ b c))]\n                            [(= (- a b) (+ a b c)) (helper i (+ a b)\
    \ c)]\n                            [(= (- a c) (+ a b c)) (helper i (+ a c) k)]\n\
    \                            [else (helper i (+ a c) k)]\n                   \
    \       )])]\n      [(< i j) (let ([a (list-ref array i)\n                   \
    \               b (list-ref array j)\n                                  c (list-ref\
    \ array k)])\n                          (cond \n                            [(=\
    \ (+ a (- b c)) (+ a b c)) (helper i j (+ a b c))]\n                         \
    \   [(= (+ a b) (- a b c)) (helper i (+ a b) c)]\n                           \
    \ [(= (+ a c) (- a b c)) (helper i (+ a c) k)]\n                            [else\
    \ (helper i (+ a c) k)]\n                          )])]\n      [else (let ([a\
    \ (list-ref array i)\n                               b (list-ref array j)\n  \
    \                             c (list-ref array k)])\n                     (cond\
    \ \n                       [(= (+ a b) (+ a b c)) (helper i (+ a b) k)]\n    \
    \                   [(= (+ a c) (+ a b c)) (helper i (+ a c) k)]\n           \
    \            [(= (+ a b) (+ a c b)) (helper i (+ a c) k)]\n                  \
    \     [else (helper i (+ a c) k)]\n                      )])]))\n  (helper (length\
    \ array)\n          (length array)\n          0))", "  (define (helper-function\
    \ current-list sum)\n    (if (> sum 0)\n        (car\n         (cdr\n        \
    \  (if (even? sum)\n              (helper-function (append (cdr current-list)\
    \ (cdr (cdr current-list))) (- sum (car current-list)))\n              (helper-function\
    \ (cdr current-list) (+ sum (car current-list))))))\n        '()))\n  (helper-function\
    \ array (+ 0)))", "  (if (null? array)\n      '()\n      (let ((sum (+ 0 (length\
    \ array)))\n            (index (cdr array)))\n        (cond ((odd? sum)\n    \
    \          (cons (car array) (sort_array (cdr array))))\n              ((even?\
    \ sum)\n              (cons (car array) (sort_array (cdr array))))\n         \
    \     (else (sort_array (cdr array)))))))", "  (sort array\n        (lambda (a\
    \ b)\n          (if (odd? (+ a b))\n            (+ a b)\n            (- a b))))\n\
    \  )\n", "  (letrec\n    ((even (lambda (list)\n              (cond\n        \
    \        [(null? list) (list '() '())]\n                [else\n              \
    \   (let ((first (car list)) (last (cdr list)))\n                   (cond\n  \
    \                   [(even? (- first last)) (cons (car list) (even (cdr list)))]\n\
    \                     [(odd? (- first last)) (cons (car list) (odd (cons first\
    \ last)))]))])))\n    ((odd  (lambda (list)\n              (cond\n           \
    \     [(null? list) (list '() '())]\n                [else\n                 (let\
    \ ((first (car list)) (last (cdr list)))\n                   (cond\n         \
    \            [(even? (- first last)) (cons (car list) (odd (cons first last)))]\n\
    \                     [(odd? (- first last)) (cons (car list) (even (cdr list)))]))])))\n\
    \    ((sort_array_inner array even odd) (let ((lists (sort_array_inner (cdr array)\
    \ even odd)))\n                                     (cond\n                  \
    \                    [(null? (car array)) (cons (car array) (cdr array))\n   \
    \                                    (else (cons (car lists) (cdr lists))))]))))\n\
    \  (sort_array_inner (sort array <) even odd))\n", "  (sort (list (car array))\
    \ (lambda (x y) (if (odd? (+ (car array) y)) (* -1 (car array)) (if (even? (+\
    \ (car array) y)) (* 1 (car array)) (if (< (car array) y) (* -1 (car array)) (*\
    \ 1 (car array)))))) (cdr array)))\n", "  (let* ((result (list-of (sort (cons\
    \ (first array) (last array)))\n                           (lambda (x y)\n   \
    \                          (if (odd? (+ x y))\n                              \
    \   (reverse (cons x y))\n                                 (cons x y)))\n    \
    \                       (lambda (x y)\n                             (if (even?\
    \ (+ x y))\n                                 (reverse (cons y x))\n          \
    \                       (cons x y))))))\n    (if (null? (rest array))\n      \
    \  result\n        (cons (first array) (sort_array (rest array))))))\n", "  (if\
    \ (null? array)\n      '()\n      (let ((sum (+ 0 (first array))) (odd (sub1 (length\
    \ (first array))))) (if (odd? sum)\n                                         \
    \                              (reverse (sort_array (rest array))) (sort_array\
    \ (cons (first array) (sort_array (rest array)))))))\n", "  (cond ((or (null?\
    \ array) (null? (cdr array)))\n         array)\n        ((or (zero? (car array))\n\
    \             (odd (sum (car array) (cdr array))))\n         (cons (car array)\n\
    \               (sort_array (cdr array))))\n        (else\n         (sort_array\
    \ (cdr array)))))\n", "  (let ([len (length array)])\n    (cond [(= len 0)\n \
    \          (cons array '())]\n          [(even? (+ (car array) (cdr array)))\n\
    \           (cons array (cons (car array) (sort_array (cdr array))))]\n      \
    \    [else\n           (cons array (sort_array (cdr array)))])))\n</code>\n<|/\
    \ a dscore=0 tags=scheme,racket,list,sorting |>\n<| c |>\nWhy `letrec` over `let`?\n\
    <|/ c |>\n<| c |>\nYou don't need `(letrec ([len (length array)])` because `(letrec\
    \ ([len (length array)])` will evaluate `(length array)` for each element of the\
    \ list `array`, which is not needed.\n<|/ c |>\n<| c |>", "  (cond\n    [(null?\
    \ array) '()]\n    [(zero? (car array)) (cdr array)]\n    [(even? (+ (car array)\
    \ (last array)))\n     (sort_array (sort_array (sort (cons 0 array) desc)))]\n\
    \    [(odd? (+ (car array) (last array)))\n     (sort_array (sort_array (sort\
    \ (cons 0 array) asc)))]\n    [else (cons (car array) (sort_array (sort (cdr array)\
    \ asc)))]))\n", "  (cond [(null? array) array]\n        [(odd? (first array))\
    \ (sort_array (sort_array (list array (last array))))]\n        [(even? (first\
    \ array)) (sort_array (list (sort_array (list array (last array)))))]\n      \
    \  [else (cons (first array) (sort_array (sort (last array) (lambda (x y) (< x\
    \ y))))]))\n</code>\n<|/ a dscore=2 tags=scheme,racket,recursion,sorting |>\n\
    <| c |>\nThis looks good, but this looks like it's just sorting in descending\
    \ order. How do I change it to sorting in ascending order?\n<|/ c |>\n<| c |>\n\
    Nevermind, I just realized that I need to change > to <. Thank you so much!\n\
    <|/ c |>\n<| a dscore=1 |>\nFor those of us who are into functional programming,\
    \ I think this may be the fastest solution for large arrays. Thanks to those who\
    \ answered. :)\n<code>", "  (cond\n    [(empty? array) empty]\n    [else\n   \
    \  (let ([sum (apply + array)])\n       (cond\n         [(even? sum)\n       \
    \   (corkt (apply insert-at (reverse array) 0))]\n         [else\n          (corkt\
    \ (apply insert-at (reverse array) 1))]))]))\n", "  (if (null? array)\n      '()\n\
    \      (cond ((odd? (sum (first array) (last array)))\n            (cons first\
    \ sort_array (cons last (sort_array (sub1 array))))\n            (cons last (sort_array\
    \ (sub1 array))))))\n</code>\n<|/ a tags=recursion,racket,scheme |>\n<| c |>\n\
    The \"if odd\" test is unnecessary, it works fine with a single argument list\
    \ like `(cons first sort_array ...)`, since \"the cons operation creates a new\
    \ list with the given element as its tail and the given list as its head.\"  So\
    \ `((cons first sort_array) ...)` is the same as `sort_array (cons first ...)`,\
    \ which then works perfectly fine with `sort-array` being `((lambda (a b) (sort\
    \ (+ a b) (lambda (x) (+ x a))) ...`\n<|/ c |>\n<| c |>\nyes, but this way I thought\
    \ that maybe it will help to see a more formal way of thinking of recursion.\n\
    <|/ c |>\n<| c |>\nThanks for the help and the explanation I really appreciate\
    \ it.  I was having trouble wrapping my head around it and I appreciate the explanation\
    \ for the recursive call.\n<|/ c |>\n<| c |>\nThanks for pointing out that `((cons\
    \ first sort_array) ...)` is the same as `sort_array (cons first ...)`.  That\
    \ actually makes it a lot more clear.  I was not aware of that.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  (if (null? (rest array))\n      array\n      (let\
    \ ((sum (+ (first array) (last array)))\n            (result (list array))\n \
    \           (head (first array))\n            (tail (rest array)))\n        (if\
    \ (odd? sum)\n            (let ((head (first array))\n                   (tail\
    \ (rest array)))\n              (if (null? (rest array))\n                  (sort_array\
    \ tail)\n                  (append (sort_array (append tail head))\n         \
    \                 (cons (first tail) result))))\n            (if (even? sum)\n\
    \                (let ((head (first tail))\n                       (tail (rest\
    \ tail)))\n                  (if (null? (rest tail))\n                      (sort_array\
    \ tail)\n                      (append (sort_array (append head tail))\n     \
    \                         (cons (first head) result)))))))))\n", "  (cond\n  \
    \  [(empty? array) (list array)]\n    [(even? (rest array))\n     (append (sort_array\
    \ (list (first array) (last array)))\n             (list array))\n     (reverse\
    \ (sort_array (list (first array) (last array))))]\n    [(odd? (rest array))\n\
    \     (append (sort_array (list (first array) (last array)))\n             (list\
    \ (last array)))\n     (reverse (sort_array (list (first array) (last array))))]\n\
    \    [else (sort_array (list (first array) (last array))) ]\n  ))\n", "  (if (empty?\
    \ array)\n      (corkt (list nil))\n      (let ((sum (+ (car array) (cadr array))))\n\
    \        (if (even? sum)\n            (let ((min (car array)))\n             \
    \ (sort_array (append (cdr array)\n                                (list (list\
    \ min (- sum min)))))\n            (let ((max (cadr array)))\n              (sort_array\
    \ (append (list (list max (+ sum max)))\n                                (cdr\
    \ array))))))))\n", "  (if (= (length array) 1)\n      (begin (append (list-ref\
    \ array 0) (sort (list-ref array 1) #(< #%1 #%2) (append (list-ref array 0) (sort\
    \ (list-ref array 1) #(> #%1 #%2) (list ))))))\n      (begin (append (sort (list-ref\
    \ array 0) #(< #%1 #%2) (append (sort (list-ref array 0) #(> #%1 #%2) (list )))))))\n",
  "  (let ([sum (reduce + (reverse array))])\n    (if (< sum 0)\n        (sort_array\
    \ (reverse array))\n        (let ([start (min 0 sum)\n              end (max 0\
    \ (- sum))])\n          (if (< start end)\n              (sort_array (reverse\
    \ array))\n              (if (even? (- sum (- start end)))\n                 \
    \ (sort-array (reverse array))\n                  (sort-array (reverse array))))))))\n",
  "  (let\n      ((total (length array))\n       (sum (lambda (x) (car x)))\n    \
    \   (even-sum (lambda (x) (cdr x))))\n    (set! sum (lambda (x y) (+ x y)))\n\
    \    (set! even-sum (lambda (x y) (if (and (>= x 0) (< x total)) (+ x y) y)))\n\
    \    (cond ((even-sum (map even-sum array)) (sort_array (map sum array))) ;; Sort\
    \ even in descending order\n          ((even-sum (map sum array)) (sort_array\
    \ (map even-sum array))) ;; Sort odd in ascending order\n          (else (list\
    \ array)))\n  (lambda (a b c) (list b a c))))\n", "  (define (helper index array)\n\
    \    (if (< (length array) 1)\n        (begin (display (first array))\n      \
    \        (set! index (+ index 1))\n              (helper (first array) array)\n\
    \              (display index)\n              (newline))\n        (begin (display\
    \ (first array))\n              (set! index (+ index 1))\n              (helper\
    \ (first array) array)\n              (display index)\n              (newline))\n\
    \        (begin (display (first array))\n              (set! index (+ index 1))\n\
    \              (helper (first array) array)\n              (display index)\n \
    \             (newline))))\n  (helper 0 array))", "  (if (null? array)\n     \
    \ array\n      (let ([sum (+ 0 (array-last array))]\n            (rest (cdr array)))\n\
    \        (if (odd? sum)\n            (cons (car array) (sort_array rest))\n  \
    \          (cons (car array) (sort_array rest (- sum (array-first array))))))))\n",
  "  (if (null? (cdr array))\n      (append (list array)\n              (list (car\
    \ array))\n              (sort_array (cdr array))))\n  (cond ((even? (car array))\n\
    \         (sort_array (cons (car array) (append (list (car array) (sort (cdr array)))\
    \ (list (car array))))))\n        ((odd? (car array))\n         (sort_array (cons\
    \ (car array) (append (list (car array) (sort (cdr array))) (list (car array))\
    \ (sort (cdr array)))))))\n</code>\n<|/ a tags=scheme dscore=1 |>\n<| c |>\nOh\
    \ thank you so much, i just didnt know what to google for haha haha :P anyways,\
    \ thank you for the help!\n<|/ c |>\n<| c |>\nBy the way, how would you do this\
    \ with cons lists? Im trying to find the best way to do it but im not familiar\
    \ with cons lists.\n<|/ c |>\n<| c |>\nYou don't need to do anything special with\
    \ `cons` lists because `cons` is used to construct lists, not add items to lists.\
    \  If you have trouble with understanding how to append items, then perhaps you\
    \ may want to pick up a textbook on scheme, either from a library, or from some\
    \ online tutorials.  If you have trouble with understanding how to work with cons\
    \ lists, then perhaps you should learn more about it before continuing on.  You\
    \ may want to try [this](http://www.gigamonkeys.com/book/syntax-recipes-for-programmers-part-two/)\
    \ as a starting point.\n<|/ c |>\n<| c |>\nThanks again! I'll definitely take\
    \ a look at that book! :D\n<|/ c |>\n<| a tags=scheme |>\n<code>", "  (sort array\
    \ (lambda (x y) (<\n                         (+ (car array) (car y)) (+ (cdr array)\
    \ (cdr y))))))\n", "  (if (empty? array)\n      array\n      (if (odd? (car array)\
    \ (+ (car array) (cadr array)))\n          (cons (car array) (sort_array (cddr\
    \ array))) \n          (cons (car array) (sort_array (cddr array)))))) \n", " \
    \ (if (< (length array) 1) array)\n    (append (sort (sort_array (sub1 array))\
    \ #'<)\n            (sort_array (sub1 array))))\n  array)\n", "  (if (or (null?\
    \ array) (null? (cdr array)))\n      '()\n      (let ((result (make-array (list\
    \ (length (cdr array)) #f #f #f))) (\n          (index (+ 0 (car array))) (\n\
    \          (sum (car array) (+ (cdr array) (+ index 0))) \n          (even (sum\
    \ (car array) (+ (cdr array) (+ index 0))))\n          )\n          )\n      (if\
    \ (even? (sum (car array) (+ (cdr array) (+ index 0)))) \n          (set! result\
    \ (cons (car array) result)) \n          (if (or (null? (cdr array)) (null? (cdr\
    \ result)))\n              '()\n              (set! result (cons (car array) (cddr\
    \ result))) \n              (set! index (+ 1 index))\n              (if (or (=\
    \ index (length (cdr array)))\n                    (even? sum)\n             \
    \       (even? (sum (car array) (+ (cdr array) (+ index 0))))\n              \
    \      )\n                  (set! result (cons (car array) result)) \n       \
    \           (set! index (+ 1 index))\n                  (if (or (= index (length\
    \ (cdr array)))\n                          (even? sum)\n                     \
    \     (even? (sum (car array) (+ (cdr array) (+ index 0))))\n                \
    \          )\n                    (set! result (cons (car array) result)) \n \
    \                   (set! index (+ 1 index))\n                    (if (or (= index\
    \ (length (cdr array)))\n                            (even? sum)\n           \
    \                 (even? (sum (car array) (+ (cdr array) (+ index 0))))\n    \
    \                        )\n                    (set! result (cons (car array)\
    \ result)) \n                    (set! index (+ 1 index))\n                  \
    \  (if (or (= index (length (cdr array)))\n                            (even?\
    \ sum)\n                            (even? (sum (car array) (+ (cdr array) (+\
    \ index 0))))\n                            )\n                    (set! result\
    \ (cons (car array) result)) \n                    (set! index (+ 1 index))\n\
    \                    (if (or (= index (length (cdr array)))\n                \
    \            (even? sum)\n                            (even? (sum (car array)\
    \ (+ (cdr array) (+ index 0))))\n                            )\n             \
    \       (set! result (cons (car array) result)) \n                    (set! index\
    \ (+ 1 index))\n                    (if (", "  (let ((result (make-array (list\
    \ array->length 0)\n                          :element-type 'number\n        \
    \                  :initial-contents 0)))\n    (loop for i from 0 to (array->length\
    \ array) do\n          (let ((sum (+ (array->car array) (- (array->cdr array))))\n\
    \                (newsum (- sum (modulo (array->cdr array)\n                 \
    \                      2 1)))\n                (j (modulo (+ i 1) 2))\n      \
    \          (k (modulo i 2)))\n            (cond ((= newsum 0)\n              \
    \     (set! result (append result (list (array->car array))))\n              \
    \     (break)\n                   (else\n                    (set! result (append\
    \ result (list (modulo (+ j 1) 2))\n                                         \
    \  (list (modulo (- k 1) 2)\n                                                \
    \ sum)))))))\n    (reverse result)))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is another recursive solution in Racket:\n<code>", "  (define (helper array\
    \ sum)\n    (if (null? array)\n        array\n        (if (even? (- sum (first\
    \ array))) (helper (rest array) sum) (helper (rest array) (- sum (first array)))))\n\
    \  (helper array (+ 0 (last array))))", "  (let loop ((head (car array)) (tail\
    \ (cdr array))\n             (sorted (car head)) (temp-head (car tail)))\n   \
    \ (cond\n      [(null? tail) (cdr sorted)]\n      [(null? (cdr tail)) (cons head\
    \ sorted)]\n      [(even? (+ head temp-head))\n       (loop (cdr tail) (cdr tail)\
    \ (cdr head) (cons head sorted))]\n      [(odd? (+ head temp-head))\n       (loop\
    \ (cdr tail) (cdr tail) (cdr tail) (cons head sorted))]\n      [(even? (+ temp-head\
    \ head))\n       (loop (cdr head) (cdr head) (cdr head) (cdr tail))]\n      [(odd?\
    \ (+ temp-head head))\n       (loop (cdr head) (cdr head) (cdr head) (cdr tail))]\n\
    \      [else (loop (cdr tail) (cdr tail) (cdr head) (cdr tail))]\n      )))\n",
  "  (cond ((empty? array)\n         (list empty))\n        ((even? (length array))\n\
    \         (sort_array (sort_array1 (rest array))))\n        (else (sort_array\
    \ (sort_array1 (rest array)) (sort_array1 (rest array))))))\n", "  (if (null?\
    \ array)\n      (list)\n      (let ((sum (add1 (apply + (car array) (cdr array))))\n\
    \            (odd (boolean-value odd? (mod sum 2)))\n            (even (boolean-value\
    \ even? (mod sum 2))))\n        (if (odd? sum)\n            (sort_array (sort_list\
    \ (list array (cdr array))))\n            (sort_array (sort_list (list (car array)\
    \ array)))))))\n", "  (sort array (lambda (a b)\n               (cond\n      \
    \          [(= (+ a b) 0)\n                 (list a)]\n                [else\n\
    \                 (cond\n                   [(= (mod a 2) 1)\n               \
    \     (list b)]\n                   [(= (mod a 2) 0)\n                    (list\
    \ a)]\n                   [(= (mod b 2) 1)\n                    (list a)]\n  \
    \                 [(= (mod b 2) 0)\n                    (list b)]\n          \
    \       )\n                )\n               ]\n              )\n            \
    \ )\n           )\n  )\n", "  (if (null? array) '()\n      (sort (list array (reverse\
    \ (list_ref array 0))) ; sort first in asc, then reverse it\n            (lambda\
    \ (x y)\n              (and (odd (+ x (last y)))\n                  (even (+ x\
    \ (first y))))))))\n", "  (let ([sum (first array) (cdr array)])\n    (cond\n\
    \      [(= 0 (length sum)) (corkt array)]\n      [(even? (sum 0)) (corkt (reverse\
    \ (sort_array (last array))))]\n      [else (corkt (append (sort_array (last array))\
    \ (list (first array))))]\n      )\n    ))\n", "  (cond\n    [(empty? array) (list\
    \ array)]\n    [(even? (car array)) (sort_array (cdr array))]\n    [(odd? (car\
    \ array)) (sort_array (cdr array))]\n    [else (sort_array (cons car array))]))",
  "  (if (null? array) array\n      (cond\n        ((< (car array) (cadr array)) (cons\
    \ (cadr array) (car array)))\n        ((> (car array) (cadr array)) (cons (car\
    \ array) (cadr array)))\n        (else (sort_array (cdr array))))))\n", "  (if\
    \ (null? array)\n      (list nil)\n      (let* ((sum (+ (first array) (last array)))\n\
    \             (isOdd? (< sum odd))\n             (result (if (isOdd?)\n      \
    \                   sort-odd\n                         sort-even))\n         \
    \    (index (list 0 0))\n             (listResult (apply append result))\n   \
    \          (loop (add1 index)\n                    (set! listResult (cons (first\
    \ array) (first listResult))\n                             (cons (last array)\
    \ (last listResult))\n                             listResult)\n             \
    \       (if (= (length index) 2)\n                        (cond\n            \
    \             ((and (= (first array) (car index))\n                          \
    \    (= (first array) (cdr index)))\n                          (cond\n       \
    \                    ((and (= (cdr index) (cdr array))\n                     \
    \           (< sum (- sum odd))\n                                (< sum (+ sum\
    \ odd))\n                                (< sum (- sum (+ odd)))\n           \
    \                     (< sum (+ sum (+ odd)))\n                              \
    \  (< sum (- sum (- odd))))\n                                (cons (car array)\
    \ (cons result (cdr array))))\n                           ((and (= (cdr index)\
    \ (cdr array))\n                                (< sum (+ sum odd))\n        \
    \                        (< sum (- sum (+ odd))\n                            \
    \    (< sum (- sum (- odd)))\n                                (< sum (+ sum (-\
    \ odd)))\n                                (< sum (- sum (+ odd)))\n          \
    \                      (< sum (+ sum (+ odd))))\n                            \
    \    (cons (car array) (cons result (cdr array))))\n                         \
    \  ((and (= (cdr index) (cdr array))\n                                (< sum (-\
    \ sum (+ odd))\n                                (< sum (+ sum (- odd))\n     \
    \                           (< sum (- sum (+ odd)))\n                        \
    \        (< sum (+ sum (- odd)))\n                                (< sum (- sum\
    \ (- odd)))\n                                (< sum (+ sum (+ odd))))\n      \
    \                          (cons (car array) (cons result (cdr array))))\n   \
    \                        ((and (= (cdr index) (cdr array))\n                 \
    \               (< sum (- sum (+ odd))\n                                (< sum\
    \ (- sum (- odd))\n                                (< sum (- sum (+ odd)))\n \
    \                               (< sum (+ sum (- odd", "  (if (null? array)\n\
    \      array\n      (let ([a (first array)\n            b (last array)\n     \
    \       c (length (sort_array (rest array)))])\n        (if (< a b)\n        \
    \    (cons (sort_array (sort array (lambda (x y) (if (even? x) (- x y) (- (- x\
    \ y) c)))))\n            (cons (sort_array (sort array (lambda (x y) (if (odd?\
    \ x) (+ x y) (- (- x y) c)))))\n          array))))\n", "  (define (aux list index\
    \ sum)\n    (cond\n      [(= sum 0) list]\n      [else (aux list\n           \
    \      (+ index 1)\n                 (+ sum (first list) (last list)))]))\n  (aux\
    \ array (length array) 0))\n", "  (sort (lambda (x y) (< x y)) array))\n", " \
    \ (let loop ((index 0) (array array (car (cdr array))) (result (car array)))\n\
    \    (if (<= index 10)\n        (cons result result)\n        (if (even? index)\n\
    \            (loop (+ index 1)\n                  (cdr array)\n              \
    \    (cons (car array) result))\n            (loop (+ index 1) (cdr array) (cons\
    \ (car array) result))))))\n", "  (if (and (list? array) (not (null? (cdr array))))\
    \ (sort-array (car array) (sort-array (cdr array) (caddr array) (cadddr array)))\
    \ (sort-array (car array) (cadddr array))))\n", "  (cond\n    [(empty? array)\
    \ (list array)]\n    [(even? (car array)) (sort_array (sort_array (cdr array)))]\n\
    \    [else (cons (car array) (sort_array (cdr array)))]))", "  (cond\n    [(empty?\
    \ array) empty]\n    [else (cons (first array)\n               (sort_array (sub1\
    \ array)))]))\n", "  (if (empty? array)\n      (list empty)\n      (let ((sum\
    \ (car array))\n            (cur-sum (+ sum 1)))\n        (let ((head-sum (if\
    \ (oddp? cur-sum) (- cur-sum sum) (+ cur-sum sum))))\n          (let ((tail-sum\
    \ (- cur-sum sum)))\n            (if (evenp? head-sum)\n                (sort_array\
    \ (cons head-sum tail-sum))\n                (sort_array (cons tail-sum head-sum)))))\n\
    \        (sort_array (cons (car array) cur-sum)))))\n", "  (if (or (empty? array)\
    \ (null? (cdr array))) array\n      (let ([head (car array)]\n            [end\
    \ (if (odd? (first array) last (last array))\n                    (cdr array)\n\
    \                    (cons (car array) (cdr array))))])\n        (let ([midpoint\
    \ (/ (length end) 2)])\n          (cons head (sort_array (sub1 end (+ head midpoint)))))))\n\
    \n#lang racket\n", "  (cond\n    [(null? array) (list array)]\n    [(empty? (rest\
    \ array)) (cons (first array) (sort array (rest array)))]\n    [(even? (sum (rest\
    \ array) (first array)))\n     (cons (first array) (sort_array (rest array)))]\n\
    \    [(odd? (sum (rest array) (first array)))\n     (sort_array (rest array))]\n\
    \    ))\n", "  (define (helper nums sum)\n    (cond [(zero? sum) nums]\n     \
    \     [(odd? sum) (cons 0 (reverse nums))]\n          [(even? sum) (cons 1 (reverse\
    \ nums))]\n          [else (helper (cons nums (reverse nums)) (+ sum nums)])\n\
    \          )\n    (helper array 0))\n  (sort_array array))\n", "  (cond\n    [(empty?\
    \ array) (list array)]\n    [(odd? (car array) (last array))\n     (cons (car\
    \ array) (reverse (sort_array (tail array))))]\n    [(even? (car array) (last\
    \ array))\n     (cons (car array) (sort_array (tail array)))]\n    [else (error\
    \ \"sort_array expects an array of positive integers\")]\n    )\n  )\n", "  (cond\
    \ [(empty? array) empty]\n        [(even? (first array)) (sort_array (rest array))]\n\
    \        [else (sort_array (rest array))]))\n", "  (sort\n   (lambda (x) (\n \
    \    (if (odd (+ (first x) (last x)) (+ (last x) (first x))) -1\n         (if\
    \ (even (+ (first x) (last x)) (+ (last x) (first x))) -1\n             (if (=\
    \ (+ 0 (- 1 n)) 1)\n                 (if (even (+ (first x) (last x)) (+ (last\
    \ x) (first x)))\n                     (- x (first x))\n                     (-\
    \ x (last x))\n                     (+ (first x) (last x))))\n             (if\
    \ (even (+ (first x) (last x)) (+ (last x) (first x)))\n                 (- x\
    \ (first x))\n                 (- x (last x))\n                 (+ (first x) (last\
    \ x))))\n     1))\n   array))\n", "  (if (null? array)\n      '(())\n      (cons\
    \ 0 (sort_array (sub1 array))\n             (sort_array (sub2 array))))\n  (cond\n\
    \    [(< (first array) (last array)) (cons (first array) (sort_array (sub2 array)))]\n\
    \    [else (cons (first array) (sort_array (sub1 array)))]))\n", "  (sort\n  \
    \ (\u03BB ((x y) (< (first x) (first y))\n            (or (and (= (first x) (first\
    \ y)) (= (last x) (last y)))\n                 (< (last x) (first y)))))\n   array))\n",
  "  (if (empty? array) empty\n      (let-values ([(sum first)\n                 \
    \  (tail rest)])\n        (sort_array rest)\n        (if (even? sum)\n       \
    \     (append (list first)\n                    (sort_array tail))\n         \
    \   (append (list first)\n                    (sort_array (sort (list first) (list\
    \ tail))))))))\n", "  (if (null? array)\n      (list array)\n      (let ((first-index-value\
    \ (first array))\n            (last-index-value (last (rest array))))\n      \
    \  (if (odd? last-index-value)\n            (sort (list array last-index-value\
    \ first-index-value)\n                  (lambda (a b)\n                    (if\
    \ (< a b)\n                        (- b a)\n                        (- a b))))\n\
    \            (sort (list array first-index-value last-index-value)\n         \
    \         (lambda (a b)\n                    (if (< b a)\n                   \
    \     (- a b)\n                        (- b a))))))))\n", "  (cond [(or (empty?\
    \ array) (empty? (cdr array))) (list array)]\n        [else (let ([first (car\
    \ array)])\n                 (sort (cons (car array) array) ; sort on the first\
    \ element\n                       #(or (odd? (car %)) (even? (car %))) (sort_array\
    \ (cdr array))))]))\n", "  (let ([array (sort array)])\n    (if (even? (length\
    \ array))\n        (sort (sort (list array)))\n        (sort (sort (list array\
    \ (car array)))) )))\n", "  (if (empty? array)\n      (list)\n      (let ([length\
    \ (length (first array))]\n            [sum (+ (first array) (last array))]\n\
    \            [even (= (modulo sum 2) 0)])\n        (if (even? (modulo sum 2))\n\
    \            (list (sort_array (sort array [> (first array) (first array)])))\n\
    \            (list (sort_array (sort array [< (first array) (first array)])))\n\
    \            array))))\n", "  (let ([sum (\u03BB (a b)\n              (+ a (first\
    \ b)))\n        even-sum (\u03BB (a b)\n              (if (even? (+ a (first b)))\n\
    \                  (+ a (first b))\n                  (- a (first b))))\n    \
    \    (odd-sum (\u03BB (a b)\n              (if (odd? (+ a (first b)))\n      \
    \            (+ a (first b))\n                  (-a (first b))))])\n    (if (null?\
    \ (first array))\n        (reverse array)\n        (if (odd? sum)\n          \
    \  (cons (first array) (sort_array (cons (first array) (sort (last array) even-sum))))\
    \ (sort_array (cons (first array) (sort (last array) odd-sum)))))))", "  (cond\n\
    \    [(null? array) (list array)]\n    [(pair? array) (append (sort (caar array)\
    \ (sort_array (cdr array)))\n                           (list (car array)))]\n\
    \    [else (append (sort (car array) (sort_array (cdr array)))\n             \
    \      (list (car array)))]\n    ))\n", "  (cond [(null? array)\n         (car\
    \ array)]\n        [(> (sum (car array) (last-element array)) (sum (first-element\
    \ array) (last-element array)))\n         (reverse (sort_array (rest array)))]\n\
    \        [else\n         (sort_array (append (sort (car array) '<) (reverse (sort_array\
    \ (rest array)))))]))\n", "  (define (helper array index result sum)\n    (if\
    \ (null? array)\n        result\n        (helper (cdr array) (+ index 1) (cons\
    \ (car array) (cons sum (car array) result)) (+ sum (car array))))\n    (helper\
    \ array 0 '() (if (even? (car array)) (car array) (- car array))))\n  (helper\
    \ array 0 '() (if (even? (car array)) (car array) (- car array))))\n", "  (if\
    \ (empty? array)\n      '()\n      (append (sort_array (first array))\n      \
    \        (sort_helper (rest array) (rest (last array)))\n              (sort_helper\
    \ (rest array) (first array))))))\n", "  (if (null? array)\n      array\n    \
    \  (append (sort (if (even? (- (car array) (sum (rest array))))\n            \
    \           (append (reverse (car array))\n                              (append\
    \ (reverse (cadr array))\n                                       (reverse (caddr\
    \ array))))\n                     (sort_array (rest array)))\n              (sort_array\
    \ (cdr array)))))\n", "  (if (null? array)\n      (list )\n      (let ((sum (+\
    \ (car array) (cadr array))))\n        (if (odd? sum)\n            (cons (car\
    \ array)\n                   (sort_array (cdr array)))\n            (cons (cadr\
    \ array)\n                   (sort_array (cdr array)))))))\n", "  (let ((l (length\
    \ array))\n        (sum (foldr (lambda (x y) (+ x y)) 0 array)))\n    (cond [(<\
    \ sum 0) array]\n          [(< l sum) (sort_array (cons 0 array))]\n         \
    \ [(= l sum) (cons 0 array)]\n          [(even? sum) (cons 0 (sort_array (sort_array\
    \ (sub1 array))))]\n          [else (cons 0 (sort_array (sort_array (sub1 array))))]))\n",
  "  (let ([sum (apply + array)])\n    (if (even? sum)\n      (cons (sort (append\
    \ array (list 0)))\n            (sort_array (append (sub1 sum) array)))\n    \
    \  (cons (sort (append array (list 0)))\n            (sort_array (append (sub1\
    \ sum) (sub1 array))))))\n", "  (sort (lambda (x y) (if (even? sum (first x) (rest\
    \ x)) (if (odd? sum (first x) (rest y)) (list x y))))\n        array))\n", " \
    \ (sort (lambda (x) (< (first x) (last x))) (make-array (size array) '(integer\
    \ list) array))\n)\n", "  (if (null? array)\n      '()\n      (if (or (= (sum\
    \ array) (car array))\n              (= (- sum array) (car array))\n         \
    \     (= (car array) (- sum array)))\n          (cons (car array) (sort_array\
    \ (cdr array)))\n          (let ((sorted (sort_array (cdr array))))\n        \
    \    (if (or (= (sum sorted) (- sum array))\n                    (= (sum array)\
    \ (- sum array))\n                    (= (car array) (- sum array)))\n       \
    \         (cons (car sorted) (sort_array (cdr sorted)))\n                (cons\
    \ (car array) (sort_array (cdr array))))))))\n", "  (check-expect (length array)\
    \ (length array))\n  (let loop ((index 0))\n    (check-expect (< index array)\
    \ true)\n    (check-expect (< index length) true)\n    (cond ((null? array) (list\
    \ array))\n          ((even? (+ 0 (length array))) (list array))\n          ((odd?\
    \ (+ 0 (length array)))\n           (cond ((null? (rest array)) (reverse (sort_array\
    \ (rest array))))\n                  ((odd? (+ 1 (length array)))\n          \
    \         (cons array (reverse (sort_array (rest array))))\n                 \
    \ ((even? (+ 1 (length array)))\n                   (cons (cons (first array)\
    \ (reverse (sort_array (rest array))))\n                        (reverse (sort_array\
    \ (rest array))))))\n          ((odd? (+ 0 (length array)))\n           (cons\
    \ array (reverse (sort_array (rest array))))\n          (else\n           (loop\
    \ (+ 1 index) (rest array)))))\n</code>\n<|/ a tags=racket,scheme,sorting |>\n\
    <| a |>\n<code>\n#lang racket", "  (if (empty? array)\n      '(())\n      (cons\
    \ (sort_sum (car array) (cdr array)) (sort_array (cdr array)))))\n", "  (if (null?\
    \ (car array))\n      (corkt array)\n      (let ([(sum (car array) (cdr array))\n\
    \             (index1 (car array))\n             (index2 (cdr array))])\n    \
    \    (if (odd? sum)\n            (corkt (insert index1 index2 (insert index index2\
    \ array)))\n            (corkt (insert index1 index2 (insert index index2 (sort_array\
    \ (append array index2)))))))))\n", "  (let loop ((head (first array))\n     \
    \        (tail (rest array)))\n    (cond\n      [(= tail empty) (append head (list\
    \ (first head)))]\n      [(even? (first head) (first tail))\n       (cons head\
    \ (loop (first tail) (rest tail)))]\n      [(odd? (first head) (first tail))\n\
    \       (cons head (loop (first tail) (last tail)))])))\n", "  (define (helper\
    \ base acc index max)\n    (cond\n      [(> index max) acc]\n      [(or (= 0 (modulo\
    \ (+ base (first acc)) 2)) (= 0 (modulo (- base (first acc)) 2)))\n       (helper\
    \ base (cons (first acc) (append acc (list (second acc))))\n              (add1\
    \ index)\n              max)]\n      [else (helper base acc (add1 index) max)]\n\
    \      ))\n  (helper array '() (add1 0) (length array))\n  )\n", "  (let ([temp-list\
    \ (list array (sub1 (length array)))])\n    (if (even? (+ (car temp-list) (caar\
    \ temp-list)))\n        (let ([max-value (car temp-list)]\n              [min-value\
    \ (cdr temp-list)]\n              [max-index (sub1 (car temp-list))]\n       \
    \       [min-index (sub1 (cdr temp-list))])\n          (sort_array min-value)\n\
    \          (sort_array max-value))\n        (let ([max-value (car temp-list)]\n\
    \              [min-value (cdr temp-list)]\n              [max-index (sub1 (car\
    \ temp-list))]\n              [min-index (sub1 (cdr temp-list))])\n          (sort_array\
    \ max-value)\n          (sort_array min-value))))))\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI thought that this is just the same answer as mine\n<|/ c |>\n<| c |>\n\
    : thanks for your answer. Can you explain to me how this approach works?\n<|/\
    \ c |>\n<| c |>\nIt's not much different than my own solution. My solution passes\
    \ through all elements of the list in the inner loop and finds the max and min\
    \ value. In the inner loop, it calls itself with the min and max values and swaps\
    \ them if the sum is odd/even. In the outer loop, it checks whether the sum was\
    \ odd/even. If it was odd, it swaps max and min. Otherwise it swaps min and max.\
    \ In the outer loop, it calls itself on the new list, which now has min and max\
    \ swapped.\n<|/ c |>\n<| c |>\nThis solution uses three pointers to the left and\
    \ right sublists of the main list to find the max and min values.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is the simplest solution:\n<code>", "  (if (null? array)\n\
    \      (list nil)\n      ((null? (cdr array)) (sort (car array)))\n      (let\
    \ ((sum (+ (car array) (cdr array))))\n        (cond\n          [(even? sum) (sort\
    \ (cdr array))] \n          [(odd? sum) (sort (car array))]))))\n", "  (let loop\
    \ ((array array)\n             (a (car array))\n             (b (caddr array)))\n\
    \    (cond ((= a b) (sort_array array))\n          ((even? (car array))\n    \
    \       (car array))\n          ((odd? (car array))\n           (cons b\n    \
    \             (loop (cdr array)\n                      (caddr array)\n       \
    \               b))\n          (else\n           (cons a\n                 (loop\
    \ (cdr array)\n                      (caddr array)\n                      a))))))\n",
  "  (let ([length (length array)])\n    (define (helper index value)\n      (cond\n\
    \        ((null? index)\n          (list value))\n        ((even? (+ value (aref\
    \ array (- index 1))))\n          (cons (car array) (helper (cdr index) value)))\n\
    \        (else\n          (cons (car array) (helper (cdr index) value))))\n  \
    \    (helper 0 0)))\n  (sort array (lambda (x) (< (sum x) 1))))\n", "  (let ([(a\
    \ (car array))\n         (b (caddr array))\n         (c (cadddr array))]\n   \
    \     (even (= (modulo b 2) 0))\n        (odd (not even)))\n    (cond [(even (=\
    \ (modulo b 2) 0))\n           (cons (car array) (sort_array c))\n           (cons\
    \ (car a) (sort_array c))\n           (cons (car a) (cons (car array) (sort_array\
    \ c))\n           (cons (car b) (cons (car array) (sort_array c))\n          \
    \ (cons (car b) (cons (car a) (sort_array c))\n           (cons (car a) (cons\
    \ (car a) (sort_array c))\n           (cons (car b) (cons (car b) (sort_array\
    \ c)))]\n          [(not even (= (modulo b 2) 0))\n           (cons (car a) (sort_array\
    \ c))\n           (cons (car b) (sort_array c))\n           (cons (car b) (cons\
    \ (car a) (sort_array c))\n           (cons (car a) (cons (car a) (sort_array\
    \ c))\n           (cons (car b) (cons (car b) (sort_array c)))]\n          [else\n\
    \           (cons (car a) (sort_array c))\n           (cons (car b) (sort_array\
    \ c))\n           (cons (car b) (cons (car a) (sort_array c))\n           (cons\
    \ (car a) (cons (car a) (sort_array c))\n           (cons (car b) (cons (car b)\
    \ (sort_array c)))])))", "  (cond\n    [(empty? array) (list array)]\n    [(sum\
    \ (car array) (cdr array)) (cons (car array) \n                              \
    \                (sort_array (cdr array)))]\n    [else (cons (car array)\n   \
    \             (sort_array (cdr array)))]))\n", "  (let loop ((array array) (index\
    \ 0) (sum (+ 0 array)))\n    (cond ((null? array) (list array))\n          ((<\
    \ sum (- 0 (length (sub1 array))) (length (sub1 array)))\n           (let ((value\
    \ (list-ref array index))\n                 (index (+ index (length (sub1 array))))\
    \ (sum (+ sum (+ value 0))))\n             (loop (sub1 array) index sum)))\n \
    \         ((= sum (- (length (sub1 array)) (length (sub1 array))))\n         \
    \  (let ((index (+ index (length (sub1 array))) (sum (+ sum (list-ref array 0)))))\n\
    \             (loop (sub1 array) index sum))\n          ((even? (sum (+ 0 array)))\n\
    \           (let ((index (+ index (length (sub1 array))) (sum (+ sum (list-ref\
    \ array 0)))))\n             (loop (sub1 array) index sum))))))\n", "  (let ((total\
    \ (+ (first array) (last array))))\n    (cond ((< total 0)\n           (sort (list\
    \ array))))\n          ((even? total)\n           (sort (list (reverse array))))\n\
    \          (else\n           (sort (list (list (- total 1) (first array)) (list\
    \ (- total 1) (last array)) array)))))\n", "  (if (null? array)\n      array\n\
    \      (if (even? (car array))\n          (sort_array (cons (car array) (sort_array\
    \ (cdr array))))\n          (sort_array (cons (car array) (sort_array (cdr array)))\
    \ (list->vector (sort (descending (car array)) array))))))\n", "  (let loop ((array\
    \ array)\n             (result '()))\n    (if (null? array)\n        result\n\
    \        (loop (cdr array)\n              (cons (car array)\n                \
    \    (cons (caddr array)\n                          result))))))\n", "  (if (<\
    \ (length array) 2)\n      '()\n      (let ([(a (b e))\n             (c (list\
    \ array))]\n            (cond [(< a b) (cons (cons a c) (sort c))]\n         \
    \         [(< b a) (cons (cons b c) (sort c))]\n                  [(< a (+ b e))\n\
    \                   (cons (cons a (sort c)) (sort c))]\n                  [(<\
    \ (+ b e) a)\n                   (cons (cons (sort c) b) (sort c))]\n        \
    \          [else (cons (sort c) a)])))) \n  #lang racket\n", "  (let loop ((array\
    \ array) (first 0) (last 0) (sum (+ (first last) 1)))\n    (cond\n      ((null?\
    \ array) (list array))\n      ((>= sum 0) (list array))\n      ((odd? (sum 0))\
    \ (sort-odd-array array first last))\n      ((even? (sum 0)) (sort-even-array\
    \ array first last))\n      (else (loop (rest array) (add1 first) (add1 last)\
    \ (add1 sum)))))\n  (loop (rest array) (add1 first) (add1 last) (add1 sum)))\n",
  "  (if (empty? array)\n      (list)\n      ;; sort in ascending order\n      (if\
    \ (even? (+ (first array) (last array)))\n          (cons (first array) (sort_array\
    \ (rest array)))\n          (cons (last array) (sort_array (rest array)))))\n\
    \  )\n", "  (if (null? array)\n      (corkt '() '() '())\n      (let ([first (car\
    \ array)\n            last (cadr array)\n            sum (+ first last)\n    \
    \        odd (= sum (/ sum 2))]\n            [sorted1 (sort_array (remove first\
    \ array odd))]\n            [sorted2 (sort_array (remove last array (= odd 0)))])\n\
    \        (cons (if (odd? sum) (first sorted1) (first sorted2))\n             \
    \  (sort_array (cons (first sorted1) (last sorted2)))))))\n", "  (letfn [(sort_helper\n\
    \           (lambda (l acc)\n             (cond\n              [(null? l)\n  \
    \             (if (or (oddp? acc) (evenp? acc)) acc\n                     (reverse\
    \ acc))\n               (if (evenp? acc) (sort_helper l (cdr acc))\n         \
    \            (sort_helper (cdr l) (cons (car l) acc))))]\n          [(odd? x)\
    \ (cond\n                     [(null? (cdr x)) x\n                       (evenp?\
    \ (car x)) (cdr x)]\n                     [(even? (car x)) (cond\n           \
    \                                [(null? (cdr x)) (cdr x)\n                  \
    \                          (odd? (car x))\n                                  \
    \          (cdr (cdr x))]\n                                           [(even?\
    \ (car x)) (cdr (cdr x))\n                                            (even? (car\
    \ x))\n                                            (cdr (cdr x))]\n          \
    \                                 [(odd? (car x)) (cdr (cdr x))\n            \
    \                                (cdr (cdr x))\n                             \
    \               (even? (car x))\n                                            (cdr\
    \ (cdr x))]\n                                           [(odd? (car x)) (cdr (cdr\
    \ x))\n                                            (cdr (cdr x))\n           \
    \                                 (odd? (car x))\n                           \
    \                 (even? (car x))\n                                          \
    \  (even? (car x))])]\n         [(even? x) (cond\n                     [(null?\
    \ (cdr x)) x\n                       (odd? (car x)) (cdr x)]\n               \
    \      [(odd? (car x)) (cond\n                                         [(null?\
    \ (cdr x)) (cdr x)\n                                           (even? (car x))\n\
    \                                           (cdr (cdr x))]\n                 \
    \                        [(even? (car x)) (cdr (cdr x))\n                    \
    \                       (odd? (car x))\n                                     \
    \      (even? (car x))\n                                           (even? (car\
    \ x))]\n                                         [(odd? (car x)) (cdr (cdr x))\n\
    \                                           (even? (car x))\n                \
    \                           (even? (car x))\n                                \
    \           (odd? (car x))])]\n         [else (error \"Not a valid input.\")]))]\n\
    \    (sort_helper array (list))))\n</code>\n<|/ a |>\n<| c |>\nHi , thank you\
    \ for taking time to answer my question. I'm new to stackoverflow, where can I\
    \ find the documentation where I can share code with others?\n<|/ c |>\n<| c |>\n\
    , Hi, I think you mean the documentation for Racket", "  (if (empty? array)\n\
    \      (list)\n      (cons (car array)\n            (sort_array (sort_array (cdr\
    \ array)))\n            (list (car array)\n                   (sub1 (car array))\n\
    \                   (sub1 (sub1 (car array))\n                   (sub1 (sub1 (sub1\
    \ (car array)))))\n            (sort_array (sort_array (cdr array))))))\n", " \
    \ (if (< (length (cdr array)) 2)\n      (sort-odd (cdr array))\n      (sort-even\
    \ (cdr array))))\n", "  (if (null? array) '()\n      (if (odd? sum (first array)\
    \ (rest array))\n          (cons first (sort_array (rest array)))\n          (cons\
    \ (first array) (sort_array (rest array)))))) ; #lang racket\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nYour code is not equivalent to the one in the question.  As a matter\
    \ of fact, the question asks to sort the list in the ascending order if the sum\
    \ of the first elements of the list is odd or reverse it in the descending order\
    \ if the sum of the first elements of the list is even.\n<|/ c |>\n<| c |>\nYou\
    \ are right. I misread the question and answered only what was asked.\n<|/ c |>\n\
    <| a |>\n<code>", "  (corkt (car (sort_array (cdr array))) (cadr array) (caddr\
    \ array)))\n", "  (if (< (length array) 2)\n      (list (first array)\n      \
    \      (second array))\n      (if (even? (+ (first array) (second array)))\n \
    \         (sort_array (sort_array (sort_list (append (reverse array) (list (first\
    \ array) (second array)))) ))\n          (sort_array (sort_array (sort_list (append\
    \ (reverse array) (list (first array) (second array)))) ))))\n", "  (if (null?\
    \ array)\n      array\n      (let ([sum (+ (first array) last)])\n        (if\
    \ (even? sum)\n            (sort_array (list last array))\n            (sort_array\
    \ (list first array))))))\n", "  (define (corkt array)\n    (let loop ([i 0] [a\
    \ array] [c 0])\n      (cond\n        [(empty? a) (list c)]\n        [(= 0 (cdr\
    \ a)) (loop (+ i 1) a c)]\n        [else (loop (+ i 1) (cdr a) (+ c 1))]))))\n\
    \  (corkt array))\n", "  (let ((sum (reduce + (range (length array)))))\n    (cond\
    \ ((= (modulo sum 2) 1)\n           (cons (sort array (lambda (x y) (> (first\
    \ x) (first y)))\n                  (lambda (x y) (< (first x) (first y)))))\n\
    \          ((= (modulo sum 2) 0)\n           (cons (sort array (lambda (x y) (<\
    \ (first x) (first y)))\n                  (lambda (x y) (> (first x) (first y)))))))))\n\
    </code>\n<|/ a |>\n<| a tags=scheme,racket,sorting,functional-programming |>\n\
    This should work:\n<code>", "  (if (null? array)\n      '()\n      (let ([sum\
    \ (+ (car array) (cadr array))]\n            [rest '()\n             pivot (car\
    \ array)\n             ]\n            [i (car array)]\n            [m (cadr array)])\n\
    \        (if (odd? sum)\n            (sort_array (append rest (list pivot)))\n\
    \            (sort_array (append rest (list m)))))\n          (append array (sort\
    \ sort (sort array))))))\n", "  (cond\n    [(null? array) (list array)]\n    [(equal?\
    \ (first array) (last (rest array))) (sort_array (rest array))]\n    [else (append\
    \ (sort_array (sub1 array))\n                   (list (first array) (rem (last\
    \ array) (first array)))\n                   (sort_array (sub1 array)))]))\n",
  "  (let ([x (first array)\n        y (second array)])\n    (if (or (null? array)\
    \ (< x y))\n        (list x y)\n        (let ([(sum (first array) (second array))\n\
    \                (min (first array) (second array))\n                (max (first\
    \ array) (second array)])\n          (if (< sum odd)\n              (let ([(sum\
    \ (first array) (second array))\n                      (min (first array) (second\
    \ array))\n                      (max (first array) (second array)])\n       \
    \             (if (< sum odd)\n                        (sort (cons x y) odd-even)\n\
    \                        (sort (cons x y) even-odd))\n                    (sort\
    \ (cons x y) odd))\n              (sort (cons x y) even)))))) \n", "  (cond\n\
    \    [(empty? array) empty]\n    [(zero? (first array)) (cons (first array) (reverse\
    \ (sort_array (rest array))))]\n    [(odd? (first array)) (cons (first array)\
    \ (sort_array (rest array)))]\n    [else (cons (first array) (sort_array (rest\
    \ array)))]))\n", "  (cond\n    [(null? array) '()]\n    [(odd? 0 (+ (car array)\
    \ (cdr array))) '(+ (car array) (cdr array))]\n    [(even? (+ (car array) (cdr\
    \ array))) '(sort (cdr (cdr array)))]\n    [else '(sort (cdr array))]))\n", " \
    \ (cond\n    [(empty? array) (list array)]\n    [(odd? (apply + first array))\
    \ (sort_array (rest array))]\n    [else (sort_array (cons (apply max array) (first\
    \ array)))]))\n", "  (if (null? array)\n      (list)\n      (cons ((car array)\
    \ (sort_array (cdr array))) (sort_sum (sort_sum (car array) (car array)) (sort_sum\
    \ (cdr array) (car array)))))\n  )\n", "  (if (null? array)\n      '()\n     \
    \ (begin\n      (let* ((sum (apply + array))\n             (first (first array))\n\
    \             (last (last array))\n             (odd (modulo sum 2))\n       \
    \      (even (modulo sum 4)))\n        (cond\n          ((equal? odd even)\n \
    \          (begin (sort-array (append (list last) array)) (sort (append (list\
    \ first) array))))\n          ((equal? odd (not even))\n           (begin (sort-array\
    \ (append (list first) array)) (sort (append (list last) array))))\n         \
    \ ((equal? even (not odd))\n           (begin (sort-array (append (list first)\
    \ array)) (sort (append (list last) array))))\n          (else (begin (sort-array\
    \ (append (list first) array)) (sort-array (append (list last) array)))))))\n\
    \        (sort-array (sort array))))))\n", "  (let ([sum (apply + array)])\n \
    \   (cond [(even? sum) (sort_array (sort_array array))]\n          [(odd? sum)\
    \ (sort_array (sort_array (reverse array)))]\n          [else array])))", "  (let\
    \ loop ((acc '())\n             (array array))\n    (cond ((null? array) acc)\n\
    \          ((oddp (- (car array) (car (cdr array)))) (reverse acc (cons (car array)\
    \ acc)))\n          ((evenp (- (car array) (car (cdr array)))) (reverse acc (cons\
    \ (car array) acc)))\n          (else (loop (cons (car array) acc)\n         \
    \              (cdr array)))))\n  ", "  (define (helper array result)\n    (if\
    \ (null? array)\n        (reverse result)\n        (helper (cdr array) (cons (car\
    \ array) result))))\n  (helper (reverse array) (list )))\n</cell>\n<code language=racket-tutorial>",
  "  (let* ((sum (+ 0 (apply + array)))\n         (odd (if (even? sum) (1) (-1)))\n\
    \         (index (car (reverse array)))\n         (values (cdr (reverse array)))\n\
    \         (result (list array))\n         (i (length array))\n         (item (car\
    \ array))\n         (sum-item (+ (car values) item))\n         (next-index (+\
    \ i 1))\n         (prev-index (- i 1)))\n    (if (odd? sum-item )\n        (begin\n\
    \          (set! item (max (item (cdr values)) item))\n          (set! sum-item\
    \ (+ sum (car values)))\n          (set! index (car values))\n          (set!\
    \ values (cdr values)))\n        (begin\n          (set! item (min (car values)\
    \ item))\n          (set! sum-item (+ sum (car values)))\n          (set! index\
    \ (car values))\n          (set! values (cdr values)))\n        (begin\n     \
    \     (set! result (cons (car values) (sort_array (cdr array))))\n          (set!\
    \ item (car array))\n          (set! sum-item (car values))\n          (set! index\
    \ (car values))\n          (set! values (cdr values))))\n    (begin\n      (set!\
    \ result (cons (car values) (sort_array (cdr array))))\n      (set! item (car\
    \ array))\n      (set! sum-item (car values))\n      (set! index (car values))\n\
    \      (set! values (cdr values)))))\n", "  (if (null? array)\n      '()\n   \
    \   (let ((sum (car array))\n            (index (cdr array))\n            (arr\
    \ (sort-array (cons sum index))))\n        (if (odd? sum)\n            (cons sum\
    \ (cons index arr))\n            (cons index (cons sum (sort arr)))))))\n", " \
    \ (if (null? array)\n      array\n      (if (even? (sum-last-index (first array)\
    \ (last-index array)))\n          (sort (sort (list (first array)) (sort (list\
    \ (last-index array)) (< ))) (< ))\n          (sort (sort (list (first array))\
    \ (sort (list (last-index array)) (> ))) (> ))))))\n", "  (let ((l (length array)))\n\
    \    (if (zero? l)\n        (list array)\n        (let ((sum (+ 0 (list-ref array\
    \ l))) (index 0))\n          (corkt (make-corkt sum (list-ref array (sub1 index))\
    \ (sub1 index))))))\n)\n", "  (sort-array-helper array (length array) 0))\n",
  "  (sort (cons 'car (cons 'cdr (sort array (lambda (x y)\n                     \
    \                             (let ([a (+ x y)])\n                           \
    \                         (if (odd? a)\n                                     \
    \                   (cons (car a) (cadr a))\n                                \
    \                      (cdr a)))))\n                          (car array))) '<))\n",
  "  (if (null? array)\n      '()\n      (let ([result (sort (list array) (\u03BB\
    \ (x y) (if (odd? (+ x y)) (- x y) (+ x y)))) ; sort the array using sort\n  \
    \          (index (- 0 (array-length result))) ; get the last index\n        \
    \    (c (lambda (j i)\n                  (if (< i index)\n                   \
    \   i\n                      (if (< j index)\n                          j\n  \
    \                        (if (= j index) (- i i)))) ; find index of the minimum\
    \ element in the array\n                  (array-ref result j (c (+ i 1) index)))\
    \ ; get the min element at that index\n              (array-ref result index (c\
    \ (+ index 1) index)))) ; get the min element in the last index\n        (if (<\
    \ (- index (array-length result)) (array-length result)) ; if the last index is\
    \ smaller than the length of sorted list\n            (cons index (sort_array\
    \ (sub1 result index)))\n            (cons (c (+ index 1) index) (sort_array (sub1\
    \ result index))))))\n", "  (define (helper array acc index)\n    (cond\n    \
    \  [(null? array) (cons index acc)]\n      [(even? (car array)) (helper (cdr array)\
    \ (cdr acc) (cdr index))]\n      [else (helper (cdr array) (cdr acc) (cdr index))]\n\
    \    ))\n  (helper array '() 0))\n", "  (let loop ((arr (car array)) (sorted (list\
    \ arr)) (cur (car arr)))\n    (if (null? arr)\n        sorted\n        (loop (cdr\
    \ arr) (cons (car arr) sorted) (+ cur (car arr))))))\n", "  (cond\n    ((empty?\
    \ array) (error \"Cannot sort an empty list\"))\n    ((odd? (car array) (cdr array))\
    \ (cons (car array) (sort_array (cdr array))))\n    ((even? (car array) (cdr array))\
    \ (cons (car array) (sort_array (cdr array))))\n    (else (sort_array (cdr array)))))\n",
  "  (if (null? array)\n      (list array)\n      \n      (let ([first_index (first\
    \ array)])\n        (let ([last_index (last array)])\n          (let ([sum (+\
    \ first_index last_index)])\n            (if (even? sum)\n                (let\
    \ ([array_copy (cons first_index array)])\n                  (sort_array array_copy)\n\
    \                  (cons (last array_copy) array_copy)\n                )\n  \
    \              (let ([array_copy (cons last_index array)])\n                 \
    \ (sort_array array_copy)\n                  (cons (first array_copy) array_copy)\n\
    \                )\n            )\n          )\n        )\n      )\n  )\n)\n",
  "  (cond\n    [(null? array) '()]\n    [(null? (cdr array)) (car array)]\n    [else\
    \ (cond\n          [(odd-sum? array) (sort (sort_array (cdr array)) (lambda (x\
    \ y) (if (> (cdr array) y) (caddr array) (caddr array)))]\n          [(even-sum?\
    \ array) (sort (sort_array (cdr array)) (lambda (x y) (if (< (cdr array) y) (caddr\
    \ array) (caddr array)))])]\n    )]))\n", "  (define (helper array prev-sum-prev-sum)\n\
    \    (if (null? (cdr array))\n        (list prev-sum-prev-sum)\n        (let ([value\
    \ (first array)])\n          (if (even? (+ prev-sum-prev-sum value))\n       \
    \       (helper (cdr array) (+ prev-sum-prev-sum value))\n              (helper\
    \ (cdr array) value))))\n  (if (even? (+ 0 (length array)))\n      (helper array\
    \ 0)\n      (helper (reverse array) (+ (length array) 1)))\n  (reverse (sort (sort_list\
    \ (reverse array))))\n  )\n", "  (if (null? (car array))\n      (list )\n    \
    \  (sort (sort_array (cdr array)) (lambda (x y)\n                            \
    \     (if (even? (+ x y)) (- y x) (- x y)))\n             :key (lambda (x)\n \
    \                   (let ((sum (+ x y)))\n                      (cond ((= sum\
    \ 0) (list x))\n                            ((even? sum) (list y))\n         \
    \                   (else (list x)))))))\n", "  (cond\n    [(empty? array) '()]\n\
    \    [(= (length array) 0) '()]\n    [(even? (sum (car array) (last-index-value\
    \ (length array)))) (list car array)]\n    [(odd? (sum (car array) (last-index-value\
    \ (length array))))\n    (list car array (sort_array (rest array)))]))\n", " \
    \ (if (or (null? (length array))\n          (null? (cdr array)))\n      (cdr array)\n\
    \      (let ((sorted (append (car array)\n                            (sort (sort_array\
    \ (cdr array))\n                                  (lambda (x y)\n            \
    \                        (if (even? (+ x y))\n                               \
    \         (- x y)\n                                        (- y x))))))\n    \
    \        (even (length array)))\n        (if (even? (length array))\n        \
    \    (reverse sorted)\n            sorted))))\n", "  (let ([sum (+ 0 (apply +\
    \ array))])\n    (cond\n      [(odd? sum) (corkt array sum (car array) (apply\
    \ + array))\n       (even? sum) (corkt array sum (apply + array) (car array))]))))\n",
  "  (check-type array list)\n  (define (make-corkt array)\n    (define (helper left\
    \ right)\n      (if (< (car right) (car left))\n          (cons left (cons (car\
    \ right) right))\n          (cons (car left) (cons right left))))\n    (corkt\
    \ (helper array (corkt (helper array (corkt array '())) '()))))\n  (corkt array\
    \ '()))\n", "  (let ([even-indices (filter even? array)]\n        [odd-indices\
    \ (filter odd? array)])\n    (if (or (empty? even-indices) (empty? odd-indices))\n\
    \        (reverse array)\n        (if (odd? (first even-indices))\n          \
    \  (append (sort-array even-indices)\n                    (cons (first odd-indices)\n\
    \                          (sort-array odd-indices)))\n            (append (cons\
    \ (first even-indices)\n                          (sort-array even-indices))\n\
    \                    (sort-array odd-indices))))))\n", "  (if (= (length (cdr\
    \ array)) 0)\n      (list (car array))\n      (sort_array (corkt (cddr array)\
    \ (car array) (car array))))) ;#lang racket\n", "  (if (null? array)\n      '()\n\
    \      (if (even? (rest array))\n          (sort_array (sort_array (rest array)))\
    \ \n          (sort_array (sort_array (append (rest array) (list 0))))))) ; descending\
    \ order", "  (if (null? array)\n      (list '())\n      (sort (append (first array)\
    \ (last array) (append (sort_array (drop 1 array)) (sort_array (drop 1 array)))\
    \ ) <)))\n", "  (corkt (cdr array)\n          (lambda (a b) (if (odd? (+ a b))\
    \ (list a b) (list b a))))\n  )\n", "  (let ([len (length array)])\n    (cond\n\
    \      [(= len 0)\n       (list array)]\n      [else (define first (car array))\n\
    \           (define last ((cadr array))\n           (cond\n             [(= (modulo\
    \ first last) 0)\n              (sort_array (list last (car array)))]\n      \
    \       [(= (modulo first last) 1)\n              (sort_array (list first (car\
    \ array) (sort_array (list last (car array))))]\n             [(= (modulo first\
    \ last) 2)\n              (sort_array (list first (car array) (sort_array (list\
    \ last (car array)) (sort_array (list first (car array))))])]\n             [else\
    \ (sort_array (list first (car array)))]\n           ))]]))\n", "  (let helper\
    \ ((a array) (t 0))\n    (cond ((null? a) (list t))\n          ((odd? (caar a))\
    \ (append (list (car a)) (helper (cdr a) (add1 t)))\n            (even? (cdar\
    \ a)) (append (list (car a)) (helper (cdr a) (sub1 t))))\n          (else (helper\
    \ (cdr a) t))))))\n", "  (if (null? array)\n      '()\n      (let ((acc (sort\
    \ (first array) (sort (last array) (lambda (x) (- x acc))))))\n        (if (even?\
    \ (+ acc array))\n            (cons (first array) (sort_array (cons (last array)\
    \ acc)))\n            (cons (first array) (sort_array (cons (first array) acc)))))))\n",
  "  (if (empty? array)\n      (list array)\n      (if (even? (first array))\n   \
    \       (append (sort_array (sort (sub1 array 1) (sort (sub1 array (length array))\
    \ #>))\n                    (sort_array (sort (sub1 array (length array)) #<)))\n\
    \          (append (sort_array (sort (sub1 array 1) #>)\n                    (sort_array\
    \ (sort (sub1 array (length array)) #<))))))\n  ;; Note the return value is a\
    \ list containing both the original array and the\n  ;; sorted array.\n  ;; In\
    \ other words, a list containing the same elements as the input list,\n  ;; but\
    \ the original list has been sorted.\n)\n", "  (cond\n    [(empty? array) empty]\n\
    \    [(null? (rest array)) (cons (first array) array)]\n    [else (cons (first\
    \ array)\n                (sort_array (sort_array (rest array))))]))\n", "  (let\
    \ helper ((array array) (sum 0)\n              (len 0))\n    (cond [(= len 0)\n\
    \           (cons (first array) \n                  (sort_array (rest array)))]\n\
    \          [(even? sum)\n           (helper (rest array)\n                   sum\
    \ (+ len 1))]\n          [(odd? sum)\n           (helper (rest array)\n      \
    \             (- sum 1)\n                   (+ len 1))]\n          [else \n  \
    \         (helper (rest array)\n                   (+ sum first)\n           \
    \        (+ len 1))]))\n</code>\n<|/ a tags=arrays,recursion,racket dscore=0 |>\n\
    <| c |>\nThank you for your answer. Can you explain me what are the helper variables?\
    \ The recursive calls are `helper ...` but I don't understand what does it do.\
    \ Thank you in advance.\n<|/ c |>\n<| c |>\nThe helper variables are used solely\
    \ to carry out the following calculations: `sum`, `len`, then return `sum` to\
    \ the next call.  I personally prefer the use of `let` when implementing recursion,\
    \ as it makes the code clearer, and is also easier to read.\n<|/ c |>\n<| c |>\n\
    I updated my answer using your solution, hope that helps.\n<|/ c |>\n<| c |>\n\
    I added a small example to my original question to clarify things. Thanks.\n<|/\
    \ c |>\n<| c |>\nYour solution does not produce the desired output for the example.\
    \ My solution does return `0 1 2 3 4 5` for the first example, but `6 5 4 3 2\
    \ 1 0` for the second example.\n<|/ c |>\n<| a tags=arrays,recursion,racket |>\n\
    <code>", "  (let ([sum (fold + (car array) (cdr array))])\n    (cond\n      [(=\
    \ sum (/ sum 2)) (car array)]\n      [(= sum (/ sum 3)) (list-sort (sort (list-sort\
    \ (sort array))))]\n      [(= sum (/ sum 4)) (list-sort (sort (list-sort (sort\
    \ (sort array))))]\n      [(= sum (/ sum 5)) (list-sort (sort (list-sort (sort\
    \ (sort array))))]\n      [(= sum (/ sum 6)) (list-sort (sort (list-sort (sort\
    \ (sort (sort array))))))]\n      [(= sum (/ sum 7)) (list-sort (sort (list-sort\
    \ (sort (sort (sort (sort array))))))]\n      [(= sum (/ sum 8)) (list-sort (sort\
    \ (list-sort (sort (sort (sort (sort array))))))]\n      [(= sum (/ sum 9)) (list-sort\
    \ (sort (list-sort (sort (sort (sort (sort array))))))]\n      [(= sum (/ sum\
    \ 10)) (list-sort (sort (list-sort (sort (sort (sort (sort array))))))]\n    \
    \  [(= sum (/ sum 11)) (list-sort (sort (list-sort (sort (sort (sort (sort (sort\
    \ array)))))))]\n      [(= sum (/ sum 12)) (list-sort (sort (list-sort (sort (sort\
    \ (sort (sort (sort array)))))))]\n      [(= sum (/ sum 13)) (list-sort (sort\
    \ (list-sort (sort (sort (sort (sort (sort array)))))))]\n      [(= sum (/ sum\
    \ 14)) (list-sort (sort (list-sort (sort (sort (sort (sort (sort (sort array)))))))]\n\
    \      [(= sum (/ sum 15)) (list-sort (sort (list-sort (sort (sort (sort (sort\
    \ (sort (sort (sort array)))))))) 1]\n      [(= sum (/ sum 16)) (list-sort (sort\
    \ (list-sort (sort (sort (sort (sort (sort (sort (sort array)))))))) 1]\n    \
    \  [(= sum (/ sum 17)) (list-sort (sort (list-sort (sort (sort (sort (sort (sort\
    \ (sort (sort (sort array)))))))) 1)]\n      [(= sum (/ sum 18)) (list-sort (sort\
    \ (list-sort ", "  (if (null? array)\n      array\n      (let ((sum (+ (first\
    \ array) (last array))))\n        (cond\n          ((< sum 0) (sort_array (sort\
    \ (cons (first array) array) <))\n          ((> sum 0) (sort_array (sort (cons\
    \ (last array) array) >))\n          (else\n           (sort_array (sort (cons\
    \ (first array) (cons (last array) array)))))\n         )\n      )\n    )\n)\n",
  "  (if (empty? array)\n      (list empty)\n      (if (even? (sum (first array) (last\
    \ array)))\n          (list reverse (sort_array (sort (sort array (lambda (x)\
    \ (- x 6)))))\n          (list (sort_array (sort (sort array (lambda (x) (+ x\
    \ 6)))))\n            (sort_array (sort (sort array (lambda (x) (- x 6)))))))))\n",
  "  (cond [(null? array) (list array)]\n        [(even? (rest array)) (list (sort_array\
    \ (rest array)) (first array) (last array))]\n        [(odd? (rest array)) (list\
    \ (last array) (rest array) (first array))]\n        [else (sort_array (rest array))]\n\
    \        ))\n", "  (sort (lambda (x y)\n          (if (oddp (+ x y))\n       \
    \       (- x y)\n              (+ x y))) array))", "  (if (null? array)\n    \
    \  '()\n      (let ([sum (reduce + array)])\n        (cond\n          [(even?\
    \ sum) (list array)]\n          [(odd? sum) (sort-array (reverse array))]\n  \
    \        [else (append (list array) (sort-array (reverse array)))])))) ; else\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=sorting,racket,algorithm |>\nAn O(n) sort\
    \ algorithm using tail recursion:\n<code>", "  (let loop ((arr array) (result\
    \ '()))\n    (cond\n      [(null? arr) result]\n      [(zero? car arr) result]\n\
    \      [else\n      (loop (cdr arr) (append result (cons (car arr) (sort_array\
    \ (cdr arr))))]\n      )))\n", "  (let loop ((array array) (result '()))\n   \
    \ (cond\n      [(null? array) (result '())]\n      [(even? (cadr array)) (loop\
    \ (cddr array) (cons (car array) result))]\n      [(odd? (cadr array)) (loop (cddr\
    \ array) (cons (car array) (append result (list (cadr array))))]])))\n", "  (corkt\
    \ '(0 1 2 3 4 5) array (list 4 2)))", "  (corkt array\n          (lambda (x) (lambda\
    \ (y) (< x y))\n                      (lambda (y) (> x y)))))\n", "  (cond\n \
    \   [(empty? array) (list array)]\n    [(equal? (first array) (last array)) (sort\
    \ (cons (first array) (sort_array (next array))))]\n    [else (cons (first array)\
    \ (sort_array (next array)))]))\n", "  (if (empty? array)\n      (list)\n    \
    \  (cons (sort (first array) (car (last array)) (lambda (x) (< (first array) (second\
    \ x))) (lambda (x) (> (first array) (second x))) (list (first array) (second array))\
    \ (sort_array (cdr array)))))\n", "  (define (helper array first)\n    (define\
    \ (helper array first first)\n      (if (null? array) \n          (list first)\n\
    \          (if (even? (+ (car array) first))\n              (helper (cdr array)\
    \ (+ first 1) first)\n              (helper (cdr array) (+ first -1) (+ first\
    \ 1)))))\n    (helper array (car array) (car array)))\n  (helper array 0 (car\
    \ array)))\n", "  (if (null? array)\n      (list array)\n      (append (sort (sub1\
    \ array))\n              (sort_array (sub1 array)))))\n", "  (define (sort_helper\
    \ arr)\n    (cond\n      [(empty? arr) empty]\n      [(even? (first arr)) (cons\
    \ (first arr) (sort_helper (rest arr)))]\n      [(odd? (first arr)) (cons (first\
    \ arr) (sort_helper (rest arr)))]\n      [else (sort_helper (rest arr))]))\n \
    \ (sort_helper array))\n", "  (if (null? array)\n      (list nil)\n      (let*\
    \ ((sum (apply + array))\n             (first (car array))\n             (last\
    \ (cdr array)))\n        (cond\n          [(odd? sum) (cons first sort_array last)]\n\
    \          [(even? sum) (cons last sort_array first)]\n          [else (cons first\
    \ sort_array last)])))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
