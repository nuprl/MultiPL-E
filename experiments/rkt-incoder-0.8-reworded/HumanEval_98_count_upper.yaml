name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; >>> (count_upper \"aBCdEf\")\n;; 1\n;; >>>\
  \ (count_upper \"abcdefg\")\n;; 0\n;; >>> (count_upper \"dBBE\")\n;; 0\n(define\
  \ (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (count (lambda (x) (char=? (char-code x) 'A)) s))\n", "  (local ((define\
    \ (count-upper-aux\n                 s\n                 count)\n            \
    \   (cond [(empty? s) count]\n                     [else (if (char=? (first s)\
    \ (first (char-after s))\n                                      'u) (count-upper-aux\
    \ (rest s)\n                                                           count +\
    \ 1) count)])))\n    (count-upper-aux s 0))\n  ;; end-of-recursion\n  (define\
    \ (count-upper-aux\n          s\n          count)\n    (cond [(empty? s) count]\n\
    \          [else (if (char=? (first s) (first (char-after s))\n              \
    \          'u) (count-upper-aux (rest s) count + 1) count)])))\n", "  (let ([count\
    \  0])\n    (if (empty? s) 0\n      (+ (if (even? (car s))\n             (char->integer\
    \ (car s))\n             0)\n         (if (even? (cdr s))\n             (count_upper\
    \ (cdr s))\n             (+ 1 count)))))\n", "  (let loop ((s s)\n           \
    \  (count 0))\n    (cond [(empty? s) count]\n          [(char-upper? (car s))\n\
    \           (loop (cdr s) (+ count 1))]\n          [else\n           (loop (cdr\
    \ s)\n                 (if (char-upper? (car s)) count 0)))]))\n", "  (cond [(empty?\
    \ s) 0]\n        [(zero? (rem (length s) 2)) 0]\n        [(even? (car s)) (+ 1\
    \ (count_upper (cdr s)))]))\n", "  (cond\n    [(empty? s) 0]\n    [(cons? s)\n\
    \     (if (even? 0) (+ 1 (count_upper (car s))) 0)]\n    [else (count_upper (cdr\
    \ s))]))\n", "  (let loop ((count 0) (s s))\n    (cond ((and char=? (char #\\\
    A) (char #\\z))\n           (if (zero? (modulo (- count 1) 2)) count 0))\n   \
    \       ((char=? (char #\\a) (char #\\e))\n           (loop (add1 count) (rest\
    \ s)))\n          ((char=? (char #\\b) (char #\\e))\n           (loop (add1 count)\
    \ (rest s)))\n          ((char=? (char #\\c) (char #\\e))\n           (loop (add1\
    \ count) (rest s)))\n          ((char=? (char #\\d) (char #\\e))\n           (loop\
    \ (add1 count) (rest s)))\n          ((char=? (char #\\e) (char #\\f))\n     \
    \      (loop (add1 count) (rest s)))\n          ((char=? (char #\\g) (char #\\\
    f))\n           (loop (add1 count) (rest s)))\n          ((char=? (char #\\h)\
    \ (char #\\i))\n           (loop (add1 count) (rest s)))\n          ((char=? (char\
    \ #\\j) (char #\\i))\n           (loop (add1 count) (rest s)))\n          ((char=?\
    \ (char #\\k) (char #\\i))\n           (loop (add1 count) (rest s)))\n       \
    \   ((char=? (char #\\l) (char #\\j))\n           (loop (add1 count) (rest s)))\n\
    \          ((char=? (char #\\m) (char #\\j))\n           (loop (add1 count) (rest\
    \ s)))\n          ((char=? (char #\\n) (char #\\j))\n           (loop (add1 count)\
    \ (rest s)))\n          ((char=? (char #\\o) (char #\\j))\n           (loop (add1\
    \ count) (rest s)))\n          ((char=? (char #\\p) (char #\\j))\n           (loop\
    \ (add1 count) (rest s)))\n          ((char=? (char #\\q) (char #\\j))\n     \
    \      (loop (add1 count) (rest s)))\n          ((char=? (char #\\r) (char #\\\
    j))\n           (loop (add1 count) (rest s)))\n          ((char=? (char #\\s)\
    \ (char #\\j))\n           (loop (add1 count) (rest s)))\n          ((char=? (char\
    \ #\\t) (char #\\j))\n           (loop (add1 count) (re", "  (match s\n    [''()\
    \      0]\n    [(#\\A #\\B)\n     (add1 (count_upper (substring s 0 1)))]\n  \
    \  [else\n     (add1 (count_upper (substring s 0 0)))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (length s)) (sub1 (count (=< #f (char (first s)) char 'a)\
    \ s))]))\n", "  (define (count-upper a b)\n    (cond ((= (length a) 0)\n     \
    \      (if (= b 'a) (+ 1 (length a))\n               (length a)))\n          ((=\
    \ (length a) 0)\n           (length a))\n          ((= (length a) 1)\n       \
    \    (if (= (char b 0) #\\A)\n               (+ 1 (count-upper (substring a 0\
    \ (- a 1) b) 'b))\n               (count-upper (substring a 0 (- a 1) 'b) 'b)))\n\
    \          ((= (char b 0) #\\D)\n           (count-upper (substring a 0 (- a 1)\
    \ b) 'b))\n          (else\n           (+ 1 (count-upper (substring a 0 (- a 1)\
    \ b) 'b)))))\n  (count-upper (substring s 0 0) 'a))\n", "  (if (empty? s)\n  \
    \    0\n      (if (char-? (car s))\n          (if (even? (car s))\n          \
    \    (+ 1 (count_upper (cdr s))))\n              (count_upper (cdr s))))))\n",
  "  (local ((define (count-upper s index count)\n            (cond\n            \
    \  [(zero? (remainder index 2)) #t count]\n              [(string=? (char s index)\
    \ 'A) #t count]\n              [(string=? (char s index) 'a) #t count]\n     \
    \         [else (count-upper (char s index) (add1 index) count)]\n           \
    \   )\n          )\n          )\n      (count-upper (char s 0) 0 0)\n      )\n\
    \  )\n", "  (bigu? (char-code #\\A) (char-code s) #:lowercase #f))\n", "  (count-if\
    \ #(< % 26) #(lambda (c) (= c #\\A)) s))\n", "  (count_up_and_down\n   (remove-all\
    \ #{\\A \\E \\I \\O} s)))\n", "  (cond [(empty? s) 0]\n        [(even? (car s))\
    \ (+ 1 (count_upper (cdr s)))]\n        [else 0]))\n", "  (define (count_vowel\
    \ s index)\n    (cond [(zero? index) 0]\n          [(equal? (char-lower-case (char\
    \ s (+ index (* 2 (modulo index (char-length s))))) (char #\\a) (char-lower-case\
    \ (char s (+ index (* 2 (modulo index (char-length s)))))))\n           (add1\
    \ (count_vowel s (+ index (* 2 (modulo index (char-length s))))))]\n         \
    \ [else (count_vowel s (+ index (* 2 (modulo index (char-length s)))))]))\n  (count_vowel\
    \ s 0))\n", "  (cond\n    ((empty? s) 0)\n    ((even? (car s)) (+ 1 (count_upper\
    \ (cdr s))))\n    (else (count_upper (cdr s)))))\n", "  (cond\n    [(null? s)\
    \ 0]\n    [(member (char-code (first s)) (list 'a 'b 'c 'd 'e 'f 'g)) (+ 1 (count_upper\
    \ (rest s)))]\n    [else 0]))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is more\
    \ or less what I'd have suggested. Note that it still has `null?`, which is a\
    \ bit of an oversight, since you could have used `memq` instead of `member`.\n\
    <|/ c |>\n<| c |>\nHa, yeah, I noticed that and went back and edited the answer.\
    \ Thanks for the suggestions.\n<|/ c |>\n<| c |>\n`memq` is better. Also, you\
    \ don't need `count-upper` at all. `count-upper` should be `count-vowels`. But\
    \ if you like `count-vowels`, then use `memq`. `count-vowels` has `null?` which\
    \ makes it better to use. `count-vowels` has `memq` which makes it better to use.\n\
    <|/ c |>\n<| c |>\nYeah, good points. I should also note that the code sample\
    \ in the original post was written in a very literal sense, without much refactoring.\
    \ I just wanted to point out how the code could be refactored quite a bit to make\
    \ the intent clearer. Also, I wanted to emphasize that `count-upper` could be\
    \ refactored further. Good catch!\n<|/ c |>\n<| a tags=racket,scheme |>\nIn case\
    \ you haven't thought of it yet, here is a more Racket idiomatic version:\n<code>",
  "  (loop\n     for i from 0\n     for c across s\n     for vowel? (char-is-vowel\
    \ c)\n     when (or (zero? i) vowel?)\n     sum 1))\n", "  (let loop ((s s)\n\
    \             (a 0)\n             (vowels '(#\\A #\\E #\\I #\\O #\\U))\n     \
    \        (i 0))\n    (cond\n      [(null? s) 0]\n      [(member vowels s)\n  \
    \     (loop (rest s)\n             (add1 a)\n             vowels\n           \
    \  (add1 i))]\n      [(even? i) (loop (rest s) (add1 a) vowels (add1 i))]\n  \
    \    [else a]))))\n", "  (cond\n    [(empty? s) 0]\n    [(empty? (rest s)) 0]\n\
    \    [(not (even? (length s))) 0]\n    [(equal? (char-code (first (first s)) 'a')\
    \ 65) (add1 0)]\n    [else (add1 (count_upper (rest s)))]))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks! Could you tell me what's the difference between `count-odd?`\
    \ vs `count-even?`? I understand the logic behind them but don't understand why\
    \ some people use `count-odd?` and `count-even?` interchangeably.\n<|/ c |>\n\
    <| c |>\n: `count-even?` is true when an even number of non-vowel letters is present.\
    \ `count-odd?` is true when an odd number of non-vowel letters is present. This\
    \ implementation counts every non-vowel letter. So a positive number will correspond\
    \ to one vowel. An even number of vowels will correspond to two vowels, and an\
    \ odd number of vowels will correspond to one vowel.\n<|/ c |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\n<code>", "  (cond\n    [(empty? s) 0]\n    [(even? (car s))\n      (cond\n\
    \        [(= (length (string->list s)) 2)\n          (cond\n            [(string=?\
    \ (string->char (car s)) (string->char #\\a)) (+ 1 2)]\n            [(string=?\
    \ (string->char (car s)) (string->char #\\b)) (+ 1 1)]\n            [(string=?\
    \ (string->char (car s)) (string->char #\\c)) (+ 1 1)]\n            [(string=?\
    \ (string->char (car s)) (string->char #\\d)) (+ 1 1)]\n            [else (+ 1\
    \ 0)])]\n        [else (cond\n             [(string=? (string->char (car s)) (string->char\
    \ #\\e)) (+ 1 2)]\n             [else (cond\n                  [(string=? (string->char\
    \ (car s)) (string->char #\\g)) (+ 1 2)]\n                  [else (cond\n    \
    \                   [(string=? (string->char (car s)) (string->char #\\h)) (+\
    \ 1 1)]\n                       [else (cond\n                             [(string=?\
    \ (string->char (car s)) (string->char #\\i)) (+ 1 1)]\n                     \
    \        [else (cond\n                                    [(string=? (string->char\
    \ (car s)) (string->char #\\j)) (+ 1 1)]\n                                   \
    \ [else (cond\n                                           [(string=? (string->char\
    \ (car s)) (string->char #\\k)) (+ 1 2)]\n                                   \
    \        [else (cond\n                                                    [(string=?\
    \ (string->char (car s)) (string->char #\\l)) (+ 1 2)]\n                     \
    \                               [else (cond\n                                \
    \                           [(string=? (string->char (car s)) (string->char #\\\
    m)) (+ 1 1)]\n                                                           [else\
    \ (cond\n                                                                    [(string=?\
    \ (string->char (car s)) (string->char #\\n)) (+ 1 1)]\n                     \
    \                                               [else (cond\n                \
    \                                                           [(string=? (string->char\
    \ (car s)) (string->char #\\o)) (+ 1 1)]\n                                   \
    \                                        [else (cond\n                       \
    \                                                             [(string=? (string->char\
    \ (car s)) (string->char #\\p)) (+ 1 1)]\n                                   \
    \                                                 [else (cond\n              \
    \                                                             [(string=? (string->char\
    \ (car s)) (string->char #\\r)) (+ ", "  (cond\n    ((null? s)0)\n    ((even?\
    \ (length s)) 0)\n    ((char=? (car s) #\\A) 0)\n    ((char=? (car s) #\\O) 1)\n\
    \    ((char=? (car s) #\\U) 2)\n    ((char=? (car s) #\\E) 2)\n    ((char=? (car\
    \ s) #\\E) 2)\n    ((char=? (car s) #\\I) 2)\n    ((char=? (car s) #\\O) 3)\n\
    \    ((char=? (car s) #\\U) 3)\n    ((char=? (car s) #\\E) 3)\n    ((char=? (car\
    \ s) #\\I) 3)\n    ((char=? (car s) #\\Y) 3)\n    ((char=? (car s) #\\a) 4)\n\
    \    ((char=? (car s) #\\e) 4)\n    ((char=? (car s) #\\i) 4)\n    ((char=? (car\
    \ s) #\\o) 4)\n    ((char=? (car s) #\\u) 4)\n    ((char=? (car s) #\\y) 4)\n\
    \    ((char=? (car s) #\\b) 4)\n    ((char=? (car s) #\\t) 4)\n    ((char=? (car\
    \ s) #\\v) 4)\n    ((char=? (car s) #\\p) 4)\n    ((char=? (car s) #\\M) 4)\n\
    \    ((char=? (car s) #\\m) 4)\n    ((char=? (car s) #\\P) 4)\n    ((char=? (car\
    \ s) #\\p) 4)\n    ((char=? (car s) #\\Q) 4)\n    ((char=? (car s) #\\q) 4)\n\
    \    ((char=? (car s) #\\R) 4)\n    ((char=? (car s) #\\r) 4)\n    ((char=? (car\
    \ s) #\\S) 4)\n    ((char=? (car s) #\\s) 4)\n    ((char=? (car s) #\\T) 4)\n\
    \    ((char=? (car s) #\\t) 4)\n    ((char=? (car s) #\\V) 4)\n    ((char=? (car\
    \ s) #\\v) 4)\n    ((char=? (car s) #\\W) 4)\n    ((char=? (car s) #\\w) 4)\n\
    \    ((char=? (car s) #\\X) 4)\n    ((char=? (car s) #\\x) 4)", "  (let ((cnt\
    \ 0))\n    (for ((ii 0) (i (string-length s)) (ii ii))\n      (if (char-upper?\
    \ i s)\n          (set! cnt (inc! cnt))\n          (inc! ii)))))\n", "  (if (empty?\
    \ s) 0)\n  (let ((count 0))\n    (loop\n      (set! count (+ count (equal? (char-code\
    \ (car s)) #\\A)))\n      (cond\n\t((odd? (length s)) (return count))\n\t((even?\
    \ (length s)) (set! count 0))\n\t(else (set! s (cdr s)))\n      )\n    )\n  ))\n",
  "  (count-even 0 (length s) [char=?[A-Z] #t] [char=?[aeiouAEIOU] #f]))\n", "  (cond\n\
    \    ((= (length s) 0) 0)\n    ((char=? s #\\A) 0)\n    ((char=? s #\\a) 0)\n\
    \    ((char=? s #\\O) 0)\n    ((char=? s #\\u) 0)\n    ((char=? s #\\0) 0)\n \
    \   ((char=? s #\\9) 0)\n    ((char=? s #\\B) 0)\n    ((char=? s #\\C) 0)\n  \
    \  ((char=? s #\\d) 0)\n    ((char=? s #\\Z) 0)\n    (else (+ 1 (count_upper (substring\
    \ s 0 (+ 0 (length s)))))))\n", "  (if (null? s)\n      0\n      (if (char-upper?\
    \ (car s))\n          (count_upper (cdr s))\n          (+ (count_upper s) 1))))\n",
  "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) 0]\n    [else (+ 1 (count-vowels\
    \ (substring s 0 2)) (count-vowels (substring s 2 4)) (count-vowels (substring\
    \ s 4 6)))]))\n", "  (let loop ((vowels '(a e i o u)) (s s)\n             (count\
    \ 0))\n    (cond\n      ((null? s) count)\n      (else\n       (cond\n       \
    \  ((or (char-upper? (char-code (first s))) (char-upper? (char-code (first s)))))\n\
    \         (loop (conj vowels c) (drop 1 s) (+ count 1)))\n         (else (loop\
    \ (conj vowels c) s (- count 1))))))))\n", "  (define (aux s index)\n    (cond\n\
    \      [(string? s) (cond (= index 0) (+ 1 (length s)))]\n      [else (aux s (+\
    \ index 2))]))\n  (aux (reverse s) 0))\n", "  (let ((count 0))\n    (for ((i 0\
    \ (+ i 2))) ; Odd indices are even indices\n      (when (= (substring s i) ?A)\n\
    \        (set! count (+ count 1))))))\n", "  (cond\n    [(empty? s)\n     0]\n\
    \    [(even? 0)\n     (if (equal? (char-code (car s)) 65)\n         (+ 1 (count_upper\
    \ (cdr s))))\n     (count_upper (cdr s))]\n    [else\n     (count_upper (cdr s))]))\n",
  "  (let ((result 0))\n    (for ([i (length s)])\n      (if (char=? (char s i) ?A)\n\
    \          (if (char=? (char s i) ?O)\n              (incf result)\n         \
    \     (incf result))\n          (incf result))\n      (if (char=? (char s i) ?A)\n\
    \          (if (char=? (char s i) ?O)\n              (incf result)\n         \
    \     (incf result))\n          (incf result))))\n  result)\n", "  (let* ((count\
    \ 0)\n         (i (string-length s))\n         (char (substring s 0 i))\n    \
    \     (c (char-code char))\n         (vowels (string->list '(\"aeiouAEIOU\")))\n\
    \         (vowels-i (length vowels))\n         (vowels-char (substring vowels\
    \ 0 vowels-i))\n         (vowels-c (char-code vowels-char)))\n    (while i\n \
    \     (when (and (char-code c) vowels-c)\n        (set! count (+ count 1)))\n\
    \      (set! i (+ i 1))\n      (set! char (substring s 0 i))\n      (set! c (char-code\
    \ char))\n      (set! vowels (substring vowels 0 vowels-i))\n      (set! vowels-i\
    \ (length vowels))\n      (set! vowels-char (substring vowels 0 vowels-i))\n \
    \     (set! vowels-c (char-code vowels-char)))))\n", "  (define (helper s count)\n\
    \    (cond\n      [(char-upper? s #\\A) count]\n      [(char-upper? s #\\Z) 0]\n\
    \      [(char-upper? s #\\a) (helper (substring s 2 1) (+ count 1))]\n      [(char-upper?\
    \ s #\\z) (helper (substring s 2 1) count)]\n      [else (helper (substring s\
    \ 1 ) count)]))\n  (helper (string s #\\U) 0))", "  (let* ((i 0)\n         (count\
    \ 0))\n    (do ((i 0 (+ i 2)) (j 0 (+ j 1)))\n        ((< i j)\n         (if (char=?\
    \ s #\\A)\n             (cond\n               ((char=? (+ i 2) #\\a)\n       \
    \         (+ count 1))\n               ((char=? (+ i 2) #\\e)\n              \
    \  (+ count 1))\n               ((char=? (+ i 2) #\\i)\n                (+ count\
    \ 1))\n               ((char=? (+ i 2) #\\o)\n                (+ count 1))\n \
    \              ((char=? (+ i 2) #\\u)\n                (+ count 1))\n        \
    \       ((= i j) #\\space)\n               ((= i j) #\\newline) #\\newline)\n\
    \               (else #\\newline)))))\n    count))\n", "  (let loop ((i 0) (c\
    \ (quote ()))\n             (acc 0))\n    (cond\n      [(zero? i) acc]\n     \
    \ [else\n       (loop (add1 i) (cons (car s) (cadr c)) (add1 acc))]))))\n", " \
    \ (count_up_even (string->list s))\n  )\n", "  (regexp-count\n   [\n    [#\".*[A-Z]\"\
    \ 0]\n    [#\"[^A-Z]\" 0]\n   ]\n   s))\n", "  (cond [(< s #\\a)(0)\n        \
    \ (< s #\\A)(0)\n         (< s #\\b)(0)\n         (< s #\\B)(0)\n         (< s\
    \ #\\c)(0)\n         (< s #\\C)(0)\n         (< s #\\d)(0)\n         (< s #\\\
    D)(0)\n         (< s #\\e)(0)\n         (< s #\\E)(0)\n         (< s #\\f)(0)\n\
    \         (< s #\\F)(0)\n         (< s #\\g)(0)\n         (< s #\\G)(0)\n    \
    \     (< s #\\h)(0)\n         (< s #\\H)(0)\n         (< s #\\i)(0)\n        \
    \ (< s #\\I)(0)\n         (< s #\\j)(0)\n         (< s #\\J)(0)\n         (< s\
    \ #\\k)(0)\n         (< s #\\K)(0)\n         (< s #\\l)(0)\n         (< s #\\\
    L)(0)\n         (< s #\\n)(0)\n         (< s #\\N)(0)\n         (< s #\\o)(0)\n\
    \         (< s #\\O)(0)\n         (< s #\\p)(0)\n         (< s #\\P)(0)\n    \
    \     (< s #\\q)(0)\n         (< s #\\Q)(0)\n         (< s #\\s)(0)\n        \
    \ (< s #\\S)(0)\n         (< s #\\t)(0)\n         (< s #\\T)(0)\n         (< s\
    \ #\\v)(0)\n         (< s #\\V)(0)\n         (< s #\\w)(0)\n         (< s #\\\
    W)(0)\n         (< s #\\x)(0)\n         (< s #\\X)(0)\n         (< s #\\y)(0)\n\
    \         (< s #\\Y)(0)\n         (< s #\\z)(0)\n         (< s #\\Z)(0)\n    \
    \     (< s #\\0)(0)\n         (< s #\\00)(0)\n         (< s #\\0)(0)\n       \
    \  (< s #\\0)(0)\n         (< s #\\0)(0)\n         (< s #\\0)(0)\n         (<\
    \ s #\\0)(0)\n         (< s #\\0)(0)\n         (< s #\\0)(0)\n         (< s #\\\
    0)(0)\n         (< s #\\0)(0)\n         (< s #\\0)(0)\n         (< s #\\0)(0)",
  "  (fold-right (lambda (c acc) \n                 (if (even? acc) \n           \
    \          (if (char=? c 'A) (+ 1 acc) acc)\n                     acc))\n    \
    \         0\n             s))\n", "  (if (< 0 (length s))\n      (+ 0 (length\
    \ s)))\n  (for ([i (in-range (length s)) (mod 2 (length s))])\n    (if (char-upper?\
    \ (char s (+ i 1)))\n        (+ 1 (* (char-upper? (char s (+ i 1))) 2)))))\n",
  "  (cond\n    [(empty? s) 0]\n    [(equal? (first s) #\\a) 1]\n    [(equal? (first\
    \ s) #\\e) 2]\n    [(equal? (first s) #\\i) 3]\n    [(equal? (first s) #\\o) 4]\n\
    \    [else (+ 1 (count_upper (rest s)))]))\n", "  (let loop ((s\n            \
    \   (string->list\n                (substring (s-ref s 0 0))))\n             (c\n\
    \               (string->list\n                (substring (s-ref s 0 0))))\n \
    \            (n\n               (string->list\n                (substring (s-ref\
    \ s 0 0))))\n             (vowels\n               (list->string '(a e i o u)))\n\
    \    (cond [(null? c) (+ 1 (count vowels))]\n          [(null? s) (+ 1 (count\
    \ vowels))]\n          [(string=? (s-ref s 0 0) (list-ref c 0))\n           (loop\
    \ (s-ref s 1 c) (list-ref c 1) n vowels)]\n          [(string=? (s-ref s 0 0)\
    \ (list-ref c 0))\n           (loop (s-ref s 1 c) (list-ref c 1) (s-ref s 1 n)\
    \ vowels)]\n          [(string=? (s-ref s 0 0) (list-ref c 0))\n           (loop\
    \ (s-ref s 1 c) (list-ref c 1) (s-ref s 1 n) vowels)]\n          [(string=? (s-ref\
    \ s 0 0) (list-ref c 0))\n           (loop (s-ref s 1 c) (list-ref c 1) (s-ref\
    \ s 1 n) vowels)]\n          [(string=? (s-ref s 0 0) (list-ref c 0))\n      \
    \     (loop (s-ref s 1 c) (list-ref c 1) (s-ref s 1 n) vowels)]\n          [(string=?\
    \ (s-ref s 0 0) (list-ref c 0))\n           (loop (s-ref s 1 c) (list-ref c 1)\
    \ (s-ref s 1 n) vowels)]\n          [(string=? (s-ref s 0 0) (list-ref c 0))\n\
    \           (loop (s-ref s 1 c) (list-ref c 1) (s-ref s 1 n) vowels)]\n      \
    \    [(string=? (s-ref s 0 0) (list-ref c 0))\n           (loop (s-ref s 1 c)\
    \ (list-ref c 1) (s-ref s 1 n) vowels)]\n          [(string=? (s-ref s 0 0) (list-ref\
    \ c 0))\n           (loop (s-ref s 1 c) (list-ref c 1) (s-ref s 1 n) vowels)]\n\
    \          [(string=? (s-ref s 0 0) (list-ref c 0))\n           (loop (s-ref s\
    \ 1 c) (list-ref c 1) (s-ref s 1 n) vowels)]\n          [(string=? (s-ref s 0\
    \ 0) (list-ref c 0))\n           (loop (s-ref s ", "  (cond\n    [(empty? s) 0]\n\
    \    [(even? (modulo s (length s))) 1]\n    [else 0]))\n", "  (count-vowels s\
    \ #:predicate (lambda (v)\n                                (and (char=? v #\\\
    A) (char=? v #\\a))))\n</code>\n<|/ a dscore=1 tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (count (lambda (c) (= c #\\A)\n                (and (string-ref\
    \  s (car s) #\\V) (= (cadr s) #\\V)))))\n", "  (count\n   (\u03BB (e)\n     (when\
    \ (even? e)\n       (char-upper? (char-code s) e))))\n)\n", "  ; count the vowels\n\
    \  (define (count-vowels s\n                    vowels)\n    (if (null? s)\n \
    \       vowels\n        (count-vowels (rest s)\n                     (cons (car\
    \ s) vowels))))\n\n  (count-vowels s (list #\\a\n                      #\\b\n\
    \                      #\\c\n                      #\\d\n                    \
    \  #\\e\n                      #\\f\n                      #\\g\n            \
    \          #\\h\n                      #\\i\n                      #\\j\n    \
    \                  #\\k\n                      #\\l\n                      #\\\
    m\n                      #\\n\n                      #\\o\n                  \
    \    #\\p\n                      #\\q\n                      #\\r\n          \
    \            #\\s\n                      #\\t\n                      #\\v\n  \
    \                    #\\W\n                      #\\X\n                      #\\\
    Y\n                      #\\Z\n                      #_\n                    \
    \  #a\n                      #b\n                      #c\n                  \
    \    #d\n                      #e\n                      #f\n                \
    \      #g\n                      #h\n                      #i\n              \
    \        #j\n                      #k\n                      #l\n            \
    \          #m\n                      #n\n                      #o\n          \
    \            #p\n                      #q\n                      #r\n        \
    \              #s\n                      #t\n                      #u\n      \
    \                #v\n                      #w\n                      #x\n    \
    \                  #y\n                      #z\n                      #A\n  \
    \                    #B\n                      #C\n                      #D\n\
    \                      #E\n                      #F\n                      #G\n\
    \                      #H\n                      #I\n                      #J\n\
    \                      #K\n                      #L\n                      #M\n\
    \                      #N\n                      #O\n                      #P\n\
    \                      #Q\n                      #R\n                      #S\n\
    \                      #T\n                      #U\n                      #V\n\
    \                      #W\n                      #X\n                      #Y\n\
    \                      #Z\n                      #_))))\n", "  (count-chars s\
    \ #\\A #\\Z #\\a)\n  )\n", "  (define (helper str count) (if (eq? count 0) 0 1))\n\
    \  (reduce helper (for [c s] (if (char=? c #\\U) 1 0)) 0))\n", "  (if (string?\
    \ s)\n      (count (lambda (x)\n              (and (char-upper? (char x)) (not\
    \ (even? x)))\n               s)\n              s))\n      0))\n", "  (count_up_from\
    \ s #{\\a\\b\\c\\d\\e\\f\\g\\h\\j\\k\\l\\m\\n\\p\\q\\r\\s\\v\\y\\z}))\n", "  (cond\
    \ (null? s)\n        0\n        (even? (car s) [a i o u])\n        (count_upper\
    \ (cdr s))\n        :else (+ 1 (count_upper (cdr s)))))", "  (let ((count 0))\n\
    \    (loop for i from 0\n          for c across s\n          when (char-uppercase\
    \ c)\n          when (odd? i)\n          do (set! count (inc! count)))\n    count))\n\
    </code>\n<|/ a |>\n<| c |>\nThis is nice but I don't understand the syntax for\
    \ \"loop\". It's not mentioned in the Racket docs at all. Does it come with some\
    \ specific definition? I'm also not sure how it relates to the other \"for\" constructs.\n\
    <|/ c |>\n<| c |>\n, Racket is a dialect of Scheme, which is (mostly) like Common\
    \ Lisp.  The `loop` construct is a special form of `for` looping through lists.\
    \  In this case it's a list comprehension that uses `char-uppercase` from the\
    \ Racket `unicode` library.  You can read more about it at http://docs.racket-lang.org/reference/lists.html.\
    \  You can read more about Common Lisp syntax at http://www.lispworks.com/documentation/HyperSpec/Body/m_loop.htm.\n\
    <|/ c |>\n<| c |>\nThank you for that. I haven't done Lisp in ages, but I did\
    \ some programming in it at university. :-) I'm still not used to the syntax of\
    \ Scheme. :-(\n<|/ c |>\n<| c |>\n, that's okay.  It's a little confusing.  You\
    \ can read about Racket syntax at http://docs.racket-lang.org/reference/expressions.html#%28form._%28%28lib._racket%2Flist..rkt%29._loop%29%29.\
    \  That syntax is similar to Common Lisp syntax.  Common Lisp also has `for` loops,\
    \ and a lot of languages have it too.  Racket is a dialect of Common Lisp that\
    \ happens to have `for` loops.  It's really the same thing.  Racket is more like\
    \ Common Lisp in some ways.  Racket is more like Common Lisp in some ways.  Racket\
    \ is more like Common Lisp in some ways.  Racket is more like Common Lisp in some\
    \ ways.  Racket is more like Common Lisp in some ways.  Racket is more like Common\
    \ Lisp in some ways.\n<|/ c |>\n<| c |>\n, Racket also has `cond` and `cond->`\
    \ and other control constructs.  `for` is an iteration construct that you can\
    \ use with a list comprehension, just like `cond` and `cond->`.\n<|/ c |>\n",
  "  (cond ((null? s) 0)\n        ((char=? (car s) #\\A) 0)\n        ((char=? (car\
    \ s) #\\U) 0)\n        (else (+ (count_upper (cdr s)) #1)))\n  )\n</code>\nThe\
    \ above code can be written more compact as:\n<code>", "  (cond\n    [(empty?\
    \ s)\n     0]\n    [(= (length s) 2)\n     1]\n    [(even? (car s) #t)\n     (+\
    \ (count_upper s (cdr s)) 1)]\n    [else\n     (count_upper (cdr s))]))\n", " \
    \ (cond\n    [(empty? s) 0]\n    [(equal? (char-code (first s)) 95) 1]\n    [(equal?\
    \ (char-code (first s)) 97) 0]\n    [else (+ 1 (count_upper (rest s)))]))\n",
  "  (let ((vowels '(a e i o u)))\n    (for/fold ([res 0]) ([char s (substring char\
    \ 1 length)]) ; get first character and update starting index\n      (cond (char=?\
    \ char vowels)\n            (res + 1)\n            (char=? (substring char 2 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 3 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 4 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 5 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 6 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 7 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 8 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 9 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 10 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 11 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 12 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 13 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 14 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 15 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 16 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 17 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 18 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 19 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 20 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 21 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 22 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 23 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 24 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 25 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring char 26 length)\
    \ vowels)\n            (+ res 1)\n            (char=? (substring ", "  (if (empty?\
    \ s)\n      0\n      (if (even? (first s))\n          (+ (count (first s) '#\\\
    U) 1)\n          (count_upper (rest s)))))\n", "  (- (string->number s)\n    \
    \ (string->number string->symbol s)))\n", "  (length (filter even?\n         \
    \        (map #(if (char-upper? (char % #{}))\n                           (+ 1\
    \ #{}) #{})\n                       (range 0 #{}) s))))\n", "  (let loop ((s s)\n\
    \             (n 0))\n    (cond\n      [(or (not s) (empty? s)) (expr (cond [(even?\
    \ (- n 2))\n                                              (+ n 1)\n          \
    \                                    (+ n 0)]\n                              \
    \            [(even? n)\n                                              (expr (cond\
    \ [(odd? (- n 2))\n                                                       (+ n\
    \ 0)]\n                                                     [(odd? n)\n      \
    \                                                 (expr (cond [(odd? (+ n 1))\n\
    \                                                                   (+ n 0)]\n\
    \                                                                   [(odd? (+\
    \ n 2))\n                                                                   (+\
    \ n 0)]\n                                                                   [(even?\
    \ (+ n 1))\n                                                                 \
    \  (+ n 0)]\n                                                                \
    \   [(even? (+ n 2))\n                                                       \
    \            (+ n 0)])))])))]\n      [(string=? (car s) \"A\")\n       (expr (cond\
    \ [(even? (- n 1))\n                   (expr (cond [(even? (- n 2))\n        \
    \                        (+ n 0)]\n                             [(even? n)\n \
    \                               (expr (cond [(odd? (- n 1))\n                \
    \                           (+ n 0)]\n                                       \
    \  [(odd? n)\n                                           (expr (cond [(odd? (+\
    \ n 1))\n                                                      (+ n 0)]\n    \
    \                                                 [(odd? (+ n 2))\n          \
    \                                            (+ n 0)]\n                      \
    \                               [(even? (+ n 1))\n                           \
    \                           (+ n 0)]\n                                       \
    \              [(even? (+ n 2))\n                                            \
    \          (+ n 0)])))])))]\n      [(string=? (car s) \"E\")\n       (expr (cond\
    \ [(even? (- n 1))\n                   (expr (cond [(even? (- n 2))\n        \
    \                        (+ n 0)]\n                             [(even? n)\n \
    \                               (expr (cond [(odd? (- n 1))\n                \
    \                           (+ n 0)]\n                                       \
    \  [(odd? n)\n                                           (expr (cond [(odd? (+\
    \ n 1))\n                                                      (+ n 0)]\n    \
    \                                                 [(odd? (+ n 2))\n          \
    \                                            (+ n 0)]\n                      \
    \                               [(even? (+ n 1))\n                           \
    \                           (+ n 0)]\n                                       \
    \              [(even? (+ n 2))\n                                            \
    \          (+ n 0)])))])))]\n      [(string=? (car s) \"I\")\n       (expr (cond\
    \ [(even? (- n 1))\n                   (expr (cond [(even? (- n 2))\n        \
    \                        (+ n 0)]\n                             [(even? n)\n \
    \                               (expr (cond [(odd? (- n 1))\n                \
    \                           (+ n 0)]\n                                       \
    \  [(odd? n)", "  (if (equal? s \"\")\n      0\n      (if (even? (string-length\
    \ s))\n          (if (equal? (string-downcase s) \"A\")\n              1\n   \
    \           0)\n          (count_upper (substring s 0 1)))))\n", "  (define (count-upper\
    \ pos str)\n    (if (zero? pos)\n        (length str)\n        (if (char=? str\
    \ (char #\\A) pos)\n            (+ 1 (count-upper (+ pos 1) str))\n          \
    \  (count-upper (+ pos 1) str)))))\n  (count-upper 0 s))\n", "  (define (count\
    \ pos len)\n    (if (> pos len)\n        0\n        (let ((c (char s pos)))\n\
    \          (if (char-upper? c) (+ 1 (count (+ pos len) len)))))\n  (count 0 s))\n",
  "  (cond [(char=? (first s) #\\A)\n         (if (even? index)\n             (+ 1\
    \ (count_upper s))\n             (count_upper s))]\n        [(char=? (first s)\
    \ #\\B)\n         (if (even? index)\n             (+ 1 (count_upper s))\n    \
    \         (count_upper s))]\n        [(even? index)\n         (count_upper s)]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(equal? (car s) s) 1]\n    [(even? (car s)) (+\
    \ (count_upper (cdr s)) 1)]\n    [else (count_upper (cdr s))]))\n", "  (cond ((null?\
    \ s) 0)\n        ((char-upper? (car s)) (inc (count_upper (cdr s))))\n       \
    \ (else (+ 1 (count_upper (cdr s))))))\n", "  (cond\n    [(or (not (member #\\\
    A s)) (not (member #\\e s))) (count s)] \n    [else (count_upper (substring s\
    \ (+ 0 (count s))))]))\n", "  (remra (lambda (c)\n           (if (char=? c 'A)\
    \ (eqv? c 'A) (char=? c 'a)))\n         s\n         (length s)))\n", "  (cond\n\
    \    [(null? s)\n     0]\n    [(atom? (car s))\n     (count_upper (cdr s))]\n\
    \    [(null? (car s))\n     (count_upper (cdr s))]\n    [else (+ 1 (count_upper\
    \ (cdr s)))]))\n", "  (cond\n    [(empty? s) 0]\n    [(oddp? s) (count_upper (cdr\
    \ s))]\n    [else (if (equal? (first s) 'A) (+ 1 0) 0)]))\n", "  (let ([i 0]\n\
    \        [len 0]\n        [char '?])\n    (cond\n      [(null? s) 0]\n      [(char=?\
    \ char ?a)\n       (cond\n         [(= i 0) 1]\n         [(char=? (cdr s) char)\
    \ (incf len)]\n         [else (incf i)]))]\n      [else (cond\n             [(=\
    \ len 0) 1]\n             [(char=? (cdr s) char) (incf len)]\n             [else\
    \ (incf len)])]))))\n</code>\n<|/ a dscore=3 |>\n<| a tags=string,racket,scheme\
    \ dscore=2 |>\nI came up with this solution. It's a little bit different than\
    \ your solution but it works.\n<code>\n#lang racket\n", "  (cond [(empty? s) 0]\n\
    \        [(even? (car s)) (add1 (count-upper (cdr s)))]\n        [else 0]))\n",
  "  (let ([i 0])\n    (cond\n      [(empty? s) 0]\n      [(equal? (car s) #\\a) (add1\
    \ i)]\n      [(equal? (car s) #\\b) (add1 i)]\n      [(equal? (car s) #\\c) (add1\
    \ i)]\n      [(equal? (car s) #\\d) (add1 i)]\n      [(equal? (car s) #\\e) (add1\
    \ i)]\n      [(equal? (car s) #\\f) (add1 i)]\n      [(equal? (car s) #\\g) (add1\
    \ i)]\n      [(equal? (car s) #\\h) (add1 i)]\n      [(equal? (car s) #\\i) (add1\
    \ i)]\n      [(equal? (car s) #\\j) (add1 i)]\n      [(equal? (car s) #\\k) (add1\
    \ i)]\n      [(equal? (car s) #\\l) (add1 i)]\n      [(equal? (car s) #\\n) (add1\
    \ i)]\n      [(equal? (car s) #\\o) (add1 i)]\n      [(equal? (car s) #\\p) (add1\
    \ i)]\n      [(equal? (car s) #\\q) (add1 i)]\n      [(equal? (car s) #\\r) (add1\
    \ i)]\n      [(equal? (car s) #\\s) (add1 i)]\n      [(equal? (car s) #\\t) (add1\
    \ i)]\n      [(equal? (car s) #\\v) (add1 i)]\n      [else (sub1 (count_upper\
    \ (cdr s))) ])))\n", "  (count\n   (lambda (i) (= (substring s i i) ?A))\n   0\
    \ (length s) 0))\n", "  (cond [(or (empty? s) (null? (cdr s))) (eq? (car s) #\\\
    A)]\n        [(= (length s) 0) 0]\n        [(= (length s) 1) 1]\n        [else\
    \ (+ 1 (if (even? (length s) (- 1 (length s))) 0))]))\n", "  (cond\n    ((string=?\
    \ s \"#t\") 0)\n    ((string=? s \"#f)\") 0)\n    ((string=? s \"#f#f#f\") 0)\n\
    \    ((string=? s \"#t#t\") 0)\n    ((string=? s \"#t#t#t\") 0)\n    ((string=?\
    \ s \"#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t\") 0)\n    ((string=? s \"\
    #t#t#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t#t#t\") 0)\n    ((string=? s\
    \ \"#t#t#t#t#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=?\
    \ s \"#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t\"\
    ) 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t#t#t\"\
    ) 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=? s\
    \ \"#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t\"\
    ) 0)\n    ((string=? s \"#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string=?\
    \ s \"#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t#t\") 0)\n    ((string", "  (let ([i 0])\n\
    \    (loop for [j 0] below s.length\n          when (char=? (car s) (char #\\\
    A)) [set! i (inc! i)]\n          when (char=? (car s) (char #\\a)) [set! i (inc!\
    \ i)]\n          when (char=? (car s) (char #\\b)) [set! i (dec! i)]\n       \
    \   when (char=? (car s) (char #\\c)) [set! i (dec! i)]\n          when (char=?\
    \ (car s) (char #\\d)) [set! i (dec! i)]\n          when (char=? (car s) (char\
    \ #\\e)) [set! i (dec! i)]\n          when (char=? (car s) (char #\\f)) [set!\
    \ i (dec! i)]\n          when (char=? (car s) (char #\\g)) [set! i (dec! i)]\n\
    \          when (char=? (car s) (char #\\h)) [set! i (dec! i)]\n          when\
    \ (char=? (car s) (char #\\i)) [set! i (dec! i)]\n          when (char=? (car\
    \ s) (char #\\j)) [set! i (dec! i)]\n          when (char=? (car s) (char #\\\
    k)) [set! i (dec! i)]\n          when (char=? (car s) (char #\\l)) [set! i (dec!\
    \ i)]\n          when (char=? (car s) (char #\\n)) [set! i (dec! i)]\n       \
    \   when (char=? (car s) (char #\\o)) [set! i (dec! i)]\n          when (char=?\
    \ (car s) (char #\\p)) [set! i (dec! i)]\n          when (char=? (car s) (char\
    \ #\\q)) [set! i (dec! i)]\n          when (char=? (car s) (char #\\r)) [set!\
    \ i (dec! i)]\n          when (char=? (car s) (char #\\s)) [set! i (inc! i)]\n\
    \          when (char=? (car s) (char #\\t)) [set! i (inc! i)]\n          when\
    \ (char=? (car s) (char #\\v)) [set! i (inc! i)]", "  (cond ( (null? s) 0 )\n\
    \        ((char=? s #\\a) (+ 1 0))\n        (else (count_upper (cdr s)))))\n",
  "  (count\n   (lambda (x) (equal? (char-upper-case? (char x) 'a) true)\n       \
    \   (even? (char x)))\n   s))\n", "  (foldr (lambda (e acc)\n           (if (even?\
    \ (- e 2))\n               (+ acc 1)\n               acc))\n         0\n     \
    \    (string-map s #\\U)))\n", "  (apply + (map (lambda (index) (if (even? index)\
    \ (modulo (char-code (car s)) 97) (0 0))) '(0 2 4 6))))\n", "  (define (iter cnt\
    \ s)\n    (if (string? s)\n        (if (equal? (char-lower-case (first s)) #\\\
    a)\n            (iter (+ cnt 1) (rest s))\n            (iter cnt s))\n       \
    \ cnt))\n  (iter 0 s))\n", "  (count_vowels s (list 'a 'b 'c 'd 'e 'f 'g)))\n",
  "  (define (helper i)\n    (if (zero? i)\n        0\n        (if (char=? (char s\
    \ i) ?A)\n            (helper (sub1 i)) (helper (add1 i)))\n        (helper (add1\
    \ i))))\n  (helper (length s)))\n", "  (define (loop i j)\n    (cond (zero? j)\n\
    \          (add1 (string->int (substring s i j))))\n    (loop (+ i 2) (+ j 1)))\n\
    \  (loop (string-length s) 0))\n", "  (let loop ((s s)\n             (acc 0))\n\
    \    (cond [(empty? s) acc]\n          [(char-upper? (car s)) (loop (cdr s) (add1\
    \ acc))]\n          [else (loop (cdr s) acc)]))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThanks for your effort! I do find your solution with `map` more\
    \ readable than the one with `for`s. But I do also want to understand why this\
    \ doesn't work: `(define (count_upper s) (map char-upper? (string->list s)) (length\
    \ s))`\n<|/ c |>\n<| c |>\n`(define (count_upper s) (map char-upper? (string->list\
    \ s)) (length s))` is just `(define (count_upper s)  (length (map char-upper?\
    \ (string->list s))))` ... the map is applied to a list and returns the same list,\
    \ so the length is the same as the length of the original list. But the `length`\
    \ function is applied to the result of that map, and it's a list of booleans.\
    \ What you mean is `(define (count_upper s)  (length (map char-upper? (string->list\
    \ s)) s))` which will return the length of the list of uppercase chars\n<|/ c\
    \ |>\n<| c |>\nAh ok, got it. I thought the length function is applied to `(string->list\
    \ s)` and the `length` function is applied to `map` as both return a list. Thanks!\n\
    <|/ c |>\n<| c |>\n`(define (count_upper s)  (length (map char-upper? (string->list\
    \ s)) s))` will work, but it is not very readable\n<|/ c |>\n<| c |>\nYes, `length`\
    \ can be applied to a list of booleans, but `length` doesn't do that, it applies\
    \ it to whatever is passed as the second argument. `string->list` returns a list,\
    \ so `map` is applied to that, and then `length` is applied to that new list.\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nIn addition to the other answers, if you\
    \ want this as a one-liner you can use a lambda:\n<code>", "  (cond [(char-not-upper-char\
    \ #\\a (s-length s)) 0]\n        [else (+ 1 (count_upper (substring s 0 (+ (%\
    \ #\\a (s-length s)) 1))))]))\n", "  (let* ((c (byte s 0))\n         (chars (subseq\
    \ s 0 1 ))\n         (count 0))\n    (cond\n      ((= c #\\a)\n       (set! count\
    \ (+ count 1)))\n      ((= c #\\E)\n       (set! count (+ count 1)))\n      ((=\
    \ c #\\W)\n       (set! count (+ count 1)))\n      (else\n       (set! count (+\
    \ count 0)))\n    (cond\n      ((>= (length chars) 1)\n       (set! count 0))\n\
    \      (else\n       (do ((c c (cdr chars)))\n           ((null? chars) (set!\
    \ count 0)))\n       (if (even? (length chars))\n           (cond\n          \
    \   ((= c #\\A)\n               (set! count (+ count 1)))\n             ((= c\
    \ #\\E)\n               (set! count (+ count 1)))\n             ((= c #\\I)\n\
    \               (set! count (+ count 1)))\n             ((= c #\\O)\n        \
    \       (set! count (+ count 1)))\n             ((= c #\\U)\n               (set!\
    \ count (+ count 1)))\n             ((= c #\\Y)\n               (set! count (+\
    \ count 1)))\n             ((= c #\\S)\n               (set! count (+ count 1)))\n\
    \             ((= c #\\W)\n               (set! count (+ count 1)))\n        \
    \     ((= c #\\M)\n               (set! count (+ count 1)))\n             ((=\
    \ c #\\V)\n               (set! count (+ count 1)))\n             ((= c #\\G)\n\
    \               (set! count (+ count 1)))\n             ((= c #\\D)\n        \
    \       (set! count (+ count 1)))\n             ((= c #\\X)\n               (set!\
    \ count (+ count 1)))\n             ((= c #\\B)\n               (set! count (+\
    \ count 1)))\n             ((= c #\\N)\n               (set! count (+ count 1)))\n\
    \             ((= c #\\H)\n               (set! count (+ count 1)))\n        \
    \     ((= c #\\G)\n               (set! count (+ count 1)))\n             ((=\
    \ c #\\D)\n               (set! count (+ count 1)))\n             ((= c #\\K)\n\
    \               (set! count (+ count 1)))\n             ((= c #\\E)\n        \
    \       (set! count (+ count 1)))\n             ((", "  (let ([i (string->integer-vector\
    \ s)])\n    (cond [(or (pair? i)\n               (null? i))\n           0]\n \
    \         [(or (= (string-ref (first i) 0)\n                    'a)\n        \
    \       (= (string-ref (first i) 1)\n                    'e)\n               (=\
    \ (string-ref (first i) 2)\n                    'i)\n               (= (string-ref\
    \ (first i) 3)\n                    'o)\n               (= (string-ref (first\
    \ i) 4)\n                    'u))\n           (+ (if (even? (string->integer-value\
    \ (second i)))\n                 (- (string->integer-value (second i)))\n    \
    \             0)\n           1)]\n          [else\n           (+ (if (even? (string->integer-value\
    \ (second i)))\n                 (- (string->integer-value (second i)))\n    \
    \             0)\n           (count_upper (rest i))]))))\n", "  (match s\n   \
    \ ((null? s) 0)\n    ((cons (car s) (count_upper (cdr s))) 1)\n    ((string (car\
    \ s) #\\V (count_upper (cdr s))) 0)\n    ((string (car s) #\\a 1) 0)\n    ((string\
    \ (car s) #\\e 1) 0)\n    ((string (car s) #\\i 1) 0)\n    ((string (car s) #\\\
    o 1) 0)\n    ((string (car s) #\\u 1) 0)\n    ((string (car s) #\\h 1) 0)\n  \
    \  ((string (car s) #\\l 1) 0)\n    ((string (car s) #\\r 1) 0)\n    ((string\
    \ (car s) #\\A 1) 0)\n    ((string (car s) #\\E 1) 0)\n    ((string (car s) #\\\
    I 1) 0)\n    ((string (car s) #\\O 1) 0)\n    ((string (car s) #\\U 1) 0)\n  \
    \  ((string (car s) #\\H 1) 0)\n    ((string (car s) #\\L 1) 0)\n    ((string\
    \ (car s) #\\R 1) 0)\n    ((string (car s) #\\c 1) 0)\n    ((string (car s) #\\\
    d 1) 0)\n    ((string (car s) #\\f 1) 0)\n    ((string (car s) #\\g 1) 0)\n  \
    \  ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\G 1) 0)\n    ((string\
    \ (car s) #\\Z 1) 0)\n    ((string (car s) #\\g 1) 0)\n    ((string (car s) #\\\
    Z 1) 0)\n    ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\z 1) 0)\n  \
    \  ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\z 1) 0)\n    ((string\
    \ (car s) #\\z 1) 0)\n    ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\\
    z 1) 0)\n    ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\z 1) 0)\n  \
    \  ((string (car s) #\\z 1) 0)\n    ((string (car s) #\\z 1) 0)\n    ((string\
    \ (car s) #\\z 1) 0)\n    ((string (car s) #\\Z 1) 0)\n    ((string (car s) #\\\
    Z 1) 0)\n    ((string (car s) #\\g 1) 0)\n    ((string (car s) #\\Z 1) 0)\n  \
    \  ((string (car s) #\\Z 1) 0)\n    ((string (car s) #", "  (let ([i (length s)])\n\
    \    (cond [(<= i 2)\n           (+ (ormap (char->int (substring s i 2)) '[a-e\
    \ i-z])\n              (or (char->int (substring s i (+ 1 i))) '[a-e i-z]))]\n\
    \          [(<= i 3)\n           (+ (ormap (char->int (substring s i 2))\n   \
    \                  (char->int (substring s (+ 1 i) (+ 2 i)))\n               \
    \      '[a-e i-z])\n              (or (char->int (substring s (+ 1 i) (+ 2 i)))\
    \ '[a-e i-z])])\n          [else\n           (ormap (char->int (substring s i\
    \ 2))\n                 (char->int (substring s (+ 1 i) (+ 2 i)))\n          \
    \       '[a-e i-z])]))\n", "  (let loop ((i 0) (result 0) (char s))\n    (if (<\
    \ i s.length)\n        (loop (+ i 2) (+ result (if (char=? char #\\U) (+ result\
    \ 1) 0)) char)\n        result)))\n", "  (cond [(empty? s) 0]\n        [(even?\
    \ (length s)) (+ 1 (count_upper (substring s 0 1)))]))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(even? (length s))\n     (+ (char_code? (car s)) (count_upper (cdr\
    \ s)))]\n    [else 0]))\n", "  (length (filter (lambda (x)\n                 \
    \   (or (char-upper? (string->char x 0))\n                        (string-upper?\
    \ (string->char x 0))))\n                    (iterate string->list s))))\n", " \
    \ (count-vowels\n   (lambda (i) (>= i 0) (char= (char-code i) 65) (char= (char-code\
    \ i) 97))\n   (lambda (i) (char= (char-code i) 97))\n   s))\n", "  (let ((count\
    \ 0))\n    (for ([i (in-range 0 string-length s)])\n      (cond\n        ((char-upper?\
    \ (char-ref s i))\n         (inc count))\n        (else count))))", "  (apply\
    \ + (map (lambda (x) (if (char=? x #\\U) (+ 1 0)\n                           \
    \    (if (char=? (char x 0) #\\A)\n                                 (+ 1 0)\n\
    \                                 (if (char=? (char x 0) #\\D)\n             \
    \                        (+ 1 0)\n                                     (if (char=?\
    \ (char x 0) #\\E)\n                                         (+ 1 0)\n       \
    \                                  (if (char=? (char x 0) #\\G)\n            \
    \                                 (+ 1 0)\n                                  \
    \           (if (char=? (char x 0) #\\B)\n                                   \
    \              (+ 1 0)\n                                                 (if (char=?\
    \ (char x 0) #\\E)\n                                                     (+ 1\
    \ 0)\n                                                     (if (char=? (char x\
    \ 0) #\\I)\n                                                         (+ 1 0)\n\
    \                                                         (if (char=? (char x\
    \ 0) #\\O)\n                                                             (+ 1\
    \ 0)\n                                                             (if (char=?\
    \ (char x 0) #\\U)\n                                                         \
    \        (+ 1 0)\n                                                           \
    \      (if (char=? (char x 0) #\\Y)\n                                        \
    \                             (+ 1 0)\n                                      \
    \                               (if (char=? (char x 0) #\\S)\n               \
    \                                                          (+ 1 0)\n         \
    \                                                                (if (char=? (char\
    \ x 0) #\\T)\n                                                               \
    \              (+ 1 0)\n                                                     \
    \                        (if (char=? (char x 0) #\\W)\n                      \
    \                                                           (+ 1 0)\n        \
    \                                                                         (if\
    \ (char=? (char x 0) #\\V)\n                                                 \
    \                                    (+ 1 0)\n                               \
    \                                                      (if (char=? (char x 0)\
    \ #\\Y)\n                                                                    \
    \                     (+ 1 0)\n                                              \
    \                                           (if (char=? (char x 0) #\\S)\n   \
    \                                                                            \
    \              (+ 1 0)\n                                                     \
    \                                        (if (char=? (char x 0) #\\E)\n      \
    \                                                                            \
    \               (+ 1 0)\n                                                    \
    \                                             (if (char=? (char x 0) #\\G)\n \
    \                                                                            \
    \                        (+ 1 0)\n                                           \
    \                                                          (if (char=? (char x\
    \ 0) #\\I)\n                                                                 \
    \                                        (+ 1 0)\n                           \
    \                                                                            \
    \  (if (char=? (char x 0) #\\O)\n                                            \
    \                                                                 (+ 1 0)\n  \
    \                                                                            \
    \                               (if (char=? (char x 0) #\\Y)\n               \
    \                                                                            \
    \                      (+ 1 0)\n                                             \
    \                                                                    (if (char=?\
    \ (char x 0) #\\T)\n                                                         \
    \                                                            (+ 1 0)\n       \
    \                                                                            \
    \                                  (if (char=? (char x 0) #\\W)\n            \
    \                                                                            \
    \                                 (+ 1 0)\n                                  \
    \                                                                            \
    \           (if (char=? (char x 0) #\\V)\n                                   \
    \                                                                            \
    \              (+ 1 0)\n                                                     \
    \                                                                        (if (char=?\
    \ (", "  (cond\n    [(empty? s) 0]\n    [(odd? (length s)) 0]\n    [(equal? (first\
    \ s) \"a\") (+ 1 (count_upper (rest s)))]\n    [(equal? (first s) \"e\") (+ 1\
    \ (count_upper (rest s)))]\n    [(equal? (first s) \"i\") (+ 1 (count_upper (rest\
    \ s)))]\n    [else (count_upper (rest s))]))\n", "  (let ((c (make-array #(/ #\\\
    A #\\z)\n                       #:element-type 'char\n                       #:initial-contents\
    \ (string->list s))))\n    (if (null? s)\n        (length c)\n        (let ((i\
    \ (length (string->list s))))\n          (loop for i below (+ i 2) collect (list-ref\
    \ c i))))))\n", "  (if (empty? s) 0\n      (let ((ch (char (car s))))\n      \
    \  (if (member ch '(A a o U)) 1\n            (if (even? (char-code ch)) (count_upper\
    \ (cdr s)) 0)))))\n", "  (if (= (length s) 0)\n      0\n      (let ([i (in-range\
    \ (length s) 2)])\n        (cond\n          [(char-upper? (char-code (char s (+\
    \ i 2)))) #t]\n          [else #f])))) ;; #lang racket\n", "  (define char-to-ind\
    \ #f)\n  (define (count-upper s i char)\n    (cond ((char= char #\\a) (count-upper\
    \ (cdr s) (i) (char-to-ind char))\n          ((char= char #\\z) (count-upper (cdr\
    \ s) (i) (char-to-ind char))\n          (else (add1 (char-to-ind char))))))\n\
    \  (let ((char-to-int #f))\n    (define (count-chars s i char)\n      (cond ((char=\
    \ char #\\a) (count-chars (cdr s) (i) (char-to-int char))\n            ((char=\
    \ char #\\z) (count-chars (cdr s) (i) (char-to-int char))\n            (else (add1\
    \ (char-to-int char))))))\n    (define (count-string s i)\n      (cond ((char=\
    \ char #\\a) (count-string (cdr s) (i) (char-to-int char))\n            ((char=\
    \ char #\\z) (count-string (cdr s) (i) (char-to-int char))\n            (else\
    \ (count-chars s (i) (char-to-int char))))))\n    (count-string s 0))\n  (count-upper\
    \ s 0 'a))\n", "  (if (or (null? s) (equal? s \"\")) 0\n      (if (even? (length\
    \ (string->list s))) \n          (length (filter #(and (>= (string-ref (symbol->string\
    \ s) %) #'A) #'a) #'(c e i o u)))))\n      (count_upper (substring s (+ 0 (- 1\
    \ (string-length s))))))\n", "  (count_vowels s #f #f))\n", "  (rest\n   (count-if\
    \ (lambda (c i)\n                (= (position c 'aeiou)\n                  (even?\
    \ i))) s 0)))\n", "  (cond\n    [(empty? s) 0]\n    [(= 0 (string-length s)) 0]\n\
    \    [(char=? (car s) #\\A) (+ 0 (string-length (substring s 0 (floor (string-length\
    \ s) 2))))]\n    [(even? (string-length s)) (+ (count_upper (substring s 0 (floor\
    \ (string-length s) 2))))]\n    [else (+ (count_upper (substring s 0 (floor (string-length\
    \ s) 2))))]))\n", "  (let loop ((s s)\n             (count 0))\n    (cond\n  \
    \    [(empty? s) count]\n      [(char-upper? car s) (loop (cdr s) (+ count 1))]\n\
    \      [else (loop (cdr s) count)])))\n", "  (cond [(null? s) 0]\n        [(even?\
    \ (remainder s 26)) (+ 1 (count_upper (substring s 0 (+ (* 26 13) (remainder s\
    \ 26))))]\n        [else (count_upper (substring s 0 (+ (* 26 13) (length s))))]))\n",
  "  (cond ((empty? s) 0)\n        ((char-upper? (car s)) (count_upper (cdr s)))\n\
    \        (else (+ 1 (count_upper (cdr s))))))\n", "  (let ([counts ((make-hash\
    \ (quote ()) '()))]\n        (chars (string->list s))\n        ([i 0]))\n    (cond\
    \ [(null? chars) 0]\n          [(char=? (first chars) #\\a) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\e) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\i) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\o) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\u) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\b) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\d) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\g) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\E) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\F) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\Z) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\c) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\H) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\p) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\P) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\a) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\e) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\i) (add1 (gethash (second\
    \ chars) counts))]\n          [(char=? (first chars) #\\o) (add1 (gethash (second\
    \ chars) counts))]", "  (cond\n    [(empty? s) 0]\n    [(equal? (first s) (first\
    \ s)) 1]\n    [else (+ 1 (count_upper (rest s))))]))\n", "  (if (null? s)\n  \
    \    0\n      (if (even? (car s))\n          (+ 1 (count_upper (cdr s))))))\n",
  "  (let loop ((i 0) (acc 0))\n    (if (< i (string-length s))\n        (begin (set!\
    \ acc (+ (string=? (char s i) 'a) (string=? (char s i) 'e) (string=? (char s i)\
    \ 'i) (string=? (char s i) 'o) (string=? (char s i) 'u)))\n        acc))\n  (values\
    \ acc 0)))\n", "  (cond\n    ((= 0 (mod (regexp-match-count \"^([AEIOU])\") s))\n\
    \     (regexp-match-count \"^([AEIOU])\"))\n    ((= 0 (mod (regexp-match-count\
    \ \"^([AEIOU])\" s) 2))\n     (regexp-match-count \"^([AEIOU])\"))\n    ((= 0\
    \ (mod (regexp-match-count \"^([AEIOU])\" s) 3))\n     (regexp-match-count \"\
    ^([AEIOU])\"))\n    ((= 0 (mod (regexp-match-count \"^([AEIOU])\" s) 4))\n   \
    \  (regexp-match-count \"^([AEIOU])\"))\n    ((= 0 (mod (regexp-match-count \"\
    ^([AEIOU])\" s) 5))\n     (regexp-match-count \"^([AEIOU])\"))\n    ((= 0 (mod\
    \ (regexp-match-count \"^([AEIOU])\" s) 6))\n     (regexp-match-count \"^([AEIOU])\"\
    ))\n    ((= 0 (mod (regexp-match-count \"^([AEIOU])\" s) 7))\n     (regexp-match-count\
    \ \"^([AEIOU])\"))\n    ((= 0 (mod (regexp-match-count \"^([AEIOU])\" s) 8))\n\
    \     (regexp-match-count \"^([AEIOU])\"))\n    ((= 0 (mod (regexp-match-count\
    \ \"^([AEIOU])\" s) 9))\n     (regexp-match-count \"^([AEIOU])\"))\n    (else\n\
    \     (regexp-match-count \"^([AEIOU])\"))))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(or (char=? (car s) 'A) (char=? (car s) 'E)) (+ 1 (count_upper (cdr s)))]\n\
    \    [else (count_upper (cdr s))]))\n", "  (length (filter (lambda (c) (or (char-upper?\
    \ (c) c))\n                        (char-upper? (c) (char-lower? (c) c))) s)))\n",
  "  (let loop ((i 0) (c 0))\n    (cond ((eq? i 0) c)\n          ((char=? (char-code\
    \ s) 'A) (c+ c (char-code s))\n           (loop (+ i 2) c))\n          ((char=?\
    \ (char-code s) 'a) (c+ c 1)\n           (loop (+ i 2) c))\n          (else (loop\
    \ (+ i 2) c)))\n    (loop (length s) 0)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I don't think it works when `s` is empty. Should it return `0` instead?\n<|/ c\
    \ |>\n<| c |>\nThe original question says \"Given a string s\" not \"Given an\
    \ empty string\". As such, the first character of the string doesn't matter, except\
    \ that it's not the only character of the string. So, no, empty string should\
    \ return `0`.\n<|/ c |>\n<| c |>\nOh, I see - I misunderstood. I was thinking\
    \ \"empty string\" was the only character. Thanks!\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", '  (count_vowels s #:a) #:z)', "  (cond\n    [(empty? s) 0]\n \
    \   [(equal? (char-code (car s)) 65) (+ 1 (count_upper (cdr s)))]\n    [else (count_upper\
    \ (cdr s))]))\n", "  (let* ([vowels '(a e i o u)]\n         [vowel-index 0])\n\
    \    (cond [(string=? s \"\") 0]\n          [(string=? s \"\") 0]\n          [else\
    \ \n           (for-each (lambda (x)\n                         (when (in-charset\
    \ vowels x true)\n                           (let ([vowel (memref vowels x 1)]\n\
    \                                 [char-index (memref vowels x 0)])\n        \
    \                     (cond\n                              [(char-index x #\\\
    A) vowel-index]\n                              [(char-index x #\\z) vowel-index]\n\
    \                              [(char-index x #\\A) 0]\n                     \
    \         [else vowel-index]))]))]))))\n", "  (count-letters (lambda (i)\n   \
    \                 (let ((ch (char-ord (car s))))\n                      (if (char-upper-ord\
    \ ch)\n                          1\n                          0)))\n         \
    \      s))\n", "  (cond [(empty? s) 0]\n        [(even? (length s)) (+ 1 (apply\
    \ min (map count-upper (subseq s 0 2))))]\n        [else 0]))", "  (define (count-up\
    \ c s)\n    (if (char=? c #\\a)\n        (add1 c)\n        (if (char=? c #\\z)\n\
    \            (add1 c)\n            0)))\n  (define (count-up i s)\n    (if (<\
    \ i s)\n        (if (char=? (substring s i i) #\\A)\n            (count-up (add1\
    \ i) s)\n            (count-up i (substring s i i))))\n  (if (< 0 (length s))\n\
    \      (add1 (count-up 0 (substring s 0 (length s)))))\n  0)\n", "  (cond [(null?\
    \ s) 0]\n        [(= (remainder s 26) 0) 1]\n        [else (+ 1 (count_upper (substring\
    \ s 0 (remainder s 26)))) ]))\n", "  (let-values (((evens uppers) (partition 2\
    \ (string->list s))))\n    (cond\n      [(null? s) 0]\n      [(eq? (car s) 'A)\
    \ 0]\n      [(= (evens count) 0) (+ count (count_upper rest))]\n      [(= (evens\
    \ count) 1) (+ count (count_upper rest))]\n      [(= (evens count) 2) (+ count\
    \ (count_upper rest))]\n      [(= (evens count) 3) (+ count (count_upper rest))]\n\
    \      [(= (evens count) 4) (+ count (count_upper rest))]\n      [(= (evens count)\
    \ 5) (+ count (count_upper rest))]\n      [(= (evens count) 6) (+ count (count_upper\
    \ rest))]\n      [(= (evens count) 7) (+ count (count_upper rest))]\n      [(=\
    \ (evens count) 8) (+ count (count_upper rest))]\n      [(= (evens count) 9) (+\
    \ count (count_upper rest))]\n      [else (+ count (count_upper rest))]\n    \
    \  )))\n", "  (let loop ((s s)\n             (accum 0))\n    (if (empty? s)\n\
    \        accum\n        (loop (cdr s)\n               (+ (if (char-upper? (first\
    \ s)) (first s) accum) 1))))\n", "  (if (empty? s)\n      0\n      (+ 1 (count\
    \ (char #\\A s)))))\n", "  (let ((count 0))\n    (for ([i (length s)])\n     \
    \ (if (even? i)\n          (let ((char (substring s i 1)))\n            (cond\
    \ ((char-upper? (char))\n                  (set! count (add1 count)))\n      \
    \            (else\n                  (set! count 0))))\n      (set! count 0))))\n",
  "  (define (count_upper s acc)\n    (cond\n      [(empty? s) acc]\n      [(equal?\
    \ (first s) #\\A) (count_upper (rest s) (+ acc 1))]\n      [(equal? (first s)\
    \ #\\e) (count_upper (rest s) (+ acc 1))]\n      [(equal? (first s) #\\I) (count_upper\
    \ (rest s) (+ acc 1))]\n      [(equal? (first s) #\\O) (count_upper (rest s) (+\
    \ acc 1))]\n      [(equal? (first s) #\\U) (count_upper (rest s) (+ acc 1))]\n\
    \      [else\n       (count_upper (rest s) (+ acc 1))]\n      ))\n  (count_upper\
    \ s 0))\n", "  (loop for c (char->int s)\n        for i in [0 .. length (char->string\
    \ s)] when (= (modulo i 2) 0) do\n        (if (char->char (char->string s) i)\
    \ (incf (char->int (substring s i i) 0)))))\n", "  (let ((vowels '(a e i o u)))\n\
    \    (define (aux i acc str)\n      (cond [(>= i str) #t]\n            [(member\
    \ (char str i) vowels) (aux i\n                                              \
    \           (+ acc (length str))\n                                           \
    \              (substring str i (length str)))]\n            [else (aux i acc\
    \ (substring str i (length str)))]))\n    (aux 0 0 (string s)))\n", "  (if (empty?\
    \ s) 0 \n      (if (char? (car s)) \n          (if (char? (cadr s))\n        \
    \      (if (char? (caddr s))\n                  (if (char? (cadddr s))\n     \
    \                 (if (char? (cadddddr s))\n                          (if (char?\
    \ (caddddddr s))\n                              (if (char? (cadddddddr s))\n \
    \                                 (if (char? (cadddddddddr s))\n             \
    \                         (if (char? (caddddddddddr s))\n                    \
    \                      (if (char? (cadddddddddddr s))\n                      \
    \                        (if (char? (cadddddddddddddr s))\n                  \
    \                                (if (char? (caddddddddddddddr s))\n         \
    \                                             (if (char? (cadddddddddddddddr s))\n\
    \                                                          (if (char? (cadddddddddddddddddr\
    \ s))\n                                                              (if (char?\
    \ (caddddddddddddddddddr s))\n                                               \
    \                   (if (char? (cadddddddddddddddddddr s))\n                 \
    \                                                     (if (char? (cadddddddddddddddddddddr\
    \ s))\n                                                                      \
    \    (if (char? (caddddddddddddddddddddddr s))\n                             \
    \                                                 (if (char? (cadddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \            (if (char? (caddddddddddddddddddddddddddr s))\n                 \
    \                                                                     (if (char?\
    \ (cadddddddddddddddddddddddddddr s))\n                                      \
    \                                                    (if (char? (cadddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                        (if (char? (caddddddddddddddddddddddddddddddr s))\n \
    \                                                                            \
    \                     (if (char? (caddddddddddddddddddddddddddddddddddr s))\n\
    \                                                                            \
    \                          (if (char? (caddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                    (if (char? (cadddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                        (if (char? (caddddddddddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                            (if (char? (caddddddddddddddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                                (if (char? (caddddddddddddddddddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                                    (if (char? (caddddddddddddddddddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                                        (if (char? (caddddddddddddddddddddddddddddddddddddddddddddddddddddddddr\
    \ s))\n                                                                      \
    \                                                            (if (char? (cadddddddddddddddddddddddddd",
  "  (let loop ((s s)\n             (count 0))\n    (if (empty? s)\n        count\n\
    \        (loop (cdr s) (+ count (list-ref (list ?a ?e ?i) (list-ref s 0 0)))))))\n",
  "  (let ((count 0))\n    (for-indexed (x s)\n      (if (even? x)\n          (set!\
    \ count (+ count 1))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt was just a sample\
    \ code. I think I missed the `even?` part of it, so I updated it.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\n#lang racket\n", "  (cond ((null s) 0)\n        ((char=?\
    \ s #\\A) 0)\n        ((char=? s #\\a) (+ 1 (count_upper (substring s 1 ))))\n\
    \        ((char=? s #\\b) (+ 1 (count_upper (substring s 2 ))))\n        ((char=?\
    \ s #\\c) (+ 1 (count_upper (substring s 3 ))))\n        ((char=? s #\\d) (+ 1\
    \ (count_upper (substring s 4 ))))\n        ((char=? s #\\e) (+ 1 (count_upper\
    \ (substring s 5 ))))\n        ((char=? s #\\f) (+ 1 (count_upper (substring s\
    \ 6 ))))\n        ((char=? s #\\g) (+ 1 (count_upper (substring s 7 ))))\n   \
    \     (else (+ 1 (count_upper (substring s 1 ))))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(oddp (string-length s)) (+ 0 (string-ref s 0))]\n    [else (+ 1\
    \ (count_upper (string-ref s (+ 0 (string-length s)))))]))\n", "  (if (null? s)\n\
    \      0\n      (if (even? (length s))\n          (if (char-upper? (car s))\n\
    \              (+ 1 (count_upper (cdr s))))\n          (if (char-upper? (car s))\n\
    \              (+ 1 (count_upper (cdr s)))))\n      (count_upper (cdr s))))\n",
  "  (let ((vowels '()) (count 0))\n    (labels ((count (i char)\n               (cond\n\
    \                  [(empty? char) (+ count 1)]\n                  [(char-upper?\
    \ char) (count (1+ i) (first char))]\n                  [else (count (1+ i) (cdr\
    \ char))])))\n      (map (\u03BB (c) (if (char-upper? c) (cons c vowels) vowels))\n\
    \           (string->list s)))))\n", "  (let loop ((s s) (n 0))\n    (cond ((or\
    \ (not s) (null? s)) (add1 n))\n          ((char=? (car s) #\\A) (loop (cdr s)\
    \ (add1 n)))\n          ((char=? (car s) #\\U) (loop (cdr s) (add1 n)))\n    \
    \      ((char=? (car s) #\\0) (loop (cdr s) (add1 n)))\n          (else (loop\
    \ (cdr s) (add1 n)))))\n  (loop (reverse s) 0))\n", "  (count_up_even (map #(match\
    \ [(c (char? #\\_) (C-upper? #\\_))\n                             ((? #\\_ (make-string\
    \ #\\_)))]\n                        (c-string c))\n                     s))\n",
  "  ;; This one is a little tricky.\n  ;; If the length is even, there can't be any\
    \ uppercase vowels.\n  ;; If the length is odd, there can be one uppercase vowel.\n\
    \  ;; So we add one to even positions, and subtract one from odd positions.\n\
    \  (cond\n    ((= (length s) 0)\n     (- 1))\n    ((even? (length s))\n     (+\
    \ 1 (count_upper (substring s 0 2))))\n    (else\n     (- 1 (count_upper (substring\
    \ s 0 2))))))\n", "  (if (string? s)\n      (let ((count-1 0))\n        (for ([i\
    \ s])\n          (if (even? i)\n              (add1 (* count (match-string-uppercase\
    \ i))))))\n      (error \"not a string\")))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(even? (length s))\n     (+ (char-code (car s)) (count_upper (cdr s)))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(equal? (first s) #\\a) 1]\n    [else (+ (count_upper\
    \ (rest s)) \n              (if (even? (first s))\n                  (count_upper\
    \ (rest s))\n                  0))]))\n", "  (cond ((or (null? s) (zero? s)) 0)\n\
    \        ((char-upper? (first s)) (+ 1))\n        (else (count_upper (cdr s)))))\n",
  "  (count_vowels '(#\\a #\\e #\\i #\\o #\\u))\n  (let loop ([s s])\n    (if (null?\
    \ s)\n        0\n        (if (odd? (car s))\n            (+ 1 (loop (cdr s)))\n\
    \            (loop (cdr s))))))\n", "  (if (empty? s) 0\n      (if (even? (length\
    \ s)) (+ 1 (first s)) (if (first s) 0 (+ 1 (first s))))))\n", "  (let loop ((count\
    \ 0) (current 0) (acc '()))\n    (cond\n      [(empty? s) count]\n      [(equal?\
    \ (char-code s) #\\a)\n       (loop (+ count current) (+ current 1) (cons #\\\
    A acc))]\n      [(equal? (char-code s) #\\e)\n       (loop (+ count current) (+\
    \ current 1) (cons #\\E acc))]\n      [(equal? (char-code s) #\\i)\n       (loop\
    \ (+ count current) (+ current 1) (cons #\\I acc))]\n      [(equal? (char-code\
    \ s) #\\o)\n       (loop (+ count current) (+ current 1) (cons #\\O acc))]\n \
    \     [else\n       (loop (+ count current) 1 (cons (char-code s) acc))]\n   \
    \ )))\n", "  (cond\n    [(= (length s) 0)\n     0]\n    [(= (% s (substring s\
    \ 'a)) 0)\n     0]\n    [else (+ 1 (/ 1 3))]))\n", "  (cond\n    ((empty? s) 0)\n\
    \    ((char-value s) (if (char-value (char-ref s 0))\n                       (if\
    \ (char-value (char-ref s 2))\n                           (if (char-value (char-ref\
    \ s 4))\n                               (if (char-value (char-ref s 6))\n    \
    \                             (if (char-value (char-ref s 8))\n              \
    \                       (if (char-value (char-ref s 10))\n                   \
    \                      (if (char-value (char-ref s 12))\n                    \
    \                       (if (char-value (char-ref s 14))\n                   \
    \                            (if (char-value (char-ref s 16))\n              \
    \                                     (if (char-value (char-ref s 18))\n     \
    \                                                (if (char-value (char-ref s 20))\n\
    \                                                       (if (char-value (char-ref\
    \ s 22))\n                                                           (if (char-value\
    \ (char-ref s 24))\n                                                         \
    \      (if (char-value (char-ref s 26))\n                                    \
    \                             (if (char-value (char-ref s 28))\n             \
    \                                                        (if (char-value (char-ref\
    \ s 30))\n                                                                   \
    \      (if (char-value (char-ref s 32))\n                                    \
    \                                       (if (char-value (char-ref s 34))\n   \
    \                                                                            (if\
    \ (char-value (char-ref s 36))\n                                             \
    \                                    (if (char-value (char-ref s 38))\n      \
    \                                                                            \
    \ (if (char-value (char-ref s 40))\n                                         \
    \                                                            (if (char-value (char-ref\
    \ s 42))\n                                                                   \
    \      (if (char-value (char-ref s 44))\n                                    \
    \                                       (if (char-value (char-ref s 46))\n   \
    \                                                                          (if\
    \ (char-value (char-ref s 48))\n                                             \
    \                                  (if (char-value (char-ref s 50))\n        \
    \                                                                            \
    \            (if (char-value (char-ref s 52))\n                              \
    \                                                                    (if (char-value\
    \ (char-ref s 54))\n                                                         \
    \                                           (if (char-value (char-ref s 56))\n\
    \                                                                            \
    \                          (if (char-value (char-ref s 58))\n                \
    \                                                                            \
    \            (if (char-value (char-ref s 60))\n                              \
    \                                                                            (if\
    \ (char-value (char-ref s 62))\n                                             \
    \                                                               (if (char-value\
    \ (char-ref s 64))\n                                                         \
    \                                                     (if (char-value (char-ref\
    \ s 66))\n                                                                   \
    \                                             (if (char-value (char-ref s 68))\n\
    \                                                                            \
    \                                      (if (char-value (char-ref s 70))\n    \
    \                                                                            \
    \                                    (if (char-value (char-ref s 72))\n      \
    \                                                                            \
    \                                    (if (char-value (char", "  (cond\n    ((empty?\
    \ s) 0)\n    ((equal? (char-code (first s)) #\\a) 0)\n    ((equal? (char-code\
    \ (first s)) #\\b) 0)\n    ((equal? (char-code (first s)) #\\c) 0)\n    ((equal?\
    \ (char-code (first s)) #\\d) 0)\n    ((equal? (char-code (first s)) #\\e) 0)\n\
    \    ((equal? (char-code (first s)) #\\f) 0)\n    ((equal? (char-code (first s))\
    \ #\\g) 0)\n    ((equal? (char-code (first s)) #\\h) 0)\n    ((equal? (char-code\
    \ (first s)) #\\i) 0)\n    ((equal? (char-code (first s)) #\\j) 0)\n    ((equal?\
    \ (char-code (first s)) #\\k) 0)\n    ((equal? (char-code (first s)) #\\l) 0)\n\
    \    ((equal? (char-code (first s)) #\\m) 0)\n    ((equal? (char-code (first s))\
    \ #\\n) 0)\n    ((equal? (char-code (first s)) #\\o) 0)\n    ((equal? (char-code\
    \ (first s)) #\\p) 0)\n    ((equal? (char-code (first s)) #\\q) 0)\n    ((equal?\
    \ (char-code (first s)) #\\r) 0)\n    ((equal? (char-code (first s)) #\\s) 0)\n\
    \    ((equal? (char-code (first s)) #\\t) 0)\n    ((equal? (char-code (first s))\
    \ #\\v) 0)\n    ((equal? (char-code (first s)) #\\W) 0)\n    ((equal? (char-code\
    \ (first s)) #\\w) 0)\n    ((equal? (char-code (first s)) #\\X) 0)\n    ((equal?\
    \ (char-code (first s)) #\\Y) 0)\n    ((equal? (char-code (first s)) #\\Z) 0)\n\
    \    ((equal? (char-code (first s)) #\\\") 0)\n    ((equal? (char-code (first\
    \ s)) #\\\") 0)\n    ((equal? (char-code (first s)) #\\\") 0)\n    ((equal? (char-code\
    \ (first s)) #\\\") 0)\n    ((equal? (char-code (first s)) #\\\") 0)\n    ((equal?\
    \ (char-code (first s)) #\\\") 0)\n    ((equal? (char-code (first s)) #\\\") 0)\n\
    \    ((equal? (char-code (first s)) #\\\") 0)\n    ((equal? (char-code (first\
    \ s)) #", "  (let loop ((s s)\n             (count 0))\n    (if (string? s)\n\
    \        (if (eq? s \"\")\n            count\n            (loop (rest s) count))\n\
    \        count\n        (loop (rest s) count))))\n", "  (define upper-count\n\
    \    (lambda (i)\n      (when (= 0 (mod i 2))\n        (cond\n          [(char=?\
    \ (char->integer s) 'A) (add1 upper-count)]\n          [(char=? (char->integer\
    \ s) 'E) (add1 upper-count)]\n          [(char=? (char->integer s) 'I) (add1 upper-count)]\n\
    \          [(char=? (char->integer s) 'O) (add1 upper-count)]\n          [(char=?\
    \ (char->integer s) 'U) (add1 upper-count)]\n          [else 0]))))\n  (loop (add1\
    \ upper-count)\n        0 s))\n", "  (count-upper-even (string-to-list s)))\n",
  "  (if (string-length (cut s 0 )) \n      (+ 1 (map (lambda (char) (char-property\
    \ char #:uppercase 0))\n                 (cut s 0 ))) \n      0))\n", '  (count-vowels
    s #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f
    #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f ', "  (if (or (char-upper?\
    \ (car s)) (char-upper? (cdr s)))\n      (+ 1 (count_upper (cdr s)))\n      0))\n",
  "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) 0]\n    [else (+ 1 (length\
    \ (filter upper? (rest s))))]))", "  (cond\n    ((empty? s)          0)\n    ((char=?\
    \ (car s) #\\A)   + (count_upper (cdr s))\n    ((char=? (car s) #\\B)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\C)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\D)   + (count_upper (cdr s))\n    ((char=? (car s) #\\E)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\F)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\G)   + (count_upper (cdr s))\n    ((char=? (car s) #\\H)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\I)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\J)   + (count_upper (cdr s))\n    ((char=? (car s) #\\K)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\L)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\M)   + (count_upper (cdr s))\n    ((char=? (car s) #\\N)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\O)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\P)   + (count_upper (cdr s))\n    ((char=? (car s) #\\Q)   + (count_upper\
    \ (cdr s))\n    ((char=? (car s) #\\R)   + (count_upper (cdr s))\n    ((char=?\
    \ (car s) #\\S))  0)))\n", "  (let loop ((s s)\n             (count 0))\n    (if\
    \ (null? s)\n        count\n        (let ((c (string->char (string s)))\n    \
    \           (letter 'a))\n          (cond\n            (string=? (char->string\
    \ c) #\\a)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\e)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\i)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\o)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\u)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\y)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\j)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\b)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\p)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\d)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\f)\n            (loop (cdr s) (1+ count))\n            (string=? (char->string\
    \ c) #\\z)\n            (loop (cdr s) (1+ count))\n            (else count)))))\n\
    \  (loop '() 0))\n</cell>\n<code language=dyalog-kernel>", "  (let ((count 0))\n\
    \    (loop for i from 0 to (length s) step 2\n          for c from (substring\
    \ s i (+ i 2))\n          when (char-upper? (c))\n          do (set! count (add1\
    \ count)))))\n", "  (define (count-vowel char count)\n    (if (char=? char #\\\
    a)\n        count\n        (count-vowel (char-after char) (incf count))))\n  (count-vowel\
    \ s (add1 (count-vowel #\\A 0))))\n", "  (cond\n    [(empty? s)\n     0]\n   \
    \ [(even? (length s))\n     (+ (count (member 'A s)) (count (member 'E s)))\n\
    \     (count (member 'I s))\n     (count (member 'O s))\n     (count (member 'U\
    \ s))\n     (count (member 'Y s))]\n    [else\n     (count_upper (rest s))]))\n",
  "  (if (equal? s \"\")\n      0\n      (let ((count 0))\n        (for-each ([c s])\
    \ ; This syntax is called a for/each loop because\n                      ;; for/each\
    \ takes one argument and does something to it\n                      ;; and returns\
    \ the new value of c. Since we are\n                      ;; iterating over s,\
    \ c will be the element of s\n                      ;; being iterated over. \n\
    \                      ; We are using for/each because we want to\n          \
    \            ;; process each character in the string\n                      ;;\
    \ one at a time but return a new value each time\n                      ;; we\
    \ loop over s.\n                      ; (for-each) is a macro that expands to\n\
    \                      ; (for/list) which takes a sequence and runs\n        \
    \              ; (for-each) on that sequence. Since we are not\n             \
    \         ; using the sequence syntax, the parentheses are\n                 \
    \     ; not required.\n                      ; (equal? s \"\") is true if the\
    \ string is empty\n                      ; (char-alphabetic? c) is true if the\
    \ character is an alphabetic character\n                      ; and (char-upper-case?\
    \ c) is true if the character is uppercase\n                      ; (char-lower-case?\
    \ c) is true if the character is lowercase\n                      (if (equal?\
    \ (char-alphabetic? c) true)\n                          (if (char-upper-case?\
    \ c) (inc count))\n                          (inc count)))))\n      count))\n",
  "  (let loop (([i 0]) (count 0))\n    (cond [(string=? s \"\") count]\n        \
    \  [(char=? (string-ref s i) #\\A) count]\n          [else\n           (loop (+\
    \ i 2) (+ count 1)))]))\n", "  (cond\n    ((null? s)    0)\n    ((eq? (char-code\
    \ (car s)) 65) \n     (count_upper (cdr s)))\n    ((even? (char-code (car s)))\
    \ \n     (count_upper (cdr s)))))\n", "  (count\n   (lambda (v) (if (even? v)\
    \ v #f))\n   (map #(make-token :upper %) #(list s)))\n)\n", "  (if (null? s)\n\
    \      0\n      (cond [(string=? (string-ref s 0) #\\A) (+ 1 (count_upper s (cdr\
    \ s)))]\n            [else 0])))\n", "  (let ((vowel 'A) \n        (count 0))\n\
    \    (for ((i (length s)))\n      (when (char-upper? (car s) vowel)\n        (set!\
    \ vowel (char-upper? (cdr s) vowel))\n        (set! count (+ count 1)))\n    \
    \  (when (even? i)\n        (set! vowel (char-upper? (car s) vowel))\n       \
    \ (set! count (+ count 1)))\n      (set! vowel (char-upper? (cdr s) vowel))\n\
    \      (set! count (+ count 1)))\n    count))\n", "  ;; This code only works with\
    \ strings that\n  ;; are all ASCII\n  (cond\n    [(empty? s)\n     (assert false)\n\
    \    ]\n    [(>= (first s) #\\A) 0]\n    [else (let [char (first s)\n        \
    \      count (cond\n                     [(char-lower (char-code char)) (add1\
    \ (count char-upper (char-code char)))]\n                     [(char-upper (char-code\
    \ char)) (add1 (count char-lower (char-code char)))]\n                     [else\
    \ 0]\n                     )]\n      (cond\n        [(even? (rest s))\n      \
    \   (add1 (count char-upper (first s)))]\n        [else 0]\n        )]\n     \
    \ )\n    )\n  )\n", "  (cond\n    [(empty? s) 0]\n    [(eq? (char-case (car s))\
    \ upper-case) (+ 1 (count_upper (cdr s)))]\n    [else (count_upper (cdr s))]))\n",
  "  (cond [(empty? s)\n         (length s)]\n        [(equal? (car s) 'A)\n     \
    \    (+ (count_upper (cdr s)) (if even? (car s) 0)))]\n        [(equal? (car s)\
    \ 'E)\n         (+ (count_upper (cdr s)) (if even? (car s) 0)))]\n        [(equal?\
    \ (car s) 'I)\n         (+ (count_upper (cdr s)) (if even? (car s) 0)))]\n   \
    \     [(equal? (car s) 'O)\n         (+ (count_upper (cdr s)) (if even? (car s)\
    \ 0)))]\n        [(equal? (car s) 'U)\n         (+ (count_upper (cdr s)) (if even?\
    \ (car s) 0)))]\n        [else\n         (count_upper (cdr s))]))\n", "  (reverse\
    \ (map (\u03BB (char) (char-code char)) (range-from 0 (string-upcase s)))\n  \
    \       filter (\u03BB (char) (char-code char))\n         (\u03BB (c) (char-code\
    \ c) (c-char-upper (+ c 1))) 0))\n", "  (cond\n    ((null? s) 0)\n    ((char-upper?\
    \ (car s)) (cadr s))\n    (else (count_upper (cdr s)))))\n", "  (cond\n    [(empty?\
    \ s) 0]\n    [(not (even? (length s)))\n     (if (char=? (first s) (first '(a)))\n\
    \         (add1 (count_upper (rest s))))\n     (if (char=? (first s) (first '(a)))\n\
    \         (add1 (count_upper (rest s))))]))\n", "  (count_up_to s #\\A #\\a #\\\
    b #\\b #\\C #\\c #\\D #\\d #\\E #\\e #\\F #\\f #\\G #\\g #\\H #\\h #\\I #\\i #\\\
    J #\\j #\\K #\\k #\\L #\\l #\\M #\\m #\\N #\\n #\\O #\\o #\\P #\\p #\\Q #\\q #\\\
    R #\\r #\\S #\\s #\\T #\\t #\\U #\\u #\\V #\\v #\\W #\\w #\\X #\\x #\\Y #\\y #\\\
    Z #\\z #\\a)\n  )\n", "  (define even? #(= (modulo % 2) 0))\n  (cond\n    ((empty?\
    \ s) 0)\n    ((even? (car s))\n     (+ (count_upper (cdr s)) (if (even? s) 1 0)))\n\
    \    (else (count_upper (cdr s)))))\n", "  (count_upper_aux (make-string-input-stream\
    \ s) (make-string-output-stream (length s))))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(or (char-upper? (car s))\n          (char-upper? (cdr s)))\n     (add1\
    \ (count_upper (cdr s)))]\n    [else (count_upper (cdr s))]))\n", "  (count\n\
    \   (lambda (c)\n     (cond\n      ((char=? c 'A) (= (modulo c 2) 0))\n      ((char=?\
    \ c 'E) (= (modulo c 2) 1))\n      ((char=? c 'I) (= (modulo c 2) 2))\n      ((char=?\
    \ c 'O) (= (modulo c 2) 3))\n      ((char=? c 'U) (= (modulo c 2) 4))\n      ((char=?\
    \ c 'a) (= (modulo c 2) 5))\n      ((char=? c 'e) (= (modulo c 2) 6))\n      ((char=?\
    \ c 'i) (= (modulo c 2) 7))\n      ((char=? c 'o) (= (modulo c 2) 8))\n      ((char=?\
    \ c 'u) (= (modulo c 2) 9))\n      ((char=? c 'D) (= (modulo c 2) 10))\n     \
    \ ((char=? c 'b) (= (modulo c 2) 11))\n      ((char=? c 'f) (= (modulo c 2) 12))\n\
    \      ((char=? c 'g) (= (modulo c 2) 13))\n      ((char=? c 'B) (= (modulo c\
    \ 2) 14))\n      ((char=? c 'c) (= (modulo c 2) 15))\n      ((char=? c 'e) (=\
    \ (modulo c 2) 16))\n      ((char=? c 'g) (= (modulo c 2) 17))\n      ((char=?\
    \ c 'h) (= (modulo c 2) 18))\n      ((char=? c 'I) (= (modulo c 2) 19))\n    \
    \  ((char=? c 'j) (= (modulo c 2) 20))\n      ((char=? c 'l) (= (modulo c 2) 21))\n\
    \      ((char=? c 'n) (= (modulo c 2) 22))\n      ((char=? c 'p) (= (modulo c\
    \ 2) 23))\n      ((char=? c 'R) (= (modulo c 2) 24))\n      ((char=? c 'T) (=\
    \ (modulo c 2) 25))\n      ((char=? c 'w) (= (modulo c 2) 26))\n      ((char=?\
    \ c 'y) (= (modulo c 2) 27))\n      ((char=? c 'Z) (= ", "  (count-upper-helper\
    \ (string-length s) #f #f #f #f #f))\n", "  (cond ((empty? s) 0)\n        (#t\
    \ (+ ((length s) #:odd (char-index 'A (first s))) #:upper (count_upper (rest s))))))\n",
  "  (count_chars s #\\U (lambda (c) (or (char=? (char-code c) #\\A) (char=? (char-code\
    \ c) #\\Z)))))\n", "  (define (count-vowels s index)\n    (if (zero? index)\n\
    \        0\n        (if (char=? (char s index) 'A)\n            (if (even? (add1\
    \ index))\n                (+ 1 (count-vowels (substring s (add1 index)) (add1\
    \ index)))\n                (count-vowels (substring s (add1 index)) (add1 index)))\n\
    \            (if (even? (add1 index))\n                (+ 1 (count-vowels (substring\
    \ s (add1 index)) (add1 index)))\n                0))))\n  (count-vowels s 0))\n",
  "  (cond [(empty? s) 0]\n        [(and (char-upper? (car s)) even?) (inc (count_upper\
    \ (cdr s)))]\n        [else 1]))\n", "  (- (length s)\n     (reduce '+ \n    \
    \          (filter (lambda (x)\n                         (and (even? x)\n    \
    \                          (equal? (char-upper x) 'A)))\n                    \
    \   s))))\n", "  (string-length (substring s 0 (string-length s))))\n", "  (cond\
    \ [(null? s)                    0]\n        [(even? (car s)) (+ 1 (count_upper\
    \ (cdr s)))])\n  #_)\n", "  (cond\n    ((= (length s) 0) 0)\n    ((= (length s)\
    \ 2) 0)\n    ((or (not (even? (length s))) (even? (length s)))\n      (count_upper\
    \ s (quotient (length s) 2)))\n    ((equal? (char-code (first s)) (char-code 'A))\
    \ (+ 1 (count_upper s (quotient (length s) 2))))\n    ((equal? (char-code (first\
    \ s)) (char-code 'a')) (+ 1 (count_upper s (quotient (length s) 2))))\n    ((equal?\
    \ (char-code (first s)) (char-code 'B)) (+ 1 (count_upper s (quotient (length\
    \ s) 2))))\n    ((equal? (char-code (first s)) (char-code 'b)) (+ 1 (count_upper\
    \ s (quotient (length s) 2))))\n    ((equal? (char-code (first s)) (char-code\
    \ 'C)) (+ 1 (count_upper s (quotient (length s) 2))))\n    ((equal? (char-code\
    \ (first s)) (char-code 'c)) (+ 1 (count_upper s (quotient (length s) 2))))\n\
    \    ((equal? (char-code (first s)) (char-code 'D)) (+ 1 (count_upper s (quotient\
    \ (length s) 2))))\n    ((equal? (char-code (first s)) (char-code 'd)) (+ 1 (count_upper\
    \ s (quotient (length s) 2))))\n    ((equal? (char-code (first s)) (char-code\
    \ 'E)) (+ 1 (count_upper s (quotient (length s) 2))))\n    ((equal? (char-code\
    \ (first s)) (char-code 'e)) (+ 1 (count_upper s (quotient (length s) 2))))\n\
    \    ((equal? (char-code (first s)) (char-code 'F)) (+ 1 (count_upper s (quotient\
    \ (length s) 2))))\n    ((equal? (char-code (first s)) (char-code 'f)) (+ 1 (count_upper\
    \ s (quotient (length s) 2))))\n    ((equal? (char-code (first s)) (char-code\
    \ 'G)) (+ 1 (count_upper s (quotient (length s) 2))))\n    ((equal? (char-code\
    \ (first s)) (char-code 'g)) (+ 1 (count_upper s (quotient (length s) 2))))\n\
    \    ((equal? (char-code (first s)) (char-code 'H)) (+ 1 (count_upper s (quotient\
    \ (length s) 2))))\n    ((equal? (char-code (first s)) (char-code 'h)) (+ 1 (",
  "  (count\n   (lambda (i j)\n     (and (< i j) (char-property s 'uppercase)))\n\
    \   (list-length s)))\n", "  (let ((i 0) (uv 0))\n    (while s (= i (string-length\
    \ s))\n      (let ((char (string->char (string->list s))))\n        (cond\n  \
    \        [(char=? (char-code char) 65) (set! uv (+ uv 1))]\n          [(char=?\
    \ (char-code char) 97) (set! uv (+ uv 1))]\n          [else (set! i (+ i 1))]))\n\
    \      (i))))", "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) (+ 1 (count\
    \ (lambda (x) (char-code (char x #\\V)) (subseq s 0)))) ]\n    [else (count_upper\
    \ (subseq s 1))]\n  )\n)\n", "  (let loop ((i 0)\n             (count 0))\n  \
    \  (cond ((char=? s #\\a) (set! i (+ i 2))\n           (set! count (1+ count))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\u) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\E) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\o) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\U) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\O) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\G) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\B) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\V) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\W) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\X) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          ((char=? s #\\X) (set! i (+ i 2))\n\
    \           (loop (+ i 2) count))\n          (else\n           (set! count (1+\
    \ count))\n           (loop (+ i 2) count)))))\n", "  (let ((c (length s)))\n\
    \    (cond [(or (= c 0) (= c 2)) (+ 1 (mod 2 c))]\n          [else 0])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
