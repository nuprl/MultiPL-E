name: HumanEval_108_count_nums
language: rkt
prompt: "#lang racket\n\n;; Write a function count_nums which takes a list of integers\
  \ and returns\n;; the number of elements which has a sum of digits > 0.\n;; If a\
  \ number is negative, then its first signed digit will be negative:\n;; e.g. -123\
  \ has signed digits -1, 2, and 3.\n;; >>> (count_nums (list ))\n;; 0\n;; >>> (count_nums\
  \ (list -1 11 -11))\n;; 1\n;; >>> (count_nums (list 1 1 2))\n;; 3\n(define (count_nums\
  \ arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_nums))\n\
  \    (check-equal? (candidate (list )) 0)\n    (check-equal? (candidate (list -1\
  \ -2 0)) 0)\n    (check-equal? (candidate (list 1 1 2 -2 3 4 5)) 6)\n    (check-equal?\
  \ (candidate (list 1 6 9 -6 0 1 5)) 5)\n    (check-equal? (candidate (list 1 100\
  \ 98 -7 1 -1)) 4)\n    (check-equal? (candidate (list 12 23 34 -45 -56 0)) 5)\n\
  \    (check-equal? (candidate (list 0 1)) 1)\n    (check-equal? (candidate (list\
  \ 1)) 1)\n))\n\n(test-humaneval)"
completions: ["  (if (empty? arr) 0\n      (+ 1 (count_nums (rest arr)))))\n", " \
    \ (if (null? arr)\n      0\n      (+ (car (head arr))\n         (count_nums (cdr\
    \ arr))))))\n</code>\nThis code works for a negative number with a signed digit:\
    \ it returns the number of elements which have a negative sum.\n<code>", "  (cond\n\
    \    ((null? arr) 0)\n    ((< (rest arr) (abs (first arr)))\n     (+ 1 (count_nums\
    \ (rest arr))))\n    (else (count_nums (rest arr)))))\n", "  (if (null? arr)\n\
    \      0\n      (+ (if (> (first arr) 0)\n             (first arr)\n         \
    \    (- (- (first arr) 1)))\n         (count_nums (rest arr)))))\n", "  (cond\
    \ ((null? arr) 0)\n        ((null? (cdr arr))\n         (if (< 0 (car arr))\n\
    \             (+ 1 0)\n             (count_nums (reverse (cdr arr))))\n      \
    \   (count_nums (reverse (cdr arr))))\n        (else (count_nums (cdr arr)))))\n",
  "  (define (helper i num_sum)\n    (cond\n      [(zero? i) num_sum]\n      [(>=\
    \ (expt i 3) 0) (helper i (+ num_sum (expt i 3)))]\n      [else (helper (sub1\
    \ i) num_sum)]\n      ))\n  (helper 0 0))\n", "  (let loop ([arr arr] [sum 0]\
    \ [idx 0])\n    (cond [(null? arr) (+ sum idx)]\n          [(> (first arr) 0)\
    \ (loop (rest arr) (+ sum (- first (first arr))) idx)]\n          [else (loop\
    \ (rest arr) (+ sum (- (first arr) (first arr)))\n                      (+ idx\
    \ 1))]))\n", "  (cond\n    ((null? arr) 0)\n    ((< (- (car arr) (car arr)) 0)\n\
    \      (+ (count_nums ((cdr arr))) (* -1 (count_nums ((cdr arr))))))\n    (else\
    \ (count_nums ((cdr arr))))))\n", "  (let loop ((i 0) (result 0))\n    (if (null?\
    \ arr)\n        result\n        (loop (+ i 1) (+ (car arr) result)))))\n</code>\n\
    <|/ a tags=racket,scheme dscore=0 |>\n<| a |>\nHere's another possible solution\
    \ that doesn't use recursion. The advantage of this is that it uses tail recursion,\
    \ so should be faster:\n<code>", "  (cond\n    [(null? arr) 0]\n    [(> (first\
    \ arr) 0) (+ 1 (count_nums (rest arr)))]\n    [else (count_nums (rest arr))]))\n",
  "  (let loop ((counts '()))\n    (cond ((null? arr) (counts))\n          ((number?\
    \ num) (loop (cons (- num (first arr)) counts)))\n          (else (loop (cons\
    \ num counts))))\n    ))\n</code>\n<|/ a |>\n<| a |>\nI guess this could be a\
    \ solution that doesn't use recursion :)\n<code>", "  (cond\n    [(empty? arr)\
    \ 0]\n    [(positive? (first arr)) (+ 1 (count_nums (rest arr)))]\n    [else (count_nums\
    \ (rest arr))]))\n", "  (cond\n    [(empty? arr) 0]\n    [(zero? (first arr))\
    \ (one? (first arr))]\n    [else (+ (count_nums (rest arr)) (count_nums (first\
    \ (rest arr))))]))\n", "  (define (count n acc)\n    (if (< n 0)\n        acc\n\
    \        (count (quotient n 10) (recur (- n 10) acc))))\n  (count (length (filter\
    \ number? arr)) 0))\n", "  (let loop ((x 0) (sum 0))\n    (if (empty? arr)\n \
    \       sum\n        (loop (+ x (first arr)) (+ sum (rest arr))))))\n", "  (if\
    \ (empty? arr)\n      0\n      (+ 1 (count_nums (first arr))))))", "  (letrec\
    \ ([count-nums-aux\n             (lambda (n sum-digits)\n               (cond\n\
    \                 [(zero? n) sum-digits]\n                 [(< sum-digits 0)\n\
    \                  (let [first-sign-digit\n                         (expt n -sum-digits)\n\
    \                         first-digit\n                         (expt first-sign-digit\
    \ -sum-digits)\n                         sum-digits (- sum-digits (* first-digit\
    \ 9))]\n                      (+ count-nums-aux (- n 1) sum-digits))]\n      \
    \           [else (+ count-nums-aux n (+ sum-digits (* first-sign-digit 9)))])))]\n\
    \    (count-nums-aux 0 (expt (count arr) 9))))\n", "  (cond\n    [(empty? arr)\
    \ 0]\n    [(< (first arr) 0) (add1 (count_nums (rest arr)))]\n    [else (add1\
    \ (count_nums (rest arr)))]))\n", "  (cond\n    [(empty? arr) 0]\n    [(> (first\
    \ arr) (second arr))\n     (add1 (count_nums (rest arr)))]\n    [else (add1 (count_nums\
    \ (rest arr)))]))\n", "  (cond\n    [(empty? arr) 0]\n    [(empty? (rest arr))\
    \ (if (< (first arr) 0) (- (first arr) 1) (first arr))]\n    [else (+ (count_nums\
    \ (rest arr)) (first arr))]))\n", "  (cond\n    [(null? arr) 0]\n    [(< (first\
    \ arr) 0) (count_nums (rest arr))]\n    [else (+ 1 (count_nums (rest arr)))]))\n",
  "  (cond\n    [(empty? arr) 0]\n    [(> (first arr) (second arr)) (count_nums (rest\
    \ arr))]\n    [else (count_nums (rest arr))]))\n", "  (if (null? (car arr))\n\
    \      0\n      (+ (last (car arr)) (count_nums (cdr arr)))))\n", "  (if (null?\
    \ (cdr arr))\n      0\n      (+ (* (first arr) (first arr))\n         (count_nums\
    \ (cdr arr)))))\n", "  (if (null? (cdddr arr))\n      (length (map (lambda (i)\
    \ (if (< i (abs i)) (- i)))\n                  (filter positive? arr)))\n    \
    \  (+ 1 (count_nums (cdddr arr)))))\n", "  (count (lambda (x)\n           (let\
    \ ((num (floor (expt x 10))))\n             (if (<= num 0)\n                 (-\
    \ num)\n                 (expt 10 num)))))\n", "  (if (empty? arr)\n      0\n\
    \      (+ 1 (count_nums (sub1 arr))))))\n", "  (- (quotient (- (car arr) 10) 10)\
    \ (- (car arr) 10) (car arr))))\n", "  (if (null? arr)\n      0\n      (let ((sum\
    \ (+ (first arr) (first arr)))\n            (tail (rest arr)))\n        (if (null?\
    \ tail)\n            (if (< sum)\n                (- sum)\n                (count_nums\
    \ (rest tail)))\n            (+ 1 (count_nums (rest tail)))))))\n", "  (cond [(empty?\
    \ arr) 0]\n        [(number? (car arr)) 1]\n        [(positive? (quotient (- (car\
    \ arr)) 10))\n         (count_nums (quotient (- (car arr)) 10))]\n        [else\
    \ (+ 1 (count_nums (cdr arr))))]))\n", "  (count\n   (lambda (x)\n     (if (<\
    \ 0 (mod x 10))\n         (add1 (rem x 10))\n         (add1 (mod x 10))))\n  \
    \ arr))\n", "  (cond\n    [(null? arr) 0]\n    [(negative? (car arr)) (- 1 (count_nums\
    \ (remainder-of (car arr) 10)))]\n    [else (+ 1 (count_nums (rest arr)))]))\n",
  "  (letrec ([f (fn [arr])\n           (define (f acc num)\n             (if (= 0\
    \ num)\n                 (add1 acc)\n                 (f (add1 acc) (quotient\
    \ num 10))))]\n         [sum (lambda (arr acc)\n               (let ([sum (f acc\
    \ 0)]\n                     [head (first arr)])\n                 (if (null? arr)\n\
    \                     acc\n                     (f (sum head) (* (quotient head\
    \ 10)) (first arr)))))]\n         [tail (lambda (arr acc)\n               (let\
    \ ([tail (rest arr)]\n                     [sum (tail acc)])\n               \
    \  (if (null? tail)\n                     acc\n                     (f (sum tail)\
    \ (first tail))))])]\n         [head (lambda (arr acc)\n               (let ([head\
    \ (first arr)])\n                 (if (null? arr)\n                     acc\n\
    \                     (head acc))))])\n    (sum arr 0)))\n", "  (if (null? arr)\n\
    \      '()\n      (add1 (count_nums (rest arr)))))\n", "  (let loop ([n 0] [result\
    \ 0])\n    (if (null? arr)\n        result\n        (loop (+ n 1)\n          \
    \     (if (= (mod n 10) 0)\n                   (+ result 1)\n                \
    \   (loop n (+ result 1)))))))\n", "  (count_nums_aux (length arr) arr))\n", " \
    \ (define (count_nums_helper arr n sum)\n    (cond\n      [(empty? arr) sum]\n\
    \      [(> (first arr) 0) (count_nums_helper (rest arr) (+ n 1) (+ sum (first\
    \ arr)))]\n      [(< 0 (first arr)) (count_nums_helper (rest arr) (+ n 1) (+ sum\
    \ (first arr)))]\n      [else (count_nums_helper (rest arr) 0 (+ sum (first arr)))]))\n\
    \  (count_nums_helper arr 0 0))\n", "  (count-nums-helper arr 0))\n", "  (cond\
    \ [(null? arr) 0]\n        [(number? (car arr)) (add1 (count_nums (cdr arr)))]\n\
    \        [else (sub1 (count_nums (cdr arr)))]))\n", "  (cond\n    [(empty? arr)\
    \ 0]\n    [(positive? (first (first arr))) (+ 1 (count_nums (rest arr)))]\n  \
    \  [else (count_nums (rest arr))]))\n", '  (count_nums_aux (length arr) 0))',
  "  (let ((acc (0))\n        (nums (remove (lambda (n) (and (< n 0) (= (digit-sum\
    \ (abs n)) 0))\n                               (list nums)))))\n    (for-each\
    \ add-digit-sum (nums)\n           (if (null? nums)\n               acc\n    \
    \           (incf acc (digit-sum (abs (first nums))))))))\n", "  (define (count-num\
    \ arr)\n    (cond ((null? arr) 0)\n          ((null? (cdr arr)) (+ (car arr) 0))\n\
    \          (else (+ (car arr) (count-num (cdr arr)))))\n    (count-num (reverse\
    \ arr)))\n  (count-num (reverse arr)))\n", "  (cond\n    [(empty? arr) 0]\n  \
    \  [else (+ (first (last (first arr))) (count_nums (rest arr)))]))\n", "  (cond\n\
    \    ((null? arr) 0)\n    ((< 0 (first arr)) (count_nums (rest arr)))\n    (else\
    \ (+ (count_nums (rest arr)) (count_nums (rest arr)))))\n)\n", "  (let* ((sum\
    \ (sum-of-digits-up arr))\n         (count (count-by (lambda (x) x) (list sum\
    \ 1)))\n         (negate (lambda (x) (- (modulo x 10))))\n         (negate-arr\
    \ (map negate arr)))\n    (cond ((null? arr) 0)\n          ((not (negative? (first\
    \ arr)))\n           (add1 (second (first arr))))\n          ((and (> 0 sum) (<\
    \ 0 sum))\n           (add1 (second (first arr)))\n           (add1 (length (rest\
    \ negate-arr)))\n           (add1 (count_nums (rest negate-arr)))\n          \
    \ (add1 (length (rest negate-arr))))\n          ((and (> 0 sum) (- (first sum)\
    \ (modulo (first arr) 10)))\n           (add1 (second (first arr)))\n        \
    \   (add1 (length (rest negate-arr)))\n           (add1 (count_nums (rest negate-arr)))\n\
    \           (add1 (length (rest negate-arr))))\n          ((and (> 0 sum) (modulo\
    \ (first arr) 10))\n           (add1 (second (first arr)))\n           (add1 (length\
    \ (rest negate-arr)))\n           (add1 (count_nums (rest negate-arr)))\n    \
    \       (add1 (length (rest negate-arr))))\n          (else (+ count (count_nums\
    \ (rest negate-arr)))))))\n", "  (cond [(null? arr) 0]\n        [(> (car arr)\
    \ 0) (+ 1 (count_nums (cdr arr)))]\n        [else (count_nums (cdr arr))]))\n",
  "  (cond [(null? (rest arr)) 0]\n        [(= (remainder (car arr) 10) 0) (+ 0 (count_nums\
    \ (cdr arr)))]\n        [else (count_nums (cdr arr))]))\n", "  (cond\n    [(null?\
    \ arr) 0]\n    [(positive? (first arr)) (+ 1 (count_nums (rest arr)))]\n    [else\
    \ (+ 1 (count_nums (rest arr)))]))\n", "  (foldr (lambda (x y)\n           (if\
    \ (< y 0)\n               (if (< x 0)\n                   (add1 (count_nums (-\
    \ x (- y))))\n                   (add1 (count_nums (- y (- (- x y)))))))\n   \
    \      0 (map (lambda (x)\n                 (digit-sum-to-1 x)))\n         arr))\n",
  "  (cond\n    ((empty? arr) 0)\n    ((odd? (first arr))\n     (if (> (first arr)\
    \ 0)\n         (+ count_nums (rest arr))\n         (count_nums (rest arr))))\n\
    \    ((= (rest arr) 0)\n     (count_nums (rest arr)))))\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [(zero? (car arr)) (car arr)]\n    [else (+ (count_nums (cdr arr))\
    \ (+ (first (cdr arr))\n                                            (first arr)))]))\n",
  "  (let loop ((arr arr) (acc 0))\n    (if (null? arr)\n        acc\n        (let\
    \ ((num (first arr)))\n          (cond ((> num 0)\n                 (loop (rest\
    \ arr)\n                      (+ acc\n                         (+ (if (< num 0)\n\
    \                               (expt -1 num)\n                              \
    \ 0)\n                             num))))\n                ((< num 0)\n     \
    \            (loop (rest arr)\n                      (- acc\n                \
    \         (- (expt -1 num)\n                            num))))\n            \
    \    (else\n                 (loop (rest arr)\n                      acc)))))\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=scheme,racket,recursion |>\n<code>",
  "  (cond\n    [(empty? arr) 0]\n    [(= (- (first arr)) 0) (+ 1 (count_nums (rest\
    \ arr)))]\n    [else (count_nums (rest arr))]))\n", "  (cond ((null? arr) 0)\n\
    \        ((negative? (first arr)) (- 1 (count_nums (rest arr))))\n        (else\
    \ (+ (count_digits (first arr)) (count_nums (rest arr)))))\n))\n", "  (cond\n\
    \    [(null? arr) 0]\n    [(< (first arr) (second arr))\n     (+ (count_nums (rest\
    \ arr)) 1)]\n    [else (+ (count_nums (rest arr)) 1)]))\n", "  (cond\n    ((null?\
    \ arr) 0)\n    ((null? (rest arr)) (length (filter (partial > 0) arr)))\n    (else\
    \ (+ 1 (count_nums (rest arr)))))\n)\n", "  (if (empty? arr)\n      0\n      (let\
    \ ((sum (+ (first arr) (rest (rest arr)))))\n        (if (< sum 0)\n         \
    \   ;; First signed digit of a negative number\n            (- sum (first arr))\n\
    \            (+ 1 (count_nums rest))))))\n", "  (if (empty? arr)\n      0\n  \
    \    (+ (count_nums (cdr arr)) (if (< 0 (first arr))\n                       \
    \         (- (first arr))\n                                0))))\n", "  (cond\
    \ [(null? arr)\n         0]\n        [(positive? (sub1 (first arr)))\n       \
    \  (count_nums (rest arr))]\n        [else\n         (count_nums (rest arr))]))\n",
  "  (cond [(empty? arr) 0]\n        [(positive? (first arr)) (+ 1 (count_nums (rest\
    \ arr)))]\n        [else (+ 1 (count_nums (rest arr)))]))\n", "  (let ([lst (list\
    \ arr)])\n    (define (helper lst acc)\n      (if (null? lst)\n        acc\n \
    \       (helper (cdr lst)\n                (if (> (first lst) 0) (+ acc ((first\
    \ lst) mod 10) (- (first lst) mod 10))\n                    (+ acc ((first lst)\
    \ mod 10))))))\n    (helper lst 0)))\n", "  (define (helper arr)\n    (cond\n\
    \      [(null? arr) 0]\n      [(= 0 (remainder car arr)) (inc (helper (cdr arr)))]\n\
    \      [else (inc (helper (cdr arr)))]))\n  (helper arr))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThanks for your answer. I understand your point, but could you\
    \ please explain why (count_nums ((list -1)) ) == 1 and (count_nums (list -11\
    \ 2 -11 1 -1 -11)) ==3? Why is the result 3 for the second example? I understand\
    \ that in example 2, the sum is 3 but it is not clear why 3 appears in the second\
    \ example. I thought the answer should be 2 since 2 does not have any positive\
    \ sum\n<|/ c |>\n<| c |>\n, I'm just trying to understand what your code is doing\
    \ and how. So (count_nums ((list -1))) should return 0 since there is no digit\
    \ > 0. And since (-11 2 -11 1 -1 -11) only has 1 digit > 0, it should not return\
    \ 3. But it does. Why is that? Thank you so much for your help\n<|/ c |>\n<| c\
    \ |>\nI updated the answer to show you exactly why it works that way. In your\
    \ second example, `(count_nums (list 1 1 2))` returns `3` because the (signed)\
    \ sum of all digits is 3, so `(count_nums (list -11 2 -11 1 -1 -11))` returns\
    \ `3` because the (signed) sum of all digits is 3.\n<|/ c |>\n<| c |>\nThanks\
    \ for your help. I understand why it returns 3 for (count_nums (list -11 2 -11\
    \ 1 -1 -11)). In the second example (count_nums (list 1 1 2)), why does it return\
    \ 3? The sum is 3 but it is not clear why 3 appears in the second example. I thought\
    \ the answer should be 2 since 2 does not have any positive sum. Thanks again\n\
    <|/ c |>\n<| c |>\n, you're not allowed to answer your own questions. If you have\
    \ an additional question, post a new question and I will answer it, but you can\
    \ also edit your original question and append the additional question. Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  (cond\n    [(empty? arr) 0]\n    [(negative?\
    \ (first arr)) (count_nums (rest arr))]\n    [else (+ (count_digits (first arr))\
    \ (count_nums (rest arr)))]))\n", "  (cond ((null? arr) 0)\n        ((> 1 (expt\
    \ (length arr) -1))\n         (+ 1 (count_nums (list (rest arr))))))\n       \
    \ ((positive? (car arr))\n         (+ 1 (count_nums (rest arr))))))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(> (first arr) (second arr)) (+ 1 (count_nums (rest\
    \ arr)))]\n    [else (count_nums (rest arr))]))\n", "  (if (null? arr)\n     \
    \ 0\n      (if (<= (- (car arr)) 0)\n          (+ 1 (count_nums (cdr arr))))))\n\
    </code>\n<|/ a tags=scheme,racket,functional-programming |>\n<| a dscore=0 tags=scheme,racket,functional-programming\
    \ |>\n<code>", "  (* (length (filter (lambda (n)\n                      (or (=\
    \ n 0)\n                          (= (mod n 10) 0)))\n                     arr))\n\
    \     10)) ; 10 is \"ten\"\n</code>\n<code>\n#lang racket\n", "  (let loop ((arr\
    \ arr) (acc 0))\n    (cond\n      [(empty? arr) acc]\n      [(equal? (car (first\
    \ arr)) (floor (/ (caddr arr) (ash (caddr arr))))) (incf acc)]\n      [else (loop\
    \ (cdr arr) (incf acc))])))\n", "  (let ([res (+ 1 (add1 (count_nums (sub1 arr)))))]\n\
    \    (cond\n      [(null? arr) (res)]\n      [(number? arr) res]\n      [(< (car\
    \ (car arr)) 9) (if (< 0 (sub1 (car arr))) (- (car arr) (count_nums (cdr arr)))]\n\
    \      [else (count_nums (cdr arr))])))\n</code>\n<|/ a tags=racket,scheme |>\n\
    <| a tags=racket,scheme |>\nThis is not exactly a complete answer, but it's too\
    \ long for a comment, and I haven't found any complete examples, so I'll post\
    \ it anyway!\nA few things to note before I start.  First, Racket's (cond) doesn't\
    \ quite work the way you might expect in that it takes three arguments.  In particular,\
    \ conditions don't have to be mutually exclusive, and you can have multiple conditions\
    \ that must all be true.\nHere's how you can solve the problem more simply:\n",
  "  (if (null? arr)\n      0\n      (+ 1 (count_nums (rest arr)))))\n", "  (let loop\
    \ ((n 0)\n             (sums #(#f . #f)))\n    (cond\n      ((null? arr) 0)\n\
    \      ((> (first arr) 0) (+ (first arr) (loop (rest arr) (cons (first (rest arr))\
    \ sums))))\n      (else (loop (rest arr) (cons (first (rest arr)) sums))))\n \
    \   (loop (first arr) sums))\n)\n", "  (count\n    (lambda (num)\n      (cond\n\
    \        ((zero? (remainder num 10)) 1)\n        ((< num 0) (sub1 (quotient num\
    \ 10)))\n        (else (- 1)))))\n  (reverse\n   (remove\n    (lambda (num)\n\
    \      (cond\n        ((zero? (remainder num 10)) num)\n        ((< num 0) (-\
    \ num)))\n      arr))))\n", "  (cond ((null? arr) 0)\n        ((> (car arr) 0)\
    \ (+ (count_nums (cdr arr)) (count_nums (- arr 1))))\n        (else (count_nums\
    \ (- arr 1)))))\n", "  (if (empty? arr)\n      0\n      (+ 1 (count (filter (lambda\
    \ (x)\n                            (if (= (modulo (car x) 10) 0) (+ 0 (modulo\
    \ (car x) 10))\n                              (modulo (car x) 10)))\n        \
    \                  (map list (reverse arr)))))))\n", "  (cond [(null? arr) 0]\n\
    \        [(< (car arr) 0)\n         (let ([s (reverse (cdr arr))])\n         \
    \  (count_nums (map #(- car %) s)))]\n        [else\n         (+ (count_nums (map\
    \ #(+ car %) arr))\n            (count_nums (map #(- car %) arr)))]))\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThank you. Very nice implementation! I hope it can\
    \ be of help to others.\n<|/ c |>\n<| c |>\nSorry I'm late but I'm trying to understand\
    \ why you made the `count_nums` function recursive. I thought a recursive function\
    \ always had to call itself. What if I want to write a function that returns `null`\
    \ if the list is empty? How would I do that?\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  (cond\n    [(empty? arr) 0]\n    [(number? (first arr)) (add1 (count_nums (rest\
    \ arr)))]\n    [else (add1 (count_nums (rest arr)))]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThank you very much!  Very helpful.  One thing I'm having trouble\
    \ with is understanding how to make each element of the list positive.  My thought\
    \ was to use a list comprehension on the list of integers and then convert each\
    \ element to positive.  I'm having trouble doing this.  I can find examples of\
    \ how to make a list of positives, but not how to do both in the same expression.\
    \  Is this even possible?\n<|/ c |>\n<| c |>\nI've expanded my answer with one\
    \ possible implementation\n<|/ c |>\n<| c |>\nThanks again!  I appreciate it!\
    \  What is the advantage of using a map over a recursive function here?  Can the\
    \ map function be used in place of a recursive function?  Apologies if these are\
    \ obvious questions!\n<|/ c |>\n<| c |>\nThe advantage of `map` is that it gives\
    \ you more control over the result. For example, if you wanted to reverse the\
    \ list before counting the numbers, `map` would be more efficient than `(define\
    \ (count_nums arr) (count_nums (reverse arr)))`\n<|/ c |>\n<| c |>\nAh, ok!  Thank\
    \ you!\n<|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nI guess the easiest way\
    \ to approach this problem would be to iterate over the array and apply the function\
    \ recursively to the rest of the list. This would require 2 passes (the original\
    \ array and the recursive function) which isn't very efficient but should work.\n\
    <code>", "  (let loop ((arr (list arr))\n             (num-so-far 0)\n       \
    \      (acc 0))\n    (cond\n      [(empty? arr) num]\n      [(number? (first arr))\n\
    \       (loop (rest arr) (+ num (first (first arr))) acc)]\n      [else (loop\
    \ (rest arr)\n                 (+ num (modulo (first arr) 10))\n             \
    \    (+ acc 1)))]))\n", "  (let loop ([n 0] [nums '()] [sums '()])\n    (cond\
    \ [(empty? arr) (+ 1 (length sums))]\n          [(integer? (first arr)) (loop\
    \ (rest arr) nums sums)]\n          [(let ([num (first arr)])\n            (let\
    \ ([sum (* 10 n)]\n                  (rest (rest arr)))\n              (loop (+\
    \ n 1) (cons num nums) (cons sum sums)))]\n          [else (loop (+ n 1) (cons\
    \ (first arr) nums) (cons (+ sum (first arr)) sums))]))))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "  (if (empty? arr)\n      0\n      (+ (first\
    \ arr) (count_nums (rest arr)))\n    )\n  )", "  (cond\n    ((null? arr) 0)\n\
    \    ((zero? (first arr)) (+ 0 (count_nums (rest arr))))\n    ((zero? (rest (rest\
    \ arr))) \n      (+ 1 (count_nums (rest arr))))\n    (else (count_nums (rest arr)))))\n",
  "  (if (null? arr)\n      0\n      (+ (length (filter (lambda (n) (> n (count_nums\
    \ (rest arr))))\n                        (map number->string arr))))))\n", " \
    \ (if (null? arr)\n      0\n      (+ (- (car arr) (car arr)) (count_nums (cdr\
    \ arr)))))\n", "  (if (null? arr)\n      0\n      (+ (take-int arr) \n       \
    \  ((count_nums (drop-int arr)))))) ;; <-- note the parenthesis!\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=0 |>\nI find your problem to be a nice puzzle. Here's\
    \ my solution:\n<code>", "  (cond\n    [(empty? arr) 0]\n    [else (+ (first (digits\
    \ arr))\n            (count_nums (rest arr)))]))\n", "  (car (filter (lambda (num)\n\
    \                   (and (number? (car num))\n                        (> (expt\
    \ (car num) -1) 0)\n                        (> (expt (car num) -2) 0)))\n    \
    \             arr)))\n", "  (cond [(empty? arr) 0]\n        [(<= (car arr) 0)\
    \ (+ 1 (count_nums (rest arr)))]\n        [else (count_nums (cdr arr))]))\n",
  "  (cond\n    [(empty? arr) 0]\n    [(number? (first arr)) (+ (count_nums (rest\
    \ arr)) (count_nums (first arr)))]\n    [else (count_nums (rest arr))]))", " \
    \ (define (helper arr acc)\n    (cond\n      [(empty? arr) acc]\n      [(< (first\
    \ arr) (- 0 (+ (first arr) (second arr))))\n       (helper (rest arr) (+ acc 1))]\n\
    \      [(> (first arr) (- 0 (+ (first arr) (second arr))))\n       (helper (rest\
    \ arr) acc)]\n      [else (helper (rest arr) acc)]\n    )\n  )\n  (helper arr\
    \ 0 (length arr)))\n", "  (let ((cnt 0))\n    (for (x (in-list arr))\n      (if\
    \ (>= x 0)\n          (if (>= (- x 0) 0)\n              (let ((s (sum (digit-nums\
    \ x))))\n                (if (> (+ s cnt) 0)\n                    (set! cnt (+\
    \ s cnt)))))\n        (set! cnt cnt))\n    cnt))\n</code>\n<|/ a dscore=2 tags=racket,scheme\
    \ |>\n<| c |>\nThe `digit-nums` function just converts the numbers to their digits\
    \ with leading zeros removed. I'm only interested in the digits themselves, and\
    \ only if the number of digits is greater than zero.\n<|/ c |>\n<| c |>\n: Thanks\
    \ for your comment. I updated my answer with the digit-nums function.\n<|/ c |>\n\
    <| c |>\nThank you for answering! But I am not looking for a solution that uses\
    \ recursion, instead I am looking for a solution that only uses the \"for\" loop.\
    \ Is this possible?\n<|/ c |>\n<| c |>\n: If you need a non-recursive solution,\
    \ then the solution provided by is a good way to go. Recursion is best when you\
    \ need to count the number of nodes in a tree, or to iterate through an input\
    \ list to compute some kind of value. I'm glad to see your question made it clear\
    \ that you were not interested in recursion.\n<|/ c |>\n<| c |>\n: In response\
    \ to your edit, I believe that my solution is not the most elegant solution. Your\
    \ solution is very concise. I'm surprised that the \"for\" loop is the only way\
    \ to do this (it seems to be the most efficient).\n<|/ c |>\n<| a |>\nSince you're\
    \ using Racket, you could use recursion: \n<code>", "  (if (null? arr) 0\n   \
    \   (+ (mod ((first arr) 1) 10)\n         (count_nums (rest arr)))))\n", "  (cond\
    \ ((null? arr) 0)\n        ((= (first arr) 0) 1)\n        (else (count_nums (rest\
    \ arr))))\n  )\n", "  (cond\n    [(empty? arr) 0]\n    [(digit-sum 0 arr) (+ 1\
    \ (count_nums (rest arr)))]\n    [else (count_nums (rest arr))]))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(not (positive? (first arr)))\n     (- (count_nums\
    \ (rest arr)))]\n    [else (+ 1 (count_nums (rest arr)))]))\n", "  (if (null?\
    \ arr)\n      0\n      (+ (digits-sum (sub1 (car arr)))\n         (count_nums\
    \ (cdr arr)))))\n", "  (let loop ((arr (rest arr)) (nums 0))\n    (if (null? arr)\
    \ nums\n      (loop (rest arr) (add1 (loop (rest arr) (add1 nums))))))) ;; tail\
    \ recursion\n", "  (cond\n    ((null? arr) 0)\n    ((= (modulo (first arr) 10)\
    \ 0) (+ 1 (count_nums (rest arr))))\n    (else (count_nums (rest arr)))))\n",
  "  (let ((result 0))\n    (do ((i arr (cdr i)))\n        ((null? i)\n         (set!\
    \ result (+ result 1))\n         (set! i\n          (sub1 (car i))))\n      (while\
    \ (> (first i) 0)\n        (set! i (- i\n                  (/ (first i) 10))))\n\
    \    result))\n", "  (if (null? arr)\n      0\n      (+ 1 (count_nums (rest arr))))\n\
    \  )\n", "  (let ([count 0])\n    (for-each ([n arr])\n              (when (integer?\
    \ n) (set! count (+ n count))))\n    (if (zero? count)\n        0\n        count)))\n",
  "  (cond [(empty? arr) 0]\n        [(positive? (first arr)) (+ 1 (count_nums (rest\
    \ arr)))]\n        [else (+ (count_nums (rest arr)) (first-num-at-least-neg (first\
    \ arr)))]))\n", "  (cond [(null? arr) 0]\n        [(> (car arr) 0) (+ 1 (count_nums\
    \ (remainder arr 10)))]\n        [else (count_nums (rest arr))]))\n", "  (if (empty?\
    \ arr)\n      0\n      (+ (if (positive? (first arr)) (first arr) (- (first arr)))\n\
    \         (count_nums (rest arr)))))\n", "  (cond [(null? arr) 0]\n        [(<\
    \ 0 (car arr)) (count_nums (remainder arr (first arr)))]\n        [else (+ 1 (count_nums\
    \ (rest arr)))]))\n", "  (cond\n    ((empty? arr) 0)\n    ((> (first arr) 0) (+\
    \ (count_nums (rest arr)) 1))\n    (else (count_nums (rest arr)))))\n", "  (cond\
    \ ((null? arr) 0)\n        ((>= (modulo (first arr) 10) 0) (+ 1 (count_nums (rest\
    \ arr))))\n        (else (count_nums (rest arr)))))\n", "  (if (empty? arr)\n\
    \      0\n      (+ (if (> (car arr) 0)\n             (* 10 (char-to-int (car arr)))\n\
    \             (* 10 #(- #\\0 (char-to-int (car arr))))\n           0)\n      \
    \   (count_nums (cdr arr)))))\n", "  (cond [(empty? arr)\n         0]\n      \
    \  [(< (first arr) 0)\n         (+ (first arr) 1)\n         (+ (count_nums (rest\
    \ arr)) (- 1 (first arr)))]\n        [else\n         (+ (count_nums (rest arr))\
    \ (- 1 (first arr)))]))\n", "  (cond [(null? arr) 0]\n        [(> (first arr)\
    \ 0) (+ 1 (count_nums (rest arr)))]\n        [else (count_nums (rest arr))]))\n\
    </cell>\n<cell>", "  (if (null? arr)\n      '()\n      (+ (count-nums (rest arr))\n\
    \         (if (> (first-digit (car arr)) 0)\n              (first-digit (car arr))\n\
    \              0)))\n", "  (* (+ 1 (- 1 (foldl (lambda (x acc) (if (< 0 (mod x\
    \ 10)) (- acc 1) acc) (+ acc 1))) 0 (length arr)))\n  ;; ...\n  )", "  (cond [(empty?\
    \ arr) (empty)]\n        [(null? (rest arr)) (add1 0 (- (first arr) 10))]\n  \
    \      [else (add1 0 (+ (first arr) (count_nums (rest arr))))]))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(zero? (first arr)) (add1 (count_nums (rest arr)))]\n\
    \    [else (add1 (count_nums (rest arr))) (add1 (count_nums (rest arr)))]))\n",
  "  (let loop ((arr (if (empty? arr) '() arr)))\n    (if (null? arr)\n        '0\n\
    \        (if (zero? (sum (first arr)))\n            (+ 1 (loop (rest arr)))\n\
    \            (loop (rest arr)))))\n)", "  (let loop ([sum (car arr)])\n    (if\
    \ (empty? arr)\n        0\n        (if (< sum (/ (remainder sum (- 10 (first arr)))\n\
    \                       (remainder sum (first arr))))\n            (+ 1 (loop\
    \ (+ sum (first arr)))\n            (loop (+ sum (first arr)))\n            0)))\n\
    \  (loop 0)))\n", "  (cond [(null? arr) 0]\n        [(positive? (car arr)) (+\
    \ 1 (count_nums (cdr arr)))]\n        [else (+ (car arr) (count_nums (cdr arr)))]))\n",
  "  (cond\n    [(null? arr) 0]\n    [(zero? (car arr)) (+ 1 (count_nums (cdr arr)))]\n\
    \    [else (+ (count_nums (car arr)) (count_nums (cdr arr)))]))\n", "  (define\
    \ (helper sum cur-num)\n    (cond\n      [(< sum 0) (cond\n                  \
    \     [(< cur-num 0)\n                        (helper sum (- cur-num))\n     \
    \                  ]\n                       [else (+ sum cur-num)])]\n      [else\
    \ (+ sum cur-num)]))\n  (helper 0 (first arr)))\n", "  (if (empty? arr)\n    \
    \  '0\n      (if (negative? (first arr))\n          (+ (* (first arr) (count (first\
    \ arr)))\n             (count_nums (rest arr)))\n          (+ (* (first arr) (count\
    \ (first arr)))\n             (count_nums (rest arr))))))\n", "  (define (helper\
    \ lst sum)\n    (if (null? lst)\n        0\n        (if (< sum (sum-digit (first\
    \ lst)))\n            (+ 1 (helper (rest lst) sum))\n            (helper (rest\
    \ lst) sum))))\n  (helper arr 0))\n", "  (cond ((null? arr) 0)\n        ((< (first\
    \ arr) (sum (rest arr)))\n         (+ 1 (count_nums (rest arr))))\n        (else\
    \ (count_nums (rest arr)))))\n</cell>\n<code language=dyalog-kernel>", "  (define\
    \ (helper n acc)\n    (cond [(null? n) acc]\n          [(< 0 (first n)) (helper\
    \ n (add1 acc))]\n          [else (helper (rest n) (add1 acc))]))\n  (helper arr\
    \ 0))\n", "  (cond\n    ((null? arr) 0)\n    ((odd? (first arr)) (count_nums (rest\
    \ arr))\n     (add1 (count_nums (rest arr))))))\n", "  (define (loop lst)\n  \
    \  (cond\n      [(empty? lst) 0]\n      [(positive? (first lst)) (+ 1 (loop (rest\
    \ lst)))]\n      [else (loop (rest lst))]))\n  (loop (reverse arr)))\n", "  (count_nums-helper\
    \ arr 0 (car (car arr))))\n", "  (cond\n    [(empty? arr) 0]\n    [(positive?\
    \ (first arr)) (+ 1 (count_nums (rest arr)))]\n    [else (count_nums (rest arr))]))\n\
    </cell>\n<code language=racket-language>\n#lang racket\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [(positive? (first arr)) (+ 1 (count_nums (rest arr)))]\n    [else\
    \ (count_nums (rest arr))]))\n", "  (let ([sum (apply + arr)])\n    (cond\n  \
    \    [(< sum 0) 0]\n      [(< sum (floor sum)) 1]\n      [else (+ 1 (count_nums\
    \ (/ (- sum 1) 10) (floor sum)))])))\n", "  (if (null? arr)\n      0\n      (+\
    \ (* (modulo (first arr) 10) (count_nums (rest arr)))\n         (count_nums (rest\
    \ arr)))))\n", "  (define (helper nums sum)\n    (cond\n      [(empty? nums) (if\
    \ (< sum 0) (+ sum 1) 0)]\n      [(zero? (first nums)) (helper rest (+ sum (first\
    \ (rest nums))))]\n      [else (helper (rest nums) (+ sum (first (rest nums))))]\n\
    \    ))\n  (helper arr (+ (first arr) 1)))\n</code>\n<|/ a |>\n<| c |>\nThanks,\
    \ I haven't thought about that way. I'll try to work it out myself and accept\
    \ your answer if everything goes well.\n<|/ c |>\n<| a dscore=2 |>\nThe problem\
    \ is that the algorithm does not work if you consider that numbers in the list\
    \ are composed of more than one digit, because the recursion stack does not return\
    \ to the previous recursive call, while in fact it should be \"resumed\" when\
    \ the first digit is consumed.\nI wrote a working implementation below. I think\
    \ the code is pretty easy to understand.\n<code>", "  (cond\n    [(empty? arr)\
    \ 0]\n    [(> (first arr) (second arr)) (+ 1 (count_nums (rest arr)))]))\n", " \
    \ (count\n   (lambda (x)\n     (if (negative? x)\n         (* x (expt 2 (floor\
    \ (car x)) 10)))\n       0))\n  (cdr arr))\n", "  (cond\n    ((empty? arr) (error\
    \ \"count_nums expects a non-empty list\"))\n    ((number? (car arr)) (+ (count_nums\
    \ (cdr arr)) 1))\n    (else (count_nums (append (cdr arr) (list (car arr)))))))",
  "  (cond ((null? arr) 0)\n        ((> (first arr) (second arr)) 1)\n        (else\
    \ (+ 1 (count_nums (rest arr)))))\n)\n", "  (count_nums-iter arr 0 0))\n", " \
    \ (if (null? arr)\n      0\n      (let ([num-sum (+ (first arr) (second arr) (*\
    \ (third (first arr)) (fourth (first arr)))) ])\n        (if (< num-sum 10)\n\
    \            (+ 1 (count_nums (rest arr)))\n            (count_nums (rest arr))\n\
    \            )\n        )\n      )\n)\n", "  (cond ((null? arr) 0)\n        ((<\
    \ 0 (car arr)) (count_nums (rest arr)))\n        (else (+ 1 (count_nums (rest\
    \ arr))))))\n</code>\nThis approach has two advantages:\n\nIt doesn't use any\
    \ global variables.\nIt uses recursive functions.\n\nI haven't tested this code;\
    \ let me know if there are any problems.\n<|/ a dscore=0 |>\n<| c |>\nI forgot\
    \ to mention that I was supposed to write it with recursion, without using the\
    \ list function. My professor has told us this is allowed. But thank you very\
    \ much for your help! I'm very new to Racket and don't really understand how to\
    \ use it.\n<|/ c |>\n<| c |>\nNo problem! I believe I've corrected the answer\
    \ to account for recursion. Let me know if it works.\n<|/ c |>\n<| a tags=racket,scheme,recursion\
    \ |>\n<code>", "  (cond\n    [(null? arr) 0]\n    [(positive? (car arr)) (+ 1\
    \ (count_nums (cdr arr)))]\n    [else (count_nums (append (list (car arr)) (cdr\
    \ arr)))]))\n", "  (if (null? arr)\n      0\n      (+ 1 (count_nums (rest arr))))))\n",
  "  (cond\n    [(empty? arr) 0]\n    [(number? (first arr))\n     (if (> (first arr)\
    \ (second arr))\n         (count_nums (rest arr))\n         (count_nums (cons\
    \ (first arr) (cons (first arr) (count_nums (rest arr)))))]\n    [else (count_nums\
    \ (rest arr))]))\n", "  (cond ((null? arr) 0)\n        ((> (first arr) 0) (+ 1\
    \ (count_nums (rest arr))))\n        (else (count_nums (rest arr)))))\n", "  (if\
    \ (null? arr)\n      0\n      (+ (first (filter (lambda (x) (>= (digit-sum (first\
    \ arr)) 0)) arr))\n         (count_nums (rest arr)))))\n", "  (if (null? (car\
    \ arr))\n      0\n      (if (positive? (car arr))\n          (+ 1 (count_nums\
    \ (cdr arr)))\n          (+ 1 (count_nums (- car arr))))))\n</cell>\n<code language=dyalog-kernel>",
  "  (- (* (count-digit arr) 10)\n     (count-digit (drop-last-digit arr))))\n", " \
    \ (if (null? arr)\n      0\n      (+ (car (last arr))\n         (if (> (first\
    \ arr) 0)\n             (count_nums (filter (lambda (x) (< x 0)) (rest arr))\n\
    \             0)))\n  )\n)\n</cell>\n<cell>\n#lang racket", "  (cond [(empty?\
    \ arr) 0]\n        [(or (>= (first (first arr)) 0)\n             (>= (first (first\
    \ (first arr)))\n                   (second (first arr)))\n             (= (first\
    \ (first (first arr)))\n                   (second (first (first arr))))\n   \
    \          (< 0 (first (first (first arr)))))\n         (+ (count_nums (rest arr))\n\
    \            (if (>= (length (first arr)) 3)\n                (count_nums (rest\
    \ arr)))]\n        [else (count_nums (rest arr))]))\n", "  (cond [(null? arr)\
    \ 0]\n        [(list? (car arr)) (count_nums (cdr arr))]\n        [else (if (>\
    \ (digits (car arr)) 0) (+ 1 (count_nums (cdr arr)))\n                (count_nums\
    \ (cdr arr)))]))\n</cell>\n<text>\nExercise: Write a procedure which can add up\
    \ all the digits in the given number.\n\n</text>\n<cell>", "  (let ((sums ()))\n\
    \    (for-each (lambda (num)\n                (cond ((negative? num) (set-sign\
    \ (first num) (- (first num))))\n                      ((number? num)\n      \
    \                 (cond ((< (+ (first num) 1) 10)\n                          \
    \     (add-to-sums (- (first num) 1))\n                               ((= (+ (first\
    \ num) 1) 10)\n                               (add-to-sums (+ (first num) 1)))\n\
    \                               (else (add-to-sums (first num)))))\n         \
    \             (else (add-to-sums (first num)))))\n              arr)\n    (length\
    \ (filter (lambda (sum) (> sum 0)) sums))))\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nIf it's an interesting problem and I didn't want to do my homework for me,\
    \ I could post the solution to [this problem](http://rosettacode.org/wiki/Counting_digits_of_a_integer#Scheme)\n\
    <|/ c |>\n<| c |>\n: Thanks for the link. I'll take a look at it when I get home\
    \ tonight and post some code.\n<|/ c |>\n<| a tags=scheme,racket |>\nThis was\
    \ my solution, using only basic procedures (I guess there might be better ways\
    \ to write this)\n<code>", "  (if (or (null? arr) (null? (cdr arr)))\n      0\n\
    \      (+ (* 1 (+ l (count-digits (car arr))))\n         (count_nums (cdr arr)))))\n",
  "  (if (null? arr)\n      0\n      (+ (digit-sum (car arr))\n         (count_nums\
    \ (cdr arr)))))\n", "  (if (null? arr)\n      0\n      (+ 1 (count_nums (cdr arr))))))\n\
    </cell>\n<cell>", "  (count\n   (lambda (n)\n     (and\n      (< n 0)\n      (>\
    \ (expt n 10) (expt 10 9)))) arr))\n", "  (cond\n    [(empty? arr) 0]\n    [(number?\
    \ first) (+ 1 (count_nums (rest arr)))]\n    [(negative? (first arr))\n     (count_nums\
    \ (rest arr))]))\n", "  (if (null? arr)\n      0\n      (let loop ((total (add1\
    \ (add1 (car arr))))\n                (arr (cdr arr)))\n        (if (null? arr)\n\
    \            total\n            (loop (add1 total) (cdr arr)))))\n", "  (cond\n\
    \    ((null? arr) 0)\n    ((and (integer? (car arr)) (< 0 (modulo (modulo (car\
    \ arr) 10)\n                                                (modulo (cdr arr)\
    \ 10))))\n     (+ 1 (count_nums (cdr arr))))\n    (else\n     (count_nums (cdr\
    \ arr)))))\n", "  (cond\n    [(empty? arr) 0]\n    [(>= (- (first arr)) 0)\n \
    \    (+ (first (last arr)) (count_nums (rest arr)))]\n    [else (+ (first (last\
    \ arr)) (count_nums (rest arr)))]))\n", "  (cond\n    [(empty? arr) 0]\n    [(not\
    \ (> (first arr) 0)) 1]\n    [else (+ 1 (count_nums (rest arr)))]))\n</code>\n\
    <|/ a tags=racket,recursion,functional-programming dscore=1 |>\n<| a dscore=0\
    \ |>\nHow about this, assuming that the first digit will always be positive and\
    \ larger than the second digit?\n<code>", "  (if (null? arr)\n      0\n      (let\
    \ ([nums (num-arr (car arr))])\n        (if (= (sum-digits (rest nums)) 0)\n \
    \           (+ 1 (count_nums (rest arr)))\n            (count_nums (rest arr))\n\
    \        )\n      )\n  )\n)\n", "  (define (loop n)\n    (cond ((< n 0) 0)\n \
    \         ((digit-sum? n arr) 1)\n          (else (+ 1 (loop (quotient n 10))))))\n\
    \  (loop (length arr)))\n", "  (cond [(or (null? arr) (empty? arr)) 0]\n     \
    \   [(positive? (first arr)) (+ (count_nums (rest arr)) (positive? (first arr)))]\n\
    \        [else (+ (count_nums (rest arr)) (count_nums (rest arr)))]))\n", "  (let\
    \ loop ((arr (reverse arr)))\n    (cond ((null? arr) 0)\n          ((< 0 (first\
    \ arr)) (+ (count_nums (rest arr)) 1))\n          (else (loop (rest arr)))))\n\
    </code>\n<|/ a tags=recursion,racket,scheme |>\n<| c |>\nThe question is tagged\
    \ R5RS, not R7RS. As it happens, the R7RS solution was posted by me 3 hours ago:\
    \ http://stackoverflow.com/questions/13122943/racket-counting-positive-numbers-and-negative-numbers-in-a-list\n\
    <|/ c |>\n<| c |>\n: Yes, but the solutions provided are not R7RS and they were\
    \ not posted by me. I thought it would be a nice thing to share in case somebody\
    \ else came here looking for a solution that uses R7RS. :)\n<|/ c |>\n<| c |>\n\
    I haven't read the R7RS version yet, although I have read some of R7RS. I am sure\
    \ it will help me to understand how to do some problems. :)\n<|/ c |>\n<| a tags=recursion,racket,scheme\
    \ dscore=1 |>\nHere's another solution, using only recursion:\n<code>", "  (if\
    \ (null? arr)\n      0\n      (+ 1 (count_nums (rest arr))))))\n", "  (let loop\
    \ ((lst (reverse arr))\n             (cnt 0))\n    (if (null? lst)\n        cnt\n\
    \        (loop (rest lst)\n               (add1 cnt)))))\n", "  (define (loop\
    \ arr num)\n    (if (null? arr)\n        0\n        (if (> (cdr num) 0)\n    \
    \        (+ (loop (cdr arr) (car arr)) (loop (cdr arr) (- (cdr num) 10)))\n  \
    \          (loop (cdr arr) (car arr)))))\n  (loop (reverse arr) (first arr)))\n",
  "  (if (null? arr)\n      0\n      (+ (car arr)\n         (count_nums (cdr arr)))))\n",
  "  (define (sum-digits num)\n    (if (< num 0)\n        (- (car num) (abs num))\n\
    \        (car num)))\n  (+ (if (> (length arr) 0)\n          (sum-digits (sub1\
    \ (car arr)))\n          0))\n  (+ (if (< (length arr) 1)\n          (sum-digits\
    \ (sub1 (cdr arr)))\n          0)))\n", "  (cond\n    [(empty? arr) 0]\n    [(positive?\
    \ (first arr)) (count_nums (rest arr))]\n    [else (count_nums (rest arr))]))\n",
  "  (let ((sum-arr (map #(mod (incf (mod (car arr) 10) 10)) arr)))\n    (if (null?\
    \ (rest arr))\n        0\n        (+ 1\n           (if (> (car arr) 0)\n     \
    \          (let ((sum (- sum-arr (car arr))))\n                 (if (< (- sum)\
    \ 0)\n                     (+ sum (count_nums (cdr arr)))\n                  \
    \   (count_nums (cdr arr)))\n                 (count_nums (cdr arr)))\n      \
    \         (count_nums (cdr arr)))\n           )\n         )\n       )\n     )\n",
  "  (count\n   (lambda (n)\n     (if (zero? n)\n         0\n         (let ((sum (if\
    \ (positive? n) (digit-sum n) 0)))\n           (when (> sum 0)\n             (+\
    \ 1 (count\n                    (lambda (x)\n                      (if (positive?\
    \ x)\n                          (digit-sum x)\n                          0))\n\
    \                     arr)))\n           0))))\n", "  (define (helper arr)\n \
    \   (cond\n      [(empty? arr) 0]\n      [(< 0 (first arr)) (helper (rest arr))]\n\
    \      [(zero? (first arr)) (helper (rest arr))]\n      [else (+ 1 (helper (rest\
    \ arr)))]))\n  (helper (reverse arr)))\n", "  (if (null? arr)\n      0\n     \
    \ (+ 0 (+ (first (first arr)) (count_nums (rest arr))))))\n", "  (cond ((empty?\
    \ arr) 0)\n        ((> (first arr) (first arr (rest arr)))\n         (count_nums\
    \ (rest arr)))\n        (else (+ 1 (count_nums (rest arr))))))\n", "  (if (null?\
    \ arr)\n      0\n      (+ 1 (count_nums (rest arr))))))\n", "  (count_nums_aux\n\
    \   (lambda (n accum)\n     (if (< n 0) accum\n         (count_nums_aux (- n 1)\
    \ (+ accum n))))\n   0 arr))\n", "  (define (helper arr)\n    (if (null? arr)\n\
    \        (length arr)\n        (helper (cdr arr)\n                 (+ (car arr)\
    \ (- car arr))))))\n  (helper arr))\n", "  (if (null? arr)\n      '0\n      (+\
    \ (car arr) (count_nums (cdr arr)))))\n", "  (cond\n    ((null? arr) 0)\n    ((not\
    \ (number? arr)) 0)\n    ((equal? (add1 (car arr)) (- (car (rest arr))))\n   \
    \  (+ 1 (count_nums (rest arr))))\n    (else (count_nums (rest arr)))))\n", " \
    \ (if (null? arr)\n      0\n      (let ([acc (+ (car arr) (count_nums (cdr arr)))]\n\
    \            [remainder (modulo (car arr) 10)])\n        (if (> acc 0)\n     \
    \       (add1 acc)\n            (add1 (- remainder 10))))))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n\"...the second loop counts all digits > 0, not only ones that\
    \ are positive.\"  I think you meant \"...the first loop counts all digits > 0,\
    \ not only ones that are positive.\"  Also, your code is not correct.  Try it:\
    \ `(count_nums (list 1 2 -3 -4 5))`.  It outputs `1`.\n<|/ c |>\n<| c |>\nThanks\
    \ for the comment. I didn't mean to include a negative number in the first loop.\
    \ I just edited my answer to include a solution for this.\n<|/ c |>\n<| c |>\n\
    Ah I see, your algorithm is still wrong.  Try `(count_nums (list 1 2 -3 -4 -5\
    \ 6))`.\n<|/ c |>\n<| a |>\nThis answer is in Racket.\nFirst, note that in Scheme,\
    \ counting loops are expressed using recursion, and that recursion must be expressed\
    \ using tail recursion.  Tail recursion eliminates many of the problems with recursion\
    \ in Scheme.  (Tail recursion eliminates certain types of stackoverflows, for\
    \ example, when the recursion unwinds to a depth of some limit.)\nThe standard\
    \ idiom for counting loops is:\n<code>", "  (if (null? arr)\n      0\n      (if\
    \ (negative? (car arr))\n          (- 1 (count_nums (list (- car arr))))\n   \
    \       (+ 0 (count_nums (cdr arr)))))) ;; <-- #lang racket\n", "  (count_nums_aux\
    \ (first arr) (- (rest arr) 0)))\n", "  (cond ((null? arr) 0)\n        ((= (-\
    \ (first arr)) 0) (+ 1 (count_nums (rest arr))))\n        (else (+ (count_nums\
    \ (rest arr)) (count_nums (rest arr))))))\n</code>\n<|/ a dscore=2 tags=recursion,racket,scheme,functional-programming\
    \ |>\n<| c |>\nThat helps somewhat, but what if you have a negative number with\
    \ a negative first digit? E.g. -3 would be counted as a negative number with a\
    \ negative first digit. So your answer here would need to be -2 for that. Is there\
    \ a way to account for that negative number in there?\n<|/ c |>\n<| c |>\nI realized\
    \ my solution is wrong for the first case, let me fix it\n<|/ c |>\n<| a tags=recursion,racket,scheme,functional-programming\
    \ |>\n<code>", "  (count\n   (lambda (x)\n     (and (number? x)\n          (>\
    \ (length (string->list (number->string x))) 1)\n          (> (apply + x) (length\
    \ (string->list (number->string x)))) ))\n   arr))\n", "  (cond\n    [(empty?\
    \ arr) 0]\n    [(> (first arr) (first arr)) (+ 1 (count_nums (rest arr)))]\n \
    \   [else (count_nums (rest arr))]))\n", "  (if (null? arr)\n      0\n      (+\
    \ (count_nums (first arr))\n         (count_nums (rest arr)))))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(null? arr) (error '(list \"Argument of list should\
    \ be a list.\"))]\n    [else (+ 1 (count_nums (rest arr)))]))\n", "  (let ([n\
    \ 0]\n        [sum (first arr)])\n    (if (empty? arr)\n        n\n        (if\
    \ (< sum 0)\n            (let ([digit (first (rest arr))]\n                  [newsum\
    \ (- sum (first digit))])\n              (set! sum (- newsum 0))\n           \
    \   (set! n (+ n 1))\n              (if (> newsum 0)\n                  (count_nums\
    \ arr)\n                  (count_nums (rest arr)))\n              sum)\n     \
    \       (count_nums arr)\n            sum))))\n", "  (count\n   (lambda (x)\n\
    \     (if (< (digit-sum (reverse x)) 0)\n         (- 1 (digit-sum (reverse x)))))\n\
    \   arr))", "  (cond [(empty? arr) 0]\n        [(positive? (first arr)) (+ (count_nums\
    \ (rest arr)) (digits (first arr)))]\n        [else (count_nums (rest arr))]))",
  "  (if (null? arr)\n      0\n      (+ (car arr)\n         (count_nums (cdr arr)))))\n",
  "  (cond\n    [(empty? arr) 0]\n    [else (+ (*\n               (expt (- (first\
    \ arr) 1) 10)\n               (first arr))\n            (count_nums (rest arr))]))\n\
    </code>\n<|/ a |>\n<| a |>\nStraight from here in Racket:\n<code>", "  (cond\n\
    \    [(empty? arr)               0]\n    [(not (integer? (first arr)))   (count_nums\
    \ (rest arr))]\n    [(and (positive? (first arr))\n           (positive? (rest\
    \ arr)))\n     (+ (count_nums (rest arr))\n        (sub1 (count_digits (first\
    \ arr)))\n        (sub1 (count_digits (rest arr))))]\n    [else              \
    \        (count_nums (rest arr))]))\n", "  (cond [(null? arr) 0]\n        [(<\
    \ 0 (cdr arr))\n         (+ (digit-sum arr) 1)\n         (count_nums (cdr arr))]\n\
    \        [else 0]))\n", "  (count-nums (cdr arr) 0))\n", "  (count_nums-helper\
    \ (if (null? arr) 0\n                        (first arr) arr)))\n", "  (cond\n\
    \    [(empty? arr) 0]\n    [(>= (first arr) 0) 1])\n</code>\nThis solution assumes\
    \ that the integer in the list is guaranteed to be non-negative. Otherwise, you\
    \ should change (first arr) 0 to: (first arr) -(min (first arr) 0)\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 tags=scheme |>\nThis is not a homework question. I am actually\
    \ trying to learn scheme so my question is\n  more theoretical and less practical.\n\
    \nI agree with other answers that this might be homework, but there are some hints\
    \ that you might find helpful.\nFirst of all, here is a way to solve this problem\
    \ without using any built-in Scheme procedures. If you have trouble understanding\
    \ this, try to translate it to Scheme first (since your teacher is teaching you\
    \ Scheme right now).\nSuppose that you're given two lists L and R of n elements.\
    \ Let's also suppose that the two lists are sorted from lowest to highest. Let's\
    \ also suppose that n is greater than zero.\nIf you have a procedure that can\
    \ do what you want if the lists are equal, greater than, and less than respectively,\
    \ then you can write a procedure to compare two lists L and R and return an appropriate\
    \ value for each list comparison. If you need to use a built-in procedure, write\
    \ a procedure that compares two lists.\nLet's call our new list L-R.\nWhen L-R\
    \ is empty, then we have L and R are equal, and L-R is empty. Now let's see what\
    \ happens if L is empty. We've already said that L and R are equal, so L-R will\
    \ also be empty.\nWhen L is empty, we want to compare it to R. Since R is empty,\
    \ we should return 0 (false). Now let's see what happens if R is empty.\nIf R\
    \ is empty and L is not empty, then we return 1. (1)\nIf R is empty and L is empty,\
    \ we should return 0. (0)\nIf R is non-empty and L is not empty, we want to return\
    \ the number of elements in R that are in L. If there are none, then return 0.\
    \ Since L is empty, we should return 1.\nIf R is non-empty and L is empty, we\
    \ want to compare the first element of R to every element of L. If any of those\
    \ elements match then we want to return that number + 1. If none match, then we\
    \ want to return 0.\nSo far we have established that the following work:\n<code>",
  "  (cond\n    [(null? (cdr arr)) 0]\n    [else (+ 1 (count_nums (rest arr)))]))\n",
  "  (cond\n    [(empty? arr) 0]\n    [(= (first arr) (+ 0 ((first arr) mod 10)))\
    \ 1]\n    [else (+ 1 (count_nums (rest arr)))]))\n", "  (cond [(empty? arr) 0]\n\
    \        [(= (length arr) 0) 0]\n        [(= (reverse (modulo (first arr) 10))\
    \ 0) 1]\n        [else (+ 1 (count_nums (rest arr))) ]))\n", "  (cond\n    ((null?\
    \ arr) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) 0)\n    ((or (number? n) (integer? n)) 0)\n    ((or (number? n) (integer?\
    \ n)) ", "  (cond\n    [(empty? arr) 0]\n    [(zero? (car arr)) 1]\n    [else\
    \ (+ (count_nums (cdr arr))\n             (count_nums (/ (car arr) (floor (/ (car\
    \ arr) 10)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
