name: HumanEval_43_pairs_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; pairs_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns #t if there are two distinct elements in the list that\n;; sum to\
  \ zero, and #f otherwise.\n;; >>> (pairs_sum_to_zero (list 1 3 5 0))\n;; #f\n;;\
  \ >>> (pairs_sum_to_zero (list 1 3 -2 1))\n;; #f\n;; >>> (pairs_sum_to_zero (list\
  \ 1 2 3 7))\n;; #f\n;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))\n;; #t\n;; >>>\
  \ (pairs_sum_to_zero (list 1))\n;; #f\n(define (pairs_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 -2 1)) #f)\n    (check-equal? (candidate (list 1 2 3 7)) #f)\n    (check-equal?\
  \ (candidate (list 2 4 -5 3 5 7)) #t)\n    (check-equal? (candidate (list 1)) #f)\n\
  \    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)\n    (check-equal? (candidate\
  \ (list -3 9 -1 3 2 31)) #t)\n    (check-equal? (candidate (list -3 9 -1 4 2 30))\
  \ #f)\n    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((l l)\n             (so_far #f))\n    (cond ((null? l)\
    \ so_far)\n          ((not (pair? l)) so_far)\n          ((equal? (car l) 0)\n\
    \           (loop (cdr l) (not so_far)))\n          ((equal? (car l) (loop (cdr\
    \ l) so_far))\n           (loop (cdr l) (not so_far)))\n          (else\n    \
    \       (loop (cdr l) (or (equal? (+ (car l) so_far) (loop (cdr l) so_far)) so_far))))))\n\
    </code>\n<|/ a tags=scheme,racket,lisp |>\n<| c |>\nThank you for sharing this\
    \ answer! I ended up using the solution in my question since it's more efficient\
    \ and requires less lines of code than the others.\n<|/ c |>\n<| c |>\nYour answer\
    \ is really helpful!\n<|/ c |>\n<| c |>\nWhat is the difference between the two\
    \ solutions given by you and the solution in the accepted answer?\n<|/ c |>\n\
    <| a dscore=4 |>\nThis is simple in Racket.\n<code>", "  (define (helper lst n\
    \ acc)\n    (cond [(empty? lst)\n           acc]\n          [(= (first lst) n)\n\
    \           (helper (rest lst) (first lst) (cons (first lst) acc))]\n        \
    \  [else\n           (helper (rest lst) n (cons (first lst) (cons (first lst)\
    \ acc)))]))\n  (helper l 0 (list #f)))\n", "  (let loop ((sum 0)\n           \
    \  (pairs '()))\n    (if (null? l)\n        #f\n        (let* ((c (car l))\n \
    \              (rest (cdr l)))\n          (if (= c 0)\n              #t\n    \
    \          (if (eqv? sum 0)\n                  (loop (+ sum c)\n             \
    \            (cons c pairs))\n                  (loop sum (cons c pairs)))))))))\n",
  "  (cond [(empty? l)\n         (#f '())]\n        [(equal? (car l) (cadr l))\n \
    \        (#f '())]\n        [else\n         (let [a (car l)\n               b\
    \ (cadr l)\n               c (cadr (cdr l))]\n           (cond [(and (equal? a\
    \ 0) (equal? b 0))\n                   (and (equal? a 1) (equal? b 1))\n     \
    \              (and (equal? a 2) (equal? b 2))]\n                 [(and (equal?\
    \ a 0) (equal? b 1))\n                   (and (equal? a 2) (equal? b 0))\n   \
    \                (and (equal? a 3) (equal? b 1))]\n                 [(and (equal?\
    \ a 0) (equal? b 2))\n                   (and (equal? a 2) (equal? b 0))\n   \
    \                (and (equal? a 3) (equal? b 2))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 0))\n   \
    \                (and (equal? a 3) (equal? b 1))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 1))\n   \
    \                (and (equal? a 3) (equal? b 2))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 2))\n   \
    \                (and (equal? a 3) (equal? b 0))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 1))\n   \
    \                (and (equal? a 3) (equal? b 2))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 2))\n   \
    \                (and (equal? a 3) (equal? b 0))]\n                 [(and (equal?\
    \ a 0) (equal? b 3))\n                   (and (equal? a 2) (equal? b 1))\n   \
    \                (and (equal? a 3) (equal? b 3))]\n                 [(and (equal?\
    \ a 1) (equal? b 0))\n                   (and (equal? a 2) (equal? b 2))\n   \
    \                (and (equal? a 3) (equal? b 0))]\n                 [(and (equal?\
    \ a 1) (equal? b 1))\n                   (and (equal? a 2) (equal? b 0))\n   \
    \                (and (equal? a 3) (equal? b 1))]\n                 [(and (equal? ",
  "  (cond\n    [(null? l) false]\n    [else (and (equal? (cadr l) 0)\n          \
    \     (equal? (caddr l) 0)\n               (equal? (cadddr l) 0))]\n    )\n  )\n",
  "  (cond\n    [(null? l) false]\n    [(pair? (car l)) (pair-sum-to-zero (cdr l))]\n\
    \    [else true]))\n", "  (let ([(first r) (second r)\n         (second (first\
    \ r))]\n        [(first l) (second l)]\n        [(first r) (second l)])\n    (cond\
    \ [(= (first l) (first r))\n          (or (= (second l) 0)\n               (=\
    \ (second r) 0))]\n          [else\n          (and (< (second r) (second l))\n\
    \              (or (= (first r) 0)\n                  (= (first l) 0))\n     \
    \         (or (= (first r) 0)\n                  (= (first l) 0))\n          \
    \    (or (= (first l) 0)\n                  (= (first r) 0))\n              (or\
    \ (= (second r) 0)\n                  (= (second l) 0)))])))\n", "  (cond [(null?\
    \ l) #f]\n        [(zero? (rest l)) #t]\n        [else (cond\n               \
    \  [(null? (rest l)) #f]\n                 [else (or (not (zero? (car l))\n  \
    \                           (not (zero? (rest (cdr l))))\n                   \
    \          (not (equal? (car l) (rest (cdr l)))))\n                         (pairs_sum_to_zero\
    \ (cdr l))]\n                 )])\n  )\n", "  (cond [(empty? l) #f]\n        [(=\
    \ (first l) (second l)) #t]\n        [(zero? (add1 (first l)))\n         (pairs_sum_to_zero\
    \ (rest l))]\n        [else (pairs_sum_to_zero (rest l))]))\n", "  (let loop ((sum\
    \ (car l))\n             (l (cdr l)))\n    (if (null? l)\n        (not (= sum\
    \ 0))\n        (loop (+ sum 0) (cdr l)))))\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Thanks, that's pretty much exactly what I came up with when I was trying to solve\
    \ it.  My issue is I'm looking for a solution using the languages I'm using. \
    \ Sorry if that wasn't clear.\n<|/ c |>\n<| c |>\nHi, I changed my answer to something\
    \ that uses the language you're using. Hope it helps!\n<|/ c |>\n<| c |>\nThanks,\
    \ that works great.  I'm still trying to understand recursion in Racket but it's\
    \ getting better every day.\n<|/ c |>\n<| a dscore=2 |>\nThe first thing you can\
    \ do is turn the numbers into strings so you can just compare them. I'm assuming\
    \ you have a function that can convert integers to strings, so this could be a\
    \ good starting point:\n<code>", "  (and (equal? (car (cdr l)) (car (cdr (cdr\
    \ l)))) #t))\n", "  (cond ((null? l) #f)\n        ((= (length l) 1) #t)\n    \
    \    ((equal? (car l) (cadr l)) (pairs_sum_to_zero (cdr l)))\n        (else (and\
    \ (equal? (+ (car l) (cadr l)) 0)\n                  (pairs_sum_to_zero (cdr l))))))\
    \ ;#lang racket\n", "  (cond\n    ((null? l) #f)\n    ((equal? (first l) 0) #t)\n\
    \    (else\n     (let ((x (first l)))\n       (cond\n        ((equal? (first l)\
    \ x) x)\n        (else (pairs_sum_to_zero (rest l))))))))\n", "  (cond ((null?\
    \ l) #f)\n        ((equal? (first l) (last (rest l)))\n         (if (equal? (first\
    \ (rest l)) 0)\n             (return #t)\n             (return #f)))\n       \
    \ (else (equal? (sum (first l)) (+ (second (first l)) (second (last l))))\n  \
    \            (if (equal? (first (first l)) 0)\n                  (return #t)\n\
    \                  (return #f))))))\n", "  (let loop ((n 0) (x null) (y null)\
    \ (found #f))\n    (cond ((null? l) found)\n          ((null? y) found)\n    \
    \      ((equal? (car l) (add1 x)) found)\n          ((equal? (car y) (car l))\
    \ (loop (add1 n) (cons (car x) y) (cdr l) found))\n          (else (loop (add1\
    \ n) (cons (car x) y) (cdr l) (or (equal? (car l) (add1 x)) found))))))\n", " \
    \ (cond ((empty? l) #f)\n        ((equal? (car l) (cadr l)) #t)\n        (else\
    \ (pairs-sum-to-zero (cdr l)))))\n", "  (cond ((null? l) #f)\n        (else (let\
    \ ((s (sum (cdr l))))\n               (and (not (= s 0))\n                   \
    \ (= (+ (car l) (car l)) s))\n                 (pairs_sum_to_zero (cdr l))))))",
  "  (for/list (([i l])\n             #:repeated\n             ([x i])\n         \
    \    #:unless (= x i))\n    (= x (- i 1))\n    (return #t)))\n", "  (cond\n  \
    \  ((null? l) #f)\n    ((member (car l) (set (cdddr l)) #f)\n     (cond\n    \
    \   ((member (car l) (rest l) #f)\n        (cond\n         ((equal? (car l) 0)\
    \ #t)\n         (#f #f))\n       (#f #t)))\n    (#t #t)))\n", "  (cond [(empty?\
    \ l) #f]\n        [(member (car (first l)) (car (rest l))) #t]\n        [else\
    \ (pairs_sum_to_zero (cdr l))]))\n", "  (or (= 2 (length l)) (null (filter #(>\
    \ 0 (+ (car l) (cdr l))) l))))\n", "  (for/fold ([x #f] [y #f])\n            ([([x\
    \ y] [y x]) #f])\n    (if (equal? (+ (car x) (abs (cdr x))) 0)\n        (equal?\
    \ (+ (car y) (abs (cdr y))) 0)\n        (set! x (cons (car x) (list (abs (cdr\
    \ x)))))\n        (set! y (cons (car y) (list (abs (cdr y)))))\n      )))\n",
  "  (cond ((null? l) #f)\n        ((member (car l) (cadr l)) #f)\n        (else (or\
    \ (pairs_sum_to_zero (cdr l))\n                    (eq (+ (car l) (first l)) 0)))))\n",
  "  (and (equal? (first l) (first l))\n       (equal? (rest l) (second l))))", " \
    \ (or (= (length l) 1)\n      (and (= (apply + l) 0)\n           (null (cdr l)))))\n",
  "  (let ((lst '()))\n    (let loop ((l (car l))\n              (tail (cdr l)))\n\
    \      (if (empty? tail)\n          lst\n          (if (= (+ l tail) (- 0))\n\
    \              (if (empty? lst)\n                  (loop (car l) (cons (car l)\
    \ (cdr lst)))\n                  (loop (car lst) (cons (car l) (cdr lst))))\n\
    \              (loop (car lst) (cons (car l) (cdr lst)))))\n    lst))\n</code>\n\
    <|/ a tags=racket,scheme |>\n<| a |>\n<code>", "  (let ((sum (apply + (map #(-\
    \ % 0) l))))\n    (cond ((= sum 0) #t)\n          (else #f))))\n", "  (cond\n\
    \    ((null? l) #f)\n    ((pair? (car l)) (and (pair? (car l))\n             \
    \           (pairs_sum_to_zero (cdr l))))\n    (else (= (+ (car l) (pairs_sum_to_zero\
    \ (cdr l)))\n             (= (+ (car l) (pair? (cdr l)))\n             (> (car\
    \ l) (pairs_sum_to_zero (cdr l))) #t))))", "  (cond ((null? l) #f)\n        ((null?\
    \ (cdr l)) #t)\n        ((< (car l) (sum (cdr l))) #f)\n        (else (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (cond\n    [(empty? l)\n     (cond\n       [(equal? (first\
    \ l) 0)\n        (eq? (second l) 0)]\n       [else\n        false]])\n    [else\n\
    \     (cond\n       [(equal? (first l) 0)\n        (equal? (second l) 0)]\n  \
    \     [else\n        (cond\n          [(equal? (first l) 0)\n           (equal?\
    \ (second l) 0)]\n          [else\n           (cond\n             [(equal? (first\
    \ l) (first l))\n              (equal? (second l) (second l))\n              (equal?\
    \ (third l) (first l))\n              (equal? (fourth l) (second l))\n       \
    \       (equal? (fifth l) (first l))\n              (equal? (sixth l) (third l))\n\
    \              (equal? (seventh l) (first l))\n              (equal? (eighth l)\
    \ (second l))\n              (equal? (nineth l) (third l))\n              (equal?\
    \ (tenth l) (first l))\n              (equal? (eleventh l) (second l))\n     \
    \         (equal? (twelfth l) (first l))\n              (equal? (thirteenth l)\
    \ (second l))\n              (equal? (fourteenth l) (first l))\n             \
    \ (equal? (fifteenth l) (third l))\n              (equal? (sixteenth l) (first\
    \ l))\n              (equal? (seventeenth l) (second l))\n              (equal?\
    \ (eighteenth l) (first l))\n              (equal? (nineteenth l) (third l))\n\
    \              (equal? (twentieth l) (first l))\n              (equal? (thirtieth\
    \ l) (second l))\n              (equal? (fourtieth l) (first l))\n           \
    \   (equal? (fiftieth l) (third l))\n              (equal? (sixtieth l) (first\
    \ l))\n              (equal? (seventieth l) (second l))\n              (equal?\
    \ (eightieth l) (first l))\n              (equal? (ninetieth l) (third l))\n \
    \             (equal? (twenty l) (first l))\n              (equal? (thirty l)\
    \ (second l))\n              (equal? (forty l) (first l))\n              (equal?\
    \ (fifty l) (second l))\n              (equal? (sixty l) (first l))\n        \
    \      (equal? (se", "  (cond ((null? l) false)\n        ((equal? (car l) (cadr\
    \ l)) false)\n        (else (equal? (car l) (cons (+ 0 (car l)) (cdr l))) \n \
    \              (pairs_sum_to_zero (cdr l)))))\n", "  (if (pair? l)\n      (cond\
    \ (\n             ;; Two distinct elements\n             (let ((a (first l))\n\
    \                  (b (second l)))\n               (and (= a 0) (= b 0))\n   \
    \            (boolean? (sum l))\n               (boolean? (- a b)))\n        \
    \       ;; Two distinct elements and one zero element\n               (let ((a\
    \ (first l))\n                    (b (second l)))\n               (and (= a 0)\
    \ (= b 0))\n               (boolean? (sum l))\n               (boolean? (- a b)))\n\
    \               ;; Two zero elements\n               (boolean? (sum l))\n    \
    \           (boolean? (- 0 (first l)))\n               ;; One zero element\n \
    \              (boolean? (sum l))\n               (boolean? (- 0 (first l)))\n\
    \               (boolean? (- 0 (first l)))\n               (boolean? (- 0 (first\
    \ l))))\n      #f)\n      #t))\n</cell>\n<code language=lambda-notebook>\n#lang\
    \ racket\n", "  (define (helper lst)\n    (define (helper lst acc i)\n      (cond\
    \ [(null? lst) (= i 0) acc]\n            [else (helper (cdr lst) (if (= (+ acc\
    \ (car lst)) 0) (cons (car lst) (cons i (cdr lst))) (car lst)) (+ i 1))]))\n \
    \   (helper lst #f 0))\n  (let ((tmp (list l)))\n    (if (null? tmp) \n      \
    \  #f\n        (let ((x (first tmp)))\n          (helper (rest tmp) (cdr x) (+\
    \ x 1))))))\n", "  (cond\n    [(empty? l) #f]\n    [else (let ([first (car l)]\n\
    \               [rest (cdr l)])\n           (cond\n            [(equal? first\
    \ (car rest)) #t]\n            [else (pairs_sum_to_zero (append rest [first]))]))]))])\n",
  "  (for/fold ([sum #t]\n             [result #f])\n            ([i 0])\n    (if\
    \ (null? l)\n        (cond ((= i 2) sum)\n              (else (set! sum (and (equal?\
    \ (+ i 1) (first l)) sum))))\n        (let ([el (first l)]\n              [next\
    \ (pairs_sum_to_zero (rest l))])\n          (set! i (+ i 1))\n          (cond\
    \ ((equal? el next) result)\n                (else (set! result (and (equal? el\
    \ next) result))))))\n  result)\n", "  (cond\n    [(empty? l) #f]\n    [else\n\
    \     (let [ (curr (first l)) (next (second l))\n           (diff (- curr next))\
    \ (list (first l))]\n       (cond\n         [ (< diff 0)\n           (cond\n \
    \            [(eq? curr (first list))\n              #f]\n             [else #f])]\n\
    \         [else\n          (cond\n            [(empty? (rest list))\n        \
    \      (cond\n                [ (< diff 0)\n                  #t]\n          \
    \      [else #f])]\n            [else\n             (let [ (curr (first list))\
    \ (next (second list)) (diff (- curr next)) ]\n              (cond\n         \
    \       [ (< diff 0)\n                  #t]\n                [else\n         \
    \        (cond\n                   [ (empty? (rest list)) #f ]\n             \
    \      [else\n                    (let*\n                      [ ((curr (first\
    \ list))\n                        (rest (rest list)) (diff (- curr next))]\n \
    \                     (cond\n                        [ (< diff 0)\n          \
    \               #f]\n                        [else\n                         (cond\n\
    \                           [ (empty? (rest list)) #t ]\n                    \
    \       [else\n                            (let*\n                           \
    \   [ ((curr (first list))\n                                (next (second list))\
    \ (diff (- curr next))]\n                              (cond\n               \
    \                 [(< diff 0) #f]\n                                [else\n   \
    \                              (cond\n                                   [(empty?\
    \ (rest list)) #t]\n                                   [else\n               \
    \                     (cond\n                                     [(empty? (rest\
    \ list)) #f]\n                                     [else\n                   \
    \                    (let*\n                                        [ ((curr (first\
    \ list))\n                                          (next (second list)) (diff\
    \ (- curr next))]\n                                       (cond\n            \
    \                            [(< diff 0) #f]\n                               \
    \         [else\n                                         (cond\n            \
    \                               [(empty? (rest list)) #f]\n                  \
    \                         [else\n                                            \
    \ (let*\n                                               [(curr (first list))\n\
    \                                                (rest (rest list))\n        \
    \                                        (diff (- curr next))]\n             \
    \                                 (cond\n                                    \
    \            [(< diff 0) #f]\n                                               \
    \ [else\n                                                 (cond\n            \
    \                                       [(empty? (rest list)) #t]\n          \
    \                                         [else #f])])])])])])])])]))]))]))]))]))]))\n",
  "  (cond\n    [(null? l) #f]\n    [else (cond\n            [(member (car l) (car\
    \ (cdr l)))\n             (pairs_sum_to_zero (cdr l))]\n            [else #t])]))\n",
  "  (cond ((empty? l) #f)\n        ((null (rest l)) #f)\n        (else (> (car (first\
    \ l)) 0)\n              (pairs_sum_to_zero (rest l)))))\n", "  (cond [(empty?\
    \ l) #f]\n        [(member (first l) (second l) #t) #f]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))\n</code>\n<|/ a |>\n<| c |>\nThanks for this. I got an error when\
    \ running it, but it's probably just my coding skills. Here's the error message\
    \ I got `#<procedure <toplevel> ...> is not a procedure`. Any ideas?\n<|/ c |>\n\
    <| c |>\nI got it working; I just had to replace the whole `pairs_sum_to_zero`\
    \ function with the `(define (pairs_sum_to_zero l) (cond [(empty? l) #f] ((member\
    \ (first l) (second l) #t) #f) [(else (pairs_sum_to_zero (rest l)))]))` code,\
    \ and then the `#lang racket` was left out of the code\n<|/ c |>\n<| c |>\nOops!\
    \ The #lang directive was inside the procedure definition, so it was being seen\
    \ as the definition of the procedure itself, not a language specifier. I've now\
    \ edited the answer to include the #lang directive outside of the function definition.\n\
    <|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nHere's an O(n) solution using pairs\
    \ instead of recursion:\n<code>", "  (cond ((null? l)\n         #f)\n        ((null?\
    \ (cdr l))\n         (if (pair? (car l))\n             (eq? (car l) (zero? (car\
    \ l)))\n             (false)))\n        (else\n         (if (< (car l) (pair?\
    \ (cdr l)))\n             (false)\n             (if (> (+ (car l) (pair? (cdr\
    \ l)))\n                   (+ (car l) (pair? (cdr l)))\n                   (-\
    \ (car l) (pair? (cdr l)))))\n             (true)))\n        )))\n", "  (let loop\
    \ ((c l)\n             (sum 0)\n             (pairs #f))\n    (if (null? c)\n\
    \        pairs\n        (loop (cdr c)\n             (if (= (+ sum sum) 0)\n  \
    \               sum\n                 (+ sum (car c)))\n             (if (pairs)\n\
    \                 (cons (list sum (car c)) pairs)\n                 pairs)))))\n",
  "  (cond ((null? l) #f)\n        ((member (+ (car l) (caar l)) l) #t)\n        (else\
    \ (pairs_sum_to_zero (cdr l)))))\n", "  (let helper ((a 0)\n              (b 0)\n\
    \              (c (length l)))\n    (cond ((= c 0)\n           (if (= a b)\n \
    \              #f\n               (if (= a 0)\n                   #f\n       \
    \            (if (= b 0)\n                       #f\n                       (if\
    \ (= a b)\n                           #f\n                           (helper (+\
    \ a b) b (- c 1))))))\n          ((= a 0)\n           (helper (+ b 1) a 0 (- c\
    \ 1)))\n          ((= b 0)\n           (helper (+ a 1) b (- c 1)))\n         \
    \ (else\n           (helper (+ a b) (+ a c) (+ b c))))))\n", "  (cond\n    ((null?\
    \ l)\n     (if (null? (cdr l))\n         (if (> (car l) 0)\n             (cdr\
    \ l)\n             #f\n             )\n         #f\n         )\n    )\n    ((not\
    \ (pair? (car l))) #f)\n    ((pair? (car l))\n     (if (> (car l) 0)\n       \
    \  #f\n         (if (> (cdr l) 0)\n             (cdr l)\n             #f\n   \
    \          )\n         )\n     (pairs_sum_to_zero (cdr l))\n    )\n    ((< 0 (car\
    \ l)) #f)\n    ((< (car l) (first l)) #f)\n    (else #t)\n    )\n  )", "  (if\
    \ (null? l)\n      #f\n      (cond ((equal? (pair? l) '()) (equal? (car (car l))\
    \ 0))\n            (else\n             (equal? (car (car l)) 0)\n            \
    \ (equal? (cdr (car l)) 0)\n             (equal? (cdddr (car l)) 0)\n        \
    \     (equal? (cadddr (car l)) 0)\n             (equal? (cddadddr (car l)) 0)\n\
    \             (equal? (caddadddr (car l)) 0)\n             (equal? (cadddadddr\
    \ (car l)) 0)\n             (equal? (cdddadddr (car l)) 0)\n             (equal?\
    \ (cddddadddr (car l)) 0)\n             (equal? (cddddadddadddr (car l)) 0)\n\
    \             (equal? (cdddddadddadddr (car l)) 0)\n             (equal? (cddddddadddadddr\
    \ (car l)) 0)\n             (equal? (cdddddadddddddr (car l)) 0)\n           \
    \  (equal? (cddddddadddddddr (car l)) 0)\n             (equal? (cdddddddadddddddr\
    \ (car l)) 0)\n             (equal? (cddddddddadddddddr (car l)) 0)\n        \
    \     (equal? (cddddddddddadddddddr (car l)) 0)\n             (equal? (cddddddddddddddadddddddr\
    \ (car l)) 0)\n             (equal? (cddddddddddddddddddadddddddr (car l)) 0)\n\
    \             (equal? (cddddddddddddddddddddddddddadddddddr (car l)) 0)\n    \
    \         (equal? (cddddddddddddddddddddddddddddddadddddddr (car l)) 0)\n    \
    \         (equal? (cddddddddddddddddddddddddddddddddddadddddddr (car l)) 0)\n\
    \             (equal? (cddddddddddddddddddddddddddddddddddddddadddddddr (car l))\
    \ 0)\n             (equal? (cddddddddddddddddddddddddddddddddddddddddddadddddddr\
    \ (car l)) 0)\n             (equal? (cddddddddddddddddddddddddddddddddddddddddddddddadddddddr\
    \ (car l)) 0)\n             (equal? (cddddddddddddddddddddddddddddddddddddddddddddddddddadddddddr\
    \ (car l)) 0)\n             (equal? (cddddddddddddddddddddddddddddddddddddddddddddddddddadddddddr",
  "  (and (equal? (car l) (cadr l))\n       (equal? (caddr l) (pair-sum (cdr l))))))\n",
  "  (let loop ((head (lfirst l)) (tail (rest l)))\n    (if (null? tail)\n       \
    \ (cdr l)\n        (if (null? (cdr tail))\n            (if (= (+ head (car tail))\
    \ 0)\n                #f\n                t)\n            (loop (+ head (car tail))\
    \ (cdr tail))))))\n", "  (cond ((null? l)\n         #f) \n        ((equal? (first\
    \ l) (second l))\n         #f)\n        (else\n         (cond ((equal? (first\
    \ l) 0)\n                 ;; two consecutive elements sum to zero\n          \
    \       (pairs_sum_to_zero (rest l)))\n               (else\n                \
    \ ;; no two consecutive elements sum to zero\n                 (pairs_sum_to_zero\
    \ (rest l)))))))\n", "  (cond [(empty? l) #f]\n        [(cons? l) (let* ([x (car\
    \ l)\n                          y (caar l)]\n                          (cond\n\
    \                            [(= y 0) #t]\n                            [(= x 0)\
    \ #f]\n                            [else (pairs_sum_to_zero l)])))]\n        [else\
    \ #f]))\n", "  (cond [(null? l) #f]\n        [(pair? l)\n         (let ((head\
    \ (car l))\n               (tail (cdr l)))\n           (cond (= head 0)\n    \
    \              (= tail 0)\n                  (pair? tail)\n                  (pairs_sum_to_zero\
    \ (tail)))\n                  [else #f])))]", "  (cond\n    [(empty? l) #f]\n\
    \    [(equal? (first l) (second l)) #t]\n    [else (if (pair? (first l))\n   \
    \             (pairs_sum_to_zero (rest l))\n                (pairs_sum_to_zero\
    \ (cons (first l) (first l))))]))\n", "  (cond [(empty? l) #f]\n        [(equal?\
    \ (first l) 0) #f]\n        [else\n         (equal? (rest (first l)) 0)\n    \
    \     (pairs_sum_to_zero (rest l))]\n        ))\n", "  (cond\n    ((null? l) false)\n\
    \    ((null? (cdr l)) #f)\n    ((> (car l) (pair-sum-to-zero (cdr l)))\n     (pairs_sum_to_zero\
    \ (cdr l)))\n    (else (and (pairs_sum_to_zero (cdr l))\n              (pairs_sum_to_zero\
    \ (cddr l)))))) \n", "  (and (not (null? l))\n       (equal? (apply + l) (apply\
    \ min l))))\n", "  (cond\n    [(null? l) #t]\n    [(null? (cdr l)) #t]\n    [(null?\
    \ (cdr (cdr l))) (= (car l) 0)]\n    [else (and (pair? (car l))\n            \
    \   (= (sum (car l)) 0))\n          (pairs_sum_to_zero (cdr l))]\n  ))\n", " \
    \ (cond\n    [(empty? l) #f]\n    [(equal? (first l) (first (car l)))\n     (cond\n\
    \       [(equal? (second l) (second (car l))) #t]\n       [else (pairs_sum_to_zero\
    \ (rest l))])]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(equal? (first l) 0)\n     (cond\n       [(empty? (rest l)) #t]\n\
    \       [else (pairs_sum_to_zero (rest l))]\n       )])\n    [else\n     (cond\
    \ (equal? (first l) (second l))\n           [else (pairs_sum_to_zero (rest l))]\n\
    \           )])\n    ))\n", "  (cond ((null? l) #f)\n        ((equal? (car l)\
    \ (car (cdr l))) #t)\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (for/fold\
    \ ([(sum 0) (i 0) (l l)] [(sum 1) (i) (l)]) ([(sum c) (i c) (l l)]\n         \
    \      [#t #f (if (> (- c sum) 0) l l)]))\n  i)\n", "  (= (length l) 2)\n  (cond\
    \ (;; both numbers are non-negative\n         (> (car l) (- (car l) (cadr l)))\
    \ #t)\n        (;; both numbers are zero\n         (= (car l) (cadr l)) #t)\n\
    \        (else\n         (cond (;; one number is non-negative\n              \
    \   (> (car l) (- (car l) (cadr l))) #t)\n               (;; one number is zero\n\
    \                 (= (car l) (cadr l)) #f)\n               (else\n           \
    \      ;; both numbers are negative\n                 (= (car l) (caddr l)) #f))))))\n",
  "  (cond\n    [(empty? l) #f]\n    [(null? (cdr l)) #t]\n    [else (let\n      \
    \     ((evens (filter (lambda (elem)\n                               (odd? (first\
    \ elem))\n                               l)))\n            (pairs (filter (lambda\
    \ (elem)\n                             (= (first elem) 0)\n                  \
    \           l)))\n           (even-pairs (filter (lambda (elem)\n            \
    \                      (and\n                                   (even? (first\
    \ elem))\n                                   (not (pair? (rest elem))))\n    \
    \                             evens)))\n           (odd-pairs (filter (lambda\
    \ (elem)\n                                (and\n                             \
    \    (odd? (first elem))\n                                 (not (pair? (rest elem))))\n\
    \                               odds))\n           (even-sums (map car\n     \
    \                       (filter (lambda (elem)\n                             \
    \          (= (+ 0 (first elem)) 0)\n                                       even-pairs))))\n\
    \           (odd-sums (map car\n                            (filter (lambda (elem)\n\
    \                                       (= (+ 0 (first elem)) 0)\n           \
    \                            odd-pairs))))\n           (sums (filter (lambda (elem)\n\
    \                          (= (+ 0 (first elem)) 0)\n                        \
    \  sums))))]\n    [else (let\n           ((evens (filter (lambda (elem)\n    \
    \                           (odd? (first elem))\n                            \
    \   l)))\n            (pairs (filter (lambda (elem)\n                        \
    \     (= (first elem) 0)\n                             l)))\n           (even-pairs\
    \ (filter (lambda (elem)\n                                  (and\n           \
    \                        (even? (first elem))\n                              \
    \     (not (pair? (rest elem))))\n                                 evens)))\n\
    \           (odd-pairs (filter (lambda (elem)\n                              \
    \  (and\n                                 (odd? (first elem))\n              \
    \                   (not (pair? (rest elem))))\n                             \
    \  odds))\n           (even-sums (map car\n                            (filter\
    \ (lambda (elem)\n                                       (= (+ 0 (first elem))\
    \ 0)\n                                       even-pairs))))\n           (odd-sums\
    \ (map car\n                            (filter (lambda (elem)\n             \
    \                          (= (+ 0 (first elem)) 0)\n                        \
    \               odd-pairs))))\n           (sums (filter (lambda (elem)\n     \
    \                     (= (+ 0 (first elem)) 0)\n                          sums))))]\n\
    \    [else (let\n           ((evens (filter (lambda (elem)\n                 \
    \              (odd? (first elem))\n                               l)))\n    \
    \        (pairs (filter (lambda (elem)\n                             (= (", " \
    \ (cond ((null? l) true)\n        ((member (first l) (second l)) (pairs_sum_to_zero\
    \ (rest l)))\n        (else false)))\n", "  (let* ((i 0)\n         (x (car l))\n\
    \         (y (first l))\n         (z (second l))\n         (z1 (second l))\n \
    \        (k (if (> i 2) (add1 i) (add1 i)))\n         (k1 (if (> i 2) (add1 i)\
    \ (add1 i)))\n         (result (if (= x y) 't\n                    (if (< x y)\
    \ #f\n                        (if (> y z) 't\n                            (if\
    \ (< y z) #f\n                                (if (< z z1) 't\n              \
    \                      (if (< z1 z1) 'f))))))\n         (r1 (if (> i 2) (add1\
    \ i) (add1 i)))\n         (r2 (if (> i 2) (add1 i) (add1 i)))\n         (result\
    \ (cond ((> i 2) result)\n                    ((= x y) result)\n             \
    \       ((< x y) result)\n                    ((> y z) result)\n             \
    \       ((< y z) result)\n                    ((< z z1) result)\n            \
    \        ((< z1 z1) result)\n                    (else (cond ((> y z) (if (< y\
    \ z) r1 r2))\n                                 ((> z z1) (if (< z z1) r1 r2))\n\
    \                                 ((> z1 z1) (if (< z1 z1) r1 r2))))))))\n", " \
    \ (let loop ((l l)\n             (accu #f)\n             (current (car l))\n \
    \            (next (cadr l)))\n    (cond\n      ((null? l) (or (null? accu) (null?\
    \ next)))\n      ((= current next)\n       (and (set! accu #t) (set! next (cadr\
    \ l))))\n      (else\n       (loop (cdr l)\n             (+ current accu)\n  \
    \           (+ next accu)\n             (+ current next))))))\n", "  (cond ((null?\
    \ l) #f)\n        ((equal? (first l) (second l))\n         (pairs_sum_to_zero\
    \ (rest l)))\n        (else (eqv? (first l) (second l) true)\n             ((equal?\
    \ (rest l)\n                       (pairs_sum_to_zero (first l)))\n          \
    \     (pairs_sum_to_zero (rest l)))\n             #t)))", "  (for/fold ((pair\
    \ '()) (sum) l)\n           ((pair (x . y) (sum . z)) (cons x (pair (+ sum y)\
    \ z)))\n    (eq? sum (zero? sum))))\n", "  (let ((sum (foldr (lambda (x y)\n \
    \                      (+ x y)) 0 l)))\n    (and (= sum 0)\n         (if (null?\
    \ l)\n             #f\n             (= l '())))\n    ))\n", "  (cond ((null? l)\
    \ '())\n        ((zero? (rest l)) (cons (car l) (cons (car l) (pairs_sum_to_zero\
    \ (cdr l))))))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c |>\nThe question\
    \ didn't specify that there are only negative integers in the list. The problem\
    \ statement only specifies that there are integers in the list that sum to zero.\n\
    <|/ c |>\n<| a |>\nThe obvious way to solve this problem would be to start with\
    \ the first element and recursively check for a solution for each successive element.\
    \  At the end, the last element would either be a solution or it would not.  \n\
    This would not be the best solution if this were to be a problem; however, it\
    \ is the most direct solution.  It would also be an excellent exercise for you\
    \ to write an iterative implementation of this solution.  \nIt will also benefit\
    \ you to write an implementation of Racket in Racket.\n<|/ a tags=racket,scheme\
    \ dscore=1 |>\n<| c |>\nI assume that \"iterative implementation\" means \"recursive\
    \ implementation\". That said, implementing a recursive solution is probably not\
    \ difficult. Writing an iterative solution is also not a bad idea, but the problem\
    \ will require some more thought in terms of how you implement it.\n<|/ c |>\n\
    <| c |>\nYes, I meant \"recursive implementation\".  My first thought was to simply\
    \ use recursion, but this requires that you think about the problem in the right\
    \ way, which is not always the case.  I guess this is where the iterative solution\
    \ would come in.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nHere's a recursive\
    \ implementation with Racket:\n<code>", "  (let ((l1 (length (distinct l))\n \
    \       x2 (filter (lambda (x y) (= (+ x y) (0) ) l l1)))\n        (count (length\
    \ (filter (lambda (x y) (= (+ x y) (0) ) l l1)))))\n    (cond\n      [(= (length\
    \ l1) 1)\n       (= count 2)\n       #t]\n      [else\n       (= count 0)\n  \
    \     #f]\n      )))\n", "  (and (equal? (length l) (length l))\n       (or (null?\
    \ l)\n           (pair? (car l))\n           (= (caar l) 0)\n           (= (cadar\
    \ l) 0))))\n", "  (cond ((null? l) #f)\n        ((null? (cdr l)) #t)\n       \
    \ ((equal (car l) (car (cdr l)))\n         (pairs_sum_to_zero (cdr l))\n     \
    \    (else (pairs_sum_to_zero (cdr l))))))\n", "  (and (= (length l) 2)\n    \
    \   (= (apply + (car l)) 0)\n       (= (apply + (cdr l)) 0)))\n", "  (cond\n \
    \   [(empty? l) #f]\n    [(null? (cdr l)) #t]\n    [else\n     (let ([pair (list\
    \ (car l)\n                      (car l))\n           (result (pairs_sum_to_zero\
    \ (cdr l)))])\n       (cond\n         [(empty? pair) #f]\n         [(= (+ (car\
    \ pair) (car result)) 0)\n          #t]\n         [else\n          (pair (cons\
    \ pair (cons result '())))]))]))\n", "  (cond\n    [(empty? l) #f]\n    [(not\
    \ (pair? (car l)))\n     (and (equal? (car l) (sum (cdr l)))\n          (pairs_sum_to_zero\
    \ (cdr l)))]\n    [else #f]))\n", "  (not (or (null? l)\n            (null? (cdr\
    \ l))\n            (equal? (+ (car l) (pair_sum_to_zero (cdr l))) 0)))) ;; <--\
    \ here\n", "  (not (or (= (length l) (length l)) (not (null? l))))\n  (let ([a\
    \ (list 0)\n        e (list* 0 (car l))])\n    (if (or (null? l)\n           \
    \ (null? (cdr l)))\n        (bool (= (car l) e))\n        (loop for e across (cdr\
    \ l)\n              for i from (if (null? (cdr l)) 0\n                       \
    \     (car e))\n              for b from (if (null? (cdr l)) 0\n             \
    \               (cdr e))\n              collect (cons a (+ b i)))))\n", "  (let\
    \ loop ((lst (reverse l))\n             (sum (reverse (apply + lst))))\n    (if\
    \ (not (null? lst))\n        (if (equal? sum (- 0 sum))\n            (equal? (car\
    \ lst) (cadr lst))\n            (loop (cdr lst) sum))\n        #f)))\n", "  (cond\n\
    \    [(null? l) #f]\n    [(equal? (first l) (first l)) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(equal? (car l) (cadr l))\
    \ #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty? l)\
    \ #f]\n    [(member (first l) l) (pairs_sum_to_zero (rest l))]\n    [else (or\
    \ (pairs_sum_to_zero (rest l)) #t)]))\n", "  (let loop ((l l) (sum #f))\n    (if\
    \ (empty? l) sum\n        (loop (rest l) (if (< sum (first l)) #t (add1 (first\
    \ l)))))))\n", "  (let ((pair (reverse (group-by (lambda (x)\n               \
    \                   (+ (first x) (rest x))\n                                 \
    \ (equal? (first x) (first pair)))\n                               l))\n     \
    \   (pairs (filter (lambda (x y)\n                         (equal? (first pair)\
    \ (first y)))\n                     pair)))\n    (and (equal? (count pairs) 2)\n\
    \         (equal? (count (filter (lambda (x)\n                               \
    \     (equal? (first pair) (first x)))\n                                 pairs))\
    \ 0)\n         (equal? (count pairs) 0)\n         #t)))\n", "  (cond [(null? l)\
    \ #f]\n        [(member (car l) (cdr l)) #t]\n        [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (cond ((null? l) false)\n        ((or (= (first l) 0) (=\
    \ (first l) (second l))) true)\n        (else (pairs_sum_to_zero (rest l))))\n\
    )\n", "  (cond [(null? l) #f]\n        [(cons (- 0 (car l)) (pairs_sum_to_zero\
    \ (cdr l)))]\n        [else #f]))\n", "  (cond [(null? l) #f]\n        [(pair?\
    \ (car l)) (pairs_sum_to_zero (cdr l))]\n        [else (equal? (car (car l)) (car\
    \ (cdr (car l)))) (pairs_sum_to_zero (cdr (car l)))]))\n", "  (cond [(null? l)\
    \ #f]\n        [(null? (cdr l)) #t]\n        [(equal? (car l) (cadr l)) #t]\n\
    \        [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(> (first l) (first l)) #f]\n    [else #t]))\n", "  (let ((s (car l)))\n\
    \    (cond\n      ((null? l) (equal? s (car l)))\n      ((equal? s 0) (equal?\
    \ (car l) s))\n      ((< s 0) (equal? (car l) s))\n      (else (= (= (+ (car l)\
    \ (* s (car l))) 0) (equal? (car l) s))))))\n", "  (let loop ((l l) (sum 0))\n\
    \    (cond\n      [(null? l) #f]\n      [(> (car l) sum) #f]\n      [(equal? (cdr\
    \ l) 0)\n       (cons (list (car l) sum) sum)]\n      [else (loop (cdr l) (+ sum\
    \ (car l)))]\n    ))\n)\n", "  (let ([sum (pairs-sum (car l))])\n    (cond [(equal?\
    \ sum '())\n           #f]\n          [else\n           (equal? (cdr l) sum)\n\
    \           #f]\n          [else (equal? (car (cdr l)) sum)\n           (pairs_sum_to_zero\
    \ (cdr l))])))\n", "  (define (helper l index sum)\n    (cond ((null? l) sum)\n\
    \          ((eqv? (car l) (list-ref l index))\n           (helper (cdr l)\n  \
    \                 (+ index (length l))\n                   (+ sum 1)))\n     \
    \     (else (helper (cdr l)\n                         (+ index (length l))\n \
    \                        (+ sum (car l))))))\n  (if (null? l) (equal? l '()))\n\
    \  (helper (cdr l)\n         0\n         #f))\n", "  (cond [(empty? l) #t]\n \
    \       [(pair? (rest l)) (pairs_sum_to_zero (rest l))]\n        [else #f]))\n",
  "  (cond ((null? l) #f)\n        ((= (first l) 0)\n         (= (second l) 0)\n \
    \        (pairs_sum_to_zero (rest l)))\n        (else (pairs_sum_to_zero (rest\
    \ l)))))\n</cell>\n<text>\n\u0417\u0430\u0434\u0430\u043D\u0438\u0435 #6\n\u041F\
    \u043E\u0441\u0447\u0438\u0442\u0430\u0439\u0442\u0435 \u0432\u0435\u0440\u043E\
    \u044F\u0442\u043D\u043E\u0441\u0442\u044C, \u043A\u043E\u0433\u0434\u0430 \u0432\
    \u044B \u0434\u0435\u043B\u0430\u0435\u0442\u0435 \u0441\u043B\u0443\u0447\u0430\
    \u0439\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442 \u0437\u043D\
    \u0430\u0447\u0435\u043D\u0438\u044F \u043F\u0435\u0440\u0432\u043E\u0433\u043E\
    \ \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0430 \u0438\u0437 \u043D\u0430\
    \u0448\u0435\u0439 \u0441\u043F\u0438\u0441\u043A\u0438 \u0440\u0430\u0441\u043F\
    \u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0439 \u0438\u0437 \u043F\u043B\
    \u043E\u0441\u043A\u0438\u0445 \u0434\u0432\u0443\u0445 \u043F\u0430\u0440\u0430\
    \u043C\u0435\u0442\u0440\u043E\u0432. \u0420\u0435\u0448\u0438\u0442\u0435 \u043F\
    \u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0443 \u0437\u0430\u0434\u0430\u043D\
    \u0438\u044F \u0441\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439\
    \ \u0437\u0430\u0434\u0430\u0447\u0435\u0439 \u0432 \u043F\u0440\u043E\u0448\u043B\
    \u044B\u0445 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F\u0445\
    . \u041D\u0435 \u0437\u0430\u0431\u0443\u0434\u044C\u0442\u0435 \u0441\u0432\u044F\
    \u0437\u0430\u0442\u044C\u0441\u044F \u0441 \u0442\u0435\u043C, \u0447\u0442\u043E\
    \ \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0430 \u0434\u043E\u043B\u0436\
    \u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0441\u043B\
    \u0435\u0434\u0443\u044E\u0449\u0438\u0439 \u043F\u0430\u0440\u0430\u043C\u0435\
    \u0442\u0440 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F \u043F\u0435\u0440\
    \u0432\u043E\u0433\u043E \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0430\
    \ \u0438 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0438\u0439 \u043F\u0430\u0440\
    \u0430\u043C\u0435\u0442\u0440 \u0438\u0437 \u043D\u0430\u0448\u0435\u0439 \u0441\
    \u043F\u0438\u0441\u043A\u0438 \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\
    \u043B\u0435\u043D\u0438\u0439.\n\n\n</text>\n<cell>\n#lang racket\n", "  (cond\
    \ [(null? l) #f]\n        [(pair? (rest l)) (and (equal? (+ (first l) (first lst))\
    \ 0)\n                            (pairs_sum_to_zero (rest lst)))]\n        [else\
    \ #f]))\n", "  (let loop ((lst (sort l)) (sum 0))\n    (cond\n      [(empty? lst)\
    \ empty]\n      [(zero? (car lst)) (if (zero? sum) true (== sum 0))]\n      [(equal?\
    \ (car lst) (cadr lst)) (loop (cdr lst) (+ sum 0))]\n      [(equal? (car lst)\
    \ (caddr lst)) (loop (cdr lst) (+ sum (car lst)))]\n      [else (loop (cdr lst)\
    \ (+ sum (car lst)))])))\n", "  (let loop ((a (car l))\n             (b (cadr\
    \ l))\n             (found #f))\n    (cond\n      ((null? l) found)\n      ((equal?\
    \ (+ a b) 0)\n       (set! found #t) a)\n      (else\n       (loop (+ a b) b (equal?\
    \ (+ a b) 0)))))) \n", "  (and (= (length l) 2)\n       (= (length (filter (lambda\
    \ (i) (= i 0)) (map car l))) 1)))\n", "  (if (empty? l)\n      #f\n      (let\
    \ ((x (first l))\n            (y (second l)))\n        (and (= x 0)\n        \
    \     (= y 0)\n             (= x y)\n             (if (< (abs (- x y)) 2)\n  \
    \               #t\n                 #f)\n             (= (+ (first l) (second\
    \ l)) 0)\n             (= (+ (first l) (second l)) 0)\n             (= (+ (first\
    \ l) (second l)) 0)\n             (= (+ (first l) (second l)) 0)\n           \
    \  (= (+ (first l) (second l)) 0)\n             (= (+ (first l) (second l)) 0)))))\n",
  "  (let ([h (make-hash-table)]))\n    (let loop ((t l) (acc #f))\n      (if (null?\
    \ t)\n          acc\n          (let ([el (car t)]\n                (old-val (gethash\
    \ el h)))\n            (set! acc (not (or (eq? old-val) acc)))\n            (loop\
    \ (cdr t) acc))))))\n", "  (< (length l) (length l)))\n", "  (if (null? l) '#t\n\
    \      (and (null? (rest l))\n           (not (= (car l) 0))\n           (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (and\n   (empty? l)\n   (every\n    (lambda (x)\n     (=\
    \ 0 (+ (first l) x))\n     (second l)))))\n", "  (cond\n    ((null? l) #f)\n \
    \   ((equal? (rest l) 0) #t)\n    (else (and (equal? (first l) (rest l)) (pairs_sum_to_zero\
    \ (rest l)))))\n  )\n)\n", "  (and (> l (length l)) (= (sum (map (lambda (e) (*\
    \ e e)) l)) 0)))\n", "  (cond\n    ((null? l) #f)\n    ((null? (cdr l)) #t)\n\
    \    ((equal? (car l) (cadr l)) (pairs_sum_to_zero (cdr l)))\n    (else (and (equal?\
    \ (car l) (add1 (cadr l))))\n           (pairs_sum_to_zero (cdr l)))))\n", " \
    \ (let loop ((a (first l)) (lst (rest l)))\n    (if (null? lst)\n        #f\n\
    \        (if (= (+ a (car lst)) 0)\n            #t\n            (loop (car lst)\n\
    \                   (rest lst)))))) \n</code>\nI wanted to see if I could do this\
    \ without recursion, but I couldn't find anything that didn't use recursion. The\
    \ problem is actually much simpler than it seems at first glance; I only need\
    \ to find two distinct elements (by index) that sum to zero.\n<|/ q dscore=2 tags=scheme,racket\
    \ |>\n<| c |>\nAre you looking for just pairs or all elements in the list?\n<|/\
    \ c |>\n<| c |>\nI'm looking for two distinct elements that sum to zero. I'll\
    \ edit the question to clarify!\n<|/ c |>\n<| c |>\nI assume that all elements\
    \ are distinct, as there is no such thing as \"distinct elements\". I think you\
    \ might be overthinking the problem.\n<|/ c |>\n<| c |>\nYou're right. I should've\
    \ clarified, sorry. I'm looking for two distinct elements that sum to zero.\n\
    <|/ c |>\n<| c |>\nJust a note: It's probably better to use a `letrec` form for\
    \ this kind of problem. Though it looks like a nice challenge, it's not necessarily\
    \ the most efficient solution.\n<|/ c |>\n<| a dscore=3 |>\nThe first thing I\
    \ notice is that the two recursive cases are nearly identical. Instead of writing\
    \ an explicit loop, it's much cleaner to take advantage of \"higher order functions\"\
    . For example, the following function generates pairs (cons el1 lst) and (cons\
    \ el2 lst) where el1 and el2 are the two elements in the list and lst is the remaining\
    \ list after the pair is generated:\n<code>", "  (for/fold ((acc #f) (action #()))\n\
    \            (elt (first l))\n            (iter (rest l))\n    (cond\n      [(<\
    \ elt 0) (iter iter)]\n      [(= acc #f) (bool (not acc))]\n      [(= elt 0) (bool\
    \ (not acc))]\n      [(< elt acc)\n       (begin (set! acc #f))\n       (begin\
    \ (set! elt 0))\n       (begin (set! action (lambda () (set! acc #f))))\n    \
    \   (begin (set! action (lambda () (set! elt 0)))\n               (set! action\
    \ (lambda () (set! acc #t))))]\n      [else (begin (set! action (lambda () (set!\
    \ acc #f))\n                            (set! elt elt))\n                 (set!\
    \ action (lambda () (set! elt 0)))\n                 (set! action (lambda () (set!\
    \ acc #t))))]\n    ))))\n", "  (pair? (append l (list (- (first l) (sum (rest\
    \ l)))))))\n", "  (cond\n    [(empty? l) #f]\n    [else (cond [(equal? (first\
    \ l) 0)\n                  (equal? (first l) (second l))]\n                 [else\
    \ #f])]))\n", "  (and (empty? l)\n       (empty? (first l)))\n  (equal? (car l)\n\
    \          (car (pair-filter l (lambda (x)\n                                 (equal?\
    \ (+ (car l) x) 0))\n                            (lambda (x)\n               \
    \                  (equal? (+ (cdr l) x) 0))))\n          :key (lambda (x)\n \
    \                (equal? (+ (car l) x) 0))\n          :except-key (lambda (x)\n\
    \                         (equal? (+ (cdr l) x) 0)))\n  )\n", "  (cond\n    [(empty?\
    \ l)\n     #f]\n    [else\n     (equal? (sum (take l l)) 0)\n     #f]\n   ))\n",
  "  (and (= (length (sort l)) 2)\n       (eq (+ (car l) (cadr l)) 0)))\n  ", "  (let\
    \ ((found '()))\n    (for/sum ((item (first l))\n              (sum (rest l)))\n\
    \      (if (pair? item)\n          (if (pair? found)\n              (eq? (+ (car\
    \ item) (car found))\n                    (+ sum (cdr item) (cdr found)))\n  \
    \            (begin (set! found (cons item found))\n                     (set!\
    \ found (cons (- sum (car item)) found)))\n          (begin (set! found (cons\
    \ (- sum (car item)) found))\n                 (set! found (cons sum (cdr found)))))))\n\
    \  found)\n", "  (and (not (null? l))\n       ((memq (+ (car l) (cadr l)) (cddr\
    \ l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l)\
    \ (cadr l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq\
    \ (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n\
    \        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr\
    \ l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (-\
    \ (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n\
    \        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr\
    \ l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (-\
    \ (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n\
    \        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr\
    \ l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (-\
    \ (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n\
    \        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (- (car l) (cadr\
    \ l)) (cddr l))\n        (memq (- (car l) (cadr l)) (cddr l))\n        (memq (-\
    \ (car l) (cadr l)) (cddr l))\n        (mem", "  (let loop ((pairs l) (s 0))\n\
    \    (if (null? pairs)\n        #f\n        (let ((k (car pairs))\n          \
    \    (t (loop (cdr pairs) (+ s k))))\n          (if (= t 0)\n              #t\n\
    \              (if (= t 1) \n                  #t\n                  (if (= t\
    \ 2)\n                      #t\n                      (if (= t 3)\n          \
    \                #t\n                          (if (= t 4)\n                 \
    \             #t\n                              (if (= t 5)\n                \
    \                  #t\n                                  (if (= t 6)\n       \
    \                               #t\n                                      #f)))))))))))\n",
  "  (let loop ((l l) (accum #f) (curr-key #f))\n    (if (null? l)\n        (or accum\n\
    \             (not (= curr-key #t)))\n        (loop (cdr l) (or (= curr-key #t)\
    \ accum)\n              (car l))))\n", "  (cond\n    [(empty? l) false]\n    [else\
    \ (equal? (reduce + (cdr l)) (reduce + (car l)))]))\n", "  (pairs-sum-to-zero\
    \ (list->vector l)))\n", "  (let loop ([n 0])\n    (cond ((null? l)\n        \
    \   (eqv? n 0))\n          ((eq? (car l) 0)\n           (loop (cdr l) (1+ n)))\n\
    \          (else\n           (loop (cdr l)\n                 (+ (car l)\n    \
    \                (loop (cdr l) (1+ n)))))))\n", "  (let ((pairs-list (partition\
    \ (lambda (x y) (= (+ x y) 0)) l)))\n    (if (empty? pairs-list)\n      #f\n \
    \     (cond (<???> #t)\n            #f))))\n", "  (let ([a (length l)\n      \
    \  sum (foldl addr 0 (reverse l))])\n    (= sum 0)))\n", "  (let ((ts (map pair\
    \ (filter (lambda (x) (equal? (+ (car x) (cdr x)) 0)) (cons l '())))))\n    (and\n\
    \     (null? ts)\n     (null? (cdr ts)))))\n", "  (cond ((null? l) #f)\n     \
    \   ((equal? (first l) (second l))\n         (eqv? l (rest l))\n         (pairs_sum_to_zero\
    \ (rest l))\n         (else #f)))\n</code>\n<|/ a tags=scheme,racket,functional-programming\
    \ |>\n<| c |>\nThis was a great answer, thanks. I did have one more question though:\
    \ How would I change this code to only sum integers (not doubles or even negatives)?\n\
    <|/ c |>\n<| c |>\nThis doesn't work. The first pair you get is (#f #t), when\
    \ it should return #t (since the list has two distinct elements that sum to 0).\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I'm working on the answer now.\n\
    <|/ c |>\n<| c |>\nI edited the code a bit to fix a bug in the handling of the\
    \ list containing only one element. If you have any more questions just ask.\n\
    <|/ c |>\n<| a dscore=2 |>\nI believe that in addition to answers here, that you\
    \ may find this solution useful:\n<code>", "  (cond\n    ((null? l) #f)\n    ((eq?\
    \ (car (car l)) (car (cdr (cdr l))) #f) #f)\n    ((eq? (car l) (car (cdr (cdr\
    \ l))) #f) #t)\n    (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond\n    [(null?\
    \ l) #f]\n    [else (let ([elem (car l)])\n               (cond\n            \
    \     [(= 0 (+ (car l) (caar l)))\n                   (cond\n                \
    \     [(= elem (cadr l)) #f]\n                     [(= elem (caddr l)) #f]\n \
    \                    [else (let ([rest (cdr l)])\n                           \
    \   (cond\n                                [(empty? rest) #f]\n              \
    \                  [(= elem (cadr rest)) #f]\n                               \
    \ [(= elem (caddr rest)) #f]\n                                [(= elem (car rest))\
    \ #f]\n                                [(= elem (cadr rest)) #f]\n           \
    \                     [(= elem (caddr rest)) #f]\n                           \
    \     [else (let ([new_elem (car rest)])\n                                   \
    \     (cond\n                                          [(= new_elem elem) #f]\n\
    \                                          [else (let ([new_rest (cdr rest)])\n\
    \                                                  (cond\n                   \
    \                                 [(empty? new_rest) #f]\n                   \
    \                                 [(= new_elem (cadr new_rest)) #f]\n        \
    \                                            [(= new_elem (caddr new_rest)) #f]\n\
    \                                                    [(= new_elem (car new_rest))\
    \ #f]\n                                                    [(= new_elem (cadr\
    \ new_rest)) #f]\n                                                    [(= new_elem\
    \ (caddr new_rest)) #f]\n                                                    [else\
    \ (let ([new_elem (car new_rest)])\n                                         \
    \                   (cond\n                                                  \
    \            [(= new_elem elem) #f]\n                                        \
    \                      [else (let ([new_rest (cdr new_rest)])\n              \
    \                                                  (cond\n                   \
    \                                               [(empty? new_rest) #f]\n     \
    \                                                             [(= new_elem (cadr\
    \ new_rest)) #f]\n                                                           \
    \       [(= new_elem (caddr new_rest)) #f]\n                                 \
    \                                 [(= new_elem (car new_rest)) #f]\n         \
    \                                                         [(= new_elem (cadr new_rest))\
    \ #f]\n                                                                  [(= new_elem\
    \ (caddr new_rest)) #f]\n                                                    \
    \              [else (let ([new_elem (car new_rest)])\n                      \
    \                                                       (cond\n              \
    \                                                                 [(= new_elem\
    \ elem) #f]\n                                                                \
    \               [else (pairs_sum_to_zero (cons new_elem new_rest))]))]))]))]))]))]))]))])))))))\n",
  "  (cond\n    [(empty? l) #f]\n    [(pair? (car l)) (or (lists_equal? (car l) (list\
    \ 0)) #f)]\n    [else (or (lists_equal? (cdr l) (list 0)) #f)]))\n", "  (cond\
    \ ((null? l) #f)\n        ((equal? (car l) (cadr l)) #f)\n        (else (equal?\
    \ (car (rest l)) (cadr (rest l))) (pairs_sum_to_zero (cdr l)))))\n", "  (< (length\
    \ l) (length l) (sum (filter (lambda (x) x) (remove-duplicates l))))\n  )\n",
  "  (cond ((null? l)\n         #f)\n        ((null? (cdr l))\n         (if (= (+\
    \ (car l) (car l))\n                  0)\n             #t\n             #f))\n\
    \        (else\n         (if (= (+ (car l) (cadr l))\n                  0)\n \
    \            #t\n             #f))))\n", "  (cond\n    [(null? l) #f]\n    [(pair?\
    \ l) (equal? (+ l (car l)) 0) (pairs_sum_to_zero l)]\n    [else #t]))\n", "  (cond\
    \ ((empty? l) #f)\n        ((member #f (remove-duplicates l))\n         (member\
    \ #f (remove-duplicates reverse-remove-duplicates l)))\n        (else (equal?\
    \ (reduce (lambda (x y) \n                             (if (= 0 (+ x y)) (cons\
    \ x y)\n                             (cons y x))\n                          l)\
    \ \n                       (list #f #t)) #t)\n  )\n)\n", "  (if (empty? l)\n \
    \     #f\n      (if (= (first l) (second l))\n          #t\n          (pairs_sum_to_zero\
    \ (rest l)))))\n</cell>\n<cell>\n#lang racket\n", "  (let loop ((x 0) (y 0))\n\
    \    (if (< (length l) (* 2 x))\n        (cond ((= (+ x y) (+ 0 0))\n        \
    \       (return #f))\n              ((= (+ x y) 0)\n               (return #t))\n\
    \              ((< y 0)\n               (loop (+ x 1) (+ y 1))\n             \
    \  (loop (+ x 1) y))\n              (else\n               (loop (+ x 1) y)))))\n",
  "  (cond ((null? l) #f)\n        ((zero? (car l)) #t)\n        (else (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (cond [(null? l) #f]\n        [(null? (cdr l)) #f]\n    \
    \    [(= ((car l) (caar l)) 0)\n         (cons (car l) (pairs_sum_to_zero (cdr\
    \ l)))]\n        [else (cons (car l)\n                    (pairs_sum_to_zero (cdr\
    \ l)))]))\n", "  (let loop ((l l)\n             (a #f)\n             (t #f))\n\
    \    (cond ((null? l)\n           (if (or (= a #f)\n                  (= a t))\
    \ #t #f))\n          ((= (first l) (first a))\n           (loop (rest l)\n   \
    \              (+ a (first l))\n                 (if t (loop (rest l) a #t) #f)))\n\
    \          (else\n           (loop (rest l)\n                 (+ a first (first\
    \ l))\n                 t))))))\n", "  (let ((a #f)\n        (b #f))\n    (if\
    \ (null? l)\n        (a b)\n        (let ((i (car l)))\n          (if (null? l)\n\
    \              (a b)\n              (let* ((j (car l))\n                     (p\
    \ (car l)))\n                (cond ((= (- i j) 0)\n                       (if\
    \ (> j 0)\n                           (a b)\n                           (b a))\n\
    \                       ((= i j)\n                         (if (= p 0)\n     \
    \                        (a b)\n                             (b a))\n        \
    \               ((> j 0)\n                         (let ((r (if (= i j) (+ i (+\
    \ j j)) 0)))\n                           (if (> r j)\n                       \
    \        (a b)\n                               (b a))\n                      \
    \     ((> r 0)\n                           (let ((r (if (= i j) (- i (- j j))\
    \ 0)))\n                             (if (> r j)\n                           \
    \      (a b)\n                                 (b a))))\n                    \
    \   ((< j 0)\n                         (let ((r (if (= i j) (+ i (- j j)) 0)))\n\
    \                           (if (> r j)\n                               (a b)\n\
    \                               (b a))\n                           ((< r 0)\n\
    \                           (let ((r (if (= i j) (- i (+ j j)) 0)))\n        \
    \                     (if (< r j)\n                                 (a b)\n  \
    \                               (b a))\n                             ((< r 0)\n\
    \                             (let ((r (if (= i j) (- i (- j j)) 0)))\n      \
    \                       (if (< r j)\n                                 (a b)\n\
    \                                 (b a))))))))))))))))\n", "  (let loop ((lst\
    \ l) (sum 0))\n    (cond ((null? lst) sum)\n          ((eq? (car lst) (cadr lst))\
    \ (loop (cdr lst) (+ sum 1)))\n          (else (loop (cdr lst) (+ sum 0))))))\n\
    </code>\nThe program is fairly simple. Let S(i) be the sum of all integers from\
    \ 0 to i. Then if the list consists of pairs (a,b), then we have:\n<code>\nS(0)=0\n\
    S(1)=a+b\nS(2)=aS(1)+bS(0)\nS(3)=aS(1) + bS(1)+bS(0)\nS(4)=aS(2)+bS(1) + bS(0)\n\
    S(5)=aS(2)+bS(1)+bS(1)+bS(0)\nS(6)=aS(3) + bS(2) + bS(1)+bS(0)\nS(7)=aS(3) + bS(2)\
    \ + bS(1)+bS(1)+bS(0)\nS(8)=aS(4) + bS(3) + bS(2) + bS(1)+bS(0)\nS(9)=aS(4) +\
    \ bS(3) + bS(2) + bS(1)+bS(1)+bS(0)\nS(10)=aS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(0)\n\
    S(11)=aS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(1)+bS(0)\nS(12)=aS(6) + bS(5) +\
    \ bS(4) + bS(3) + bS(2) + bS(1)+bS(0)\nS(13)=aS(6) + bS(5) + bS(4) + bS(3) + bS(2)\
    \ + bS(1)+bS(1)+bS(0)\nS(14)=aS(7) + bS(6) + bS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(0)\n\
    S(15)=aS(7) + bS(6) + bS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(1)+bS(0)\nS(16)=aS(8)\
    \ + bS(7) + bS(6) + bS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(0)\nS(17)=aS(8) +\
    \ bS(7) + bS(6) + bS(5) + bS(4) + bS(3) + bS(2) + bS(1)+bS(1)+b", "  (cond\n \
    \   [(empty? l) empty]\n    [(member (head l) (rest (tail l))) t]\n    [else f]))\n",
  "  (cond [(null? l)\n         #f]\n        [(member (car l) (rest (cdr l)))\n  \
    \       (if (equal? (+ (car l) (rest (cdr l)))\n                    0)\n     \
    \      #f\n           (pairs_sum_to_zero (cdr l)))]\n        [else\n         (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (define (helper lst accum i)\n    (cond ((null? lst)\n  \
    \         accum )\n          ((eqv? (car lst) i)\n           (helper (cdr lst)\n\
    \                  (if (null? accum)\n                      (cdr accum )\n   \
    \                   (cons (car accum)\n                             (helper (cdr\
    \ accum) (cdr accum) i))))))\n  (helper (reverse l) '() 0))\n", "  (cond\n   \
    \ [(empty? l) #f]\n    [(equal? (first l) 0) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]\n    ))\n", "  (cond\n    [(empty? l) #f]\n    [else (eqv? (car l)\
    \ (car (cdr l))) (pairs_sum_to_zero (cdr l))]\n    [else #f]))\n", "  (< (reduce\
    \ +\n             (map (lambda (x) (+ (first x) x) (next x)))\n             (reverse\
    \ l))\n      0))\n", "  (cond\n    [(empty? l) #f]\n    [(member (first l) (second\
    \ l)) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (let loop ((l l) (res\
    \ #f))\n    (cond ((null? l)\n           (cond ((eqv? res (car l)) res)\n    \
    \              (else (set! res (car l)) res)))\n          ((not (pair? l))\n \
    \          (cond ((eqv? res (car l)) res)\n                  (else (set! res (car\
    \ l)) res)))\n          (else\n           (loop (cdr l) (let ((sndl (cdr l)))\
    \ (if (pair? (car l))\n                                                  (if (eqv?\
    \ (caar l) sndl) (loop (cddr l) #t) (loop (cdddr l) #f))\n                   \
    \                               (loop (cdr l) #t)))))))", "  (cond [(null? l)\
    \ #f]\n        [(equal? (first l) (first l)) #t]\n        [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond ((null? l) #f)\n        ((> (car l) 0) #t)\n     \
    \   (else (pairs_sum_to_zero (cdr l)))))\n", "  (let loop ((l l) (sum 0))\n  \
    \  (cond\n      [(empty? l) false]\n      [(equal? (car l) sum) (loop (cdr l)\
    \ (+ sum 0))]\n      [(equal? (car l) (cadr l)) (loop (cdr l) (+ sum (cadr l)))]\n\
    \      [else (loop (cdr l) (+ sum (car l)))])))\n", "  (if (null? l)\n      (null)\n\
    \      (let ((x (car l))\n            (y (pair? x))\n            (z (if (= y '())\n\
    \                   (car l)\n                   (let ((x (car y))\n          \
    \              (y2 (pair? x))\n                        (z2 (if (= y2 '())\n  \
    \                             (car y)\n                               (let ((x\
    \ (car y2))\n                                    (y3 (pair? x))\n            \
    \                        (z3 (if (= y3 '())\n                                \
    \          (car y2)\n                                          (let ((x (car y3))\n\
    \                                                (y4 (pair? x))\n            \
    \                                    (z4 (if (= y4 '())\n                    \
    \                                  (car y3)\n                                \
    \                      (let ((x (car y4))\n                                  \
    \                          (y5 (pair? x))\n                                  \
    \                          (z5 (if (= y5 '())\n                              \
    \                                   (car y4)\n                               \
    \                                  (let ((x (car y5))\n                      \
    \                                  (y6 (pair? x))\n                          \
    \                              (z6 (if (= y6 '())\n                          \
    \                                    (car y5)\n                              \
    \                                (let ((x (car y6))\n                        \
    \                                            (y7 (pair? x))\n                \
    \                                                    (z7 (if (= y7 '())\n    \
    \                                                                         (car\
    \ y6)\n                                                                      \
    \       (let ((x (car y7))\n                                                 \
    \                       (y8 (pair? x))\n                                     \
    \                                   (z8 (if (= y8 '())\n                     \
    \                                                             (car y7)\n     \
    \                                                                            \
    \ (let ((x (car y8))\n                                                       \
    \                   (y9 (pair? x))\n                                         \
    \                                 (z9 (if (= y9 '())\n                       \
    \                                                         (car y8)\n         \
    \                                                                       (let ((x\
    \ (car y9))\n                                                        (y10 (pair?\
    \ x))\n                                                        (z10 (if (= y10\
    \ '())\n                                                                     \
    \  (car y9)\n                                                                \
    \       (let ((x (car y10))\n                                                \
    \                    (y11 (pair? x))\n                                       \
    \                             (z11 (if (= y11 '())\n                         \
    \                                                 (car y10)\n                \
    \                                                          (let ((x (car y11))\n\
    \                                                                            \
    \    (y12 (pair? x))\n                                                       \
    \                         (z12 (if (= y12 '())\n                             \
    \                                                       (car y11)\n          \
    \                                                                          (let\
    \ ((x (car y12))\n                                                           \
    \               (y13 (pair? x))\n                                            \
    \                              (z13 (if (= y13 '())\n                        \
    \                                                          (car y12)\n       \
    \                                                                           (let\
    \ ((x (car y13))\n                                                           \
    \             (y14 (pair", "  (cond\n    [(empty? l) #f]\n    [(not (pair? l))\
    \ #f]\n    [(pair? (rest l)) (cons (first l) (pairs_sum_to_zero (rest l)))]\n\
    \    [else (pairs_sum_to_zero (first l))]\n    ))\n", "  (cond\n    ((null? l)\
    \ false)\n    ((equal? (car l) (cadr l)) (equal? (car (cdr l)) 0))\n    (else\n\
    \     (equal? (car (car l)) (car (cdr (car l))))\n     (equal? (car (car l)) (cadr\
    \ (car l))))\n    (else\n     (equal? (car (car l)) (car (cdr (car l))))\n   \
    \  (equal? (car (car l)) (cadr (cdr (car l))))\n     (equal? (car (car l)) (pairs_sum_to_zero\
    \ (cdr l))))))\n", "  (equal? (list (car l) (car (cdr l))) (append (list (list\
    \ (car l) (car (cdr l))))\n                                                 (list\
    \ (list (car l) (car (cdr l)))) )))\n", "  (cond [(null? l)\n         #f]\n  \
    \      [(or (= (+ (first l) (second l)) 0)\n             (= (+ (first l) (second\
    \ l))\n               (second l))\n             #t)\n         #t]\n        [else\n\
    \         (let ((pair (list (first l) (second l))))\n           (cond\n      \
    \       [(null? (rest l))\n              #f]\n             [(= (+ (first pair)\
    \ (second pair)) 0)\n              #t]\n             [else\n               (let\
    \ ((car (first pair))\n                     (cdr (second pair)))\n           \
    \      (cond\n                   [(null? (rest l))\n                    #f]\n\
    \                   [(= (+ car cdr) 0)\n                    #t]\n            \
    \       [else\n                    (let ((next (pairs_sum_to_zero (rest l))))\n\
    \                      (cond\n                        [(null? next)\n        \
    \                 #f]\n                        [else\n                       \
    \  (cons pair (cons (first pair)\n                                        next))\n\
    \                         #t]))]]))]))\n", "  (let ([x (first l)\n         y (second\
    \ l)])\n    (cond\n      [(and (null? x) (null? y)) #t]\n      [(null? x) y]\n\
    \      [(null? y) x]\n      [else (equal? (+ x y) 0)])))\n", "  (pairs-sum-to-zero\
    \ (cdr l) (car l)))\n", "  (let ((a (reverse l))\n        (b (cdr a)))\n    (or\
    \ (null? b)\n        (equal? (car a) (car b))\n        (equal? (car b) 0)))))\n",
  "  (cond [(null? l) #f]\n        [(equal? (first l) 0)\n         (cond [(null? (rest\
    \ l)) #f]\n               [else #f]\n               )]\n        [else\n      \
    \   (cond [(equal? (rest l) 0)\n                #t]\n               [else (pairs_sum_to_zero\
    \ (rest l))])]))\n", "  (cond\n    [(empty? l) #f]\n    [(equal? (rest l) 0) #t]\n\
    \    [(pair? (rest l))\n     (cond\n       [(equal? (first l) (first (rest l)))\n\
    \        #f]\n       [(equal? (first l) 0)\n        #f]\n       [else #t])]\n\
    \    [else #f]))\n", "  (cond [(null? l) #f]\n        [(null? (cdr l)) #f]\n \
    \       [(equal? (car (car l)) (car (cdr l))) #f]\n        [else (pairs_sum_to_zero\
    \ (cdr l))]\n))\n", "  (if (null? l)\n      (exact? 0)\n      (let ((sum (+ 0\
    \ (car l))) (second (car l)))\n        (cond ((eq? second sum) \n            \
    \   (eq? (car l) (cons sum (cdr l)))\n               (pair? l) \n            \
    \   (pairs_sum_to_zero (cdr l))\n               (else #f))))))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(not (even? (first l))) #f]\n    [else (let ([s (+\
    \ (first l) (second l))]\n              [t (pairs_sum_to_zero (rest l))])\n  \
    \      (or (and (= s 0) #t) (and (= t 0) #t))]))))\n", "  (cond ((null? l) true)\n\
    \        ((> (car (car l)) (car (cdr l)))\n         (if (> (car (car l)) 0)\n\
    \             (if (< (car (cdr l)) 0)\n                 (pairs_sum_to_zero (cdr\
    \ l))\n                 (not (pairs_sum_to_zero (cdr l))))\n             (pairs_sum_to_zero\
    \ (cdr l))))\n        (else (pairs_sum_to_zero (cdr l)))))\n", "  (cond\n    ((null?\
    \ l) #f)\n    ((null? (cdr l)) #t)\n    ((= (+ (car l) (cadr l)) 0) #f)\n    (else\
    \ (pairs_sum_to_zero (cdr l)))))\n", "  (cond [(null? l) #f]\n        [(equal?\
    \ (car l) (filter (lambda (x) (= x 0)) (cdr l))) #t]\n        [else (pairs_sum_to_zero\
    \ (cdr l))]))\n", "  (cond\n    [(empty? l) false]\n    [(equal? (first l) (first\
    \ (rest l))) false]\n    [else (= (sum (first l)) 0) (pairs_sum_to_zero (rest\
    \ l))]\n  ))\n", "  (for/list ((i l) (j l))\n    (let ((sum (+ i j)))\n      (when\
    \ (> sum 0)\n        (return-from pairs_sum_to_zero\n          (and (equal? i\
    \ j) (equal? i sum)))))\n    (return-from pairs_sum_to_zero #f)))\n</cell>\n<cell>\n\
    %%html\n<img src='http://rosettacode.org/wiki/Partial_sum#R5R2'>\n</cell>\n<cell>\n\
    #lang racket\n", "  (cond [(null? l) #f]\n        [(equal? (car l) (cadr l)) #t]\n\
    \        [else (pairs_sum_to_zero (cdr l))]))\n", "  (cond [(empty? l) #f]\n \
    \       [(pair? (car l))\n         (or (pair? (car l)) (pairs_sum_to_zero (cdr\
    \ l)))]\n        [else #t]))\n", "  (cond ((null? l) #f)\n        ((equal? (first\
    \ l) (first (rest l)))\n         (equal? (first l) (rest (rest l)))\n        \
    \ (equal? (first l) (rest (rest (rest l))))\n        ((equal? (first (first l))\
    \ (first (rest (first l))))\n         (equal? (first (first l)) (rest (first (rest\
    \ (first l))))\n         (equal? (first (first l)) (rest (rest (first (rest (first\
    \ l)))))\n         (equal? (first (first l)) (rest (rest (rest (first (rest (first\
    \ l)))))\n         (equal? (first (first l)) (rest (rest (rest (rest (first (rest\
    \ (first l)))))\n         (equal? (first (first l)) (rest (rest (rest (rest (rest\
    \ (first (rest (first l)))))\n         (equal? (first (first l)) (rest (rest (rest\
    \ (rest (rest (rest (first (rest (first l)))))\n         (equal? (first (first\
    \ l)) (rest (rest (rest (rest (rest (rest (first (rest (first l)))))\n       \
    \  (equal? (first (first l)) (rest (rest (rest (rest (rest (rest (rest (rest (rest\
    \ (rest (first (rest (first l)))))\n         (equal? (first (first l)) (rest (rest\
    \ (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (first (rest\
    \ l)))))\n         (equal? (first (first l)) (rest (rest (rest (rest (rest (rest\
    \ (rest (rest (rest (rest (rest (rest (rest (rest (first (rest l)))))\n      \
    \   (equal? (first (first l)) (rest (rest (rest (rest (rest (rest (rest (rest\
    \ (rest (rest (rest (rest (rest (rest (rest (first (rest l)))))\n         (equal?\
    \ (first (first l)) (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest\
    \ (rest (rest (rest (rest (rest (first (rest l)))))\n         (equal? (first (first\
    \ l)) (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest (rest\
    \ (first (rest l)))))\n         (equal? (first (first l)) ", "  (for/fold ([pairs\
    \ '()])\n            ([sum #t])\n            (for/list ((x l) (e (in-order l)))\n\
    \              (if (pair? pairs)\n                  (if (= (+ (car x) (caar pairs))\n\
    \                      (+ (cadr x) (cadar pairs))\n                      (pairs))\n\
    \                  (cons (list x (car pairs))\n                        (pairs\
    \ (+ (car x) (cadr pairs)))))))\n  sum)\n", "  (cond [(or (null? l) (null? (cdr\
    \ l)))\n         #f]\n        [(equal? (car l) (cadr l))\n         (not (pairs_sum_to_zero\
    \ (cdr l)))]\n        [else\n         (let ([found (member -car l)])\n       \
    \    (if (= 1 (length found))\n             (not (pairs_sum_to_zero (cdr l)))\n\
    \             (equal? found (pairs_sum_to_zero (cdr l))))]))\n", "  (define (helper\
    \ l index sum)\n    (cond ((null? l) (= sum #t))\n          ((eq? l (car l)) (helper\
    \ (cdr l)\n                                       (+ index (car l))\n        \
    \                               (+ sum car l)))\n          (else (helper (cdr\
    \ l) index sum))))\n  (helper l 0 0))\n", "  (and (= (length l) 2)\n       (<\
    \ (car l) (cadr l))\n       (= (+ (car l) (cadr l)) 0)))", "  (and\n   (equal?\
    \ (apply + l) 0)\n   (or (null? l)\n       (equal? (car l) (cadr l)))))\n", " \
    \ (cond\n    [(empty? l) #f]\n    [(not (pair? (first l))) #f]\n    [(eq? (second\
    \ l) 0) #f]\n    [(pair? (first l))\n     (cond\n       [(> (second l) (first\
    \ l)) #f]\n       [(not (> (second l) (first l))) #t]\n       [else #f]])\n  \
    \   #t]\n    [else #f]))\n", "  (cond ((null? l) '())\n        ((pair? (car l))\n\
    \         (and (pairs_sum_to_zero (cdr l))\n               (= 0 (+ (car l) (caar\
    \ l))))\n        )\n        ((= 0 (+ (car l) (caar l)))\n         (#t (pairs_sum_to_zero\
    \ (cdr l))))\n        (else (pairs_sum_to_zero (cdr l))))\n)\n", "  (let ([pairs-1\
    \ (remove-duplicates l)]\n        [pairs  (remove-duplicates pairs-1)]\n     \
    \   [zeroes (remove-duplicates pairs-1 #f #f)]\n        [result #f])\n    (cond\
    \ [(empty? pairs-1) #f]\n          [(pairs-2 zeroes pairs #f #t) result]\n   \
    \       [(pairs-2 pairs zeroes #f #t) (pairs_sum_to_zero (remove #f zeroes))]\n\
    \          [(pairs-2 pairs zeroes #t #f) (pairs_sum_to_zero (remove #t zeroes))]\n\
    \          [(pairs-2 pairs zeroes #f #f) result]\n          [else #f])))\n", " \
    \ (let loop ((lst '())\n             (accum 0))\n    (cond [(null? lst)\n    \
    \       (not (pair? lst))\n           (return '#f)]\n          [(member (car lst)\
    \ lst)\n           (loop (cdr lst) accum)]\n          [else\n           (loop\
    \ (cons (car lst) lst)\n                 (+ (car lst) accum))]))\n", "  (define\
    \ (helper lst acc)\n    (cond [(empty? lst)\n           acc]\n          [(zero?\
    \ (first lst))\n           (helper (rest lst) acc)]\n          [else\n       \
    \    (helper (rest lst)\n                  (cons (first lst)\n               \
    \         acc))]\n          ))\n  (helper l '()))\n", "  (let ((pairs '()))\n\
    \    (cond ((null? l) (pairs))\n          ((null? (cdr l)) (if (null? (cdr pairs))\
    \ #t #f))\n          (else (let* ((x (car l))\n                       (y (cadr\
    \ l))\n                       (xy (car pairs))\n                       (yy (cadr\
    \ pairs))\n                       (xy (+ x xy))\n                       (yy (+\
    \ y yy))\n                       (pairs (cons x y xy yy)))\n                 \
    \   (cons (cons x y) pairs)))))\n", "  (let helper ((sum '()) (l l))\n    (cond\
    \ [(empty? l)\n           (equal? (first l) (first sum))\n           (equal? (first\
    \ sum) 0)]\n          [(equal? (first l) (car sum))\n           (helper (cdr sum)\
    \ (remove (car l) sum))]\n          [else\n           (let ([x (first l)]\n  \
    \                ([y (first sum)])\n                  (new-sum (cons x y)))\n\
    \             (cond\n              [(empty? new-sum)\n               (helper (cons\
    \ x (rest sum))\n                      (remove x sum))]\n              [else\n\
    \               (helper (cons x new-sum)\n                      (remove x (rest\
    \ new-sum))])])]))\n", "  (cond\n    ((empty? l) #f)\n    ((not (pair? (car l)))\
    \ (equal? (car l) 0))\n    (else (equal? (car l) (sum (cdr l))) (pairs_sum_to_zero\
    \ (cdr l)))))\n", "  (for/fold ([tf #f] [(t #f)] [t #f])\n            [x xs]\n\
    \    (cond\n      [(empty? xs) (set! t (equal? x 0))]\n      [(equal? (car xs)\
    \ (apply + tf (cons (car xs) t)))]\n      [(equal? t (apply + tf (cons xs (cdr\
    \ ts))))]\n      [else (set! t (equal? x 0))]))))", "  (let loop ((pairs '())\n\
    \             (current (first l)))\n    (cond\n      [(null? l) true]\n      [(null?\
    \ (rest l)) (= current (first pairs))]\n      [(= current (first pairs)) (loop\
    \ pairs (first l))]\n      [else (loop (cons (first pairs) pairs) (first l))]))\n\
    \  false)\n", "  (cond [(null? l) #f]\n        [(= (first l) (second l)) #t]\n\
    \        [else (pairs_sum_to_zero (rest l))]))\n", "  (cond [(empty? l) #f]\n\
    \        [else (or (= (last l) 0) (equal? (last l) (sum l)))]\n  )\n)\n", "  (or\
    \ (null? l)\n      (= 2 (length l))\n      (equal? (first l) (second l))\n   \
    \   (or (equal? (first l) (second (first l)))\n          (equal? (second l) (second\
    \ (first l)))\n          (equal? (first l) (second (second l))))))\n", "  (let\
    \ ((sum (reduce (lambda (x y) (+ x y)) 0)))\n    (cond\n      [(empty? l) false]\n\
    \      [else (= (- sum l) 0) #t]\n    )\n  )\n)\n", "  (cond\n    ((null? l) false)\n\
    \    ((member (first l) l) false)\n    ((member (second l) l) (pairs_sum_to_zero\
    \ (rest l)))\n    (else (and (pairs_sum_to_zero (rest l)) (pairs_sum_to_zero (first\
    \ l)))\n        )\n    )\n  )\n)\n", "  (cond ((null? l) #f)\n        ((not (pair?\
    \ (car l)))\n         (if (> (+ (car l) (first l)) 0)\n             (if (> (+\
    \ (car l) (first l)) 0)\n                 #t\n                 #f))))\n      \
    \  ((pair? (car l)) (if (> (+ (car l) (first l)) 0)\n                        \
    \      (if (> (+ (car l) (first l)) 0)\n                                  (if\
    \ (> (+ (car l) (first l)) 0)\n                                      (if (> (+\
    \ (car l) (first l)) 0)\n                                          (if (> (+ (car\
    \ l) (first l)) 0)\n                                              (if (> (+ (car\
    \ l) (first l)) 0)\n                                                  #t\n   \
    \                                               #f))))\n                     \
    \             (if (> (+ (car l) (first l)) 0)\n                              \
    \        #t\n                                      #f))))\n                  \
    \    #f)))\n</code>\n<code>\n#lang racket\n", "  (let loop ([acc #f])\n    (if\
    \ (null? l)\n        acc\n        (loop (let ([x (car l)]\n                  [y\
    \ (second l)])\n              (if (= (+ x y) 0)\n                  (begin\n  \
    \                  (set! acc (not acc))\n                    (if (not acc)\n \
    \                       acc\n                        (loop (cdr l)))))))))\n",
  "  (if (null? l)\n      #f\n      (let ((x (car l)))\n        (if (or (= 0 (mod\
    \ x 2))\n                (cdr l))\n            #t\n            (or (pairs_sum_to_zero\
    \ (cdr l))\n                (pairs_sum_to_zero (cdr l)))))\n      ))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [else (let ([pair (first l)])\n            (let ([next\
    \ (first l)])\n              (if (pair-sum-to-zero? pair next)\n             \
    \     #f\n                  (or (pair-sum-to-zero? pair next) (pairs_sum_to_zero\
    \ (rest l))))]))]))\n", "  (let loop ((lst l) (acc #t))\n    (cond ((null? lst)\
    \ acc)\n          ((not (pair? lst)) acc)\n          ((null? (cdr lst)) acc)\n\
    \          (else\n           (loop (cdr lst)\n                  (and (not (pair?\
    \ (car lst)))\n                       (not (equal? (+ (car lst) (cadr lst))\n\
    \                                   (car acc)))))))\n</code>\n<|/ a tags=scheme\
    \ |>\n<| a tags=scheme |>\nA more efficient way to solve this problem would be\
    \ to use SRFI-45's for/fold instead of recursion. The following will return the\
    \ smallest pair of values that sum to zero:\n<code>", "  (cond\n    [(null? l)\
    \ #f]\n    [else\n     (let ([head (first l)\n            tail (rest l)\n    \
    \        tail-sum (apply + tail)])\n       (cond [(= tail-sum 0) #f]\n       \
    \      [else (and (= head tail-sum) (pairs_sum_to_zero tail))]))]))\n", "  (cond\
    \ ((null? l) #f)\n        (else (let ((x (car l))\n                     (y (if\
    \ (equal? y 0) x y)))\n               (if (< x y)\n                   (cons (list\
    \ x y)\n                         (pairs_sum_to_zero (cdr l)))\n              \
    \     (cons (list x y)\n                         (pairs_sum_to_zero (cdr l)))))\n\
    \          )))\n", "  (cond\n    [(empty? l) #t]\n    [(pair? l)\n     (let* ([l0\
    \ (first l) (l1 (rest l))]\n             [r (pairs_sum_to_zero l1)]\n        \
    \     [t (boolean-equal? (+ l0 l1) 0)])\n       #(cond\n          [(boolean? t)\
    \ #t]\n          [(equal? t #f) #f]))]\n    [(number? l) (number= (first l) 0)]\n\
    \    [(boolean? l) #f]\n    [else #f]))\n", "  (if (null? l)\n      #f\n     \
    \ (cond\n        ((equal? (add1 (cadr (car l))) 0)\n         (equal? (cadr (car\
    \ l)) 0))\n        (else (equal? (add1 (cadr (car l))) (add1 (cadr (car l)))))\n\
    \        (else #f))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
